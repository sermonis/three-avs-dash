function dash_initPathPlannerWorker(){(()=>{var __webpack_modules__={243:module=>{eval('module.exports = "Math.clamp = (number, min, max) => Math.max(min, Math.min(number, max));\\r\\n\\r\\nMath.wrapAngle = (angle) => {\\r\\n  angle = angle % (Math.PI * 2);\\r\\n  if (angle <= -Math.PI) return angle + Math.PI * 2;\\r\\n  else if (angle > Math.PI) return angle - Math.PI * 2;\\r\\n  else return angle;\\r\\n}\\r\\n\\r\\nTHREE.Vector2.fromAngle = (angle) => new THREE.Vector2(Math.cos(angle), Math.sin(angle));\\r\\n\\r\\nTHREE.Curve.prototype.getCurvatureAt = function(u) {\\r\\n  let t2 = this.getUtoTmapping(u);\\r\\n\\r\\n  const delta = 0.0001;\\r\\n  let t1 = t2 - delta;\\r\\n  let t3 = t2 + delta;\\r\\n\\r\\n  if (t1 < 0) {\\r\\n    t1 = 0;\\r\\n    t2 = delta;\\r\\n    t3 = 2 * delta;\\r\\n  }\\r\\n\\r\\n  if (t3 > 1) {\\r\\n    t3 = 1;\\r\\n    t2 = 1 - delta;\\r\\n    t1 = 1 - 2 * delta;\\r\\n  }\\r\\n\\r\\n  const p1 = this.getPoint(t1);\\r\\n  const p2 = this.getPoint(t2);\\r\\n  const p3 = this.getPoint(t3);\\r\\n\\r\\n  return (Math.atan2(p3.y - p2.y, p3.x - p2.x) - Math.atan2(p2.y - p1.y, p2.x - p1.x)) / p2.distanceTo(p1);\\r\\n};\\r\\n"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aHJlZS1hdnMtZGFzaC8uL2pzL1V0aWxzLmpzPzEyNjIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsMEZBQTBGLHFDQUFxQyxvQ0FBb0Msd0RBQXdELDJEQUEyRCx3QkFBd0IsS0FBSyxpR0FBaUcsNERBQTRELHNDQUFzQywrQkFBK0IsMEJBQTBCLDBCQUEwQix1QkFBdUIsZUFBZSxtQkFBbUIsdUJBQXVCLE9BQU8sdUJBQXVCLGVBQWUsdUJBQXVCLDJCQUEyQixPQUFPLHVDQUF1QyxtQ0FBbUMsbUNBQW1DLG1IQUFtSCxNQUFNIiwiZmlsZSI6IjI0My5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCJNYXRoLmNsYW1wID0gKG51bWJlciwgbWluLCBtYXgpID0+IE1hdGgubWF4KG1pbiwgTWF0aC5taW4obnVtYmVyLCBtYXgpKTtcXHJcXG5cXHJcXG5NYXRoLndyYXBBbmdsZSA9IChhbmdsZSkgPT4ge1xcclxcbiAgYW5nbGUgPSBhbmdsZSAlIChNYXRoLlBJICogMik7XFxyXFxuICBpZiAoYW5nbGUgPD0gLU1hdGguUEkpIHJldHVybiBhbmdsZSArIE1hdGguUEkgKiAyO1xcclxcbiAgZWxzZSBpZiAoYW5nbGUgPiBNYXRoLlBJKSByZXR1cm4gYW5nbGUgLSBNYXRoLlBJICogMjtcXHJcXG4gIGVsc2UgcmV0dXJuIGFuZ2xlO1xcclxcbn1cXHJcXG5cXHJcXG5USFJFRS5WZWN0b3IyLmZyb21BbmdsZSA9IChhbmdsZSkgPT4gbmV3IFRIUkVFLlZlY3RvcjIoTWF0aC5jb3MoYW5nbGUpLCBNYXRoLnNpbihhbmdsZSkpO1xcclxcblxcclxcblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRDdXJ2YXR1cmVBdCA9IGZ1bmN0aW9uKHUpIHtcXHJcXG4gIGxldCB0MiA9IHRoaXMuZ2V0VXRvVG1hcHBpbmcodSk7XFxyXFxuXFxyXFxuICBjb25zdCBkZWx0YSA9IDAuMDAwMTtcXHJcXG4gIGxldCB0MSA9IHQyIC0gZGVsdGE7XFxyXFxuICBsZXQgdDMgPSB0MiArIGRlbHRhO1xcclxcblxcclxcbiAgaWYgKHQxIDwgMCkge1xcclxcbiAgICB0MSA9IDA7XFxyXFxuICAgIHQyID0gZGVsdGE7XFxyXFxuICAgIHQzID0gMiAqIGRlbHRhO1xcclxcbiAgfVxcclxcblxcclxcbiAgaWYgKHQzID4gMSkge1xcclxcbiAgICB0MyA9IDE7XFxyXFxuICAgIHQyID0gMSAtIGRlbHRhO1xcclxcbiAgICB0MSA9IDEgLSAyICogZGVsdGE7XFxyXFxuICB9XFxyXFxuXFxyXFxuICBjb25zdCBwMSA9IHRoaXMuZ2V0UG9pbnQodDEpO1xcclxcbiAgY29uc3QgcDIgPSB0aGlzLmdldFBvaW50KHQyKTtcXHJcXG4gIGNvbnN0IHAzID0gdGhpcy5nZXRQb2ludCh0Myk7XFxyXFxuXFxyXFxuICByZXR1cm4gKE1hdGguYXRhbjIocDMueSAtIHAyLnksIHAzLnggLSBwMi54KSAtIE1hdGguYXRhbjIocDIueSAtIHAxLnksIHAyLnggLSBwMS54KSkgLyBwMi5kaXN0YW5jZVRvKHAxKTtcXHJcXG59O1xcclxcblwiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///243\n')},931:module=>{eval("module.exports = \"(function (global, factory) {\\r\\n\\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\\r\\n\\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\\r\\n\\t(factory((global.THREE = {})));\\r\\n}(this, (function (exports) { 'use strict';\\r\\n\\r\\n\\t// Polyfills\\r\\n\\r\\n\\tif ( Number.EPSILON === undefined ) {\\r\\n\\r\\n\\t\\tNumber.EPSILON = Math.pow( 2, - 52 );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tif ( Number.isInteger === undefined ) {\\r\\n\\r\\n\\t\\t// Missing in IE\\r\\n\\t\\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\\r\\n\\r\\n\\t\\tNumber.isInteger = function ( value ) {\\r\\n\\r\\n\\t\\t\\treturn typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tif ( Math.sign === undefined ) {\\r\\n\\r\\n\\t\\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\\r\\n\\r\\n\\t\\tMath.sign = function ( x ) {\\r\\n\\r\\n\\t\\t\\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tif ( 'name' in Function.prototype === false ) {\\r\\n\\r\\n\\t\\t// Missing in IE\\r\\n\\t\\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\\r\\n\\r\\n\\t\\tObject.defineProperty( Function.prototype, 'name', {\\r\\n\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\treturn this.toString().match( /^\\\\s*function\\\\s*([^\\\\(\\\\s]*)/ )[ 1 ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tif ( Object.assign === undefined ) {\\r\\n\\r\\n\\t\\t// Missing in IE\\r\\n\\t\\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\\r\\n\\r\\n\\t\\t( function () {\\r\\n\\r\\n\\t\\t\\tObject.assign = function ( target ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( target === undefined || target === null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthrow new TypeError( 'Cannot convert undefined or null to object' );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tvar output = Object( target );\\r\\n\\r\\n\\t\\t\\t\\tfor ( var index = 1; index < arguments.length; index ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar source = arguments[ index ];\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( source !== undefined && source !== null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var nextKey in source ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\toutput[ nextKey ] = source[ nextKey ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn output;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t} )();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * https://github.com/mrdoob/eventdispatcher.js/\\r\\n\\t */\\r\\n\\r\\n\\tfunction EventDispatcher() {}\\r\\n\\r\\n\\tObject.assign( EventDispatcher.prototype, {\\r\\n\\r\\n\\t\\taddEventListener: function ( type, listener ) {\\r\\n\\r\\n\\t\\t\\tif ( this._listeners === undefined ) this._listeners = {};\\r\\n\\r\\n\\t\\t\\tvar listeners = this._listeners;\\r\\n\\r\\n\\t\\t\\tif ( listeners[ type ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tlisteners[ type ] = [];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\\r\\n\\r\\n\\t\\t\\t\\tlisteners[ type ].push( listener );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\thasEventListener: function ( type, listener ) {\\r\\n\\r\\n\\t\\t\\tif ( this._listeners === undefined ) return false;\\r\\n\\r\\n\\t\\t\\tvar listeners = this._listeners;\\r\\n\\r\\n\\t\\t\\treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tremoveEventListener: function ( type, listener ) {\\r\\n\\r\\n\\t\\t\\tif ( this._listeners === undefined ) return;\\r\\n\\r\\n\\t\\t\\tvar listeners = this._listeners;\\r\\n\\t\\t\\tvar listenerArray = listeners[ type ];\\r\\n\\r\\n\\t\\t\\tif ( listenerArray !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tvar index = listenerArray.indexOf( listener );\\r\\n\\r\\n\\t\\t\\t\\tif ( index !== - 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tlistenerArray.splice( index, 1 );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdispatchEvent: function ( event ) {\\r\\n\\r\\n\\t\\t\\tif ( this._listeners === undefined ) return;\\r\\n\\r\\n\\t\\t\\tvar listeners = this._listeners;\\r\\n\\t\\t\\tvar listenerArray = listeners[ event.type ];\\r\\n\\r\\n\\t\\t\\tif ( listenerArray !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tevent.target = this;\\r\\n\\r\\n\\t\\t\\t\\tvar array = listenerArray.slice( 0 );\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tarray[ i ].call( this, event );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tvar REVISION = '89';\\r\\n\\tvar MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\\r\\n\\tvar CullFaceNone = 0;\\r\\n\\tvar CullFaceBack = 1;\\r\\n\\tvar CullFaceFront = 2;\\r\\n\\tvar CullFaceFrontBack = 3;\\r\\n\\tvar FrontFaceDirectionCW = 0;\\r\\n\\tvar FrontFaceDirectionCCW = 1;\\r\\n\\tvar BasicShadowMap = 0;\\r\\n\\tvar PCFShadowMap = 1;\\r\\n\\tvar PCFSoftShadowMap = 2;\\r\\n\\tvar FrontSide = 0;\\r\\n\\tvar BackSide = 1;\\r\\n\\tvar DoubleSide = 2;\\r\\n\\tvar FlatShading = 1;\\r\\n\\tvar SmoothShading = 2;\\r\\n\\tvar NoColors = 0;\\r\\n\\tvar FaceColors = 1;\\r\\n\\tvar VertexColors = 2;\\r\\n\\tvar NoBlending = 0;\\r\\n\\tvar NormalBlending = 1;\\r\\n\\tvar AdditiveBlending = 2;\\r\\n\\tvar SubtractiveBlending = 3;\\r\\n\\tvar MultiplyBlending = 4;\\r\\n\\tvar CustomBlending = 5;\\r\\n\\tvar AddEquation = 100;\\r\\n\\tvar SubtractEquation = 101;\\r\\n\\tvar ReverseSubtractEquation = 102;\\r\\n\\tvar MinEquation = 103;\\r\\n\\tvar MaxEquation = 104;\\r\\n\\tvar ZeroFactor = 200;\\r\\n\\tvar OneFactor = 201;\\r\\n\\tvar SrcColorFactor = 202;\\r\\n\\tvar OneMinusSrcColorFactor = 203;\\r\\n\\tvar SrcAlphaFactor = 204;\\r\\n\\tvar OneMinusSrcAlphaFactor = 205;\\r\\n\\tvar DstAlphaFactor = 206;\\r\\n\\tvar OneMinusDstAlphaFactor = 207;\\r\\n\\tvar DstColorFactor = 208;\\r\\n\\tvar OneMinusDstColorFactor = 209;\\r\\n\\tvar SrcAlphaSaturateFactor = 210;\\r\\n\\tvar NeverDepth = 0;\\r\\n\\tvar AlwaysDepth = 1;\\r\\n\\tvar LessDepth = 2;\\r\\n\\tvar LessEqualDepth = 3;\\r\\n\\tvar EqualDepth = 4;\\r\\n\\tvar GreaterEqualDepth = 5;\\r\\n\\tvar GreaterDepth = 6;\\r\\n\\tvar NotEqualDepth = 7;\\r\\n\\tvar MultiplyOperation = 0;\\r\\n\\tvar MixOperation = 1;\\r\\n\\tvar AddOperation = 2;\\r\\n\\tvar NoToneMapping = 0;\\r\\n\\tvar LinearToneMapping = 1;\\r\\n\\tvar ReinhardToneMapping = 2;\\r\\n\\tvar Uncharted2ToneMapping = 3;\\r\\n\\tvar CineonToneMapping = 4;\\r\\n\\tvar UVMapping = 300;\\r\\n\\tvar CubeReflectionMapping = 301;\\r\\n\\tvar CubeRefractionMapping = 302;\\r\\n\\tvar EquirectangularReflectionMapping = 303;\\r\\n\\tvar EquirectangularRefractionMapping = 304;\\r\\n\\tvar SphericalReflectionMapping = 305;\\r\\n\\tvar CubeUVReflectionMapping = 306;\\r\\n\\tvar CubeUVRefractionMapping = 307;\\r\\n\\tvar RepeatWrapping = 1000;\\r\\n\\tvar ClampToEdgeWrapping = 1001;\\r\\n\\tvar MirroredRepeatWrapping = 1002;\\r\\n\\tvar NearestFilter = 1003;\\r\\n\\tvar NearestMipMapNearestFilter = 1004;\\r\\n\\tvar NearestMipMapLinearFilter = 1005;\\r\\n\\tvar LinearFilter = 1006;\\r\\n\\tvar LinearMipMapNearestFilter = 1007;\\r\\n\\tvar LinearMipMapLinearFilter = 1008;\\r\\n\\tvar UnsignedByteType = 1009;\\r\\n\\tvar ByteType = 1010;\\r\\n\\tvar ShortType = 1011;\\r\\n\\tvar UnsignedShortType = 1012;\\r\\n\\tvar IntType = 1013;\\r\\n\\tvar UnsignedIntType = 1014;\\r\\n\\tvar FloatType = 1015;\\r\\n\\tvar HalfFloatType = 1016;\\r\\n\\tvar UnsignedShort4444Type = 1017;\\r\\n\\tvar UnsignedShort5551Type = 1018;\\r\\n\\tvar UnsignedShort565Type = 1019;\\r\\n\\tvar UnsignedInt248Type = 1020;\\r\\n\\tvar AlphaFormat = 1021;\\r\\n\\tvar RGBFormat = 1022;\\r\\n\\tvar RGBAFormat = 1023;\\r\\n\\tvar LuminanceFormat = 1024;\\r\\n\\tvar LuminanceAlphaFormat = 1025;\\r\\n\\tvar RGBEFormat = RGBAFormat;\\r\\n\\tvar DepthFormat = 1026;\\r\\n\\tvar DepthStencilFormat = 1027;\\r\\n\\tvar RGB_S3TC_DXT1_Format = 2001;\\r\\n\\tvar RGBA_S3TC_DXT1_Format = 2002;\\r\\n\\tvar RGBA_S3TC_DXT3_Format = 2003;\\r\\n\\tvar RGBA_S3TC_DXT5_Format = 2004;\\r\\n\\tvar RGB_PVRTC_4BPPV1_Format = 2100;\\r\\n\\tvar RGB_PVRTC_2BPPV1_Format = 2101;\\r\\n\\tvar RGBA_PVRTC_4BPPV1_Format = 2102;\\r\\n\\tvar RGBA_PVRTC_2BPPV1_Format = 2103;\\r\\n\\tvar RGB_ETC1_Format = 2151;\\r\\n\\tvar LoopOnce = 2200;\\r\\n\\tvar LoopRepeat = 2201;\\r\\n\\tvar LoopPingPong = 2202;\\r\\n\\tvar InterpolateDiscrete = 2300;\\r\\n\\tvar InterpolateLinear = 2301;\\r\\n\\tvar InterpolateSmooth = 2302;\\r\\n\\tvar ZeroCurvatureEnding = 2400;\\r\\n\\tvar ZeroSlopeEnding = 2401;\\r\\n\\tvar WrapAroundEnding = 2402;\\r\\n\\tvar TrianglesDrawMode = 0;\\r\\n\\tvar TriangleStripDrawMode = 1;\\r\\n\\tvar TriangleFanDrawMode = 2;\\r\\n\\tvar LinearEncoding = 3000;\\r\\n\\tvar sRGBEncoding = 3001;\\r\\n\\tvar GammaEncoding = 3007;\\r\\n\\tvar RGBEEncoding = 3002;\\r\\n\\tvar LogLuvEncoding = 3003;\\r\\n\\tvar RGBM7Encoding = 3004;\\r\\n\\tvar RGBM16Encoding = 3005;\\r\\n\\tvar RGBDEncoding = 3006;\\r\\n\\tvar BasicDepthPacking = 3200;\\r\\n\\tvar RGBADepthPacking = 3201;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tvar _Math = {\\r\\n\\r\\n\\t\\tDEG2RAD: Math.PI / 180,\\r\\n\\t\\tRAD2DEG: 180 / Math.PI,\\r\\n\\r\\n\\t\\tgenerateUUID: ( function () {\\r\\n\\r\\n\\t\\t\\t// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\\r\\n\\r\\n\\t\\t\\tvar lut = [];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < 256; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tlut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 ).toUpperCase();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn function () {\\r\\n\\r\\n\\t\\t\\t\\tvar d0 = Math.random() * 0xffffffff | 0;\\r\\n\\t\\t\\t\\tvar d1 = Math.random() * 0xffffffff | 0;\\r\\n\\t\\t\\t\\tvar d2 = Math.random() * 0xffffffff | 0;\\r\\n\\t\\t\\t\\tvar d3 = Math.random() * 0xffffffff | 0;\\r\\n\\t\\t\\t\\treturn lut[ d0 & 0xff ] + lut[ d0 >> 8 & 0xff ] + lut[ d0 >> 16 & 0xff ] + lut[ d0 >> 24 & 0xff ] + '-' +\\r\\n\\t\\t\\t\\t\\tlut[ d1 & 0xff ] + lut[ d1 >> 8 & 0xff ] + '-' + lut[ d1 >> 16 & 0x0f | 0x40 ] + lut[ d1 >> 24 & 0xff ] + '-' +\\r\\n\\t\\t\\t\\t\\tlut[ d2 & 0x3f | 0x80 ] + lut[ d2 >> 8 & 0xff ] + '-' + lut[ d2 >> 16 & 0xff ] + lut[ d2 >> 24 & 0xff ] +\\r\\n\\t\\t\\t\\t\\tlut[ d3 & 0xff ] + lut[ d3 >> 8 & 0xff ] + lut[ d3 >> 16 & 0xff ] + lut[ d3 >> 24 & 0xff ];\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t} )(),\\r\\n\\r\\n\\t\\tclamp: function ( value, min, max ) {\\r\\n\\r\\n\\t\\t\\treturn Math.max( min, Math.min( max, value ) );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// compute euclidian modulo of m % n\\r\\n\\t\\t// https://en.wikipedia.org/wiki/Modulo_operation\\r\\n\\r\\n\\t\\teuclideanModulo: function ( n, m ) {\\r\\n\\r\\n\\t\\t\\treturn ( ( n % m ) + m ) % m;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// Linear mapping from range <a1, a2> to range <b1, b2>\\r\\n\\r\\n\\t\\tmapLinear: function ( x, a1, a2, b1, b2 ) {\\r\\n\\r\\n\\t\\t\\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// https://en.wikipedia.org/wiki/Linear_interpolation\\r\\n\\r\\n\\t\\tlerp: function ( x, y, t ) {\\r\\n\\r\\n\\t\\t\\treturn ( 1 - t ) * x + t * y;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// http://en.wikipedia.org/wiki/Smoothstep\\r\\n\\r\\n\\t\\tsmoothstep: function ( x, min, max ) {\\r\\n\\r\\n\\t\\t\\tif ( x <= min ) return 0;\\r\\n\\t\\t\\tif ( x >= max ) return 1;\\r\\n\\r\\n\\t\\t\\tx = ( x - min ) / ( max - min );\\r\\n\\r\\n\\t\\t\\treturn x * x * ( 3 - 2 * x );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsmootherstep: function ( x, min, max ) {\\r\\n\\r\\n\\t\\t\\tif ( x <= min ) return 0;\\r\\n\\t\\t\\tif ( x >= max ) return 1;\\r\\n\\r\\n\\t\\t\\tx = ( x - min ) / ( max - min );\\r\\n\\r\\n\\t\\t\\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// Random integer from <low, high> interval\\r\\n\\r\\n\\t\\trandInt: function ( low, high ) {\\r\\n\\r\\n\\t\\t\\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// Random float from <low, high> interval\\r\\n\\r\\n\\t\\trandFloat: function ( low, high ) {\\r\\n\\r\\n\\t\\t\\treturn low + Math.random() * ( high - low );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// Random float from <-range/2, range/2> interval\\r\\n\\r\\n\\t\\trandFloatSpread: function ( range ) {\\r\\n\\r\\n\\t\\t\\treturn range * ( 0.5 - Math.random() );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdegToRad: function ( degrees ) {\\r\\n\\r\\n\\t\\t\\treturn degrees * _Math.DEG2RAD;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tradToDeg: function ( radians ) {\\r\\n\\r\\n\\t\\t\\treturn radians * _Math.RAD2DEG;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tisPowerOfTwo: function ( value ) {\\r\\n\\r\\n\\t\\t\\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tceilPowerOfTwo: function ( value ) {\\r\\n\\r\\n\\t\\t\\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tfloorPowerOfTwo: function ( value ) {\\r\\n\\r\\n\\t\\t\\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author philogb / http://blog.thejit.org/\\r\\n\\t * @author egraether / http://egraether.com/\\r\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\r\\n\\t */\\r\\n\\r\\n\\tfunction Vector2( x, y ) {\\r\\n\\r\\n\\t\\tthis.x = x || 0;\\r\\n\\t\\tthis.y = y || 0;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.defineProperties( Vector2.prototype, {\\r\\n\\r\\n\\t\\t\\\"width\\\": {\\r\\n\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\treturn this.x;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.x = value;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t\\\"height\\\": {\\r\\n\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\treturn this.y;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.y = value;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tObject.assign( Vector2.prototype, {\\r\\n\\r\\n\\t\\tisVector2: true,\\r\\n\\r\\n\\t\\tset: function ( x, y ) {\\r\\n\\r\\n\\t\\t\\tthis.x = x;\\r\\n\\t\\t\\tthis.y = y;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetScalar: function ( scalar ) {\\r\\n\\r\\n\\t\\t\\tthis.x = scalar;\\r\\n\\t\\t\\tthis.y = scalar;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetX: function ( x ) {\\r\\n\\r\\n\\t\\t\\tthis.x = x;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetY: function ( y ) {\\r\\n\\r\\n\\t\\t\\tthis.y = y;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetComponent: function ( index, value ) {\\r\\n\\r\\n\\t\\t\\tswitch ( index ) {\\r\\n\\r\\n\\t\\t\\t\\tcase 0: this.x = value; break;\\r\\n\\t\\t\\t\\tcase 1: this.y = value; break;\\r\\n\\t\\t\\t\\tdefault: throw new Error( 'index is out of range: ' + index );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetComponent: function ( index ) {\\r\\n\\r\\n\\t\\t\\tswitch ( index ) {\\r\\n\\r\\n\\t\\t\\t\\tcase 0: return this.x;\\r\\n\\t\\t\\t\\tcase 1: return this.y;\\r\\n\\t\\t\\t\\tdefault: throw new Error( 'index is out of range: ' + index );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor( this.x, this.y );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( v ) {\\r\\n\\r\\n\\t\\t\\tthis.x = v.x;\\r\\n\\t\\t\\tthis.y = v.y;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tadd: function ( v, w ) {\\r\\n\\r\\n\\t\\t\\tif ( w !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\\r\\n\\t\\t\\t\\treturn this.addVectors( v, w );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.x += v.x;\\r\\n\\t\\t\\tthis.y += v.y;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\taddScalar: function ( s ) {\\r\\n\\r\\n\\t\\t\\tthis.x += s;\\r\\n\\t\\t\\tthis.y += s;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\taddVectors: function ( a, b ) {\\r\\n\\r\\n\\t\\t\\tthis.x = a.x + b.x;\\r\\n\\t\\t\\tthis.y = a.y + b.y;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\taddScaledVector: function ( v, s ) {\\r\\n\\r\\n\\t\\t\\tthis.x += v.x * s;\\r\\n\\t\\t\\tthis.y += v.y * s;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsub: function ( v, w ) {\\r\\n\\r\\n\\t\\t\\tif ( w !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\\r\\n\\t\\t\\t\\treturn this.subVectors( v, w );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.x -= v.x;\\r\\n\\t\\t\\tthis.y -= v.y;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsubScalar: function ( s ) {\\r\\n\\r\\n\\t\\t\\tthis.x -= s;\\r\\n\\t\\t\\tthis.y -= s;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsubVectors: function ( a, b ) {\\r\\n\\r\\n\\t\\t\\tthis.x = a.x - b.x;\\r\\n\\t\\t\\tthis.y = a.y - b.y;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmultiply: function ( v ) {\\r\\n\\r\\n\\t\\t\\tthis.x *= v.x;\\r\\n\\t\\t\\tthis.y *= v.y;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmultiplyScalar: function ( scalar ) {\\r\\n\\r\\n\\t\\t\\tthis.x *= scalar;\\r\\n\\t\\t\\tthis.y *= scalar;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdivide: function ( v ) {\\r\\n\\r\\n\\t\\t\\tthis.x /= v.x;\\r\\n\\t\\t\\tthis.y /= v.y;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdivideScalar: function ( scalar ) {\\r\\n\\r\\n\\t\\t\\treturn this.multiplyScalar( 1 / scalar );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tapplyMatrix3: function ( m ) {\\r\\n\\r\\n\\t\\t\\tvar x = this.x, y = this.y;\\r\\n\\t\\t\\tvar e = m.elements;\\r\\n\\r\\n\\t\\t\\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];\\r\\n\\t\\t\\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmin: function ( v ) {\\r\\n\\r\\n\\t\\t\\tthis.x = Math.min( this.x, v.x );\\r\\n\\t\\t\\tthis.y = Math.min( this.y, v.y );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmax: function ( v ) {\\r\\n\\r\\n\\t\\t\\tthis.x = Math.max( this.x, v.x );\\r\\n\\t\\t\\tthis.y = Math.max( this.y, v.y );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclamp: function ( min, max ) {\\r\\n\\r\\n\\t\\t\\t// assumes min < max, componentwise\\r\\n\\r\\n\\t\\t\\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\\r\\n\\t\\t\\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclampScalar: function () {\\r\\n\\r\\n\\t\\t\\tvar min = new Vector2();\\r\\n\\t\\t\\tvar max = new Vector2();\\r\\n\\r\\n\\t\\t\\treturn function clampScalar( minVal, maxVal ) {\\r\\n\\r\\n\\t\\t\\t\\tmin.set( minVal, minVal );\\r\\n\\t\\t\\t\\tmax.set( maxVal, maxVal );\\r\\n\\r\\n\\t\\t\\t\\treturn this.clamp( min, max );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tclampLength: function ( min, max ) {\\r\\n\\r\\n\\t\\t\\tvar length = this.length();\\r\\n\\r\\n\\t\\t\\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tfloor: function () {\\r\\n\\r\\n\\t\\t\\tthis.x = Math.floor( this.x );\\r\\n\\t\\t\\tthis.y = Math.floor( this.y );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tceil: function () {\\r\\n\\r\\n\\t\\t\\tthis.x = Math.ceil( this.x );\\r\\n\\t\\t\\tthis.y = Math.ceil( this.y );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tround: function () {\\r\\n\\r\\n\\t\\t\\tthis.x = Math.round( this.x );\\r\\n\\t\\t\\tthis.y = Math.round( this.y );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\troundToZero: function () {\\r\\n\\r\\n\\t\\t\\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\\r\\n\\t\\t\\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tnegate: function () {\\r\\n\\r\\n\\t\\t\\tthis.x = - this.x;\\r\\n\\t\\t\\tthis.y = - this.y;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdot: function ( v ) {\\r\\n\\r\\n\\t\\t\\treturn this.x * v.x + this.y * v.y;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tlengthSq: function () {\\r\\n\\r\\n\\t\\t\\treturn this.x * this.x + this.y * this.y;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tlength: function () {\\r\\n\\r\\n\\t\\t\\treturn Math.sqrt( this.x * this.x + this.y * this.y );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmanhattanLength: function () {\\r\\n\\r\\n\\t\\t\\treturn Math.abs( this.x ) + Math.abs( this.y );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tnormalize: function () {\\r\\n\\r\\n\\t\\t\\treturn this.divideScalar( this.length() || 1 );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tangle: function () {\\r\\n\\r\\n\\t\\t\\t// computes the angle in radians with respect to the positive x-axis\\r\\n\\r\\n\\t\\t\\tvar angle = Math.atan2( this.y, this.x );\\r\\n\\r\\n\\t\\t\\tif ( angle < 0 ) angle += 2 * Math.PI;\\r\\n\\r\\n\\t\\t\\treturn angle;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdistanceTo: function ( v ) {\\r\\n\\r\\n\\t\\t\\treturn Math.sqrt( this.distanceToSquared( v ) );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdistanceToSquared: function ( v ) {\\r\\n\\r\\n\\t\\t\\tvar dx = this.x - v.x, dy = this.y - v.y;\\r\\n\\t\\t\\treturn dx * dx + dy * dy;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmanhattanDistanceTo: function ( v ) {\\r\\n\\r\\n\\t\\t\\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetLength: function ( length ) {\\r\\n\\r\\n\\t\\t\\treturn this.normalize().multiplyScalar( length );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tlerp: function ( v, alpha ) {\\r\\n\\r\\n\\t\\t\\tthis.x += ( v.x - this.x ) * alpha;\\r\\n\\t\\t\\tthis.y += ( v.y - this.y ) * alpha;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tlerpVectors: function ( v1, v2, alpha ) {\\r\\n\\r\\n\\t\\t\\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tequals: function ( v ) {\\r\\n\\r\\n\\t\\t\\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tfromArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\t\\tthis.x = array[ offset ];\\r\\n\\t\\t\\tthis.y = array[ offset + 1 ];\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttoArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\t\\tif ( array === undefined ) array = [];\\r\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\t\\tarray[ offset ] = this.x;\\r\\n\\t\\t\\tarray[ offset + 1 ] = this.y;\\r\\n\\r\\n\\t\\t\\treturn array;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tfromBufferAttribute: function ( attribute, index, offset ) {\\r\\n\\r\\n\\t\\t\\tif ( offset !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.x = attribute.getX( index );\\r\\n\\t\\t\\tthis.y = attribute.getY( index );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\trotateAround: function ( center, angle ) {\\r\\n\\r\\n\\t\\t\\tvar c = Math.cos( angle ), s = Math.sin( angle );\\r\\n\\r\\n\\t\\t\\tvar x = this.x - center.x;\\r\\n\\t\\t\\tvar y = this.y - center.y;\\r\\n\\r\\n\\t\\t\\tthis.x = x * c - y * s + center.x;\\r\\n\\t\\t\\tthis.y = x * s + y * c + center.y;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author supereggbert / http://www.paulbrunt.co.uk/\\r\\n\\t * @author philogb / http://blog.thejit.org/\\r\\n\\t * @author jordi_ros / http://plattsoft.com\\r\\n\\t * @author D1plo1d / http://github.com/D1plo1d\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t * @author mikael emtinger / http://gomo.se/\\r\\n\\t * @author timknip / http://www.floorplanner.com/\\r\\n\\t * @author bhouston / http://clara.io\\r\\n\\t * @author WestLangley / http://github.com/WestLangley\\r\\n\\t */\\r\\n\\r\\n\\tfunction Matrix4() {\\r\\n\\r\\n\\t\\tthis.elements = [\\r\\n\\r\\n\\t\\t\\t1, 0, 0, 0,\\r\\n\\t\\t\\t0, 1, 0, 0,\\r\\n\\t\\t\\t0, 0, 1, 0,\\r\\n\\t\\t\\t0, 0, 0, 1\\r\\n\\r\\n\\t\\t];\\r\\n\\r\\n\\t\\tif ( arguments.length > 0 ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( Matrix4.prototype, {\\r\\n\\r\\n\\t\\tisMatrix4: true,\\r\\n\\r\\n\\t\\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\\r\\n\\r\\n\\t\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\t\\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\\r\\n\\t\\t\\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\\r\\n\\t\\t\\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\\r\\n\\t\\t\\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tidentity: function () {\\r\\n\\r\\n\\t\\t\\tthis.set(\\r\\n\\r\\n\\t\\t\\t\\t1, 0, 0, 0,\\r\\n\\t\\t\\t\\t0, 1, 0, 0,\\r\\n\\t\\t\\t\\t0, 0, 1, 0,\\r\\n\\t\\t\\t\\t0, 0, 0, 1\\r\\n\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new Matrix4().fromArray( this.elements );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( m ) {\\r\\n\\r\\n\\t\\t\\tvar te = this.elements;\\r\\n\\t\\t\\tvar me = m.elements;\\r\\n\\r\\n\\t\\t\\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];\\r\\n\\t\\t\\tte[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];\\r\\n\\t\\t\\tte[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];\\r\\n\\t\\t\\tte[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopyPosition: function ( m ) {\\r\\n\\r\\n\\t\\t\\tvar te = this.elements, me = m.elements;\\r\\n\\r\\n\\t\\t\\tte[ 12 ] = me[ 12 ];\\r\\n\\t\\t\\tte[ 13 ] = me[ 13 ];\\r\\n\\t\\t\\tte[ 14 ] = me[ 14 ];\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\textractBasis: function ( xAxis, yAxis, zAxis ) {\\r\\n\\r\\n\\t\\t\\txAxis.setFromMatrixColumn( this, 0 );\\r\\n\\t\\t\\tyAxis.setFromMatrixColumn( this, 1 );\\r\\n\\t\\t\\tzAxis.setFromMatrixColumn( this, 2 );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\\r\\n\\r\\n\\t\\t\\tthis.set(\\r\\n\\t\\t\\t\\txAxis.x, yAxis.x, zAxis.x, 0,\\r\\n\\t\\t\\t\\txAxis.y, yAxis.y, zAxis.y, 0,\\r\\n\\t\\t\\t\\txAxis.z, yAxis.z, zAxis.z, 0,\\r\\n\\t\\t\\t\\t0, 0, 0, 1\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\textractRotation: function () {\\r\\n\\r\\n\\t\\t\\tvar v1 = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function extractRotation( m ) {\\r\\n\\r\\n\\t\\t\\t\\tvar te = this.elements;\\r\\n\\t\\t\\t\\tvar me = m.elements;\\r\\n\\r\\n\\t\\t\\t\\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\\r\\n\\t\\t\\t\\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\\r\\n\\t\\t\\t\\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\\r\\n\\r\\n\\t\\t\\t\\tte[ 0 ] = me[ 0 ] * scaleX;\\r\\n\\t\\t\\t\\tte[ 1 ] = me[ 1 ] * scaleX;\\r\\n\\t\\t\\t\\tte[ 2 ] = me[ 2 ] * scaleX;\\r\\n\\r\\n\\t\\t\\t\\tte[ 4 ] = me[ 4 ] * scaleY;\\r\\n\\t\\t\\t\\tte[ 5 ] = me[ 5 ] * scaleY;\\r\\n\\t\\t\\t\\tte[ 6 ] = me[ 6 ] * scaleY;\\r\\n\\r\\n\\t\\t\\t\\tte[ 8 ] = me[ 8 ] * scaleZ;\\r\\n\\t\\t\\t\\tte[ 9 ] = me[ 9 ] * scaleZ;\\r\\n\\t\\t\\t\\tte[ 10 ] = me[ 10 ] * scaleZ;\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tmakeRotationFromEuler: function ( euler ) {\\r\\n\\r\\n\\t\\t\\tif ( ! ( euler && euler.isEuler ) ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\t\\tvar x = euler.x, y = euler.y, z = euler.z;\\r\\n\\t\\t\\tvar a = Math.cos( x ), b = Math.sin( x );\\r\\n\\t\\t\\tvar c = Math.cos( y ), d = Math.sin( y );\\r\\n\\t\\t\\tvar e = Math.cos( z ), f = Math.sin( z );\\r\\n\\r\\n\\t\\t\\tif ( euler.order === 'XYZ' ) {\\r\\n\\r\\n\\t\\t\\t\\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\\r\\n\\r\\n\\t\\t\\t\\tte[ 0 ] = c * e;\\r\\n\\t\\t\\t\\tte[ 4 ] = - c * f;\\r\\n\\t\\t\\t\\tte[ 8 ] = d;\\r\\n\\r\\n\\t\\t\\t\\tte[ 1 ] = af + be * d;\\r\\n\\t\\t\\t\\tte[ 5 ] = ae - bf * d;\\r\\n\\t\\t\\t\\tte[ 9 ] = - b * c;\\r\\n\\r\\n\\t\\t\\t\\tte[ 2 ] = bf - ae * d;\\r\\n\\t\\t\\t\\tte[ 6 ] = be + af * d;\\r\\n\\t\\t\\t\\tte[ 10 ] = a * c;\\r\\n\\r\\n\\t\\t\\t} else if ( euler.order === 'YXZ' ) {\\r\\n\\r\\n\\t\\t\\t\\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\\r\\n\\r\\n\\t\\t\\t\\tte[ 0 ] = ce + df * b;\\r\\n\\t\\t\\t\\tte[ 4 ] = de * b - cf;\\r\\n\\t\\t\\t\\tte[ 8 ] = a * d;\\r\\n\\r\\n\\t\\t\\t\\tte[ 1 ] = a * f;\\r\\n\\t\\t\\t\\tte[ 5 ] = a * e;\\r\\n\\t\\t\\t\\tte[ 9 ] = - b;\\r\\n\\r\\n\\t\\t\\t\\tte[ 2 ] = cf * b - de;\\r\\n\\t\\t\\t\\tte[ 6 ] = df + ce * b;\\r\\n\\t\\t\\t\\tte[ 10 ] = a * c;\\r\\n\\r\\n\\t\\t\\t} else if ( euler.order === 'ZXY' ) {\\r\\n\\r\\n\\t\\t\\t\\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\\r\\n\\r\\n\\t\\t\\t\\tte[ 0 ] = ce - df * b;\\r\\n\\t\\t\\t\\tte[ 4 ] = - a * f;\\r\\n\\t\\t\\t\\tte[ 8 ] = de + cf * b;\\r\\n\\r\\n\\t\\t\\t\\tte[ 1 ] = cf + de * b;\\r\\n\\t\\t\\t\\tte[ 5 ] = a * e;\\r\\n\\t\\t\\t\\tte[ 9 ] = df - ce * b;\\r\\n\\r\\n\\t\\t\\t\\tte[ 2 ] = - a * d;\\r\\n\\t\\t\\t\\tte[ 6 ] = b;\\r\\n\\t\\t\\t\\tte[ 10 ] = a * c;\\r\\n\\r\\n\\t\\t\\t} else if ( euler.order === 'ZYX' ) {\\r\\n\\r\\n\\t\\t\\t\\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\\r\\n\\r\\n\\t\\t\\t\\tte[ 0 ] = c * e;\\r\\n\\t\\t\\t\\tte[ 4 ] = be * d - af;\\r\\n\\t\\t\\t\\tte[ 8 ] = ae * d + bf;\\r\\n\\r\\n\\t\\t\\t\\tte[ 1 ] = c * f;\\r\\n\\t\\t\\t\\tte[ 5 ] = bf * d + ae;\\r\\n\\t\\t\\t\\tte[ 9 ] = af * d - be;\\r\\n\\r\\n\\t\\t\\t\\tte[ 2 ] = - d;\\r\\n\\t\\t\\t\\tte[ 6 ] = b * c;\\r\\n\\t\\t\\t\\tte[ 10 ] = a * c;\\r\\n\\r\\n\\t\\t\\t} else if ( euler.order === 'YZX' ) {\\r\\n\\r\\n\\t\\t\\t\\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\\r\\n\\r\\n\\t\\t\\t\\tte[ 0 ] = c * e;\\r\\n\\t\\t\\t\\tte[ 4 ] = bd - ac * f;\\r\\n\\t\\t\\t\\tte[ 8 ] = bc * f + ad;\\r\\n\\r\\n\\t\\t\\t\\tte[ 1 ] = f;\\r\\n\\t\\t\\t\\tte[ 5 ] = a * e;\\r\\n\\t\\t\\t\\tte[ 9 ] = - b * e;\\r\\n\\r\\n\\t\\t\\t\\tte[ 2 ] = - d * e;\\r\\n\\t\\t\\t\\tte[ 6 ] = ad * f + bc;\\r\\n\\t\\t\\t\\tte[ 10 ] = ac - bd * f;\\r\\n\\r\\n\\t\\t\\t} else if ( euler.order === 'XZY' ) {\\r\\n\\r\\n\\t\\t\\t\\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\\r\\n\\r\\n\\t\\t\\t\\tte[ 0 ] = c * e;\\r\\n\\t\\t\\t\\tte[ 4 ] = - f;\\r\\n\\t\\t\\t\\tte[ 8 ] = d * e;\\r\\n\\r\\n\\t\\t\\t\\tte[ 1 ] = ac * f + bd;\\r\\n\\t\\t\\t\\tte[ 5 ] = a * e;\\r\\n\\t\\t\\t\\tte[ 9 ] = ad * f - bc;\\r\\n\\r\\n\\t\\t\\t\\tte[ 2 ] = bc * f - ad;\\r\\n\\t\\t\\t\\tte[ 6 ] = b * e;\\r\\n\\t\\t\\t\\tte[ 10 ] = bd * f + ac;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// last column\\r\\n\\t\\t\\tte[ 3 ] = 0;\\r\\n\\t\\t\\tte[ 7 ] = 0;\\r\\n\\t\\t\\tte[ 11 ] = 0;\\r\\n\\r\\n\\t\\t\\t// bottom row\\r\\n\\t\\t\\tte[ 12 ] = 0;\\r\\n\\t\\t\\tte[ 13 ] = 0;\\r\\n\\t\\t\\tte[ 14 ] = 0;\\r\\n\\t\\t\\tte[ 15 ] = 1;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmakeRotationFromQuaternion: function ( q ) {\\r\\n\\r\\n\\t\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\t\\tvar x = q._x, y = q._y, z = q._z, w = q._w;\\r\\n\\t\\t\\tvar x2 = x + x, y2 = y + y, z2 = z + z;\\r\\n\\t\\t\\tvar xx = x * x2, xy = x * y2, xz = x * z2;\\r\\n\\t\\t\\tvar yy = y * y2, yz = y * z2, zz = z * z2;\\r\\n\\t\\t\\tvar wx = w * x2, wy = w * y2, wz = w * z2;\\r\\n\\r\\n\\t\\t\\tte[ 0 ] = 1 - ( yy + zz );\\r\\n\\t\\t\\tte[ 4 ] = xy - wz;\\r\\n\\t\\t\\tte[ 8 ] = xz + wy;\\r\\n\\r\\n\\t\\t\\tte[ 1 ] = xy + wz;\\r\\n\\t\\t\\tte[ 5 ] = 1 - ( xx + zz );\\r\\n\\t\\t\\tte[ 9 ] = yz - wx;\\r\\n\\r\\n\\t\\t\\tte[ 2 ] = xz - wy;\\r\\n\\t\\t\\tte[ 6 ] = yz + wx;\\r\\n\\t\\t\\tte[ 10 ] = 1 - ( xx + yy );\\r\\n\\r\\n\\t\\t\\t// last column\\r\\n\\t\\t\\tte[ 3 ] = 0;\\r\\n\\t\\t\\tte[ 7 ] = 0;\\r\\n\\t\\t\\tte[ 11 ] = 0;\\r\\n\\r\\n\\t\\t\\t// bottom row\\r\\n\\t\\t\\tte[ 12 ] = 0;\\r\\n\\t\\t\\tte[ 13 ] = 0;\\r\\n\\t\\t\\tte[ 14 ] = 0;\\r\\n\\t\\t\\tte[ 15 ] = 1;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tlookAt: function () {\\r\\n\\r\\n\\t\\t\\tvar x = new Vector3();\\r\\n\\t\\t\\tvar y = new Vector3();\\r\\n\\t\\t\\tvar z = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function lookAt( eye, target, up ) {\\r\\n\\r\\n\\t\\t\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\t\\t\\tz.subVectors( eye, target );\\r\\n\\r\\n\\t\\t\\t\\tif ( z.lengthSq() === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// eye and target are in the same position\\r\\n\\r\\n\\t\\t\\t\\t\\tz.z = 1;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tz.normalize();\\r\\n\\t\\t\\t\\tx.crossVectors( up, z );\\r\\n\\r\\n\\t\\t\\t\\tif ( x.lengthSq() === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// up and z are parallel\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( Math.abs( up.z ) === 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tz.x += 0.0001;\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tz.z += 0.0001;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tz.normalize();\\r\\n\\t\\t\\t\\t\\tx.crossVectors( up, z );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tx.normalize();\\r\\n\\t\\t\\t\\ty.crossVectors( z, x );\\r\\n\\r\\n\\t\\t\\t\\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\\r\\n\\t\\t\\t\\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\\r\\n\\t\\t\\t\\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tmultiply: function ( m, n ) {\\r\\n\\r\\n\\t\\t\\tif ( n !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\\r\\n\\t\\t\\t\\treturn this.multiplyMatrices( m, n );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this.multiplyMatrices( this, m );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tpremultiply: function ( m ) {\\r\\n\\r\\n\\t\\t\\treturn this.multiplyMatrices( m, this );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmultiplyMatrices: function ( a, b ) {\\r\\n\\r\\n\\t\\t\\tvar ae = a.elements;\\r\\n\\t\\t\\tvar be = b.elements;\\r\\n\\t\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\t\\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\\r\\n\\t\\t\\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\\r\\n\\t\\t\\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\\r\\n\\t\\t\\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\\r\\n\\r\\n\\t\\t\\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\\r\\n\\t\\t\\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\\r\\n\\t\\t\\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\\r\\n\\t\\t\\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\\r\\n\\r\\n\\t\\t\\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\\r\\n\\t\\t\\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\\r\\n\\t\\t\\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\\r\\n\\t\\t\\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\\r\\n\\r\\n\\t\\t\\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\\r\\n\\t\\t\\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\\r\\n\\t\\t\\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\\r\\n\\t\\t\\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\\r\\n\\r\\n\\t\\t\\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\\r\\n\\t\\t\\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\\r\\n\\t\\t\\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\\r\\n\\t\\t\\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\\r\\n\\r\\n\\t\\t\\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\\r\\n\\t\\t\\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\\r\\n\\t\\t\\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\\r\\n\\t\\t\\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmultiplyScalar: function ( s ) {\\r\\n\\r\\n\\t\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\t\\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\\r\\n\\t\\t\\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\\r\\n\\t\\t\\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\\r\\n\\t\\t\\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tapplyToBufferAttribute: function () {\\r\\n\\r\\n\\t\\t\\tvar v1 = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function applyToBufferAttribute( attribute ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tv1.x = attribute.getX( i );\\r\\n\\t\\t\\t\\t\\tv1.y = attribute.getY( i );\\r\\n\\t\\t\\t\\t\\tv1.z = attribute.getZ( i );\\r\\n\\r\\n\\t\\t\\t\\t\\tv1.applyMatrix4( this );\\r\\n\\r\\n\\t\\t\\t\\t\\tattribute.setXYZ( i, v1.x, v1.y, v1.z );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn attribute;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tdeterminant: function () {\\r\\n\\r\\n\\t\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\t\\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\\r\\n\\t\\t\\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\\r\\n\\t\\t\\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\\r\\n\\t\\t\\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\\r\\n\\r\\n\\t\\t\\t//TODO: make this more efficient\\r\\n\\t\\t\\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\\r\\n\\r\\n\\t\\t\\treturn (\\r\\n\\t\\t\\t\\tn41 * (\\r\\n\\t\\t\\t\\t\\t+ n14 * n23 * n32\\r\\n\\t\\t\\t\\t\\t - n13 * n24 * n32\\r\\n\\t\\t\\t\\t\\t - n14 * n22 * n33\\r\\n\\t\\t\\t\\t\\t + n12 * n24 * n33\\r\\n\\t\\t\\t\\t\\t + n13 * n22 * n34\\r\\n\\t\\t\\t\\t\\t - n12 * n23 * n34\\r\\n\\t\\t\\t\\t) +\\r\\n\\t\\t\\t\\tn42 * (\\r\\n\\t\\t\\t\\t\\t+ n11 * n23 * n34\\r\\n\\t\\t\\t\\t\\t - n11 * n24 * n33\\r\\n\\t\\t\\t\\t\\t + n14 * n21 * n33\\r\\n\\t\\t\\t\\t\\t - n13 * n21 * n34\\r\\n\\t\\t\\t\\t\\t + n13 * n24 * n31\\r\\n\\t\\t\\t\\t\\t - n14 * n23 * n31\\r\\n\\t\\t\\t\\t) +\\r\\n\\t\\t\\t\\tn43 * (\\r\\n\\t\\t\\t\\t\\t+ n11 * n24 * n32\\r\\n\\t\\t\\t\\t\\t - n11 * n22 * n34\\r\\n\\t\\t\\t\\t\\t - n14 * n21 * n32\\r\\n\\t\\t\\t\\t\\t + n12 * n21 * n34\\r\\n\\t\\t\\t\\t\\t + n14 * n22 * n31\\r\\n\\t\\t\\t\\t\\t - n12 * n24 * n31\\r\\n\\t\\t\\t\\t) +\\r\\n\\t\\t\\t\\tn44 * (\\r\\n\\t\\t\\t\\t\\t- n13 * n22 * n31\\r\\n\\t\\t\\t\\t\\t - n11 * n23 * n32\\r\\n\\t\\t\\t\\t\\t + n11 * n22 * n33\\r\\n\\t\\t\\t\\t\\t + n13 * n21 * n32\\r\\n\\t\\t\\t\\t\\t - n12 * n21 * n33\\r\\n\\t\\t\\t\\t\\t + n12 * n23 * n31\\r\\n\\t\\t\\t\\t)\\r\\n\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttranspose: function () {\\r\\n\\r\\n\\t\\t\\tvar te = this.elements;\\r\\n\\t\\t\\tvar tmp;\\r\\n\\r\\n\\t\\t\\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\\r\\n\\t\\t\\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\\r\\n\\t\\t\\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\\r\\n\\r\\n\\t\\t\\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\\r\\n\\t\\t\\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\\r\\n\\t\\t\\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetPosition: function ( v ) {\\r\\n\\r\\n\\t\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\t\\tte[ 12 ] = v.x;\\r\\n\\t\\t\\tte[ 13 ] = v.y;\\r\\n\\t\\t\\tte[ 14 ] = v.z;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetInverse: function ( m, throwOnDegenerate ) {\\r\\n\\r\\n\\t\\t\\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\\r\\n\\t\\t\\tvar te = this.elements,\\r\\n\\t\\t\\t\\tme = m.elements,\\r\\n\\r\\n\\t\\t\\t\\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\\r\\n\\t\\t\\t\\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\\r\\n\\t\\t\\t\\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\\r\\n\\t\\t\\t\\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\\r\\n\\r\\n\\t\\t\\t\\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\\r\\n\\t\\t\\t\\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\\r\\n\\t\\t\\t\\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\\r\\n\\t\\t\\t\\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\\r\\n\\r\\n\\t\\t\\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\\r\\n\\r\\n\\t\\t\\tif ( det === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tvar msg = \\\"THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0\\\";\\r\\n\\r\\n\\t\\t\\t\\tif ( throwOnDegenerate === true ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthrow new Error( msg );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( msg );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn this.identity();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar detInv = 1 / det;\\r\\n\\r\\n\\t\\t\\tte[ 0 ] = t11 * detInv;\\r\\n\\t\\t\\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\\r\\n\\t\\t\\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\\r\\n\\t\\t\\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\\r\\n\\r\\n\\t\\t\\tte[ 4 ] = t12 * detInv;\\r\\n\\t\\t\\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\\r\\n\\t\\t\\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\\r\\n\\t\\t\\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\\r\\n\\r\\n\\t\\t\\tte[ 8 ] = t13 * detInv;\\r\\n\\t\\t\\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\\r\\n\\t\\t\\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\\r\\n\\t\\t\\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\\r\\n\\r\\n\\t\\t\\tte[ 12 ] = t14 * detInv;\\r\\n\\t\\t\\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\\r\\n\\t\\t\\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\\r\\n\\t\\t\\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tscale: function ( v ) {\\r\\n\\r\\n\\t\\t\\tvar te = this.elements;\\r\\n\\t\\t\\tvar x = v.x, y = v.y, z = v.z;\\r\\n\\r\\n\\t\\t\\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\\r\\n\\t\\t\\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\\r\\n\\t\\t\\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\\r\\n\\t\\t\\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetMaxScaleOnAxis: function () {\\r\\n\\r\\n\\t\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\t\\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\\r\\n\\t\\t\\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\\r\\n\\t\\t\\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\\r\\n\\r\\n\\t\\t\\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmakeTranslation: function ( x, y, z ) {\\r\\n\\r\\n\\t\\t\\tthis.set(\\r\\n\\r\\n\\t\\t\\t\\t1, 0, 0, x,\\r\\n\\t\\t\\t\\t0, 1, 0, y,\\r\\n\\t\\t\\t\\t0, 0, 1, z,\\r\\n\\t\\t\\t\\t0, 0, 0, 1\\r\\n\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmakeRotationX: function ( theta ) {\\r\\n\\r\\n\\t\\t\\tvar c = Math.cos( theta ), s = Math.sin( theta );\\r\\n\\r\\n\\t\\t\\tthis.set(\\r\\n\\r\\n\\t\\t\\t\\t1, 0, 0, 0,\\r\\n\\t\\t\\t\\t0, c, - s, 0,\\r\\n\\t\\t\\t\\t0, s, c, 0,\\r\\n\\t\\t\\t\\t0, 0, 0, 1\\r\\n\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmakeRotationY: function ( theta ) {\\r\\n\\r\\n\\t\\t\\tvar c = Math.cos( theta ), s = Math.sin( theta );\\r\\n\\r\\n\\t\\t\\tthis.set(\\r\\n\\r\\n\\t\\t\\t\\t c, 0, s, 0,\\r\\n\\t\\t\\t\\t 0, 1, 0, 0,\\r\\n\\t\\t\\t\\t- s, 0, c, 0,\\r\\n\\t\\t\\t\\t 0, 0, 0, 1\\r\\n\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmakeRotationZ: function ( theta ) {\\r\\n\\r\\n\\t\\t\\tvar c = Math.cos( theta ), s = Math.sin( theta );\\r\\n\\r\\n\\t\\t\\tthis.set(\\r\\n\\r\\n\\t\\t\\t\\tc, - s, 0, 0,\\r\\n\\t\\t\\t\\ts, c, 0, 0,\\r\\n\\t\\t\\t\\t0, 0, 1, 0,\\r\\n\\t\\t\\t\\t0, 0, 0, 1\\r\\n\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmakeRotationAxis: function ( axis, angle ) {\\r\\n\\r\\n\\t\\t\\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\\r\\n\\r\\n\\t\\t\\tvar c = Math.cos( angle );\\r\\n\\t\\t\\tvar s = Math.sin( angle );\\r\\n\\t\\t\\tvar t = 1 - c;\\r\\n\\t\\t\\tvar x = axis.x, y = axis.y, z = axis.z;\\r\\n\\t\\t\\tvar tx = t * x, ty = t * y;\\r\\n\\r\\n\\t\\t\\tthis.set(\\r\\n\\r\\n\\t\\t\\t\\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\\r\\n\\t\\t\\t\\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\\r\\n\\t\\t\\t\\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\\r\\n\\t\\t\\t\\t0, 0, 0, 1\\r\\n\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t return this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmakeScale: function ( x, y, z ) {\\r\\n\\r\\n\\t\\t\\tthis.set(\\r\\n\\r\\n\\t\\t\\t\\tx, 0, 0, 0,\\r\\n\\t\\t\\t\\t0, y, 0, 0,\\r\\n\\t\\t\\t\\t0, 0, z, 0,\\r\\n\\t\\t\\t\\t0, 0, 0, 1\\r\\n\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmakeShear: function ( x, y, z ) {\\r\\n\\r\\n\\t\\t\\tthis.set(\\r\\n\\r\\n\\t\\t\\t\\t1, y, z, 0,\\r\\n\\t\\t\\t\\tx, 1, z, 0,\\r\\n\\t\\t\\t\\tx, y, 1, 0,\\r\\n\\t\\t\\t\\t0, 0, 0, 1\\r\\n\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcompose: function ( position, quaternion, scale ) {\\r\\n\\r\\n\\t\\t\\tthis.makeRotationFromQuaternion( quaternion );\\r\\n\\t\\t\\tthis.scale( scale );\\r\\n\\t\\t\\tthis.setPosition( position );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdecompose: function () {\\r\\n\\r\\n\\t\\t\\tvar vector = new Vector3();\\r\\n\\t\\t\\tvar matrix = new Matrix4();\\r\\n\\r\\n\\t\\t\\treturn function decompose( position, quaternion, scale ) {\\r\\n\\r\\n\\t\\t\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\t\\t\\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\\r\\n\\t\\t\\t\\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\\r\\n\\t\\t\\t\\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\\r\\n\\r\\n\\t\\t\\t\\t// if determine is negative, we need to invert one scale\\r\\n\\t\\t\\t\\tvar det = this.determinant();\\r\\n\\t\\t\\t\\tif ( det < 0 ) sx = - sx;\\r\\n\\r\\n\\t\\t\\t\\tposition.x = te[ 12 ];\\r\\n\\t\\t\\t\\tposition.y = te[ 13 ];\\r\\n\\t\\t\\t\\tposition.z = te[ 14 ];\\r\\n\\r\\n\\t\\t\\t\\t// scale the rotation part\\r\\n\\t\\t\\t\\tmatrix.copy( this );\\r\\n\\r\\n\\t\\t\\t\\tvar invSX = 1 / sx;\\r\\n\\t\\t\\t\\tvar invSY = 1 / sy;\\r\\n\\t\\t\\t\\tvar invSZ = 1 / sz;\\r\\n\\r\\n\\t\\t\\t\\tmatrix.elements[ 0 ] *= invSX;\\r\\n\\t\\t\\t\\tmatrix.elements[ 1 ] *= invSX;\\r\\n\\t\\t\\t\\tmatrix.elements[ 2 ] *= invSX;\\r\\n\\r\\n\\t\\t\\t\\tmatrix.elements[ 4 ] *= invSY;\\r\\n\\t\\t\\t\\tmatrix.elements[ 5 ] *= invSY;\\r\\n\\t\\t\\t\\tmatrix.elements[ 6 ] *= invSY;\\r\\n\\r\\n\\t\\t\\t\\tmatrix.elements[ 8 ] *= invSZ;\\r\\n\\t\\t\\t\\tmatrix.elements[ 9 ] *= invSZ;\\r\\n\\t\\t\\t\\tmatrix.elements[ 10 ] *= invSZ;\\r\\n\\r\\n\\t\\t\\t\\tquaternion.setFromRotationMatrix( matrix );\\r\\n\\r\\n\\t\\t\\t\\tscale.x = sx;\\r\\n\\t\\t\\t\\tscale.y = sy;\\r\\n\\t\\t\\t\\tscale.z = sz;\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tmakePerspective: function ( left, right, top, bottom, near, far ) {\\r\\n\\r\\n\\t\\t\\tif ( far === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar te = this.elements;\\r\\n\\t\\t\\tvar x = 2 * near / ( right - left );\\r\\n\\t\\t\\tvar y = 2 * near / ( top - bottom );\\r\\n\\r\\n\\t\\t\\tvar a = ( right + left ) / ( right - left );\\r\\n\\t\\t\\tvar b = ( top + bottom ) / ( top - bottom );\\r\\n\\t\\t\\tvar c = - ( far + near ) / ( far - near );\\r\\n\\t\\t\\tvar d = - 2 * far * near / ( far - near );\\r\\n\\r\\n\\t\\t\\tte[ 0 ] = x;\\tte[ 4 ] = 0;\\tte[ 8 ] = a;\\tte[ 12 ] = 0;\\r\\n\\t\\t\\tte[ 1 ] = 0;\\tte[ 5 ] = y;\\tte[ 9 ] = b;\\tte[ 13 ] = 0;\\r\\n\\t\\t\\tte[ 2 ] = 0;\\tte[ 6 ] = 0;\\tte[ 10 ] = c;\\tte[ 14 ] = d;\\r\\n\\t\\t\\tte[ 3 ] = 0;\\tte[ 7 ] = 0;\\tte[ 11 ] = - 1;\\tte[ 15 ] = 0;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\\r\\n\\r\\n\\t\\t\\tvar te = this.elements;\\r\\n\\t\\t\\tvar w = 1.0 / ( right - left );\\r\\n\\t\\t\\tvar h = 1.0 / ( top - bottom );\\r\\n\\t\\t\\tvar p = 1.0 / ( far - near );\\r\\n\\r\\n\\t\\t\\tvar x = ( right + left ) * w;\\r\\n\\t\\t\\tvar y = ( top + bottom ) * h;\\r\\n\\t\\t\\tvar z = ( far + near ) * p;\\r\\n\\r\\n\\t\\t\\tte[ 0 ] = 2 * w;\\tte[ 4 ] = 0;\\tte[ 8 ] = 0;\\tte[ 12 ] = - x;\\r\\n\\t\\t\\tte[ 1 ] = 0;\\tte[ 5 ] = 2 * h;\\tte[ 9 ] = 0;\\tte[ 13 ] = - y;\\r\\n\\t\\t\\tte[ 2 ] = 0;\\tte[ 6 ] = 0;\\tte[ 10 ] = - 2 * p;\\tte[ 14 ] = - z;\\r\\n\\t\\t\\tte[ 3 ] = 0;\\tte[ 7 ] = 0;\\tte[ 11 ] = 0;\\tte[ 15 ] = 1;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tequals: function ( matrix ) {\\r\\n\\r\\n\\t\\t\\tvar te = this.elements;\\r\\n\\t\\t\\tvar me = matrix.elements;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < 16; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( te[ i ] !== me[ i ] ) return false;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn true;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tfromArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < 16; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.elements[ i ] = array[ i + offset ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttoArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\t\\tif ( array === undefined ) array = [];\\r\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\t\\tarray[ offset ] = te[ 0 ];\\r\\n\\t\\t\\tarray[ offset + 1 ] = te[ 1 ];\\r\\n\\t\\t\\tarray[ offset + 2 ] = te[ 2 ];\\r\\n\\t\\t\\tarray[ offset + 3 ] = te[ 3 ];\\r\\n\\r\\n\\t\\t\\tarray[ offset + 4 ] = te[ 4 ];\\r\\n\\t\\t\\tarray[ offset + 5 ] = te[ 5 ];\\r\\n\\t\\t\\tarray[ offset + 6 ] = te[ 6 ];\\r\\n\\t\\t\\tarray[ offset + 7 ] = te[ 7 ];\\r\\n\\r\\n\\t\\t\\tarray[ offset + 8 ] = te[ 8 ];\\r\\n\\t\\t\\tarray[ offset + 9 ] = te[ 9 ];\\r\\n\\t\\t\\tarray[ offset + 10 ] = te[ 10 ];\\r\\n\\t\\t\\tarray[ offset + 11 ] = te[ 11 ];\\r\\n\\r\\n\\t\\t\\tarray[ offset + 12 ] = te[ 12 ];\\r\\n\\t\\t\\tarray[ offset + 13 ] = te[ 13 ];\\r\\n\\t\\t\\tarray[ offset + 14 ] = te[ 14 ];\\r\\n\\t\\t\\tarray[ offset + 15 ] = te[ 15 ];\\r\\n\\r\\n\\t\\t\\treturn array;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mikael emtinger / http://gomo.se/\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t * @author WestLangley / http://github.com/WestLangley\\r\\n\\t * @author bhouston / http://clara.io\\r\\n\\t */\\r\\n\\r\\n\\tfunction Quaternion( x, y, z, w ) {\\r\\n\\r\\n\\t\\tthis._x = x || 0;\\r\\n\\t\\tthis._y = y || 0;\\r\\n\\t\\tthis._z = z || 0;\\r\\n\\t\\tthis._w = ( w !== undefined ) ? w : 1;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( Quaternion, {\\r\\n\\r\\n\\t\\tslerp: function ( qa, qb, qm, t ) {\\r\\n\\r\\n\\t\\t\\treturn qm.copy( qa ).slerp( qb, t );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tslerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\\r\\n\\r\\n\\t\\t\\t// fuzz-free, array-based Quaternion SLERP operation\\r\\n\\r\\n\\t\\t\\tvar x0 = src0[ srcOffset0 + 0 ],\\r\\n\\t\\t\\t\\ty0 = src0[ srcOffset0 + 1 ],\\r\\n\\t\\t\\t\\tz0 = src0[ srcOffset0 + 2 ],\\r\\n\\t\\t\\t\\tw0 = src0[ srcOffset0 + 3 ],\\r\\n\\r\\n\\t\\t\\t\\tx1 = src1[ srcOffset1 + 0 ],\\r\\n\\t\\t\\t\\ty1 = src1[ srcOffset1 + 1 ],\\r\\n\\t\\t\\t\\tz1 = src1[ srcOffset1 + 2 ],\\r\\n\\t\\t\\t\\tw1 = src1[ srcOffset1 + 3 ];\\r\\n\\r\\n\\t\\t\\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\\r\\n\\r\\n\\t\\t\\t\\tvar s = 1 - t,\\r\\n\\r\\n\\t\\t\\t\\t\\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\\r\\n\\r\\n\\t\\t\\t\\t\\tdir = ( cos >= 0 ? 1 : - 1 ),\\r\\n\\t\\t\\t\\t\\tsqrSin = 1 - cos * cos;\\r\\n\\r\\n\\t\\t\\t\\t// Skip the Slerp for tiny steps to avoid numeric problems:\\r\\n\\t\\t\\t\\tif ( sqrSin > Number.EPSILON ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar sin = Math.sqrt( sqrSin ),\\r\\n\\t\\t\\t\\t\\t\\tlen = Math.atan2( sin, cos * dir );\\r\\n\\r\\n\\t\\t\\t\\t\\ts = Math.sin( s * len ) / sin;\\r\\n\\t\\t\\t\\t\\tt = Math.sin( t * len ) / sin;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tvar tDir = t * dir;\\r\\n\\r\\n\\t\\t\\t\\tx0 = x0 * s + x1 * tDir;\\r\\n\\t\\t\\t\\ty0 = y0 * s + y1 * tDir;\\r\\n\\t\\t\\t\\tz0 = z0 * s + z1 * tDir;\\r\\n\\t\\t\\t\\tw0 = w0 * s + w1 * tDir;\\r\\n\\r\\n\\t\\t\\t\\t// Normalize in case we just did a lerp:\\r\\n\\t\\t\\t\\tif ( s === 1 - t ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\\r\\n\\r\\n\\t\\t\\t\\t\\tx0 *= f;\\r\\n\\t\\t\\t\\t\\ty0 *= f;\\r\\n\\t\\t\\t\\t\\tz0 *= f;\\r\\n\\t\\t\\t\\t\\tw0 *= f;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tdst[ dstOffset ] = x0;\\r\\n\\t\\t\\tdst[ dstOffset + 1 ] = y0;\\r\\n\\t\\t\\tdst[ dstOffset + 2 ] = z0;\\r\\n\\t\\t\\tdst[ dstOffset + 3 ] = w0;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tObject.defineProperties( Quaternion.prototype, {\\r\\n\\r\\n\\t\\tx: {\\r\\n\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\treturn this._x;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._x = value;\\r\\n\\t\\t\\t\\tthis.onChangeCallback();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ty: {\\r\\n\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\treturn this._y;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._y = value;\\r\\n\\t\\t\\t\\tthis.onChangeCallback();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tz: {\\r\\n\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\treturn this._z;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._z = value;\\r\\n\\t\\t\\t\\tthis.onChangeCallback();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tw: {\\r\\n\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\treturn this._w;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._w = value;\\r\\n\\t\\t\\t\\tthis.onChangeCallback();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tObject.assign( Quaternion.prototype, {\\r\\n\\r\\n\\t\\tset: function ( x, y, z, w ) {\\r\\n\\r\\n\\t\\t\\tthis._x = x;\\r\\n\\t\\t\\tthis._y = y;\\r\\n\\t\\t\\tthis._z = z;\\r\\n\\t\\t\\tthis._w = w;\\r\\n\\r\\n\\t\\t\\tthis.onChangeCallback();\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor( this._x, this._y, this._z, this._w );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( quaternion ) {\\r\\n\\r\\n\\t\\t\\tthis._x = quaternion.x;\\r\\n\\t\\t\\tthis._y = quaternion.y;\\r\\n\\t\\t\\tthis._z = quaternion.z;\\r\\n\\t\\t\\tthis._w = quaternion.w;\\r\\n\\r\\n\\t\\t\\tthis.onChangeCallback();\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFromEuler: function ( euler, update ) {\\r\\n\\r\\n\\t\\t\\tif ( ! ( euler && euler.isEuler ) ) {\\r\\n\\r\\n\\t\\t\\t\\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar x = euler._x, y = euler._y, z = euler._z, order = euler.order;\\r\\n\\r\\n\\t\\t\\t// http://www.mathworks.com/matlabcentral/fileexchange/\\r\\n\\t\\t\\t// \\t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\\r\\n\\t\\t\\t//\\tcontent/SpinCalc.m\\r\\n\\r\\n\\t\\t\\tvar cos = Math.cos;\\r\\n\\t\\t\\tvar sin = Math.sin;\\r\\n\\r\\n\\t\\t\\tvar c1 = cos( x / 2 );\\r\\n\\t\\t\\tvar c2 = cos( y / 2 );\\r\\n\\t\\t\\tvar c3 = cos( z / 2 );\\r\\n\\r\\n\\t\\t\\tvar s1 = sin( x / 2 );\\r\\n\\t\\t\\tvar s2 = sin( y / 2 );\\r\\n\\t\\t\\tvar s3 = sin( z / 2 );\\r\\n\\r\\n\\t\\t\\tif ( order === 'XYZ' ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\\r\\n\\t\\t\\t\\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\\r\\n\\t\\t\\t\\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\\r\\n\\t\\t\\t\\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\\r\\n\\r\\n\\t\\t\\t} else if ( order === 'YXZ' ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\\r\\n\\t\\t\\t\\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\\r\\n\\t\\t\\t\\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\\r\\n\\t\\t\\t\\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\\r\\n\\r\\n\\t\\t\\t} else if ( order === 'ZXY' ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\\r\\n\\t\\t\\t\\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\\r\\n\\t\\t\\t\\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\\r\\n\\t\\t\\t\\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\\r\\n\\r\\n\\t\\t\\t} else if ( order === 'ZYX' ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\\r\\n\\t\\t\\t\\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\\r\\n\\t\\t\\t\\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\\r\\n\\t\\t\\t\\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\\r\\n\\r\\n\\t\\t\\t} else if ( order === 'YZX' ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\\r\\n\\t\\t\\t\\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\\r\\n\\t\\t\\t\\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\\r\\n\\t\\t\\t\\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\\r\\n\\r\\n\\t\\t\\t} else if ( order === 'XZY' ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\\r\\n\\t\\t\\t\\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\\r\\n\\t\\t\\t\\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\\r\\n\\t\\t\\t\\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( update !== false ) this.onChangeCallback();\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFromAxisAngle: function ( axis, angle ) {\\r\\n\\r\\n\\t\\t\\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\\r\\n\\r\\n\\t\\t\\t// assumes axis is normalized\\r\\n\\r\\n\\t\\t\\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\\r\\n\\r\\n\\t\\t\\tthis._x = axis.x * s;\\r\\n\\t\\t\\tthis._y = axis.y * s;\\r\\n\\t\\t\\tthis._z = axis.z * s;\\r\\n\\t\\t\\tthis._w = Math.cos( halfAngle );\\r\\n\\r\\n\\t\\t\\tthis.onChangeCallback();\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFromRotationMatrix: function ( m ) {\\r\\n\\r\\n\\t\\t\\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\\r\\n\\r\\n\\t\\t\\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\\r\\n\\r\\n\\t\\t\\tvar te = m.elements,\\r\\n\\r\\n\\t\\t\\t\\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\\r\\n\\t\\t\\t\\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\\r\\n\\t\\t\\t\\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\\r\\n\\r\\n\\t\\t\\t\\ttrace = m11 + m22 + m33,\\r\\n\\t\\t\\t\\ts;\\r\\n\\r\\n\\t\\t\\tif ( trace > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\ts = 0.5 / Math.sqrt( trace + 1.0 );\\r\\n\\r\\n\\t\\t\\t\\tthis._w = 0.25 / s;\\r\\n\\t\\t\\t\\tthis._x = ( m32 - m23 ) * s;\\r\\n\\t\\t\\t\\tthis._y = ( m13 - m31 ) * s;\\r\\n\\t\\t\\t\\tthis._z = ( m21 - m12 ) * s;\\r\\n\\r\\n\\t\\t\\t} else if ( m11 > m22 && m11 > m33 ) {\\r\\n\\r\\n\\t\\t\\t\\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\\r\\n\\r\\n\\t\\t\\t\\tthis._w = ( m32 - m23 ) / s;\\r\\n\\t\\t\\t\\tthis._x = 0.25 * s;\\r\\n\\t\\t\\t\\tthis._y = ( m12 + m21 ) / s;\\r\\n\\t\\t\\t\\tthis._z = ( m13 + m31 ) / s;\\r\\n\\r\\n\\t\\t\\t} else if ( m22 > m33 ) {\\r\\n\\r\\n\\t\\t\\t\\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\\r\\n\\r\\n\\t\\t\\t\\tthis._w = ( m13 - m31 ) / s;\\r\\n\\t\\t\\t\\tthis._x = ( m12 + m21 ) / s;\\r\\n\\t\\t\\t\\tthis._y = 0.25 * s;\\r\\n\\t\\t\\t\\tthis._z = ( m23 + m32 ) / s;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\\r\\n\\r\\n\\t\\t\\t\\tthis._w = ( m21 - m12 ) / s;\\r\\n\\t\\t\\t\\tthis._x = ( m13 + m31 ) / s;\\r\\n\\t\\t\\t\\tthis._y = ( m23 + m32 ) / s;\\r\\n\\t\\t\\t\\tthis._z = 0.25 * s;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.onChangeCallback();\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFromUnitVectors: function () {\\r\\n\\r\\n\\t\\t\\t// assumes direction vectors vFrom and vTo are normalized\\r\\n\\r\\n\\t\\t\\tvar v1 = new Vector3();\\r\\n\\t\\t\\tvar r;\\r\\n\\r\\n\\t\\t\\tvar EPS = 0.000001;\\r\\n\\r\\n\\t\\t\\treturn function setFromUnitVectors( vFrom, vTo ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( v1 === undefined ) v1 = new Vector3();\\r\\n\\r\\n\\t\\t\\t\\tr = vFrom.dot( vTo ) + 1;\\r\\n\\r\\n\\t\\t\\t\\tif ( r < EPS ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tr = 0;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tv1.set( - vFrom.y, vFrom.x, 0 );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tv1.set( 0, - vFrom.z, vFrom.y );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tv1.crossVectors( vFrom, vTo );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tthis._x = v1.x;\\r\\n\\t\\t\\t\\tthis._y = v1.y;\\r\\n\\t\\t\\t\\tthis._z = v1.z;\\r\\n\\t\\t\\t\\tthis._w = r;\\r\\n\\r\\n\\t\\t\\t\\treturn this.normalize();\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tinverse: function () {\\r\\n\\r\\n\\t\\t\\treturn this.conjugate().normalize();\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tconjugate: function () {\\r\\n\\r\\n\\t\\t\\tthis._x *= - 1;\\r\\n\\t\\t\\tthis._y *= - 1;\\r\\n\\t\\t\\tthis._z *= - 1;\\r\\n\\r\\n\\t\\t\\tthis.onChangeCallback();\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdot: function ( v ) {\\r\\n\\r\\n\\t\\t\\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tlengthSq: function () {\\r\\n\\r\\n\\t\\t\\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tlength: function () {\\r\\n\\r\\n\\t\\t\\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tnormalize: function () {\\r\\n\\r\\n\\t\\t\\tvar l = this.length();\\r\\n\\r\\n\\t\\t\\tif ( l === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._x = 0;\\r\\n\\t\\t\\t\\tthis._y = 0;\\r\\n\\t\\t\\t\\tthis._z = 0;\\r\\n\\t\\t\\t\\tthis._w = 1;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tl = 1 / l;\\r\\n\\r\\n\\t\\t\\t\\tthis._x = this._x * l;\\r\\n\\t\\t\\t\\tthis._y = this._y * l;\\r\\n\\t\\t\\t\\tthis._z = this._z * l;\\r\\n\\t\\t\\t\\tthis._w = this._w * l;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.onChangeCallback();\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmultiply: function ( q, p ) {\\r\\n\\r\\n\\t\\t\\tif ( p !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\\r\\n\\t\\t\\t\\treturn this.multiplyQuaternions( q, p );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this.multiplyQuaternions( this, q );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tpremultiply: function ( q ) {\\r\\n\\r\\n\\t\\t\\treturn this.multiplyQuaternions( q, this );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmultiplyQuaternions: function ( a, b ) {\\r\\n\\r\\n\\t\\t\\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\\r\\n\\r\\n\\t\\t\\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\\r\\n\\t\\t\\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\\r\\n\\r\\n\\t\\t\\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\\r\\n\\t\\t\\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\\r\\n\\t\\t\\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\\r\\n\\t\\t\\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\\r\\n\\r\\n\\t\\t\\tthis.onChangeCallback();\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tslerp: function ( qb, t ) {\\r\\n\\r\\n\\t\\t\\tif ( t === 0 ) return this;\\r\\n\\t\\t\\tif ( t === 1 ) return this.copy( qb );\\r\\n\\r\\n\\t\\t\\tvar x = this._x, y = this._y, z = this._z, w = this._w;\\r\\n\\r\\n\\t\\t\\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\\r\\n\\r\\n\\t\\t\\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\\r\\n\\r\\n\\t\\t\\tif ( cosHalfTheta < 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._w = - qb._w;\\r\\n\\t\\t\\t\\tthis._x = - qb._x;\\r\\n\\t\\t\\t\\tthis._y = - qb._y;\\r\\n\\t\\t\\t\\tthis._z = - qb._z;\\r\\n\\r\\n\\t\\t\\t\\tcosHalfTheta = - cosHalfTheta;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tthis.copy( qb );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( cosHalfTheta >= 1.0 ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._w = w;\\r\\n\\t\\t\\t\\tthis._x = x;\\r\\n\\t\\t\\t\\tthis._y = y;\\r\\n\\t\\t\\t\\tthis._z = z;\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\\r\\n\\r\\n\\t\\t\\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._w = 0.5 * ( w + this._w );\\r\\n\\t\\t\\t\\tthis._x = 0.5 * ( x + this._x );\\r\\n\\t\\t\\t\\tthis._y = 0.5 * ( y + this._y );\\r\\n\\t\\t\\t\\tthis._z = 0.5 * ( z + this._z );\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\\r\\n\\t\\t\\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\\r\\n\\t\\t\\t\\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\\r\\n\\r\\n\\t\\t\\tthis._w = ( w * ratioA + this._w * ratioB );\\r\\n\\t\\t\\tthis._x = ( x * ratioA + this._x * ratioB );\\r\\n\\t\\t\\tthis._y = ( y * ratioA + this._y * ratioB );\\r\\n\\t\\t\\tthis._z = ( z * ratioA + this._z * ratioB );\\r\\n\\r\\n\\t\\t\\tthis.onChangeCallback();\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tequals: function ( quaternion ) {\\r\\n\\r\\n\\t\\t\\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tfromArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\t\\tthis._x = array[ offset ];\\r\\n\\t\\t\\tthis._y = array[ offset + 1 ];\\r\\n\\t\\t\\tthis._z = array[ offset + 2 ];\\r\\n\\t\\t\\tthis._w = array[ offset + 3 ];\\r\\n\\r\\n\\t\\t\\tthis.onChangeCallback();\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttoArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\t\\tif ( array === undefined ) array = [];\\r\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\t\\tarray[ offset ] = this._x;\\r\\n\\t\\t\\tarray[ offset + 1 ] = this._y;\\r\\n\\t\\t\\tarray[ offset + 2 ] = this._z;\\r\\n\\t\\t\\tarray[ offset + 3 ] = this._w;\\r\\n\\r\\n\\t\\t\\treturn array;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tonChange: function ( callback ) {\\r\\n\\r\\n\\t\\t\\tthis.onChangeCallback = callback;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tonChangeCallback: function () {}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author kile / http://kile.stravaganza.org/\\r\\n\\t * @author philogb / http://blog.thejit.org/\\r\\n\\t * @author mikael emtinger / http://gomo.se/\\r\\n\\t * @author egraether / http://egraether.com/\\r\\n\\t * @author WestLangley / http://github.com/WestLangley\\r\\n\\t */\\r\\n\\r\\n\\tfunction Vector3( x, y, z ) {\\r\\n\\r\\n\\t\\tthis.x = x || 0;\\r\\n\\t\\tthis.y = y || 0;\\r\\n\\t\\tthis.z = z || 0;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( Vector3.prototype, {\\r\\n\\r\\n\\t\\tisVector3: true,\\r\\n\\r\\n\\t\\tset: function ( x, y, z ) {\\r\\n\\r\\n\\t\\t\\tthis.x = x;\\r\\n\\t\\t\\tthis.y = y;\\r\\n\\t\\t\\tthis.z = z;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetScalar: function ( scalar ) {\\r\\n\\r\\n\\t\\t\\tthis.x = scalar;\\r\\n\\t\\t\\tthis.y = scalar;\\r\\n\\t\\t\\tthis.z = scalar;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetX: function ( x ) {\\r\\n\\r\\n\\t\\t\\tthis.x = x;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetY: function ( y ) {\\r\\n\\r\\n\\t\\t\\tthis.y = y;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetZ: function ( z ) {\\r\\n\\r\\n\\t\\t\\tthis.z = z;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetComponent: function ( index, value ) {\\r\\n\\r\\n\\t\\t\\tswitch ( index ) {\\r\\n\\r\\n\\t\\t\\t\\tcase 0: this.x = value; break;\\r\\n\\t\\t\\t\\tcase 1: this.y = value; break;\\r\\n\\t\\t\\t\\tcase 2: this.z = value; break;\\r\\n\\t\\t\\t\\tdefault: throw new Error( 'index is out of range: ' + index );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetComponent: function ( index ) {\\r\\n\\r\\n\\t\\t\\tswitch ( index ) {\\r\\n\\r\\n\\t\\t\\t\\tcase 0: return this.x;\\r\\n\\t\\t\\t\\tcase 1: return this.y;\\r\\n\\t\\t\\t\\tcase 2: return this.z;\\r\\n\\t\\t\\t\\tdefault: throw new Error( 'index is out of range: ' + index );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor( this.x, this.y, this.z );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( v ) {\\r\\n\\r\\n\\t\\t\\tthis.x = v.x;\\r\\n\\t\\t\\tthis.y = v.y;\\r\\n\\t\\t\\tthis.z = v.z;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tadd: function ( v, w ) {\\r\\n\\r\\n\\t\\t\\tif ( w !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\\r\\n\\t\\t\\t\\treturn this.addVectors( v, w );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.x += v.x;\\r\\n\\t\\t\\tthis.y += v.y;\\r\\n\\t\\t\\tthis.z += v.z;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\taddScalar: function ( s ) {\\r\\n\\r\\n\\t\\t\\tthis.x += s;\\r\\n\\t\\t\\tthis.y += s;\\r\\n\\t\\t\\tthis.z += s;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\taddVectors: function ( a, b ) {\\r\\n\\r\\n\\t\\t\\tthis.x = a.x + b.x;\\r\\n\\t\\t\\tthis.y = a.y + b.y;\\r\\n\\t\\t\\tthis.z = a.z + b.z;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\taddScaledVector: function ( v, s ) {\\r\\n\\r\\n\\t\\t\\tthis.x += v.x * s;\\r\\n\\t\\t\\tthis.y += v.y * s;\\r\\n\\t\\t\\tthis.z += v.z * s;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsub: function ( v, w ) {\\r\\n\\r\\n\\t\\t\\tif ( w !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\\r\\n\\t\\t\\t\\treturn this.subVectors( v, w );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.x -= v.x;\\r\\n\\t\\t\\tthis.y -= v.y;\\r\\n\\t\\t\\tthis.z -= v.z;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsubScalar: function ( s ) {\\r\\n\\r\\n\\t\\t\\tthis.x -= s;\\r\\n\\t\\t\\tthis.y -= s;\\r\\n\\t\\t\\tthis.z -= s;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsubVectors: function ( a, b ) {\\r\\n\\r\\n\\t\\t\\tthis.x = a.x - b.x;\\r\\n\\t\\t\\tthis.y = a.y - b.y;\\r\\n\\t\\t\\tthis.z = a.z - b.z;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmultiply: function ( v, w ) {\\r\\n\\r\\n\\t\\t\\tif ( w !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\\r\\n\\t\\t\\t\\treturn this.multiplyVectors( v, w );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.x *= v.x;\\r\\n\\t\\t\\tthis.y *= v.y;\\r\\n\\t\\t\\tthis.z *= v.z;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmultiplyScalar: function ( scalar ) {\\r\\n\\r\\n\\t\\t\\tthis.x *= scalar;\\r\\n\\t\\t\\tthis.y *= scalar;\\r\\n\\t\\t\\tthis.z *= scalar;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmultiplyVectors: function ( a, b ) {\\r\\n\\r\\n\\t\\t\\tthis.x = a.x * b.x;\\r\\n\\t\\t\\tthis.y = a.y * b.y;\\r\\n\\t\\t\\tthis.z = a.z * b.z;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tapplyEuler: function () {\\r\\n\\r\\n\\t\\t\\tvar quaternion = new Quaternion();\\r\\n\\r\\n\\t\\t\\treturn function applyEuler( euler ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( ! ( euler && euler.isEuler ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn this.applyQuaternion( quaternion.setFromEuler( euler ) );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tapplyAxisAngle: function () {\\r\\n\\r\\n\\t\\t\\tvar quaternion = new Quaternion();\\r\\n\\r\\n\\t\\t\\treturn function applyAxisAngle( axis, angle ) {\\r\\n\\r\\n\\t\\t\\t\\treturn this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tapplyMatrix3: function ( m ) {\\r\\n\\r\\n\\t\\t\\tvar x = this.x, y = this.y, z = this.z;\\r\\n\\t\\t\\tvar e = m.elements;\\r\\n\\r\\n\\t\\t\\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\\r\\n\\t\\t\\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\\r\\n\\t\\t\\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tapplyMatrix4: function ( m ) {\\r\\n\\r\\n\\t\\t\\tvar x = this.x, y = this.y, z = this.z;\\r\\n\\t\\t\\tvar e = m.elements;\\r\\n\\r\\n\\t\\t\\tvar w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );\\r\\n\\r\\n\\t\\t\\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;\\r\\n\\t\\t\\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;\\r\\n\\t\\t\\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tapplyQuaternion: function ( q ) {\\r\\n\\r\\n\\t\\t\\tvar x = this.x, y = this.y, z = this.z;\\r\\n\\t\\t\\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\\r\\n\\r\\n\\t\\t\\t// calculate quat * vector\\r\\n\\r\\n\\t\\t\\tvar ix = qw * x + qy * z - qz * y;\\r\\n\\t\\t\\tvar iy = qw * y + qz * x - qx * z;\\r\\n\\t\\t\\tvar iz = qw * z + qx * y - qy * x;\\r\\n\\t\\t\\tvar iw = - qx * x - qy * y - qz * z;\\r\\n\\r\\n\\t\\t\\t// calculate result * inverse quat\\r\\n\\r\\n\\t\\t\\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\\r\\n\\t\\t\\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\\r\\n\\t\\t\\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tproject: function () {\\r\\n\\r\\n\\t\\t\\tvar matrix = new Matrix4();\\r\\n\\r\\n\\t\\t\\treturn function project( camera ) {\\r\\n\\r\\n\\t\\t\\t\\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\\r\\n\\t\\t\\t\\treturn this.applyMatrix4( matrix );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tunproject: function () {\\r\\n\\r\\n\\t\\t\\tvar matrix = new Matrix4();\\r\\n\\r\\n\\t\\t\\treturn function unproject( camera ) {\\r\\n\\r\\n\\t\\t\\t\\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\\r\\n\\t\\t\\t\\treturn this.applyMatrix4( matrix );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\ttransformDirection: function ( m ) {\\r\\n\\r\\n\\t\\t\\t// input: THREE.Matrix4 affine matrix\\r\\n\\t\\t\\t// vector interpreted as a direction\\r\\n\\r\\n\\t\\t\\tvar x = this.x, y = this.y, z = this.z;\\r\\n\\t\\t\\tvar e = m.elements;\\r\\n\\r\\n\\t\\t\\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\\r\\n\\t\\t\\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\\r\\n\\t\\t\\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\\r\\n\\r\\n\\t\\t\\treturn this.normalize();\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdivide: function ( v ) {\\r\\n\\r\\n\\t\\t\\tthis.x /= v.x;\\r\\n\\t\\t\\tthis.y /= v.y;\\r\\n\\t\\t\\tthis.z /= v.z;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdivideScalar: function ( scalar ) {\\r\\n\\r\\n\\t\\t\\treturn this.multiplyScalar( 1 / scalar );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmin: function ( v ) {\\r\\n\\r\\n\\t\\t\\tthis.x = Math.min( this.x, v.x );\\r\\n\\t\\t\\tthis.y = Math.min( this.y, v.y );\\r\\n\\t\\t\\tthis.z = Math.min( this.z, v.z );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmax: function ( v ) {\\r\\n\\r\\n\\t\\t\\tthis.x = Math.max( this.x, v.x );\\r\\n\\t\\t\\tthis.y = Math.max( this.y, v.y );\\r\\n\\t\\t\\tthis.z = Math.max( this.z, v.z );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclamp: function ( min, max ) {\\r\\n\\r\\n\\t\\t\\t// assumes min < max, componentwise\\r\\n\\r\\n\\t\\t\\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\\r\\n\\t\\t\\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\\r\\n\\t\\t\\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclampScalar: function () {\\r\\n\\r\\n\\t\\t\\tvar min = new Vector3();\\r\\n\\t\\t\\tvar max = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function clampScalar( minVal, maxVal ) {\\r\\n\\r\\n\\t\\t\\t\\tmin.set( minVal, minVal, minVal );\\r\\n\\t\\t\\t\\tmax.set( maxVal, maxVal, maxVal );\\r\\n\\r\\n\\t\\t\\t\\treturn this.clamp( min, max );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tclampLength: function ( min, max ) {\\r\\n\\r\\n\\t\\t\\tvar length = this.length();\\r\\n\\r\\n\\t\\t\\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tfloor: function () {\\r\\n\\r\\n\\t\\t\\tthis.x = Math.floor( this.x );\\r\\n\\t\\t\\tthis.y = Math.floor( this.y );\\r\\n\\t\\t\\tthis.z = Math.floor( this.z );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tceil: function () {\\r\\n\\r\\n\\t\\t\\tthis.x = Math.ceil( this.x );\\r\\n\\t\\t\\tthis.y = Math.ceil( this.y );\\r\\n\\t\\t\\tthis.z = Math.ceil( this.z );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tround: function () {\\r\\n\\r\\n\\t\\t\\tthis.x = Math.round( this.x );\\r\\n\\t\\t\\tthis.y = Math.round( this.y );\\r\\n\\t\\t\\tthis.z = Math.round( this.z );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\troundToZero: function () {\\r\\n\\r\\n\\t\\t\\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\\r\\n\\t\\t\\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\\r\\n\\t\\t\\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tnegate: function () {\\r\\n\\r\\n\\t\\t\\tthis.x = - this.x;\\r\\n\\t\\t\\tthis.y = - this.y;\\r\\n\\t\\t\\tthis.z = - this.z;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdot: function ( v ) {\\r\\n\\r\\n\\t\\t\\treturn this.x * v.x + this.y * v.y + this.z * v.z;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// TODO lengthSquared?\\r\\n\\r\\n\\t\\tlengthSq: function () {\\r\\n\\r\\n\\t\\t\\treturn this.x * this.x + this.y * this.y + this.z * this.z;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tlength: function () {\\r\\n\\r\\n\\t\\t\\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmanhattanLength: function () {\\r\\n\\r\\n\\t\\t\\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tnormalize: function () {\\r\\n\\r\\n\\t\\t\\treturn this.divideScalar( this.length() || 1 );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetLength: function ( length ) {\\r\\n\\r\\n\\t\\t\\treturn this.normalize().multiplyScalar( length );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tlerp: function ( v, alpha ) {\\r\\n\\r\\n\\t\\t\\tthis.x += ( v.x - this.x ) * alpha;\\r\\n\\t\\t\\tthis.y += ( v.y - this.y ) * alpha;\\r\\n\\t\\t\\tthis.z += ( v.z - this.z ) * alpha;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tlerpVectors: function ( v1, v2, alpha ) {\\r\\n\\r\\n\\t\\t\\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcross: function ( v, w ) {\\r\\n\\r\\n\\t\\t\\tif ( w !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\\r\\n\\t\\t\\t\\treturn this.crossVectors( v, w );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this.crossVectors( this, v );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcrossVectors: function ( a, b ) {\\r\\n\\r\\n\\t\\t\\tvar ax = a.x, ay = a.y, az = a.z;\\r\\n\\t\\t\\tvar bx = b.x, by = b.y, bz = b.z;\\r\\n\\r\\n\\t\\t\\tthis.x = ay * bz - az * by;\\r\\n\\t\\t\\tthis.y = az * bx - ax * bz;\\r\\n\\t\\t\\tthis.z = ax * by - ay * bx;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tprojectOnVector: function ( vector ) {\\r\\n\\r\\n\\t\\t\\tvar scalar = vector.dot( this ) / vector.lengthSq();\\r\\n\\r\\n\\t\\t\\treturn this.copy( vector ).multiplyScalar( scalar );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tprojectOnPlane: function () {\\r\\n\\r\\n\\t\\t\\tvar v1 = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function projectOnPlane( planeNormal ) {\\r\\n\\r\\n\\t\\t\\t\\tv1.copy( this ).projectOnVector( planeNormal );\\r\\n\\r\\n\\t\\t\\t\\treturn this.sub( v1 );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\treflect: function () {\\r\\n\\r\\n\\t\\t\\t// reflect incident vector off plane orthogonal to normal\\r\\n\\t\\t\\t// normal is assumed to have unit length\\r\\n\\r\\n\\t\\t\\tvar v1 = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function reflect( normal ) {\\r\\n\\r\\n\\t\\t\\t\\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tangleTo: function ( v ) {\\r\\n\\r\\n\\t\\t\\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\\r\\n\\r\\n\\t\\t\\t// clamp, to handle numerical problems\\r\\n\\r\\n\\t\\t\\treturn Math.acos( _Math.clamp( theta, - 1, 1 ) );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdistanceTo: function ( v ) {\\r\\n\\r\\n\\t\\t\\treturn Math.sqrt( this.distanceToSquared( v ) );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdistanceToSquared: function ( v ) {\\r\\n\\r\\n\\t\\t\\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\\r\\n\\r\\n\\t\\t\\treturn dx * dx + dy * dy + dz * dz;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmanhattanDistanceTo: function ( v ) {\\r\\n\\r\\n\\t\\t\\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFromSpherical: function ( s ) {\\r\\n\\r\\n\\t\\t\\tvar sinPhiRadius = Math.sin( s.phi ) * s.radius;\\r\\n\\r\\n\\t\\t\\tthis.x = sinPhiRadius * Math.sin( s.theta );\\r\\n\\t\\t\\tthis.y = Math.cos( s.phi ) * s.radius;\\r\\n\\t\\t\\tthis.z = sinPhiRadius * Math.cos( s.theta );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFromCylindrical: function ( c ) {\\r\\n\\r\\n\\t\\t\\tthis.x = c.radius * Math.sin( c.theta );\\r\\n\\t\\t\\tthis.y = c.y;\\r\\n\\t\\t\\tthis.z = c.radius * Math.cos( c.theta );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFromMatrixPosition: function ( m ) {\\r\\n\\r\\n\\t\\t\\tvar e = m.elements;\\r\\n\\r\\n\\t\\t\\tthis.x = e[ 12 ];\\r\\n\\t\\t\\tthis.y = e[ 13 ];\\r\\n\\t\\t\\tthis.z = e[ 14 ];\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFromMatrixScale: function ( m ) {\\r\\n\\r\\n\\t\\t\\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\\r\\n\\t\\t\\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\\r\\n\\t\\t\\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\\r\\n\\r\\n\\t\\t\\tthis.x = sx;\\r\\n\\t\\t\\tthis.y = sy;\\r\\n\\t\\t\\tthis.z = sz;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFromMatrixColumn: function ( m, index ) {\\r\\n\\r\\n\\t\\t\\treturn this.fromArray( m.elements, index * 4 );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tequals: function ( v ) {\\r\\n\\r\\n\\t\\t\\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tfromArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\t\\tthis.x = array[ offset ];\\r\\n\\t\\t\\tthis.y = array[ offset + 1 ];\\r\\n\\t\\t\\tthis.z = array[ offset + 2 ];\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttoArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\t\\tif ( array === undefined ) array = [];\\r\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\t\\tarray[ offset ] = this.x;\\r\\n\\t\\t\\tarray[ offset + 1 ] = this.y;\\r\\n\\t\\t\\tarray[ offset + 2 ] = this.z;\\r\\n\\r\\n\\t\\t\\treturn array;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tfromBufferAttribute: function ( attribute, index, offset ) {\\r\\n\\r\\n\\t\\t\\tif ( offset !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.x = attribute.getX( index );\\r\\n\\t\\t\\tthis.y = attribute.getY( index );\\r\\n\\t\\t\\tthis.z = attribute.getZ( index );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t * @author WestLangley / http://github.com/WestLangley\\r\\n\\t * @author bhouston / http://clara.io\\r\\n\\t * @author tschw\\r\\n\\t */\\r\\n\\r\\n\\tfunction Matrix3() {\\r\\n\\r\\n\\t\\tthis.elements = [\\r\\n\\r\\n\\t\\t\\t1, 0, 0,\\r\\n\\t\\t\\t0, 1, 0,\\r\\n\\t\\t\\t0, 0, 1\\r\\n\\r\\n\\t\\t];\\r\\n\\r\\n\\t\\tif ( arguments.length > 0 ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( Matrix3.prototype, {\\r\\n\\r\\n\\t\\tisMatrix3: true,\\r\\n\\r\\n\\t\\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\\r\\n\\r\\n\\t\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\t\\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\\r\\n\\t\\t\\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\\r\\n\\t\\t\\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tidentity: function () {\\r\\n\\r\\n\\t\\t\\tthis.set(\\r\\n\\r\\n\\t\\t\\t\\t1, 0, 0,\\r\\n\\t\\t\\t\\t0, 1, 0,\\r\\n\\t\\t\\t\\t0, 0, 1\\r\\n\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor().fromArray( this.elements );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( m ) {\\r\\n\\r\\n\\t\\t\\tvar te = this.elements;\\r\\n\\t\\t\\tvar me = m.elements;\\r\\n\\r\\n\\t\\t\\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];\\r\\n\\t\\t\\tte[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];\\r\\n\\t\\t\\tte[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFromMatrix4: function ( m ) {\\r\\n\\r\\n\\t\\t\\tvar me = m.elements;\\r\\n\\r\\n\\t\\t\\tthis.set(\\r\\n\\r\\n\\t\\t\\t\\tme[ 0 ], me[ 4 ], me[ 8 ],\\r\\n\\t\\t\\t\\tme[ 1 ], me[ 5 ], me[ 9 ],\\r\\n\\t\\t\\t\\tme[ 2 ], me[ 6 ], me[ 10 ]\\r\\n\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tapplyToBufferAttribute: function () {\\r\\n\\r\\n\\t\\t\\tvar v1 = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function applyToBufferAttribute( attribute ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tv1.x = attribute.getX( i );\\r\\n\\t\\t\\t\\t\\tv1.y = attribute.getY( i );\\r\\n\\t\\t\\t\\t\\tv1.z = attribute.getZ( i );\\r\\n\\r\\n\\t\\t\\t\\t\\tv1.applyMatrix3( this );\\r\\n\\r\\n\\t\\t\\t\\t\\tattribute.setXYZ( i, v1.x, v1.y, v1.z );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn attribute;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tmultiply: function ( m ) {\\r\\n\\r\\n\\t\\t\\treturn this.multiplyMatrices( this, m );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tpremultiply: function ( m ) {\\r\\n\\r\\n\\t\\t\\treturn this.multiplyMatrices( m, this );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmultiplyMatrices: function ( a, b ) {\\r\\n\\r\\n\\t\\t\\tvar ae = a.elements;\\r\\n\\t\\t\\tvar be = b.elements;\\r\\n\\t\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\t\\tvar a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];\\r\\n\\t\\t\\tvar a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];\\r\\n\\t\\t\\tvar a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];\\r\\n\\r\\n\\t\\t\\tvar b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];\\r\\n\\t\\t\\tvar b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];\\r\\n\\t\\t\\tvar b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];\\r\\n\\r\\n\\t\\t\\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;\\r\\n\\t\\t\\tte[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;\\r\\n\\t\\t\\tte[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;\\r\\n\\r\\n\\t\\t\\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;\\r\\n\\t\\t\\tte[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;\\r\\n\\t\\t\\tte[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;\\r\\n\\r\\n\\t\\t\\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;\\r\\n\\t\\t\\tte[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;\\r\\n\\t\\t\\tte[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmultiplyScalar: function ( s ) {\\r\\n\\r\\n\\t\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\t\\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\\r\\n\\t\\t\\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\\r\\n\\t\\t\\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdeterminant: function () {\\r\\n\\r\\n\\t\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\t\\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\\r\\n\\t\\t\\t\\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\\r\\n\\t\\t\\t\\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\\r\\n\\r\\n\\t\\t\\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetInverse: function ( matrix, throwOnDegenerate ) {\\r\\n\\r\\n\\t\\t\\tif ( matrix && matrix.isMatrix4 ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( \\\"THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.\\\" );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar me = matrix.elements,\\r\\n\\t\\t\\t\\tte = this.elements,\\r\\n\\r\\n\\t\\t\\t\\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\\r\\n\\t\\t\\t\\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\\r\\n\\t\\t\\t\\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\\r\\n\\r\\n\\t\\t\\t\\tt11 = n33 * n22 - n32 * n23,\\r\\n\\t\\t\\t\\tt12 = n32 * n13 - n33 * n12,\\r\\n\\t\\t\\t\\tt13 = n23 * n12 - n22 * n13,\\r\\n\\r\\n\\t\\t\\t\\tdet = n11 * t11 + n21 * t12 + n31 * t13;\\r\\n\\r\\n\\t\\t\\tif ( det === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tvar msg = \\\"THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0\\\";\\r\\n\\r\\n\\t\\t\\t\\tif ( throwOnDegenerate === true ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthrow new Error( msg );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( msg );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn this.identity();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar detInv = 1 / det;\\r\\n\\r\\n\\t\\t\\tte[ 0 ] = t11 * detInv;\\r\\n\\t\\t\\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\\r\\n\\t\\t\\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\\r\\n\\r\\n\\t\\t\\tte[ 3 ] = t12 * detInv;\\r\\n\\t\\t\\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\\r\\n\\t\\t\\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\\r\\n\\r\\n\\t\\t\\tte[ 6 ] = t13 * detInv;\\r\\n\\t\\t\\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\\r\\n\\t\\t\\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttranspose: function () {\\r\\n\\r\\n\\t\\t\\tvar tmp, m = this.elements;\\r\\n\\r\\n\\t\\t\\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\\r\\n\\t\\t\\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\\r\\n\\t\\t\\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetNormalMatrix: function ( matrix4 ) {\\r\\n\\r\\n\\t\\t\\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttransposeIntoArray: function ( r ) {\\r\\n\\r\\n\\t\\t\\tvar m = this.elements;\\r\\n\\r\\n\\t\\t\\tr[ 0 ] = m[ 0 ];\\r\\n\\t\\t\\tr[ 1 ] = m[ 3 ];\\r\\n\\t\\t\\tr[ 2 ] = m[ 6 ];\\r\\n\\t\\t\\tr[ 3 ] = m[ 1 ];\\r\\n\\t\\t\\tr[ 4 ] = m[ 4 ];\\r\\n\\t\\t\\tr[ 5 ] = m[ 7 ];\\r\\n\\t\\t\\tr[ 6 ] = m[ 2 ];\\r\\n\\t\\t\\tr[ 7 ] = m[ 5 ];\\r\\n\\t\\t\\tr[ 8 ] = m[ 8 ];\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {\\r\\n\\r\\n\\t\\t\\tvar c = Math.cos( rotation );\\r\\n\\t\\t\\tvar s = Math.sin( rotation );\\r\\n\\r\\n\\t\\t\\tthis.set(\\r\\n\\t\\t\\t\\tsx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,\\r\\n\\t\\t\\t\\t- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,\\r\\n\\t\\t\\t\\t0, 0, 1\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tscale: function ( sx, sy ) {\\r\\n\\r\\n\\t\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\t\\tte[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;\\r\\n\\t\\t\\tte[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\trotate: function ( theta ) {\\r\\n\\r\\n\\t\\t\\tvar c = Math.cos( theta );\\r\\n\\t\\t\\tvar s = Math.sin( theta );\\r\\n\\r\\n\\t\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\t\\tvar a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];\\r\\n\\t\\t\\tvar a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];\\r\\n\\r\\n\\t\\t\\tte[ 0 ] = c * a11 + s * a21;\\r\\n\\t\\t\\tte[ 3 ] = c * a12 + s * a22;\\r\\n\\t\\t\\tte[ 6 ] = c * a13 + s * a23;\\r\\n\\r\\n\\t\\t\\tte[ 1 ] = - s * a11 + c * a21;\\r\\n\\t\\t\\tte[ 4 ] = - s * a12 + c * a22;\\r\\n\\t\\t\\tte[ 7 ] = - s * a13 + c * a23;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttranslate: function ( tx, ty ) {\\r\\n\\r\\n\\t\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\t\\tte[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];\\r\\n\\t\\t\\tte[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tequals: function ( matrix ) {\\r\\n\\r\\n\\t\\t\\tvar te = this.elements;\\r\\n\\t\\t\\tvar me = matrix.elements;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < 9; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( te[ i ] !== me[ i ] ) return false;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn true;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tfromArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < 9; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.elements[ i ] = array[ i + offset ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttoArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\t\\tif ( array === undefined ) array = [];\\r\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\t\\tarray[ offset ] = te[ 0 ];\\r\\n\\t\\t\\tarray[ offset + 1 ] = te[ 1 ];\\r\\n\\t\\t\\tarray[ offset + 2 ] = te[ 2 ];\\r\\n\\r\\n\\t\\t\\tarray[ offset + 3 ] = te[ 3 ];\\r\\n\\t\\t\\tarray[ offset + 4 ] = te[ 4 ];\\r\\n\\t\\t\\tarray[ offset + 5 ] = te[ 5 ];\\r\\n\\r\\n\\t\\t\\tarray[ offset + 6 ] = te[ 6 ];\\r\\n\\t\\t\\tarray[ offset + 7 ] = te[ 7 ];\\r\\n\\t\\t\\tarray[ offset + 8 ] = te[ 8 ];\\r\\n\\r\\n\\t\\t\\treturn array;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t * @author szimek / https://github.com/szimek/\\r\\n\\t */\\r\\n\\r\\n\\tvar textureId = 0;\\r\\n\\r\\n\\tfunction Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\\r\\n\\r\\n\\t\\tObject.defineProperty( this, 'id', { value: textureId ++ } );\\r\\n\\r\\n\\t\\tthis.uuid = _Math.generateUUID();\\r\\n\\r\\n\\t\\tthis.name = '';\\r\\n\\r\\n\\t\\tthis.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;\\r\\n\\t\\tthis.mipmaps = [];\\r\\n\\r\\n\\t\\tthis.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;\\r\\n\\r\\n\\t\\tthis.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;\\r\\n\\t\\tthis.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;\\r\\n\\r\\n\\t\\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\\r\\n\\t\\tthis.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;\\r\\n\\r\\n\\t\\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\\r\\n\\r\\n\\t\\tthis.format = format !== undefined ? format : RGBAFormat;\\r\\n\\t\\tthis.type = type !== undefined ? type : UnsignedByteType;\\r\\n\\r\\n\\t\\tthis.offset = new Vector2( 0, 0 );\\r\\n\\t\\tthis.repeat = new Vector2( 1, 1 );\\r\\n\\t\\tthis.center = new Vector2( 0, 0 );\\r\\n\\t\\tthis.rotation = 0;\\r\\n\\r\\n\\t\\tthis.matrixAutoUpdate = true;\\r\\n\\t\\tthis.matrix = new Matrix3();\\r\\n\\r\\n\\t\\tthis.generateMipmaps = true;\\r\\n\\t\\tthis.premultiplyAlpha = false;\\r\\n\\t\\tthis.flipY = true;\\r\\n\\t\\tthis.unpackAlignment = 4;\\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\\r\\n\\r\\n\\t\\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\\r\\n\\t\\t//\\r\\n\\t\\t// Also changing the encoding after already used by a Material will not automatically make the Material\\r\\n\\t\\t// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\\r\\n\\t\\tthis.encoding = encoding !== undefined ? encoding : LinearEncoding;\\r\\n\\r\\n\\t\\tthis.version = 0;\\r\\n\\t\\tthis.onUpdate = null;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tTexture.DEFAULT_IMAGE = undefined;\\r\\n\\tTexture.DEFAULT_MAPPING = UVMapping;\\r\\n\\r\\n\\tTexture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: Texture,\\r\\n\\r\\n\\t\\tisTexture: true,\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\t\\tthis.name = source.name;\\r\\n\\r\\n\\t\\t\\tthis.image = source.image;\\r\\n\\t\\t\\tthis.mipmaps = source.mipmaps.slice( 0 );\\r\\n\\r\\n\\t\\t\\tthis.mapping = source.mapping;\\r\\n\\r\\n\\t\\t\\tthis.wrapS = source.wrapS;\\r\\n\\t\\t\\tthis.wrapT = source.wrapT;\\r\\n\\r\\n\\t\\t\\tthis.magFilter = source.magFilter;\\r\\n\\t\\t\\tthis.minFilter = source.minFilter;\\r\\n\\r\\n\\t\\t\\tthis.anisotropy = source.anisotropy;\\r\\n\\r\\n\\t\\t\\tthis.format = source.format;\\r\\n\\t\\t\\tthis.type = source.type;\\r\\n\\r\\n\\t\\t\\tthis.offset.copy( source.offset );\\r\\n\\t\\t\\tthis.repeat.copy( source.repeat );\\r\\n\\t\\t\\tthis.center.copy( source.center );\\r\\n\\t\\t\\tthis.rotation = source.rotation;\\r\\n\\r\\n\\t\\t\\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\\r\\n\\t\\t\\tthis.matrix.copy( source.matrix );\\r\\n\\r\\n\\t\\t\\tthis.generateMipmaps = source.generateMipmaps;\\r\\n\\t\\t\\tthis.premultiplyAlpha = source.premultiplyAlpha;\\r\\n\\t\\t\\tthis.flipY = source.flipY;\\r\\n\\t\\t\\tthis.unpackAlignment = source.unpackAlignment;\\r\\n\\t\\t\\tthis.encoding = source.encoding;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttoJSON: function ( meta ) {\\r\\n\\r\\n\\t\\t\\tvar isRootObject = ( meta === undefined || typeof meta === 'string' );\\r\\n\\r\\n\\t\\t\\tif ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\treturn meta.textures[ this.uuid ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfunction getDataURL( image ) {\\r\\n\\r\\n\\t\\t\\t\\tvar canvas;\\r\\n\\r\\n\\t\\t\\t\\tif ( image instanceof HTMLCanvasElement ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcanvas = image;\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tcanvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\\r\\n\\t\\t\\t\\t\\tcanvas.width = image.width;\\r\\n\\t\\t\\t\\t\\tcanvas.height = image.height;\\r\\n\\r\\n\\t\\t\\t\\t\\tvar context = canvas.getContext( '2d' );\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( image instanceof ImageData ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcontext.putImageData( image, 0, 0 );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcontext.drawImage( image, 0, 0, image.width, image.height );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn canvas.toDataURL( 'image/png' );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar output = {\\r\\n\\t\\t\\t\\tmetadata: {\\r\\n\\t\\t\\t\\t\\tversion: 4.5,\\r\\n\\t\\t\\t\\t\\ttype: 'Texture',\\r\\n\\t\\t\\t\\t\\tgenerator: 'Texture.toJSON'\\r\\n\\t\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t\\tuuid: this.uuid,\\r\\n\\t\\t\\t\\tname: this.name,\\r\\n\\r\\n\\t\\t\\t\\tmapping: this.mapping,\\r\\n\\r\\n\\t\\t\\t\\trepeat: [ this.repeat.x, this.repeat.y ],\\r\\n\\t\\t\\t\\toffset: [ this.offset.x, this.offset.y ],\\r\\n\\t\\t\\t\\tcenter: [ this.center.x, this.center.y ],\\r\\n\\t\\t\\t\\trotation: this.rotation,\\r\\n\\r\\n\\t\\t\\t\\twrap: [ this.wrapS, this.wrapT ],\\r\\n\\r\\n\\t\\t\\t\\tminFilter: this.minFilter,\\r\\n\\t\\t\\t\\tmagFilter: this.magFilter,\\r\\n\\t\\t\\t\\tanisotropy: this.anisotropy,\\r\\n\\r\\n\\t\\t\\t\\tflipY: this.flipY\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\tif ( this.image !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t// TODO: Move to THREE.Image\\r\\n\\r\\n\\t\\t\\t\\tvar image = this.image;\\r\\n\\r\\n\\t\\t\\t\\tif ( image.uuid === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\timage.uuid = _Math.generateUUID(); // UGH\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tmeta.images[ image.uuid ] = {\\r\\n\\t\\t\\t\\t\\t\\tuuid: image.uuid,\\r\\n\\t\\t\\t\\t\\t\\turl: getDataURL( image )\\r\\n\\t\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\toutput.image = image.uuid;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( ! isRootObject ) {\\r\\n\\r\\n\\t\\t\\t\\tmeta.textures[ this.uuid ] = output;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn output;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdispose: function () {\\r\\n\\r\\n\\t\\t\\tthis.dispatchEvent( { type: 'dispose' } );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttransformUv: function ( uv ) {\\r\\n\\r\\n\\t\\t\\tif ( this.mapping !== UVMapping ) return;\\r\\n\\r\\n\\t\\t\\tuv.applyMatrix3( this.matrix );\\r\\n\\r\\n\\t\\t\\tif ( uv.x < 0 || uv.x > 1 ) {\\r\\n\\r\\n\\t\\t\\t\\tswitch ( this.wrapS ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcase RepeatWrapping:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tuv.x = uv.x - Math.floor( uv.x );\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase ClampToEdgeWrapping:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tuv.x = uv.x < 0 ? 0 : 1;\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase MirroredRepeatWrapping:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tuv.x = Math.ceil( uv.x ) - uv.x;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tuv.x = uv.x - Math.floor( uv.x );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( uv.y < 0 || uv.y > 1 ) {\\r\\n\\r\\n\\t\\t\\t\\tswitch ( this.wrapT ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcase RepeatWrapping:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tuv.y = uv.y - Math.floor( uv.y );\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase ClampToEdgeWrapping:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tuv.y = uv.y < 0 ? 0 : 1;\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase MirroredRepeatWrapping:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tuv.y = Math.ceil( uv.y ) - uv.y;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tuv.y = uv.y - Math.floor( uv.y );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( this.flipY ) {\\r\\n\\r\\n\\t\\t\\t\\tuv.y = 1 - uv.y;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tObject.defineProperty( Texture.prototype, \\\"needsUpdate\\\", {\\r\\n\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tif ( value === true ) this.version ++;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author supereggbert / http://www.paulbrunt.co.uk/\\r\\n\\t * @author philogb / http://blog.thejit.org/\\r\\n\\t * @author mikael emtinger / http://gomo.se/\\r\\n\\t * @author egraether / http://egraether.com/\\r\\n\\t * @author WestLangley / http://github.com/WestLangley\\r\\n\\t */\\r\\n\\r\\n\\tfunction Vector4( x, y, z, w ) {\\r\\n\\r\\n\\t\\tthis.x = x || 0;\\r\\n\\t\\tthis.y = y || 0;\\r\\n\\t\\tthis.z = z || 0;\\r\\n\\t\\tthis.w = ( w !== undefined ) ? w : 1;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( Vector4.prototype, {\\r\\n\\r\\n\\t\\tisVector4: true,\\r\\n\\r\\n\\t\\tset: function ( x, y, z, w ) {\\r\\n\\r\\n\\t\\t\\tthis.x = x;\\r\\n\\t\\t\\tthis.y = y;\\r\\n\\t\\t\\tthis.z = z;\\r\\n\\t\\t\\tthis.w = w;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetScalar: function ( scalar ) {\\r\\n\\r\\n\\t\\t\\tthis.x = scalar;\\r\\n\\t\\t\\tthis.y = scalar;\\r\\n\\t\\t\\tthis.z = scalar;\\r\\n\\t\\t\\tthis.w = scalar;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetX: function ( x ) {\\r\\n\\r\\n\\t\\t\\tthis.x = x;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetY: function ( y ) {\\r\\n\\r\\n\\t\\t\\tthis.y = y;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetZ: function ( z ) {\\r\\n\\r\\n\\t\\t\\tthis.z = z;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetW: function ( w ) {\\r\\n\\r\\n\\t\\t\\tthis.w = w;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetComponent: function ( index, value ) {\\r\\n\\r\\n\\t\\t\\tswitch ( index ) {\\r\\n\\r\\n\\t\\t\\t\\tcase 0: this.x = value; break;\\r\\n\\t\\t\\t\\tcase 1: this.y = value; break;\\r\\n\\t\\t\\t\\tcase 2: this.z = value; break;\\r\\n\\t\\t\\t\\tcase 3: this.w = value; break;\\r\\n\\t\\t\\t\\tdefault: throw new Error( 'index is out of range: ' + index );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetComponent: function ( index ) {\\r\\n\\r\\n\\t\\t\\tswitch ( index ) {\\r\\n\\r\\n\\t\\t\\t\\tcase 0: return this.x;\\r\\n\\t\\t\\t\\tcase 1: return this.y;\\r\\n\\t\\t\\t\\tcase 2: return this.z;\\r\\n\\t\\t\\t\\tcase 3: return this.w;\\r\\n\\t\\t\\t\\tdefault: throw new Error( 'index is out of range: ' + index );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor( this.x, this.y, this.z, this.w );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( v ) {\\r\\n\\r\\n\\t\\t\\tthis.x = v.x;\\r\\n\\t\\t\\tthis.y = v.y;\\r\\n\\t\\t\\tthis.z = v.z;\\r\\n\\t\\t\\tthis.w = ( v.w !== undefined ) ? v.w : 1;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tadd: function ( v, w ) {\\r\\n\\r\\n\\t\\t\\tif ( w !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\\r\\n\\t\\t\\t\\treturn this.addVectors( v, w );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.x += v.x;\\r\\n\\t\\t\\tthis.y += v.y;\\r\\n\\t\\t\\tthis.z += v.z;\\r\\n\\t\\t\\tthis.w += v.w;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\taddScalar: function ( s ) {\\r\\n\\r\\n\\t\\t\\tthis.x += s;\\r\\n\\t\\t\\tthis.y += s;\\r\\n\\t\\t\\tthis.z += s;\\r\\n\\t\\t\\tthis.w += s;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\taddVectors: function ( a, b ) {\\r\\n\\r\\n\\t\\t\\tthis.x = a.x + b.x;\\r\\n\\t\\t\\tthis.y = a.y + b.y;\\r\\n\\t\\t\\tthis.z = a.z + b.z;\\r\\n\\t\\t\\tthis.w = a.w + b.w;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\taddScaledVector: function ( v, s ) {\\r\\n\\r\\n\\t\\t\\tthis.x += v.x * s;\\r\\n\\t\\t\\tthis.y += v.y * s;\\r\\n\\t\\t\\tthis.z += v.z * s;\\r\\n\\t\\t\\tthis.w += v.w * s;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsub: function ( v, w ) {\\r\\n\\r\\n\\t\\t\\tif ( w !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\\r\\n\\t\\t\\t\\treturn this.subVectors( v, w );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.x -= v.x;\\r\\n\\t\\t\\tthis.y -= v.y;\\r\\n\\t\\t\\tthis.z -= v.z;\\r\\n\\t\\t\\tthis.w -= v.w;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsubScalar: function ( s ) {\\r\\n\\r\\n\\t\\t\\tthis.x -= s;\\r\\n\\t\\t\\tthis.y -= s;\\r\\n\\t\\t\\tthis.z -= s;\\r\\n\\t\\t\\tthis.w -= s;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsubVectors: function ( a, b ) {\\r\\n\\r\\n\\t\\t\\tthis.x = a.x - b.x;\\r\\n\\t\\t\\tthis.y = a.y - b.y;\\r\\n\\t\\t\\tthis.z = a.z - b.z;\\r\\n\\t\\t\\tthis.w = a.w - b.w;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmultiplyScalar: function ( scalar ) {\\r\\n\\r\\n\\t\\t\\tthis.x *= scalar;\\r\\n\\t\\t\\tthis.y *= scalar;\\r\\n\\t\\t\\tthis.z *= scalar;\\r\\n\\t\\t\\tthis.w *= scalar;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tapplyMatrix4: function ( m ) {\\r\\n\\r\\n\\t\\t\\tvar x = this.x, y = this.y, z = this.z, w = this.w;\\r\\n\\t\\t\\tvar e = m.elements;\\r\\n\\r\\n\\t\\t\\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\\r\\n\\t\\t\\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\\r\\n\\t\\t\\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\\r\\n\\t\\t\\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdivideScalar: function ( scalar ) {\\r\\n\\r\\n\\t\\t\\treturn this.multiplyScalar( 1 / scalar );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetAxisAngleFromQuaternion: function ( q ) {\\r\\n\\r\\n\\t\\t\\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\\r\\n\\r\\n\\t\\t\\t// q is assumed to be normalized\\r\\n\\r\\n\\t\\t\\tthis.w = 2 * Math.acos( q.w );\\r\\n\\r\\n\\t\\t\\tvar s = Math.sqrt( 1 - q.w * q.w );\\r\\n\\r\\n\\t\\t\\tif ( s < 0.0001 ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.x = 1;\\r\\n\\t\\t\\t\\tthis.y = 0;\\r\\n\\t\\t\\t\\tthis.z = 0;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tthis.x = q.x / s;\\r\\n\\t\\t\\t\\tthis.y = q.y / s;\\r\\n\\t\\t\\t\\tthis.z = q.z / s;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetAxisAngleFromRotationMatrix: function ( m ) {\\r\\n\\r\\n\\t\\t\\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\\r\\n\\r\\n\\t\\t\\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\\r\\n\\r\\n\\t\\t\\tvar angle, x, y, z,\\t\\t// variables for result\\r\\n\\t\\t\\t\\tepsilon = 0.01,\\t\\t// margin to allow for rounding errors\\r\\n\\t\\t\\t\\tepsilon2 = 0.1,\\t\\t// margin to distinguish between 0 and 180 degrees\\r\\n\\r\\n\\t\\t\\t\\tte = m.elements,\\r\\n\\r\\n\\t\\t\\t\\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\\r\\n\\t\\t\\t\\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\\r\\n\\t\\t\\t\\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\\r\\n\\r\\n\\t\\t\\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\\r\\n\\t\\t\\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\\r\\n\\t\\t\\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\\r\\n\\r\\n\\t\\t\\t\\t// singularity found\\r\\n\\t\\t\\t\\t// first check for identity matrix which must have +1 for all terms\\r\\n\\t\\t\\t\\t// in leading diagonal and zero in other terms\\r\\n\\r\\n\\t\\t\\t\\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\\r\\n\\t\\t\\t\\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\\r\\n\\t\\t\\t\\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\\r\\n\\t\\t\\t\\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// this singularity is identity matrix so angle = 0\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.set( 1, 0, 0, 0 );\\r\\n\\r\\n\\t\\t\\t\\t\\treturn this; // zero angle, arbitrary axis\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// otherwise this singularity is angle = 180\\r\\n\\r\\n\\t\\t\\t\\tangle = Math.PI;\\r\\n\\r\\n\\t\\t\\t\\tvar xx = ( m11 + 1 ) / 2;\\r\\n\\t\\t\\t\\tvar yy = ( m22 + 1 ) / 2;\\r\\n\\t\\t\\t\\tvar zz = ( m33 + 1 ) / 2;\\r\\n\\t\\t\\t\\tvar xy = ( m12 + m21 ) / 4;\\r\\n\\t\\t\\t\\tvar xz = ( m13 + m31 ) / 4;\\r\\n\\t\\t\\t\\tvar yz = ( m23 + m32 ) / 4;\\r\\n\\r\\n\\t\\t\\t\\tif ( ( xx > yy ) && ( xx > zz ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// m11 is the largest diagonal term\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( xx < epsilon ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tx = 0;\\r\\n\\t\\t\\t\\t\\t\\ty = 0.707106781;\\r\\n\\t\\t\\t\\t\\t\\tz = 0.707106781;\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tx = Math.sqrt( xx );\\r\\n\\t\\t\\t\\t\\t\\ty = xy / x;\\r\\n\\t\\t\\t\\t\\t\\tz = xz / x;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else if ( yy > zz ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// m22 is the largest diagonal term\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( yy < epsilon ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tx = 0.707106781;\\r\\n\\t\\t\\t\\t\\t\\ty = 0;\\r\\n\\t\\t\\t\\t\\t\\tz = 0.707106781;\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ty = Math.sqrt( yy );\\r\\n\\t\\t\\t\\t\\t\\tx = xy / y;\\r\\n\\t\\t\\t\\t\\t\\tz = yz / y;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t// m33 is the largest diagonal term so base result on this\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( zz < epsilon ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tx = 0.707106781;\\r\\n\\t\\t\\t\\t\\t\\ty = 0.707106781;\\r\\n\\t\\t\\t\\t\\t\\tz = 0;\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tz = Math.sqrt( zz );\\r\\n\\t\\t\\t\\t\\t\\tx = xz / z;\\r\\n\\t\\t\\t\\t\\t\\ty = yz / z;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tthis.set( x, y, z, angle );\\r\\n\\r\\n\\t\\t\\t\\treturn this; // return 180 deg rotation\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// as we have reached here there are no singularities so we can handle normally\\r\\n\\r\\n\\t\\t\\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\\r\\n\\t\\t\\t                   ( m13 - m31 ) * ( m13 - m31 ) +\\r\\n\\t\\t\\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\\r\\n\\r\\n\\t\\t\\tif ( Math.abs( s ) < 0.001 ) s = 1;\\r\\n\\r\\n\\t\\t\\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\\r\\n\\t\\t\\t// caught by singularity test above, but I've left it in just in case\\r\\n\\r\\n\\t\\t\\tthis.x = ( m32 - m23 ) / s;\\r\\n\\t\\t\\tthis.y = ( m13 - m31 ) / s;\\r\\n\\t\\t\\tthis.z = ( m21 - m12 ) / s;\\r\\n\\t\\t\\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmin: function ( v ) {\\r\\n\\r\\n\\t\\t\\tthis.x = Math.min( this.x, v.x );\\r\\n\\t\\t\\tthis.y = Math.min( this.y, v.y );\\r\\n\\t\\t\\tthis.z = Math.min( this.z, v.z );\\r\\n\\t\\t\\tthis.w = Math.min( this.w, v.w );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmax: function ( v ) {\\r\\n\\r\\n\\t\\t\\tthis.x = Math.max( this.x, v.x );\\r\\n\\t\\t\\tthis.y = Math.max( this.y, v.y );\\r\\n\\t\\t\\tthis.z = Math.max( this.z, v.z );\\r\\n\\t\\t\\tthis.w = Math.max( this.w, v.w );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclamp: function ( min, max ) {\\r\\n\\r\\n\\t\\t\\t// assumes min < max, componentwise\\r\\n\\r\\n\\t\\t\\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\\r\\n\\t\\t\\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\\r\\n\\t\\t\\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\\r\\n\\t\\t\\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclampScalar: function () {\\r\\n\\r\\n\\t\\t\\tvar min, max;\\r\\n\\r\\n\\t\\t\\treturn function clampScalar( minVal, maxVal ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( min === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tmin = new Vector4();\\r\\n\\t\\t\\t\\t\\tmax = new Vector4();\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tmin.set( minVal, minVal, minVal, minVal );\\r\\n\\t\\t\\t\\tmax.set( maxVal, maxVal, maxVal, maxVal );\\r\\n\\r\\n\\t\\t\\t\\treturn this.clamp( min, max );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tclampLength: function ( min, max ) {\\r\\n\\r\\n\\t\\t\\tvar length = this.length();\\r\\n\\r\\n\\t\\t\\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tfloor: function () {\\r\\n\\r\\n\\t\\t\\tthis.x = Math.floor( this.x );\\r\\n\\t\\t\\tthis.y = Math.floor( this.y );\\r\\n\\t\\t\\tthis.z = Math.floor( this.z );\\r\\n\\t\\t\\tthis.w = Math.floor( this.w );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tceil: function () {\\r\\n\\r\\n\\t\\t\\tthis.x = Math.ceil( this.x );\\r\\n\\t\\t\\tthis.y = Math.ceil( this.y );\\r\\n\\t\\t\\tthis.z = Math.ceil( this.z );\\r\\n\\t\\t\\tthis.w = Math.ceil( this.w );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tround: function () {\\r\\n\\r\\n\\t\\t\\tthis.x = Math.round( this.x );\\r\\n\\t\\t\\tthis.y = Math.round( this.y );\\r\\n\\t\\t\\tthis.z = Math.round( this.z );\\r\\n\\t\\t\\tthis.w = Math.round( this.w );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\troundToZero: function () {\\r\\n\\r\\n\\t\\t\\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\\r\\n\\t\\t\\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\\r\\n\\t\\t\\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\\r\\n\\t\\t\\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tnegate: function () {\\r\\n\\r\\n\\t\\t\\tthis.x = - this.x;\\r\\n\\t\\t\\tthis.y = - this.y;\\r\\n\\t\\t\\tthis.z = - this.z;\\r\\n\\t\\t\\tthis.w = - this.w;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdot: function ( v ) {\\r\\n\\r\\n\\t\\t\\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tlengthSq: function () {\\r\\n\\r\\n\\t\\t\\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tlength: function () {\\r\\n\\r\\n\\t\\t\\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmanhattanLength: function () {\\r\\n\\r\\n\\t\\t\\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tnormalize: function () {\\r\\n\\r\\n\\t\\t\\treturn this.divideScalar( this.length() || 1 );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetLength: function ( length ) {\\r\\n\\r\\n\\t\\t\\treturn this.normalize().multiplyScalar( length );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tlerp: function ( v, alpha ) {\\r\\n\\r\\n\\t\\t\\tthis.x += ( v.x - this.x ) * alpha;\\r\\n\\t\\t\\tthis.y += ( v.y - this.y ) * alpha;\\r\\n\\t\\t\\tthis.z += ( v.z - this.z ) * alpha;\\r\\n\\t\\t\\tthis.w += ( v.w - this.w ) * alpha;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tlerpVectors: function ( v1, v2, alpha ) {\\r\\n\\r\\n\\t\\t\\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tequals: function ( v ) {\\r\\n\\r\\n\\t\\t\\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tfromArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\t\\tthis.x = array[ offset ];\\r\\n\\t\\t\\tthis.y = array[ offset + 1 ];\\r\\n\\t\\t\\tthis.z = array[ offset + 2 ];\\r\\n\\t\\t\\tthis.w = array[ offset + 3 ];\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttoArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\t\\tif ( array === undefined ) array = [];\\r\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\t\\tarray[ offset ] = this.x;\\r\\n\\t\\t\\tarray[ offset + 1 ] = this.y;\\r\\n\\t\\t\\tarray[ offset + 2 ] = this.z;\\r\\n\\t\\t\\tarray[ offset + 3 ] = this.w;\\r\\n\\r\\n\\t\\t\\treturn array;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tfromBufferAttribute: function ( attribute, index, offset ) {\\r\\n\\r\\n\\t\\t\\tif ( offset !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.x = attribute.getX( index );\\r\\n\\t\\t\\tthis.y = attribute.getY( index );\\r\\n\\t\\t\\tthis.z = attribute.getZ( index );\\r\\n\\t\\t\\tthis.w = attribute.getW( index );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author szimek / https://github.com/szimek/\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t * @author Marius Kintel / https://github.com/kintel\\r\\n\\t */\\r\\n\\r\\n\\t/*\\r\\n\\t In options, we can specify:\\r\\n\\t * Texture parameters for an auto-generated target texture\\r\\n\\t * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\\r\\n\\t*/\\r\\n\\tfunction WebGLRenderTarget( width, height, options ) {\\r\\n\\r\\n\\t\\tthis.uuid = _Math.generateUUID();\\r\\n\\r\\n\\t\\tthis.width = width;\\r\\n\\t\\tthis.height = height;\\r\\n\\r\\n\\t\\tthis.scissor = new Vector4( 0, 0, width, height );\\r\\n\\t\\tthis.scissorTest = false;\\r\\n\\r\\n\\t\\tthis.viewport = new Vector4( 0, 0, width, height );\\r\\n\\r\\n\\t\\toptions = options || {};\\r\\n\\r\\n\\t\\tif ( options.minFilter === undefined ) options.minFilter = LinearFilter;\\r\\n\\r\\n\\t\\tthis.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\\r\\n\\r\\n\\t\\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\\r\\n\\t\\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\\r\\n\\t\\tthis.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tWebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: WebGLRenderTarget,\\r\\n\\r\\n\\t\\tisWebGLRenderTarget: true,\\r\\n\\r\\n\\t\\tsetSize: function ( width, height ) {\\r\\n\\r\\n\\t\\t\\tif ( this.width !== width || this.height !== height ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.width = width;\\r\\n\\t\\t\\t\\tthis.height = height;\\r\\n\\r\\n\\t\\t\\t\\tthis.dispose();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.viewport.set( 0, 0, width, height );\\r\\n\\t\\t\\tthis.scissor.set( 0, 0, width, height );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\t\\tthis.width = source.width;\\r\\n\\t\\t\\tthis.height = source.height;\\r\\n\\r\\n\\t\\t\\tthis.viewport.copy( source.viewport );\\r\\n\\r\\n\\t\\t\\tthis.texture = source.texture.clone();\\r\\n\\r\\n\\t\\t\\tthis.depthBuffer = source.depthBuffer;\\r\\n\\t\\t\\tthis.stencilBuffer = source.stencilBuffer;\\r\\n\\t\\t\\tthis.depthTexture = source.depthTexture;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdispose: function () {\\r\\n\\r\\n\\t\\t\\tthis.dispatchEvent( { type: 'dispose' } );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author alteredq / http://alteredqualia.com\\r\\n\\t */\\r\\n\\r\\n\\tfunction WebGLRenderTargetCube( width, height, options ) {\\r\\n\\r\\n\\t\\tWebGLRenderTarget.call( this, width, height, options );\\r\\n\\r\\n\\t\\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\\r\\n\\t\\tthis.activeMipMapLevel = 0;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tWebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );\\r\\n\\tWebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;\\r\\n\\r\\n\\tWebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\\r\\n\\r\\n\\t\\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\\r\\n\\r\\n\\t\\tthis.image = { data: data, width: width, height: height };\\r\\n\\r\\n\\t\\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\\r\\n\\t\\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\\r\\n\\r\\n\\t\\tthis.generateMipmaps = false;\\r\\n\\t\\tthis.flipY = false;\\r\\n\\t\\tthis.unpackAlignment = 1;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tDataTexture.prototype = Object.create( Texture.prototype );\\r\\n\\tDataTexture.prototype.constructor = DataTexture;\\r\\n\\r\\n\\tDataTexture.prototype.isDataTexture = true;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\\r\\n\\r\\n\\t\\timages = images !== undefined ? images : [];\\r\\n\\t\\tmapping = mapping !== undefined ? mapping : CubeReflectionMapping;\\r\\n\\r\\n\\t\\tTexture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\\r\\n\\r\\n\\t\\tthis.flipY = false;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tCubeTexture.prototype = Object.create( Texture.prototype );\\r\\n\\tCubeTexture.prototype.constructor = CubeTexture;\\r\\n\\r\\n\\tCubeTexture.prototype.isCubeTexture = true;\\r\\n\\r\\n\\tObject.defineProperty( CubeTexture.prototype, 'images', {\\r\\n\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\treturn this.image;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.image = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author tschw\\r\\n\\t *\\r\\n\\t * Uniforms of a program.\\r\\n\\t * Those form a tree structure with a special top-level container for the root,\\r\\n\\t * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.\\r\\n\\t *\\r\\n\\t *\\r\\n\\t * Properties of inner nodes including the top-level container:\\r\\n\\t *\\r\\n\\t * .seq - array of nested uniforms\\r\\n\\t * .map - nested uniforms by name\\r\\n\\t *\\r\\n\\t *\\r\\n\\t * Methods of all nodes except the top-level container:\\r\\n\\t *\\r\\n\\t * .setValue( gl, value, [renderer] )\\r\\n\\t *\\r\\n\\t * \\t\\tuploads a uniform value(s)\\r\\n\\t *  \\tthe 'renderer' parameter is needed for sampler uniforms\\r\\n\\t *\\r\\n\\t *\\r\\n\\t * Static methods of the top-level container (renderer factorizations):\\r\\n\\t *\\r\\n\\t * .upload( gl, seq, values, renderer )\\r\\n\\t *\\r\\n\\t * \\t\\tsets uniforms in 'seq' to 'values[id].value'\\r\\n\\t *\\r\\n\\t * .seqWithValue( seq, values ) : filteredSeq\\r\\n\\t *\\r\\n\\t * \\t\\tfilters 'seq' entries with corresponding entry in values\\r\\n\\t *\\r\\n\\t *\\r\\n\\t * Methods of the top-level container (renderer factorizations):\\r\\n\\t *\\r\\n\\t * .setValue( gl, name, value )\\r\\n\\t *\\r\\n\\t * \\t\\tsets uniform with  name 'name' to 'value'\\r\\n\\t *\\r\\n\\t * .set( gl, obj, prop )\\r\\n\\t *\\r\\n\\t * \\t\\tsets uniform from object and property with same name than uniform\\r\\n\\t *\\r\\n\\t * .setOptional( gl, obj, prop )\\r\\n\\t *\\r\\n\\t * \\t\\tlike .set for an optional property of the object\\r\\n\\t *\\r\\n\\t */\\r\\n\\r\\n\\tvar emptyTexture = new Texture();\\r\\n\\tvar emptyCubeTexture = new CubeTexture();\\r\\n\\r\\n\\t// --- Base for inner nodes (including the root) ---\\r\\n\\r\\n\\tfunction UniformContainer() {\\r\\n\\r\\n\\t\\tthis.seq = [];\\r\\n\\t\\tthis.map = {};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// --- Utilities ---\\r\\n\\r\\n\\t// Array Caches (provide typed arrays for temporary by size)\\r\\n\\r\\n\\tvar arrayCacheF32 = [];\\r\\n\\tvar arrayCacheI32 = [];\\r\\n\\r\\n\\t// Float32Array caches used for uploading Matrix uniforms\\r\\n\\r\\n\\tvar mat4array = new Float32Array( 16 );\\r\\n\\tvar mat3array = new Float32Array( 9 );\\r\\n\\r\\n\\t// Flattening for arrays of vectors and matrices\\r\\n\\r\\n\\tfunction flatten( array, nBlocks, blockSize ) {\\r\\n\\r\\n\\t\\tvar firstElem = array[ 0 ];\\r\\n\\r\\n\\t\\tif ( firstElem <= 0 || firstElem > 0 ) return array;\\r\\n\\t\\t// unoptimized: ! isNaN( firstElem )\\r\\n\\t\\t// see http://jacksondunstan.com/articles/983\\r\\n\\r\\n\\t\\tvar n = nBlocks * blockSize,\\r\\n\\t\\t\\tr = arrayCacheF32[ n ];\\r\\n\\r\\n\\t\\tif ( r === undefined ) {\\r\\n\\r\\n\\t\\t\\tr = new Float32Array( n );\\r\\n\\t\\t\\tarrayCacheF32[ n ] = r;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( nBlocks !== 0 ) {\\r\\n\\r\\n\\t\\t\\tfirstElem.toArray( r, 0 );\\r\\n\\r\\n\\t\\t\\tfor ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\toffset += blockSize;\\r\\n\\t\\t\\t\\tarray[ i ].toArray( r, offset );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn r;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// Texture unit allocation\\r\\n\\r\\n\\tfunction allocTexUnits( renderer, n ) {\\r\\n\\r\\n\\t\\tvar r = arrayCacheI32[ n ];\\r\\n\\r\\n\\t\\tif ( r === undefined ) {\\r\\n\\r\\n\\t\\t\\tr = new Int32Array( n );\\r\\n\\t\\t\\tarrayCacheI32[ n ] = r;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor ( var i = 0; i !== n; ++ i )\\r\\n\\t\\t\\tr[ i ] = renderer.allocTextureUnit();\\r\\n\\r\\n\\t\\treturn r;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// --- Setters ---\\r\\n\\r\\n\\t// Note: Defining these methods externally, because they come in a bunch\\r\\n\\t// and this way their names minify.\\r\\n\\r\\n\\t// Single scalar\\r\\n\\r\\n\\tfunction setValue1f( gl, v ) {\\r\\n\\r\\n\\t\\tgl.uniform1f( this.addr, v );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction setValue1i( gl, v ) {\\r\\n\\r\\n\\t\\tgl.uniform1i( this.addr, v );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// Single float vector (from flat array or THREE.VectorN)\\r\\n\\r\\n\\tfunction setValue2fv( gl, v ) {\\r\\n\\r\\n\\t\\tif ( v.x === undefined ) {\\r\\n\\r\\n\\t\\t\\tgl.uniform2fv( this.addr, v );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tgl.uniform2f( this.addr, v.x, v.y );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction setValue3fv( gl, v ) {\\r\\n\\r\\n\\t\\tif ( v.x !== undefined ) {\\r\\n\\r\\n\\t\\t\\tgl.uniform3f( this.addr, v.x, v.y, v.z );\\r\\n\\r\\n\\t\\t} else if ( v.r !== undefined ) {\\r\\n\\r\\n\\t\\t\\tgl.uniform3f( this.addr, v.r, v.g, v.b );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tgl.uniform3fv( this.addr, v );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction setValue4fv( gl, v ) {\\r\\n\\r\\n\\t\\tif ( v.x === undefined ) {\\r\\n\\r\\n\\t\\t\\tgl.uniform4fv( this.addr, v );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// Single matrix (from flat array or MatrixN)\\r\\n\\r\\n\\tfunction setValue2fm( gl, v ) {\\r\\n\\r\\n\\t\\tgl.uniformMatrix2fv( this.addr, false, v.elements || v );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction setValue3fm( gl, v ) {\\r\\n\\r\\n\\t\\tif ( v.elements === undefined ) {\\r\\n\\r\\n\\t\\t\\tgl.uniformMatrix3fv( this.addr, false, v );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tmat3array.set( v.elements );\\r\\n\\t\\t\\tgl.uniformMatrix3fv( this.addr, false, mat3array );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction setValue4fm( gl, v ) {\\r\\n\\r\\n\\t\\tif ( v.elements === undefined ) {\\r\\n\\r\\n\\t\\t\\tgl.uniformMatrix4fv( this.addr, false, v );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tmat4array.set( v.elements );\\r\\n\\t\\t\\tgl.uniformMatrix4fv( this.addr, false, mat4array );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// Single texture (2D / Cube)\\r\\n\\r\\n\\tfunction setValueT1( gl, v, renderer ) {\\r\\n\\r\\n\\t\\tvar unit = renderer.allocTextureUnit();\\r\\n\\t\\tgl.uniform1i( this.addr, unit );\\r\\n\\t\\trenderer.setTexture2D( v || emptyTexture, unit );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction setValueT6( gl, v, renderer ) {\\r\\n\\r\\n\\t\\tvar unit = renderer.allocTextureUnit();\\r\\n\\t\\tgl.uniform1i( this.addr, unit );\\r\\n\\t\\trenderer.setTextureCube( v || emptyCubeTexture, unit );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// Integer / Boolean vectors or arrays thereof (always flat arrays)\\r\\n\\r\\n\\tfunction setValue2iv( gl, v ) {\\r\\n\\r\\n\\t\\tgl.uniform2iv( this.addr, v );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction setValue3iv( gl, v ) {\\r\\n\\r\\n\\t\\tgl.uniform3iv( this.addr, v );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction setValue4iv( gl, v ) {\\r\\n\\r\\n\\t\\tgl.uniform4iv( this.addr, v );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// Helper to pick the right setter for the singular case\\r\\n\\r\\n\\tfunction getSingularSetter( type ) {\\r\\n\\r\\n\\t\\tswitch ( type ) {\\r\\n\\r\\n\\t\\t\\tcase 0x1406: return setValue1f; // FLOAT\\r\\n\\t\\t\\tcase 0x8b50: return setValue2fv; // _VEC2\\r\\n\\t\\t\\tcase 0x8b51: return setValue3fv; // _VEC3\\r\\n\\t\\t\\tcase 0x8b52: return setValue4fv; // _VEC4\\r\\n\\r\\n\\t\\t\\tcase 0x8b5a: return setValue2fm; // _MAT2\\r\\n\\t\\t\\tcase 0x8b5b: return setValue3fm; // _MAT3\\r\\n\\t\\t\\tcase 0x8b5c: return setValue4fm; // _MAT4\\r\\n\\r\\n\\t\\t\\tcase 0x8b5e: case 0x8d66: return setValueT1; // SAMPLER_2D, SAMPLER_EXTERNAL_OES\\r\\n\\t\\t\\tcase 0x8b60: return setValueT6; // SAMPLER_CUBE\\r\\n\\r\\n\\t\\t\\tcase 0x1404: case 0x8b56: return setValue1i; // INT, BOOL\\r\\n\\t\\t\\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\\r\\n\\t\\t\\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\\r\\n\\t\\t\\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// Array of scalars\\r\\n\\r\\n\\tfunction setValue1fv( gl, v ) {\\r\\n\\r\\n\\t\\tgl.uniform1fv( this.addr, v );\\r\\n\\r\\n\\t}\\r\\n\\tfunction setValue1iv( gl, v ) {\\r\\n\\r\\n\\t\\tgl.uniform1iv( this.addr, v );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// Array of vectors (flat or from THREE classes)\\r\\n\\r\\n\\tfunction setValueV2a( gl, v ) {\\r\\n\\r\\n\\t\\tgl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction setValueV3a( gl, v ) {\\r\\n\\r\\n\\t\\tgl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction setValueV4a( gl, v ) {\\r\\n\\r\\n\\t\\tgl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// Array of matrices (flat or from THREE clases)\\r\\n\\r\\n\\tfunction setValueM2a( gl, v ) {\\r\\n\\r\\n\\t\\tgl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction setValueM3a( gl, v ) {\\r\\n\\r\\n\\t\\tgl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction setValueM4a( gl, v ) {\\r\\n\\r\\n\\t\\tgl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// Array of textures (2D / Cube)\\r\\n\\r\\n\\tfunction setValueT1a( gl, v, renderer ) {\\r\\n\\r\\n\\t\\tvar n = v.length,\\r\\n\\t\\t\\tunits = allocTexUnits( renderer, n );\\r\\n\\r\\n\\t\\tgl.uniform1iv( this.addr, units );\\r\\n\\r\\n\\t\\tfor ( var i = 0; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\trenderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction setValueT6a( gl, v, renderer ) {\\r\\n\\r\\n\\t\\tvar n = v.length,\\r\\n\\t\\t\\tunits = allocTexUnits( renderer, n );\\r\\n\\r\\n\\t\\tgl.uniform1iv( this.addr, units );\\r\\n\\r\\n\\t\\tfor ( var i = 0; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\trenderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// Helper to pick the right setter for a pure (bottom-level) array\\r\\n\\r\\n\\tfunction getPureArraySetter( type ) {\\r\\n\\r\\n\\t\\tswitch ( type ) {\\r\\n\\r\\n\\t\\t\\tcase 0x1406: return setValue1fv; // FLOAT\\r\\n\\t\\t\\tcase 0x8b50: return setValueV2a; // _VEC2\\r\\n\\t\\t\\tcase 0x8b51: return setValueV3a; // _VEC3\\r\\n\\t\\t\\tcase 0x8b52: return setValueV4a; // _VEC4\\r\\n\\r\\n\\t\\t\\tcase 0x8b5a: return setValueM2a; // _MAT2\\r\\n\\t\\t\\tcase 0x8b5b: return setValueM3a; // _MAT3\\r\\n\\t\\t\\tcase 0x8b5c: return setValueM4a; // _MAT4\\r\\n\\r\\n\\t\\t\\tcase 0x8b5e: return setValueT1a; // SAMPLER_2D\\r\\n\\t\\t\\tcase 0x8b60: return setValueT6a; // SAMPLER_CUBE\\r\\n\\r\\n\\t\\t\\tcase 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL\\r\\n\\t\\t\\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\\r\\n\\t\\t\\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\\r\\n\\t\\t\\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// --- Uniform Classes ---\\r\\n\\r\\n\\tfunction SingleUniform( id, activeInfo, addr ) {\\r\\n\\r\\n\\t\\tthis.id = id;\\r\\n\\t\\tthis.addr = addr;\\r\\n\\t\\tthis.setValue = getSingularSetter( activeInfo.type );\\r\\n\\r\\n\\t\\t// this.path = activeInfo.name; // DEBUG\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction PureArrayUniform( id, activeInfo, addr ) {\\r\\n\\r\\n\\t\\tthis.id = id;\\r\\n\\t\\tthis.addr = addr;\\r\\n\\t\\tthis.size = activeInfo.size;\\r\\n\\t\\tthis.setValue = getPureArraySetter( activeInfo.type );\\r\\n\\r\\n\\t\\t// this.path = activeInfo.name; // DEBUG\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction StructuredUniform( id ) {\\r\\n\\r\\n\\t\\tthis.id = id;\\r\\n\\r\\n\\t\\tUniformContainer.call( this ); // mix-in\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tStructuredUniform.prototype.setValue = function ( gl, value ) {\\r\\n\\r\\n\\t\\t// Note: Don't need an extra 'renderer' parameter, since samplers\\r\\n\\t\\t// are not allowed in structured uniforms.\\r\\n\\r\\n\\t\\tvar seq = this.seq;\\r\\n\\r\\n\\t\\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\tvar u = seq[ i ];\\r\\n\\t\\t\\tu.setValue( gl, value[ u.id ] );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t// --- Top-level ---\\r\\n\\r\\n\\t// Parser - builds up the property tree from the path strings\\r\\n\\r\\n\\tvar RePathPart = /([\\\\w\\\\d_]+)(\\\\])?(\\\\[|\\\\.)?/g;\\r\\n\\r\\n\\t// extracts\\r\\n\\t// \\t- the identifier (member name or array index)\\r\\n\\t//  - followed by an optional right bracket (found when array index)\\r\\n\\t//  - followed by an optional left bracket or dot (type of subscript)\\r\\n\\t//\\r\\n\\t// Note: These portions can be read in a non-overlapping fashion and\\r\\n\\t// allow straightforward parsing of the hierarchy that WebGL encodes\\r\\n\\t// in the uniform names.\\r\\n\\r\\n\\tfunction addUniform( container, uniformObject ) {\\r\\n\\r\\n\\t\\tcontainer.seq.push( uniformObject );\\r\\n\\t\\tcontainer.map[ uniformObject.id ] = uniformObject;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction parseUniform( activeInfo, addr, container ) {\\r\\n\\r\\n\\t\\tvar path = activeInfo.name,\\r\\n\\t\\t\\tpathLength = path.length;\\r\\n\\r\\n\\t\\t// reset RegExp object, because of the early exit of a previous run\\r\\n\\t\\tRePathPart.lastIndex = 0;\\r\\n\\r\\n\\t\\tfor ( ; ; ) {\\r\\n\\r\\n\\t\\t\\tvar match = RePathPart.exec( path ),\\r\\n\\t\\t\\t\\tmatchEnd = RePathPart.lastIndex,\\r\\n\\r\\n\\t\\t\\t\\tid = match[ 1 ],\\r\\n\\t\\t\\t\\tidIsIndex = match[ 2 ] === ']',\\r\\n\\t\\t\\t\\tsubscript = match[ 3 ];\\r\\n\\r\\n\\t\\t\\tif ( idIsIndex ) id = id | 0; // convert to integer\\r\\n\\r\\n\\t\\t\\tif ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {\\r\\n\\r\\n\\t\\t\\t\\t// bare name or \\\"pure\\\" bottom-level array \\\"[0]\\\" suffix\\r\\n\\r\\n\\t\\t\\t\\taddUniform( container, subscript === undefined ?\\r\\n\\t\\t\\t\\t\\tnew SingleUniform( id, activeInfo, addr ) :\\r\\n\\t\\t\\t\\t\\tnew PureArrayUniform( id, activeInfo, addr ) );\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t// step into inner node / create it in case it doesn't exist\\r\\n\\r\\n\\t\\t\\t\\tvar map = container.map, next = map[ id ];\\r\\n\\r\\n\\t\\t\\t\\tif ( next === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tnext = new StructuredUniform( id );\\r\\n\\t\\t\\t\\t\\taddUniform( container, next );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tcontainer = next;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// Root Container\\r\\n\\r\\n\\tfunction WebGLUniforms( gl, program, renderer ) {\\r\\n\\r\\n\\t\\tUniformContainer.call( this );\\r\\n\\r\\n\\t\\tthis.renderer = renderer;\\r\\n\\r\\n\\t\\tvar n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < n; ++ i ) {\\r\\n\\r\\n\\t\\t\\tvar info = gl.getActiveUniform( program, i ),\\r\\n\\t\\t\\t\\tpath = info.name,\\r\\n\\t\\t\\t\\taddr = gl.getUniformLocation( program, path );\\r\\n\\r\\n\\t\\t\\tparseUniform( info, addr, this );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tWebGLUniforms.prototype.setValue = function ( gl, name, value ) {\\r\\n\\r\\n\\t\\tvar u = this.map[ name ];\\r\\n\\r\\n\\t\\tif ( u !== undefined ) u.setValue( gl, value, this.renderer );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tWebGLUniforms.prototype.setOptional = function ( gl, object, name ) {\\r\\n\\r\\n\\t\\tvar v = object[ name ];\\r\\n\\r\\n\\t\\tif ( v !== undefined ) this.setValue( gl, name, v );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\t// Static interface\\r\\n\\r\\n\\tWebGLUniforms.upload = function ( gl, seq, values, renderer ) {\\r\\n\\r\\n\\t\\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\tvar u = seq[ i ],\\r\\n\\t\\t\\t\\tv = values[ u.id ];\\r\\n\\r\\n\\t\\t\\tif ( v.needsUpdate !== false ) {\\r\\n\\r\\n\\t\\t\\t\\t// note: always updating when .needsUpdate is undefined\\r\\n\\t\\t\\t\\tu.setValue( gl, v.value, renderer );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tWebGLUniforms.seqWithValue = function ( seq, values ) {\\r\\n\\r\\n\\t\\tvar r = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\tvar u = seq[ i ];\\r\\n\\t\\t\\tif ( u.id in values ) r.push( u );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn r;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tvar ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\\r\\n\\t\\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\\r\\n\\t\\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\\r\\n\\t\\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\\r\\n\\t\\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\\r\\n\\t\\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\\r\\n\\t\\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\\r\\n\\t\\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\\r\\n\\t\\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\\r\\n\\t\\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\\r\\n\\t\\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\\r\\n\\t\\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\\r\\n\\t\\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\\r\\n\\t\\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\\r\\n\\t\\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\\r\\n\\t\\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\\r\\n\\t\\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\\r\\n\\t\\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\\r\\n\\t\\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\\r\\n\\t\\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\\r\\n\\t\\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\\r\\n\\t\\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\\r\\n\\t\\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\\r\\n\\t\\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\\r\\n\\r\\n\\tfunction Color( r, g, b ) {\\r\\n\\r\\n\\t\\tif ( g === undefined && b === undefined ) {\\r\\n\\r\\n\\t\\t\\t// r is THREE.Color, hex or string\\r\\n\\t\\t\\treturn this.set( r );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this.setRGB( r, g, b );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( Color.prototype, {\\r\\n\\r\\n\\t\\tisColor: true,\\r\\n\\r\\n\\t\\tr: 1, g: 1, b: 1,\\r\\n\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tif ( value && value.isColor ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.copy( value );\\r\\n\\r\\n\\t\\t\\t} else if ( typeof value === 'number' ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.setHex( value );\\r\\n\\r\\n\\t\\t\\t} else if ( typeof value === 'string' ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.setStyle( value );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetScalar: function ( scalar ) {\\r\\n\\r\\n\\t\\t\\tthis.r = scalar;\\r\\n\\t\\t\\tthis.g = scalar;\\r\\n\\t\\t\\tthis.b = scalar;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetHex: function ( hex ) {\\r\\n\\r\\n\\t\\t\\thex = Math.floor( hex );\\r\\n\\r\\n\\t\\t\\tthis.r = ( hex >> 16 & 255 ) / 255;\\r\\n\\t\\t\\tthis.g = ( hex >> 8 & 255 ) / 255;\\r\\n\\t\\t\\tthis.b = ( hex & 255 ) / 255;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetRGB: function ( r, g, b ) {\\r\\n\\r\\n\\t\\t\\tthis.r = r;\\r\\n\\t\\t\\tthis.g = g;\\r\\n\\t\\t\\tthis.b = b;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetHSL: function () {\\r\\n\\r\\n\\t\\t\\tfunction hue2rgb( p, q, t ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( t < 0 ) t += 1;\\r\\n\\t\\t\\t\\tif ( t > 1 ) t -= 1;\\r\\n\\t\\t\\t\\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\\r\\n\\t\\t\\t\\tif ( t < 1 / 2 ) return q;\\r\\n\\t\\t\\t\\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\\r\\n\\t\\t\\t\\treturn p;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn function setHSL( h, s, l ) {\\r\\n\\r\\n\\t\\t\\t\\t// h,s,l ranges are in 0.0 - 1.0\\r\\n\\t\\t\\t\\th = _Math.euclideanModulo( h, 1 );\\r\\n\\t\\t\\t\\ts = _Math.clamp( s, 0, 1 );\\r\\n\\t\\t\\t\\tl = _Math.clamp( l, 0, 1 );\\r\\n\\r\\n\\t\\t\\t\\tif ( s === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.r = this.g = this.b = l;\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\\r\\n\\t\\t\\t\\t\\tvar q = ( 2 * l ) - p;\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.r = hue2rgb( q, p, h + 1 / 3 );\\r\\n\\t\\t\\t\\t\\tthis.g = hue2rgb( q, p, h );\\r\\n\\t\\t\\t\\t\\tthis.b = hue2rgb( q, p, h - 1 / 3 );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tsetStyle: function ( style ) {\\r\\n\\r\\n\\t\\t\\tfunction handleAlpha( string ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( string === undefined ) return;\\r\\n\\r\\n\\t\\t\\t\\tif ( parseFloat( string ) < 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\t\\tvar m;\\r\\n\\r\\n\\t\\t\\tif ( m = /^((?:rgb|hsl)a?)\\\\(\\\\s*([^\\\\)]*)\\\\)/.exec( style ) ) {\\r\\n\\r\\n\\t\\t\\t\\t// rgb / hsl\\r\\n\\r\\n\\t\\t\\t\\tvar color;\\r\\n\\t\\t\\t\\tvar name = m[ 1 ];\\r\\n\\t\\t\\t\\tvar components = m[ 2 ];\\r\\n\\r\\n\\t\\t\\t\\tswitch ( name ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'rgb':\\r\\n\\t\\t\\t\\t\\tcase 'rgba':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( color = /^(\\\\d+)\\\\s*,\\\\s*(\\\\d+)\\\\s*,\\\\s*(\\\\d+)\\\\s*(,\\\\s*([0-9]*\\\\.?[0-9]+)\\\\s*)?$/.exec( components ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t// rgb(255,0,0) rgba(255,0,0,0.5)\\r\\n\\t\\t\\t\\t\\t\\t\\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\\r\\n\\t\\t\\t\\t\\t\\t\\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\\r\\n\\t\\t\\t\\t\\t\\t\\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\thandleAlpha( color[ 5 ] );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( color = /^(\\\\d+)\\\\%\\\\s*,\\\\s*(\\\\d+)\\\\%\\\\s*,\\\\s*(\\\\d+)\\\\%\\\\s*(,\\\\s*([0-9]*\\\\.?[0-9]+)\\\\s*)?$/.exec( components ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\\r\\n\\t\\t\\t\\t\\t\\t\\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\\r\\n\\t\\t\\t\\t\\t\\t\\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\\r\\n\\t\\t\\t\\t\\t\\t\\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\thandleAlpha( color[ 5 ] );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'hsl':\\r\\n\\t\\t\\t\\t\\tcase 'hsla':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( color = /^([0-9]*\\\\.?[0-9]+)\\\\s*,\\\\s*(\\\\d+)\\\\%\\\\s*,\\\\s*(\\\\d+)\\\\%\\\\s*(,\\\\s*([0-9]*\\\\.?[0-9]+)\\\\s*)?$/.exec( components ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\\r\\n\\t\\t\\t\\t\\t\\t\\tvar h = parseFloat( color[ 1 ] ) / 360;\\r\\n\\t\\t\\t\\t\\t\\t\\tvar s = parseInt( color[ 2 ], 10 ) / 100;\\r\\n\\t\\t\\t\\t\\t\\t\\tvar l = parseInt( color[ 3 ], 10 ) / 100;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\thandleAlpha( color[ 5 ] );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\treturn this.setHSL( h, s, l );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else if ( m = /^\\\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\\r\\n\\r\\n\\t\\t\\t\\t// hex color\\r\\n\\r\\n\\t\\t\\t\\tvar hex = m[ 1 ];\\r\\n\\t\\t\\t\\tvar size = hex.length;\\r\\n\\r\\n\\t\\t\\t\\tif ( size === 3 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// #ff0\\r\\n\\t\\t\\t\\t\\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\\r\\n\\t\\t\\t\\t\\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\\r\\n\\t\\t\\t\\t\\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\\r\\n\\r\\n\\t\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t\\t} else if ( size === 6 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// #ff0000\\r\\n\\t\\t\\t\\t\\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\\r\\n\\t\\t\\t\\t\\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\\r\\n\\t\\t\\t\\t\\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\\r\\n\\r\\n\\t\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( style && style.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t// color keywords\\r\\n\\t\\t\\t\\tvar hex = ColorKeywords[ style ];\\r\\n\\r\\n\\t\\t\\t\\tif ( hex !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// red\\r\\n\\t\\t\\t\\t\\tthis.setHex( hex );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t// unknown color\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.Color: Unknown color ' + style );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor( this.r, this.g, this.b );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( color ) {\\r\\n\\r\\n\\t\\t\\tthis.r = color.r;\\r\\n\\t\\t\\tthis.g = color.g;\\r\\n\\t\\t\\tthis.b = color.b;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopyGammaToLinear: function ( color, gammaFactor ) {\\r\\n\\r\\n\\t\\t\\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\\r\\n\\r\\n\\t\\t\\tthis.r = Math.pow( color.r, gammaFactor );\\r\\n\\t\\t\\tthis.g = Math.pow( color.g, gammaFactor );\\r\\n\\t\\t\\tthis.b = Math.pow( color.b, gammaFactor );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopyLinearToGamma: function ( color, gammaFactor ) {\\r\\n\\r\\n\\t\\t\\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\\r\\n\\r\\n\\t\\t\\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\\r\\n\\r\\n\\t\\t\\tthis.r = Math.pow( color.r, safeInverse );\\r\\n\\t\\t\\tthis.g = Math.pow( color.g, safeInverse );\\r\\n\\t\\t\\tthis.b = Math.pow( color.b, safeInverse );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tconvertGammaToLinear: function () {\\r\\n\\r\\n\\t\\t\\tvar r = this.r, g = this.g, b = this.b;\\r\\n\\r\\n\\t\\t\\tthis.r = r * r;\\r\\n\\t\\t\\tthis.g = g * g;\\r\\n\\t\\t\\tthis.b = b * b;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tconvertLinearToGamma: function () {\\r\\n\\r\\n\\t\\t\\tthis.r = Math.sqrt( this.r );\\r\\n\\t\\t\\tthis.g = Math.sqrt( this.g );\\r\\n\\t\\t\\tthis.b = Math.sqrt( this.b );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetHex: function () {\\r\\n\\r\\n\\t\\t\\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetHexString: function () {\\r\\n\\r\\n\\t\\t\\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetHSL: function ( optionalTarget ) {\\r\\n\\r\\n\\t\\t\\t// h,s,l ranges are in 0.0 - 1.0\\r\\n\\r\\n\\t\\t\\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\\r\\n\\r\\n\\t\\t\\tvar r = this.r, g = this.g, b = this.b;\\r\\n\\r\\n\\t\\t\\tvar max = Math.max( r, g, b );\\r\\n\\t\\t\\tvar min = Math.min( r, g, b );\\r\\n\\r\\n\\t\\t\\tvar hue, saturation;\\r\\n\\t\\t\\tvar lightness = ( min + max ) / 2.0;\\r\\n\\r\\n\\t\\t\\tif ( min === max ) {\\r\\n\\r\\n\\t\\t\\t\\thue = 0;\\r\\n\\t\\t\\t\\tsaturation = 0;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tvar delta = max - min;\\r\\n\\r\\n\\t\\t\\t\\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\\r\\n\\r\\n\\t\\t\\t\\tswitch ( max ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\\r\\n\\t\\t\\t\\t\\tcase g: hue = ( b - r ) / delta + 2; break;\\r\\n\\t\\t\\t\\t\\tcase b: hue = ( r - g ) / delta + 4; break;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\thue /= 6;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\thsl.h = hue;\\r\\n\\t\\t\\thsl.s = saturation;\\r\\n\\t\\t\\thsl.l = lightness;\\r\\n\\r\\n\\t\\t\\treturn hsl;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetStyle: function () {\\r\\n\\r\\n\\t\\t\\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\toffsetHSL: function ( h, s, l ) {\\r\\n\\r\\n\\t\\t\\tvar hsl = this.getHSL();\\r\\n\\r\\n\\t\\t\\thsl.h += h; hsl.s += s; hsl.l += l;\\r\\n\\r\\n\\t\\t\\tthis.setHSL( hsl.h, hsl.s, hsl.l );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tadd: function ( color ) {\\r\\n\\r\\n\\t\\t\\tthis.r += color.r;\\r\\n\\t\\t\\tthis.g += color.g;\\r\\n\\t\\t\\tthis.b += color.b;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\taddColors: function ( color1, color2 ) {\\r\\n\\r\\n\\t\\t\\tthis.r = color1.r + color2.r;\\r\\n\\t\\t\\tthis.g = color1.g + color2.g;\\r\\n\\t\\t\\tthis.b = color1.b + color2.b;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\taddScalar: function ( s ) {\\r\\n\\r\\n\\t\\t\\tthis.r += s;\\r\\n\\t\\t\\tthis.g += s;\\r\\n\\t\\t\\tthis.b += s;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsub: function ( color ) {\\r\\n\\r\\n\\t\\t\\tthis.r = Math.max( 0, this.r - color.r );\\r\\n\\t\\t\\tthis.g = Math.max( 0, this.g - color.g );\\r\\n\\t\\t\\tthis.b = Math.max( 0, this.b - color.b );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmultiply: function ( color ) {\\r\\n\\r\\n\\t\\t\\tthis.r *= color.r;\\r\\n\\t\\t\\tthis.g *= color.g;\\r\\n\\t\\t\\tthis.b *= color.b;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmultiplyScalar: function ( s ) {\\r\\n\\r\\n\\t\\t\\tthis.r *= s;\\r\\n\\t\\t\\tthis.g *= s;\\r\\n\\t\\t\\tthis.b *= s;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tlerp: function ( color, alpha ) {\\r\\n\\r\\n\\t\\t\\tthis.r += ( color.r - this.r ) * alpha;\\r\\n\\t\\t\\tthis.g += ( color.g - this.g ) * alpha;\\r\\n\\t\\t\\tthis.b += ( color.b - this.b ) * alpha;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tequals: function ( c ) {\\r\\n\\r\\n\\t\\t\\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tfromArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\t\\tthis.r = array[ offset ];\\r\\n\\t\\t\\tthis.g = array[ offset + 1 ];\\r\\n\\t\\t\\tthis.b = array[ offset + 2 ];\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttoArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\t\\tif ( array === undefined ) array = [];\\r\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\t\\tarray[ offset ] = this.r;\\r\\n\\t\\t\\tarray[ offset + 1 ] = this.g;\\r\\n\\t\\t\\tarray[ offset + 2 ] = this.b;\\r\\n\\r\\n\\t\\t\\treturn array;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttoJSON: function () {\\r\\n\\r\\n\\t\\t\\treturn this.getHex();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * Uniforms library for shared webgl shaders\\r\\n\\t */\\r\\n\\r\\n\\tvar UniformsLib = {\\r\\n\\r\\n\\t\\tcommon: {\\r\\n\\r\\n\\t\\t\\tdiffuse: { value: new Color( 0xeeeeee ) },\\r\\n\\t\\t\\topacity: { value: 1.0 },\\r\\n\\r\\n\\t\\t\\tmap: { value: null },\\r\\n\\t\\t\\tuvTransform: { value: new Matrix3() },\\r\\n\\r\\n\\t\\t\\talphaMap: { value: null },\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tspecularmap: {\\r\\n\\r\\n\\t\\t\\tspecularMap: { value: null },\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tenvmap: {\\r\\n\\r\\n\\t\\t\\tenvMap: { value: null },\\r\\n\\t\\t\\tflipEnvMap: { value: - 1 },\\r\\n\\t\\t\\treflectivity: { value: 1.0 },\\r\\n\\t\\t\\trefractionRatio: { value: 0.98 }\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\taomap: {\\r\\n\\r\\n\\t\\t\\taoMap: { value: null },\\r\\n\\t\\t\\taoMapIntensity: { value: 1 }\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tlightmap: {\\r\\n\\r\\n\\t\\t\\tlightMap: { value: null },\\r\\n\\t\\t\\tlightMapIntensity: { value: 1 }\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\temissivemap: {\\r\\n\\r\\n\\t\\t\\temissiveMap: { value: null }\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tbumpmap: {\\r\\n\\r\\n\\t\\t\\tbumpMap: { value: null },\\r\\n\\t\\t\\tbumpScale: { value: 1 }\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tnormalmap: {\\r\\n\\r\\n\\t\\t\\tnormalMap: { value: null },\\r\\n\\t\\t\\tnormalScale: { value: new Vector2( 1, 1 ) }\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdisplacementmap: {\\r\\n\\r\\n\\t\\t\\tdisplacementMap: { value: null },\\r\\n\\t\\t\\tdisplacementScale: { value: 1 },\\r\\n\\t\\t\\tdisplacementBias: { value: 0 }\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\troughnessmap: {\\r\\n\\r\\n\\t\\t\\troughnessMap: { value: null }\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmetalnessmap: {\\r\\n\\r\\n\\t\\t\\tmetalnessMap: { value: null }\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgradientmap: {\\r\\n\\r\\n\\t\\t\\tgradientMap: { value: null }\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tfog: {\\r\\n\\r\\n\\t\\t\\tfogDensity: { value: 0.00025 },\\r\\n\\t\\t\\tfogNear: { value: 1 },\\r\\n\\t\\t\\tfogFar: { value: 2000 },\\r\\n\\t\\t\\tfogColor: { value: new Color( 0xffffff ) }\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tlights: {\\r\\n\\r\\n\\t\\t\\tambientLightColor: { value: [] },\\r\\n\\r\\n\\t\\t\\tdirectionalLights: { value: [], properties: {\\r\\n\\t\\t\\t\\tdirection: {},\\r\\n\\t\\t\\t\\tcolor: {},\\r\\n\\r\\n\\t\\t\\t\\tshadow: {},\\r\\n\\t\\t\\t\\tshadowBias: {},\\r\\n\\t\\t\\t\\tshadowRadius: {},\\r\\n\\t\\t\\t\\tshadowMapSize: {}\\r\\n\\t\\t\\t} },\\r\\n\\r\\n\\t\\t\\tdirectionalShadowMap: { value: [] },\\r\\n\\t\\t\\tdirectionalShadowMatrix: { value: [] },\\r\\n\\r\\n\\t\\t\\tspotLights: { value: [], properties: {\\r\\n\\t\\t\\t\\tcolor: {},\\r\\n\\t\\t\\t\\tposition: {},\\r\\n\\t\\t\\t\\tdirection: {},\\r\\n\\t\\t\\t\\tdistance: {},\\r\\n\\t\\t\\t\\tconeCos: {},\\r\\n\\t\\t\\t\\tpenumbraCos: {},\\r\\n\\t\\t\\t\\tdecay: {},\\r\\n\\r\\n\\t\\t\\t\\tshadow: {},\\r\\n\\t\\t\\t\\tshadowBias: {},\\r\\n\\t\\t\\t\\tshadowRadius: {},\\r\\n\\t\\t\\t\\tshadowMapSize: {}\\r\\n\\t\\t\\t} },\\r\\n\\r\\n\\t\\t\\tspotShadowMap: { value: [] },\\r\\n\\t\\t\\tspotShadowMatrix: { value: [] },\\r\\n\\r\\n\\t\\t\\tpointLights: { value: [], properties: {\\r\\n\\t\\t\\t\\tcolor: {},\\r\\n\\t\\t\\t\\tposition: {},\\r\\n\\t\\t\\t\\tdecay: {},\\r\\n\\t\\t\\t\\tdistance: {},\\r\\n\\r\\n\\t\\t\\t\\tshadow: {},\\r\\n\\t\\t\\t\\tshadowBias: {},\\r\\n\\t\\t\\t\\tshadowRadius: {},\\r\\n\\t\\t\\t\\tshadowMapSize: {},\\r\\n\\t\\t\\t\\tshadowCameraNear: {},\\r\\n\\t\\t\\t\\tshadowCameraFar: {}\\r\\n\\t\\t\\t} },\\r\\n\\r\\n\\t\\t\\tpointShadowMap: { value: [] },\\r\\n\\t\\t\\tpointShadowMatrix: { value: [] },\\r\\n\\r\\n\\t\\t\\themisphereLights: { value: [], properties: {\\r\\n\\t\\t\\t\\tdirection: {},\\r\\n\\t\\t\\t\\tskyColor: {},\\r\\n\\t\\t\\t\\tgroundColor: {}\\r\\n\\t\\t\\t} },\\r\\n\\r\\n\\t\\t\\t// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src\\r\\n\\t\\t\\trectAreaLights: { value: [], properties: {\\r\\n\\t\\t\\t\\tcolor: {},\\r\\n\\t\\t\\t\\tposition: {},\\r\\n\\t\\t\\t\\twidth: {},\\r\\n\\t\\t\\t\\theight: {}\\r\\n\\t\\t\\t} }\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tpoints: {\\r\\n\\r\\n\\t\\t\\tdiffuse: { value: new Color( 0xeeeeee ) },\\r\\n\\t\\t\\topacity: { value: 1.0 },\\r\\n\\t\\t\\tsize: { value: 1.0 },\\r\\n\\t\\t\\tscale: { value: 1.0 },\\r\\n\\t\\t\\tmap: { value: null },\\r\\n\\t\\t\\tuvTransform: { value: new Matrix3() }\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * Uniform Utilities\\r\\n\\t */\\r\\n\\r\\n\\tvar UniformsUtils = {\\r\\n\\r\\n\\t\\tmerge: function ( uniforms ) {\\r\\n\\r\\n\\t\\t\\tvar merged = {};\\r\\n\\r\\n\\t\\t\\tfor ( var u = 0; u < uniforms.length; u ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar tmp = this.clone( uniforms[ u ] );\\r\\n\\r\\n\\t\\t\\t\\tfor ( var p in tmp ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tmerged[ p ] = tmp[ p ];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn merged;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclone: function ( uniforms_src ) {\\r\\n\\r\\n\\t\\t\\tvar uniforms_dst = {};\\r\\n\\r\\n\\t\\t\\tfor ( var u in uniforms_src ) {\\r\\n\\r\\n\\t\\t\\t\\tuniforms_dst[ u ] = {};\\r\\n\\r\\n\\t\\t\\t\\tfor ( var p in uniforms_src[ u ] ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar parameter_src = uniforms_src[ u ][ p ];\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( parameter_src && ( parameter_src.isColor ||\\r\\n\\t\\t\\t\\t\\t\\tparameter_src.isMatrix3 || parameter_src.isMatrix4 ||\\r\\n\\t\\t\\t\\t\\t\\tparameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||\\r\\n\\t\\t\\t\\t\\t\\tparameter_src.isTexture ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tuniforms_dst[ u ][ p ] = parameter_src.clone();\\r\\n\\r\\n\\t\\t\\t\\t\\t} else if ( Array.isArray( parameter_src ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tuniforms_dst[ u ][ p ] = parameter_src.slice();\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tuniforms_dst[ u ][ p ] = parameter_src;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn uniforms_dst;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tvar alphamap_fragment = \\\"#ifdef USE_ALPHAMAP\\\\n\\\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar alphamap_pars_fragment = \\\"#ifdef USE_ALPHAMAP\\\\n\\\\tuniform sampler2D alphaMap;\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar alphatest_fragment = \\\"#ifdef ALPHATEST\\\\n\\\\tif ( diffuseColor.a < ALPHATEST ) discard;\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar aomap_fragment = \\\"#ifdef USE_AOMAP\\\\n\\\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\\\n\\\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\\\n\\\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\\\n\\\\t\\\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\\\n\\\\t\\\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar aomap_pars_fragment = \\\"#ifdef USE_AOMAP\\\\n\\\\tuniform sampler2D aoMap;\\\\n\\\\tuniform float aoMapIntensity;\\\\n#endif\\\";\\r\\n\\r\\n\\tvar begin_vertex = \\\"\\\\nvec3 transformed = vec3( position );\\\\n\\\";\\r\\n\\r\\n\\tvar beginnormal_vertex = \\\"\\\\nvec3 objectNormal = vec3( normal );\\\\n\\\";\\r\\n\\r\\n\\tvar bsdfs = \\\"float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\\\n\\\\tif( decayExponent > 0.0 ) {\\\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\\\n\\\\t\\\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\\\n\\\\t\\\\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\\\n\\\\t\\\\treturn distanceFalloff * maxDistanceCutoffFactor;\\\\n#else\\\\n\\\\t\\\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\\\n#endif\\\\n\\\\t}\\\\n\\\\treturn 1.0;\\\\n}\\\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\\\n\\\\treturn RECIPROCAL_PI * diffuseColor;\\\\n}\\\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\\\n\\\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\\\n\\\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\\\n}\\\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\\\n\\\\tfloat a2 = pow2( alpha );\\\\n\\\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\\\n\\\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\\\n\\\\treturn 1.0 / ( gl * gv );\\\\n}\\\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\\\n\\\\tfloat a2 = pow2( alpha );\\\\n\\\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\\\n\\\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\\\n\\\\treturn 0.5 / max( gv + gl, EPSILON );\\\\n}\\\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\\\n\\\\tfloat a2 = pow2( alpha );\\\\n\\\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\\\n\\\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\\\n}\\\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\\\n\\\\tfloat alpha = pow2( roughness );\\\\n\\\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\\\n\\\\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\\\n\\\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\\\n\\\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\\\n\\\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\\\n\\\\tvec3 F = F_Schlick( specularColor, dotLH );\\\\n\\\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\\\n\\\\tfloat D = D_GGX( alpha, dotNH );\\\\n\\\\treturn F * ( G * D );\\\\n}\\\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\\\n\\\\tconst float LUT_SIZE  = 64.0;\\\\n\\\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\\\n\\\\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\\\\n\\\\tfloat theta = acos( dot( N, V ) );\\\\n\\\\tvec2 uv = vec2(\\\\n\\\\t\\\\tsqrt( saturate( roughness ) ),\\\\n\\\\t\\\\tsaturate( theta / ( 0.5 * PI ) ) );\\\\n\\\\tuv = uv * LUT_SCALE + LUT_BIAS;\\\\n\\\\treturn uv;\\\\n}\\\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\\\n\\\\tfloat l = length( f );\\\\n\\\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\\\n}\\\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\\\n\\\\tfloat x = dot( v1, v2 );\\\\n\\\\tfloat y = abs( x );\\\\n\\\\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\\\\n\\\\tfloat b = 3.45068 + (4.18814 + y) * y;\\\\n\\\\tfloat v = a / b;\\\\n\\\\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\\\\n\\\\treturn cross( v1, v2 ) * theta_sintheta;\\\\n}\\\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\\\n\\\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\\\n\\\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\\\n\\\\tvec3 lightNormal = cross( v1, v2 );\\\\n\\\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\\\n\\\\tvec3 T1, T2;\\\\n\\\\tT1 = normalize( V - N * dot( V, N ) );\\\\n\\\\tT2 = - cross( N, T1 );\\\\n\\\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\\\n\\\\tvec3 coords[ 4 ];\\\\n\\\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\\\n\\\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\\\n\\\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\\\n\\\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\\\n\\\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\\\n\\\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\\\n\\\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\\\n\\\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\\\n\\\\tvec3 vectorFormFactor = vec3( 0.0 );\\\\n\\\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\\\n\\\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\\\n\\\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\\\n\\\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\\\n\\\\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\\\\n\\\\treturn result;\\\\n}\\\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\\\n\\\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\\\n\\\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\\\n\\\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\\\n\\\\tvec4 r = roughness * c0 + c1;\\\\n\\\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\\\n\\\\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\\\n\\\\treturn specularColor * AB.x + AB.y;\\\\n}\\\\nfloat G_BlinnPhong_Implicit( ) {\\\\n\\\\treturn 0.25;\\\\n}\\\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\\\n\\\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\\\n}\\\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\\\n\\\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\\\n\\\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\\\n\\\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\\\n\\\\tvec3 F = F_Schlick( specularColor, dotLH );\\\\n\\\\tfloat G = G_BlinnPhong_Implicit( );\\\\n\\\\tfloat D = D_BlinnPhong( shininess, dotNH );\\\\n\\\\treturn F * ( G * D );\\\\n}\\\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\\\n\\\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\\\n}\\\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\\\n\\\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar bumpmap_pars_fragment = \\\"#ifdef USE_BUMPMAP\\\\n\\\\tuniform sampler2D bumpMap;\\\\n\\\\tuniform float bumpScale;\\\\n\\\\tvec2 dHdxy_fwd() {\\\\n\\\\t\\\\tvec2 dSTdx = dFdx( vUv );\\\\n\\\\t\\\\tvec2 dSTdy = dFdy( vUv );\\\\n\\\\t\\\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\\\n\\\\t\\\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\\\n\\\\t\\\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\\\n\\\\t\\\\treturn vec2( dBx, dBy );\\\\n\\\\t}\\\\n\\\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\\\n\\\\t\\\\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\\\\n\\\\t\\\\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\\\\n\\\\t\\\\tvec3 vN = surf_norm;\\\\n\\\\t\\\\tvec3 R1 = cross( vSigmaY, vN );\\\\n\\\\t\\\\tvec3 R2 = cross( vN, vSigmaX );\\\\n\\\\t\\\\tfloat fDet = dot( vSigmaX, R1 );\\\\n\\\\t\\\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\\\n\\\\t\\\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\\\n\\\\t}\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar clipping_planes_fragment = \\\"#if NUM_CLIPPING_PLANES > 0\\\\n\\\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\\\\n\\\\t\\\\tvec4 plane = clippingPlanes[ i ];\\\\n\\\\t\\\\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\\\n\\\\t}\\\\n\\\\t\\\\t\\\\n\\\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\\\n\\\\t\\\\tbool clipped = true;\\\\n\\\\t\\\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\\\\n\\\\t\\\\t\\\\tvec4 plane = clippingPlanes[ i ];\\\\n\\\\t\\\\t\\\\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\tif ( clipped ) discard;\\\\n\\\\t\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar clipping_planes_pars_fragment = \\\"#if NUM_CLIPPING_PLANES > 0\\\\n\\\\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\\\n\\\\t\\\\tvarying vec3 vViewPosition;\\\\n\\\\t#endif\\\\n\\\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar clipping_planes_pars_vertex = \\\"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\\\n\\\\tvarying vec3 vViewPosition;\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar clipping_planes_vertex = \\\"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\\\n\\\\tvViewPosition = - mvPosition.xyz;\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar color_fragment = \\\"#ifdef USE_COLOR\\\\n\\\\tdiffuseColor.rgb *= vColor;\\\\n#endif\\\";\\r\\n\\r\\n\\tvar color_pars_fragment = \\\"#ifdef USE_COLOR\\\\n\\\\tvarying vec3 vColor;\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar color_pars_vertex = \\\"#ifdef USE_COLOR\\\\n\\\\tvarying vec3 vColor;\\\\n#endif\\\";\\r\\n\\r\\n\\tvar color_vertex = \\\"#ifdef USE_COLOR\\\\n\\\\tvColor.xyz = color.xyz;\\\\n#endif\\\";\\r\\n\\r\\n\\tvar common = \\\"#define PI 3.14159265359\\\\n#define PI2 6.28318530718\\\\n#define PI_HALF 1.5707963267949\\\\n#define RECIPROCAL_PI 0.31830988618\\\\n#define RECIPROCAL_PI2 0.15915494\\\\n#define LOG2 1.442695\\\\n#define EPSILON 1e-6\\\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\\\nfloat pow2( const in float x ) { return x*x; }\\\\nfloat pow3( const in float x ) { return x*x*x; }\\\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\\\nhighp float rand( const in vec2 uv ) {\\\\n\\\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\\\n\\\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\\\n\\\\treturn fract(sin(sn) * c);\\\\n}\\\\nstruct IncidentLight {\\\\n\\\\tvec3 color;\\\\n\\\\tvec3 direction;\\\\n\\\\tbool visible;\\\\n};\\\\nstruct ReflectedLight {\\\\n\\\\tvec3 directDiffuse;\\\\n\\\\tvec3 directSpecular;\\\\n\\\\tvec3 indirectDiffuse;\\\\n\\\\tvec3 indirectSpecular;\\\\n};\\\\nstruct GeometricContext {\\\\n\\\\tvec3 position;\\\\n\\\\tvec3 normal;\\\\n\\\\tvec3 viewDir;\\\\n};\\\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\\\n\\\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\\\n}\\\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\\\n\\\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\\\n}\\\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\\\n\\\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\\\n\\\\treturn - distance * planeNormal + point;\\\\n}\\\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\\\n\\\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\\\n}\\\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\\\n\\\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\\\n}\\\\nmat3 transposeMat3( const in mat3 m ) {\\\\n\\\\tmat3 tmp;\\\\n\\\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\\\n\\\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\\\n\\\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\\\n\\\\treturn tmp;\\\\n}\\\\nfloat linearToRelativeLuminance( const in vec3 color ) {\\\\n\\\\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\\\\n\\\\treturn dot( weights, color.rgb );\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar cube_uv_reflection_fragment = \\\"#ifdef ENVMAP_TYPE_CUBE_UV\\\\n#define cubeUV_textureSize (1024.0)\\\\nint getFaceFromDirection(vec3 direction) {\\\\n\\\\tvec3 absDirection = abs(direction);\\\\n\\\\tint face = -1;\\\\n\\\\tif( absDirection.x > absDirection.z ) {\\\\n\\\\t\\\\tif(absDirection.x > absDirection.y )\\\\n\\\\t\\\\t\\\\tface = direction.x > 0.0 ? 0 : 3;\\\\n\\\\t\\\\telse\\\\n\\\\t\\\\t\\\\tface = direction.y > 0.0 ? 1 : 4;\\\\n\\\\t}\\\\n\\\\telse {\\\\n\\\\t\\\\tif(absDirection.z > absDirection.y )\\\\n\\\\t\\\\t\\\\tface = direction.z > 0.0 ? 2 : 5;\\\\n\\\\t\\\\telse\\\\n\\\\t\\\\t\\\\tface = direction.y > 0.0 ? 1 : 4;\\\\n\\\\t}\\\\n\\\\treturn face;\\\\n}\\\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\\\n\\\\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\\\n\\\\tfloat dxRoughness = dFdx(roughness);\\\\n\\\\tfloat dyRoughness = dFdy(roughness);\\\\n\\\\tvec3 dx = dFdx( vec * scale * dxRoughness );\\\\n\\\\tvec3 dy = dFdy( vec * scale * dyRoughness );\\\\n\\\\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\\\n\\\\td = clamp(d, 1.0, cubeUV_rangeClamp);\\\\n\\\\tfloat mipLevel = 0.5 * log2(d);\\\\n\\\\treturn vec2(floor(mipLevel), fract(mipLevel));\\\\n}\\\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\\\n\\\\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\\\n\\\\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\\\n\\\\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\\\n\\\\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\\\n\\\\tfloat powScale = exp2_packed.x * exp2_packed.y;\\\\n\\\\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\\\n\\\\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\\\n\\\\tbool bRes = mipLevel == 0.0;\\\\n\\\\tscale =  bRes && (scale < a) ? a : scale;\\\\n\\\\tvec3 r;\\\\n\\\\tvec2 offset;\\\\n\\\\tint face = getFaceFromDirection(direction);\\\\n\\\\tfloat rcpPowScale = 1.0 / powScale;\\\\n\\\\tif( face == 0) {\\\\n\\\\t\\\\tr = vec3(direction.x, -direction.z, direction.y);\\\\n\\\\t\\\\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\\\n\\\\t\\\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\\\n\\\\t}\\\\n\\\\telse if( face == 1) {\\\\n\\\\t\\\\tr = vec3(direction.y, direction.x, direction.z);\\\\n\\\\t\\\\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\\\n\\\\t\\\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\\\n\\\\t}\\\\n\\\\telse if( face == 2) {\\\\n\\\\t\\\\tr = vec3(direction.z, direction.x, direction.y);\\\\n\\\\t\\\\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\\\n\\\\t\\\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\\\n\\\\t}\\\\n\\\\telse if( face == 3) {\\\\n\\\\t\\\\tr = vec3(direction.x, direction.z, direction.y);\\\\n\\\\t\\\\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\\\n\\\\t\\\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\\\n\\\\t}\\\\n\\\\telse if( face == 4) {\\\\n\\\\t\\\\tr = vec3(direction.y, direction.x, -direction.z);\\\\n\\\\t\\\\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\\\n\\\\t\\\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\\\n\\\\t}\\\\n\\\\telse {\\\\n\\\\t\\\\tr = vec3(direction.z, -direction.x, direction.y);\\\\n\\\\t\\\\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\\\n\\\\t\\\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\\\n\\\\t}\\\\n\\\\tr = normalize(r);\\\\n\\\\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\\\n\\\\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\\\n\\\\tvec2 base = offset + vec2( texelOffset );\\\\n\\\\treturn base + s * ( scale - 2.0 * texelOffset );\\\\n}\\\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\\\n\\\\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\\\n\\\\tfloat r1 = floor(roughnessVal);\\\\n\\\\tfloat r2 = r1 + 1.0;\\\\n\\\\tfloat t = fract(roughnessVal);\\\\n\\\\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\\\n\\\\tfloat s = mipInfo.y;\\\\n\\\\tfloat level0 = mipInfo.x;\\\\n\\\\tfloat level1 = level0 + 1.0;\\\\n\\\\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\\\n\\\\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\\\n\\\\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\\\n\\\\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\\\n\\\\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\\\n\\\\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\\\n\\\\tvec4 result = mix(color10, color20, t);\\\\n\\\\treturn vec4(result.rgb, 1.0);\\\\n}\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar defaultnormal_vertex = \\\"vec3 transformedNormal = normalMatrix * objectNormal;\\\\n#ifdef FLIP_SIDED\\\\n\\\\ttransformedNormal = - transformedNormal;\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar displacementmap_pars_vertex = \\\"#ifdef USE_DISPLACEMENTMAP\\\\n\\\\tuniform sampler2D displacementMap;\\\\n\\\\tuniform float displacementScale;\\\\n\\\\tuniform float displacementBias;\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar displacementmap_vertex = \\\"#ifdef USE_DISPLACEMENTMAP\\\\n\\\\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar emissivemap_fragment = \\\"#ifdef USE_EMISSIVEMAP\\\\n\\\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\\\n\\\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\\\n\\\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar emissivemap_pars_fragment = \\\"#ifdef USE_EMISSIVEMAP\\\\n\\\\tuniform sampler2D emissiveMap;\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar encodings_fragment = \\\"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\\\n\\\";\\r\\n\\r\\n\\tvar encodings_pars_fragment = \\\"\\\\nvec4 LinearToLinear( in vec4 value ) {\\\\n\\\\treturn value;\\\\n}\\\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\\\n\\\\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\\\n}\\\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\\\n\\\\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\\\n}\\\\nvec4 sRGBToLinear( in vec4 value ) {\\\\n\\\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\\\n}\\\\nvec4 LinearTosRGB( in vec4 value ) {\\\\n\\\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\\\n}\\\\nvec4 RGBEToLinear( in vec4 value ) {\\\\n\\\\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\\\n}\\\\nvec4 LinearToRGBE( in vec4 value ) {\\\\n\\\\tfloat maxComponent = max( max( value.r, value.g ), value.b );\\\\n\\\\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\\\n\\\\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\\\n}\\\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\\\n\\\\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\\\\n}\\\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\\\n\\\\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\\\\n\\\\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\\\n\\\\tM            = ceil( M * 255.0 ) / 255.0;\\\\n\\\\treturn vec4( value.rgb / ( M * maxRange ), M );\\\\n}\\\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\\\n\\\\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\\\n}\\\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\\\n\\\\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\\\\n\\\\tfloat D      = max( maxRange / maxRGB, 1.0 );\\\\n\\\\tD            = min( floor( D ) / 255.0, 1.0 );\\\\n\\\\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\\\n}\\\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\\\nvec4 LinearToLogLuv( in vec4 value )  {\\\\n\\\\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\\\n\\\\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\\\n\\\\tvec4 vResult;\\\\n\\\\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\\\n\\\\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\\\n\\\\tvResult.w = fract(Le);\\\\n\\\\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\\\n\\\\treturn vResult;\\\\n}\\\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\\\nvec4 LogLuvToLinear( in vec4 value ) {\\\\n\\\\tfloat Le = value.z * 255.0 + value.w;\\\\n\\\\tvec3 Xp_Y_XYZp;\\\\n\\\\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\\\n\\\\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\\\n\\\\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\\\n\\\\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\\\n\\\\treturn vec4( max(vRGB, 0.0), 1.0 );\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar envmap_fragment = \\\"#ifdef USE_ENVMAP\\\\n\\\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\\\n\\\\t\\\\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\\\n\\\\t\\\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\\\n\\\\t\\\\t#ifdef ENVMAP_MODE_REFLECTION\\\\n\\\\t\\\\t\\\\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\\\n\\\\t\\\\t#endif\\\\n\\\\t#else\\\\n\\\\t\\\\tvec3 reflectVec = vReflect;\\\\n\\\\t#endif\\\\n\\\\t#ifdef ENVMAP_TYPE_CUBE\\\\n\\\\t\\\\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\\\n\\\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\\\n\\\\t\\\\tvec2 sampleUV;\\\\n\\\\t\\\\treflectVec = normalize( reflectVec );\\\\n\\\\t\\\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\\\n\\\\t\\\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\\\n\\\\t\\\\tvec4 envColor = texture2D( envMap, sampleUV );\\\\n\\\\t#elif defined( ENVMAP_TYPE_SPHERE )\\\\n\\\\t\\\\treflectVec = normalize( reflectVec );\\\\n\\\\t\\\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\\\n\\\\t\\\\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\\\n\\\\t#else\\\\n\\\\t\\\\tvec4 envColor = vec4( 0.0 );\\\\n\\\\t#endif\\\\n\\\\tenvColor = envMapTexelToLinear( envColor );\\\\n\\\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\\\n\\\\t\\\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\\\n\\\\t#elif defined( ENVMAP_BLENDING_MIX )\\\\n\\\\t\\\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\\\n\\\\t#elif defined( ENVMAP_BLENDING_ADD )\\\\n\\\\t\\\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar envmap_pars_fragment = \\\"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\\\n\\\\tuniform float reflectivity;\\\\n\\\\tuniform float envMapIntensity;\\\\n#endif\\\\n#ifdef USE_ENVMAP\\\\n\\\\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\\\n\\\\t\\\\tvarying vec3 vWorldPosition;\\\\n\\\\t#endif\\\\n\\\\t#ifdef ENVMAP_TYPE_CUBE\\\\n\\\\t\\\\tuniform samplerCube envMap;\\\\n\\\\t#else\\\\n\\\\t\\\\tuniform sampler2D envMap;\\\\n\\\\t#endif\\\\n\\\\tuniform float flipEnvMap;\\\\n\\\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\\\n\\\\t\\\\tuniform float refractionRatio;\\\\n\\\\t#else\\\\n\\\\t\\\\tvarying vec3 vReflect;\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar envmap_pars_vertex = \\\"#ifdef USE_ENVMAP\\\\n\\\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\\\n\\\\t\\\\tvarying vec3 vWorldPosition;\\\\n\\\\t#else\\\\n\\\\t\\\\tvarying vec3 vReflect;\\\\n\\\\t\\\\tuniform float refractionRatio;\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar envmap_vertex = \\\"#ifdef USE_ENVMAP\\\\n\\\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\\\n\\\\t\\\\tvWorldPosition = worldPosition.xyz;\\\\n\\\\t#else\\\\n\\\\t\\\\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\\\n\\\\t\\\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\\\n\\\\t\\\\t#ifdef ENVMAP_MODE_REFLECTION\\\\n\\\\t\\\\t\\\\tvReflect = reflect( cameraToVertex, worldNormal );\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\\\n\\\\t\\\\t#endif\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar fog_vertex = \\\"\\\\n#ifdef USE_FOG\\\\nfogDepth = -mvPosition.z;\\\\n#endif\\\";\\r\\n\\r\\n\\tvar fog_pars_vertex = \\\"#ifdef USE_FOG\\\\n  varying float fogDepth;\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar fog_fragment = \\\"#ifdef USE_FOG\\\\n\\\\t#ifdef FOG_EXP2\\\\n\\\\t\\\\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\\\\n\\\\t#else\\\\n\\\\t\\\\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\\\\n\\\\t#endif\\\\n\\\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar fog_pars_fragment = \\\"#ifdef USE_FOG\\\\n\\\\tuniform vec3 fogColor;\\\\n\\\\tvarying float fogDepth;\\\\n\\\\t#ifdef FOG_EXP2\\\\n\\\\t\\\\tuniform float fogDensity;\\\\n\\\\t#else\\\\n\\\\t\\\\tuniform float fogNear;\\\\n\\\\t\\\\tuniform float fogFar;\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar gradientmap_pars_fragment = \\\"#ifdef TOON\\\\n\\\\tuniform sampler2D gradientMap;\\\\n\\\\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\\\n\\\\t\\\\tfloat dotNL = dot( normal, lightDirection );\\\\n\\\\t\\\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\\\n\\\\t\\\\t#ifdef USE_GRADIENTMAP\\\\n\\\\t\\\\t\\\\treturn texture2D( gradientMap, coord ).rgb;\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar lightmap_fragment = \\\"#ifdef USE_LIGHTMAP\\\\n\\\\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar lightmap_pars_fragment = \\\"#ifdef USE_LIGHTMAP\\\\n\\\\tuniform sampler2D lightMap;\\\\n\\\\tuniform float lightMapIntensity;\\\\n#endif\\\";\\r\\n\\r\\n\\tvar lights_lambert_vertex = \\\"vec3 diffuse = vec3( 1.0 );\\\\nGeometricContext geometry;\\\\ngeometry.position = mvPosition.xyz;\\\\ngeometry.normal = normalize( transformedNormal );\\\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\\\nGeometricContext backGeometry;\\\\nbackGeometry.position = geometry.position;\\\\nbackGeometry.normal = -geometry.normal;\\\\nbackGeometry.viewDir = geometry.viewDir;\\\\nvLightFront = vec3( 0.0 );\\\\n#ifdef DOUBLE_SIDED\\\\n\\\\tvLightBack = vec3( 0.0 );\\\\n#endif\\\\nIncidentLight directLight;\\\\nfloat dotNL;\\\\nvec3 directLightColor_Diffuse;\\\\n#if NUM_POINT_LIGHTS > 0\\\\n\\\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\\\n\\\\t\\\\tdotNL = dot( geometry.normal, directLight.direction );\\\\n\\\\t\\\\tdirectLightColor_Diffuse = PI * directLight.color;\\\\n\\\\t\\\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\\\n\\\\t\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\t\\\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\\n#endif\\\\n#if NUM_SPOT_LIGHTS > 0\\\\n\\\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\\\n\\\\t\\\\tdotNL = dot( geometry.normal, directLight.direction );\\\\n\\\\t\\\\tdirectLightColor_Diffuse = PI * directLight.color;\\\\n\\\\t\\\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\\\n\\\\t\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\t\\\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\\n#endif\\\\n#if NUM_DIR_LIGHTS > 0\\\\n\\\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\\\n\\\\t\\\\tdotNL = dot( geometry.normal, directLight.direction );\\\\n\\\\t\\\\tdirectLightColor_Diffuse = PI * directLight.color;\\\\n\\\\t\\\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\\\n\\\\t\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\t\\\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\\n#endif\\\\n#if NUM_HEMI_LIGHTS > 0\\\\n\\\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\\\n\\\\t\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\t\\\\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar lights_pars = \\\"uniform vec3 ambientLightColor;\\\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\\\n\\\\tvec3 irradiance = ambientLightColor;\\\\n\\\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\\\n\\\\t\\\\tirradiance *= PI;\\\\n\\\\t#endif\\\\n\\\\treturn irradiance;\\\\n}\\\\n#if NUM_DIR_LIGHTS > 0\\\\n\\\\tstruct DirectionalLight {\\\\n\\\\t\\\\tvec3 direction;\\\\n\\\\t\\\\tvec3 color;\\\\n\\\\t\\\\tint shadow;\\\\n\\\\t\\\\tfloat shadowBias;\\\\n\\\\t\\\\tfloat shadowRadius;\\\\n\\\\t\\\\tvec2 shadowMapSize;\\\\n\\\\t};\\\\n\\\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\\\n\\\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\\\n\\\\t\\\\tdirectLight.color = directionalLight.color;\\\\n\\\\t\\\\tdirectLight.direction = directionalLight.direction;\\\\n\\\\t\\\\tdirectLight.visible = true;\\\\n\\\\t}\\\\n#endif\\\\n#if NUM_POINT_LIGHTS > 0\\\\n\\\\tstruct PointLight {\\\\n\\\\t\\\\tvec3 position;\\\\n\\\\t\\\\tvec3 color;\\\\n\\\\t\\\\tfloat distance;\\\\n\\\\t\\\\tfloat decay;\\\\n\\\\t\\\\tint shadow;\\\\n\\\\t\\\\tfloat shadowBias;\\\\n\\\\t\\\\tfloat shadowRadius;\\\\n\\\\t\\\\tvec2 shadowMapSize;\\\\n\\\\t\\\\tfloat shadowCameraNear;\\\\n\\\\t\\\\tfloat shadowCameraFar;\\\\n\\\\t};\\\\n\\\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\\\n\\\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\\\n\\\\t\\\\tvec3 lVector = pointLight.position - geometry.position;\\\\n\\\\t\\\\tdirectLight.direction = normalize( lVector );\\\\n\\\\t\\\\tfloat lightDistance = length( lVector );\\\\n\\\\t\\\\tdirectLight.color = pointLight.color;\\\\n\\\\t\\\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\\\n\\\\t\\\\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\\\\n\\\\t}\\\\n#endif\\\\n#if NUM_SPOT_LIGHTS > 0\\\\n\\\\tstruct SpotLight {\\\\n\\\\t\\\\tvec3 position;\\\\n\\\\t\\\\tvec3 direction;\\\\n\\\\t\\\\tvec3 color;\\\\n\\\\t\\\\tfloat distance;\\\\n\\\\t\\\\tfloat decay;\\\\n\\\\t\\\\tfloat coneCos;\\\\n\\\\t\\\\tfloat penumbraCos;\\\\n\\\\t\\\\tint shadow;\\\\n\\\\t\\\\tfloat shadowBias;\\\\n\\\\t\\\\tfloat shadowRadius;\\\\n\\\\t\\\\tvec2 shadowMapSize;\\\\n\\\\t};\\\\n\\\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\\\n\\\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\\\n\\\\t\\\\tvec3 lVector = spotLight.position - geometry.position;\\\\n\\\\t\\\\tdirectLight.direction = normalize( lVector );\\\\n\\\\t\\\\tfloat lightDistance = length( lVector );\\\\n\\\\t\\\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\\\n\\\\t\\\\tif ( angleCos > spotLight.coneCos ) {\\\\n\\\\t\\\\t\\\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\\\n\\\\t\\\\t\\\\tdirectLight.color = spotLight.color;\\\\n\\\\t\\\\t\\\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\\\n\\\\t\\\\t\\\\tdirectLight.visible = true;\\\\n\\\\t\\\\t} else {\\\\n\\\\t\\\\t\\\\tdirectLight.color = vec3( 0.0 );\\\\n\\\\t\\\\t\\\\tdirectLight.visible = false;\\\\n\\\\t\\\\t}\\\\n\\\\t}\\\\n#endif\\\\n#if NUM_RECT_AREA_LIGHTS > 0\\\\n\\\\tstruct RectAreaLight {\\\\n\\\\t\\\\tvec3 color;\\\\n\\\\t\\\\tvec3 position;\\\\n\\\\t\\\\tvec3 halfWidth;\\\\n\\\\t\\\\tvec3 halfHeight;\\\\n\\\\t};\\\\n\\\\tuniform sampler2D ltcMat;\\\\tuniform sampler2D ltcMag;\\\\n\\\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\\\n#endif\\\\n#if NUM_HEMI_LIGHTS > 0\\\\n\\\\tstruct HemisphereLight {\\\\n\\\\t\\\\tvec3 direction;\\\\n\\\\t\\\\tvec3 skyColor;\\\\n\\\\t\\\\tvec3 groundColor;\\\\n\\\\t};\\\\n\\\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\\\n\\\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\\\n\\\\t\\\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\\\n\\\\t\\\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\\\n\\\\t\\\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\\\n\\\\t\\\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\\\n\\\\t\\\\t\\\\tirradiance *= PI;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\treturn irradiance;\\\\n\\\\t}\\\\n#endif\\\\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\\\n\\\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\\\n\\\\t\\\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\\\n\\\\t\\\\t#ifdef ENVMAP_TYPE_CUBE\\\\n\\\\t\\\\t\\\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\\\n\\\\t\\\\t\\\\t#ifdef TEXTURE_LOD_EXT\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\\\n\\\\t\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\\\n\\\\t\\\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\\\n\\\\t\\\\t\\\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\\\n\\\\t\\\\t\\\\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\tvec4 envMapColor = vec4( 0.0 );\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\treturn PI * envMapColor.rgb * envMapIntensity;\\\\n\\\\t}\\\\n\\\\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\\\n\\\\t\\\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\\\n\\\\t\\\\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\\\n\\\\t\\\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\\\n\\\\t}\\\\n\\\\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\\\n\\\\t\\\\t#ifdef ENVMAP_MODE_REFLECTION\\\\n\\\\t\\\\t\\\\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\\\n\\\\t\\\\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\\\n\\\\t\\\\t#ifdef ENVMAP_TYPE_CUBE\\\\n\\\\t\\\\t\\\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\\\n\\\\t\\\\t\\\\t#ifdef TEXTURE_LOD_EXT\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\\\n\\\\t\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\\\n\\\\t\\\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\\\n\\\\t\\\\t\\\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\\\n\\\\t\\\\t\\\\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\\\n\\\\t\\\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\\\n\\\\t\\\\t\\\\tvec2 sampleUV;\\\\n\\\\t\\\\t\\\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\\\n\\\\t\\\\t\\\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\\\n\\\\t\\\\t\\\\t#ifdef TEXTURE_LOD_EXT\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\\\n\\\\t\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\\\n\\\\t\\\\t#elif defined( ENVMAP_TYPE_SPHERE )\\\\n\\\\t\\\\t\\\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\\\n\\\\t\\\\t\\\\t#ifdef TEXTURE_LOD_EXT\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\\\n\\\\t\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\treturn envMapColor.rgb * envMapIntensity;\\\\n\\\\t}\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar lights_phong_fragment = \\\"BlinnPhongMaterial material;\\\\nmaterial.diffuseColor = diffuseColor.rgb;\\\\nmaterial.specularColor = specular;\\\\nmaterial.specularShininess = shininess;\\\\nmaterial.specularStrength = specularStrength;\\\\n\\\";\\r\\n\\r\\n\\tvar lights_phong_pars_fragment = \\\"varying vec3 vViewPosition;\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\nstruct BlinnPhongMaterial {\\\\n\\\\tvec3\\\\tdiffuseColor;\\\\n\\\\tvec3\\\\tspecularColor;\\\\n\\\\tfloat\\\\tspecularShininess;\\\\n\\\\tfloat\\\\tspecularStrength;\\\\n};\\\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\t#ifdef TOON\\\\n\\\\t\\\\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\\\\n\\\\t#else\\\\n\\\\t\\\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\\\n\\\\t\\\\tvec3 irradiance = dotNL * directLight.color;\\\\n\\\\t#endif\\\\n\\\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\\\n\\\\t\\\\tirradiance *= PI;\\\\n\\\\t#endif\\\\n\\\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\\\n\\\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\\\n}\\\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\\\n}\\\\n#define RE_Direct\\\\t\\\\t\\\\t\\\\tRE_Direct_BlinnPhong\\\\n#define RE_IndirectDiffuse\\\\t\\\\tRE_IndirectDiffuse_BlinnPhong\\\\n#define Material_LightProbeLOD( material )\\\\t(0)\\\\n\\\";\\r\\n\\r\\n\\tvar lights_physical_fragment = \\\"PhysicalMaterial material;\\\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\\\n#ifdef STANDARD\\\\n\\\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\\\n#else\\\\n\\\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\\\n\\\\tmaterial.clearCoat = saturate( clearCoat );\\\\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar lights_physical_pars_fragment = \\\"struct PhysicalMaterial {\\\\n\\\\tvec3\\\\tdiffuseColor;\\\\n\\\\tfloat\\\\tspecularRoughness;\\\\n\\\\tvec3\\\\tspecularColor;\\\\n\\\\t#ifndef STANDARD\\\\n\\\\t\\\\tfloat clearCoat;\\\\n\\\\t\\\\tfloat clearCoatRoughness;\\\\n\\\\t#endif\\\\n};\\\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\\\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\\\\n\\\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\\\n}\\\\n#if NUM_RECT_AREA_LIGHTS > 0\\\\n\\\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\t\\\\tvec3 normal = geometry.normal;\\\\n\\\\t\\\\tvec3 viewDir = geometry.viewDir;\\\\n\\\\t\\\\tvec3 position = geometry.position;\\\\n\\\\t\\\\tvec3 lightPos = rectAreaLight.position;\\\\n\\\\t\\\\tvec3 halfWidth = rectAreaLight.halfWidth;\\\\n\\\\t\\\\tvec3 halfHeight = rectAreaLight.halfHeight;\\\\n\\\\t\\\\tvec3 lightColor = rectAreaLight.color;\\\\n\\\\t\\\\tfloat roughness = material.specularRoughness;\\\\n\\\\t\\\\tvec3 rectCoords[ 4 ];\\\\n\\\\t\\\\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\\\\t\\\\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\\\\n\\\\t\\\\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\\\\n\\\\t\\\\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\\\\n\\\\t\\\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\\\n\\\\t\\\\tfloat norm = texture2D( ltcMag, uv ).a;\\\\n\\\\t\\\\tvec4 t = texture2D( ltcMat, uv );\\\\n\\\\t\\\\tmat3 mInv = mat3(\\\\n\\\\t\\\\t\\\\tvec3(   1,   0, t.y ),\\\\n\\\\t\\\\t\\\\tvec3(   0, t.z,   0 ),\\\\n\\\\t\\\\t\\\\tvec3( t.w,   0, t.x )\\\\n\\\\t\\\\t);\\\\n\\\\t\\\\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\\\n\\\\t\\\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\\\\n\\\\t}\\\\n#endif\\\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\\\n\\\\tvec3 irradiance = dotNL * directLight.color;\\\\n\\\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\\\n\\\\t\\\\tirradiance *= PI;\\\\n\\\\t#endif\\\\n\\\\t#ifndef STANDARD\\\\n\\\\t\\\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\\\n\\\\t#else\\\\n\\\\t\\\\tfloat clearCoatDHR = 0.0;\\\\n\\\\t#endif\\\\n\\\\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\\\n\\\\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\\\n\\\\t#ifndef STANDARD\\\\n\\\\t\\\\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\\\n\\\\t#endif\\\\n}\\\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\\\n}\\\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\t#ifndef STANDARD\\\\n\\\\t\\\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\\\n\\\\t\\\\tfloat dotNL = dotNV;\\\\n\\\\t\\\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\\\n\\\\t#else\\\\n\\\\t\\\\tfloat clearCoatDHR = 0.0;\\\\n\\\\t#endif\\\\n\\\\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\\\n\\\\t#ifndef STANDARD\\\\n\\\\t\\\\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\\\n\\\\t#endif\\\\n}\\\\n#define RE_Direct\\\\t\\\\t\\\\t\\\\tRE_Direct_Physical\\\\n#define RE_Direct_RectArea\\\\t\\\\tRE_Direct_RectArea_Physical\\\\n#define RE_IndirectDiffuse\\\\t\\\\tRE_IndirectDiffuse_Physical\\\\n#define RE_IndirectSpecular\\\\t\\\\tRE_IndirectSpecular_Physical\\\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\\\n\\\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar lights_template = \\\"\\\\nGeometricContext geometry;\\\\ngeometry.position = - vViewPosition;\\\\ngeometry.normal = normal;\\\\ngeometry.viewDir = normalize( vViewPosition );\\\\nIncidentLight directLight;\\\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\\\n\\\\tPointLight pointLight;\\\\n\\\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tpointLight = pointLights[ i ];\\\\n\\\\t\\\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\\\n\\\\t\\\\t#ifdef USE_SHADOWMAP\\\\n\\\\t\\\\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\tRE_Direct( directLight, geometry, material, reflectedLight );\\\\n\\\\t}\\\\n#endif\\\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\\\n\\\\tSpotLight spotLight;\\\\n\\\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tspotLight = spotLights[ i ];\\\\n\\\\t\\\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\\\n\\\\t\\\\t#ifdef USE_SHADOWMAP\\\\n\\\\t\\\\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\tRE_Direct( directLight, geometry, material, reflectedLight );\\\\n\\\\t}\\\\n#endif\\\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\\\n\\\\tDirectionalLight directionalLight;\\\\n\\\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tdirectionalLight = directionalLights[ i ];\\\\n\\\\t\\\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\\\n\\\\t\\\\t#ifdef USE_SHADOWMAP\\\\n\\\\t\\\\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\tRE_Direct( directLight, geometry, material, reflectedLight );\\\\n\\\\t}\\\\n#endif\\\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\\\n\\\\tRectAreaLight rectAreaLight;\\\\n\\\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\\\n\\\\t\\\\trectAreaLight = rectAreaLights[ i ];\\\\n\\\\t\\\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\\\n\\\\t}\\\\n#endif\\\\n#if defined( RE_IndirectDiffuse )\\\\n\\\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\\\n\\\\t#ifdef USE_LIGHTMAP\\\\n\\\\t\\\\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\\\n\\\\t\\\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\\\n\\\\t\\\\t\\\\tlightMapIrradiance *= PI;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\tirradiance += lightMapIrradiance;\\\\n\\\\t#endif\\\\n\\\\t#if ( NUM_HEMI_LIGHTS > 0 )\\\\n\\\\t\\\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\\\n\\\\t\\\\t\\\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\\\n\\\\t\\\\t}\\\\n\\\\t#endif\\\\n\\\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\\\n\\\\t\\\\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\\\n\\\\t#endif\\\\n\\\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\\\n#endif\\\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\\\n\\\\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\\\n\\\\t#ifndef STANDARD\\\\n\\\\t\\\\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\\\\n\\\\t#else\\\\n\\\\t\\\\tvec3 clearCoatRadiance = vec3( 0.0 );\\\\n\\\\t#endif\\\\n\\\\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar logdepthbuf_fragment = \\\"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\\\n\\\\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\\\\n#endif\\\";\\r\\n\\r\\n\\tvar logdepthbuf_pars_fragment = \\\"#ifdef USE_LOGDEPTHBUF\\\\n\\\\tuniform float logDepthBufFC;\\\\n\\\\t#ifdef USE_LOGDEPTHBUF_EXT\\\\n\\\\t\\\\tvarying float vFragDepth;\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar logdepthbuf_pars_vertex = \\\"#ifdef USE_LOGDEPTHBUF\\\\n\\\\t#ifdef USE_LOGDEPTHBUF_EXT\\\\n\\\\t\\\\tvarying float vFragDepth;\\\\n\\\\t#endif\\\\n\\\\tuniform float logDepthBufFC;\\\\n#endif\\\";\\r\\n\\r\\n\\tvar logdepthbuf_vertex = \\\"#ifdef USE_LOGDEPTHBUF\\\\n\\\\t#ifdef USE_LOGDEPTHBUF_EXT\\\\n\\\\t\\\\tvFragDepth = 1.0 + gl_Position.w;\\\\n\\\\t#else\\\\n\\\\t\\\\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\\\\n\\\\t\\\\tgl_Position.z *= gl_Position.w;\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar map_fragment = \\\"#ifdef USE_MAP\\\\n\\\\tvec4 texelColor = texture2D( map, vUv );\\\\n\\\\ttexelColor = mapTexelToLinear( texelColor );\\\\n\\\\tdiffuseColor *= texelColor;\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar map_pars_fragment = \\\"#ifdef USE_MAP\\\\n\\\\tuniform sampler2D map;\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar map_particle_fragment = \\\"#ifdef USE_MAP\\\\n\\\\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\\\n\\\\tvec4 mapTexel = texture2D( map, uv );\\\\n\\\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar map_particle_pars_fragment = \\\"#ifdef USE_MAP\\\\n\\\\tuniform mat3 uvTransform;\\\\n\\\\tuniform sampler2D map;\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar metalnessmap_fragment = \\\"float metalnessFactor = metalness;\\\\n#ifdef USE_METALNESSMAP\\\\n\\\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\\\n\\\\tmetalnessFactor *= texelMetalness.b;\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar metalnessmap_pars_fragment = \\\"#ifdef USE_METALNESSMAP\\\\n\\\\tuniform sampler2D metalnessMap;\\\\n#endif\\\";\\r\\n\\r\\n\\tvar morphnormal_vertex = \\\"#ifdef USE_MORPHNORMALS\\\\n\\\\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\\\n\\\\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\\\n\\\\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\\\n\\\\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar morphtarget_pars_vertex = \\\"#ifdef USE_MORPHTARGETS\\\\n\\\\t#ifndef USE_MORPHNORMALS\\\\n\\\\tuniform float morphTargetInfluences[ 8 ];\\\\n\\\\t#else\\\\n\\\\tuniform float morphTargetInfluences[ 4 ];\\\\n\\\\t#endif\\\\n#endif\\\";\\r\\n\\r\\n\\tvar morphtarget_vertex = \\\"#ifdef USE_MORPHTARGETS\\\\n\\\\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\\\n\\\\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\\\n\\\\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\\\n\\\\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\\\n\\\\t#ifndef USE_MORPHNORMALS\\\\n\\\\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\\\n\\\\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\\\n\\\\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\\\n\\\\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar normal_fragment = \\\"#ifdef FLAT_SHADED\\\\n\\\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\\\n\\\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\\\n\\\\tvec3 normal = normalize( cross( fdx, fdy ) );\\\\n#else\\\\n\\\\tvec3 normal = normalize( vNormal );\\\\n\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\\\n\\\\t#endif\\\\n#endif\\\\n#ifdef USE_NORMALMAP\\\\n\\\\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\\\n#elif defined( USE_BUMPMAP )\\\\n\\\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar normalmap_pars_fragment = \\\"#ifdef USE_NORMALMAP\\\\n\\\\tuniform sampler2D normalMap;\\\\n\\\\tuniform vec2 normalScale;\\\\n\\\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\\\n\\\\t\\\\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\\\n\\\\t\\\\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\\\n\\\\t\\\\tvec2 st0 = dFdx( vUv.st );\\\\n\\\\t\\\\tvec2 st1 = dFdy( vUv.st );\\\\n\\\\t\\\\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\\\n\\\\t\\\\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\\\n\\\\t\\\\tvec3 N = normalize( surf_norm );\\\\n\\\\t\\\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\\\n\\\\t\\\\tmapN.xy = normalScale * mapN.xy;\\\\n\\\\t\\\\tmat3 tsn = mat3( S, T, N );\\\\n\\\\t\\\\treturn normalize( tsn * mapN );\\\\n\\\\t}\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar packing = \\\"vec3 packNormalToRGB( const in vec3 normal ) {\\\\n\\\\treturn normalize( normal ) * 0.5 + 0.5;\\\\n}\\\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\\\n\\\\treturn 2.0 * rgb.xyz - 1.0;\\\\n}\\\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\\\nconst float ShiftRight8 = 1. / 256.;\\\\nvec4 packDepthToRGBA( const in float v ) {\\\\n\\\\tvec4 r = vec4( fract( v * PackFactors ), v );\\\\n\\\\tr.yzw -= r.xyz * ShiftRight8;\\\\treturn r * PackUpscale;\\\\n}\\\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\\\n\\\\treturn dot( v, UnpackFactors );\\\\n}\\\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\\\n\\\\treturn ( viewZ + near ) / ( near - far );\\\\n}\\\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\\\n\\\\treturn linearClipZ * ( near - far ) - near;\\\\n}\\\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\\\n\\\\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\\\n}\\\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\\\n\\\\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar premultiplied_alpha_fragment = \\\"#ifdef PREMULTIPLIED_ALPHA\\\\n\\\\tgl_FragColor.rgb *= gl_FragColor.a;\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar project_vertex = \\\"vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\\\ngl_Position = projectionMatrix * mvPosition;\\\\n\\\";\\r\\n\\r\\n\\tvar dithering_fragment = \\\"#if defined( DITHERING )\\\\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar dithering_pars_fragment = \\\"#if defined( DITHERING )\\\\n\\\\tvec3 dithering( vec3 color ) {\\\\n\\\\t\\\\tfloat grid_position = rand( gl_FragCoord.xy );\\\\n\\\\t\\\\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\\\n\\\\t\\\\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\\\n\\\\t\\\\treturn color + dither_shift_RGB;\\\\n\\\\t}\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar roughnessmap_fragment = \\\"float roughnessFactor = roughness;\\\\n#ifdef USE_ROUGHNESSMAP\\\\n\\\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\\\n\\\\troughnessFactor *= texelRoughness.g;\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar roughnessmap_pars_fragment = \\\"#ifdef USE_ROUGHNESSMAP\\\\n\\\\tuniform sampler2D roughnessMap;\\\\n#endif\\\";\\r\\n\\r\\n\\tvar shadowmap_pars_fragment = \\\"#ifdef USE_SHADOWMAP\\\\n\\\\t#if NUM_DIR_LIGHTS > 0\\\\n\\\\t\\\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\\\n\\\\t\\\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\\\n\\\\t#endif\\\\n\\\\t#if NUM_SPOT_LIGHTS > 0\\\\n\\\\t\\\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\\\n\\\\t\\\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\\\n\\\\t#endif\\\\n\\\\t#if NUM_POINT_LIGHTS > 0\\\\n\\\\t\\\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\\\n\\\\t\\\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\\\n\\\\t#endif\\\\n\\\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\\\n\\\\t\\\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\\\n\\\\t}\\\\n\\\\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\\\n\\\\t\\\\tconst vec2 offset = vec2( 0.0, 1.0 );\\\\n\\\\t\\\\tvec2 texelSize = vec2( 1.0 ) / size;\\\\n\\\\t\\\\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\\\n\\\\t\\\\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\\\n\\\\t\\\\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\\\n\\\\t\\\\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\\\n\\\\t\\\\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\\\n\\\\t\\\\tvec2 f = fract( uv * size + 0.5 );\\\\n\\\\t\\\\tfloat a = mix( lb, lt, f.y );\\\\n\\\\t\\\\tfloat b = mix( rb, rt, f.y );\\\\n\\\\t\\\\tfloat c = mix( a, b, f.x );\\\\n\\\\t\\\\treturn c;\\\\n\\\\t}\\\\n\\\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\\\n\\\\t\\\\tfloat shadow = 1.0;\\\\n\\\\t\\\\tshadowCoord.xyz /= shadowCoord.w;\\\\n\\\\t\\\\tshadowCoord.z += shadowBias;\\\\n\\\\t\\\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\\\n\\\\t\\\\tbool inFrustum = all( inFrustumVec );\\\\n\\\\t\\\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\\\n\\\\t\\\\tbool frustumTest = all( frustumTestVec );\\\\n\\\\t\\\\tif ( frustumTest ) {\\\\n\\\\t\\\\t#if defined( SHADOWMAP_TYPE_PCF )\\\\n\\\\t\\\\t\\\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\\\n\\\\t\\\\t\\\\tfloat dx0 = - texelSize.x * shadowRadius;\\\\n\\\\t\\\\t\\\\tfloat dy0 = - texelSize.y * shadowRadius;\\\\n\\\\t\\\\t\\\\tfloat dx1 = + texelSize.x * shadowRadius;\\\\n\\\\t\\\\t\\\\tfloat dy1 = + texelSize.y * shadowRadius;\\\\n\\\\t\\\\t\\\\tshadow = (\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\\\n\\\\t\\\\t\\\\t) * ( 1.0 / 9.0 );\\\\n\\\\t\\\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\\\n\\\\t\\\\t\\\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\\\n\\\\t\\\\t\\\\tfloat dx0 = - texelSize.x * shadowRadius;\\\\n\\\\t\\\\t\\\\tfloat dy0 = - texelSize.y * shadowRadius;\\\\n\\\\t\\\\t\\\\tfloat dx1 = + texelSize.x * shadowRadius;\\\\n\\\\t\\\\t\\\\tfloat dy1 = + texelSize.y * shadowRadius;\\\\n\\\\t\\\\t\\\\tshadow = (\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\\\n\\\\t\\\\t\\\\t) * ( 1.0 / 9.0 );\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\treturn shadow;\\\\n\\\\t}\\\\n\\\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\\\n\\\\t\\\\tvec3 absV = abs( v );\\\\n\\\\t\\\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\\\n\\\\t\\\\tabsV *= scaleToCube;\\\\n\\\\t\\\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\\\n\\\\t\\\\tvec2 planar = v.xy;\\\\n\\\\t\\\\tfloat almostATexel = 1.5 * texelSizeY;\\\\n\\\\t\\\\tfloat almostOne = 1.0 - almostATexel;\\\\n\\\\t\\\\tif ( absV.z >= almostOne ) {\\\\n\\\\t\\\\t\\\\tif ( v.z > 0.0 )\\\\n\\\\t\\\\t\\\\t\\\\tplanar.x = 4.0 - v.x;\\\\n\\\\t\\\\t} else if ( absV.x >= almostOne ) {\\\\n\\\\t\\\\t\\\\tfloat signX = sign( v.x );\\\\n\\\\t\\\\t\\\\tplanar.x = v.z * signX + 2.0 * signX;\\\\n\\\\t\\\\t} else if ( absV.y >= almostOne ) {\\\\n\\\\t\\\\t\\\\tfloat signY = sign( v.y );\\\\n\\\\t\\\\t\\\\tplanar.x = v.x + 2.0 * signY + 2.0;\\\\n\\\\t\\\\t\\\\tplanar.y = v.z * signY - 2.0;\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\\\n\\\\t}\\\\n\\\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\\\n\\\\t\\\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\\\n\\\\t\\\\tvec3 lightToPosition = shadowCoord.xyz;\\\\n\\\\t\\\\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\\\\t\\\\tdp += shadowBias;\\\\n\\\\t\\\\tvec3 bd3D = normalize( lightToPosition );\\\\n\\\\t\\\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\\\n\\\\t\\\\t\\\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\\\n\\\\t\\\\t\\\\treturn (\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\\\n\\\\t\\\\t\\\\t) * ( 1.0 / 9.0 );\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar shadowmap_pars_vertex = \\\"#ifdef USE_SHADOWMAP\\\\n\\\\t#if NUM_DIR_LIGHTS > 0\\\\n\\\\t\\\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\\\n\\\\t\\\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\\\n\\\\t#endif\\\\n\\\\t#if NUM_SPOT_LIGHTS > 0\\\\n\\\\t\\\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\\\n\\\\t\\\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\\\n\\\\t#endif\\\\n\\\\t#if NUM_POINT_LIGHTS > 0\\\\n\\\\t\\\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\\\n\\\\t\\\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar shadowmap_vertex = \\\"#ifdef USE_SHADOWMAP\\\\n\\\\t#if NUM_DIR_LIGHTS > 0\\\\n\\\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\\\n\\\\t}\\\\n\\\\t#endif\\\\n\\\\t#if NUM_SPOT_LIGHTS > 0\\\\n\\\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\\\n\\\\t}\\\\n\\\\t#endif\\\\n\\\\t#if NUM_POINT_LIGHTS > 0\\\\n\\\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\\\n\\\\t}\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar shadowmask_pars_fragment = \\\"float getShadowMask() {\\\\n\\\\tfloat shadow = 1.0;\\\\n\\\\t#ifdef USE_SHADOWMAP\\\\n\\\\t#if NUM_DIR_LIGHTS > 0\\\\n\\\\tDirectionalLight directionalLight;\\\\n\\\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tdirectionalLight = directionalLights[ i ];\\\\n\\\\t\\\\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\\\n\\\\t}\\\\n\\\\t#endif\\\\n\\\\t#if NUM_SPOT_LIGHTS > 0\\\\n\\\\tSpotLight spotLight;\\\\n\\\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tspotLight = spotLights[ i ];\\\\n\\\\t\\\\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\\\n\\\\t}\\\\n\\\\t#endif\\\\n\\\\t#if NUM_POINT_LIGHTS > 0\\\\n\\\\tPointLight pointLight;\\\\n\\\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tpointLight = pointLights[ i ];\\\\n\\\\t\\\\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\\\n\\\\t}\\\\n\\\\t#endif\\\\n\\\\t#endif\\\\n\\\\treturn shadow;\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar skinbase_vertex = \\\"#ifdef USE_SKINNING\\\\n\\\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\\\n\\\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\\\n\\\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\\\n\\\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\\\n#endif\\\";\\r\\n\\r\\n\\tvar skinning_pars_vertex = \\\"#ifdef USE_SKINNING\\\\n\\\\tuniform mat4 bindMatrix;\\\\n\\\\tuniform mat4 bindMatrixInverse;\\\\n\\\\t#ifdef BONE_TEXTURE\\\\n\\\\t\\\\tuniform sampler2D boneTexture;\\\\n\\\\t\\\\tuniform int boneTextureSize;\\\\n\\\\t\\\\tmat4 getBoneMatrix( const in float i ) {\\\\n\\\\t\\\\t\\\\tfloat j = i * 4.0;\\\\n\\\\t\\\\t\\\\tfloat x = mod( j, float( boneTextureSize ) );\\\\n\\\\t\\\\t\\\\tfloat y = floor( j / float( boneTextureSize ) );\\\\n\\\\t\\\\t\\\\tfloat dx = 1.0 / float( boneTextureSize );\\\\n\\\\t\\\\t\\\\tfloat dy = 1.0 / float( boneTextureSize );\\\\n\\\\t\\\\t\\\\ty = dy * ( y + 0.5 );\\\\n\\\\t\\\\t\\\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\\\n\\\\t\\\\t\\\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\\\n\\\\t\\\\t\\\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\\\n\\\\t\\\\t\\\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\\\n\\\\t\\\\t\\\\tmat4 bone = mat4( v1, v2, v3, v4 );\\\\n\\\\t\\\\t\\\\treturn bone;\\\\n\\\\t\\\\t}\\\\n\\\\t#else\\\\n\\\\t\\\\tuniform mat4 boneMatrices[ MAX_BONES ];\\\\n\\\\t\\\\tmat4 getBoneMatrix( const in float i ) {\\\\n\\\\t\\\\t\\\\tmat4 bone = boneMatrices[ int(i) ];\\\\n\\\\t\\\\t\\\\treturn bone;\\\\n\\\\t\\\\t}\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar skinning_vertex = \\\"#ifdef USE_SKINNING\\\\n\\\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\\\n\\\\tvec4 skinned = vec4( 0.0 );\\\\n\\\\tskinned += boneMatX * skinVertex * skinWeight.x;\\\\n\\\\tskinned += boneMatY * skinVertex * skinWeight.y;\\\\n\\\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\\\n\\\\tskinned += boneMatW * skinVertex * skinWeight.w;\\\\n\\\\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar skinnormal_vertex = \\\"#ifdef USE_SKINNING\\\\n\\\\tmat4 skinMatrix = mat4( 0.0 );\\\\n\\\\tskinMatrix += skinWeight.x * boneMatX;\\\\n\\\\tskinMatrix += skinWeight.y * boneMatY;\\\\n\\\\tskinMatrix += skinWeight.z * boneMatZ;\\\\n\\\\tskinMatrix += skinWeight.w * boneMatW;\\\\n\\\\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\\\n\\\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar specularmap_fragment = \\\"float specularStrength;\\\\n#ifdef USE_SPECULARMAP\\\\n\\\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\\\n\\\\tspecularStrength = texelSpecular.r;\\\\n#else\\\\n\\\\tspecularStrength = 1.0;\\\\n#endif\\\";\\r\\n\\r\\n\\tvar specularmap_pars_fragment = \\\"#ifdef USE_SPECULARMAP\\\\n\\\\tuniform sampler2D specularMap;\\\\n#endif\\\";\\r\\n\\r\\n\\tvar tonemapping_fragment = \\\"#if defined( TONE_MAPPING )\\\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar tonemapping_pars_fragment = \\\"#ifndef saturate\\\\n\\\\t#define saturate(a) clamp( a, 0.0, 1.0 )\\\\n#endif\\\\nuniform float toneMappingExposure;\\\\nuniform float toneMappingWhitePoint;\\\\nvec3 LinearToneMapping( vec3 color ) {\\\\n\\\\treturn toneMappingExposure * color;\\\\n}\\\\nvec3 ReinhardToneMapping( vec3 color ) {\\\\n\\\\tcolor *= toneMappingExposure;\\\\n\\\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\\\n}\\\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\\\n\\\\tcolor *= toneMappingExposure;\\\\n\\\\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\\\n}\\\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\\\n\\\\tcolor *= toneMappingExposure;\\\\n\\\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\\\n\\\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar uv_pars_fragment = \\\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\\\n\\\\tvarying vec2 vUv;\\\\n#endif\\\";\\r\\n\\r\\n\\tvar uv_pars_vertex = \\\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\\\n\\\\tvarying vec2 vUv;\\\\n\\\\tuniform mat3 uvTransform;\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar uv_vertex = \\\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\\\n\\\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\\\n#endif\\\";\\r\\n\\r\\n\\tvar uv2_pars_fragment = \\\"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\\\n\\\\tvarying vec2 vUv2;\\\\n#endif\\\";\\r\\n\\r\\n\\tvar uv2_pars_vertex = \\\"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\\\n\\\\tattribute vec2 uv2;\\\\n\\\\tvarying vec2 vUv2;\\\\n#endif\\\";\\r\\n\\r\\n\\tvar uv2_vertex = \\\"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\\\n\\\\tvUv2 = uv2;\\\\n#endif\\\";\\r\\n\\r\\n\\tvar worldpos_vertex = \\\"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\\\\n\\\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\\\n#endif\\\\n\\\";\\r\\n\\r\\n\\tvar cube_frag = \\\"uniform samplerCube tCube;\\\\nuniform float tFlip;\\\\nuniform float opacity;\\\\nvarying vec3 vWorldPosition;\\\\nvoid main() {\\\\n\\\\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\\\n\\\\tgl_FragColor.a *= opacity;\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar cube_vert = \\\"varying vec3 vWorldPosition;\\\\n#include <common>\\\\nvoid main() {\\\\n\\\\tvWorldPosition = transformDirection( position, modelMatrix );\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\tgl_Position.z = gl_Position.w;\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar depth_frag = \\\"#if DEPTH_PACKING == 3200\\\\n\\\\tuniform float opacity;\\\\n#endif\\\\n#include <common>\\\\n#include <packing>\\\\n#include <uv_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( 1.0 );\\\\n\\\\t#if DEPTH_PACKING == 3200\\\\n\\\\t\\\\tdiffuseColor.a = opacity;\\\\n\\\\t#endif\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#if DEPTH_PACKING == 3200\\\\n\\\\t\\\\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\\\\n\\\\t#elif DEPTH_PACKING == 3201\\\\n\\\\t\\\\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\\\n\\\\t#endif\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar depth_vert = \\\"#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <displacementmap_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#ifdef USE_DISPLACEMENTMAP\\\\n\\\\t\\\\t#include <beginnormal_vertex>\\\\n\\\\t\\\\t#include <morphnormal_vertex>\\\\n\\\\t\\\\t#include <skinnormal_vertex>\\\\n\\\\t#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <displacementmap_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar distanceRGBA_frag = \\\"#define DISTANCE\\\\nuniform vec3 referencePosition;\\\\nuniform float nearDistance;\\\\nuniform float farDistance;\\\\nvarying vec3 vWorldPosition;\\\\n#include <common>\\\\n#include <packing>\\\\n#include <uv_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main () {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( 1.0 );\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\tfloat dist = length( vWorldPosition - referencePosition );\\\\n\\\\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\\\n\\\\tdist = saturate( dist );\\\\n\\\\tgl_FragColor = packDepthToRGBA( dist );\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar distanceRGBA_vert = \\\"#define DISTANCE\\\\nvarying vec3 vWorldPosition;\\\\n#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <displacementmap_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#ifdef USE_DISPLACEMENTMAP\\\\n\\\\t\\\\t#include <beginnormal_vertex>\\\\n\\\\t\\\\t#include <morphnormal_vertex>\\\\n\\\\t\\\\t#include <skinnormal_vertex>\\\\n\\\\t#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <displacementmap_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\tvWorldPosition = worldPosition.xyz;\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar equirect_frag = \\\"uniform sampler2D tEquirect;\\\\nvarying vec3 vWorldPosition;\\\\n#include <common>\\\\nvoid main() {\\\\n\\\\tvec3 direction = normalize( vWorldPosition );\\\\n\\\\tvec2 sampleUV;\\\\n\\\\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\\\n\\\\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\\\n\\\\tgl_FragColor = texture2D( tEquirect, sampleUV );\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar equirect_vert = \\\"varying vec3 vWorldPosition;\\\\n#include <common>\\\\nvoid main() {\\\\n\\\\tvWorldPosition = transformDirection( position, modelMatrix );\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <project_vertex>\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar linedashed_frag = \\\"uniform vec3 diffuse;\\\\nuniform float opacity;\\\\nuniform float dashSize;\\\\nuniform float totalSize;\\\\nvarying float vLineDistance;\\\\n#include <common>\\\\n#include <color_pars_fragment>\\\\n#include <fog_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\\\n\\\\t\\\\tdiscard;\\\\n\\\\t}\\\\n\\\\tvec3 outgoingLight = vec3( 0.0 );\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\toutgoingLight = diffuseColor.rgb;\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar linedashed_vert = \\\"uniform float scale;\\\\nattribute float lineDistance;\\\\nvarying float vLineDistance;\\\\n#include <common>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <color_vertex>\\\\n\\\\tvLineDistance = scale * lineDistance;\\\\n\\\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\\\n\\\\tgl_Position = projectionMatrix * mvPosition;\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar meshbasic_frag = \\\"uniform vec3 diffuse;\\\\nuniform float opacity;\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\n#include <common>\\\\n#include <color_pars_fragment>\\\\n#include <uv_pars_fragment>\\\\n#include <uv2_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <aomap_pars_fragment>\\\\n#include <lightmap_pars_fragment>\\\\n#include <envmap_pars_fragment>\\\\n#include <fog_pars_fragment>\\\\n#include <specularmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\t#include <specularmap_fragment>\\\\n\\\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\\\n\\\\t#ifdef USE_LIGHTMAP\\\\n\\\\t\\\\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\\\n\\\\t#else\\\\n\\\\t\\\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\\\n\\\\t#endif\\\\n\\\\t#include <aomap_fragment>\\\\n\\\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\\\n\\\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\\\n\\\\t#include <envmap_fragment>\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar meshbasic_vert = \\\"#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <uv2_pars_vertex>\\\\n#include <envmap_pars_vertex>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <uv2_vertex>\\\\n\\\\t#include <color_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#ifdef USE_ENVMAP\\\\n\\\\t#include <beginnormal_vertex>\\\\n\\\\t#include <morphnormal_vertex>\\\\n\\\\t#include <skinnormal_vertex>\\\\n\\\\t#include <defaultnormal_vertex>\\\\n\\\\t#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\t#include <envmap_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar meshlambert_frag = \\\"uniform vec3 diffuse;\\\\nuniform vec3 emissive;\\\\nuniform float opacity;\\\\nvarying vec3 vLightFront;\\\\n#ifdef DOUBLE_SIDED\\\\n\\\\tvarying vec3 vLightBack;\\\\n#endif\\\\n#include <common>\\\\n#include <packing>\\\\n#include <dithering_pars_fragment>\\\\n#include <color_pars_fragment>\\\\n#include <uv_pars_fragment>\\\\n#include <uv2_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <aomap_pars_fragment>\\\\n#include <lightmap_pars_fragment>\\\\n#include <emissivemap_pars_fragment>\\\\n#include <envmap_pars_fragment>\\\\n#include <bsdfs>\\\\n#include <lights_pars>\\\\n#include <fog_pars_fragment>\\\\n#include <shadowmap_pars_fragment>\\\\n#include <shadowmask_pars_fragment>\\\\n#include <specularmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\\\n\\\\tvec3 totalEmissiveRadiance = emissive;\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\t#include <specularmap_fragment>\\\\n\\\\t#include <emissivemap_fragment>\\\\n\\\\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\\\n\\\\t#include <lightmap_fragment>\\\\n\\\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\\\n\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\\\n\\\\t#else\\\\n\\\\t\\\\treflectedLight.directDiffuse = vLightFront;\\\\n\\\\t#endif\\\\n\\\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\\\n\\\\t#include <aomap_fragment>\\\\n\\\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\\\n\\\\t#include <envmap_fragment>\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t#include <dithering_fragment>\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar meshlambert_vert = \\\"#define LAMBERT\\\\nvarying vec3 vLightFront;\\\\n#ifdef DOUBLE_SIDED\\\\n\\\\tvarying vec3 vLightBack;\\\\n#endif\\\\n#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <uv2_pars_vertex>\\\\n#include <envmap_pars_vertex>\\\\n#include <bsdfs>\\\\n#include <lights_pars>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <shadowmap_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <uv2_vertex>\\\\n\\\\t#include <color_vertex>\\\\n\\\\t#include <beginnormal_vertex>\\\\n\\\\t#include <morphnormal_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#include <skinnormal_vertex>\\\\n\\\\t#include <defaultnormal_vertex>\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <envmap_vertex>\\\\n\\\\t#include <lights_lambert_vertex>\\\\n\\\\t#include <shadowmap_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar meshphong_frag = \\\"#define PHONG\\\\nuniform vec3 diffuse;\\\\nuniform vec3 emissive;\\\\nuniform vec3 specular;\\\\nuniform float shininess;\\\\nuniform float opacity;\\\\n#include <common>\\\\n#include <packing>\\\\n#include <dithering_pars_fragment>\\\\n#include <color_pars_fragment>\\\\n#include <uv_pars_fragment>\\\\n#include <uv2_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <aomap_pars_fragment>\\\\n#include <lightmap_pars_fragment>\\\\n#include <emissivemap_pars_fragment>\\\\n#include <envmap_pars_fragment>\\\\n#include <gradientmap_pars_fragment>\\\\n#include <fog_pars_fragment>\\\\n#include <bsdfs>\\\\n#include <lights_pars>\\\\n#include <lights_phong_pars_fragment>\\\\n#include <shadowmap_pars_fragment>\\\\n#include <bumpmap_pars_fragment>\\\\n#include <normalmap_pars_fragment>\\\\n#include <specularmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\\\n\\\\tvec3 totalEmissiveRadiance = emissive;\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\t#include <specularmap_fragment>\\\\n\\\\t#include <normal_fragment>\\\\n\\\\t#include <emissivemap_fragment>\\\\n\\\\t#include <lights_phong_fragment>\\\\n\\\\t#include <lights_template>\\\\n\\\\t#include <aomap_fragment>\\\\n\\\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\\\n\\\\t#include <envmap_fragment>\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t#include <dithering_fragment>\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar meshphong_vert = \\\"#define PHONG\\\\nvarying vec3 vViewPosition;\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\n#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <uv2_pars_vertex>\\\\n#include <displacementmap_pars_vertex>\\\\n#include <envmap_pars_vertex>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <shadowmap_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <uv2_vertex>\\\\n\\\\t#include <color_vertex>\\\\n\\\\t#include <beginnormal_vertex>\\\\n\\\\t#include <morphnormal_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#include <skinnormal_vertex>\\\\n\\\\t#include <defaultnormal_vertex>\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvNormal = normalize( transformedNormal );\\\\n#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <displacementmap_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\tvViewPosition = - mvPosition.xyz;\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <envmap_vertex>\\\\n\\\\t#include <shadowmap_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar meshphysical_frag = \\\"#define PHYSICAL\\\\nuniform vec3 diffuse;\\\\nuniform vec3 emissive;\\\\nuniform float roughness;\\\\nuniform float metalness;\\\\nuniform float opacity;\\\\n#ifndef STANDARD\\\\n\\\\tuniform float clearCoat;\\\\n\\\\tuniform float clearCoatRoughness;\\\\n#endif\\\\nvarying vec3 vViewPosition;\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\n#include <common>\\\\n#include <packing>\\\\n#include <dithering_pars_fragment>\\\\n#include <color_pars_fragment>\\\\n#include <uv_pars_fragment>\\\\n#include <uv2_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <aomap_pars_fragment>\\\\n#include <lightmap_pars_fragment>\\\\n#include <emissivemap_pars_fragment>\\\\n#include <envmap_pars_fragment>\\\\n#include <fog_pars_fragment>\\\\n#include <bsdfs>\\\\n#include <cube_uv_reflection_fragment>\\\\n#include <lights_pars>\\\\n#include <lights_physical_pars_fragment>\\\\n#include <shadowmap_pars_fragment>\\\\n#include <bumpmap_pars_fragment>\\\\n#include <normalmap_pars_fragment>\\\\n#include <roughnessmap_pars_fragment>\\\\n#include <metalnessmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\\\n\\\\tvec3 totalEmissiveRadiance = emissive;\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\t#include <roughnessmap_fragment>\\\\n\\\\t#include <metalnessmap_fragment>\\\\n\\\\t#include <normal_fragment>\\\\n\\\\t#include <emissivemap_fragment>\\\\n\\\\t#include <lights_physical_fragment>\\\\n\\\\t#include <lights_template>\\\\n\\\\t#include <aomap_fragment>\\\\n\\\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t#include <dithering_fragment>\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar meshphysical_vert = \\\"#define PHYSICAL\\\\nvarying vec3 vViewPosition;\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\n#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <uv2_pars_vertex>\\\\n#include <displacementmap_pars_vertex>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <shadowmap_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <uv2_vertex>\\\\n\\\\t#include <color_vertex>\\\\n\\\\t#include <beginnormal_vertex>\\\\n\\\\t#include <morphnormal_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#include <skinnormal_vertex>\\\\n\\\\t#include <defaultnormal_vertex>\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvNormal = normalize( transformedNormal );\\\\n#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <displacementmap_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\tvViewPosition = - mvPosition.xyz;\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <shadowmap_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar normal_frag = \\\"#define NORMAL\\\\nuniform float opacity;\\\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\\\n\\\\tvarying vec3 vViewPosition;\\\\n#endif\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\n#include <packing>\\\\n#include <uv_pars_fragment>\\\\n#include <bumpmap_pars_fragment>\\\\n#include <normalmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <normal_fragment>\\\\n\\\\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar normal_vert = \\\"#define NORMAL\\\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\\\n\\\\tvarying vec3 vViewPosition;\\\\n#endif\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\n#include <uv_pars_vertex>\\\\n#include <displacementmap_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <beginnormal_vertex>\\\\n\\\\t#include <morphnormal_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#include <skinnormal_vertex>\\\\n\\\\t#include <defaultnormal_vertex>\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvNormal = normalize( transformedNormal );\\\\n#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <displacementmap_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\\\n\\\\tvViewPosition = - mvPosition.xyz;\\\\n#endif\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar points_frag = \\\"uniform vec3 diffuse;\\\\nuniform float opacity;\\\\n#include <common>\\\\n#include <packing>\\\\n#include <color_pars_fragment>\\\\n#include <map_particle_pars_fragment>\\\\n#include <fog_pars_fragment>\\\\n#include <shadowmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec3 outgoingLight = vec3( 0.0 );\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <map_particle_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\toutgoingLight = diffuseColor.rgb;\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar points_vert = \\\"uniform float size;\\\\nuniform float scale;\\\\n#include <common>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <shadowmap_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <color_vertex>\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#ifdef USE_SIZEATTENUATION\\\\n\\\\t\\\\tgl_PointSize = size * ( scale / - mvPosition.z );\\\\n\\\\t#else\\\\n\\\\t\\\\tgl_PointSize = size;\\\\n\\\\t#endif\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <shadowmap_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar shadow_frag = \\\"uniform vec3 color;\\\\nuniform float opacity;\\\\n#include <common>\\\\n#include <packing>\\\\n#include <fog_pars_fragment>\\\\n#include <bsdfs>\\\\n#include <lights_pars>\\\\n#include <shadowmap_pars_fragment>\\\\n#include <shadowmask_pars_fragment>\\\\nvoid main() {\\\\n\\\\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\\\n\\\\t#include <fog_fragment>\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar shadow_vert = \\\"#include <fog_pars_vertex>\\\\n#include <shadowmap_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <shadowmap_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\\n\\\";\\r\\n\\r\\n\\tvar ShaderChunk = {\\r\\n\\t\\talphamap_fragment: alphamap_fragment,\\r\\n\\t\\talphamap_pars_fragment: alphamap_pars_fragment,\\r\\n\\t\\talphatest_fragment: alphatest_fragment,\\r\\n\\t\\taomap_fragment: aomap_fragment,\\r\\n\\t\\taomap_pars_fragment: aomap_pars_fragment,\\r\\n\\t\\tbegin_vertex: begin_vertex,\\r\\n\\t\\tbeginnormal_vertex: beginnormal_vertex,\\r\\n\\t\\tbsdfs: bsdfs,\\r\\n\\t\\tbumpmap_pars_fragment: bumpmap_pars_fragment,\\r\\n\\t\\tclipping_planes_fragment: clipping_planes_fragment,\\r\\n\\t\\tclipping_planes_pars_fragment: clipping_planes_pars_fragment,\\r\\n\\t\\tclipping_planes_pars_vertex: clipping_planes_pars_vertex,\\r\\n\\t\\tclipping_planes_vertex: clipping_planes_vertex,\\r\\n\\t\\tcolor_fragment: color_fragment,\\r\\n\\t\\tcolor_pars_fragment: color_pars_fragment,\\r\\n\\t\\tcolor_pars_vertex: color_pars_vertex,\\r\\n\\t\\tcolor_vertex: color_vertex,\\r\\n\\t\\tcommon: common,\\r\\n\\t\\tcube_uv_reflection_fragment: cube_uv_reflection_fragment,\\r\\n\\t\\tdefaultnormal_vertex: defaultnormal_vertex,\\r\\n\\t\\tdisplacementmap_pars_vertex: displacementmap_pars_vertex,\\r\\n\\t\\tdisplacementmap_vertex: displacementmap_vertex,\\r\\n\\t\\temissivemap_fragment: emissivemap_fragment,\\r\\n\\t\\temissivemap_pars_fragment: emissivemap_pars_fragment,\\r\\n\\t\\tencodings_fragment: encodings_fragment,\\r\\n\\t\\tencodings_pars_fragment: encodings_pars_fragment,\\r\\n\\t\\tenvmap_fragment: envmap_fragment,\\r\\n\\t\\tenvmap_pars_fragment: envmap_pars_fragment,\\r\\n\\t\\tenvmap_pars_vertex: envmap_pars_vertex,\\r\\n\\t\\tenvmap_vertex: envmap_vertex,\\r\\n\\t\\tfog_vertex: fog_vertex,\\r\\n\\t\\tfog_pars_vertex: fog_pars_vertex,\\r\\n\\t\\tfog_fragment: fog_fragment,\\r\\n\\t\\tfog_pars_fragment: fog_pars_fragment,\\r\\n\\t\\tgradientmap_pars_fragment: gradientmap_pars_fragment,\\r\\n\\t\\tlightmap_fragment: lightmap_fragment,\\r\\n\\t\\tlightmap_pars_fragment: lightmap_pars_fragment,\\r\\n\\t\\tlights_lambert_vertex: lights_lambert_vertex,\\r\\n\\t\\tlights_pars: lights_pars,\\r\\n\\t\\tlights_phong_fragment: lights_phong_fragment,\\r\\n\\t\\tlights_phong_pars_fragment: lights_phong_pars_fragment,\\r\\n\\t\\tlights_physical_fragment: lights_physical_fragment,\\r\\n\\t\\tlights_physical_pars_fragment: lights_physical_pars_fragment,\\r\\n\\t\\tlights_template: lights_template,\\r\\n\\t\\tlogdepthbuf_fragment: logdepthbuf_fragment,\\r\\n\\t\\tlogdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\\r\\n\\t\\tlogdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\\r\\n\\t\\tlogdepthbuf_vertex: logdepthbuf_vertex,\\r\\n\\t\\tmap_fragment: map_fragment,\\r\\n\\t\\tmap_pars_fragment: map_pars_fragment,\\r\\n\\t\\tmap_particle_fragment: map_particle_fragment,\\r\\n\\t\\tmap_particle_pars_fragment: map_particle_pars_fragment,\\r\\n\\t\\tmetalnessmap_fragment: metalnessmap_fragment,\\r\\n\\t\\tmetalnessmap_pars_fragment: metalnessmap_pars_fragment,\\r\\n\\t\\tmorphnormal_vertex: morphnormal_vertex,\\r\\n\\t\\tmorphtarget_pars_vertex: morphtarget_pars_vertex,\\r\\n\\t\\tmorphtarget_vertex: morphtarget_vertex,\\r\\n\\t\\tnormal_fragment: normal_fragment,\\r\\n\\t\\tnormalmap_pars_fragment: normalmap_pars_fragment,\\r\\n\\t\\tpacking: packing,\\r\\n\\t\\tpremultiplied_alpha_fragment: premultiplied_alpha_fragment,\\r\\n\\t\\tproject_vertex: project_vertex,\\r\\n\\t\\tdithering_fragment: dithering_fragment,\\r\\n\\t\\tdithering_pars_fragment: dithering_pars_fragment,\\r\\n\\t\\troughnessmap_fragment: roughnessmap_fragment,\\r\\n\\t\\troughnessmap_pars_fragment: roughnessmap_pars_fragment,\\r\\n\\t\\tshadowmap_pars_fragment: shadowmap_pars_fragment,\\r\\n\\t\\tshadowmap_pars_vertex: shadowmap_pars_vertex,\\r\\n\\t\\tshadowmap_vertex: shadowmap_vertex,\\r\\n\\t\\tshadowmask_pars_fragment: shadowmask_pars_fragment,\\r\\n\\t\\tskinbase_vertex: skinbase_vertex,\\r\\n\\t\\tskinning_pars_vertex: skinning_pars_vertex,\\r\\n\\t\\tskinning_vertex: skinning_vertex,\\r\\n\\t\\tskinnormal_vertex: skinnormal_vertex,\\r\\n\\t\\tspecularmap_fragment: specularmap_fragment,\\r\\n\\t\\tspecularmap_pars_fragment: specularmap_pars_fragment,\\r\\n\\t\\ttonemapping_fragment: tonemapping_fragment,\\r\\n\\t\\ttonemapping_pars_fragment: tonemapping_pars_fragment,\\r\\n\\t\\tuv_pars_fragment: uv_pars_fragment,\\r\\n\\t\\tuv_pars_vertex: uv_pars_vertex,\\r\\n\\t\\tuv_vertex: uv_vertex,\\r\\n\\t\\tuv2_pars_fragment: uv2_pars_fragment,\\r\\n\\t\\tuv2_pars_vertex: uv2_pars_vertex,\\r\\n\\t\\tuv2_vertex: uv2_vertex,\\r\\n\\t\\tworldpos_vertex: worldpos_vertex,\\r\\n\\r\\n\\t\\tcube_frag: cube_frag,\\r\\n\\t\\tcube_vert: cube_vert,\\r\\n\\t\\tdepth_frag: depth_frag,\\r\\n\\t\\tdepth_vert: depth_vert,\\r\\n\\t\\tdistanceRGBA_frag: distanceRGBA_frag,\\r\\n\\t\\tdistanceRGBA_vert: distanceRGBA_vert,\\r\\n\\t\\tequirect_frag: equirect_frag,\\r\\n\\t\\tequirect_vert: equirect_vert,\\r\\n\\t\\tlinedashed_frag: linedashed_frag,\\r\\n\\t\\tlinedashed_vert: linedashed_vert,\\r\\n\\t\\tmeshbasic_frag: meshbasic_frag,\\r\\n\\t\\tmeshbasic_vert: meshbasic_vert,\\r\\n\\t\\tmeshlambert_frag: meshlambert_frag,\\r\\n\\t\\tmeshlambert_vert: meshlambert_vert,\\r\\n\\t\\tmeshphong_frag: meshphong_frag,\\r\\n\\t\\tmeshphong_vert: meshphong_vert,\\r\\n\\t\\tmeshphysical_frag: meshphysical_frag,\\r\\n\\t\\tmeshphysical_vert: meshphysical_vert,\\r\\n\\t\\tnormal_frag: normal_frag,\\r\\n\\t\\tnormal_vert: normal_vert,\\r\\n\\t\\tpoints_frag: points_frag,\\r\\n\\t\\tpoints_vert: points_vert,\\r\\n\\t\\tshadow_frag: shadow_frag,\\r\\n\\t\\tshadow_vert: shadow_vert\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author mikael emtinger / http://gomo.se/\\r\\n\\t */\\r\\n\\r\\n\\tvar ShaderLib = {\\r\\n\\r\\n\\t\\tbasic: {\\r\\n\\r\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\r\\n\\t\\t\\t\\tUniformsLib.common,\\r\\n\\t\\t\\t\\tUniformsLib.specularmap,\\r\\n\\t\\t\\t\\tUniformsLib.envmap,\\r\\n\\t\\t\\t\\tUniformsLib.aomap,\\r\\n\\t\\t\\t\\tUniformsLib.lightmap,\\r\\n\\t\\t\\t\\tUniformsLib.fog\\r\\n\\t\\t\\t] ),\\r\\n\\r\\n\\t\\t\\tvertexShader: ShaderChunk.meshbasic_vert,\\r\\n\\t\\t\\tfragmentShader: ShaderChunk.meshbasic_frag\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tlambert: {\\r\\n\\r\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\r\\n\\t\\t\\t\\tUniformsLib.common,\\r\\n\\t\\t\\t\\tUniformsLib.specularmap,\\r\\n\\t\\t\\t\\tUniformsLib.envmap,\\r\\n\\t\\t\\t\\tUniformsLib.aomap,\\r\\n\\t\\t\\t\\tUniformsLib.lightmap,\\r\\n\\t\\t\\t\\tUniformsLib.emissivemap,\\r\\n\\t\\t\\t\\tUniformsLib.fog,\\r\\n\\t\\t\\t\\tUniformsLib.lights,\\r\\n\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\temissive: { value: new Color( 0x000000 ) }\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t] ),\\r\\n\\r\\n\\t\\t\\tvertexShader: ShaderChunk.meshlambert_vert,\\r\\n\\t\\t\\tfragmentShader: ShaderChunk.meshlambert_frag\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tphong: {\\r\\n\\r\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\r\\n\\t\\t\\t\\tUniformsLib.common,\\r\\n\\t\\t\\t\\tUniformsLib.specularmap,\\r\\n\\t\\t\\t\\tUniformsLib.envmap,\\r\\n\\t\\t\\t\\tUniformsLib.aomap,\\r\\n\\t\\t\\t\\tUniformsLib.lightmap,\\r\\n\\t\\t\\t\\tUniformsLib.emissivemap,\\r\\n\\t\\t\\t\\tUniformsLib.bumpmap,\\r\\n\\t\\t\\t\\tUniformsLib.normalmap,\\r\\n\\t\\t\\t\\tUniformsLib.displacementmap,\\r\\n\\t\\t\\t\\tUniformsLib.gradientmap,\\r\\n\\t\\t\\t\\tUniformsLib.fog,\\r\\n\\t\\t\\t\\tUniformsLib.lights,\\r\\n\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\temissive: { value: new Color( 0x000000 ) },\\r\\n\\t\\t\\t\\t\\tspecular: { value: new Color( 0x111111 ) },\\r\\n\\t\\t\\t\\t\\tshininess: { value: 30 }\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t] ),\\r\\n\\r\\n\\t\\t\\tvertexShader: ShaderChunk.meshphong_vert,\\r\\n\\t\\t\\tfragmentShader: ShaderChunk.meshphong_frag\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tstandard: {\\r\\n\\r\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\r\\n\\t\\t\\t\\tUniformsLib.common,\\r\\n\\t\\t\\t\\tUniformsLib.envmap,\\r\\n\\t\\t\\t\\tUniformsLib.aomap,\\r\\n\\t\\t\\t\\tUniformsLib.lightmap,\\r\\n\\t\\t\\t\\tUniformsLib.emissivemap,\\r\\n\\t\\t\\t\\tUniformsLib.bumpmap,\\r\\n\\t\\t\\t\\tUniformsLib.normalmap,\\r\\n\\t\\t\\t\\tUniformsLib.displacementmap,\\r\\n\\t\\t\\t\\tUniformsLib.roughnessmap,\\r\\n\\t\\t\\t\\tUniformsLib.metalnessmap,\\r\\n\\t\\t\\t\\tUniformsLib.fog,\\r\\n\\t\\t\\t\\tUniformsLib.lights,\\r\\n\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\temissive: { value: new Color( 0x000000 ) },\\r\\n\\t\\t\\t\\t\\troughness: { value: 0.5 },\\r\\n\\t\\t\\t\\t\\tmetalness: { value: 0.5 },\\r\\n\\t\\t\\t\\t\\tenvMapIntensity: { value: 1 } // temporary\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t] ),\\r\\n\\r\\n\\t\\t\\tvertexShader: ShaderChunk.meshphysical_vert,\\r\\n\\t\\t\\tfragmentShader: ShaderChunk.meshphysical_frag\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tpoints: {\\r\\n\\r\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\r\\n\\t\\t\\t\\tUniformsLib.points,\\r\\n\\t\\t\\t\\tUniformsLib.fog\\r\\n\\t\\t\\t] ),\\r\\n\\r\\n\\t\\t\\tvertexShader: ShaderChunk.points_vert,\\r\\n\\t\\t\\tfragmentShader: ShaderChunk.points_frag\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdashed: {\\r\\n\\r\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\r\\n\\t\\t\\t\\tUniformsLib.common,\\r\\n\\t\\t\\t\\tUniformsLib.fog,\\r\\n\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\tscale: { value: 1 },\\r\\n\\t\\t\\t\\t\\tdashSize: { value: 1 },\\r\\n\\t\\t\\t\\t\\ttotalSize: { value: 2 }\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t] ),\\r\\n\\r\\n\\t\\t\\tvertexShader: ShaderChunk.linedashed_vert,\\r\\n\\t\\t\\tfragmentShader: ShaderChunk.linedashed_frag\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdepth: {\\r\\n\\r\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\r\\n\\t\\t\\t\\tUniformsLib.common,\\r\\n\\t\\t\\t\\tUniformsLib.displacementmap\\r\\n\\t\\t\\t] ),\\r\\n\\r\\n\\t\\t\\tvertexShader: ShaderChunk.depth_vert,\\r\\n\\t\\t\\tfragmentShader: ShaderChunk.depth_frag\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tnormal: {\\r\\n\\r\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\r\\n\\t\\t\\t\\tUniformsLib.common,\\r\\n\\t\\t\\t\\tUniformsLib.bumpmap,\\r\\n\\t\\t\\t\\tUniformsLib.normalmap,\\r\\n\\t\\t\\t\\tUniformsLib.displacementmap,\\r\\n\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\topacity: { value: 1.0 }\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t] ),\\r\\n\\r\\n\\t\\t\\tvertexShader: ShaderChunk.normal_vert,\\r\\n\\t\\t\\tfragmentShader: ShaderChunk.normal_frag\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t/* -------------------------------------------------------------------------\\r\\n\\t\\t//\\tCube map shader\\r\\n\\t\\t ------------------------------------------------------------------------- */\\r\\n\\r\\n\\t\\tcube: {\\r\\n\\r\\n\\t\\t\\tuniforms: {\\r\\n\\t\\t\\t\\ttCube: { value: null },\\r\\n\\t\\t\\t\\ttFlip: { value: - 1 },\\r\\n\\t\\t\\t\\topacity: { value: 1.0 }\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tvertexShader: ShaderChunk.cube_vert,\\r\\n\\t\\t\\tfragmentShader: ShaderChunk.cube_frag\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tequirect: {\\r\\n\\r\\n\\t\\t\\tuniforms: {\\r\\n\\t\\t\\t\\ttEquirect: { value: null },\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tvertexShader: ShaderChunk.equirect_vert,\\r\\n\\t\\t\\tfragmentShader: ShaderChunk.equirect_frag\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdistanceRGBA: {\\r\\n\\r\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\r\\n\\t\\t\\t\\tUniformsLib.common,\\r\\n\\t\\t\\t\\tUniformsLib.displacementmap,\\r\\n\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\treferencePosition: { value: new Vector3() },\\r\\n\\t\\t\\t\\t\\tnearDistance: { value: 1 },\\r\\n\\t\\t\\t\\t\\tfarDistance: { value: 1000 }\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t] ),\\r\\n\\r\\n\\t\\t\\tvertexShader: ShaderChunk.distanceRGBA_vert,\\r\\n\\t\\t\\tfragmentShader: ShaderChunk.distanceRGBA_frag\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tshadow: {\\r\\n\\r\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\r\\n\\t\\t\\t\\tUniformsLib.lights,\\r\\n\\t\\t\\t\\tUniformsLib.fog,\\r\\n\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\tcolor: { value: new Color( 0x00000 ) },\\r\\n\\t\\t\\t\\t\\topacity: { value: 1.0 }\\r\\n\\t\\t\\t\\t},\\r\\n\\t\\t\\t] ),\\r\\n\\r\\n\\t\\t\\tvertexShader: ShaderChunk.shadow_vert,\\r\\n\\t\\t\\tfragmentShader: ShaderChunk.shadow_frag\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tShaderLib.physical = {\\r\\n\\r\\n\\t\\tuniforms: UniformsUtils.merge( [\\r\\n\\t\\t\\tShaderLib.standard.uniforms,\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\tclearCoat: { value: 0 },\\r\\n\\t\\t\\t\\tclearCoatRoughness: { value: 0 }\\r\\n\\t\\t\\t}\\r\\n\\t\\t] ),\\r\\n\\r\\n\\t\\tvertexShader: ShaderChunk.meshphysical_vert,\\r\\n\\t\\tfragmentShader: ShaderChunk.meshphysical_frag\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author bhouston / http://clara.io\\r\\n\\t */\\r\\n\\r\\n\\tfunction Box2( min, max ) {\\r\\n\\r\\n\\t\\tthis.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );\\r\\n\\t\\tthis.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( Box2.prototype, {\\r\\n\\r\\n\\t\\tset: function ( min, max ) {\\r\\n\\r\\n\\t\\t\\tthis.min.copy( min );\\r\\n\\t\\t\\tthis.max.copy( max );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFromPoints: function ( points ) {\\r\\n\\r\\n\\t\\t\\tthis.makeEmpty();\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.expandByPoint( points[ i ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFromCenterAndSize: function () {\\r\\n\\r\\n\\t\\t\\tvar v1 = new Vector2();\\r\\n\\r\\n\\t\\t\\treturn function setFromCenterAndSize( center, size ) {\\r\\n\\r\\n\\t\\t\\t\\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\\r\\n\\t\\t\\t\\tthis.min.copy( center ).sub( halfSize );\\r\\n\\t\\t\\t\\tthis.max.copy( center ).add( halfSize );\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( box ) {\\r\\n\\r\\n\\t\\t\\tthis.min.copy( box.min );\\r\\n\\t\\t\\tthis.max.copy( box.max );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmakeEmpty: function () {\\r\\n\\r\\n\\t\\t\\tthis.min.x = this.min.y = + Infinity;\\r\\n\\t\\t\\tthis.max.x = this.max.y = - Infinity;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tisEmpty: function () {\\r\\n\\r\\n\\t\\t\\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\\r\\n\\r\\n\\t\\t\\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetCenter: function ( optionalTarget ) {\\r\\n\\r\\n\\t\\t\\tvar result = optionalTarget || new Vector2();\\r\\n\\t\\t\\treturn this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetSize: function ( optionalTarget ) {\\r\\n\\r\\n\\t\\t\\tvar result = optionalTarget || new Vector2();\\r\\n\\t\\t\\treturn this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\texpandByPoint: function ( point ) {\\r\\n\\r\\n\\t\\t\\tthis.min.min( point );\\r\\n\\t\\t\\tthis.max.max( point );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\texpandByVector: function ( vector ) {\\r\\n\\r\\n\\t\\t\\tthis.min.sub( vector );\\r\\n\\t\\t\\tthis.max.add( vector );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\texpandByScalar: function ( scalar ) {\\r\\n\\r\\n\\t\\t\\tthis.min.addScalar( - scalar );\\r\\n\\t\\t\\tthis.max.addScalar( scalar );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcontainsPoint: function ( point ) {\\r\\n\\r\\n\\t\\t\\treturn point.x < this.min.x || point.x > this.max.x ||\\r\\n\\t\\t\\t\\tpoint.y < this.min.y || point.y > this.max.y ? false : true;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcontainsBox: function ( box ) {\\r\\n\\r\\n\\t\\t\\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\\r\\n\\t\\t\\t\\tthis.min.y <= box.min.y && box.max.y <= this.max.y;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetParameter: function ( point, optionalTarget ) {\\r\\n\\r\\n\\t\\t\\t// This can potentially have a divide by zero if the box\\r\\n\\t\\t\\t// has a size dimension of 0.\\r\\n\\r\\n\\t\\t\\tvar result = optionalTarget || new Vector2();\\r\\n\\r\\n\\t\\t\\treturn result.set(\\r\\n\\t\\t\\t\\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\\r\\n\\t\\t\\t\\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tintersectsBox: function ( box ) {\\r\\n\\r\\n\\t\\t\\t// using 4 splitting planes to rule out intersections\\r\\n\\r\\n\\t\\t\\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\\r\\n\\t\\t\\t\\tbox.max.y < this.min.y || box.min.y > this.max.y ? false : true;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclampPoint: function ( point, optionalTarget ) {\\r\\n\\r\\n\\t\\t\\tvar result = optionalTarget || new Vector2();\\r\\n\\t\\t\\treturn result.copy( point ).clamp( this.min, this.max );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdistanceToPoint: function () {\\r\\n\\r\\n\\t\\t\\tvar v1 = new Vector2();\\r\\n\\r\\n\\t\\t\\treturn function distanceToPoint( point ) {\\r\\n\\r\\n\\t\\t\\t\\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\\r\\n\\t\\t\\t\\treturn clampedPoint.sub( point ).length();\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tintersect: function ( box ) {\\r\\n\\r\\n\\t\\t\\tthis.min.max( box.min );\\r\\n\\t\\t\\tthis.max.min( box.max );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tunion: function ( box ) {\\r\\n\\r\\n\\t\\t\\tthis.min.min( box.min );\\r\\n\\t\\t\\tthis.max.max( box.max );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttranslate: function ( offset ) {\\r\\n\\r\\n\\t\\t\\tthis.min.add( offset );\\r\\n\\t\\t\\tthis.max.add( offset );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tequals: function ( box ) {\\r\\n\\r\\n\\t\\t\\treturn box.min.equals( this.min ) && box.max.equals( this.max );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mikael emtinger / http://gomo.se/\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction WebGLFlareRenderer( renderer, gl, state, textures, capabilities ) {\\r\\n\\r\\n\\t\\tvar vertexBuffer, elementBuffer;\\r\\n\\t\\tvar shader, program, attributes, uniforms;\\r\\n\\r\\n\\t\\tvar tempTexture, occlusionTexture;\\r\\n\\r\\n\\t\\tfunction init() {\\r\\n\\r\\n\\t\\t\\tvar vertices = new Float32Array( [\\r\\n\\t\\t\\t\\t- 1, - 1, 0, 0,\\r\\n\\t\\t\\t\\t  1, - 1, 1, 0,\\r\\n\\t\\t\\t\\t  1, 1, 1, 1,\\r\\n\\t\\t\\t\\t- 1, 1, 0, 1\\r\\n\\t\\t\\t] );\\r\\n\\r\\n\\t\\t\\tvar faces = new Uint16Array( [\\r\\n\\t\\t\\t\\t0, 1, 2,\\r\\n\\t\\t\\t\\t0, 2, 3\\r\\n\\t\\t\\t] );\\r\\n\\r\\n\\t\\t\\t// buffers\\r\\n\\r\\n\\t\\t\\tvertexBuffer = gl.createBuffer();\\r\\n\\t\\t\\telementBuffer = gl.createBuffer();\\r\\n\\r\\n\\t\\t\\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\\r\\n\\t\\t\\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\\r\\n\\r\\n\\t\\t\\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\\r\\n\\t\\t\\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\\r\\n\\r\\n\\t\\t\\t// textures\\r\\n\\r\\n\\t\\t\\ttempTexture = gl.createTexture();\\r\\n\\t\\t\\tocclusionTexture = gl.createTexture();\\r\\n\\r\\n\\t\\t\\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\\r\\n\\t\\t\\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\\r\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\\r\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\\r\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\\r\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\\r\\n\\r\\n\\t\\t\\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\\r\\n\\t\\t\\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\\r\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\\r\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\\r\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\\r\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\\r\\n\\r\\n\\t\\t\\tshader = {\\r\\n\\r\\n\\t\\t\\t\\tvertexShader: [\\r\\n\\r\\n\\t\\t\\t\\t\\t'uniform lowp int renderType;',\\r\\n\\r\\n\\t\\t\\t\\t\\t'uniform vec3 screenPosition;',\\r\\n\\t\\t\\t\\t\\t'uniform vec2 scale;',\\r\\n\\t\\t\\t\\t\\t'uniform float rotation;',\\r\\n\\r\\n\\t\\t\\t\\t\\t'uniform sampler2D occlusionMap;',\\r\\n\\r\\n\\t\\t\\t\\t\\t'attribute vec2 position;',\\r\\n\\t\\t\\t\\t\\t'attribute vec2 uv;',\\r\\n\\r\\n\\t\\t\\t\\t\\t'varying vec2 vUV;',\\r\\n\\t\\t\\t\\t\\t'varying float vVisibility;',\\r\\n\\r\\n\\t\\t\\t\\t\\t'void main() {',\\r\\n\\r\\n\\t\\t\\t\\t\\t'\\tvUV = uv;',\\r\\n\\r\\n\\t\\t\\t\\t\\t'\\tvec2 pos = position;',\\r\\n\\r\\n\\t\\t\\t\\t\\t'\\tif ( renderType == 2 ) {',\\r\\n\\r\\n\\t\\t\\t\\t\\t'\\t\\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );',\\r\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );',\\r\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );',\\r\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );',\\r\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );',\\r\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );',\\r\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );',\\r\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );',\\r\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );',\\r\\n\\r\\n\\t\\t\\t\\t\\t'\\t\\tvVisibility =        visibility.r / 9.0;',\\r\\n\\t\\t\\t\\t\\t'\\t\\tvVisibility *= 1.0 - visibility.g / 9.0;',\\r\\n\\t\\t\\t\\t\\t'\\t\\tvVisibility *=       visibility.b / 9.0;',\\r\\n\\t\\t\\t\\t\\t'\\t\\tvVisibility *= 1.0 - visibility.a / 9.0;',\\r\\n\\r\\n\\t\\t\\t\\t\\t'\\t\\tpos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;',\\r\\n\\t\\t\\t\\t\\t'\\t\\tpos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;',\\r\\n\\r\\n\\t\\t\\t\\t\\t'\\t}',\\r\\n\\r\\n\\t\\t\\t\\t\\t'\\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );',\\r\\n\\r\\n\\t\\t\\t\\t\\t'}'\\r\\n\\r\\n\\t\\t\\t\\t].join( '\\\\n' ),\\r\\n\\r\\n\\t\\t\\t\\tfragmentShader: [\\r\\n\\r\\n\\t\\t\\t\\t\\t'uniform lowp int renderType;',\\r\\n\\r\\n\\t\\t\\t\\t\\t'uniform sampler2D map;',\\r\\n\\t\\t\\t\\t\\t'uniform float opacity;',\\r\\n\\t\\t\\t\\t\\t'uniform vec3 color;',\\r\\n\\r\\n\\t\\t\\t\\t\\t'varying vec2 vUV;',\\r\\n\\t\\t\\t\\t\\t'varying float vVisibility;',\\r\\n\\r\\n\\t\\t\\t\\t\\t'void main() {',\\r\\n\\r\\n\\t\\t\\t\\t\\t// pink square\\r\\n\\r\\n\\t\\t\\t\\t\\t'\\tif ( renderType == 0 ) {',\\r\\n\\r\\n\\t\\t\\t\\t\\t'\\t\\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );',\\r\\n\\r\\n\\t\\t\\t\\t\\t// restore\\r\\n\\r\\n\\t\\t\\t\\t\\t'\\t} else if ( renderType == 1 ) {',\\r\\n\\r\\n\\t\\t\\t\\t\\t'\\t\\tgl_FragColor = texture2D( map, vUV );',\\r\\n\\r\\n\\t\\t\\t\\t\\t// flare\\r\\n\\r\\n\\t\\t\\t\\t\\t'\\t} else {',\\r\\n\\r\\n\\t\\t\\t\\t\\t'\\t\\tvec4 texture = texture2D( map, vUV );',\\r\\n\\t\\t\\t\\t\\t'\\t\\ttexture.a *= opacity * vVisibility;',\\r\\n\\t\\t\\t\\t\\t'\\t\\tgl_FragColor = texture;',\\r\\n\\t\\t\\t\\t\\t'\\t\\tgl_FragColor.rgb *= color;',\\r\\n\\r\\n\\t\\t\\t\\t\\t'\\t}',\\r\\n\\r\\n\\t\\t\\t\\t\\t'}'\\r\\n\\r\\n\\t\\t\\t\\t].join( '\\\\n' )\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\tprogram = createProgram( shader );\\r\\n\\r\\n\\t\\t\\tattributes = {\\r\\n\\t\\t\\t\\tvertex: gl.getAttribLocation( program, 'position' ),\\r\\n\\t\\t\\t\\tuv: gl.getAttribLocation( program, 'uv' )\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\tuniforms = {\\r\\n\\t\\t\\t\\trenderType: gl.getUniformLocation( program, 'renderType' ),\\r\\n\\t\\t\\t\\tmap: gl.getUniformLocation( program, 'map' ),\\r\\n\\t\\t\\t\\tocclusionMap: gl.getUniformLocation( program, 'occlusionMap' ),\\r\\n\\t\\t\\t\\topacity: gl.getUniformLocation( program, 'opacity' ),\\r\\n\\t\\t\\t\\tcolor: gl.getUniformLocation( program, 'color' ),\\r\\n\\t\\t\\t\\tscale: gl.getUniformLocation( program, 'scale' ),\\r\\n\\t\\t\\t\\trotation: gl.getUniformLocation( program, 'rotation' ),\\r\\n\\t\\t\\t\\tscreenPosition: gl.getUniformLocation( program, 'screenPosition' )\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t/*\\r\\n\\t\\t * Render lens flares\\r\\n\\t\\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\\r\\n\\t\\t *         reads these back and calculates occlusion.\\r\\n\\t\\t */\\r\\n\\r\\n\\t\\tthis.render = function ( flares, scene, camera, viewport ) {\\r\\n\\r\\n\\t\\t\\tif ( flares.length === 0 ) return;\\r\\n\\r\\n\\t\\t\\tvar tempPosition = new Vector3();\\r\\n\\r\\n\\t\\t\\tvar invAspect = viewport.w / viewport.z,\\r\\n\\t\\t\\t\\thalfViewportWidth = viewport.z * 0.5,\\r\\n\\t\\t\\t\\thalfViewportHeight = viewport.w * 0.5;\\r\\n\\r\\n\\t\\t\\tvar size = 16 / viewport.w,\\r\\n\\t\\t\\t\\tscale = new Vector2( size * invAspect, size );\\r\\n\\r\\n\\t\\t\\tvar screenPosition = new Vector3( 1, 1, 0 ),\\r\\n\\t\\t\\t\\tscreenPositionPixels = new Vector2( 1, 1 );\\r\\n\\r\\n\\t\\t\\tvar validArea = new Box2();\\r\\n\\r\\n\\t\\t\\tvalidArea.min.set( viewport.x, viewport.y );\\r\\n\\t\\t\\tvalidArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );\\r\\n\\r\\n\\t\\t\\tif ( program === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tinit();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tstate.useProgram( program );\\r\\n\\r\\n\\t\\t\\tstate.initAttributes();\\r\\n\\t\\t\\tstate.enableAttribute( attributes.vertex );\\r\\n\\t\\t\\tstate.enableAttribute( attributes.uv );\\r\\n\\t\\t\\tstate.disableUnusedAttributes();\\r\\n\\r\\n\\t\\t\\t// loop through all lens flares to update their occlusion and positions\\r\\n\\t\\t\\t// setup gl and common used attribs/uniforms\\r\\n\\r\\n\\t\\t\\tgl.uniform1i( uniforms.occlusionMap, 0 );\\r\\n\\t\\t\\tgl.uniform1i( uniforms.map, 1 );\\r\\n\\r\\n\\t\\t\\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\\r\\n\\t\\t\\tgl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\\r\\n\\t\\t\\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\\r\\n\\r\\n\\t\\t\\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\\r\\n\\r\\n\\t\\t\\tstate.disable( gl.CULL_FACE );\\r\\n\\t\\t\\tstate.buffers.depth.setMask( false );\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = flares.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tsize = 16 / viewport.w;\\r\\n\\t\\t\\t\\tscale.set( size * invAspect, size );\\r\\n\\r\\n\\t\\t\\t\\t// calc object screen position\\r\\n\\r\\n\\t\\t\\t\\tvar flare = flares[ i ];\\r\\n\\r\\n\\t\\t\\t\\ttempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );\\r\\n\\r\\n\\t\\t\\t\\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\\r\\n\\t\\t\\t\\ttempPosition.applyMatrix4( camera.projectionMatrix );\\r\\n\\r\\n\\t\\t\\t\\t// setup arrays for gl programs\\r\\n\\r\\n\\t\\t\\t\\tscreenPosition.copy( tempPosition );\\r\\n\\r\\n\\t\\t\\t\\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\\r\\n\\r\\n\\t\\t\\t\\tscreenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;\\r\\n\\t\\t\\t\\tscreenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;\\r\\n\\r\\n\\t\\t\\t\\t// screen cull\\r\\n\\r\\n\\t\\t\\t\\tif ( validArea.containsPoint( screenPositionPixels ) === true ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// save current RGB to temp texture\\r\\n\\r\\n\\t\\t\\t\\t\\tstate.activeTexture( gl.TEXTURE0 );\\r\\n\\t\\t\\t\\t\\tstate.bindTexture( gl.TEXTURE_2D, null );\\r\\n\\t\\t\\t\\t\\tstate.activeTexture( gl.TEXTURE1 );\\r\\n\\t\\t\\t\\t\\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\\r\\n\\t\\t\\t\\t\\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\\r\\n\\r\\n\\r\\n\\t\\t\\t\\t\\t// render pink quad\\r\\n\\r\\n\\t\\t\\t\\t\\tgl.uniform1i( uniforms.renderType, 0 );\\r\\n\\t\\t\\t\\t\\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\\r\\n\\t\\t\\t\\t\\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\\r\\n\\r\\n\\t\\t\\t\\t\\tstate.disable( gl.BLEND );\\r\\n\\t\\t\\t\\t\\tstate.enable( gl.DEPTH_TEST );\\r\\n\\r\\n\\t\\t\\t\\t\\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\\r\\n\\r\\n\\r\\n\\t\\t\\t\\t\\t// copy result to occlusionMap\\r\\n\\r\\n\\t\\t\\t\\t\\tstate.activeTexture( gl.TEXTURE0 );\\r\\n\\t\\t\\t\\t\\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\\r\\n\\t\\t\\t\\t\\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\\r\\n\\r\\n\\r\\n\\t\\t\\t\\t\\t// restore graphics\\r\\n\\r\\n\\t\\t\\t\\t\\tgl.uniform1i( uniforms.renderType, 1 );\\r\\n\\t\\t\\t\\t\\tstate.disable( gl.DEPTH_TEST );\\r\\n\\r\\n\\t\\t\\t\\t\\tstate.activeTexture( gl.TEXTURE1 );\\r\\n\\t\\t\\t\\t\\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\\r\\n\\t\\t\\t\\t\\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\\r\\n\\r\\n\\r\\n\\t\\t\\t\\t\\t// update object positions\\r\\n\\r\\n\\t\\t\\t\\t\\tflare.positionScreen.copy( screenPosition );\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( flare.customUpdateCallback ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tflare.customUpdateCallback( flare );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tflare.updateLensFlares();\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t// render flares\\r\\n\\r\\n\\t\\t\\t\\t\\tgl.uniform1i( uniforms.renderType, 2 );\\r\\n\\t\\t\\t\\t\\tstate.enable( gl.BLEND );\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar sprite = flare.lensFlares[ j ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tscreenPosition.x = sprite.x;\\r\\n\\t\\t\\t\\t\\t\\t\\tscreenPosition.y = sprite.y;\\r\\n\\t\\t\\t\\t\\t\\t\\tscreenPosition.z = sprite.z;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tsize = sprite.size * sprite.scale / viewport.w;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tscale.x = size * invAspect;\\r\\n\\t\\t\\t\\t\\t\\t\\tscale.y = size;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\\r\\n\\t\\t\\t\\t\\t\\t\\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\\r\\n\\t\\t\\t\\t\\t\\t\\tgl.uniform1f( uniforms.rotation, sprite.rotation );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tgl.uniform1f( uniforms.opacity, sprite.opacity );\\r\\n\\t\\t\\t\\t\\t\\t\\tgl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tstate.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\ttextures.setTexture2D( sprite.texture, 1 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// restore gl\\r\\n\\r\\n\\t\\t\\tstate.enable( gl.CULL_FACE );\\r\\n\\t\\t\\tstate.enable( gl.DEPTH_TEST );\\r\\n\\t\\t\\tstate.buffers.depth.setMask( true );\\r\\n\\r\\n\\t\\t\\tstate.reset();\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tfunction createProgram( shader ) {\\r\\n\\r\\n\\t\\t\\tvar program = gl.createProgram();\\r\\n\\r\\n\\t\\t\\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\\r\\n\\t\\t\\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\\r\\n\\r\\n\\t\\t\\tvar prefix = 'precision ' + capabilities.precision + ' float;\\\\n';\\r\\n\\r\\n\\t\\t\\tgl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\\r\\n\\t\\t\\tgl.shaderSource( vertexShader, prefix + shader.vertexShader );\\r\\n\\r\\n\\t\\t\\tgl.compileShader( fragmentShader );\\r\\n\\t\\t\\tgl.compileShader( vertexShader );\\r\\n\\r\\n\\t\\t\\tgl.attachShader( program, fragmentShader );\\r\\n\\t\\t\\tgl.attachShader( program, vertexShader );\\r\\n\\r\\n\\t\\t\\tgl.linkProgram( program );\\r\\n\\r\\n\\t\\t\\treturn program;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\\r\\n\\r\\n\\t\\tTexture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\\r\\n\\r\\n\\t\\tthis.needsUpdate = true;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tCanvasTexture.prototype = Object.create( Texture.prototype );\\r\\n\\tCanvasTexture.prototype.constructor = CanvasTexture;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mikael emtinger / http://gomo.se/\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction WebGLSpriteRenderer( renderer, gl, state, textures, capabilities ) {\\r\\n\\r\\n\\t\\tvar vertexBuffer, elementBuffer;\\r\\n\\t\\tvar program, attributes, uniforms;\\r\\n\\r\\n\\t\\tvar texture;\\r\\n\\r\\n\\t\\t// decompose matrixWorld\\r\\n\\r\\n\\t\\tvar spritePosition = new Vector3();\\r\\n\\t\\tvar spriteRotation = new Quaternion();\\r\\n\\t\\tvar spriteScale = new Vector3();\\r\\n\\r\\n\\t\\tfunction init() {\\r\\n\\r\\n\\t\\t\\tvar vertices = new Float32Array( [\\r\\n\\t\\t\\t\\t- 0.5, - 0.5, 0, 0,\\r\\n\\t\\t\\t\\t  0.5, - 0.5, 1, 0,\\r\\n\\t\\t\\t\\t  0.5, 0.5, 1, 1,\\r\\n\\t\\t\\t\\t- 0.5, 0.5, 0, 1\\r\\n\\t\\t\\t] );\\r\\n\\r\\n\\t\\t\\tvar faces = new Uint16Array( [\\r\\n\\t\\t\\t\\t0, 1, 2,\\r\\n\\t\\t\\t\\t0, 2, 3\\r\\n\\t\\t\\t] );\\r\\n\\r\\n\\t\\t\\tvertexBuffer = gl.createBuffer();\\r\\n\\t\\t\\telementBuffer = gl.createBuffer();\\r\\n\\r\\n\\t\\t\\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\\r\\n\\t\\t\\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\\r\\n\\r\\n\\t\\t\\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\\r\\n\\t\\t\\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\\r\\n\\r\\n\\t\\t\\tprogram = createProgram();\\r\\n\\r\\n\\t\\t\\tattributes = {\\r\\n\\t\\t\\t\\tposition: gl.getAttribLocation( program, 'position' ),\\r\\n\\t\\t\\t\\tuv: gl.getAttribLocation( program, 'uv' )\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\tuniforms = {\\r\\n\\t\\t\\t\\tuvOffset: gl.getUniformLocation( program, 'uvOffset' ),\\r\\n\\t\\t\\t\\tuvScale: gl.getUniformLocation( program, 'uvScale' ),\\r\\n\\r\\n\\t\\t\\t\\trotation: gl.getUniformLocation( program, 'rotation' ),\\r\\n\\t\\t\\t\\tscale: gl.getUniformLocation( program, 'scale' ),\\r\\n\\r\\n\\t\\t\\t\\tcolor: gl.getUniformLocation( program, 'color' ),\\r\\n\\t\\t\\t\\tmap: gl.getUniformLocation( program, 'map' ),\\r\\n\\t\\t\\t\\topacity: gl.getUniformLocation( program, 'opacity' ),\\r\\n\\r\\n\\t\\t\\t\\tmodelViewMatrix: gl.getUniformLocation( program, 'modelViewMatrix' ),\\r\\n\\t\\t\\t\\tprojectionMatrix: gl.getUniformLocation( program, 'projectionMatrix' ),\\r\\n\\r\\n\\t\\t\\t\\tfogType: gl.getUniformLocation( program, 'fogType' ),\\r\\n\\t\\t\\t\\tfogDensity: gl.getUniformLocation( program, 'fogDensity' ),\\r\\n\\t\\t\\t\\tfogNear: gl.getUniformLocation( program, 'fogNear' ),\\r\\n\\t\\t\\t\\tfogFar: gl.getUniformLocation( program, 'fogFar' ),\\r\\n\\t\\t\\t\\tfogColor: gl.getUniformLocation( program, 'fogColor' ),\\r\\n\\t\\t\\t\\tfogDepth: gl.getUniformLocation( program, 'fogDepth' ),\\r\\n\\r\\n\\t\\t\\t\\talphaTest: gl.getUniformLocation( program, 'alphaTest' )\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\\r\\n\\t\\t\\tcanvas.width = 8;\\r\\n\\t\\t\\tcanvas.height = 8;\\r\\n\\r\\n\\t\\t\\tvar context = canvas.getContext( '2d' );\\r\\n\\t\\t\\tcontext.fillStyle = 'white';\\r\\n\\t\\t\\tcontext.fillRect( 0, 0, 8, 8 );\\r\\n\\r\\n\\t\\t\\ttexture = new CanvasTexture( canvas );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.render = function ( sprites, scene, camera ) {\\r\\n\\r\\n\\t\\t\\tif ( sprites.length === 0 ) return;\\r\\n\\r\\n\\t\\t\\t// setup gl\\r\\n\\r\\n\\t\\t\\tif ( program === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tinit();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tstate.useProgram( program );\\r\\n\\r\\n\\t\\t\\tstate.initAttributes();\\r\\n\\t\\t\\tstate.enableAttribute( attributes.position );\\r\\n\\t\\t\\tstate.enableAttribute( attributes.uv );\\r\\n\\t\\t\\tstate.disableUnusedAttributes();\\r\\n\\r\\n\\t\\t\\tstate.disable( gl.CULL_FACE );\\r\\n\\t\\t\\tstate.enable( gl.BLEND );\\r\\n\\r\\n\\t\\t\\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\\r\\n\\t\\t\\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\\r\\n\\t\\t\\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\\r\\n\\r\\n\\t\\t\\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\\r\\n\\r\\n\\t\\t\\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\\r\\n\\r\\n\\t\\t\\tstate.activeTexture( gl.TEXTURE0 );\\r\\n\\t\\t\\tgl.uniform1i( uniforms.map, 0 );\\r\\n\\r\\n\\t\\t\\tvar oldFogType = 0;\\r\\n\\t\\t\\tvar sceneFogType = 0;\\r\\n\\t\\t\\tvar fog = scene.fog;\\r\\n\\r\\n\\t\\t\\tif ( fog ) {\\r\\n\\r\\n\\t\\t\\t\\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\\r\\n\\r\\n\\t\\t\\t\\tif ( fog.isFog ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tgl.uniform1f( uniforms.fogNear, fog.near );\\r\\n\\t\\t\\t\\t\\tgl.uniform1f( uniforms.fogFar, fog.far );\\r\\n\\r\\n\\t\\t\\t\\t\\tgl.uniform1i( uniforms.fogType, 1 );\\r\\n\\t\\t\\t\\t\\toldFogType = 1;\\r\\n\\t\\t\\t\\t\\tsceneFogType = 1;\\r\\n\\r\\n\\t\\t\\t\\t} else if ( fog.isFogExp2 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tgl.uniform1f( uniforms.fogDensity, fog.density );\\r\\n\\r\\n\\t\\t\\t\\t\\tgl.uniform1i( uniforms.fogType, 2 );\\r\\n\\t\\t\\t\\t\\toldFogType = 2;\\r\\n\\t\\t\\t\\t\\tsceneFogType = 2;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tgl.uniform1i( uniforms.fogType, 0 );\\r\\n\\t\\t\\t\\toldFogType = 0;\\r\\n\\t\\t\\t\\tsceneFogType = 0;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\t\\t// update positions and sort\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar sprite = sprites[ i ];\\r\\n\\r\\n\\t\\t\\t\\tsprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\\r\\n\\t\\t\\t\\tsprite.z = - sprite.modelViewMatrix.elements[ 14 ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tsprites.sort( painterSortStable );\\r\\n\\r\\n\\t\\t\\t// render all sprites\\r\\n\\r\\n\\t\\t\\tvar scale = [];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar sprite = sprites[ i ];\\r\\n\\t\\t\\t\\tvar material = sprite.material;\\r\\n\\r\\n\\t\\t\\t\\tif ( material.visible === false ) continue;\\r\\n\\r\\n\\t\\t\\t\\tsprite.onBeforeRender( renderer, scene, camera, undefined, material, undefined );\\r\\n\\r\\n\\t\\t\\t\\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\\r\\n\\t\\t\\t\\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\\r\\n\\r\\n\\t\\t\\t\\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\\r\\n\\r\\n\\t\\t\\t\\tscale[ 0 ] = spriteScale.x;\\r\\n\\t\\t\\t\\tscale[ 1 ] = spriteScale.y;\\r\\n\\r\\n\\t\\t\\t\\tvar fogType = 0;\\r\\n\\r\\n\\t\\t\\t\\tif ( scene.fog && material.fog ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tfogType = sceneFogType;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( oldFogType !== fogType ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tgl.uniform1i( uniforms.fogType, fogType );\\r\\n\\t\\t\\t\\t\\toldFogType = fogType;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( material.map !== null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\\r\\n\\t\\t\\t\\t\\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\\r\\n\\t\\t\\t\\t\\tgl.uniform2f( uniforms.uvScale, 1, 1 );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tgl.uniform1f( uniforms.opacity, material.opacity );\\r\\n\\t\\t\\t\\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\\r\\n\\r\\n\\t\\t\\t\\tgl.uniform1f( uniforms.rotation, material.rotation );\\r\\n\\t\\t\\t\\tgl.uniform2fv( uniforms.scale, scale );\\r\\n\\r\\n\\t\\t\\t\\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\\r\\n\\t\\t\\t\\tstate.buffers.depth.setTest( material.depthTest );\\r\\n\\t\\t\\t\\tstate.buffers.depth.setMask( material.depthWrite );\\r\\n\\t\\t\\t\\tstate.buffers.color.setMask( material.colorWrite );\\r\\n\\r\\n\\t\\t\\t\\ttextures.setTexture2D( material.map || texture, 0 );\\r\\n\\r\\n\\t\\t\\t\\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\\r\\n\\r\\n\\t\\t\\t\\tsprite.onAfterRender( renderer, scene, camera, undefined, material, undefined );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// restore gl\\r\\n\\r\\n\\t\\t\\tstate.enable( gl.CULL_FACE );\\r\\n\\r\\n\\t\\t\\tstate.reset();\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tfunction createProgram() {\\r\\n\\r\\n\\t\\t\\tvar program = gl.createProgram();\\r\\n\\r\\n\\t\\t\\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\\r\\n\\t\\t\\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\\r\\n\\r\\n\\t\\t\\tgl.shaderSource( vertexShader, [\\r\\n\\r\\n\\t\\t\\t\\t'precision ' + capabilities.precision + ' float;',\\r\\n\\r\\n\\t\\t\\t\\t'#define SHADER_NAME ' + 'SpriteMaterial',\\r\\n\\r\\n\\t\\t\\t\\t'uniform mat4 modelViewMatrix;',\\r\\n\\t\\t\\t\\t'uniform mat4 projectionMatrix;',\\r\\n\\t\\t\\t\\t'uniform float rotation;',\\r\\n\\t\\t\\t\\t'uniform vec2 scale;',\\r\\n\\t\\t\\t\\t'uniform vec2 uvOffset;',\\r\\n\\t\\t\\t\\t'uniform vec2 uvScale;',\\r\\n\\r\\n\\t\\t\\t\\t'attribute vec2 position;',\\r\\n\\t\\t\\t\\t'attribute vec2 uv;',\\r\\n\\r\\n\\t\\t\\t\\t'varying vec2 vUV;',\\r\\n\\t\\t\\t\\t'varying float fogDepth;',\\r\\n\\r\\n\\t\\t\\t\\t'void main() {',\\r\\n\\r\\n\\t\\t\\t\\t'\\tvUV = uvOffset + uv * uvScale;',\\r\\n\\r\\n\\t\\t\\t\\t'\\tvec2 alignedPosition = position * scale;',\\r\\n\\r\\n\\t\\t\\t\\t'\\tvec2 rotatedPosition;',\\r\\n\\t\\t\\t\\t'\\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\\r\\n\\t\\t\\t\\t'\\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\\r\\n\\r\\n\\t\\t\\t\\t'\\tvec4 mvPosition;',\\r\\n\\r\\n\\t\\t\\t\\t'\\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\\r\\n\\t\\t\\t\\t'\\tmvPosition.xy += rotatedPosition;',\\r\\n\\r\\n\\t\\t\\t\\t'\\tgl_Position = projectionMatrix * mvPosition;',\\r\\n\\r\\n\\t\\t\\t\\t'\\tfogDepth = - mvPosition.z;',\\r\\n\\r\\n\\t\\t\\t\\t'}'\\r\\n\\r\\n\\t\\t\\t].join( '\\\\n' ) );\\r\\n\\r\\n\\t\\t\\tgl.shaderSource( fragmentShader, [\\r\\n\\r\\n\\t\\t\\t\\t'precision ' + capabilities.precision + ' float;',\\r\\n\\r\\n\\t\\t\\t\\t'#define SHADER_NAME ' + 'SpriteMaterial',\\r\\n\\r\\n\\t\\t\\t\\t'uniform vec3 color;',\\r\\n\\t\\t\\t\\t'uniform sampler2D map;',\\r\\n\\t\\t\\t\\t'uniform float opacity;',\\r\\n\\r\\n\\t\\t\\t\\t'uniform int fogType;',\\r\\n\\t\\t\\t\\t'uniform vec3 fogColor;',\\r\\n\\t\\t\\t\\t'uniform float fogDensity;',\\r\\n\\t\\t\\t\\t'uniform float fogNear;',\\r\\n\\t\\t\\t\\t'uniform float fogFar;',\\r\\n\\t\\t\\t\\t'uniform float alphaTest;',\\r\\n\\r\\n\\t\\t\\t\\t'varying vec2 vUV;',\\r\\n\\t\\t\\t\\t'varying float fogDepth;',\\r\\n\\r\\n\\t\\t\\t\\t'void main() {',\\r\\n\\r\\n\\t\\t\\t\\t'\\tvec4 texture = texture2D( map, vUV );',\\r\\n\\r\\n\\t\\t\\t\\t'\\tgl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\\r\\n\\r\\n\\t\\t\\t\\t'\\tif ( gl_FragColor.a < alphaTest ) discard;',\\r\\n\\r\\n\\t\\t\\t\\t'\\tif ( fogType > 0 ) {',\\r\\n\\r\\n\\t\\t\\t\\t'\\t\\tfloat fogFactor = 0.0;',\\r\\n\\r\\n\\t\\t\\t\\t'\\t\\tif ( fogType == 1 ) {',\\r\\n\\r\\n\\t\\t\\t\\t'\\t\\t\\tfogFactor = smoothstep( fogNear, fogFar, fogDepth );',\\r\\n\\r\\n\\t\\t\\t\\t'\\t\\t} else {',\\r\\n\\r\\n\\t\\t\\t\\t'\\t\\t\\tconst float LOG2 = 1.442695;',\\r\\n\\t\\t\\t\\t'\\t\\t\\tfogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );',\\r\\n\\t\\t\\t\\t'\\t\\t\\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\\r\\n\\r\\n\\t\\t\\t\\t'\\t\\t}',\\r\\n\\r\\n\\t\\t\\t\\t'\\t\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );',\\r\\n\\r\\n\\t\\t\\t\\t'\\t}',\\r\\n\\r\\n\\t\\t\\t\\t'}'\\r\\n\\r\\n\\t\\t\\t].join( '\\\\n' ) );\\r\\n\\r\\n\\t\\t\\tgl.compileShader( vertexShader );\\r\\n\\t\\t\\tgl.compileShader( fragmentShader );\\r\\n\\r\\n\\t\\t\\tgl.attachShader( program, vertexShader );\\r\\n\\t\\t\\tgl.attachShader( program, fragmentShader );\\r\\n\\r\\n\\t\\t\\tgl.linkProgram( program );\\r\\n\\r\\n\\t\\t\\treturn program;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction painterSortStable( a, b ) {\\r\\n\\r\\n\\t\\t\\tif ( a.renderOrder !== b.renderOrder ) {\\r\\n\\r\\n\\t\\t\\t\\treturn a.renderOrder - b.renderOrder;\\r\\n\\r\\n\\t\\t\\t} else if ( a.z !== b.z ) {\\r\\n\\r\\n\\t\\t\\t\\treturn b.z - a.z;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\treturn b.id - a.id;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t */\\r\\n\\r\\n\\tvar materialId = 0;\\r\\n\\r\\n\\tfunction Material() {\\r\\n\\r\\n\\t\\tObject.defineProperty( this, 'id', { value: materialId ++ } );\\r\\n\\r\\n\\t\\tthis.uuid = _Math.generateUUID();\\r\\n\\r\\n\\t\\tthis.name = '';\\r\\n\\t\\tthis.type = 'Material';\\r\\n\\r\\n\\t\\tthis.fog = true;\\r\\n\\t\\tthis.lights = true;\\r\\n\\r\\n\\t\\tthis.blending = NormalBlending;\\r\\n\\t\\tthis.side = FrontSide;\\r\\n\\t\\tthis.flatShading = false;\\r\\n\\t\\tthis.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors\\r\\n\\r\\n\\t\\tthis.opacity = 1;\\r\\n\\t\\tthis.transparent = false;\\r\\n\\r\\n\\t\\tthis.blendSrc = SrcAlphaFactor;\\r\\n\\t\\tthis.blendDst = OneMinusSrcAlphaFactor;\\r\\n\\t\\tthis.blendEquation = AddEquation;\\r\\n\\t\\tthis.blendSrcAlpha = null;\\r\\n\\t\\tthis.blendDstAlpha = null;\\r\\n\\t\\tthis.blendEquationAlpha = null;\\r\\n\\r\\n\\t\\tthis.depthFunc = LessEqualDepth;\\r\\n\\t\\tthis.depthTest = true;\\r\\n\\t\\tthis.depthWrite = true;\\r\\n\\r\\n\\t\\tthis.clippingPlanes = null;\\r\\n\\t\\tthis.clipIntersection = false;\\r\\n\\t\\tthis.clipShadows = false;\\r\\n\\r\\n\\t\\tthis.colorWrite = true;\\r\\n\\r\\n\\t\\tthis.precision = null; // override the renderer's default precision for this material\\r\\n\\r\\n\\t\\tthis.polygonOffset = false;\\r\\n\\t\\tthis.polygonOffsetFactor = 0;\\r\\n\\t\\tthis.polygonOffsetUnits = 0;\\r\\n\\r\\n\\t\\tthis.dithering = false;\\r\\n\\r\\n\\t\\tthis.alphaTest = 0;\\r\\n\\t\\tthis.premultipliedAlpha = false;\\r\\n\\r\\n\\t\\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\\r\\n\\r\\n\\t\\tthis.visible = true;\\r\\n\\r\\n\\t\\tthis.userData = {};\\r\\n\\r\\n\\t\\tthis.needsUpdate = true;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tMaterial.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: Material,\\r\\n\\r\\n\\t\\tisMaterial: true,\\r\\n\\r\\n\\t\\tonBeforeCompile: function () {},\\r\\n\\r\\n\\t\\tsetValues: function ( values ) {\\r\\n\\r\\n\\t\\t\\tif ( values === undefined ) return;\\r\\n\\r\\n\\t\\t\\tfor ( var key in values ) {\\r\\n\\r\\n\\t\\t\\t\\tvar newValue = values[ key ];\\r\\n\\r\\n\\t\\t\\t\\tif ( newValue === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( \\\"THREE.Material: '\\\" + key + \\\"' parameter is undefined.\\\" );\\r\\n\\t\\t\\t\\t\\tcontinue;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// for backward compatability if shading is set in the constructor\\r\\n\\t\\t\\t\\tif ( key === 'shading' ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\\r\\n\\t\\t\\t\\t\\tthis.flatShading = ( newValue === FlatShading ) ? true : false;\\r\\n\\t\\t\\t\\t\\tcontinue;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tvar currentValue = this[ key ];\\r\\n\\r\\n\\t\\t\\t\\tif ( currentValue === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( \\\"THREE.\\\" + this.type + \\\": '\\\" + key + \\\"' is not a property of this material.\\\" );\\r\\n\\t\\t\\t\\t\\tcontinue;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( currentValue && currentValue.isColor ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcurrentValue.set( newValue );\\r\\n\\r\\n\\t\\t\\t\\t} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcurrentValue.copy( newValue );\\r\\n\\r\\n\\t\\t\\t\\t} else if ( key === 'overdraw' ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// ensure overdraw is backwards-compatible with legacy boolean type\\r\\n\\t\\t\\t\\t\\tthis[ key ] = Number( newValue );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis[ key ] = newValue;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttoJSON: function ( meta ) {\\r\\n\\r\\n\\t\\t\\tvar isRoot = ( meta === undefined || typeof meta === 'string' );\\r\\n\\r\\n\\t\\t\\tif ( isRoot ) {\\r\\n\\r\\n\\t\\t\\t\\tmeta = {\\r\\n\\t\\t\\t\\t\\ttextures: {},\\r\\n\\t\\t\\t\\t\\timages: {}\\r\\n\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar data = {\\r\\n\\t\\t\\t\\tmetadata: {\\r\\n\\t\\t\\t\\t\\tversion: 4.5,\\r\\n\\t\\t\\t\\t\\ttype: 'Material',\\r\\n\\t\\t\\t\\t\\tgenerator: 'Material.toJSON'\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t// standard Material serialization\\r\\n\\t\\t\\tdata.uuid = this.uuid;\\r\\n\\t\\t\\tdata.type = this.type;\\r\\n\\r\\n\\t\\t\\tif ( this.name !== '' ) data.name = this.name;\\r\\n\\r\\n\\t\\t\\tif ( this.color && this.color.isColor ) data.color = this.color.getHex();\\r\\n\\r\\n\\t\\t\\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\\r\\n\\t\\t\\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\\r\\n\\r\\n\\t\\t\\tif ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();\\r\\n\\t\\t\\tif ( this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;\\r\\n\\r\\n\\t\\t\\tif ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();\\r\\n\\t\\t\\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\\r\\n\\t\\t\\tif ( this.clearCoat !== undefined ) data.clearCoat = this.clearCoat;\\r\\n\\t\\t\\tif ( this.clearCoatRoughness !== undefined ) data.clearCoatRoughness = this.clearCoatRoughness;\\r\\n\\r\\n\\t\\t\\tif ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;\\r\\n\\t\\t\\tif ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\\r\\n\\t\\t\\tif ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\\r\\n\\t\\t\\tif ( this.bumpMap && this.bumpMap.isTexture ) {\\r\\n\\r\\n\\t\\t\\t\\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\\r\\n\\t\\t\\t\\tdata.bumpScale = this.bumpScale;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif ( this.normalMap && this.normalMap.isTexture ) {\\r\\n\\r\\n\\t\\t\\t\\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\\r\\n\\t\\t\\t\\tdata.normalScale = this.normalScale.toArray();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif ( this.displacementMap && this.displacementMap.isTexture ) {\\r\\n\\r\\n\\t\\t\\t\\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\\r\\n\\t\\t\\t\\tdata.displacementScale = this.displacementScale;\\r\\n\\t\\t\\t\\tdata.displacementBias = this.displacementBias;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\\r\\n\\t\\t\\tif ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\\r\\n\\r\\n\\t\\t\\tif ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\\r\\n\\t\\t\\tif ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\\r\\n\\r\\n\\t\\t\\tif ( this.envMap && this.envMap.isTexture ) {\\r\\n\\r\\n\\t\\t\\t\\tdata.envMap = this.envMap.toJSON( meta ).uuid;\\r\\n\\t\\t\\t\\tdata.reflectivity = this.reflectivity; // Scale behind envMap\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( this.gradientMap && this.gradientMap.isTexture ) {\\r\\n\\r\\n\\t\\t\\t\\tdata.gradientMap = this.gradientMap.toJSON( meta ).uuid;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( this.size !== undefined ) data.size = this.size;\\r\\n\\t\\t\\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\\r\\n\\r\\n\\t\\t\\tif ( this.blending !== NormalBlending ) data.blending = this.blending;\\r\\n\\t\\t\\tif ( this.flatShading === true ) data.flatShading = this.flatShading;\\r\\n\\t\\t\\tif ( this.side !== FrontSide ) data.side = this.side;\\r\\n\\t\\t\\tif ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;\\r\\n\\r\\n\\t\\t\\tif ( this.opacity < 1 ) data.opacity = this.opacity;\\r\\n\\t\\t\\tif ( this.transparent === true ) data.transparent = this.transparent;\\r\\n\\r\\n\\t\\t\\tdata.depthFunc = this.depthFunc;\\r\\n\\t\\t\\tdata.depthTest = this.depthTest;\\r\\n\\t\\t\\tdata.depthWrite = this.depthWrite;\\r\\n\\r\\n\\t\\t\\t// rotation (SpriteMaterial)\\r\\n\\t\\t\\tif ( this.rotation !== 0 ) data.rotation = this.rotation;\\r\\n\\r\\n\\t\\t\\tif ( this.linewidth !== 1 ) data.linewidth = this.linewidth;\\r\\n\\t\\t\\tif ( this.dashSize !== undefined ) data.dashSize = this.dashSize;\\r\\n\\t\\t\\tif ( this.gapSize !== undefined ) data.gapSize = this.gapSize;\\r\\n\\t\\t\\tif ( this.scale !== undefined ) data.scale = this.scale;\\r\\n\\r\\n\\t\\t\\tif ( this.dithering === true ) data.dithering = true;\\r\\n\\r\\n\\t\\t\\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\\r\\n\\t\\t\\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\\r\\n\\r\\n\\t\\t\\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\\r\\n\\t\\t\\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\\r\\n\\t\\t\\tif ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;\\r\\n\\t\\t\\tif ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;\\r\\n\\r\\n\\t\\t\\tif ( this.morphTargets === true ) data.morphTargets = true;\\r\\n\\t\\t\\tif ( this.skinning === true ) data.skinning = true;\\r\\n\\r\\n\\t\\t\\tif ( this.visible === false ) data.visible = false;\\r\\n\\t\\t\\tif ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;\\r\\n\\r\\n\\t\\t\\t// TODO: Copied from Object3D.toJSON\\r\\n\\r\\n\\t\\t\\tfunction extractFromCache( cache ) {\\r\\n\\r\\n\\t\\t\\t\\tvar values = [];\\r\\n\\r\\n\\t\\t\\t\\tfor ( var key in cache ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar data = cache[ key ];\\r\\n\\t\\t\\t\\t\\tdelete data.metadata;\\r\\n\\t\\t\\t\\t\\tvalues.push( data );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn values;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( isRoot ) {\\r\\n\\r\\n\\t\\t\\t\\tvar textures = extractFromCache( meta.textures );\\r\\n\\t\\t\\t\\tvar images = extractFromCache( meta.images );\\r\\n\\r\\n\\t\\t\\t\\tif ( textures.length > 0 ) data.textures = textures;\\r\\n\\t\\t\\t\\tif ( images.length > 0 ) data.images = images;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn data;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\t\\tthis.name = source.name;\\r\\n\\r\\n\\t\\t\\tthis.fog = source.fog;\\r\\n\\t\\t\\tthis.lights = source.lights;\\r\\n\\r\\n\\t\\t\\tthis.blending = source.blending;\\r\\n\\t\\t\\tthis.side = source.side;\\r\\n\\t\\t\\tthis.flatShading = source.flatShading;\\r\\n\\t\\t\\tthis.vertexColors = source.vertexColors;\\r\\n\\r\\n\\t\\t\\tthis.opacity = source.opacity;\\r\\n\\t\\t\\tthis.transparent = source.transparent;\\r\\n\\r\\n\\t\\t\\tthis.blendSrc = source.blendSrc;\\r\\n\\t\\t\\tthis.blendDst = source.blendDst;\\r\\n\\t\\t\\tthis.blendEquation = source.blendEquation;\\r\\n\\t\\t\\tthis.blendSrcAlpha = source.blendSrcAlpha;\\r\\n\\t\\t\\tthis.blendDstAlpha = source.blendDstAlpha;\\r\\n\\t\\t\\tthis.blendEquationAlpha = source.blendEquationAlpha;\\r\\n\\r\\n\\t\\t\\tthis.depthFunc = source.depthFunc;\\r\\n\\t\\t\\tthis.depthTest = source.depthTest;\\r\\n\\t\\t\\tthis.depthWrite = source.depthWrite;\\r\\n\\r\\n\\t\\t\\tthis.colorWrite = source.colorWrite;\\r\\n\\r\\n\\t\\t\\tthis.precision = source.precision;\\r\\n\\r\\n\\t\\t\\tthis.polygonOffset = source.polygonOffset;\\r\\n\\t\\t\\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\\r\\n\\t\\t\\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\\r\\n\\r\\n\\t\\t\\tthis.dithering = source.dithering;\\r\\n\\r\\n\\t\\t\\tthis.alphaTest = source.alphaTest;\\r\\n\\t\\t\\tthis.premultipliedAlpha = source.premultipliedAlpha;\\r\\n\\r\\n\\t\\t\\tthis.overdraw = source.overdraw;\\r\\n\\r\\n\\t\\t\\tthis.visible = source.visible;\\r\\n\\t\\t\\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\\r\\n\\r\\n\\t\\t\\tthis.clipShadows = source.clipShadows;\\r\\n\\t\\t\\tthis.clipIntersection = source.clipIntersection;\\r\\n\\r\\n\\t\\t\\tvar srcPlanes = source.clippingPlanes,\\r\\n\\t\\t\\t\\tdstPlanes = null;\\r\\n\\r\\n\\t\\t\\tif ( srcPlanes !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tvar n = srcPlanes.length;\\r\\n\\t\\t\\t\\tdstPlanes = new Array( n );\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0; i !== n; ++ i )\\r\\n\\t\\t\\t\\t\\tdstPlanes[ i ] = srcPlanes[ i ].clone();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.clippingPlanes = dstPlanes;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdispose: function () {\\r\\n\\r\\n\\t\\t\\tthis.dispatchEvent( { type: 'dispose' } );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t * @author bhouston / https://clara.io\\r\\n\\t * @author WestLangley / http://github.com/WestLangley\\r\\n\\t *\\r\\n\\t * parameters = {\\r\\n\\t *\\r\\n\\t *  opacity: <float>,\\r\\n\\t *\\r\\n\\t *  map: new THREE.Texture( <Image> ),\\r\\n\\t *\\r\\n\\t *  alphaMap: new THREE.Texture( <Image> ),\\r\\n\\t *\\r\\n\\t *  displacementMap: new THREE.Texture( <Image> ),\\r\\n\\t *  displacementScale: <float>,\\r\\n\\t *  displacementBias: <float>,\\r\\n\\t *\\r\\n\\t *  wireframe: <boolean>,\\r\\n\\t *  wireframeLinewidth: <float>\\r\\n\\t * }\\r\\n\\t */\\r\\n\\r\\n\\tfunction MeshDepthMaterial( parameters ) {\\r\\n\\r\\n\\t\\tMaterial.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'MeshDepthMaterial';\\r\\n\\r\\n\\t\\tthis.depthPacking = BasicDepthPacking;\\r\\n\\r\\n\\t\\tthis.skinning = false;\\r\\n\\t\\tthis.morphTargets = false;\\r\\n\\r\\n\\t\\tthis.map = null;\\r\\n\\r\\n\\t\\tthis.alphaMap = null;\\r\\n\\r\\n\\t\\tthis.displacementMap = null;\\r\\n\\t\\tthis.displacementScale = 1;\\r\\n\\t\\tthis.displacementBias = 0;\\r\\n\\r\\n\\t\\tthis.wireframe = false;\\r\\n\\t\\tthis.wireframeLinewidth = 1;\\r\\n\\r\\n\\t\\tthis.fog = false;\\r\\n\\t\\tthis.lights = false;\\r\\n\\r\\n\\t\\tthis.setValues( parameters );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tMeshDepthMaterial.prototype = Object.create( Material.prototype );\\r\\n\\tMeshDepthMaterial.prototype.constructor = MeshDepthMaterial;\\r\\n\\r\\n\\tMeshDepthMaterial.prototype.isMeshDepthMaterial = true;\\r\\n\\r\\n\\tMeshDepthMaterial.prototype.copy = function ( source ) {\\r\\n\\r\\n\\t\\tMaterial.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.depthPacking = source.depthPacking;\\r\\n\\r\\n\\t\\tthis.skinning = source.skinning;\\r\\n\\t\\tthis.morphTargets = source.morphTargets;\\r\\n\\r\\n\\t\\tthis.map = source.map;\\r\\n\\r\\n\\t\\tthis.alphaMap = source.alphaMap;\\r\\n\\r\\n\\t\\tthis.displacementMap = source.displacementMap;\\r\\n\\t\\tthis.displacementScale = source.displacementScale;\\r\\n\\t\\tthis.displacementBias = source.displacementBias;\\r\\n\\r\\n\\t\\tthis.wireframe = source.wireframe;\\r\\n\\t\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author WestLangley / http://github.com/WestLangley\\r\\n\\t *\\r\\n\\t * parameters = {\\r\\n\\t *\\r\\n\\t *  referencePosition: <float>,\\r\\n\\t *  nearDistance: <float>,\\r\\n\\t *  farDistance: <float>,\\r\\n\\t *\\r\\n\\t *  skinning: <bool>,\\r\\n\\t *  morphTargets: <bool>,\\r\\n\\t *\\r\\n\\t *  map: new THREE.Texture( <Image> ),\\r\\n\\t *\\r\\n\\t *  alphaMap: new THREE.Texture( <Image> ),\\r\\n\\t *\\r\\n\\t *  displacementMap: new THREE.Texture( <Image> ),\\r\\n\\t *  displacementScale: <float>,\\r\\n\\t *  displacementBias: <float>\\r\\n\\t *\\r\\n\\t * }\\r\\n\\t */\\r\\n\\r\\n\\tfunction MeshDistanceMaterial( parameters ) {\\r\\n\\r\\n\\t\\tMaterial.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'MeshDistanceMaterial';\\r\\n\\r\\n\\t\\tthis.referencePosition = new Vector3();\\r\\n\\t\\tthis.nearDistance = 1;\\r\\n\\t\\tthis.farDistance = 1000;\\r\\n\\r\\n\\t\\tthis.skinning = false;\\r\\n\\t\\tthis.morphTargets = false;\\r\\n\\r\\n\\t\\tthis.map = null;\\r\\n\\r\\n\\t\\tthis.alphaMap = null;\\r\\n\\r\\n\\t\\tthis.displacementMap = null;\\r\\n\\t\\tthis.displacementScale = 1;\\r\\n\\t\\tthis.displacementBias = 0;\\r\\n\\r\\n\\t\\tthis.fog = false;\\r\\n\\t\\tthis.lights = false;\\r\\n\\r\\n\\t\\tthis.setValues( parameters );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tMeshDistanceMaterial.prototype = Object.create( Material.prototype );\\r\\n\\tMeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;\\r\\n\\r\\n\\tMeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;\\r\\n\\r\\n\\tMeshDistanceMaterial.prototype.copy = function ( source ) {\\r\\n\\r\\n\\t\\tMaterial.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.referencePosition.copy( source.referencePosition );\\r\\n\\t\\tthis.nearDistance = source.nearDistance;\\r\\n\\t\\tthis.farDistance = source.farDistance;\\r\\n\\r\\n\\t\\tthis.skinning = source.skinning;\\r\\n\\t\\tthis.morphTargets = source.morphTargets;\\r\\n\\r\\n\\t\\tthis.map = source.map;\\r\\n\\r\\n\\t\\tthis.alphaMap = source.alphaMap;\\r\\n\\r\\n\\t\\tthis.displacementMap = source.displacementMap;\\r\\n\\t\\tthis.displacementScale = source.displacementScale;\\r\\n\\t\\tthis.displacementBias = source.displacementBias;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author bhouston / http://clara.io\\r\\n\\t * @author WestLangley / http://github.com/WestLangley\\r\\n\\t */\\r\\n\\r\\n\\tfunction Box3( min, max ) {\\r\\n\\r\\n\\t\\tthis.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );\\r\\n\\t\\tthis.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( Box3.prototype, {\\r\\n\\r\\n\\t\\tisBox3: true,\\r\\n\\r\\n\\t\\tset: function ( min, max ) {\\r\\n\\r\\n\\t\\t\\tthis.min.copy( min );\\r\\n\\t\\t\\tthis.max.copy( max );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFromArray: function ( array ) {\\r\\n\\r\\n\\t\\t\\tvar minX = + Infinity;\\r\\n\\t\\t\\tvar minY = + Infinity;\\r\\n\\t\\t\\tvar minZ = + Infinity;\\r\\n\\r\\n\\t\\t\\tvar maxX = - Infinity;\\r\\n\\t\\t\\tvar maxY = - Infinity;\\r\\n\\t\\t\\tvar maxZ = - Infinity;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\\r\\n\\r\\n\\t\\t\\t\\tvar x = array[ i ];\\r\\n\\t\\t\\t\\tvar y = array[ i + 1 ];\\r\\n\\t\\t\\t\\tvar z = array[ i + 2 ];\\r\\n\\r\\n\\t\\t\\t\\tif ( x < minX ) minX = x;\\r\\n\\t\\t\\t\\tif ( y < minY ) minY = y;\\r\\n\\t\\t\\t\\tif ( z < minZ ) minZ = z;\\r\\n\\r\\n\\t\\t\\t\\tif ( x > maxX ) maxX = x;\\r\\n\\t\\t\\t\\tif ( y > maxY ) maxY = y;\\r\\n\\t\\t\\t\\tif ( z > maxZ ) maxZ = z;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.min.set( minX, minY, minZ );\\r\\n\\t\\t\\tthis.max.set( maxX, maxY, maxZ );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFromBufferAttribute: function ( attribute ) {\\r\\n\\r\\n\\t\\t\\tvar minX = + Infinity;\\r\\n\\t\\t\\tvar minY = + Infinity;\\r\\n\\t\\t\\tvar minZ = + Infinity;\\r\\n\\r\\n\\t\\t\\tvar maxX = - Infinity;\\r\\n\\t\\t\\tvar maxY = - Infinity;\\r\\n\\t\\t\\tvar maxZ = - Infinity;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar x = attribute.getX( i );\\r\\n\\t\\t\\t\\tvar y = attribute.getY( i );\\r\\n\\t\\t\\t\\tvar z = attribute.getZ( i );\\r\\n\\r\\n\\t\\t\\t\\tif ( x < minX ) minX = x;\\r\\n\\t\\t\\t\\tif ( y < minY ) minY = y;\\r\\n\\t\\t\\t\\tif ( z < minZ ) minZ = z;\\r\\n\\r\\n\\t\\t\\t\\tif ( x > maxX ) maxX = x;\\r\\n\\t\\t\\t\\tif ( y > maxY ) maxY = y;\\r\\n\\t\\t\\t\\tif ( z > maxZ ) maxZ = z;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.min.set( minX, minY, minZ );\\r\\n\\t\\t\\tthis.max.set( maxX, maxY, maxZ );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFromPoints: function ( points ) {\\r\\n\\r\\n\\t\\t\\tthis.makeEmpty();\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.expandByPoint( points[ i ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFromCenterAndSize: function () {\\r\\n\\r\\n\\t\\t\\tvar v1 = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function setFromCenterAndSize( center, size ) {\\r\\n\\r\\n\\t\\t\\t\\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\\r\\n\\r\\n\\t\\t\\t\\tthis.min.copy( center ).sub( halfSize );\\r\\n\\t\\t\\t\\tthis.max.copy( center ).add( halfSize );\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tsetFromObject: function ( object ) {\\r\\n\\r\\n\\t\\t\\tthis.makeEmpty();\\r\\n\\r\\n\\t\\t\\treturn this.expandByObject( object );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( box ) {\\r\\n\\r\\n\\t\\t\\tthis.min.copy( box.min );\\r\\n\\t\\t\\tthis.max.copy( box.max );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmakeEmpty: function () {\\r\\n\\r\\n\\t\\t\\tthis.min.x = this.min.y = this.min.z = + Infinity;\\r\\n\\t\\t\\tthis.max.x = this.max.y = this.max.z = - Infinity;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tisEmpty: function () {\\r\\n\\r\\n\\t\\t\\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\\r\\n\\r\\n\\t\\t\\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetCenter: function ( optionalTarget ) {\\r\\n\\r\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\r\\n\\t\\t\\treturn this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetSize: function ( optionalTarget ) {\\r\\n\\r\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\r\\n\\t\\t\\treturn this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\texpandByPoint: function ( point ) {\\r\\n\\r\\n\\t\\t\\tthis.min.min( point );\\r\\n\\t\\t\\tthis.max.max( point );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\texpandByVector: function ( vector ) {\\r\\n\\r\\n\\t\\t\\tthis.min.sub( vector );\\r\\n\\t\\t\\tthis.max.add( vector );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\texpandByScalar: function ( scalar ) {\\r\\n\\r\\n\\t\\t\\tthis.min.addScalar( - scalar );\\r\\n\\t\\t\\tthis.max.addScalar( scalar );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\texpandByObject: function () {\\r\\n\\r\\n\\t\\t\\t// Computes the world-axis-aligned bounding box of an object (including its children),\\r\\n\\t\\t\\t// accounting for both the object's, and children's, world transforms\\r\\n\\r\\n\\t\\t\\tvar scope, i, l;\\r\\n\\r\\n\\t\\t\\tvar v1 = new Vector3();\\r\\n\\r\\n\\t\\t\\tfunction traverse( node ) {\\r\\n\\r\\n\\t\\t\\t\\tvar geometry = node.geometry;\\r\\n\\r\\n\\t\\t\\t\\tif ( geometry !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( geometry.isGeometry ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar vertices = geometry.vertices;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tv1.copy( vertices[ i ] );\\r\\n\\t\\t\\t\\t\\t\\t\\tv1.applyMatrix4( node.matrixWorld );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tscope.expandByPoint( v1 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t} else if ( geometry.isBufferGeometry ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar attribute = geometry.attributes.position;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( attribute !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tfor ( i = 0, l = attribute.count; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tv1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tscope.expandByPoint( v1 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn function expandByObject( object ) {\\r\\n\\r\\n\\t\\t\\t\\tscope = this;\\r\\n\\r\\n\\t\\t\\t\\tobject.updateMatrixWorld( true );\\r\\n\\r\\n\\t\\t\\t\\tobject.traverse( traverse );\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tcontainsPoint: function ( point ) {\\r\\n\\r\\n\\t\\t\\treturn point.x < this.min.x || point.x > this.max.x ||\\r\\n\\t\\t\\t\\tpoint.y < this.min.y || point.y > this.max.y ||\\r\\n\\t\\t\\t\\tpoint.z < this.min.z || point.z > this.max.z ? false : true;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcontainsBox: function ( box ) {\\r\\n\\r\\n\\t\\t\\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\\r\\n\\t\\t\\t\\tthis.min.y <= box.min.y && box.max.y <= this.max.y &&\\r\\n\\t\\t\\t\\tthis.min.z <= box.min.z && box.max.z <= this.max.z;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetParameter: function ( point, optionalTarget ) {\\r\\n\\r\\n\\t\\t\\t// This can potentially have a divide by zero if the box\\r\\n\\t\\t\\t// has a size dimension of 0.\\r\\n\\r\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\r\\n\\r\\n\\t\\t\\treturn result.set(\\r\\n\\t\\t\\t\\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\\r\\n\\t\\t\\t\\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\\r\\n\\t\\t\\t\\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tintersectsBox: function ( box ) {\\r\\n\\r\\n\\t\\t\\t// using 6 splitting planes to rule out intersections.\\r\\n\\t\\t\\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\\r\\n\\t\\t\\t\\tbox.max.y < this.min.y || box.min.y > this.max.y ||\\r\\n\\t\\t\\t\\tbox.max.z < this.min.z || box.min.z > this.max.z ? false : true;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tintersectsSphere: ( function () {\\r\\n\\r\\n\\t\\t\\tvar closestPoint = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function intersectsSphere( sphere ) {\\r\\n\\r\\n\\t\\t\\t\\t// Find the point on the AABB closest to the sphere center.\\r\\n\\t\\t\\t\\tthis.clampPoint( sphere.center, closestPoint );\\r\\n\\r\\n\\t\\t\\t\\t// If that point is inside the sphere, the AABB and sphere intersect.\\r\\n\\t\\t\\t\\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t} )(),\\r\\n\\r\\n\\t\\tintersectsPlane: function ( plane ) {\\r\\n\\r\\n\\t\\t\\t// We compute the minimum and maximum dot product values. If those values\\r\\n\\t\\t\\t// are on the same side (back or front) of the plane, then there is no intersection.\\r\\n\\r\\n\\t\\t\\tvar min, max;\\r\\n\\r\\n\\t\\t\\tif ( plane.normal.x > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tmin = plane.normal.x * this.min.x;\\r\\n\\t\\t\\t\\tmax = plane.normal.x * this.max.x;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tmin = plane.normal.x * this.max.x;\\r\\n\\t\\t\\t\\tmax = plane.normal.x * this.min.x;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( plane.normal.y > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tmin += plane.normal.y * this.min.y;\\r\\n\\t\\t\\t\\tmax += plane.normal.y * this.max.y;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tmin += plane.normal.y * this.max.y;\\r\\n\\t\\t\\t\\tmax += plane.normal.y * this.min.y;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( plane.normal.z > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tmin += plane.normal.z * this.min.z;\\r\\n\\t\\t\\t\\tmax += plane.normal.z * this.max.z;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tmin += plane.normal.z * this.max.z;\\r\\n\\t\\t\\t\\tmax += plane.normal.z * this.min.z;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn ( min <= plane.constant && max >= plane.constant );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclampPoint: function ( point, optionalTarget ) {\\r\\n\\r\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\r\\n\\t\\t\\treturn result.copy( point ).clamp( this.min, this.max );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdistanceToPoint: function () {\\r\\n\\r\\n\\t\\t\\tvar v1 = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function distanceToPoint( point ) {\\r\\n\\r\\n\\t\\t\\t\\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\\r\\n\\t\\t\\t\\treturn clampedPoint.sub( point ).length();\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tgetBoundingSphere: function () {\\r\\n\\r\\n\\t\\t\\tvar v1 = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function getBoundingSphere( optionalTarget ) {\\r\\n\\r\\n\\t\\t\\t\\tvar result = optionalTarget || new Sphere();\\r\\n\\r\\n\\t\\t\\t\\tthis.getCenter( result.center );\\r\\n\\r\\n\\t\\t\\t\\tresult.radius = this.getSize( v1 ).length() * 0.5;\\r\\n\\r\\n\\t\\t\\t\\treturn result;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tintersect: function ( box ) {\\r\\n\\r\\n\\t\\t\\tthis.min.max( box.min );\\r\\n\\t\\t\\tthis.max.min( box.max );\\r\\n\\r\\n\\t\\t\\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\\r\\n\\t\\t\\tif ( this.isEmpty() ) this.makeEmpty();\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tunion: function ( box ) {\\r\\n\\r\\n\\t\\t\\tthis.min.min( box.min );\\r\\n\\t\\t\\tthis.max.max( box.max );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tapplyMatrix4: function () {\\r\\n\\r\\n\\t\\t\\tvar points = [\\r\\n\\t\\t\\t\\tnew Vector3(),\\r\\n\\t\\t\\t\\tnew Vector3(),\\r\\n\\t\\t\\t\\tnew Vector3(),\\r\\n\\t\\t\\t\\tnew Vector3(),\\r\\n\\t\\t\\t\\tnew Vector3(),\\r\\n\\t\\t\\t\\tnew Vector3(),\\r\\n\\t\\t\\t\\tnew Vector3(),\\r\\n\\t\\t\\t\\tnew Vector3()\\r\\n\\t\\t\\t];\\r\\n\\r\\n\\t\\t\\treturn function applyMatrix4( matrix ) {\\r\\n\\r\\n\\t\\t\\t\\t// transform of empty box is an empty box.\\r\\n\\t\\t\\t\\tif ( this.isEmpty() ) return this;\\r\\n\\r\\n\\t\\t\\t\\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\\r\\n\\t\\t\\t\\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\\r\\n\\t\\t\\t\\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\\r\\n\\t\\t\\t\\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\\r\\n\\t\\t\\t\\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\\r\\n\\t\\t\\t\\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\\r\\n\\t\\t\\t\\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\\r\\n\\t\\t\\t\\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\\r\\n\\t\\t\\t\\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );\\t// 111\\r\\n\\r\\n\\t\\t\\t\\tthis.setFromPoints( points );\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\ttranslate: function ( offset ) {\\r\\n\\r\\n\\t\\t\\tthis.min.add( offset );\\r\\n\\t\\t\\tthis.max.add( offset );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tequals: function ( box ) {\\r\\n\\r\\n\\t\\t\\treturn box.min.equals( this.min ) && box.max.equals( this.max );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author bhouston / http://clara.io\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction Sphere( center, radius ) {\\r\\n\\r\\n\\t\\tthis.center = ( center !== undefined ) ? center : new Vector3();\\r\\n\\t\\tthis.radius = ( radius !== undefined ) ? radius : 0;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( Sphere.prototype, {\\r\\n\\r\\n\\t\\tset: function ( center, radius ) {\\r\\n\\r\\n\\t\\t\\tthis.center.copy( center );\\r\\n\\t\\t\\tthis.radius = radius;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFromPoints: function () {\\r\\n\\r\\n\\t\\t\\tvar box = new Box3();\\r\\n\\r\\n\\t\\t\\treturn function setFromPoints( points, optionalCenter ) {\\r\\n\\r\\n\\t\\t\\t\\tvar center = this.center;\\r\\n\\r\\n\\t\\t\\t\\tif ( optionalCenter !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcenter.copy( optionalCenter );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tbox.setFromPoints( points ).getCenter( center );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tvar maxRadiusSq = 0;\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tthis.radius = Math.sqrt( maxRadiusSq );\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( sphere ) {\\r\\n\\r\\n\\t\\t\\tthis.center.copy( sphere.center );\\r\\n\\t\\t\\tthis.radius = sphere.radius;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tempty: function () {\\r\\n\\r\\n\\t\\t\\treturn ( this.radius <= 0 );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcontainsPoint: function ( point ) {\\r\\n\\r\\n\\t\\t\\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdistanceToPoint: function ( point ) {\\r\\n\\r\\n\\t\\t\\treturn ( point.distanceTo( this.center ) - this.radius );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tintersectsSphere: function ( sphere ) {\\r\\n\\r\\n\\t\\t\\tvar radiusSum = this.radius + sphere.radius;\\r\\n\\r\\n\\t\\t\\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tintersectsBox: function ( box ) {\\r\\n\\r\\n\\t\\t\\treturn box.intersectsSphere( this );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tintersectsPlane: function ( plane ) {\\r\\n\\r\\n\\t\\t\\treturn Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclampPoint: function ( point, optionalTarget ) {\\r\\n\\r\\n\\t\\t\\tvar deltaLengthSq = this.center.distanceToSquared( point );\\r\\n\\r\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\r\\n\\r\\n\\t\\t\\tresult.copy( point );\\r\\n\\r\\n\\t\\t\\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\\r\\n\\r\\n\\t\\t\\t\\tresult.sub( this.center ).normalize();\\r\\n\\t\\t\\t\\tresult.multiplyScalar( this.radius ).add( this.center );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn result;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetBoundingBox: function ( optionalTarget ) {\\r\\n\\r\\n\\t\\t\\tvar box = optionalTarget || new Box3();\\r\\n\\r\\n\\t\\t\\tbox.set( this.center, this.center );\\r\\n\\t\\t\\tbox.expandByScalar( this.radius );\\r\\n\\r\\n\\t\\t\\treturn box;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tapplyMatrix4: function ( matrix ) {\\r\\n\\r\\n\\t\\t\\tthis.center.applyMatrix4( matrix );\\r\\n\\t\\t\\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttranslate: function ( offset ) {\\r\\n\\r\\n\\t\\t\\tthis.center.add( offset );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tequals: function ( sphere ) {\\r\\n\\r\\n\\t\\t\\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author bhouston / http://clara.io\\r\\n\\t */\\r\\n\\r\\n\\tfunction Plane( normal, constant ) {\\r\\n\\r\\n\\t\\t// normal is assumed to be normalized\\r\\n\\r\\n\\t\\tthis.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );\\r\\n\\t\\tthis.constant = ( constant !== undefined ) ? constant : 0;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( Plane.prototype, {\\r\\n\\r\\n\\t\\tset: function ( normal, constant ) {\\r\\n\\r\\n\\t\\t\\tthis.normal.copy( normal );\\r\\n\\t\\t\\tthis.constant = constant;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetComponents: function ( x, y, z, w ) {\\r\\n\\r\\n\\t\\t\\tthis.normal.set( x, y, z );\\r\\n\\t\\t\\tthis.constant = w;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\\r\\n\\r\\n\\t\\t\\tthis.normal.copy( normal );\\r\\n\\t\\t\\tthis.constant = - point.dot( this.normal );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFromCoplanarPoints: function () {\\r\\n\\r\\n\\t\\t\\tvar v1 = new Vector3();\\r\\n\\t\\t\\tvar v2 = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function setFromCoplanarPoints( a, b, c ) {\\r\\n\\r\\n\\t\\t\\t\\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\\r\\n\\r\\n\\t\\t\\t\\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\\r\\n\\r\\n\\t\\t\\t\\tthis.setFromNormalAndCoplanarPoint( normal, a );\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( plane ) {\\r\\n\\r\\n\\t\\t\\tthis.normal.copy( plane.normal );\\r\\n\\t\\t\\tthis.constant = plane.constant;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tnormalize: function () {\\r\\n\\r\\n\\t\\t\\t// Note: will lead to a divide by zero if the plane is invalid.\\r\\n\\r\\n\\t\\t\\tvar inverseNormalLength = 1.0 / this.normal.length();\\r\\n\\t\\t\\tthis.normal.multiplyScalar( inverseNormalLength );\\r\\n\\t\\t\\tthis.constant *= inverseNormalLength;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tnegate: function () {\\r\\n\\r\\n\\t\\t\\tthis.constant *= - 1;\\r\\n\\t\\t\\tthis.normal.negate();\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdistanceToPoint: function ( point ) {\\r\\n\\r\\n\\t\\t\\treturn this.normal.dot( point ) + this.constant;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdistanceToSphere: function ( sphere ) {\\r\\n\\r\\n\\t\\t\\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tprojectPoint: function ( point, optionalTarget ) {\\r\\n\\r\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\r\\n\\r\\n\\t\\t\\treturn result.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tintersectLine: function () {\\r\\n\\r\\n\\t\\t\\tvar v1 = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function intersectLine( line, optionalTarget ) {\\r\\n\\r\\n\\t\\t\\t\\tvar result = optionalTarget || new Vector3();\\r\\n\\r\\n\\t\\t\\t\\tvar direction = line.delta( v1 );\\r\\n\\r\\n\\t\\t\\t\\tvar denominator = this.normal.dot( direction );\\r\\n\\r\\n\\t\\t\\t\\tif ( denominator === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// line is coplanar, return origin\\r\\n\\t\\t\\t\\t\\tif ( this.distanceToPoint( line.start ) === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\treturn result.copy( line.start );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t// Unsure if this is the correct method to handle this case.\\r\\n\\t\\t\\t\\t\\treturn undefined;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\\r\\n\\r\\n\\t\\t\\t\\tif ( t < 0 || t > 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn undefined;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tintersectsLine: function ( line ) {\\r\\n\\r\\n\\t\\t\\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\\r\\n\\r\\n\\t\\t\\tvar startSign = this.distanceToPoint( line.start );\\r\\n\\t\\t\\tvar endSign = this.distanceToPoint( line.end );\\r\\n\\r\\n\\t\\t\\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tintersectsBox: function ( box ) {\\r\\n\\r\\n\\t\\t\\treturn box.intersectsPlane( this );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tintersectsSphere: function ( sphere ) {\\r\\n\\r\\n\\t\\t\\treturn sphere.intersectsPlane( this );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcoplanarPoint: function ( optionalTarget ) {\\r\\n\\r\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\r\\n\\r\\n\\t\\t\\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tapplyMatrix4: function () {\\r\\n\\r\\n\\t\\t\\tvar v1 = new Vector3();\\r\\n\\t\\t\\tvar m1 = new Matrix3();\\r\\n\\r\\n\\t\\t\\treturn function applyMatrix4( matrix, optionalNormalMatrix ) {\\r\\n\\r\\n\\t\\t\\t\\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\\r\\n\\r\\n\\t\\t\\t\\tvar referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );\\r\\n\\r\\n\\t\\t\\t\\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\\r\\n\\r\\n\\t\\t\\t\\tthis.constant = - referencePoint.dot( normal );\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\ttranslate: function ( offset ) {\\r\\n\\r\\n\\t\\t\\tthis.constant -= offset.dot( this.normal );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tequals: function ( plane ) {\\r\\n\\r\\n\\t\\t\\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t * @author bhouston / http://clara.io\\r\\n\\t */\\r\\n\\r\\n\\tfunction Frustum( p0, p1, p2, p3, p4, p5 ) {\\r\\n\\r\\n\\t\\tthis.planes = [\\r\\n\\r\\n\\t\\t\\t( p0 !== undefined ) ? p0 : new Plane(),\\r\\n\\t\\t\\t( p1 !== undefined ) ? p1 : new Plane(),\\r\\n\\t\\t\\t( p2 !== undefined ) ? p2 : new Plane(),\\r\\n\\t\\t\\t( p3 !== undefined ) ? p3 : new Plane(),\\r\\n\\t\\t\\t( p4 !== undefined ) ? p4 : new Plane(),\\r\\n\\t\\t\\t( p5 !== undefined ) ? p5 : new Plane()\\r\\n\\r\\n\\t\\t];\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( Frustum.prototype, {\\r\\n\\r\\n\\t\\tset: function ( p0, p1, p2, p3, p4, p5 ) {\\r\\n\\r\\n\\t\\t\\tvar planes = this.planes;\\r\\n\\r\\n\\t\\t\\tplanes[ 0 ].copy( p0 );\\r\\n\\t\\t\\tplanes[ 1 ].copy( p1 );\\r\\n\\t\\t\\tplanes[ 2 ].copy( p2 );\\r\\n\\t\\t\\tplanes[ 3 ].copy( p3 );\\r\\n\\t\\t\\tplanes[ 4 ].copy( p4 );\\r\\n\\t\\t\\tplanes[ 5 ].copy( p5 );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( frustum ) {\\r\\n\\r\\n\\t\\t\\tvar planes = this.planes;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tplanes[ i ].copy( frustum.planes[ i ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFromMatrix: function ( m ) {\\r\\n\\r\\n\\t\\t\\tvar planes = this.planes;\\r\\n\\t\\t\\tvar me = m.elements;\\r\\n\\t\\t\\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\\r\\n\\t\\t\\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\\r\\n\\t\\t\\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\\r\\n\\t\\t\\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\\r\\n\\r\\n\\t\\t\\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\\r\\n\\t\\t\\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\\r\\n\\t\\t\\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\\r\\n\\t\\t\\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\\r\\n\\t\\t\\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\\r\\n\\t\\t\\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tintersectsObject: function () {\\r\\n\\r\\n\\t\\t\\tvar sphere = new Sphere();\\r\\n\\r\\n\\t\\t\\treturn function intersectsObject( object ) {\\r\\n\\r\\n\\t\\t\\t\\tvar geometry = object.geometry;\\r\\n\\r\\n\\t\\t\\t\\tif ( geometry.boundingSphere === null )\\r\\n\\t\\t\\t\\t\\tgeometry.computeBoundingSphere();\\r\\n\\r\\n\\t\\t\\t\\tsphere.copy( geometry.boundingSphere )\\r\\n\\t\\t\\t\\t\\t.applyMatrix4( object.matrixWorld );\\r\\n\\r\\n\\t\\t\\t\\treturn this.intersectsSphere( sphere );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tintersectsSprite: function () {\\r\\n\\r\\n\\t\\t\\tvar sphere = new Sphere();\\r\\n\\r\\n\\t\\t\\treturn function intersectsSprite( sprite ) {\\r\\n\\r\\n\\t\\t\\t\\tsphere.center.set( 0, 0, 0 );\\r\\n\\t\\t\\t\\tsphere.radius = 0.7071067811865476;\\r\\n\\t\\t\\t\\tsphere.applyMatrix4( sprite.matrixWorld );\\r\\n\\r\\n\\t\\t\\t\\treturn this.intersectsSphere( sphere );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tintersectsSphere: function ( sphere ) {\\r\\n\\r\\n\\t\\t\\tvar planes = this.planes;\\r\\n\\t\\t\\tvar center = sphere.center;\\r\\n\\t\\t\\tvar negRadius = - sphere.radius;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar distance = planes[ i ].distanceToPoint( center );\\r\\n\\r\\n\\t\\t\\t\\tif ( distance < negRadius ) {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn false;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn true;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tintersectsBox: function () {\\r\\n\\r\\n\\t\\t\\tvar p1 = new Vector3(),\\r\\n\\t\\t\\t\\tp2 = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function intersectsBox( box ) {\\r\\n\\r\\n\\t\\t\\t\\tvar planes = this.planes;\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar plane = planes[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\\r\\n\\t\\t\\t\\t\\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\\r\\n\\t\\t\\t\\t\\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\\r\\n\\t\\t\\t\\t\\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\\r\\n\\t\\t\\t\\t\\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\\r\\n\\t\\t\\t\\t\\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\\r\\n\\r\\n\\t\\t\\t\\t\\tvar d1 = plane.distanceToPoint( p1 );\\r\\n\\t\\t\\t\\t\\tvar d2 = plane.distanceToPoint( p2 );\\r\\n\\r\\n\\t\\t\\t\\t\\t// if both outside plane, no intersection\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( d1 < 0 && d2 < 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\treturn false;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn true;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tcontainsPoint: function ( point ) {\\r\\n\\r\\n\\t\\t\\tvar planes = this.planes;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn false;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn true;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction WebGLShadowMap( _renderer, _objects, maxTextureSize ) {\\r\\n\\r\\n\\t\\tvar _frustum = new Frustum(),\\r\\n\\t\\t\\t_projScreenMatrix = new Matrix4(),\\r\\n\\r\\n\\t\\t\\t_shadowMapSize = new Vector2(),\\r\\n\\t\\t\\t_maxShadowMapSize = new Vector2( maxTextureSize, maxTextureSize ),\\r\\n\\r\\n\\t\\t\\t_lookTarget = new Vector3(),\\r\\n\\t\\t\\t_lightPositionWorld = new Vector3(),\\r\\n\\r\\n\\t\\t\\t_MorphingFlag = 1,\\r\\n\\t\\t\\t_SkinningFlag = 2,\\r\\n\\r\\n\\t\\t\\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\\r\\n\\r\\n\\t\\t\\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\\r\\n\\t\\t\\t_distanceMaterials = new Array( _NumberOfMaterialVariants ),\\r\\n\\r\\n\\t\\t\\t_materialCache = {};\\r\\n\\r\\n\\t\\tvar cubeDirections = [\\r\\n\\t\\t\\tnew Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),\\r\\n\\t\\t\\tnew Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )\\r\\n\\t\\t];\\r\\n\\r\\n\\t\\tvar cubeUps = [\\r\\n\\t\\t\\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),\\r\\n\\t\\t\\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),\\tnew Vector3( 0, 0, - 1 )\\r\\n\\t\\t];\\r\\n\\r\\n\\t\\tvar cube2DViewPorts = [\\r\\n\\t\\t\\tnew Vector4(), new Vector4(), new Vector4(),\\r\\n\\t\\t\\tnew Vector4(), new Vector4(), new Vector4()\\r\\n\\t\\t];\\r\\n\\r\\n\\t\\t// init\\r\\n\\r\\n\\t\\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\\r\\n\\r\\n\\t\\t\\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\\r\\n\\t\\t\\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\\r\\n\\r\\n\\t\\t\\tvar depthMaterial = new MeshDepthMaterial( {\\r\\n\\r\\n\\t\\t\\t\\tdepthPacking: RGBADepthPacking,\\r\\n\\r\\n\\t\\t\\t\\tmorphTargets: useMorphing,\\r\\n\\t\\t\\t\\tskinning: useSkinning\\r\\n\\r\\n\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\t_depthMaterials[ i ] = depthMaterial;\\r\\n\\r\\n\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\tvar distanceMaterial = new MeshDistanceMaterial( {\\r\\n\\r\\n\\t\\t\\t\\tmorphTargets: useMorphing,\\r\\n\\t\\t\\t\\tskinning: useSkinning\\r\\n\\r\\n\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\t_distanceMaterials[ i ] = distanceMaterial;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\tthis.enabled = false;\\r\\n\\r\\n\\t\\tthis.autoUpdate = true;\\r\\n\\t\\tthis.needsUpdate = false;\\r\\n\\r\\n\\t\\tthis.type = PCFShadowMap;\\r\\n\\r\\n\\t\\tthis.renderReverseSided = true;\\r\\n\\t\\tthis.renderSingleSided = true;\\r\\n\\r\\n\\t\\tthis.render = function ( lights, scene, camera ) {\\r\\n\\r\\n\\t\\t\\tif ( scope.enabled === false ) return;\\r\\n\\t\\t\\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\\r\\n\\r\\n\\t\\t\\tif ( lights.length === 0 ) return;\\r\\n\\r\\n\\t\\t\\t// TODO Clean up (needed in case of contextlost)\\r\\n\\t\\t\\tvar _gl = _renderer.context;\\r\\n\\t\\t\\tvar _state = _renderer.state;\\r\\n\\r\\n\\t\\t\\t// Set GL state for depth map.\\r\\n\\t\\t\\t_state.disable( _gl.BLEND );\\r\\n\\t\\t\\t_state.buffers.color.setClear( 1, 1, 1, 1 );\\r\\n\\t\\t\\t_state.buffers.depth.setTest( true );\\r\\n\\t\\t\\t_state.setScissorTest( false );\\r\\n\\r\\n\\t\\t\\t// render depth map\\r\\n\\r\\n\\t\\t\\tvar faceCount;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, il = lights.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar light = lights[ i ];\\r\\n\\t\\t\\t\\tvar shadow = light.shadow;\\r\\n\\t\\t\\t\\tvar isPointLight = light && light.isPointLight;\\r\\n\\r\\n\\t\\t\\t\\tif ( shadow === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\\r\\n\\t\\t\\t\\t\\tcontinue;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tvar shadowCamera = shadow.camera;\\r\\n\\r\\n\\t\\t\\t\\t_shadowMapSize.copy( shadow.mapSize );\\r\\n\\t\\t\\t\\t_shadowMapSize.min( _maxShadowMapSize );\\r\\n\\r\\n\\t\\t\\t\\tif ( isPointLight ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar vpWidth = _shadowMapSize.x;\\r\\n\\t\\t\\t\\t\\tvar vpHeight = _shadowMapSize.y;\\r\\n\\r\\n\\t\\t\\t\\t\\t// These viewports map a cube-map onto a 2D texture with the\\r\\n\\t\\t\\t\\t\\t// following orientation:\\r\\n\\t\\t\\t\\t\\t//\\r\\n\\t\\t\\t\\t\\t//  xzXZ\\r\\n\\t\\t\\t\\t\\t//   y Y\\r\\n\\t\\t\\t\\t\\t//\\r\\n\\t\\t\\t\\t\\t// X - Positive x direction\\r\\n\\t\\t\\t\\t\\t// x - Negative x direction\\r\\n\\t\\t\\t\\t\\t// Y - Positive y direction\\r\\n\\t\\t\\t\\t\\t// y - Negative y direction\\r\\n\\t\\t\\t\\t\\t// Z - Positive z direction\\r\\n\\t\\t\\t\\t\\t// z - Negative z direction\\r\\n\\r\\n\\t\\t\\t\\t\\t// positive X\\r\\n\\t\\t\\t\\t\\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\\r\\n\\t\\t\\t\\t\\t// negative X\\r\\n\\t\\t\\t\\t\\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\\r\\n\\t\\t\\t\\t\\t// positive Z\\r\\n\\t\\t\\t\\t\\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\\r\\n\\t\\t\\t\\t\\t// negative Z\\r\\n\\t\\t\\t\\t\\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\\r\\n\\t\\t\\t\\t\\t// positive Y\\r\\n\\t\\t\\t\\t\\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\\r\\n\\t\\t\\t\\t\\t// negative Y\\r\\n\\t\\t\\t\\t\\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\\r\\n\\r\\n\\t\\t\\t\\t\\t_shadowMapSize.x *= 4.0;\\r\\n\\t\\t\\t\\t\\t_shadowMapSize.y *= 2.0;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( shadow.map === null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };\\r\\n\\r\\n\\t\\t\\t\\t\\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\\r\\n\\t\\t\\t\\t\\tshadow.map.texture.name = light.name + \\\".shadowMap\\\";\\r\\n\\r\\n\\t\\t\\t\\t\\tshadowCamera.updateProjectionMatrix();\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( shadow.isSpotLightShadow ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tshadow.update( light );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tvar shadowMap = shadow.map;\\r\\n\\t\\t\\t\\tvar shadowMatrix = shadow.matrix;\\r\\n\\r\\n\\t\\t\\t\\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\\r\\n\\t\\t\\t\\tshadowCamera.position.copy( _lightPositionWorld );\\r\\n\\r\\n\\t\\t\\t\\tif ( isPointLight ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tfaceCount = 6;\\r\\n\\r\\n\\t\\t\\t\\t\\t// for point lights we set the shadow matrix to be a translation-only matrix\\r\\n\\t\\t\\t\\t\\t// equal to inverse of the light's position\\r\\n\\r\\n\\t\\t\\t\\t\\tshadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tfaceCount = 1;\\r\\n\\r\\n\\t\\t\\t\\t\\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\\r\\n\\t\\t\\t\\t\\tshadowCamera.lookAt( _lookTarget );\\r\\n\\t\\t\\t\\t\\tshadowCamera.updateMatrixWorld();\\r\\n\\r\\n\\t\\t\\t\\t\\t// compute shadow matrix\\r\\n\\r\\n\\t\\t\\t\\t\\tshadowMatrix.set(\\r\\n\\t\\t\\t\\t\\t\\t0.5, 0.0, 0.0, 0.5,\\r\\n\\t\\t\\t\\t\\t\\t0.0, 0.5, 0.0, 0.5,\\r\\n\\t\\t\\t\\t\\t\\t0.0, 0.0, 0.5, 0.5,\\r\\n\\t\\t\\t\\t\\t\\t0.0, 0.0, 0.0, 1.0\\r\\n\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\\r\\n\\t\\t\\t\\t\\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t_renderer.setRenderTarget( shadowMap );\\r\\n\\t\\t\\t\\t_renderer.clear();\\r\\n\\r\\n\\t\\t\\t\\t// render shadow map for each cube face (if omni-directional) or\\r\\n\\t\\t\\t\\t// run a single pass if not\\r\\n\\r\\n\\t\\t\\t\\tfor ( var face = 0; face < faceCount; face ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( isPointLight ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t_lookTarget.copy( shadowCamera.position );\\r\\n\\t\\t\\t\\t\\t\\t_lookTarget.add( cubeDirections[ face ] );\\r\\n\\t\\t\\t\\t\\t\\tshadowCamera.up.copy( cubeUps[ face ] );\\r\\n\\t\\t\\t\\t\\t\\tshadowCamera.lookAt( _lookTarget );\\r\\n\\t\\t\\t\\t\\t\\tshadowCamera.updateMatrixWorld();\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar vpDimensions = cube2DViewPorts[ face ];\\r\\n\\t\\t\\t\\t\\t\\t_state.viewport( vpDimensions );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t// update camera matrices and frustum\\r\\n\\r\\n\\t\\t\\t\\t\\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\\r\\n\\t\\t\\t\\t\\t_frustum.setFromMatrix( _projScreenMatrix );\\r\\n\\r\\n\\t\\t\\t\\t\\t// set object matrices & frustum culling\\r\\n\\r\\n\\t\\t\\t\\t\\trenderObject( scene, camera, shadowCamera, isPointLight );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tscope.needsUpdate = false;\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar ) {\\r\\n\\r\\n\\t\\t\\tvar geometry = object.geometry;\\r\\n\\r\\n\\t\\t\\tvar result = null;\\r\\n\\r\\n\\t\\t\\tvar materialVariants = _depthMaterials;\\r\\n\\t\\t\\tvar customMaterial = object.customDepthMaterial;\\r\\n\\r\\n\\t\\t\\tif ( isPointLight ) {\\r\\n\\r\\n\\t\\t\\t\\tmaterialVariants = _distanceMaterials;\\r\\n\\t\\t\\t\\tcustomMaterial = object.customDistanceMaterial;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( ! customMaterial ) {\\r\\n\\r\\n\\t\\t\\t\\tvar useMorphing = false;\\r\\n\\r\\n\\t\\t\\t\\tif ( material.morphTargets ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( geometry && geometry.isBufferGeometry ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tuseMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;\\r\\n\\r\\n\\t\\t\\t\\t\\t} else if ( geometry && geometry.isGeometry ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tuseMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( object.isSkinnedMesh && material.skinning === false ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tvar useSkinning = object.isSkinnedMesh && material.skinning;\\r\\n\\r\\n\\t\\t\\t\\tvar variantIndex = 0;\\r\\n\\r\\n\\t\\t\\t\\tif ( useMorphing ) variantIndex |= _MorphingFlag;\\r\\n\\t\\t\\t\\tif ( useSkinning ) variantIndex |= _SkinningFlag;\\r\\n\\r\\n\\t\\t\\t\\tresult = materialVariants[ variantIndex ];\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tresult = customMaterial;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( _renderer.localClippingEnabled &&\\r\\n\\t\\t\\t\\t\\tmaterial.clipShadows === true &&\\r\\n\\t\\t\\t\\t\\tmaterial.clippingPlanes.length !== 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t// in this case we need a unique material instance reflecting the\\r\\n\\t\\t\\t\\t// appropriate state\\r\\n\\r\\n\\t\\t\\t\\tvar keyA = result.uuid, keyB = material.uuid;\\r\\n\\r\\n\\t\\t\\t\\tvar materialsForVariant = _materialCache[ keyA ];\\r\\n\\r\\n\\t\\t\\t\\tif ( materialsForVariant === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tmaterialsForVariant = {};\\r\\n\\t\\t\\t\\t\\t_materialCache[ keyA ] = materialsForVariant;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tvar cachedMaterial = materialsForVariant[ keyB ];\\r\\n\\r\\n\\t\\t\\t\\tif ( cachedMaterial === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcachedMaterial = result.clone();\\r\\n\\t\\t\\t\\t\\tmaterialsForVariant[ keyB ] = cachedMaterial;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tresult = cachedMaterial;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tresult.visible = material.visible;\\r\\n\\t\\t\\tresult.wireframe = material.wireframe;\\r\\n\\r\\n\\t\\t\\tvar side = material.side;\\r\\n\\r\\n\\t\\t\\tif ( scope.renderSingleSided && side == DoubleSide ) {\\r\\n\\r\\n\\t\\t\\t\\tside = FrontSide;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( scope.renderReverseSided ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( side === FrontSide ) side = BackSide;\\r\\n\\t\\t\\t\\telse if ( side === BackSide ) side = FrontSide;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tresult.side = side;\\r\\n\\r\\n\\t\\t\\tresult.clipShadows = material.clipShadows;\\r\\n\\t\\t\\tresult.clippingPlanes = material.clippingPlanes;\\r\\n\\t\\t\\tresult.clipIntersection = material.clipIntersection;\\r\\n\\r\\n\\t\\t\\tresult.wireframeLinewidth = material.wireframeLinewidth;\\r\\n\\t\\t\\tresult.linewidth = material.linewidth;\\r\\n\\r\\n\\t\\t\\tif ( isPointLight && result.isMeshDistanceMaterial ) {\\r\\n\\r\\n\\t\\t\\t\\tresult.referencePosition.copy( lightPositionWorld );\\r\\n\\t\\t\\t\\tresult.nearDistance = shadowCameraNear;\\r\\n\\t\\t\\t\\tresult.farDistance = shadowCameraFar;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn result;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction renderObject( object, camera, shadowCamera, isPointLight ) {\\r\\n\\r\\n\\t\\t\\tif ( object.visible === false ) return;\\r\\n\\r\\n\\t\\t\\tvar visible = object.layers.test( camera.layers );\\r\\n\\r\\n\\t\\t\\tif ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( object.castShadow && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\\r\\n\\r\\n\\t\\t\\t\\t\\tvar geometry = _objects.update( object );\\r\\n\\t\\t\\t\\t\\tvar material = object.material;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( Array.isArray( material ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar groups = geometry.groups;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar group = groups[ k ];\\r\\n\\t\\t\\t\\t\\t\\t\\tvar groupMaterial = material[ group.materialIndex ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( groupMaterial && groupMaterial.visible ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t} else if ( material.visible ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );\\r\\n\\t\\t\\t\\t\\t\\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar children = object.children;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\trenderObject( children[ i ], camera, shadowCamera, isPointLight );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction WebGLAttributes( gl ) {\\r\\n\\r\\n\\t\\tvar buffers = {};\\r\\n\\r\\n\\t\\tfunction createBuffer( attribute, bufferType ) {\\r\\n\\r\\n\\t\\t\\tvar array = attribute.array;\\r\\n\\t\\t\\tvar usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\\r\\n\\r\\n\\t\\t\\tvar buffer = gl.createBuffer();\\r\\n\\r\\n\\t\\t\\tgl.bindBuffer( bufferType, buffer );\\r\\n\\t\\t\\tgl.bufferData( bufferType, array, usage );\\r\\n\\r\\n\\t\\t\\tattribute.onUploadCallback();\\r\\n\\r\\n\\t\\t\\tvar type = gl.FLOAT;\\r\\n\\r\\n\\t\\t\\tif ( array instanceof Float32Array ) {\\r\\n\\r\\n\\t\\t\\t\\ttype = gl.FLOAT;\\r\\n\\r\\n\\t\\t\\t} else if ( array instanceof Float64Array ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );\\r\\n\\r\\n\\t\\t\\t} else if ( array instanceof Uint16Array ) {\\r\\n\\r\\n\\t\\t\\t\\ttype = gl.UNSIGNED_SHORT;\\r\\n\\r\\n\\t\\t\\t} else if ( array instanceof Int16Array ) {\\r\\n\\r\\n\\t\\t\\t\\ttype = gl.SHORT;\\r\\n\\r\\n\\t\\t\\t} else if ( array instanceof Uint32Array ) {\\r\\n\\r\\n\\t\\t\\t\\ttype = gl.UNSIGNED_INT;\\r\\n\\r\\n\\t\\t\\t} else if ( array instanceof Int32Array ) {\\r\\n\\r\\n\\t\\t\\t\\ttype = gl.INT;\\r\\n\\r\\n\\t\\t\\t} else if ( array instanceof Int8Array ) {\\r\\n\\r\\n\\t\\t\\t\\ttype = gl.BYTE;\\r\\n\\r\\n\\t\\t\\t} else if ( array instanceof Uint8Array ) {\\r\\n\\r\\n\\t\\t\\t\\ttype = gl.UNSIGNED_BYTE;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn {\\r\\n\\t\\t\\t\\tbuffer: buffer,\\r\\n\\t\\t\\t\\ttype: type,\\r\\n\\t\\t\\t\\tbytesPerElement: array.BYTES_PER_ELEMENT,\\r\\n\\t\\t\\t\\tversion: attribute.version\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction updateBuffer( buffer, attribute, bufferType ) {\\r\\n\\r\\n\\t\\t\\tvar array = attribute.array;\\r\\n\\t\\t\\tvar updateRange = attribute.updateRange;\\r\\n\\r\\n\\t\\t\\tgl.bindBuffer( bufferType, buffer );\\r\\n\\r\\n\\t\\t\\tif ( attribute.dynamic === false ) {\\r\\n\\r\\n\\t\\t\\t\\tgl.bufferData( bufferType, array, gl.STATIC_DRAW );\\r\\n\\r\\n\\t\\t\\t} else if ( updateRange.count === - 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t// Not using update ranges\\r\\n\\r\\n\\t\\t\\t\\tgl.bufferSubData( bufferType, 0, array );\\r\\n\\r\\n\\t\\t\\t} else if ( updateRange.count === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tgl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,\\r\\n\\t\\t\\t\\t\\tarray.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );\\r\\n\\r\\n\\t\\t\\t\\tupdateRange.count = - 1; // reset range\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tfunction get( attribute ) {\\r\\n\\r\\n\\t\\t\\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\\r\\n\\r\\n\\t\\t\\treturn buffers[ attribute.uuid ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction remove( attribute ) {\\r\\n\\r\\n\\t\\t\\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\\r\\n\\r\\n\\t\\t\\tvar data = buffers[ attribute.uuid ];\\r\\n\\r\\n\\t\\t\\tif ( data ) {\\r\\n\\r\\n\\t\\t\\t\\tgl.deleteBuffer( data.buffer );\\r\\n\\r\\n\\t\\t\\t\\tdelete buffers[ attribute.uuid ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction update( attribute, bufferType ) {\\r\\n\\r\\n\\t\\t\\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\\r\\n\\r\\n\\t\\t\\tvar data = buffers[ attribute.uuid ];\\r\\n\\r\\n\\t\\t\\tif ( data === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tbuffers[ attribute.uuid ] = createBuffer( attribute, bufferType );\\r\\n\\r\\n\\t\\t\\t} else if ( data.version < attribute.version ) {\\r\\n\\r\\n\\t\\t\\t\\tupdateBuffer( data.buffer, attribute, bufferType );\\r\\n\\r\\n\\t\\t\\t\\tdata.version = attribute.version;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn {\\r\\n\\r\\n\\t\\t\\tget: get,\\r\\n\\t\\t\\tremove: remove,\\r\\n\\t\\t\\tupdate: update\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author WestLangley / http://github.com/WestLangley\\r\\n\\t * @author bhouston / http://clara.io\\r\\n\\t */\\r\\n\\r\\n\\tfunction Euler( x, y, z, order ) {\\r\\n\\r\\n\\t\\tthis._x = x || 0;\\r\\n\\t\\tthis._y = y || 0;\\r\\n\\t\\tthis._z = z || 0;\\r\\n\\t\\tthis._order = order || Euler.DefaultOrder;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tEuler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\\r\\n\\r\\n\\tEuler.DefaultOrder = 'XYZ';\\r\\n\\r\\n\\tObject.defineProperties( Euler.prototype, {\\r\\n\\r\\n\\t\\tx: {\\r\\n\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\treturn this._x;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._x = value;\\r\\n\\t\\t\\t\\tthis.onChangeCallback();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ty: {\\r\\n\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\treturn this._y;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._y = value;\\r\\n\\t\\t\\t\\tthis.onChangeCallback();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tz: {\\r\\n\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\treturn this._z;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._z = value;\\r\\n\\t\\t\\t\\tthis.onChangeCallback();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\torder: {\\r\\n\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\treturn this._order;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._order = value;\\r\\n\\t\\t\\t\\tthis.onChangeCallback();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tObject.assign( Euler.prototype, {\\r\\n\\r\\n\\t\\tisEuler: true,\\r\\n\\r\\n\\t\\tset: function ( x, y, z, order ) {\\r\\n\\r\\n\\t\\t\\tthis._x = x;\\r\\n\\t\\t\\tthis._y = y;\\r\\n\\t\\t\\tthis._z = z;\\r\\n\\t\\t\\tthis._order = order || this._order;\\r\\n\\r\\n\\t\\t\\tthis.onChangeCallback();\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor( this._x, this._y, this._z, this._order );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( euler ) {\\r\\n\\r\\n\\t\\t\\tthis._x = euler._x;\\r\\n\\t\\t\\tthis._y = euler._y;\\r\\n\\t\\t\\tthis._z = euler._z;\\r\\n\\t\\t\\tthis._order = euler._order;\\r\\n\\r\\n\\t\\t\\tthis.onChangeCallback();\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFromRotationMatrix: function ( m, order, update ) {\\r\\n\\r\\n\\t\\t\\tvar clamp = _Math.clamp;\\r\\n\\r\\n\\t\\t\\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\\r\\n\\r\\n\\t\\t\\tvar te = m.elements;\\r\\n\\t\\t\\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\\r\\n\\t\\t\\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\\r\\n\\t\\t\\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\\r\\n\\r\\n\\t\\t\\torder = order || this._order;\\r\\n\\r\\n\\t\\t\\tif ( order === 'XYZ' ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\\r\\n\\r\\n\\t\\t\\t\\tif ( Math.abs( m13 ) < 0.99999 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._x = Math.atan2( - m23, m33 );\\r\\n\\t\\t\\t\\t\\tthis._z = Math.atan2( - m12, m11 );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._x = Math.atan2( m32, m22 );\\r\\n\\t\\t\\t\\t\\tthis._z = 0;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else if ( order === 'YXZ' ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\\r\\n\\r\\n\\t\\t\\t\\tif ( Math.abs( m23 ) < 0.99999 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._y = Math.atan2( m13, m33 );\\r\\n\\t\\t\\t\\t\\tthis._z = Math.atan2( m21, m22 );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._y = Math.atan2( - m31, m11 );\\r\\n\\t\\t\\t\\t\\tthis._z = 0;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else if ( order === 'ZXY' ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\\r\\n\\r\\n\\t\\t\\t\\tif ( Math.abs( m32 ) < 0.99999 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._y = Math.atan2( - m31, m33 );\\r\\n\\t\\t\\t\\t\\tthis._z = Math.atan2( - m12, m22 );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._y = 0;\\r\\n\\t\\t\\t\\t\\tthis._z = Math.atan2( m21, m11 );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else if ( order === 'ZYX' ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\\r\\n\\r\\n\\t\\t\\t\\tif ( Math.abs( m31 ) < 0.99999 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._x = Math.atan2( m32, m33 );\\r\\n\\t\\t\\t\\t\\tthis._z = Math.atan2( m21, m11 );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._x = 0;\\r\\n\\t\\t\\t\\t\\tthis._z = Math.atan2( - m12, m22 );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else if ( order === 'YZX' ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\\r\\n\\r\\n\\t\\t\\t\\tif ( Math.abs( m21 ) < 0.99999 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._x = Math.atan2( - m23, m22 );\\r\\n\\t\\t\\t\\t\\tthis._y = Math.atan2( - m31, m11 );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._x = 0;\\r\\n\\t\\t\\t\\t\\tthis._y = Math.atan2( m13, m33 );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else if ( order === 'XZY' ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\\r\\n\\r\\n\\t\\t\\t\\tif ( Math.abs( m12 ) < 0.99999 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._x = Math.atan2( m32, m22 );\\r\\n\\t\\t\\t\\t\\tthis._y = Math.atan2( m13, m11 );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._x = Math.atan2( - m23, m33 );\\r\\n\\t\\t\\t\\t\\tthis._y = 0;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis._order = order;\\r\\n\\r\\n\\t\\t\\tif ( update !== false ) this.onChangeCallback();\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFromQuaternion: function () {\\r\\n\\r\\n\\t\\t\\tvar matrix = new Matrix4();\\r\\n\\r\\n\\t\\t\\treturn function setFromQuaternion( q, order, update ) {\\r\\n\\r\\n\\t\\t\\t\\tmatrix.makeRotationFromQuaternion( q );\\r\\n\\r\\n\\t\\t\\t\\treturn this.setFromRotationMatrix( matrix, order, update );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tsetFromVector3: function ( v, order ) {\\r\\n\\r\\n\\t\\t\\treturn this.set( v.x, v.y, v.z, order || this._order );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\treorder: function () {\\r\\n\\r\\n\\t\\t\\t// WARNING: this discards revolution information -bhouston\\r\\n\\r\\n\\t\\t\\tvar q = new Quaternion();\\r\\n\\r\\n\\t\\t\\treturn function reorder( newOrder ) {\\r\\n\\r\\n\\t\\t\\t\\tq.setFromEuler( this );\\r\\n\\r\\n\\t\\t\\t\\treturn this.setFromQuaternion( q, newOrder );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tequals: function ( euler ) {\\r\\n\\r\\n\\t\\t\\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tfromArray: function ( array ) {\\r\\n\\r\\n\\t\\t\\tthis._x = array[ 0 ];\\r\\n\\t\\t\\tthis._y = array[ 1 ];\\r\\n\\t\\t\\tthis._z = array[ 2 ];\\r\\n\\t\\t\\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\\r\\n\\r\\n\\t\\t\\tthis.onChangeCallback();\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttoArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\t\\tif ( array === undefined ) array = [];\\r\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\t\\tarray[ offset ] = this._x;\\r\\n\\t\\t\\tarray[ offset + 1 ] = this._y;\\r\\n\\t\\t\\tarray[ offset + 2 ] = this._z;\\r\\n\\t\\t\\tarray[ offset + 3 ] = this._order;\\r\\n\\r\\n\\t\\t\\treturn array;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttoVector3: function ( optionalResult ) {\\r\\n\\r\\n\\t\\t\\tif ( optionalResult ) {\\r\\n\\r\\n\\t\\t\\t\\treturn optionalResult.set( this._x, this._y, this._z );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\treturn new Vector3( this._x, this._y, this._z );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tonChange: function ( callback ) {\\r\\n\\r\\n\\t\\t\\tthis.onChangeCallback = callback;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tonChangeCallback: function () {}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction Layers() {\\r\\n\\r\\n\\t\\tthis.mask = 1 | 0;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( Layers.prototype, {\\r\\n\\r\\n\\t\\tset: function ( channel ) {\\r\\n\\r\\n\\t\\t\\tthis.mask = 1 << channel | 0;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tenable: function ( channel ) {\\r\\n\\r\\n\\t\\t\\tthis.mask |= 1 << channel | 0;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttoggle: function ( channel ) {\\r\\n\\r\\n\\t\\t\\tthis.mask ^= 1 << channel | 0;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdisable: function ( channel ) {\\r\\n\\r\\n\\t\\t\\tthis.mask &= ~ ( 1 << channel | 0 );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttest: function ( layers ) {\\r\\n\\r\\n\\t\\t\\treturn ( this.mask & layers.mask ) !== 0;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author mikael emtinger / http://gomo.se/\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t * @author WestLangley / http://github.com/WestLangley\\r\\n\\t * @author elephantatwork / www.elephantatwork.ch\\r\\n\\t */\\r\\n\\r\\n\\tvar object3DId = 0;\\r\\n\\r\\n\\tfunction Object3D() {\\r\\n\\r\\n\\t\\tObject.defineProperty( this, 'id', { value: object3DId ++ } );\\r\\n\\r\\n\\t\\tthis.uuid = _Math.generateUUID();\\r\\n\\r\\n\\t\\tthis.name = '';\\r\\n\\t\\tthis.type = 'Object3D';\\r\\n\\r\\n\\t\\tthis.parent = null;\\r\\n\\t\\tthis.children = [];\\r\\n\\r\\n\\t\\tthis.up = Object3D.DefaultUp.clone();\\r\\n\\r\\n\\t\\tvar position = new Vector3();\\r\\n\\t\\tvar rotation = new Euler();\\r\\n\\t\\tvar quaternion = new Quaternion();\\r\\n\\t\\tvar scale = new Vector3( 1, 1, 1 );\\r\\n\\r\\n\\t\\tfunction onRotationChange() {\\r\\n\\r\\n\\t\\t\\tquaternion.setFromEuler( rotation, false );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction onQuaternionChange() {\\r\\n\\r\\n\\t\\t\\trotation.setFromQuaternion( quaternion, undefined, false );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\trotation.onChange( onRotationChange );\\r\\n\\t\\tquaternion.onChange( onQuaternionChange );\\r\\n\\r\\n\\t\\tObject.defineProperties( this, {\\r\\n\\t\\t\\tposition: {\\r\\n\\t\\t\\t\\tenumerable: true,\\r\\n\\t\\t\\t\\tvalue: position\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\trotation: {\\r\\n\\t\\t\\t\\tenumerable: true,\\r\\n\\t\\t\\t\\tvalue: rotation\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tquaternion: {\\r\\n\\t\\t\\t\\tenumerable: true,\\r\\n\\t\\t\\t\\tvalue: quaternion\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tscale: {\\r\\n\\t\\t\\t\\tenumerable: true,\\r\\n\\t\\t\\t\\tvalue: scale\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tmodelViewMatrix: {\\r\\n\\t\\t\\t\\tvalue: new Matrix4()\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tnormalMatrix: {\\r\\n\\t\\t\\t\\tvalue: new Matrix3()\\r\\n\\t\\t\\t}\\r\\n\\t\\t} );\\r\\n\\r\\n\\t\\tthis.matrix = new Matrix4();\\r\\n\\t\\tthis.matrixWorld = new Matrix4();\\r\\n\\r\\n\\t\\tthis.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\\r\\n\\t\\tthis.matrixWorldNeedsUpdate = false;\\r\\n\\r\\n\\t\\tthis.layers = new Layers();\\r\\n\\t\\tthis.visible = true;\\r\\n\\r\\n\\t\\tthis.castShadow = false;\\r\\n\\t\\tthis.receiveShadow = false;\\r\\n\\r\\n\\t\\tthis.frustumCulled = true;\\r\\n\\t\\tthis.renderOrder = 0;\\r\\n\\r\\n\\t\\tthis.userData = {};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject3D.DefaultUp = new Vector3( 0, 1, 0 );\\r\\n\\tObject3D.DefaultMatrixAutoUpdate = true;\\r\\n\\r\\n\\tObject3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: Object3D,\\r\\n\\r\\n\\t\\tisObject3D: true,\\r\\n\\r\\n\\t\\tonBeforeRender: function () {},\\r\\n\\t\\tonAfterRender: function () {},\\r\\n\\r\\n\\t\\tapplyMatrix: function ( matrix ) {\\r\\n\\r\\n\\t\\t\\tthis.matrix.multiplyMatrices( matrix, this.matrix );\\r\\n\\r\\n\\t\\t\\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tapplyQuaternion: function ( q ) {\\r\\n\\r\\n\\t\\t\\tthis.quaternion.premultiply( q );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetRotationFromAxisAngle: function ( axis, angle ) {\\r\\n\\r\\n\\t\\t\\t// assumes axis is normalized\\r\\n\\r\\n\\t\\t\\tthis.quaternion.setFromAxisAngle( axis, angle );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetRotationFromEuler: function ( euler ) {\\r\\n\\r\\n\\t\\t\\tthis.quaternion.setFromEuler( euler, true );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetRotationFromMatrix: function ( m ) {\\r\\n\\r\\n\\t\\t\\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\\r\\n\\r\\n\\t\\t\\tthis.quaternion.setFromRotationMatrix( m );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetRotationFromQuaternion: function ( q ) {\\r\\n\\r\\n\\t\\t\\t// assumes q is normalized\\r\\n\\r\\n\\t\\t\\tthis.quaternion.copy( q );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\trotateOnAxis: function () {\\r\\n\\r\\n\\t\\t\\t// rotate object on axis in object space\\r\\n\\t\\t\\t// axis is assumed to be normalized\\r\\n\\r\\n\\t\\t\\tvar q1 = new Quaternion();\\r\\n\\r\\n\\t\\t\\treturn function rotateOnAxis( axis, angle ) {\\r\\n\\r\\n\\t\\t\\t\\tq1.setFromAxisAngle( axis, angle );\\r\\n\\r\\n\\t\\t\\t\\tthis.quaternion.multiply( q1 );\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\trotateOnWorldAxis: function () {\\r\\n\\r\\n\\t\\t\\t// rotate object on axis in world space\\r\\n\\t\\t\\t// axis is assumed to be normalized\\r\\n\\t\\t\\t// method assumes no rotated parent\\r\\n\\r\\n\\t\\t\\tvar q1 = new Quaternion();\\r\\n\\r\\n\\t\\t\\treturn function rotateOnWorldAxis( axis, angle ) {\\r\\n\\r\\n\\t\\t\\t\\tq1.setFromAxisAngle( axis, angle );\\r\\n\\r\\n\\t\\t\\t\\tthis.quaternion.premultiply( q1 );\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\trotateX: function () {\\r\\n\\r\\n\\t\\t\\tvar v1 = new Vector3( 1, 0, 0 );\\r\\n\\r\\n\\t\\t\\treturn function rotateX( angle ) {\\r\\n\\r\\n\\t\\t\\t\\treturn this.rotateOnAxis( v1, angle );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\trotateY: function () {\\r\\n\\r\\n\\t\\t\\tvar v1 = new Vector3( 0, 1, 0 );\\r\\n\\r\\n\\t\\t\\treturn function rotateY( angle ) {\\r\\n\\r\\n\\t\\t\\t\\treturn this.rotateOnAxis( v1, angle );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\trotateZ: function () {\\r\\n\\r\\n\\t\\t\\tvar v1 = new Vector3( 0, 0, 1 );\\r\\n\\r\\n\\t\\t\\treturn function rotateZ( angle ) {\\r\\n\\r\\n\\t\\t\\t\\treturn this.rotateOnAxis( v1, angle );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\ttranslateOnAxis: function () {\\r\\n\\r\\n\\t\\t\\t// translate object by distance along axis in object space\\r\\n\\t\\t\\t// axis is assumed to be normalized\\r\\n\\r\\n\\t\\t\\tvar v1 = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function translateOnAxis( axis, distance ) {\\r\\n\\r\\n\\t\\t\\t\\tv1.copy( axis ).applyQuaternion( this.quaternion );\\r\\n\\r\\n\\t\\t\\t\\tthis.position.add( v1.multiplyScalar( distance ) );\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\ttranslateX: function () {\\r\\n\\r\\n\\t\\t\\tvar v1 = new Vector3( 1, 0, 0 );\\r\\n\\r\\n\\t\\t\\treturn function translateX( distance ) {\\r\\n\\r\\n\\t\\t\\t\\treturn this.translateOnAxis( v1, distance );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\ttranslateY: function () {\\r\\n\\r\\n\\t\\t\\tvar v1 = new Vector3( 0, 1, 0 );\\r\\n\\r\\n\\t\\t\\treturn function translateY( distance ) {\\r\\n\\r\\n\\t\\t\\t\\treturn this.translateOnAxis( v1, distance );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\ttranslateZ: function () {\\r\\n\\r\\n\\t\\t\\tvar v1 = new Vector3( 0, 0, 1 );\\r\\n\\r\\n\\t\\t\\treturn function translateZ( distance ) {\\r\\n\\r\\n\\t\\t\\t\\treturn this.translateOnAxis( v1, distance );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tlocalToWorld: function ( vector ) {\\r\\n\\r\\n\\t\\t\\treturn vector.applyMatrix4( this.matrixWorld );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tworldToLocal: function () {\\r\\n\\r\\n\\t\\t\\tvar m1 = new Matrix4();\\r\\n\\r\\n\\t\\t\\treturn function worldToLocal( vector ) {\\r\\n\\r\\n\\t\\t\\t\\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tlookAt: function () {\\r\\n\\r\\n\\t\\t\\t// This method does not support objects with rotated and/or translated parent(s)\\r\\n\\r\\n\\t\\t\\tvar m1 = new Matrix4();\\r\\n\\t\\t\\tvar vector = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function lookAt( x, y, z ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( x.isVector3 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvector.copy( x );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tvector.set( x, y, z );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( this.isCamera ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tm1.lookAt( this.position, vector, this.up );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tm1.lookAt( vector, this.position, this.up );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tthis.quaternion.setFromRotationMatrix( m1 );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tadd: function ( object ) {\\r\\n\\r\\n\\t\\t\\tif ( arguments.length > 1 ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0; i < arguments.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.add( arguments[ i ] );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( object === this ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( \\\"THREE.Object3D.add: object can't be added as a child of itself.\\\", object );\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( ( object && object.isObject3D ) ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( object.parent !== null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tobject.parent.remove( object );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tobject.parent = this;\\r\\n\\t\\t\\t\\tobject.dispatchEvent( { type: 'added' } );\\r\\n\\r\\n\\t\\t\\t\\tthis.children.push( object );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( \\\"THREE.Object3D.add: object not an instance of THREE.Object3D.\\\", object );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tremove: function ( object ) {\\r\\n\\r\\n\\t\\t\\tif ( arguments.length > 1 ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0; i < arguments.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.remove( arguments[ i ] );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar index = this.children.indexOf( object );\\r\\n\\r\\n\\t\\t\\tif ( index !== - 1 ) {\\r\\n\\r\\n\\t\\t\\t\\tobject.parent = null;\\r\\n\\r\\n\\t\\t\\t\\tobject.dispatchEvent( { type: 'removed' } );\\r\\n\\r\\n\\t\\t\\t\\tthis.children.splice( index, 1 );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetObjectById: function ( id ) {\\r\\n\\r\\n\\t\\t\\treturn this.getObjectByProperty( 'id', id );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetObjectByName: function ( name ) {\\r\\n\\r\\n\\t\\t\\treturn this.getObjectByProperty( 'name', name );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetObjectByProperty: function ( name, value ) {\\r\\n\\r\\n\\t\\t\\tif ( this[ name ] === value ) return this;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar child = this.children[ i ];\\r\\n\\t\\t\\t\\tvar object = child.getObjectByProperty( name, value );\\r\\n\\r\\n\\t\\t\\t\\tif ( object !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn object;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn undefined;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetWorldPosition: function ( optionalTarget ) {\\r\\n\\r\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\r\\n\\r\\n\\t\\t\\tthis.updateMatrixWorld( true );\\r\\n\\r\\n\\t\\t\\treturn result.setFromMatrixPosition( this.matrixWorld );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetWorldQuaternion: function () {\\r\\n\\r\\n\\t\\t\\tvar position = new Vector3();\\r\\n\\t\\t\\tvar scale = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function getWorldQuaternion( optionalTarget ) {\\r\\n\\r\\n\\t\\t\\t\\tvar result = optionalTarget || new Quaternion();\\r\\n\\r\\n\\t\\t\\t\\tthis.updateMatrixWorld( true );\\r\\n\\r\\n\\t\\t\\t\\tthis.matrixWorld.decompose( position, result, scale );\\r\\n\\r\\n\\t\\t\\t\\treturn result;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tgetWorldRotation: function () {\\r\\n\\r\\n\\t\\t\\tvar quaternion = new Quaternion();\\r\\n\\r\\n\\t\\t\\treturn function getWorldRotation( optionalTarget ) {\\r\\n\\r\\n\\t\\t\\t\\tvar result = optionalTarget || new Euler();\\r\\n\\r\\n\\t\\t\\t\\tthis.getWorldQuaternion( quaternion );\\r\\n\\r\\n\\t\\t\\t\\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tgetWorldScale: function () {\\r\\n\\r\\n\\t\\t\\tvar position = new Vector3();\\r\\n\\t\\t\\tvar quaternion = new Quaternion();\\r\\n\\r\\n\\t\\t\\treturn function getWorldScale( optionalTarget ) {\\r\\n\\r\\n\\t\\t\\t\\tvar result = optionalTarget || new Vector3();\\r\\n\\r\\n\\t\\t\\t\\tthis.updateMatrixWorld( true );\\r\\n\\r\\n\\t\\t\\t\\tthis.matrixWorld.decompose( position, quaternion, result );\\r\\n\\r\\n\\t\\t\\t\\treturn result;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tgetWorldDirection: function () {\\r\\n\\r\\n\\t\\t\\tvar quaternion = new Quaternion();\\r\\n\\r\\n\\t\\t\\treturn function getWorldDirection( optionalTarget ) {\\r\\n\\r\\n\\t\\t\\t\\tvar result = optionalTarget || new Vector3();\\r\\n\\r\\n\\t\\t\\t\\tthis.getWorldQuaternion( quaternion );\\r\\n\\r\\n\\t\\t\\t\\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\traycast: function () {},\\r\\n\\r\\n\\t\\ttraverse: function ( callback ) {\\r\\n\\r\\n\\t\\t\\tcallback( this );\\r\\n\\r\\n\\t\\t\\tvar children = this.children;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tchildren[ i ].traverse( callback );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttraverseVisible: function ( callback ) {\\r\\n\\r\\n\\t\\t\\tif ( this.visible === false ) return;\\r\\n\\r\\n\\t\\t\\tcallback( this );\\r\\n\\r\\n\\t\\t\\tvar children = this.children;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tchildren[ i ].traverseVisible( callback );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttraverseAncestors: function ( callback ) {\\r\\n\\r\\n\\t\\t\\tvar parent = this.parent;\\r\\n\\r\\n\\t\\t\\tif ( parent !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tcallback( parent );\\r\\n\\r\\n\\t\\t\\t\\tparent.traverseAncestors( callback );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tupdateMatrix: function () {\\r\\n\\r\\n\\t\\t\\tthis.matrix.compose( this.position, this.quaternion, this.scale );\\r\\n\\r\\n\\t\\t\\tthis.matrixWorldNeedsUpdate = true;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tupdateMatrixWorld: function ( force ) {\\r\\n\\r\\n\\t\\t\\tif ( this.matrixAutoUpdate ) this.updateMatrix();\\r\\n\\r\\n\\t\\t\\tif ( this.matrixWorldNeedsUpdate || force ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( this.parent === null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.matrixWorld.copy( this.matrix );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tthis.matrixWorldNeedsUpdate = false;\\r\\n\\r\\n\\t\\t\\t\\tforce = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// update children\\r\\n\\r\\n\\t\\t\\tvar children = this.children;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tchildren[ i ].updateMatrixWorld( force );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttoJSON: function ( meta ) {\\r\\n\\r\\n\\t\\t\\t// meta is a string when called from JSON.stringify\\r\\n\\t\\t\\tvar isRootObject = ( meta === undefined || typeof meta === 'string' );\\r\\n\\r\\n\\t\\t\\tvar output = {};\\r\\n\\r\\n\\t\\t\\t// meta is a hash used to collect geometries, materials.\\r\\n\\t\\t\\t// not providing it implies that this is the root object\\r\\n\\t\\t\\t// being serialized.\\r\\n\\t\\t\\tif ( isRootObject ) {\\r\\n\\r\\n\\t\\t\\t\\t// initialize meta obj\\r\\n\\t\\t\\t\\tmeta = {\\r\\n\\t\\t\\t\\t\\tgeometries: {},\\r\\n\\t\\t\\t\\t\\tmaterials: {},\\r\\n\\t\\t\\t\\t\\ttextures: {},\\r\\n\\t\\t\\t\\t\\timages: {},\\r\\n\\t\\t\\t\\t\\tshapes: {}\\r\\n\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t\\toutput.metadata = {\\r\\n\\t\\t\\t\\t\\tversion: 4.5,\\r\\n\\t\\t\\t\\t\\ttype: 'Object',\\r\\n\\t\\t\\t\\t\\tgenerator: 'Object3D.toJSON'\\r\\n\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// standard Object3D serialization\\r\\n\\r\\n\\t\\t\\tvar object = {};\\r\\n\\r\\n\\t\\t\\tobject.uuid = this.uuid;\\r\\n\\t\\t\\tobject.type = this.type;\\r\\n\\r\\n\\t\\t\\tif ( this.name !== '' ) object.name = this.name;\\r\\n\\t\\t\\tif ( this.castShadow === true ) object.castShadow = true;\\r\\n\\t\\t\\tif ( this.receiveShadow === true ) object.receiveShadow = true;\\r\\n\\t\\t\\tif ( this.visible === false ) object.visible = false;\\r\\n\\t\\t\\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\\r\\n\\r\\n\\t\\t\\tobject.matrix = this.matrix.toArray();\\r\\n\\r\\n\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\tfunction serialize( library, element ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( library[ element.uuid ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tlibrary[ element.uuid ] = element.toJSON( meta );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn element.uuid;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( this.geometry !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tobject.geometry = serialize( meta.geometries, this.geometry );\\r\\n\\r\\n\\t\\t\\t\\tvar parameters = this.geometry.parameters;\\r\\n\\r\\n\\t\\t\\t\\tif ( parameters !== undefined && parameters.shapes !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar shapes = parameters.shapes;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( Array.isArray( shapes ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar shape = shapes[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tserialize( meta.shapes, shape );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tserialize( meta.shapes, shapes );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( this.material !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( Array.isArray( this.material ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar uuids = [];\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = this.material.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tuuids.push( serialize( meta.materials, this.material[ i ] ) );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tobject.material = uuids;\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tobject.material = serialize( meta.materials, this.material );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\tif ( this.children.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tobject.children = [];\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0; i < this.children.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tobject.children.push( this.children[ i ].toJSON( meta ).object );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( isRootObject ) {\\r\\n\\r\\n\\t\\t\\t\\tvar geometries = extractFromCache( meta.geometries );\\r\\n\\t\\t\\t\\tvar materials = extractFromCache( meta.materials );\\r\\n\\t\\t\\t\\tvar textures = extractFromCache( meta.textures );\\r\\n\\t\\t\\t\\tvar images = extractFromCache( meta.images );\\r\\n\\t\\t\\t\\tvar shapes = extractFromCache( meta.shapes );\\r\\n\\r\\n\\t\\t\\t\\tif ( geometries.length > 0 ) output.geometries = geometries;\\r\\n\\t\\t\\t\\tif ( materials.length > 0 ) output.materials = materials;\\r\\n\\t\\t\\t\\tif ( textures.length > 0 ) output.textures = textures;\\r\\n\\t\\t\\t\\tif ( images.length > 0 ) output.images = images;\\r\\n\\t\\t\\t\\tif ( shapes.length > 0 ) output.shapes = shapes;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\toutput.object = object;\\r\\n\\r\\n\\t\\t\\treturn output;\\r\\n\\r\\n\\t\\t\\t// extract data from the cache hash\\r\\n\\t\\t\\t// remove metadata on each item\\r\\n\\t\\t\\t// and return as array\\r\\n\\t\\t\\tfunction extractFromCache( cache ) {\\r\\n\\r\\n\\t\\t\\t\\tvar values = [];\\r\\n\\t\\t\\t\\tfor ( var key in cache ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar data = cache[ key ];\\r\\n\\t\\t\\t\\t\\tdelete data.metadata;\\r\\n\\t\\t\\t\\t\\tvalues.push( data );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\treturn values;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclone: function ( recursive ) {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor().copy( this, recursive );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( source, recursive ) {\\r\\n\\r\\n\\t\\t\\tif ( recursive === undefined ) recursive = true;\\r\\n\\r\\n\\t\\t\\tthis.name = source.name;\\r\\n\\r\\n\\t\\t\\tthis.up.copy( source.up );\\r\\n\\r\\n\\t\\t\\tthis.position.copy( source.position );\\r\\n\\t\\t\\tthis.quaternion.copy( source.quaternion );\\r\\n\\t\\t\\tthis.scale.copy( source.scale );\\r\\n\\r\\n\\t\\t\\tthis.matrix.copy( source.matrix );\\r\\n\\t\\t\\tthis.matrixWorld.copy( source.matrixWorld );\\r\\n\\r\\n\\t\\t\\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\\r\\n\\t\\t\\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\\r\\n\\r\\n\\t\\t\\tthis.layers.mask = source.layers.mask;\\r\\n\\t\\t\\tthis.visible = source.visible;\\r\\n\\r\\n\\t\\t\\tthis.castShadow = source.castShadow;\\r\\n\\t\\t\\tthis.receiveShadow = source.receiveShadow;\\r\\n\\r\\n\\t\\t\\tthis.frustumCulled = source.frustumCulled;\\r\\n\\t\\t\\tthis.renderOrder = source.renderOrder;\\r\\n\\r\\n\\t\\t\\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\\r\\n\\r\\n\\t\\t\\tif ( recursive === true ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0; i < source.children.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar child = source.children[ i ];\\r\\n\\t\\t\\t\\t\\tthis.add( child.clone() );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author mikael emtinger / http://gomo.se/\\r\\n\\t * @author WestLangley / http://github.com/WestLangley\\r\\n\\t*/\\r\\n\\r\\n\\tfunction Camera() {\\r\\n\\r\\n\\t\\tObject3D.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'Camera';\\r\\n\\r\\n\\t\\tthis.matrixWorldInverse = new Matrix4();\\r\\n\\t\\tthis.projectionMatrix = new Matrix4();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tCamera.prototype = Object.assign( Object.create( Object3D.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: Camera,\\r\\n\\r\\n\\t\\tisCamera: true,\\r\\n\\r\\n\\t\\tcopy: function ( source, recursive ) {\\r\\n\\r\\n\\t\\t\\tObject3D.prototype.copy.call( this, source, recursive );\\r\\n\\r\\n\\t\\t\\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\\r\\n\\t\\t\\tthis.projectionMatrix.copy( source.projectionMatrix );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetWorldDirection: function () {\\r\\n\\r\\n\\t\\t\\tvar quaternion = new Quaternion();\\r\\n\\r\\n\\t\\t\\treturn function getWorldDirection( optionalTarget ) {\\r\\n\\r\\n\\t\\t\\t\\tvar result = optionalTarget || new Vector3();\\r\\n\\r\\n\\t\\t\\t\\tthis.getWorldQuaternion( quaternion );\\r\\n\\r\\n\\t\\t\\t\\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tupdateMatrixWorld: function ( force ) {\\r\\n\\r\\n\\t\\t\\tObject3D.prototype.updateMatrixWorld.call( this, force );\\r\\n\\r\\n\\t\\t\\tthis.matrixWorldInverse.getInverse( this.matrixWorld );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t * @author arose / http://github.com/arose\\r\\n\\t */\\r\\n\\r\\n\\tfunction OrthographicCamera( left, right, top, bottom, near, far ) {\\r\\n\\r\\n\\t\\tCamera.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'OrthographicCamera';\\r\\n\\r\\n\\t\\tthis.zoom = 1;\\r\\n\\t\\tthis.view = null;\\r\\n\\r\\n\\t\\tthis.left = left;\\r\\n\\t\\tthis.right = right;\\r\\n\\t\\tthis.top = top;\\r\\n\\t\\tthis.bottom = bottom;\\r\\n\\r\\n\\t\\tthis.near = ( near !== undefined ) ? near : 0.1;\\r\\n\\t\\tthis.far = ( far !== undefined ) ? far : 2000;\\r\\n\\r\\n\\t\\tthis.updateProjectionMatrix();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tOrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: OrthographicCamera,\\r\\n\\r\\n\\t\\tisOrthographicCamera: true,\\r\\n\\r\\n\\t\\tcopy: function ( source, recursive ) {\\r\\n\\r\\n\\t\\t\\tCamera.prototype.copy.call( this, source, recursive );\\r\\n\\r\\n\\t\\t\\tthis.left = source.left;\\r\\n\\t\\t\\tthis.right = source.right;\\r\\n\\t\\t\\tthis.top = source.top;\\r\\n\\t\\t\\tthis.bottom = source.bottom;\\r\\n\\t\\t\\tthis.near = source.near;\\r\\n\\t\\t\\tthis.far = source.far;\\r\\n\\r\\n\\t\\t\\tthis.zoom = source.zoom;\\r\\n\\t\\t\\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\\r\\n\\r\\n\\t\\t\\tif ( this.view === null ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.view = {\\r\\n\\t\\t\\t\\t\\tenabled: true,\\r\\n\\t\\t\\t\\t\\tfullWidth: 1,\\r\\n\\t\\t\\t\\t\\tfullHeight: 1,\\r\\n\\t\\t\\t\\t\\toffsetX: 0,\\r\\n\\t\\t\\t\\t\\toffsetY: 0,\\r\\n\\t\\t\\t\\t\\twidth: 1,\\r\\n\\t\\t\\t\\t\\theight: 1\\r\\n\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.view.enabled = true;\\r\\n\\t\\t\\tthis.view.fullWidth = fullWidth;\\r\\n\\t\\t\\tthis.view.fullHeight = fullHeight;\\r\\n\\t\\t\\tthis.view.offsetX = x;\\r\\n\\t\\t\\tthis.view.offsetY = y;\\r\\n\\t\\t\\tthis.view.width = width;\\r\\n\\t\\t\\tthis.view.height = height;\\r\\n\\r\\n\\t\\t\\tthis.updateProjectionMatrix();\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclearViewOffset: function () {\\r\\n\\r\\n\\t\\t\\tif ( this.view !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.view.enabled = false;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.updateProjectionMatrix();\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tupdateProjectionMatrix: function () {\\r\\n\\r\\n\\t\\t\\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\\r\\n\\t\\t\\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\\r\\n\\t\\t\\tvar cx = ( this.right + this.left ) / 2;\\r\\n\\t\\t\\tvar cy = ( this.top + this.bottom ) / 2;\\r\\n\\r\\n\\t\\t\\tvar left = cx - dx;\\r\\n\\t\\t\\tvar right = cx + dx;\\r\\n\\t\\t\\tvar top = cy + dy;\\r\\n\\t\\t\\tvar bottom = cy - dy;\\r\\n\\r\\n\\t\\t\\tif ( this.view !== null && this.view.enabled ) {\\r\\n\\r\\n\\t\\t\\t\\tvar zoomW = this.zoom / ( this.view.width / this.view.fullWidth );\\r\\n\\t\\t\\t\\tvar zoomH = this.zoom / ( this.view.height / this.view.fullHeight );\\r\\n\\t\\t\\t\\tvar scaleW = ( this.right - this.left ) / this.view.width;\\r\\n\\t\\t\\t\\tvar scaleH = ( this.top - this.bottom ) / this.view.height;\\r\\n\\r\\n\\t\\t\\t\\tleft += scaleW * ( this.view.offsetX / zoomW );\\r\\n\\t\\t\\t\\tright = left + scaleW * ( this.view.width / zoomW );\\r\\n\\t\\t\\t\\ttop -= scaleH * ( this.view.offsetY / zoomH );\\r\\n\\t\\t\\t\\tbottom = top - scaleH * ( this.view.height / zoomH );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttoJSON: function ( meta ) {\\r\\n\\r\\n\\t\\t\\tvar data = Object3D.prototype.toJSON.call( this, meta );\\r\\n\\r\\n\\t\\t\\tdata.object.zoom = this.zoom;\\r\\n\\t\\t\\tdata.object.left = this.left;\\r\\n\\t\\t\\tdata.object.right = this.right;\\r\\n\\t\\t\\tdata.object.top = this.top;\\r\\n\\t\\t\\tdata.object.bottom = this.bottom;\\r\\n\\t\\t\\tdata.object.near = this.near;\\r\\n\\t\\t\\tdata.object.far = this.far;\\r\\n\\r\\n\\t\\t\\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\\r\\n\\r\\n\\t\\t\\treturn data;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction Face3( a, b, c, normal, color, materialIndex ) {\\r\\n\\r\\n\\t\\tthis.a = a;\\r\\n\\t\\tthis.b = b;\\r\\n\\t\\tthis.c = c;\\r\\n\\r\\n\\t\\tthis.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();\\r\\n\\t\\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\\r\\n\\r\\n\\t\\tthis.color = ( color && color.isColor ) ? color : new Color();\\r\\n\\t\\tthis.vertexColors = Array.isArray( color ) ? color : [];\\r\\n\\r\\n\\t\\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( Face3.prototype, {\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\t\\tthis.a = source.a;\\r\\n\\t\\t\\tthis.b = source.b;\\r\\n\\t\\t\\tthis.c = source.c;\\r\\n\\r\\n\\t\\t\\tthis.normal.copy( source.normal );\\r\\n\\t\\t\\tthis.color.copy( source.color );\\r\\n\\r\\n\\t\\t\\tthis.materialIndex = source.materialIndex;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author kile / http://kile.stravaganza.org/\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t * @author mikael emtinger / http://gomo.se/\\r\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\r\\n\\t * @author bhouston / http://clara.io\\r\\n\\t */\\r\\n\\r\\n\\tvar geometryId = 0; // Geometry uses even numbers as Id\\r\\n\\r\\n\\tfunction Geometry() {\\r\\n\\r\\n\\t\\tObject.defineProperty( this, 'id', { value: geometryId += 2 } );\\r\\n\\r\\n\\t\\tthis.uuid = _Math.generateUUID();\\r\\n\\r\\n\\t\\tthis.name = '';\\r\\n\\t\\tthis.type = 'Geometry';\\r\\n\\r\\n\\t\\tthis.vertices = [];\\r\\n\\t\\tthis.colors = [];\\r\\n\\t\\tthis.faces = [];\\r\\n\\t\\tthis.faceVertexUvs = [[]];\\r\\n\\r\\n\\t\\tthis.morphTargets = [];\\r\\n\\t\\tthis.morphNormals = [];\\r\\n\\r\\n\\t\\tthis.skinWeights = [];\\r\\n\\t\\tthis.skinIndices = [];\\r\\n\\r\\n\\t\\tthis.lineDistances = [];\\r\\n\\r\\n\\t\\tthis.boundingBox = null;\\r\\n\\t\\tthis.boundingSphere = null;\\r\\n\\r\\n\\t\\t// update flags\\r\\n\\r\\n\\t\\tthis.elementsNeedUpdate = false;\\r\\n\\t\\tthis.verticesNeedUpdate = false;\\r\\n\\t\\tthis.uvsNeedUpdate = false;\\r\\n\\t\\tthis.normalsNeedUpdate = false;\\r\\n\\t\\tthis.colorsNeedUpdate = false;\\r\\n\\t\\tthis.lineDistancesNeedUpdate = false;\\r\\n\\t\\tthis.groupsNeedUpdate = false;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: Geometry,\\r\\n\\r\\n\\t\\tisGeometry: true,\\r\\n\\r\\n\\t\\tapplyMatrix: function ( matrix ) {\\r\\n\\r\\n\\t\\t\\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar vertex = this.vertices[ i ];\\r\\n\\t\\t\\t\\tvertex.applyMatrix4( matrix );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar face = this.faces[ i ];\\r\\n\\t\\t\\t\\tface.normal.applyMatrix3( normalMatrix ).normalize();\\r\\n\\r\\n\\t\\t\\t\\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( this.boundingBox !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.computeBoundingBox();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( this.boundingSphere !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.computeBoundingSphere();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.verticesNeedUpdate = true;\\r\\n\\t\\t\\tthis.normalsNeedUpdate = true;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\trotateX: function () {\\r\\n\\r\\n\\t\\t\\t// rotate geometry around world x-axis\\r\\n\\r\\n\\t\\t\\tvar m1 = new Matrix4();\\r\\n\\r\\n\\t\\t\\treturn function rotateX( angle ) {\\r\\n\\r\\n\\t\\t\\t\\tm1.makeRotationX( angle );\\r\\n\\r\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\trotateY: function () {\\r\\n\\r\\n\\t\\t\\t// rotate geometry around world y-axis\\r\\n\\r\\n\\t\\t\\tvar m1 = new Matrix4();\\r\\n\\r\\n\\t\\t\\treturn function rotateY( angle ) {\\r\\n\\r\\n\\t\\t\\t\\tm1.makeRotationY( angle );\\r\\n\\r\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\trotateZ: function () {\\r\\n\\r\\n\\t\\t\\t// rotate geometry around world z-axis\\r\\n\\r\\n\\t\\t\\tvar m1 = new Matrix4();\\r\\n\\r\\n\\t\\t\\treturn function rotateZ( angle ) {\\r\\n\\r\\n\\t\\t\\t\\tm1.makeRotationZ( angle );\\r\\n\\r\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\ttranslate: function () {\\r\\n\\r\\n\\t\\t\\t// translate geometry\\r\\n\\r\\n\\t\\t\\tvar m1 = new Matrix4();\\r\\n\\r\\n\\t\\t\\treturn function translate( x, y, z ) {\\r\\n\\r\\n\\t\\t\\t\\tm1.makeTranslation( x, y, z );\\r\\n\\r\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tscale: function () {\\r\\n\\r\\n\\t\\t\\t// scale geometry\\r\\n\\r\\n\\t\\t\\tvar m1 = new Matrix4();\\r\\n\\r\\n\\t\\t\\treturn function scale( x, y, z ) {\\r\\n\\r\\n\\t\\t\\t\\tm1.makeScale( x, y, z );\\r\\n\\r\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tlookAt: function () {\\r\\n\\r\\n\\t\\t\\tvar obj = new Object3D();\\r\\n\\r\\n\\t\\t\\treturn function lookAt( vector ) {\\r\\n\\r\\n\\t\\t\\t\\tobj.lookAt( vector );\\r\\n\\r\\n\\t\\t\\t\\tobj.updateMatrix();\\r\\n\\r\\n\\t\\t\\t\\tthis.applyMatrix( obj.matrix );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tfromBufferGeometry: function ( geometry ) {\\r\\n\\r\\n\\t\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\t\\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\\r\\n\\t\\t\\tvar attributes = geometry.attributes;\\r\\n\\r\\n\\t\\t\\tvar positions = attributes.position.array;\\r\\n\\t\\t\\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\\r\\n\\t\\t\\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\\r\\n\\t\\t\\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\\r\\n\\t\\t\\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\\r\\n\\r\\n\\t\\t\\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\\r\\n\\r\\n\\t\\t\\tvar tempNormals = [];\\r\\n\\t\\t\\tvar tempUVs = [];\\r\\n\\t\\t\\tvar tempUVs2 = [];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\\r\\n\\r\\n\\t\\t\\t\\tscope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\\r\\n\\r\\n\\t\\t\\t\\tif ( normals !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\ttempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( colors !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tscope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( uvs !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\ttempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( uvs2 !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\ttempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfunction addFace( a, b, c, materialIndex ) {\\r\\n\\r\\n\\t\\t\\t\\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\\r\\n\\t\\t\\t\\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\\r\\n\\r\\n\\t\\t\\t\\tvar face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\\r\\n\\r\\n\\t\\t\\t\\tscope.faces.push( face );\\r\\n\\r\\n\\t\\t\\t\\tif ( uvs !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( uvs2 !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tscope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar groups = geometry.groups;\\r\\n\\r\\n\\t\\t\\tif ( groups.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0; i < groups.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar group = groups[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\tvar start = group.start;\\r\\n\\t\\t\\t\\t\\tvar count = group.count;\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( indices !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\taddFace( j, j + 1, j + 2, group.materialIndex );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tif ( indices !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < indices.length; i += 3 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\taddFace( i, i + 1, i + 2 );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.computeFaceNormals();\\r\\n\\r\\n\\t\\t\\tif ( geometry.boundingBox !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.boundingBox = geometry.boundingBox.clone();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( geometry.boundingSphere !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.boundingSphere = geometry.boundingSphere.clone();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcenter: function () {\\r\\n\\r\\n\\t\\t\\tthis.computeBoundingBox();\\r\\n\\r\\n\\t\\t\\tvar offset = this.boundingBox.getCenter().negate();\\r\\n\\r\\n\\t\\t\\tthis.translate( offset.x, offset.y, offset.z );\\r\\n\\r\\n\\t\\t\\treturn offset;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tnormalize: function () {\\r\\n\\r\\n\\t\\t\\tthis.computeBoundingSphere();\\r\\n\\r\\n\\t\\t\\tvar center = this.boundingSphere.center;\\r\\n\\t\\t\\tvar radius = this.boundingSphere.radius;\\r\\n\\r\\n\\t\\t\\tvar s = radius === 0 ? 1 : 1.0 / radius;\\r\\n\\r\\n\\t\\t\\tvar matrix = new Matrix4();\\r\\n\\t\\t\\tmatrix.set(\\r\\n\\t\\t\\t\\ts, 0, 0, - s * center.x,\\r\\n\\t\\t\\t\\t0, s, 0, - s * center.y,\\r\\n\\t\\t\\t\\t0, 0, s, - s * center.z,\\r\\n\\t\\t\\t\\t0, 0, 0, 1\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\tthis.applyMatrix( matrix );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcomputeFaceNormals: function () {\\r\\n\\r\\n\\t\\t\\tvar cb = new Vector3(), ab = new Vector3();\\r\\n\\r\\n\\t\\t\\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar face = this.faces[ f ];\\r\\n\\r\\n\\t\\t\\t\\tvar vA = this.vertices[ face.a ];\\r\\n\\t\\t\\t\\tvar vB = this.vertices[ face.b ];\\r\\n\\t\\t\\t\\tvar vC = this.vertices[ face.c ];\\r\\n\\r\\n\\t\\t\\t\\tcb.subVectors( vC, vB );\\r\\n\\t\\t\\t\\tab.subVectors( vA, vB );\\r\\n\\t\\t\\t\\tcb.cross( ab );\\r\\n\\r\\n\\t\\t\\t\\tcb.normalize();\\r\\n\\r\\n\\t\\t\\t\\tface.normal.copy( cb );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcomputeVertexNormals: function ( areaWeighted ) {\\r\\n\\r\\n\\t\\t\\tif ( areaWeighted === undefined ) areaWeighted = true;\\r\\n\\r\\n\\t\\t\\tvar v, vl, f, fl, face, vertices;\\r\\n\\r\\n\\t\\t\\tvertices = new Array( this.vertices.length );\\r\\n\\r\\n\\t\\t\\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvertices[ v ] = new Vector3();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( areaWeighted ) {\\r\\n\\r\\n\\t\\t\\t\\t// vertex normals weighted by triangle areas\\r\\n\\t\\t\\t\\t// http://www.iquilezles.org/www/articles/normals/normals.htm\\r\\n\\r\\n\\t\\t\\t\\tvar vA, vB, vC;\\r\\n\\t\\t\\t\\tvar cb = new Vector3(), ab = new Vector3();\\r\\n\\r\\n\\t\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tface = this.faces[ f ];\\r\\n\\r\\n\\t\\t\\t\\t\\tvA = this.vertices[ face.a ];\\r\\n\\t\\t\\t\\t\\tvB = this.vertices[ face.b ];\\r\\n\\t\\t\\t\\t\\tvC = this.vertices[ face.c ];\\r\\n\\r\\n\\t\\t\\t\\t\\tcb.subVectors( vC, vB );\\r\\n\\t\\t\\t\\t\\tab.subVectors( vA, vB );\\r\\n\\t\\t\\t\\t\\tcb.cross( ab );\\r\\n\\r\\n\\t\\t\\t\\t\\tvertices[ face.a ].add( cb );\\r\\n\\t\\t\\t\\t\\tvertices[ face.b ].add( cb );\\r\\n\\t\\t\\t\\t\\tvertices[ face.c ].add( cb );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tthis.computeFaceNormals();\\r\\n\\r\\n\\t\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tface = this.faces[ f ];\\r\\n\\r\\n\\t\\t\\t\\t\\tvertices[ face.a ].add( face.normal );\\r\\n\\t\\t\\t\\t\\tvertices[ face.b ].add( face.normal );\\r\\n\\t\\t\\t\\t\\tvertices[ face.c ].add( face.normal );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvertices[ v ].normalize();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tface = this.faces[ f ];\\r\\n\\r\\n\\t\\t\\t\\tvar vertexNormals = face.vertexNormals;\\r\\n\\r\\n\\t\\t\\t\\tif ( vertexNormals.length === 3 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\\r\\n\\t\\t\\t\\t\\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\\r\\n\\t\\t\\t\\t\\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\\r\\n\\t\\t\\t\\t\\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\\r\\n\\t\\t\\t\\t\\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( this.faces.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.normalsNeedUpdate = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcomputeFlatVertexNormals: function () {\\r\\n\\r\\n\\t\\t\\tvar f, fl, face;\\r\\n\\r\\n\\t\\t\\tthis.computeFaceNormals();\\r\\n\\r\\n\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tface = this.faces[ f ];\\r\\n\\r\\n\\t\\t\\t\\tvar vertexNormals = face.vertexNormals;\\r\\n\\r\\n\\t\\t\\t\\tif ( vertexNormals.length === 3 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvertexNormals[ 0 ].copy( face.normal );\\r\\n\\t\\t\\t\\t\\tvertexNormals[ 1 ].copy( face.normal );\\r\\n\\t\\t\\t\\t\\tvertexNormals[ 2 ].copy( face.normal );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tvertexNormals[ 0 ] = face.normal.clone();\\r\\n\\t\\t\\t\\t\\tvertexNormals[ 1 ] = face.normal.clone();\\r\\n\\t\\t\\t\\t\\tvertexNormals[ 2 ] = face.normal.clone();\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( this.faces.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.normalsNeedUpdate = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcomputeMorphNormals: function () {\\r\\n\\r\\n\\t\\t\\tvar i, il, f, fl, face;\\r\\n\\r\\n\\t\\t\\t// save original normals\\r\\n\\t\\t\\t// - create temp variables on first access\\r\\n\\t\\t\\t//   otherwise just copy (for faster repeated calls)\\r\\n\\r\\n\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tface = this.faces[ f ];\\r\\n\\r\\n\\t\\t\\t\\tif ( ! face.__originalFaceNormal ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tface.__originalFaceNormal = face.normal.clone();\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tface.__originalFaceNormal.copy( face.normal );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\\r\\n\\r\\n\\t\\t\\t\\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( ! face.__originalVertexNormals[ i ] ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// use temp geometry to compute face and vertex normals for each morph\\r\\n\\r\\n\\t\\t\\tvar tmpGeo = new Geometry();\\r\\n\\t\\t\\ttmpGeo.faces = this.faces;\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t// create on first access\\r\\n\\r\\n\\t\\t\\t\\tif ( ! this.morphNormals[ i ] ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.morphNormals[ i ] = {};\\r\\n\\t\\t\\t\\t\\tthis.morphNormals[ i ].faceNormals = [];\\r\\n\\t\\t\\t\\t\\tthis.morphNormals[ i ].vertexNormals = [];\\r\\n\\r\\n\\t\\t\\t\\t\\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\\r\\n\\t\\t\\t\\t\\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\\r\\n\\r\\n\\t\\t\\t\\t\\tvar faceNormal, vertexNormals;\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfaceNormal = new Vector3();\\r\\n\\t\\t\\t\\t\\t\\tvertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tdstNormalsFace.push( faceNormal );\\r\\n\\t\\t\\t\\t\\t\\tdstNormalsVertex.push( vertexNormals );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tvar morphNormals = this.morphNormals[ i ];\\r\\n\\r\\n\\t\\t\\t\\t// set vertices to morph target\\r\\n\\r\\n\\t\\t\\t\\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\\r\\n\\r\\n\\t\\t\\t\\t// compute morph normals\\r\\n\\r\\n\\t\\t\\t\\ttmpGeo.computeFaceNormals();\\r\\n\\t\\t\\t\\ttmpGeo.computeVertexNormals();\\r\\n\\r\\n\\t\\t\\t\\t// store morph normals\\r\\n\\r\\n\\t\\t\\t\\tvar faceNormal, vertexNormals;\\r\\n\\r\\n\\t\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tface = this.faces[ f ];\\r\\n\\r\\n\\t\\t\\t\\t\\tfaceNormal = morphNormals.faceNormals[ f ];\\r\\n\\t\\t\\t\\t\\tvertexNormals = morphNormals.vertexNormals[ f ];\\r\\n\\r\\n\\t\\t\\t\\t\\tfaceNormal.copy( face.normal );\\r\\n\\r\\n\\t\\t\\t\\t\\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\\r\\n\\t\\t\\t\\t\\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\\r\\n\\t\\t\\t\\t\\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// restore original normals\\r\\n\\r\\n\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tface = this.faces[ f ];\\r\\n\\r\\n\\t\\t\\t\\tface.normal = face.__originalFaceNormal;\\r\\n\\t\\t\\t\\tface.vertexNormals = face.__originalVertexNormals;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcomputeLineDistances: function () {\\r\\n\\r\\n\\t\\t\\tvar d = 0;\\r\\n\\t\\t\\tvar vertices = this.vertices;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( i > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tthis.lineDistances[ i ] = d;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcomputeBoundingBox: function () {\\r\\n\\r\\n\\t\\t\\tif ( this.boundingBox === null ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.boundingBox = new Box3();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.boundingBox.setFromPoints( this.vertices );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcomputeBoundingSphere: function () {\\r\\n\\r\\n\\t\\t\\tif ( this.boundingSphere === null ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.boundingSphere = new Sphere();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.boundingSphere.setFromPoints( this.vertices );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmerge: function ( geometry, matrix, materialIndexOffset ) {\\r\\n\\r\\n\\t\\t\\tif ( ! ( geometry && geometry.isGeometry ) ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\\r\\n\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar normalMatrix,\\r\\n\\t\\t\\t\\tvertexOffset = this.vertices.length,\\r\\n\\t\\t\\t\\tvertices1 = this.vertices,\\r\\n\\t\\t\\t\\tvertices2 = geometry.vertices,\\r\\n\\t\\t\\t\\tfaces1 = this.faces,\\r\\n\\t\\t\\t\\tfaces2 = geometry.faces,\\r\\n\\t\\t\\t\\tuvs1 = this.faceVertexUvs[ 0 ],\\r\\n\\t\\t\\t\\tuvs2 = geometry.faceVertexUvs[ 0 ],\\r\\n\\t\\t\\t\\tcolors1 = this.colors,\\r\\n\\t\\t\\t\\tcolors2 = geometry.colors;\\r\\n\\r\\n\\t\\t\\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\\r\\n\\r\\n\\t\\t\\tif ( matrix !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tnormalMatrix = new Matrix3().getNormalMatrix( matrix );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// vertices\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar vertex = vertices2[ i ];\\r\\n\\r\\n\\t\\t\\t\\tvar vertexCopy = vertex.clone();\\r\\n\\r\\n\\t\\t\\t\\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\\r\\n\\r\\n\\t\\t\\t\\tvertices1.push( vertexCopy );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// colors\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, il = colors2.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tcolors1.push( colors2[ i ].clone() );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// faces\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar face = faces2[ i ], faceCopy, normal, color,\\r\\n\\t\\t\\t\\t\\tfaceVertexNormals = face.vertexNormals,\\r\\n\\t\\t\\t\\t\\tfaceVertexColors = face.vertexColors;\\r\\n\\r\\n\\t\\t\\t\\tfaceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\\r\\n\\t\\t\\t\\tfaceCopy.normal.copy( face.normal );\\r\\n\\r\\n\\t\\t\\t\\tif ( normalMatrix !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tnormal = faceVertexNormals[ j ].clone();\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( normalMatrix !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tnormal.applyMatrix3( normalMatrix ).normalize();\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tfaceCopy.vertexNormals.push( normal );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tfaceCopy.color.copy( face.color );\\r\\n\\r\\n\\t\\t\\t\\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcolor = faceVertexColors[ j ];\\r\\n\\t\\t\\t\\t\\tfaceCopy.vertexColors.push( color.clone() );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\\r\\n\\r\\n\\t\\t\\t\\tfaces1.push( faceCopy );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// uvs\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar uv = uvs2[ i ], uvCopy = [];\\r\\n\\r\\n\\t\\t\\t\\tif ( uv === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcontinue;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tuvCopy.push( uv[ j ].clone() );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tuvs1.push( uvCopy );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmergeMesh: function ( mesh ) {\\r\\n\\r\\n\\t\\t\\tif ( ! ( mesh && mesh.isMesh ) ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\\r\\n\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tmesh.matrixAutoUpdate && mesh.updateMatrix();\\r\\n\\r\\n\\t\\t\\tthis.merge( mesh.geometry, mesh.matrix );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t/*\\r\\n\\t\\t * Checks for duplicate vertices with hashmap.\\r\\n\\t\\t * Duplicated vertices are removed\\r\\n\\t\\t * and faces' vertices are updated.\\r\\n\\t\\t */\\r\\n\\r\\n\\t\\tmergeVertices: function () {\\r\\n\\r\\n\\t\\t\\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\\r\\n\\t\\t\\tvar unique = [], changes = [];\\r\\n\\r\\n\\t\\t\\tvar v, key;\\r\\n\\t\\t\\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\\r\\n\\t\\t\\tvar precision = Math.pow( 10, precisionPoints );\\r\\n\\t\\t\\tvar i, il, face;\\r\\n\\t\\t\\tvar indices, j, jl;\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tv = this.vertices[ i ];\\r\\n\\t\\t\\t\\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\\r\\n\\r\\n\\t\\t\\t\\tif ( verticesMap[ key ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tverticesMap[ key ] = i;\\r\\n\\t\\t\\t\\t\\tunique.push( this.vertices[ i ] );\\r\\n\\t\\t\\t\\t\\tchanges[ i ] = unique.length - 1;\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\\r\\n\\t\\t\\t\\t\\tchanges[ i ] = changes[ verticesMap[ key ] ];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\t\\t// if faces are completely degenerate after merging vertices, we\\r\\n\\t\\t\\t// have to remove them from the geometry.\\r\\n\\t\\t\\tvar faceIndicesToRemove = [];\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tface = this.faces[ i ];\\r\\n\\r\\n\\t\\t\\t\\tface.a = changes[ face.a ];\\r\\n\\t\\t\\t\\tface.b = changes[ face.b ];\\r\\n\\t\\t\\t\\tface.c = changes[ face.c ];\\r\\n\\r\\n\\t\\t\\t\\tindices = [ face.a, face.b, face.c ];\\r\\n\\r\\n\\t\\t\\t\\t// if any duplicate vertices are found in a Face3\\r\\n\\t\\t\\t\\t// we have to remove the face as nothing can be saved\\r\\n\\t\\t\\t\\tfor ( var n = 0; n < 3; n ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfaceIndicesToRemove.push( i );\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\\r\\n\\r\\n\\t\\t\\t\\tvar idx = faceIndicesToRemove[ i ];\\r\\n\\r\\n\\t\\t\\t\\tthis.faces.splice( idx, 1 );\\r\\n\\r\\n\\t\\t\\t\\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.faceVertexUvs[ j ].splice( idx, 1 );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// Use unique set of vertices\\r\\n\\r\\n\\t\\t\\tvar diff = this.vertices.length - unique.length;\\r\\n\\t\\t\\tthis.vertices = unique;\\r\\n\\t\\t\\treturn diff;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFromPoints: function ( points ) {\\r\\n\\r\\n\\t\\t\\tthis.vertices = [];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar point = points[ i ];\\r\\n\\t\\t\\t\\tthis.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsortFacesByMaterialIndex: function () {\\r\\n\\r\\n\\t\\t\\tvar faces = this.faces;\\r\\n\\t\\t\\tvar length = faces.length;\\r\\n\\r\\n\\t\\t\\t// tag faces\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tfaces[ i ]._id = i;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// sort faces\\r\\n\\r\\n\\t\\t\\tfunction materialIndexSort( a, b ) {\\r\\n\\r\\n\\t\\t\\t\\treturn a.materialIndex - b.materialIndex;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfaces.sort( materialIndexSort );\\r\\n\\r\\n\\t\\t\\t// sort uvs\\r\\n\\r\\n\\t\\t\\tvar uvs1 = this.faceVertexUvs[ 0 ];\\r\\n\\t\\t\\tvar uvs2 = this.faceVertexUvs[ 1 ];\\r\\n\\r\\n\\t\\t\\tvar newUvs1, newUvs2;\\r\\n\\r\\n\\t\\t\\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\\r\\n\\t\\t\\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar id = faces[ i ]._id;\\r\\n\\r\\n\\t\\t\\t\\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\\r\\n\\t\\t\\t\\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\\r\\n\\t\\t\\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttoJSON: function () {\\r\\n\\r\\n\\t\\t\\tvar data = {\\r\\n\\t\\t\\t\\tmetadata: {\\r\\n\\t\\t\\t\\t\\tversion: 4.5,\\r\\n\\t\\t\\t\\t\\ttype: 'Geometry',\\r\\n\\t\\t\\t\\t\\tgenerator: 'Geometry.toJSON'\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t// standard Geometry serialization\\r\\n\\r\\n\\t\\t\\tdata.uuid = this.uuid;\\r\\n\\t\\t\\tdata.type = this.type;\\r\\n\\t\\t\\tif ( this.name !== '' ) data.name = this.name;\\r\\n\\r\\n\\t\\t\\tif ( this.parameters !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tvar parameters = this.parameters;\\r\\n\\r\\n\\t\\t\\t\\tfor ( var key in parameters ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn data;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar vertices = [];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar vertex = this.vertices[ i ];\\r\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar faces = [];\\r\\n\\t\\t\\tvar normals = [];\\r\\n\\t\\t\\tvar normalsHash = {};\\r\\n\\t\\t\\tvar colors = [];\\r\\n\\t\\t\\tvar colorsHash = {};\\r\\n\\t\\t\\tvar uvs = [];\\r\\n\\t\\t\\tvar uvsHash = {};\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < this.faces.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar face = this.faces[ i ];\\r\\n\\r\\n\\t\\t\\t\\tvar hasMaterial = true;\\r\\n\\t\\t\\t\\tvar hasFaceUv = false; // deprecated\\r\\n\\t\\t\\t\\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\\r\\n\\t\\t\\t\\tvar hasFaceNormal = face.normal.length() > 0;\\r\\n\\t\\t\\t\\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\\r\\n\\t\\t\\t\\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\\r\\n\\t\\t\\t\\tvar hasFaceVertexColor = face.vertexColors.length > 0;\\r\\n\\r\\n\\t\\t\\t\\tvar faceType = 0;\\r\\n\\r\\n\\t\\t\\t\\tfaceType = setBit( faceType, 0, 0 ); // isQuad\\r\\n\\t\\t\\t\\tfaceType = setBit( faceType, 1, hasMaterial );\\r\\n\\t\\t\\t\\tfaceType = setBit( faceType, 2, hasFaceUv );\\r\\n\\t\\t\\t\\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\\r\\n\\t\\t\\t\\tfaceType = setBit( faceType, 4, hasFaceNormal );\\r\\n\\t\\t\\t\\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\\r\\n\\t\\t\\t\\tfaceType = setBit( faceType, 6, hasFaceColor );\\r\\n\\t\\t\\t\\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\\r\\n\\r\\n\\t\\t\\t\\tfaces.push( faceType );\\r\\n\\t\\t\\t\\tfaces.push( face.a, face.b, face.c );\\r\\n\\t\\t\\t\\tfaces.push( face.materialIndex );\\r\\n\\r\\n\\t\\t\\t\\tif ( hasFaceVertexUv ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\tfaces.push(\\r\\n\\t\\t\\t\\t\\t\\tgetUvIndex( faceVertexUvs[ 0 ] ),\\r\\n\\t\\t\\t\\t\\t\\tgetUvIndex( faceVertexUvs[ 1 ] ),\\r\\n\\t\\t\\t\\t\\t\\tgetUvIndex( faceVertexUvs[ 2 ] )\\r\\n\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( hasFaceNormal ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tfaces.push( getNormalIndex( face.normal ) );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( hasFaceVertexNormal ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar vertexNormals = face.vertexNormals;\\r\\n\\r\\n\\t\\t\\t\\t\\tfaces.push(\\r\\n\\t\\t\\t\\t\\t\\tgetNormalIndex( vertexNormals[ 0 ] ),\\r\\n\\t\\t\\t\\t\\t\\tgetNormalIndex( vertexNormals[ 1 ] ),\\r\\n\\t\\t\\t\\t\\t\\tgetNormalIndex( vertexNormals[ 2 ] )\\r\\n\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( hasFaceColor ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tfaces.push( getColorIndex( face.color ) );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( hasFaceVertexColor ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar vertexColors = face.vertexColors;\\r\\n\\r\\n\\t\\t\\t\\t\\tfaces.push(\\r\\n\\t\\t\\t\\t\\t\\tgetColorIndex( vertexColors[ 0 ] ),\\r\\n\\t\\t\\t\\t\\t\\tgetColorIndex( vertexColors[ 1 ] ),\\r\\n\\t\\t\\t\\t\\t\\tgetColorIndex( vertexColors[ 2 ] )\\r\\n\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfunction setBit( value, position, enabled ) {\\r\\n\\r\\n\\t\\t\\t\\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfunction getNormalIndex( normal ) {\\r\\n\\r\\n\\t\\t\\t\\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\\r\\n\\r\\n\\t\\t\\t\\tif ( normalsHash[ hash ] !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn normalsHash[ hash ];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tnormalsHash[ hash ] = normals.length / 3;\\r\\n\\t\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\r\\n\\r\\n\\t\\t\\t\\treturn normalsHash[ hash ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfunction getColorIndex( color ) {\\r\\n\\r\\n\\t\\t\\t\\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\\r\\n\\r\\n\\t\\t\\t\\tif ( colorsHash[ hash ] !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn colorsHash[ hash ];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tcolorsHash[ hash ] = colors.length;\\r\\n\\t\\t\\t\\tcolors.push( color.getHex() );\\r\\n\\r\\n\\t\\t\\t\\treturn colorsHash[ hash ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfunction getUvIndex( uv ) {\\r\\n\\r\\n\\t\\t\\t\\tvar hash = uv.x.toString() + uv.y.toString();\\r\\n\\r\\n\\t\\t\\t\\tif ( uvsHash[ hash ] !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn uvsHash[ hash ];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tuvsHash[ hash ] = uvs.length / 2;\\r\\n\\t\\t\\t\\tuvs.push( uv.x, uv.y );\\r\\n\\r\\n\\t\\t\\t\\treturn uvsHash[ hash ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tdata.data = {};\\r\\n\\r\\n\\t\\t\\tdata.data.vertices = vertices;\\r\\n\\t\\t\\tdata.data.normals = normals;\\r\\n\\t\\t\\tif ( colors.length > 0 ) data.data.colors = colors;\\r\\n\\t\\t\\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\\r\\n\\t\\t\\tdata.data.faces = faces;\\r\\n\\r\\n\\t\\t\\treturn data;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\t/*\\r\\n\\t\\t\\t // Handle primitives\\r\\n\\r\\n\\t\\t\\t var parameters = this.parameters;\\r\\n\\r\\n\\t\\t\\t if ( parameters !== undefined ) {\\r\\n\\r\\n\\t\\t\\t var values = [];\\r\\n\\r\\n\\t\\t\\t for ( var key in parameters ) {\\r\\n\\r\\n\\t\\t\\t values.push( parameters[ key ] );\\r\\n\\r\\n\\t\\t\\t }\\r\\n\\r\\n\\t\\t\\t var geometry = Object.create( this.constructor.prototype );\\r\\n\\t\\t\\t this.constructor.apply( geometry, values );\\r\\n\\t\\t\\t return geometry;\\r\\n\\r\\n\\t\\t\\t }\\r\\n\\r\\n\\t\\t\\t return new this.constructor().copy( this );\\r\\n\\t\\t\\t */\\r\\n\\r\\n\\t\\t\\treturn new Geometry().copy( this );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\t\\tvar i, il, j, jl, k, kl;\\r\\n\\r\\n\\t\\t\\t// reset\\r\\n\\r\\n\\t\\t\\tthis.vertices = [];\\r\\n\\t\\t\\tthis.colors = [];\\r\\n\\t\\t\\tthis.faces = [];\\r\\n\\t\\t\\tthis.faceVertexUvs = [[]];\\r\\n\\t\\t\\tthis.morphTargets = [];\\r\\n\\t\\t\\tthis.morphNormals = [];\\r\\n\\t\\t\\tthis.skinWeights = [];\\r\\n\\t\\t\\tthis.skinIndices = [];\\r\\n\\t\\t\\tthis.lineDistances = [];\\r\\n\\t\\t\\tthis.boundingBox = null;\\r\\n\\t\\t\\tthis.boundingSphere = null;\\r\\n\\r\\n\\t\\t\\t// name\\r\\n\\r\\n\\t\\t\\tthis.name = source.name;\\r\\n\\r\\n\\t\\t\\t// vertices\\r\\n\\r\\n\\t\\t\\tvar vertices = source.vertices;\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.vertices.push( vertices[ i ].clone() );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// colors\\r\\n\\r\\n\\t\\t\\tvar colors = source.colors;\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, il = colors.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.colors.push( colors[ i ].clone() );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// faces\\r\\n\\r\\n\\t\\t\\tvar faces = source.faces;\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, il = faces.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.faces.push( faces[ i ].clone() );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// face vertex uvs\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar faceVertexUvs = source.faceVertexUvs[ i ];\\r\\n\\r\\n\\t\\t\\t\\tif ( this.faceVertexUvs[ i ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.faceVertexUvs[ i ] = [];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tfor ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( k = 0, kl = uvs.length; k < kl; k ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar uv = uvs[ k ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tuvsCopy.push( uv.clone() );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.faceVertexUvs[ i ].push( uvsCopy );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// morph targets\\r\\n\\r\\n\\t\\t\\tvar morphTargets = source.morphTargets;\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, il = morphTargets.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar morphTarget = {};\\r\\n\\t\\t\\t\\tmorphTarget.name = morphTargets[ i ].name;\\r\\n\\r\\n\\t\\t\\t\\t// vertices\\r\\n\\r\\n\\t\\t\\t\\tif ( morphTargets[ i ].vertices !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tmorphTarget.vertices = [];\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tmorphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// normals\\r\\n\\r\\n\\t\\t\\t\\tif ( morphTargets[ i ].normals !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tmorphTarget.normals = [];\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tmorphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tthis.morphTargets.push( morphTarget );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// morph normals\\r\\n\\r\\n\\t\\t\\tvar morphNormals = source.morphNormals;\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, il = morphNormals.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar morphNormal = {};\\r\\n\\r\\n\\t\\t\\t\\t// vertex normals\\r\\n\\r\\n\\t\\t\\t\\tif ( morphNormals[ i ].vertexNormals !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tmorphNormal.vertexNormals = [];\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];\\r\\n\\t\\t\\t\\t\\t\\tvar destVertexNormal = {};\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tdestVertexNormal.a = srcVertexNormal.a.clone();\\r\\n\\t\\t\\t\\t\\t\\tdestVertexNormal.b = srcVertexNormal.b.clone();\\r\\n\\t\\t\\t\\t\\t\\tdestVertexNormal.c = srcVertexNormal.c.clone();\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tmorphNormal.vertexNormals.push( destVertexNormal );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// face normals\\r\\n\\r\\n\\t\\t\\t\\tif ( morphNormals[ i ].faceNormals !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tmorphNormal.faceNormals = [];\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tmorphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tthis.morphNormals.push( morphNormal );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// skin weights\\r\\n\\r\\n\\t\\t\\tvar skinWeights = source.skinWeights;\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, il = skinWeights.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.skinWeights.push( skinWeights[ i ].clone() );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// skin indices\\r\\n\\r\\n\\t\\t\\tvar skinIndices = source.skinIndices;\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, il = skinIndices.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.skinIndices.push( skinIndices[ i ].clone() );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// line distances\\r\\n\\r\\n\\t\\t\\tvar lineDistances = source.lineDistances;\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, il = lineDistances.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.lineDistances.push( lineDistances[ i ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// bounding box\\r\\n\\r\\n\\t\\t\\tvar boundingBox = source.boundingBox;\\r\\n\\r\\n\\t\\t\\tif ( boundingBox !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.boundingBox = boundingBox.clone();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// bounding sphere\\r\\n\\r\\n\\t\\t\\tvar boundingSphere = source.boundingSphere;\\r\\n\\r\\n\\t\\t\\tif ( boundingSphere !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.boundingSphere = boundingSphere.clone();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// update flags\\r\\n\\r\\n\\t\\t\\tthis.elementsNeedUpdate = source.elementsNeedUpdate;\\r\\n\\t\\t\\tthis.verticesNeedUpdate = source.verticesNeedUpdate;\\r\\n\\t\\t\\tthis.uvsNeedUpdate = source.uvsNeedUpdate;\\r\\n\\t\\t\\tthis.normalsNeedUpdate = source.normalsNeedUpdate;\\r\\n\\t\\t\\tthis.colorsNeedUpdate = source.colorsNeedUpdate;\\r\\n\\t\\t\\tthis.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\\r\\n\\t\\t\\tthis.groupsNeedUpdate = source.groupsNeedUpdate;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdispose: function () {\\r\\n\\r\\n\\t\\t\\tthis.dispatchEvent( { type: 'dispose' } );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction BufferAttribute( array, itemSize, normalized ) {\\r\\n\\r\\n\\t\\tif ( Array.isArray( array ) ) {\\r\\n\\r\\n\\t\\t\\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.uuid = _Math.generateUUID();\\r\\n\\t\\tthis.name = '';\\r\\n\\r\\n\\t\\tthis.array = array;\\r\\n\\t\\tthis.itemSize = itemSize;\\r\\n\\t\\tthis.count = array !== undefined ? array.length / itemSize : 0;\\r\\n\\t\\tthis.normalized = normalized === true;\\r\\n\\r\\n\\t\\tthis.dynamic = false;\\r\\n\\t\\tthis.updateRange = { offset: 0, count: - 1 };\\r\\n\\r\\n\\t\\tthis.onUploadCallback = function () {};\\r\\n\\r\\n\\t\\tthis.version = 0;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.defineProperty( BufferAttribute.prototype, 'needsUpdate', {\\r\\n\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tif ( value === true ) this.version ++;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tObject.assign( BufferAttribute.prototype, {\\r\\n\\r\\n\\t\\tisBufferAttribute: true,\\r\\n\\r\\n\\t\\tsetArray: function ( array ) {\\r\\n\\r\\n\\t\\t\\tif ( Array.isArray( array ) ) {\\r\\n\\r\\n\\t\\t\\t\\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.count = array !== undefined ? array.length / this.itemSize : 0;\\r\\n\\t\\t\\tthis.array = array;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetDynamic: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.dynamic = value;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\t\\tthis.array = new source.array.constructor( source.array );\\r\\n\\t\\t\\tthis.itemSize = source.itemSize;\\r\\n\\t\\t\\tthis.count = source.count;\\r\\n\\t\\t\\tthis.normalized = source.normalized;\\r\\n\\r\\n\\t\\t\\tthis.dynamic = source.dynamic;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopyAt: function ( index1, attribute, index2 ) {\\r\\n\\r\\n\\t\\t\\tindex1 *= this.itemSize;\\r\\n\\t\\t\\tindex2 *= attribute.itemSize;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopyArray: function ( array ) {\\r\\n\\r\\n\\t\\t\\tthis.array.set( array );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopyColorsArray: function ( colors ) {\\r\\n\\r\\n\\t\\t\\tvar array = this.array, offset = 0;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar color = colors[ i ];\\r\\n\\r\\n\\t\\t\\t\\tif ( color === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\\r\\n\\t\\t\\t\\t\\tcolor = new Color();\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tarray[ offset ++ ] = color.r;\\r\\n\\t\\t\\t\\tarray[ offset ++ ] = color.g;\\r\\n\\t\\t\\t\\tarray[ offset ++ ] = color.b;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopyIndicesArray: function ( indices ) {\\r\\n\\r\\n\\t\\t\\tvar array = this.array, offset = 0;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar index = indices[ i ];\\r\\n\\r\\n\\t\\t\\t\\tarray[ offset ++ ] = index.a;\\r\\n\\t\\t\\t\\tarray[ offset ++ ] = index.b;\\r\\n\\t\\t\\t\\tarray[ offset ++ ] = index.c;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopyVector2sArray: function ( vectors ) {\\r\\n\\r\\n\\t\\t\\tvar array = this.array, offset = 0;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar vector = vectors[ i ];\\r\\n\\r\\n\\t\\t\\t\\tif ( vector === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\\r\\n\\t\\t\\t\\t\\tvector = new Vector2();\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.x;\\r\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.y;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopyVector3sArray: function ( vectors ) {\\r\\n\\r\\n\\t\\t\\tvar array = this.array, offset = 0;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar vector = vectors[ i ];\\r\\n\\r\\n\\t\\t\\t\\tif ( vector === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\\r\\n\\t\\t\\t\\t\\tvector = new Vector3();\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.x;\\r\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.y;\\r\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.z;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopyVector4sArray: function ( vectors ) {\\r\\n\\r\\n\\t\\t\\tvar array = this.array, offset = 0;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar vector = vectors[ i ];\\r\\n\\r\\n\\t\\t\\t\\tif ( vector === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\\r\\n\\t\\t\\t\\t\\tvector = new Vector4();\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.x;\\r\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.y;\\r\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.z;\\r\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.w;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tset: function ( value, offset ) {\\r\\n\\r\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\t\\tthis.array.set( value, offset );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetX: function ( index ) {\\r\\n\\r\\n\\t\\t\\treturn this.array[ index * this.itemSize ];\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetX: function ( index, x ) {\\r\\n\\r\\n\\t\\t\\tthis.array[ index * this.itemSize ] = x;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetY: function ( index ) {\\r\\n\\r\\n\\t\\t\\treturn this.array[ index * this.itemSize + 1 ];\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetY: function ( index, y ) {\\r\\n\\r\\n\\t\\t\\tthis.array[ index * this.itemSize + 1 ] = y;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetZ: function ( index ) {\\r\\n\\r\\n\\t\\t\\treturn this.array[ index * this.itemSize + 2 ];\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetZ: function ( index, z ) {\\r\\n\\r\\n\\t\\t\\tthis.array[ index * this.itemSize + 2 ] = z;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetW: function ( index ) {\\r\\n\\r\\n\\t\\t\\treturn this.array[ index * this.itemSize + 3 ];\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetW: function ( index, w ) {\\r\\n\\r\\n\\t\\t\\tthis.array[ index * this.itemSize + 3 ] = w;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetXY: function ( index, x, y ) {\\r\\n\\r\\n\\t\\t\\tindex *= this.itemSize;\\r\\n\\r\\n\\t\\t\\tthis.array[ index + 0 ] = x;\\r\\n\\t\\t\\tthis.array[ index + 1 ] = y;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetXYZ: function ( index, x, y, z ) {\\r\\n\\r\\n\\t\\t\\tindex *= this.itemSize;\\r\\n\\r\\n\\t\\t\\tthis.array[ index + 0 ] = x;\\r\\n\\t\\t\\tthis.array[ index + 1 ] = y;\\r\\n\\t\\t\\tthis.array[ index + 2 ] = z;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetXYZW: function ( index, x, y, z, w ) {\\r\\n\\r\\n\\t\\t\\tindex *= this.itemSize;\\r\\n\\r\\n\\t\\t\\tthis.array[ index + 0 ] = x;\\r\\n\\t\\t\\tthis.array[ index + 1 ] = y;\\r\\n\\t\\t\\tthis.array[ index + 2 ] = z;\\r\\n\\t\\t\\tthis.array[ index + 3 ] = w;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tonUpload: function ( callback ) {\\r\\n\\r\\n\\t\\t\\tthis.onUploadCallback = callback;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor( this.array, this.itemSize ).copy( this );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tfunction Int8BufferAttribute( array, itemSize, normalized ) {\\r\\n\\r\\n\\t\\tBufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tInt8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\r\\n\\tInt8BufferAttribute.prototype.constructor = Int8BufferAttribute;\\r\\n\\r\\n\\r\\n\\tfunction Uint8BufferAttribute( array, itemSize, normalized ) {\\r\\n\\r\\n\\t\\tBufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tUint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\r\\n\\tUint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;\\r\\n\\r\\n\\r\\n\\tfunction Uint8ClampedBufferAttribute( array, itemSize, normalized ) {\\r\\n\\r\\n\\t\\tBufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tUint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\r\\n\\tUint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;\\r\\n\\r\\n\\r\\n\\tfunction Int16BufferAttribute( array, itemSize, normalized ) {\\r\\n\\r\\n\\t\\tBufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tInt16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\r\\n\\tInt16BufferAttribute.prototype.constructor = Int16BufferAttribute;\\r\\n\\r\\n\\r\\n\\tfunction Uint16BufferAttribute( array, itemSize, normalized ) {\\r\\n\\r\\n\\t\\tBufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tUint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\r\\n\\tUint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;\\r\\n\\r\\n\\r\\n\\tfunction Int32BufferAttribute( array, itemSize, normalized ) {\\r\\n\\r\\n\\t\\tBufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tInt32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\r\\n\\tInt32BufferAttribute.prototype.constructor = Int32BufferAttribute;\\r\\n\\r\\n\\r\\n\\tfunction Uint32BufferAttribute( array, itemSize, normalized ) {\\r\\n\\r\\n\\t\\tBufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tUint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\r\\n\\tUint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;\\r\\n\\r\\n\\r\\n\\tfunction Float32BufferAttribute( array, itemSize, normalized ) {\\r\\n\\r\\n\\t\\tBufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tFloat32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\r\\n\\tFloat32BufferAttribute.prototype.constructor = Float32BufferAttribute;\\r\\n\\r\\n\\r\\n\\tfunction Float64BufferAttribute( array, itemSize, normalized ) {\\r\\n\\r\\n\\t\\tBufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tFloat64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\r\\n\\tFloat64BufferAttribute.prototype.constructor = Float64BufferAttribute;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction DirectGeometry() {\\r\\n\\r\\n\\t\\tthis.indices = [];\\r\\n\\t\\tthis.vertices = [];\\r\\n\\t\\tthis.normals = [];\\r\\n\\t\\tthis.colors = [];\\r\\n\\t\\tthis.uvs = [];\\r\\n\\t\\tthis.uvs2 = [];\\r\\n\\r\\n\\t\\tthis.groups = [];\\r\\n\\r\\n\\t\\tthis.morphTargets = {};\\r\\n\\r\\n\\t\\tthis.skinWeights = [];\\r\\n\\t\\tthis.skinIndices = [];\\r\\n\\r\\n\\t\\t// this.lineDistances = [];\\r\\n\\r\\n\\t\\tthis.boundingBox = null;\\r\\n\\t\\tthis.boundingSphere = null;\\r\\n\\r\\n\\t\\t// update flags\\r\\n\\r\\n\\t\\tthis.verticesNeedUpdate = false;\\r\\n\\t\\tthis.normalsNeedUpdate = false;\\r\\n\\t\\tthis.colorsNeedUpdate = false;\\r\\n\\t\\tthis.uvsNeedUpdate = false;\\r\\n\\t\\tthis.groupsNeedUpdate = false;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( DirectGeometry.prototype, {\\r\\n\\r\\n\\t\\tcomputeGroups: function ( geometry ) {\\r\\n\\r\\n\\t\\t\\tvar group;\\r\\n\\t\\t\\tvar groups = [];\\r\\n\\t\\t\\tvar materialIndex = undefined;\\r\\n\\r\\n\\t\\t\\tvar faces = geometry.faces;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < faces.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar face = faces[ i ];\\r\\n\\r\\n\\t\\t\\t\\t// materials\\r\\n\\r\\n\\t\\t\\t\\tif ( face.materialIndex !== materialIndex ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tmaterialIndex = face.materialIndex;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( group !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgroup.count = ( i * 3 ) - group.start;\\r\\n\\t\\t\\t\\t\\t\\tgroups.push( group );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tgroup = {\\r\\n\\t\\t\\t\\t\\t\\tstart: i * 3,\\r\\n\\t\\t\\t\\t\\t\\tmaterialIndex: materialIndex\\r\\n\\t\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( group !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tgroup.count = ( i * 3 ) - group.start;\\r\\n\\t\\t\\t\\tgroups.push( group );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.groups = groups;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tfromGeometry: function ( geometry ) {\\r\\n\\r\\n\\t\\t\\tvar faces = geometry.faces;\\r\\n\\t\\t\\tvar vertices = geometry.vertices;\\r\\n\\t\\t\\tvar faceVertexUvs = geometry.faceVertexUvs;\\r\\n\\r\\n\\t\\t\\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\\r\\n\\t\\t\\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\\r\\n\\r\\n\\t\\t\\t// morphs\\r\\n\\r\\n\\t\\t\\tvar morphTargets = geometry.morphTargets;\\r\\n\\t\\t\\tvar morphTargetsLength = morphTargets.length;\\r\\n\\r\\n\\t\\t\\tvar morphTargetsPosition;\\r\\n\\r\\n\\t\\t\\tif ( morphTargetsLength > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tmorphTargetsPosition = [];\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tmorphTargetsPosition[ i ] = [];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tthis.morphTargets.position = morphTargetsPosition;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar morphNormals = geometry.morphNormals;\\r\\n\\t\\t\\tvar morphNormalsLength = morphNormals.length;\\r\\n\\r\\n\\t\\t\\tvar morphTargetsNormal;\\r\\n\\r\\n\\t\\t\\tif ( morphNormalsLength > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tmorphTargetsNormal = [];\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tmorphTargetsNormal[ i ] = [];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tthis.morphTargets.normal = morphTargetsNormal;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// skins\\r\\n\\r\\n\\t\\t\\tvar skinIndices = geometry.skinIndices;\\r\\n\\t\\t\\tvar skinWeights = geometry.skinWeights;\\r\\n\\r\\n\\t\\t\\tvar hasSkinIndices = skinIndices.length === vertices.length;\\r\\n\\t\\t\\tvar hasSkinWeights = skinWeights.length === vertices.length;\\r\\n\\r\\n\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < faces.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar face = faces[ i ];\\r\\n\\r\\n\\t\\t\\t\\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\\r\\n\\r\\n\\t\\t\\t\\tvar vertexNormals = face.vertexNormals;\\r\\n\\r\\n\\t\\t\\t\\tif ( vertexNormals.length === 3 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar normal = face.normal;\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.normals.push( normal, normal, normal );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tvar vertexColors = face.vertexColors;\\r\\n\\r\\n\\t\\t\\t\\tif ( vertexColors.length === 3 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar color = face.color;\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.colors.push( color, color, color );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( hasFaceVertexUv === true ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( vertexUvs !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tthis.uvs.push( new Vector2(), new Vector2(), new Vector2() );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( hasFaceVertexUv2 === true ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( vertexUvs !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tthis.uvs2.push( new Vector2(), new Vector2(), new Vector2() );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// morphs\\r\\n\\r\\n\\t\\t\\t\\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar morphTarget = morphTargets[ j ].vertices;\\r\\n\\r\\n\\t\\t\\t\\t\\tmorphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\tmorphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// skins\\r\\n\\r\\n\\t\\t\\t\\tif ( hasSkinIndices ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( hasSkinWeights ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.computeGroups( geometry );\\r\\n\\r\\n\\t\\t\\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\\r\\n\\t\\t\\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\\r\\n\\t\\t\\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\\r\\n\\t\\t\\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\\r\\n\\t\\t\\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction arrayMax( array ) {\\r\\n\\r\\n\\t\\tif ( array.length === 0 ) return - Infinity;\\r\\n\\r\\n\\t\\tvar max = array[ 0 ];\\r\\n\\r\\n\\t\\tfor ( var i = 1, l = array.length; i < l; ++ i ) {\\r\\n\\r\\n\\t\\t\\tif ( array[ i ] > max ) max = array[ i ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn max;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tvar bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id\\r\\n\\r\\n\\tfunction BufferGeometry() {\\r\\n\\r\\n\\t\\tObject.defineProperty( this, 'id', { value: bufferGeometryId += 2 } );\\r\\n\\r\\n\\t\\tthis.uuid = _Math.generateUUID();\\r\\n\\r\\n\\t\\tthis.name = '';\\r\\n\\t\\tthis.type = 'BufferGeometry';\\r\\n\\r\\n\\t\\tthis.index = null;\\r\\n\\t\\tthis.attributes = {};\\r\\n\\r\\n\\t\\tthis.morphAttributes = {};\\r\\n\\r\\n\\t\\tthis.groups = [];\\r\\n\\r\\n\\t\\tthis.boundingBox = null;\\r\\n\\t\\tthis.boundingSphere = null;\\r\\n\\r\\n\\t\\tthis.drawRange = { start: 0, count: Infinity };\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: BufferGeometry,\\r\\n\\r\\n\\t\\tisBufferGeometry: true,\\r\\n\\r\\n\\t\\tgetIndex: function () {\\r\\n\\r\\n\\t\\t\\treturn this.index;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetIndex: function ( index ) {\\r\\n\\r\\n\\t\\t\\tif ( Array.isArray( index ) ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tthis.index = index;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\taddAttribute: function ( name, attribute ) {\\r\\n\\r\\n\\t\\t\\tif ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\\r\\n\\r\\n\\t\\t\\t\\tthis.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\\r\\n\\r\\n\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( name === 'index' ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\\r\\n\\t\\t\\t\\tthis.setIndex( attribute );\\r\\n\\r\\n\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.attributes[ name ] = attribute;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetAttribute: function ( name ) {\\r\\n\\r\\n\\t\\t\\treturn this.attributes[ name ];\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tremoveAttribute: function ( name ) {\\r\\n\\r\\n\\t\\t\\tdelete this.attributes[ name ];\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\taddGroup: function ( start, count, materialIndex ) {\\r\\n\\r\\n\\t\\t\\tthis.groups.push( {\\r\\n\\r\\n\\t\\t\\t\\tstart: start,\\r\\n\\t\\t\\t\\tcount: count,\\r\\n\\t\\t\\t\\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\\r\\n\\r\\n\\t\\t\\t} );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclearGroups: function () {\\r\\n\\r\\n\\t\\t\\tthis.groups = [];\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetDrawRange: function ( start, count ) {\\r\\n\\r\\n\\t\\t\\tthis.drawRange.start = start;\\r\\n\\t\\t\\tthis.drawRange.count = count;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tapplyMatrix: function ( matrix ) {\\r\\n\\r\\n\\t\\t\\tvar position = this.attributes.position;\\r\\n\\r\\n\\t\\t\\tif ( position !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tmatrix.applyToBufferAttribute( position );\\r\\n\\t\\t\\t\\tposition.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar normal = this.attributes.normal;\\r\\n\\r\\n\\t\\t\\tif ( normal !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\\r\\n\\r\\n\\t\\t\\t\\tnormalMatrix.applyToBufferAttribute( normal );\\r\\n\\t\\t\\t\\tnormal.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( this.boundingBox !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.computeBoundingBox();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( this.boundingSphere !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.computeBoundingSphere();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\trotateX: function () {\\r\\n\\r\\n\\t\\t\\t// rotate geometry around world x-axis\\r\\n\\r\\n\\t\\t\\tvar m1 = new Matrix4();\\r\\n\\r\\n\\t\\t\\treturn function rotateX( angle ) {\\r\\n\\r\\n\\t\\t\\t\\tm1.makeRotationX( angle );\\r\\n\\r\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\trotateY: function () {\\r\\n\\r\\n\\t\\t\\t// rotate geometry around world y-axis\\r\\n\\r\\n\\t\\t\\tvar m1 = new Matrix4();\\r\\n\\r\\n\\t\\t\\treturn function rotateY( angle ) {\\r\\n\\r\\n\\t\\t\\t\\tm1.makeRotationY( angle );\\r\\n\\r\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\trotateZ: function () {\\r\\n\\r\\n\\t\\t\\t// rotate geometry around world z-axis\\r\\n\\r\\n\\t\\t\\tvar m1 = new Matrix4();\\r\\n\\r\\n\\t\\t\\treturn function rotateZ( angle ) {\\r\\n\\r\\n\\t\\t\\t\\tm1.makeRotationZ( angle );\\r\\n\\r\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\ttranslate: function () {\\r\\n\\r\\n\\t\\t\\t// translate geometry\\r\\n\\r\\n\\t\\t\\tvar m1 = new Matrix4();\\r\\n\\r\\n\\t\\t\\treturn function translate( x, y, z ) {\\r\\n\\r\\n\\t\\t\\t\\tm1.makeTranslation( x, y, z );\\r\\n\\r\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tscale: function () {\\r\\n\\r\\n\\t\\t\\t// scale geometry\\r\\n\\r\\n\\t\\t\\tvar m1 = new Matrix4();\\r\\n\\r\\n\\t\\t\\treturn function scale( x, y, z ) {\\r\\n\\r\\n\\t\\t\\t\\tm1.makeScale( x, y, z );\\r\\n\\r\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tlookAt: function () {\\r\\n\\r\\n\\t\\t\\tvar obj = new Object3D();\\r\\n\\r\\n\\t\\t\\treturn function lookAt( vector ) {\\r\\n\\r\\n\\t\\t\\t\\tobj.lookAt( vector );\\r\\n\\r\\n\\t\\t\\t\\tobj.updateMatrix();\\r\\n\\r\\n\\t\\t\\t\\tthis.applyMatrix( obj.matrix );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tcenter: function () {\\r\\n\\r\\n\\t\\t\\tthis.computeBoundingBox();\\r\\n\\r\\n\\t\\t\\tvar offset = this.boundingBox.getCenter().negate();\\r\\n\\r\\n\\t\\t\\tthis.translate( offset.x, offset.y, offset.z );\\r\\n\\r\\n\\t\\t\\treturn offset;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFromObject: function ( object ) {\\r\\n\\r\\n\\t\\t\\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\\r\\n\\r\\n\\t\\t\\tvar geometry = object.geometry;\\r\\n\\r\\n\\t\\t\\tif ( object.isPoints || object.isLine ) {\\r\\n\\r\\n\\t\\t\\t\\tvar positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );\\r\\n\\t\\t\\t\\tvar colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );\\r\\n\\r\\n\\t\\t\\t\\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\\r\\n\\t\\t\\t\\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\\r\\n\\r\\n\\t\\t\\t\\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( geometry.boundingSphere !== null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.boundingSphere = geometry.boundingSphere.clone();\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( geometry.boundingBox !== null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.boundingBox = geometry.boundingBox.clone();\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else if ( object.isMesh ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( geometry && geometry.isGeometry ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.fromGeometry( geometry );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFromPoints: function ( points ) {\\r\\n\\r\\n\\t\\t\\tvar position = [];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar point = points[ i ];\\r\\n\\t\\t\\t\\tposition.push( point.x, point.y, point.z || 0 );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tupdateFromObject: function ( object ) {\\r\\n\\r\\n\\t\\t\\tvar geometry = object.geometry;\\r\\n\\r\\n\\t\\t\\tif ( object.isMesh ) {\\r\\n\\r\\n\\t\\t\\t\\tvar direct = geometry.__directGeometry;\\r\\n\\r\\n\\t\\t\\t\\tif ( geometry.elementsNeedUpdate === true ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tdirect = undefined;\\r\\n\\t\\t\\t\\t\\tgeometry.elementsNeedUpdate = false;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( direct === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn this.fromGeometry( geometry );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\\r\\n\\t\\t\\t\\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\\r\\n\\t\\t\\t\\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\\r\\n\\t\\t\\t\\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\\r\\n\\t\\t\\t\\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\\r\\n\\r\\n\\t\\t\\t\\tgeometry.verticesNeedUpdate = false;\\r\\n\\t\\t\\t\\tgeometry.normalsNeedUpdate = false;\\r\\n\\t\\t\\t\\tgeometry.colorsNeedUpdate = false;\\r\\n\\t\\t\\t\\tgeometry.uvsNeedUpdate = false;\\r\\n\\t\\t\\t\\tgeometry.groupsNeedUpdate = false;\\r\\n\\r\\n\\t\\t\\t\\tgeometry = direct;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar attribute;\\r\\n\\r\\n\\t\\t\\tif ( geometry.verticesNeedUpdate === true ) {\\r\\n\\r\\n\\t\\t\\t\\tattribute = this.attributes.position;\\r\\n\\r\\n\\t\\t\\t\\tif ( attribute !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tattribute.copyVector3sArray( geometry.vertices );\\r\\n\\t\\t\\t\\t\\tattribute.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tgeometry.verticesNeedUpdate = false;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( geometry.normalsNeedUpdate === true ) {\\r\\n\\r\\n\\t\\t\\t\\tattribute = this.attributes.normal;\\r\\n\\r\\n\\t\\t\\t\\tif ( attribute !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tattribute.copyVector3sArray( geometry.normals );\\r\\n\\t\\t\\t\\t\\tattribute.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tgeometry.normalsNeedUpdate = false;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( geometry.colorsNeedUpdate === true ) {\\r\\n\\r\\n\\t\\t\\t\\tattribute = this.attributes.color;\\r\\n\\r\\n\\t\\t\\t\\tif ( attribute !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tattribute.copyColorsArray( geometry.colors );\\r\\n\\t\\t\\t\\t\\tattribute.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tgeometry.colorsNeedUpdate = false;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( geometry.uvsNeedUpdate ) {\\r\\n\\r\\n\\t\\t\\t\\tattribute = this.attributes.uv;\\r\\n\\r\\n\\t\\t\\t\\tif ( attribute !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tattribute.copyVector2sArray( geometry.uvs );\\r\\n\\t\\t\\t\\t\\tattribute.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tgeometry.uvsNeedUpdate = false;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( geometry.lineDistancesNeedUpdate ) {\\r\\n\\r\\n\\t\\t\\t\\tattribute = this.attributes.lineDistance;\\r\\n\\r\\n\\t\\t\\t\\tif ( attribute !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tattribute.copyArray( geometry.lineDistances );\\r\\n\\t\\t\\t\\t\\tattribute.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tgeometry.lineDistancesNeedUpdate = false;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( geometry.groupsNeedUpdate ) {\\r\\n\\r\\n\\t\\t\\t\\tgeometry.computeGroups( object.geometry );\\r\\n\\t\\t\\t\\tthis.groups = geometry.groups;\\r\\n\\r\\n\\t\\t\\t\\tgeometry.groupsNeedUpdate = false;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tfromGeometry: function ( geometry ) {\\r\\n\\r\\n\\t\\t\\tgeometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );\\r\\n\\r\\n\\t\\t\\treturn this.fromDirectGeometry( geometry.__directGeometry );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tfromDirectGeometry: function ( geometry ) {\\r\\n\\r\\n\\t\\t\\tvar positions = new Float32Array( geometry.vertices.length * 3 );\\r\\n\\t\\t\\tthis.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\\r\\n\\r\\n\\t\\t\\tif ( geometry.normals.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tvar normals = new Float32Array( geometry.normals.length * 3 );\\r\\n\\t\\t\\t\\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( geometry.colors.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tvar colors = new Float32Array( geometry.colors.length * 3 );\\r\\n\\t\\t\\t\\tthis.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( geometry.uvs.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\\r\\n\\t\\t\\t\\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( geometry.uvs2.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\\r\\n\\t\\t\\t\\tthis.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( geometry.indices.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tvar TypeArray = arrayMax( geometry.indices ) > 65535 ? Uint32Array : Uint16Array;\\r\\n\\t\\t\\t\\tvar indices = new TypeArray( geometry.indices.length * 3 );\\r\\n\\t\\t\\t\\tthis.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// groups\\r\\n\\r\\n\\t\\t\\tthis.groups = geometry.groups;\\r\\n\\r\\n\\t\\t\\t// morphs\\r\\n\\r\\n\\t\\t\\tfor ( var name in geometry.morphTargets ) {\\r\\n\\r\\n\\t\\t\\t\\tvar array = [];\\r\\n\\t\\t\\t\\tvar morphTargets = geometry.morphTargets[ name ];\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar morphTarget = morphTargets[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\tvar attribute = new Float32BufferAttribute( morphTarget.length * 3, 3 );\\r\\n\\r\\n\\t\\t\\t\\t\\tarray.push( attribute.copyVector3sArray( morphTarget ) );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tthis.morphAttributes[ name ] = array;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// skinning\\r\\n\\r\\n\\t\\t\\tif ( geometry.skinIndices.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tvar skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );\\r\\n\\t\\t\\t\\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( geometry.skinWeights.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tvar skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );\\r\\n\\t\\t\\t\\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\tif ( geometry.boundingSphere !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.boundingSphere = geometry.boundingSphere.clone();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( geometry.boundingBox !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.boundingBox = geometry.boundingBox.clone();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcomputeBoundingBox: function () {\\r\\n\\r\\n\\t\\t\\tif ( this.boundingBox === null ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.boundingBox = new Box3();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar position = this.attributes.position;\\r\\n\\r\\n\\t\\t\\tif ( position !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.boundingBox.setFromBufferAttribute( position );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tthis.boundingBox.makeEmpty();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \\\"position\\\" attribute is likely to have NaN values.', this );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcomputeBoundingSphere: function () {\\r\\n\\r\\n\\t\\t\\tvar box = new Box3();\\r\\n\\t\\t\\tvar vector = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function computeBoundingSphere() {\\r\\n\\r\\n\\t\\t\\t\\tif ( this.boundingSphere === null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.boundingSphere = new Sphere();\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tvar position = this.attributes.position;\\r\\n\\r\\n\\t\\t\\t\\tif ( position ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar center = this.boundingSphere.center;\\r\\n\\r\\n\\t\\t\\t\\t\\tbox.setFromBufferAttribute( position );\\r\\n\\t\\t\\t\\t\\tbox.getCenter( center );\\r\\n\\r\\n\\t\\t\\t\\t\\t// hoping to find a boundingSphere with a radius smaller than the\\r\\n\\t\\t\\t\\t\\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\\r\\n\\r\\n\\t\\t\\t\\t\\tvar maxRadiusSq = 0;\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0, il = position.count; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvector.x = position.getX( i );\\r\\n\\t\\t\\t\\t\\t\\tvector.y = position.getY( i );\\r\\n\\t\\t\\t\\t\\t\\tvector.z = position.getZ( i );\\r\\n\\t\\t\\t\\t\\t\\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( isNaN( this.boundingSphere.radius ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \\\"position\\\" attribute is likely to have NaN values.', this );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tcomputeFaceNormals: function () {\\r\\n\\r\\n\\t\\t\\t// backwards compatibility\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcomputeVertexNormals: function () {\\r\\n\\r\\n\\t\\t\\tvar index = this.index;\\r\\n\\t\\t\\tvar attributes = this.attributes;\\r\\n\\t\\t\\tvar groups = this.groups;\\r\\n\\r\\n\\t\\t\\tif ( attributes.position ) {\\r\\n\\r\\n\\t\\t\\t\\tvar positions = attributes.position.array;\\r\\n\\r\\n\\t\\t\\t\\tif ( attributes.normal === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t// reset existing normals to zero\\r\\n\\r\\n\\t\\t\\t\\t\\tvar array = attributes.normal.array;\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tarray[ i ] = 0;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tvar normals = attributes.normal.array;\\r\\n\\r\\n\\t\\t\\t\\tvar vA, vB, vC;\\r\\n\\t\\t\\t\\tvar pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\\r\\n\\t\\t\\t\\tvar cb = new Vector3(), ab = new Vector3();\\r\\n\\r\\n\\t\\t\\t\\t// indexed elements\\r\\n\\r\\n\\t\\t\\t\\tif ( index ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar indices = index.array;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( groups.length === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tthis.addGroup( 0, indices.length );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var j = 0, jl = groups.length; j < jl; ++ j ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar group = groups[ j ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar start = group.start;\\r\\n\\t\\t\\t\\t\\t\\tvar count = group.count;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvA = indices[ i + 0 ] * 3;\\r\\n\\t\\t\\t\\t\\t\\t\\tvB = indices[ i + 1 ] * 3;\\r\\n\\t\\t\\t\\t\\t\\t\\tvC = indices[ i + 2 ] * 3;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tpA.fromArray( positions, vA );\\r\\n\\t\\t\\t\\t\\t\\t\\tpB.fromArray( positions, vB );\\r\\n\\t\\t\\t\\t\\t\\t\\tpC.fromArray( positions, vC );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tcb.subVectors( pC, pB );\\r\\n\\t\\t\\t\\t\\t\\t\\tab.subVectors( pA, pB );\\r\\n\\t\\t\\t\\t\\t\\t\\tcb.cross( ab );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vA ] += cb.x;\\r\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vA + 1 ] += cb.y;\\r\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vA + 2 ] += cb.z;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vB ] += cb.x;\\r\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vB + 1 ] += cb.y;\\r\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vB + 2 ] += cb.z;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vC ] += cb.x;\\r\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vC + 1 ] += cb.y;\\r\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vC + 2 ] += cb.z;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t// non-indexed elements (unconnected triangle soup)\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tpA.fromArray( positions, i );\\r\\n\\t\\t\\t\\t\\t\\tpB.fromArray( positions, i + 3 );\\r\\n\\t\\t\\t\\t\\t\\tpC.fromArray( positions, i + 6 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcb.subVectors( pC, pB );\\r\\n\\t\\t\\t\\t\\t\\tab.subVectors( pA, pB );\\r\\n\\t\\t\\t\\t\\t\\tcb.cross( ab );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tnormals[ i ] = cb.x;\\r\\n\\t\\t\\t\\t\\t\\tnormals[ i + 1 ] = cb.y;\\r\\n\\t\\t\\t\\t\\t\\tnormals[ i + 2 ] = cb.z;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tnormals[ i + 3 ] = cb.x;\\r\\n\\t\\t\\t\\t\\t\\tnormals[ i + 4 ] = cb.y;\\r\\n\\t\\t\\t\\t\\t\\tnormals[ i + 5 ] = cb.z;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tnormals[ i + 6 ] = cb.x;\\r\\n\\t\\t\\t\\t\\t\\tnormals[ i + 7 ] = cb.y;\\r\\n\\t\\t\\t\\t\\t\\tnormals[ i + 8 ] = cb.z;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tthis.normalizeNormals();\\r\\n\\r\\n\\t\\t\\t\\tattributes.normal.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmerge: function ( geometry, offset ) {\\r\\n\\r\\n\\t\\t\\tif ( ! ( geometry && geometry.isBufferGeometry ) ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\\r\\n\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\t\\tvar attributes = this.attributes;\\r\\n\\r\\n\\t\\t\\tfor ( var key in attributes ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( geometry.attributes[ key ] === undefined ) continue;\\r\\n\\r\\n\\t\\t\\t\\tvar attribute1 = attributes[ key ];\\r\\n\\t\\t\\t\\tvar attributeArray1 = attribute1.array;\\r\\n\\r\\n\\t\\t\\t\\tvar attribute2 = geometry.attributes[ key ];\\r\\n\\t\\t\\t\\tvar attributeArray2 = attribute2.array;\\r\\n\\r\\n\\t\\t\\t\\tvar attributeSize = attribute2.itemSize;\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tattributeArray1[ j ] = attributeArray2[ i ];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tnormalizeNormals: function () {\\r\\n\\r\\n\\t\\t\\tvar vector = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function normalizeNormals() {\\r\\n\\r\\n\\t\\t\\t\\tvar normals = this.attributes.normal;\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, il = normals.count; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvector.x = normals.getX( i );\\r\\n\\t\\t\\t\\t\\tvector.y = normals.getY( i );\\r\\n\\t\\t\\t\\t\\tvector.z = normals.getZ( i );\\r\\n\\r\\n\\t\\t\\t\\t\\tvector.normalize();\\r\\n\\r\\n\\t\\t\\t\\t\\tnormals.setXYZ( i, vector.x, vector.y, vector.z );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\ttoNonIndexed: function () {\\r\\n\\r\\n\\t\\t\\tif ( this.index === null ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar geometry2 = new BufferGeometry();\\r\\n\\r\\n\\t\\t\\tvar indices = this.index.array;\\r\\n\\t\\t\\tvar attributes = this.attributes;\\r\\n\\r\\n\\t\\t\\tfor ( var name in attributes ) {\\r\\n\\r\\n\\t\\t\\t\\tvar attribute = attributes[ name ];\\r\\n\\r\\n\\t\\t\\t\\tvar array = attribute.array;\\r\\n\\t\\t\\t\\tvar itemSize = attribute.itemSize;\\r\\n\\r\\n\\t\\t\\t\\tvar array2 = new array.constructor( indices.length * itemSize );\\r\\n\\r\\n\\t\\t\\t\\tvar index = 0, index2 = 0;\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tindex = indices[ i ] * itemSize;\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var j = 0; j < itemSize; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tarray2[ index2 ++ ] = array[ index ++ ];\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tgeometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn geometry2;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttoJSON: function () {\\r\\n\\r\\n\\t\\t\\tvar data = {\\r\\n\\t\\t\\t\\tmetadata: {\\r\\n\\t\\t\\t\\t\\tversion: 4.5,\\r\\n\\t\\t\\t\\t\\ttype: 'BufferGeometry',\\r\\n\\t\\t\\t\\t\\tgenerator: 'BufferGeometry.toJSON'\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t// standard BufferGeometry serialization\\r\\n\\r\\n\\t\\t\\tdata.uuid = this.uuid;\\r\\n\\t\\t\\tdata.type = this.type;\\r\\n\\t\\t\\tif ( this.name !== '' ) data.name = this.name;\\r\\n\\r\\n\\t\\t\\tif ( this.parameters !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tvar parameters = this.parameters;\\r\\n\\r\\n\\t\\t\\t\\tfor ( var key in parameters ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn data;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tdata.data = { attributes: {} };\\r\\n\\r\\n\\t\\t\\tvar index = this.index;\\r\\n\\r\\n\\t\\t\\tif ( index !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tvar array = Array.prototype.slice.call( index.array );\\r\\n\\r\\n\\t\\t\\t\\tdata.data.index = {\\r\\n\\t\\t\\t\\t\\ttype: index.array.constructor.name,\\r\\n\\t\\t\\t\\t\\tarray: array\\r\\n\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar attributes = this.attributes;\\r\\n\\r\\n\\t\\t\\tfor ( var key in attributes ) {\\r\\n\\r\\n\\t\\t\\t\\tvar attribute = attributes[ key ];\\r\\n\\r\\n\\t\\t\\t\\tvar array = Array.prototype.slice.call( attribute.array );\\r\\n\\r\\n\\t\\t\\t\\tdata.data.attributes[ key ] = {\\r\\n\\t\\t\\t\\t\\titemSize: attribute.itemSize,\\r\\n\\t\\t\\t\\t\\ttype: attribute.array.constructor.name,\\r\\n\\t\\t\\t\\t\\tarray: array,\\r\\n\\t\\t\\t\\t\\tnormalized: attribute.normalized\\r\\n\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar groups = this.groups;\\r\\n\\r\\n\\t\\t\\tif ( groups.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar boundingSphere = this.boundingSphere;\\r\\n\\r\\n\\t\\t\\tif ( boundingSphere !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tdata.data.boundingSphere = {\\r\\n\\t\\t\\t\\t\\tcenter: boundingSphere.center.toArray(),\\r\\n\\t\\t\\t\\t\\tradius: boundingSphere.radius\\r\\n\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn data;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\t/*\\r\\n\\t\\t\\t // Handle primitives\\r\\n\\r\\n\\t\\t\\t var parameters = this.parameters;\\r\\n\\r\\n\\t\\t\\t if ( parameters !== undefined ) {\\r\\n\\r\\n\\t\\t\\t var values = [];\\r\\n\\r\\n\\t\\t\\t for ( var key in parameters ) {\\r\\n\\r\\n\\t\\t\\t values.push( parameters[ key ] );\\r\\n\\r\\n\\t\\t\\t }\\r\\n\\r\\n\\t\\t\\t var geometry = Object.create( this.constructor.prototype );\\r\\n\\t\\t\\t this.constructor.apply( geometry, values );\\r\\n\\t\\t\\t return geometry;\\r\\n\\r\\n\\t\\t\\t }\\r\\n\\r\\n\\t\\t\\t return new this.constructor().copy( this );\\r\\n\\t\\t\\t */\\r\\n\\r\\n\\t\\t\\treturn new BufferGeometry().copy( this );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\t\\tvar name, i, l;\\r\\n\\r\\n\\t\\t\\t// reset\\r\\n\\r\\n\\t\\t\\tthis.index = null;\\r\\n\\t\\t\\tthis.attributes = {};\\r\\n\\t\\t\\tthis.morphAttributes = {};\\r\\n\\t\\t\\tthis.groups = [];\\r\\n\\t\\t\\tthis.boundingBox = null;\\r\\n\\t\\t\\tthis.boundingSphere = null;\\r\\n\\r\\n\\t\\t\\t// name\\r\\n\\r\\n\\t\\t\\tthis.name = source.name;\\r\\n\\r\\n\\t\\t\\t// index\\r\\n\\r\\n\\t\\t\\tvar index = source.index;\\r\\n\\r\\n\\t\\t\\tif ( index !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.setIndex( index.clone() );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// attributes\\r\\n\\r\\n\\t\\t\\tvar attributes = source.attributes;\\r\\n\\r\\n\\t\\t\\tfor ( name in attributes ) {\\r\\n\\r\\n\\t\\t\\t\\tvar attribute = attributes[ name ];\\r\\n\\t\\t\\t\\tthis.addAttribute( name, attribute.clone() );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// morph attributes\\r\\n\\r\\n\\t\\t\\tvar morphAttributes = source.morphAttributes;\\r\\n\\r\\n\\t\\t\\tfor ( name in morphAttributes ) {\\r\\n\\r\\n\\t\\t\\t\\tvar array = [];\\r\\n\\t\\t\\t\\tvar morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\\r\\n\\r\\n\\t\\t\\t\\tfor ( i = 0, l = morphAttribute.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tarray.push( morphAttribute[ i ].clone() );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tthis.morphAttributes[ name ] = array;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// groups\\r\\n\\r\\n\\t\\t\\tvar groups = source.groups;\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, l = groups.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar group = groups[ i ];\\r\\n\\t\\t\\t\\tthis.addGroup( group.start, group.count, group.materialIndex );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// bounding box\\r\\n\\r\\n\\t\\t\\tvar boundingBox = source.boundingBox;\\r\\n\\r\\n\\t\\t\\tif ( boundingBox !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.boundingBox = boundingBox.clone();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// bounding sphere\\r\\n\\r\\n\\t\\t\\tvar boundingSphere = source.boundingSphere;\\r\\n\\r\\n\\t\\t\\tif ( boundingSphere !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.boundingSphere = boundingSphere.clone();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// draw range\\r\\n\\r\\n\\t\\t\\tthis.drawRange.start = source.drawRange.start;\\r\\n\\t\\t\\tthis.drawRange.count = source.drawRange.count;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdispose: function () {\\r\\n\\r\\n\\t\\t\\tthis.dispatchEvent( { type: 'dispose' } );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author Mugen87 / https://github.com/Mugen87\\r\\n\\t */\\r\\n\\r\\n\\t// BoxGeometry\\r\\n\\r\\n\\tfunction BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\\r\\n\\r\\n\\t\\tGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'BoxGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\twidth: width,\\r\\n\\t\\t\\theight: height,\\r\\n\\t\\t\\tdepth: depth,\\r\\n\\t\\t\\twidthSegments: widthSegments,\\r\\n\\t\\t\\theightSegments: heightSegments,\\r\\n\\t\\t\\tdepthSegments: depthSegments\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\\r\\n\\t\\tthis.mergeVertices();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tBoxGeometry.prototype = Object.create( Geometry.prototype );\\r\\n\\tBoxGeometry.prototype.constructor = BoxGeometry;\\r\\n\\r\\n\\t// BoxBufferGeometry\\r\\n\\r\\n\\tfunction BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\\r\\n\\r\\n\\t\\tBufferGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'BoxBufferGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\twidth: width,\\r\\n\\t\\t\\theight: height,\\r\\n\\t\\t\\tdepth: depth,\\r\\n\\t\\t\\twidthSegments: widthSegments,\\r\\n\\t\\t\\theightSegments: heightSegments,\\r\\n\\t\\t\\tdepthSegments: depthSegments\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\twidth = width || 1;\\r\\n\\t\\theight = height || 1;\\r\\n\\t\\tdepth = depth || 1;\\r\\n\\r\\n\\t\\t// segments\\r\\n\\r\\n\\t\\twidthSegments = Math.floor( widthSegments ) || 1;\\r\\n\\t\\theightSegments = Math.floor( heightSegments ) || 1;\\r\\n\\t\\tdepthSegments = Math.floor( depthSegments ) || 1;\\r\\n\\r\\n\\t\\t// buffers\\r\\n\\r\\n\\t\\tvar indices = [];\\r\\n\\t\\tvar vertices = [];\\r\\n\\t\\tvar normals = [];\\r\\n\\t\\tvar uvs = [];\\r\\n\\r\\n\\t\\t// helper variables\\r\\n\\r\\n\\t\\tvar numberOfVertices = 0;\\r\\n\\t\\tvar groupStart = 0;\\r\\n\\r\\n\\t\\t// build each side of the box geometry\\r\\n\\r\\n\\t\\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px\\r\\n\\t\\tbuildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx\\r\\n\\t\\tbuildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py\\r\\n\\t\\tbuildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny\\r\\n\\t\\tbuildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz\\r\\n\\t\\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz\\r\\n\\r\\n\\t\\t// build geometry\\r\\n\\r\\n\\t\\tthis.setIndex( indices );\\r\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\r\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\r\\n\\r\\n\\t\\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\\r\\n\\r\\n\\t\\t\\tvar segmentWidth = width / gridX;\\r\\n\\t\\t\\tvar segmentHeight = height / gridY;\\r\\n\\r\\n\\t\\t\\tvar widthHalf = width / 2;\\r\\n\\t\\t\\tvar heightHalf = height / 2;\\r\\n\\t\\t\\tvar depthHalf = depth / 2;\\r\\n\\r\\n\\t\\t\\tvar gridX1 = gridX + 1;\\r\\n\\t\\t\\tvar gridY1 = gridY + 1;\\r\\n\\r\\n\\t\\t\\tvar vertexCounter = 0;\\r\\n\\t\\t\\tvar groupCount = 0;\\r\\n\\r\\n\\t\\t\\tvar ix, iy;\\r\\n\\r\\n\\t\\t\\tvar vector = new Vector3();\\r\\n\\r\\n\\t\\t\\t// generate vertices, normals and uvs\\r\\n\\r\\n\\t\\t\\tfor ( iy = 0; iy < gridY1; iy ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar y = iy * segmentHeight - heightHalf;\\r\\n\\r\\n\\t\\t\\t\\tfor ( ix = 0; ix < gridX1; ix ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar x = ix * segmentWidth - widthHalf;\\r\\n\\r\\n\\t\\t\\t\\t\\t// set values to correct vector component\\r\\n\\r\\n\\t\\t\\t\\t\\tvector[ u ] = x * udir;\\r\\n\\t\\t\\t\\t\\tvector[ v ] = y * vdir;\\r\\n\\t\\t\\t\\t\\tvector[ w ] = depthHalf;\\r\\n\\r\\n\\t\\t\\t\\t\\t// now apply vector to vertex buffer\\r\\n\\r\\n\\t\\t\\t\\t\\tvertices.push( vector.x, vector.y, vector.z );\\r\\n\\r\\n\\t\\t\\t\\t\\t// set values to correct vector component\\r\\n\\r\\n\\t\\t\\t\\t\\tvector[ u ] = 0;\\r\\n\\t\\t\\t\\t\\tvector[ v ] = 0;\\r\\n\\t\\t\\t\\t\\tvector[ w ] = depth > 0 ? 1 : - 1;\\r\\n\\r\\n\\t\\t\\t\\t\\t// now apply vector to normal buffer\\r\\n\\r\\n\\t\\t\\t\\t\\tnormals.push( vector.x, vector.y, vector.z );\\r\\n\\r\\n\\t\\t\\t\\t\\t// uvs\\r\\n\\r\\n\\t\\t\\t\\t\\tuvs.push( ix / gridX );\\r\\n\\t\\t\\t\\t\\tuvs.push( 1 - ( iy / gridY ) );\\r\\n\\r\\n\\t\\t\\t\\t\\t// counters\\r\\n\\r\\n\\t\\t\\t\\t\\tvertexCounter += 1;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// indices\\r\\n\\r\\n\\t\\t\\t// 1. you need three indices to draw a single face\\r\\n\\t\\t\\t// 2. a single segment consists of two faces\\r\\n\\t\\t\\t// 3. so we need to generate six (2*3) indices per segment\\r\\n\\r\\n\\t\\t\\tfor ( iy = 0; iy < gridY; iy ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( ix = 0; ix < gridX; ix ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar a = numberOfVertices + ix + gridX1 * iy;\\r\\n\\t\\t\\t\\t\\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\\r\\n\\t\\t\\t\\t\\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\\r\\n\\t\\t\\t\\t\\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\\r\\n\\r\\n\\t\\t\\t\\t\\t// faces\\r\\n\\r\\n\\t\\t\\t\\t\\tindices.push( a, b, d );\\r\\n\\t\\t\\t\\t\\tindices.push( b, c, d );\\r\\n\\r\\n\\t\\t\\t\\t\\t// increase counter\\r\\n\\r\\n\\t\\t\\t\\t\\tgroupCount += 6;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// add a group to the geometry. this will ensure multi material support\\r\\n\\r\\n\\t\\t\\tscope.addGroup( groupStart, groupCount, materialIndex );\\r\\n\\r\\n\\t\\t\\t// calculate new start value for groups\\r\\n\\r\\n\\t\\t\\tgroupStart += groupCount;\\r\\n\\r\\n\\t\\t\\t// update total number of vertices\\r\\n\\r\\n\\t\\t\\tnumberOfVertices += vertexCounter;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tBoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\n\\tBoxBufferGeometry.prototype.constructor = BoxBufferGeometry;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author Mugen87 / https://github.com/Mugen87\\r\\n\\t */\\r\\n\\r\\n\\t// PlaneGeometry\\r\\n\\r\\n\\tfunction PlaneGeometry( width, height, widthSegments, heightSegments ) {\\r\\n\\r\\n\\t\\tGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'PlaneGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\twidth: width,\\r\\n\\t\\t\\theight: height,\\r\\n\\t\\t\\twidthSegments: widthSegments,\\r\\n\\t\\t\\theightSegments: heightSegments\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\\r\\n\\t\\tthis.mergeVertices();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tPlaneGeometry.prototype = Object.create( Geometry.prototype );\\r\\n\\tPlaneGeometry.prototype.constructor = PlaneGeometry;\\r\\n\\r\\n\\t// PlaneBufferGeometry\\r\\n\\r\\n\\tfunction PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {\\r\\n\\r\\n\\t\\tBufferGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'PlaneBufferGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\twidth: width,\\r\\n\\t\\t\\theight: height,\\r\\n\\t\\t\\twidthSegments: widthSegments,\\r\\n\\t\\t\\theightSegments: heightSegments\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\twidth = width || 1;\\r\\n\\t\\theight = height || 1;\\r\\n\\r\\n\\t\\tvar width_half = width / 2;\\r\\n\\t\\tvar height_half = height / 2;\\r\\n\\r\\n\\t\\tvar gridX = Math.floor( widthSegments ) || 1;\\r\\n\\t\\tvar gridY = Math.floor( heightSegments ) || 1;\\r\\n\\r\\n\\t\\tvar gridX1 = gridX + 1;\\r\\n\\t\\tvar gridY1 = gridY + 1;\\r\\n\\r\\n\\t\\tvar segment_width = width / gridX;\\r\\n\\t\\tvar segment_height = height / gridY;\\r\\n\\r\\n\\t\\tvar ix, iy;\\r\\n\\r\\n\\t\\t// buffers\\r\\n\\r\\n\\t\\tvar indices = [];\\r\\n\\t\\tvar vertices = [];\\r\\n\\t\\tvar normals = [];\\r\\n\\t\\tvar uvs = [];\\r\\n\\r\\n\\t\\t// generate vertices, normals and uvs\\r\\n\\r\\n\\t\\tfor ( iy = 0; iy < gridY1; iy ++ ) {\\r\\n\\r\\n\\t\\t\\tvar y = iy * segment_height - height_half;\\r\\n\\r\\n\\t\\t\\tfor ( ix = 0; ix < gridX1; ix ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar x = ix * segment_width - width_half;\\r\\n\\r\\n\\t\\t\\t\\tvertices.push( x, - y, 0 );\\r\\n\\r\\n\\t\\t\\t\\tnormals.push( 0, 0, 1 );\\r\\n\\r\\n\\t\\t\\t\\tuvs.push( ix / gridX );\\r\\n\\t\\t\\t\\tuvs.push( 1 - ( iy / gridY ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// indices\\r\\n\\r\\n\\t\\tfor ( iy = 0; iy < gridY; iy ++ ) {\\r\\n\\r\\n\\t\\t\\tfor ( ix = 0; ix < gridX; ix ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar a = ix + gridX1 * iy;\\r\\n\\t\\t\\t\\tvar b = ix + gridX1 * ( iy + 1 );\\r\\n\\t\\t\\t\\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\\r\\n\\t\\t\\t\\tvar d = ( ix + 1 ) + gridX1 * iy;\\r\\n\\r\\n\\t\\t\\t\\t// faces\\r\\n\\r\\n\\t\\t\\t\\tindices.push( a, b, d );\\r\\n\\t\\t\\t\\tindices.push( b, c, d );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// build geometry\\r\\n\\r\\n\\t\\tthis.setIndex( indices );\\r\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\r\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tPlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\n\\tPlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t *\\r\\n\\t * parameters = {\\r\\n\\t *  color: <hex>,\\r\\n\\t *  opacity: <float>,\\r\\n\\t *  map: new THREE.Texture( <Image> ),\\r\\n\\t *\\r\\n\\t *  lightMap: new THREE.Texture( <Image> ),\\r\\n\\t *  lightMapIntensity: <float>\\r\\n\\t *\\r\\n\\t *  aoMap: new THREE.Texture( <Image> ),\\r\\n\\t *  aoMapIntensity: <float>\\r\\n\\t *\\r\\n\\t *  specularMap: new THREE.Texture( <Image> ),\\r\\n\\t *\\r\\n\\t *  alphaMap: new THREE.Texture( <Image> ),\\r\\n\\t *\\r\\n\\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\\r\\n\\t *  combine: THREE.Multiply,\\r\\n\\t *  reflectivity: <float>,\\r\\n\\t *  refractionRatio: <float>,\\r\\n\\t *\\r\\n\\t *  depthTest: <bool>,\\r\\n\\t *  depthWrite: <bool>,\\r\\n\\t *\\r\\n\\t *  wireframe: <boolean>,\\r\\n\\t *  wireframeLinewidth: <float>,\\r\\n\\t *\\r\\n\\t *  skinning: <bool>,\\r\\n\\t *  morphTargets: <bool>\\r\\n\\t * }\\r\\n\\t */\\r\\n\\r\\n\\tfunction MeshBasicMaterial( parameters ) {\\r\\n\\r\\n\\t\\tMaterial.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'MeshBasicMaterial';\\r\\n\\r\\n\\t\\tthis.color = new Color( 0xffffff ); // emissive\\r\\n\\r\\n\\t\\tthis.map = null;\\r\\n\\r\\n\\t\\tthis.lightMap = null;\\r\\n\\t\\tthis.lightMapIntensity = 1.0;\\r\\n\\r\\n\\t\\tthis.aoMap = null;\\r\\n\\t\\tthis.aoMapIntensity = 1.0;\\r\\n\\r\\n\\t\\tthis.specularMap = null;\\r\\n\\r\\n\\t\\tthis.alphaMap = null;\\r\\n\\r\\n\\t\\tthis.envMap = null;\\r\\n\\t\\tthis.combine = MultiplyOperation;\\r\\n\\t\\tthis.reflectivity = 1;\\r\\n\\t\\tthis.refractionRatio = 0.98;\\r\\n\\r\\n\\t\\tthis.wireframe = false;\\r\\n\\t\\tthis.wireframeLinewidth = 1;\\r\\n\\t\\tthis.wireframeLinecap = 'round';\\r\\n\\t\\tthis.wireframeLinejoin = 'round';\\r\\n\\r\\n\\t\\tthis.skinning = false;\\r\\n\\t\\tthis.morphTargets = false;\\r\\n\\r\\n\\t\\tthis.lights = false;\\r\\n\\r\\n\\t\\tthis.setValues( parameters );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tMeshBasicMaterial.prototype = Object.create( Material.prototype );\\r\\n\\tMeshBasicMaterial.prototype.constructor = MeshBasicMaterial;\\r\\n\\r\\n\\tMeshBasicMaterial.prototype.isMeshBasicMaterial = true;\\r\\n\\r\\n\\tMeshBasicMaterial.prototype.copy = function ( source ) {\\r\\n\\r\\n\\t\\tMaterial.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.color.copy( source.color );\\r\\n\\r\\n\\t\\tthis.map = source.map;\\r\\n\\r\\n\\t\\tthis.lightMap = source.lightMap;\\r\\n\\t\\tthis.lightMapIntensity = source.lightMapIntensity;\\r\\n\\r\\n\\t\\tthis.aoMap = source.aoMap;\\r\\n\\t\\tthis.aoMapIntensity = source.aoMapIntensity;\\r\\n\\r\\n\\t\\tthis.specularMap = source.specularMap;\\r\\n\\r\\n\\t\\tthis.alphaMap = source.alphaMap;\\r\\n\\r\\n\\t\\tthis.envMap = source.envMap;\\r\\n\\t\\tthis.combine = source.combine;\\r\\n\\t\\tthis.reflectivity = source.reflectivity;\\r\\n\\t\\tthis.refractionRatio = source.refractionRatio;\\r\\n\\r\\n\\t\\tthis.wireframe = source.wireframe;\\r\\n\\t\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\r\\n\\t\\tthis.wireframeLinecap = source.wireframeLinecap;\\r\\n\\t\\tthis.wireframeLinejoin = source.wireframeLinejoin;\\r\\n\\r\\n\\t\\tthis.skinning = source.skinning;\\r\\n\\t\\tthis.morphTargets = source.morphTargets;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t *\\r\\n\\t * parameters = {\\r\\n\\t *  defines: { \\\"label\\\" : \\\"value\\\" },\\r\\n\\t *  uniforms: { \\\"parameter1\\\": { value: 1.0 }, \\\"parameter2\\\": { value2: 2 } },\\r\\n\\t *\\r\\n\\t *  fragmentShader: <string>,\\r\\n\\t *  vertexShader: <string>,\\r\\n\\t *\\r\\n\\t *  wireframe: <boolean>,\\r\\n\\t *  wireframeLinewidth: <float>,\\r\\n\\t *\\r\\n\\t *  lights: <bool>,\\r\\n\\t *\\r\\n\\t *  skinning: <bool>,\\r\\n\\t *  morphTargets: <bool>,\\r\\n\\t *  morphNormals: <bool>\\r\\n\\t * }\\r\\n\\t */\\r\\n\\r\\n\\tfunction ShaderMaterial( parameters ) {\\r\\n\\r\\n\\t\\tMaterial.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'ShaderMaterial';\\r\\n\\r\\n\\t\\tthis.defines = {};\\r\\n\\t\\tthis.uniforms = {};\\r\\n\\r\\n\\t\\tthis.vertexShader = 'void main() {\\\\n\\\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\\n}';\\r\\n\\t\\tthis.fragmentShader = 'void main() {\\\\n\\\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\\\n}';\\r\\n\\r\\n\\t\\tthis.linewidth = 1;\\r\\n\\r\\n\\t\\tthis.wireframe = false;\\r\\n\\t\\tthis.wireframeLinewidth = 1;\\r\\n\\r\\n\\t\\tthis.fog = false; // set to use scene fog\\r\\n\\t\\tthis.lights = false; // set to use scene lights\\r\\n\\t\\tthis.clipping = false; // set to use user-defined clipping planes\\r\\n\\r\\n\\t\\tthis.skinning = false; // set to use skinning attribute streams\\r\\n\\t\\tthis.morphTargets = false; // set to use morph targets\\r\\n\\t\\tthis.morphNormals = false; // set to use morph normals\\r\\n\\r\\n\\t\\tthis.extensions = {\\r\\n\\t\\t\\tderivatives: false, // set to use derivatives\\r\\n\\t\\t\\tfragDepth: false, // set to use fragment depth values\\r\\n\\t\\t\\tdrawBuffers: false, // set to use draw buffers\\r\\n\\t\\t\\tshaderTextureLOD: false // set to use shader texture LOD\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\t// When rendered geometry doesn't include these attributes but the material does,\\r\\n\\t\\t// use these default values in WebGL. This avoids errors when buffer data is missing.\\r\\n\\t\\tthis.defaultAttributeValues = {\\r\\n\\t\\t\\t'color': [ 1, 1, 1 ],\\r\\n\\t\\t\\t'uv': [ 0, 0 ],\\r\\n\\t\\t\\t'uv2': [ 0, 0 ]\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.index0AttributeName = undefined;\\r\\n\\r\\n\\t\\tif ( parameters !== undefined ) {\\r\\n\\r\\n\\t\\t\\tif ( parameters.attributes !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.setValues( parameters );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tShaderMaterial.prototype = Object.create( Material.prototype );\\r\\n\\tShaderMaterial.prototype.constructor = ShaderMaterial;\\r\\n\\r\\n\\tShaderMaterial.prototype.isShaderMaterial = true;\\r\\n\\r\\n\\tShaderMaterial.prototype.copy = function ( source ) {\\r\\n\\r\\n\\t\\tMaterial.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.fragmentShader = source.fragmentShader;\\r\\n\\t\\tthis.vertexShader = source.vertexShader;\\r\\n\\r\\n\\t\\tthis.uniforms = UniformsUtils.clone( source.uniforms );\\r\\n\\r\\n\\t\\tthis.defines = source.defines;\\r\\n\\r\\n\\t\\tthis.wireframe = source.wireframe;\\r\\n\\t\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\r\\n\\r\\n\\t\\tthis.lights = source.lights;\\r\\n\\t\\tthis.clipping = source.clipping;\\r\\n\\r\\n\\t\\tthis.skinning = source.skinning;\\r\\n\\r\\n\\t\\tthis.morphTargets = source.morphTargets;\\r\\n\\t\\tthis.morphNormals = source.morphNormals;\\r\\n\\r\\n\\t\\tthis.extensions = source.extensions;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tShaderMaterial.prototype.toJSON = function ( meta ) {\\r\\n\\r\\n\\t\\tvar data = Material.prototype.toJSON.call( this, meta );\\r\\n\\r\\n\\t\\tdata.uniforms = this.uniforms;\\r\\n\\t\\tdata.vertexShader = this.vertexShader;\\r\\n\\t\\tdata.fragmentShader = this.fragmentShader;\\r\\n\\r\\n\\t\\treturn data;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author bhouston / http://clara.io\\r\\n\\t */\\r\\n\\r\\n\\tfunction Ray( origin, direction ) {\\r\\n\\r\\n\\t\\tthis.origin = ( origin !== undefined ) ? origin : new Vector3();\\r\\n\\t\\tthis.direction = ( direction !== undefined ) ? direction : new Vector3();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( Ray.prototype, {\\r\\n\\r\\n\\t\\tset: function ( origin, direction ) {\\r\\n\\r\\n\\t\\t\\tthis.origin.copy( origin );\\r\\n\\t\\t\\tthis.direction.copy( direction );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( ray ) {\\r\\n\\r\\n\\t\\t\\tthis.origin.copy( ray.origin );\\r\\n\\t\\t\\tthis.direction.copy( ray.direction );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tat: function ( t, optionalTarget ) {\\r\\n\\r\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\r\\n\\r\\n\\t\\t\\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tlookAt: function ( v ) {\\r\\n\\r\\n\\t\\t\\tthis.direction.copy( v ).sub( this.origin ).normalize();\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\trecast: function () {\\r\\n\\r\\n\\t\\t\\tvar v1 = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function recast( t ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.origin.copy( this.at( t, v1 ) );\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tclosestPointToPoint: function ( point, optionalTarget ) {\\r\\n\\r\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\r\\n\\t\\t\\tresult.subVectors( point, this.origin );\\r\\n\\t\\t\\tvar directionDistance = result.dot( this.direction );\\r\\n\\r\\n\\t\\t\\tif ( directionDistance < 0 ) {\\r\\n\\r\\n\\t\\t\\t\\treturn result.copy( this.origin );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdistanceToPoint: function ( point ) {\\r\\n\\r\\n\\t\\t\\treturn Math.sqrt( this.distanceSqToPoint( point ) );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdistanceSqToPoint: function () {\\r\\n\\r\\n\\t\\t\\tvar v1 = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function distanceSqToPoint( point ) {\\r\\n\\r\\n\\t\\t\\t\\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\\r\\n\\r\\n\\t\\t\\t\\t// point behind the ray\\r\\n\\r\\n\\t\\t\\t\\tif ( directionDistance < 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn this.origin.distanceToSquared( point );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\\r\\n\\r\\n\\t\\t\\t\\treturn v1.distanceToSquared( point );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tdistanceSqToSegment: function () {\\r\\n\\r\\n\\t\\t\\tvar segCenter = new Vector3();\\r\\n\\t\\t\\tvar segDir = new Vector3();\\r\\n\\t\\t\\tvar diff = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\\r\\n\\r\\n\\t\\t\\t\\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\\r\\n\\t\\t\\t\\t// It returns the min distance between the ray and the segment\\r\\n\\t\\t\\t\\t// defined by v0 and v1\\r\\n\\t\\t\\t\\t// It can also set two optional targets :\\r\\n\\t\\t\\t\\t// - The closest point on the ray\\r\\n\\t\\t\\t\\t// - The closest point on the segment\\r\\n\\r\\n\\t\\t\\t\\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\\r\\n\\t\\t\\t\\tsegDir.copy( v1 ).sub( v0 ).normalize();\\r\\n\\t\\t\\t\\tdiff.copy( this.origin ).sub( segCenter );\\r\\n\\r\\n\\t\\t\\t\\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\\r\\n\\t\\t\\t\\tvar a01 = - this.direction.dot( segDir );\\r\\n\\t\\t\\t\\tvar b0 = diff.dot( this.direction );\\r\\n\\t\\t\\t\\tvar b1 = - diff.dot( segDir );\\r\\n\\t\\t\\t\\tvar c = diff.lengthSq();\\r\\n\\t\\t\\t\\tvar det = Math.abs( 1 - a01 * a01 );\\r\\n\\t\\t\\t\\tvar s0, s1, sqrDist, extDet;\\r\\n\\r\\n\\t\\t\\t\\tif ( det > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// The ray and segment are not parallel.\\r\\n\\r\\n\\t\\t\\t\\t\\ts0 = a01 * b1 - b0;\\r\\n\\t\\t\\t\\t\\ts1 = a01 * b0 - b1;\\r\\n\\t\\t\\t\\t\\textDet = segExtent * det;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( s0 >= 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( s1 >= - extDet ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( s1 <= extDet ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t// region 0\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t// Minimum at interior points of ray and segment.\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tvar invDet = 1 / det;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\ts0 *= invDet;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\ts1 *= invDet;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t// region 1\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\ts1 = segExtent;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t// region 5\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\ts1 = - segExtent;\\r\\n\\t\\t\\t\\t\\t\\t\\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\\r\\n\\t\\t\\t\\t\\t\\t\\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( s1 <= - extDet ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t// region 4\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\\r\\n\\t\\t\\t\\t\\t\\t\\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\\r\\n\\t\\t\\t\\t\\t\\t\\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t} else if ( s1 <= extDet ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t// region 3\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\ts0 = 0;\\r\\n\\t\\t\\t\\t\\t\\t\\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\\r\\n\\t\\t\\t\\t\\t\\t\\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t// region 2\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\\r\\n\\t\\t\\t\\t\\t\\t\\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\\r\\n\\t\\t\\t\\t\\t\\t\\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t// Ray and segment are parallel.\\r\\n\\r\\n\\t\\t\\t\\t\\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\\r\\n\\t\\t\\t\\t\\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\\r\\n\\t\\t\\t\\t\\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( optionalPointOnRay ) {\\r\\n\\r\\n\\t\\t\\t\\t\\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( optionalPointOnSegment ) {\\r\\n\\r\\n\\t\\t\\t\\t\\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn sqrDist;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tintersectSphere: function () {\\r\\n\\r\\n\\t\\t\\tvar v1 = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function intersectSphere( sphere, optionalTarget ) {\\r\\n\\r\\n\\t\\t\\t\\tv1.subVectors( sphere.center, this.origin );\\r\\n\\t\\t\\t\\tvar tca = v1.dot( this.direction );\\r\\n\\t\\t\\t\\tvar d2 = v1.dot( v1 ) - tca * tca;\\r\\n\\t\\t\\t\\tvar radius2 = sphere.radius * sphere.radius;\\r\\n\\r\\n\\t\\t\\t\\tif ( d2 > radius2 ) return null;\\r\\n\\r\\n\\t\\t\\t\\tvar thc = Math.sqrt( radius2 - d2 );\\r\\n\\r\\n\\t\\t\\t\\t// t0 = first intersect point - entrance on front of sphere\\r\\n\\t\\t\\t\\tvar t0 = tca - thc;\\r\\n\\r\\n\\t\\t\\t\\t// t1 = second intersect point - exit point on back of sphere\\r\\n\\t\\t\\t\\tvar t1 = tca + thc;\\r\\n\\r\\n\\t\\t\\t\\t// test to see if both t0 and t1 are behind the ray - if so, return null\\r\\n\\t\\t\\t\\tif ( t0 < 0 && t1 < 0 ) return null;\\r\\n\\r\\n\\t\\t\\t\\t// test to see if t0 is behind the ray:\\r\\n\\t\\t\\t\\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\\r\\n\\t\\t\\t\\t// in order to always return an intersect point that is in front of the ray.\\r\\n\\t\\t\\t\\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\\r\\n\\r\\n\\t\\t\\t\\t// else t0 is in front of the ray, so return the first collision point scaled by t0\\r\\n\\t\\t\\t\\treturn this.at( t0, optionalTarget );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tintersectsSphere: function ( sphere ) {\\r\\n\\r\\n\\t\\t\\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdistanceToPlane: function ( plane ) {\\r\\n\\r\\n\\t\\t\\tvar denominator = plane.normal.dot( this.direction );\\r\\n\\r\\n\\t\\t\\tif ( denominator === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t// line is coplanar, return origin\\r\\n\\t\\t\\t\\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn 0;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// Null is preferable to undefined since undefined means.... it is undefined\\r\\n\\r\\n\\t\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\\r\\n\\r\\n\\t\\t\\t// Return if the ray never intersects the plane\\r\\n\\r\\n\\t\\t\\treturn t >= 0 ? t : null;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tintersectPlane: function ( plane, optionalTarget ) {\\r\\n\\r\\n\\t\\t\\tvar t = this.distanceToPlane( plane );\\r\\n\\r\\n\\t\\t\\tif ( t === null ) {\\r\\n\\r\\n\\t\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this.at( t, optionalTarget );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tintersectsPlane: function ( plane ) {\\r\\n\\r\\n\\t\\t\\t// check if the ray lies on the plane first\\r\\n\\r\\n\\t\\t\\tvar distToPoint = plane.distanceToPoint( this.origin );\\r\\n\\r\\n\\t\\t\\tif ( distToPoint === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\treturn true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar denominator = plane.normal.dot( this.direction );\\r\\n\\r\\n\\t\\t\\tif ( denominator * distToPoint < 0 ) {\\r\\n\\r\\n\\t\\t\\t\\treturn true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// ray origin is behind the plane (and is pointing behind it)\\r\\n\\r\\n\\t\\t\\treturn false;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tintersectBox: function ( box, optionalTarget ) {\\r\\n\\r\\n\\t\\t\\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\\r\\n\\r\\n\\t\\t\\tvar invdirx = 1 / this.direction.x,\\r\\n\\t\\t\\t\\tinvdiry = 1 / this.direction.y,\\r\\n\\t\\t\\t\\tinvdirz = 1 / this.direction.z;\\r\\n\\r\\n\\t\\t\\tvar origin = this.origin;\\r\\n\\r\\n\\t\\t\\tif ( invdirx >= 0 ) {\\r\\n\\r\\n\\t\\t\\t\\ttmin = ( box.min.x - origin.x ) * invdirx;\\r\\n\\t\\t\\t\\ttmax = ( box.max.x - origin.x ) * invdirx;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\ttmin = ( box.max.x - origin.x ) * invdirx;\\r\\n\\t\\t\\t\\ttmax = ( box.min.x - origin.x ) * invdirx;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( invdiry >= 0 ) {\\r\\n\\r\\n\\t\\t\\t\\ttymin = ( box.min.y - origin.y ) * invdiry;\\r\\n\\t\\t\\t\\ttymax = ( box.max.y - origin.y ) * invdiry;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\ttymin = ( box.max.y - origin.y ) * invdiry;\\r\\n\\t\\t\\t\\ttymax = ( box.min.y - origin.y ) * invdiry;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\\r\\n\\r\\n\\t\\t\\t// These lines also handle the case where tmin or tmax is NaN\\r\\n\\t\\t\\t// (result of 0 * Infinity). x !== x returns true if x is NaN\\r\\n\\r\\n\\t\\t\\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\\r\\n\\r\\n\\t\\t\\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\\r\\n\\r\\n\\t\\t\\tif ( invdirz >= 0 ) {\\r\\n\\r\\n\\t\\t\\t\\ttzmin = ( box.min.z - origin.z ) * invdirz;\\r\\n\\t\\t\\t\\ttzmax = ( box.max.z - origin.z ) * invdirz;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\ttzmin = ( box.max.z - origin.z ) * invdirz;\\r\\n\\t\\t\\t\\ttzmax = ( box.min.z - origin.z ) * invdirz;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\\r\\n\\r\\n\\t\\t\\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\\r\\n\\r\\n\\t\\t\\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\\r\\n\\r\\n\\t\\t\\t//return point closest to the ray (positive side)\\r\\n\\r\\n\\t\\t\\tif ( tmax < 0 ) return null;\\r\\n\\r\\n\\t\\t\\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tintersectsBox: ( function () {\\r\\n\\r\\n\\t\\t\\tvar v = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function intersectsBox( box ) {\\r\\n\\r\\n\\t\\t\\t\\treturn this.intersectBox( box, v ) !== null;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t} )(),\\r\\n\\r\\n\\t\\tintersectTriangle: function () {\\r\\n\\r\\n\\t\\t\\t// Compute the offset origin, edges, and normal.\\r\\n\\t\\t\\tvar diff = new Vector3();\\r\\n\\t\\t\\tvar edge1 = new Vector3();\\r\\n\\t\\t\\tvar edge2 = new Vector3();\\r\\n\\t\\t\\tvar normal = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {\\r\\n\\r\\n\\t\\t\\t\\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\\r\\n\\r\\n\\t\\t\\t\\tedge1.subVectors( b, a );\\r\\n\\t\\t\\t\\tedge2.subVectors( c, a );\\r\\n\\t\\t\\t\\tnormal.crossVectors( edge1, edge2 );\\r\\n\\r\\n\\t\\t\\t\\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\\r\\n\\t\\t\\t\\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\\r\\n\\t\\t\\t\\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\\r\\n\\t\\t\\t\\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\\r\\n\\t\\t\\t\\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\\r\\n\\t\\t\\t\\tvar DdN = this.direction.dot( normal );\\r\\n\\t\\t\\t\\tvar sign;\\r\\n\\r\\n\\t\\t\\t\\tif ( DdN > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( backfaceCulling ) return null;\\r\\n\\t\\t\\t\\t\\tsign = 1;\\r\\n\\r\\n\\t\\t\\t\\t} else if ( DdN < 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tsign = - 1;\\r\\n\\t\\t\\t\\t\\tDdN = - DdN;\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tdiff.subVectors( this.origin, a );\\r\\n\\t\\t\\t\\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\\r\\n\\r\\n\\t\\t\\t\\t// b1 < 0, no intersection\\r\\n\\t\\t\\t\\tif ( DdQxE2 < 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\\r\\n\\r\\n\\t\\t\\t\\t// b2 < 0, no intersection\\r\\n\\t\\t\\t\\tif ( DdE1xQ < 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// b1+b2 > 1, no intersection\\r\\n\\t\\t\\t\\tif ( DdQxE2 + DdE1xQ > DdN ) {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// Line intersects triangle, check if ray does.\\r\\n\\t\\t\\t\\tvar QdN = - sign * diff.dot( normal );\\r\\n\\r\\n\\t\\t\\t\\t// t < 0, no intersection\\r\\n\\t\\t\\t\\tif ( QdN < 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// Ray intersects triangle.\\r\\n\\t\\t\\t\\treturn this.at( QdN / DdN, optionalTarget );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tapplyMatrix4: function ( matrix4 ) {\\r\\n\\r\\n\\t\\t\\tthis.origin.applyMatrix4( matrix4 );\\r\\n\\t\\t\\tthis.direction.transformDirection( matrix4 );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tequals: function ( ray ) {\\r\\n\\r\\n\\t\\t\\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author bhouston / http://clara.io\\r\\n\\t */\\r\\n\\r\\n\\tfunction Line3( start, end ) {\\r\\n\\r\\n\\t\\tthis.start = ( start !== undefined ) ? start : new Vector3();\\r\\n\\t\\tthis.end = ( end !== undefined ) ? end : new Vector3();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( Line3.prototype, {\\r\\n\\r\\n\\t\\tset: function ( start, end ) {\\r\\n\\r\\n\\t\\t\\tthis.start.copy( start );\\r\\n\\t\\t\\tthis.end.copy( end );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( line ) {\\r\\n\\r\\n\\t\\t\\tthis.start.copy( line.start );\\r\\n\\t\\t\\tthis.end.copy( line.end );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetCenter: function ( optionalTarget ) {\\r\\n\\r\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\r\\n\\t\\t\\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdelta: function ( optionalTarget ) {\\r\\n\\r\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\r\\n\\t\\t\\treturn result.subVectors( this.end, this.start );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdistanceSq: function () {\\r\\n\\r\\n\\t\\t\\treturn this.start.distanceToSquared( this.end );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdistance: function () {\\r\\n\\r\\n\\t\\t\\treturn this.start.distanceTo( this.end );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tat: function ( t, optionalTarget ) {\\r\\n\\r\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\r\\n\\r\\n\\t\\t\\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclosestPointToPointParameter: function () {\\r\\n\\r\\n\\t\\t\\tvar startP = new Vector3();\\r\\n\\t\\t\\tvar startEnd = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function closestPointToPointParameter( point, clampToLine ) {\\r\\n\\r\\n\\t\\t\\t\\tstartP.subVectors( point, this.start );\\r\\n\\t\\t\\t\\tstartEnd.subVectors( this.end, this.start );\\r\\n\\r\\n\\t\\t\\t\\tvar startEnd2 = startEnd.dot( startEnd );\\r\\n\\t\\t\\t\\tvar startEnd_startP = startEnd.dot( startP );\\r\\n\\r\\n\\t\\t\\t\\tvar t = startEnd_startP / startEnd2;\\r\\n\\r\\n\\t\\t\\t\\tif ( clampToLine ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tt = _Math.clamp( t, 0, 1 );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn t;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\\r\\n\\r\\n\\t\\t\\tvar t = this.closestPointToPointParameter( point, clampToLine );\\r\\n\\r\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\r\\n\\r\\n\\t\\t\\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tapplyMatrix4: function ( matrix ) {\\r\\n\\r\\n\\t\\t\\tthis.start.applyMatrix4( matrix );\\r\\n\\t\\t\\tthis.end.applyMatrix4( matrix );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tequals: function ( line ) {\\r\\n\\r\\n\\t\\t\\treturn line.start.equals( this.start ) && line.end.equals( this.end );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author bhouston / http://clara.io\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction Triangle( a, b, c ) {\\r\\n\\r\\n\\t\\tthis.a = ( a !== undefined ) ? a : new Vector3();\\r\\n\\t\\tthis.b = ( b !== undefined ) ? b : new Vector3();\\r\\n\\t\\tthis.c = ( c !== undefined ) ? c : new Vector3();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( Triangle, {\\r\\n\\r\\n\\t\\tnormal: function () {\\r\\n\\r\\n\\t\\t\\tvar v0 = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function normal( a, b, c, optionalTarget ) {\\r\\n\\r\\n\\t\\t\\t\\tvar result = optionalTarget || new Vector3();\\r\\n\\r\\n\\t\\t\\t\\tresult.subVectors( c, b );\\r\\n\\t\\t\\t\\tv0.subVectors( a, b );\\r\\n\\t\\t\\t\\tresult.cross( v0 );\\r\\n\\r\\n\\t\\t\\t\\tvar resultLengthSq = result.lengthSq();\\r\\n\\t\\t\\t\\tif ( resultLengthSq > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn result.set( 0, 0, 0 );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\t// static/instance method to calculate barycentric coordinates\\r\\n\\t\\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\\r\\n\\t\\tbarycoordFromPoint: function () {\\r\\n\\r\\n\\t\\t\\tvar v0 = new Vector3();\\r\\n\\t\\t\\tvar v1 = new Vector3();\\r\\n\\t\\t\\tvar v2 = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function barycoordFromPoint( point, a, b, c, optionalTarget ) {\\r\\n\\r\\n\\t\\t\\t\\tv0.subVectors( c, a );\\r\\n\\t\\t\\t\\tv1.subVectors( b, a );\\r\\n\\t\\t\\t\\tv2.subVectors( point, a );\\r\\n\\r\\n\\t\\t\\t\\tvar dot00 = v0.dot( v0 );\\r\\n\\t\\t\\t\\tvar dot01 = v0.dot( v1 );\\r\\n\\t\\t\\t\\tvar dot02 = v0.dot( v2 );\\r\\n\\t\\t\\t\\tvar dot11 = v1.dot( v1 );\\r\\n\\t\\t\\t\\tvar dot12 = v1.dot( v2 );\\r\\n\\r\\n\\t\\t\\t\\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\\r\\n\\r\\n\\t\\t\\t\\tvar result = optionalTarget || new Vector3();\\r\\n\\r\\n\\t\\t\\t\\t// collinear or singular triangle\\r\\n\\t\\t\\t\\tif ( denom === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// arbitrary location outside of triangle?\\r\\n\\t\\t\\t\\t\\t// not sure if this is the best idea, maybe should be returning undefined\\r\\n\\t\\t\\t\\t\\treturn result.set( - 2, - 1, - 1 );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tvar invDenom = 1 / denom;\\r\\n\\t\\t\\t\\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\\r\\n\\t\\t\\t\\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\\r\\n\\r\\n\\t\\t\\t\\t// barycentric coordinates must always sum to 1\\r\\n\\t\\t\\t\\treturn result.set( 1 - u - v, v, u );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tcontainsPoint: function () {\\r\\n\\r\\n\\t\\t\\tvar v1 = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function containsPoint( point, a, b, c ) {\\r\\n\\r\\n\\t\\t\\t\\tvar result = Triangle.barycoordFromPoint( point, a, b, c, v1 );\\r\\n\\r\\n\\t\\t\\t\\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}()\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tObject.assign( Triangle.prototype, {\\r\\n\\r\\n\\t\\tset: function ( a, b, c ) {\\r\\n\\r\\n\\t\\t\\tthis.a.copy( a );\\r\\n\\t\\t\\tthis.b.copy( b );\\r\\n\\t\\t\\tthis.c.copy( c );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\\r\\n\\r\\n\\t\\t\\tthis.a.copy( points[ i0 ] );\\r\\n\\t\\t\\tthis.b.copy( points[ i1 ] );\\r\\n\\t\\t\\tthis.c.copy( points[ i2 ] );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( triangle ) {\\r\\n\\r\\n\\t\\t\\tthis.a.copy( triangle.a );\\r\\n\\t\\t\\tthis.b.copy( triangle.b );\\r\\n\\t\\t\\tthis.c.copy( triangle.c );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tarea: function () {\\r\\n\\r\\n\\t\\t\\tvar v0 = new Vector3();\\r\\n\\t\\t\\tvar v1 = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function area() {\\r\\n\\r\\n\\t\\t\\t\\tv0.subVectors( this.c, this.b );\\r\\n\\t\\t\\t\\tv1.subVectors( this.a, this.b );\\r\\n\\r\\n\\t\\t\\t\\treturn v0.cross( v1 ).length() * 0.5;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tmidpoint: function ( optionalTarget ) {\\r\\n\\r\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\r\\n\\t\\t\\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tnormal: function ( optionalTarget ) {\\r\\n\\r\\n\\t\\t\\treturn Triangle.normal( this.a, this.b, this.c, optionalTarget );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tplane: function ( optionalTarget ) {\\r\\n\\r\\n\\t\\t\\tvar result = optionalTarget || new Plane();\\r\\n\\r\\n\\t\\t\\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tbarycoordFromPoint: function ( point, optionalTarget ) {\\r\\n\\r\\n\\t\\t\\treturn Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcontainsPoint: function ( point ) {\\r\\n\\r\\n\\t\\t\\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclosestPointToPoint: function () {\\r\\n\\r\\n\\t\\t\\tvar plane = new Plane();\\r\\n\\t\\t\\tvar edgeList = [ new Line3(), new Line3(), new Line3() ];\\r\\n\\t\\t\\tvar projectedPoint = new Vector3();\\r\\n\\t\\t\\tvar closestPoint = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function closestPointToPoint( point, optionalTarget ) {\\r\\n\\r\\n\\t\\t\\t\\tvar result = optionalTarget || new Vector3();\\r\\n\\t\\t\\t\\tvar minDistance = Infinity;\\r\\n\\r\\n\\t\\t\\t\\t// project the point onto the plane of the triangle\\r\\n\\r\\n\\t\\t\\t\\tplane.setFromCoplanarPoints( this.a, this.b, this.c );\\r\\n\\t\\t\\t\\tplane.projectPoint( point, projectedPoint );\\r\\n\\r\\n\\t\\t\\t\\t// check if the projection lies within the triangle\\r\\n\\r\\n\\t\\t\\t\\tif ( this.containsPoint( projectedPoint ) === true ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// if so, this is the closest point\\r\\n\\r\\n\\t\\t\\t\\t\\tresult.copy( projectedPoint );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices\\r\\n\\r\\n\\t\\t\\t\\t\\tedgeList[ 0 ].set( this.a, this.b );\\r\\n\\t\\t\\t\\t\\tedgeList[ 1 ].set( this.b, this.c );\\r\\n\\t\\t\\t\\t\\tedgeList[ 2 ].set( this.c, this.a );\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < edgeList.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tedgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar distance = projectedPoint.distanceToSquared( closestPoint );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( distance < minDistance ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tminDistance = distance;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tresult.copy( closestPoint );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn result;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tequals: function ( triangle ) {\\r\\n\\r\\n\\t\\t\\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t * @author mikael emtinger / http://gomo.se/\\r\\n\\t * @author jonobr1 / http://jonobr1.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction Mesh( geometry, material ) {\\r\\n\\r\\n\\t\\tObject3D.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'Mesh';\\r\\n\\r\\n\\t\\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\\r\\n\\t\\tthis.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );\\r\\n\\r\\n\\t\\tthis.drawMode = TrianglesDrawMode;\\r\\n\\r\\n\\t\\tthis.updateMorphTargets();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tMesh.prototype = Object.assign( Object.create( Object3D.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: Mesh,\\r\\n\\r\\n\\t\\tisMesh: true,\\r\\n\\r\\n\\t\\tsetDrawMode: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.drawMode = value;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\t\\tObject3D.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\t\\tthis.drawMode = source.drawMode;\\r\\n\\r\\n\\t\\t\\tif ( source.morphTargetInfluences !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.morphTargetInfluences = source.morphTargetInfluences.slice();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( source.morphTargetDictionary !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tupdateMorphTargets: function () {\\r\\n\\r\\n\\t\\t\\tvar geometry = this.geometry;\\r\\n\\t\\t\\tvar m, ml, name;\\r\\n\\r\\n\\t\\t\\tif ( geometry.isBufferGeometry ) {\\r\\n\\r\\n\\t\\t\\t\\tvar morphAttributes = geometry.morphAttributes;\\r\\n\\t\\t\\t\\tvar keys = Object.keys( morphAttributes );\\r\\n\\r\\n\\t\\t\\t\\tif ( keys.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar morphAttribute = morphAttributes[ keys[ 0 ] ];\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( morphAttribute !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tthis.morphTargetInfluences = [];\\r\\n\\t\\t\\t\\t\\t\\tthis.morphTargetDictionary = {};\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tname = morphAttribute[ m ].name || String( m );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tthis.morphTargetInfluences.push( 0 );\\r\\n\\t\\t\\t\\t\\t\\t\\tthis.morphTargetDictionary[ name ] = m;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tvar morphTargets = geometry.morphTargets;\\r\\n\\r\\n\\t\\t\\t\\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.morphTargetInfluences = [];\\r\\n\\t\\t\\t\\t\\tthis.morphTargetDictionary = {};\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( m = 0, ml = morphTargets.length; m < ml; m ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tname = morphTargets[ m ].name || String( m );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tthis.morphTargetInfluences.push( 0 );\\r\\n\\t\\t\\t\\t\\t\\tthis.morphTargetDictionary[ name ] = m;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\traycast: ( function () {\\r\\n\\r\\n\\t\\t\\tvar inverseMatrix = new Matrix4();\\r\\n\\t\\t\\tvar ray = new Ray();\\r\\n\\t\\t\\tvar sphere = new Sphere();\\r\\n\\r\\n\\t\\t\\tvar vA = new Vector3();\\r\\n\\t\\t\\tvar vB = new Vector3();\\r\\n\\t\\t\\tvar vC = new Vector3();\\r\\n\\r\\n\\t\\t\\tvar tempA = new Vector3();\\r\\n\\t\\t\\tvar tempB = new Vector3();\\r\\n\\t\\t\\tvar tempC = new Vector3();\\r\\n\\r\\n\\t\\t\\tvar uvA = new Vector2();\\r\\n\\t\\t\\tvar uvB = new Vector2();\\r\\n\\t\\t\\tvar uvC = new Vector2();\\r\\n\\r\\n\\t\\t\\tvar barycoord = new Vector3();\\r\\n\\r\\n\\t\\t\\tvar intersectionPoint = new Vector3();\\r\\n\\t\\t\\tvar intersectionPointWorld = new Vector3();\\r\\n\\r\\n\\t\\t\\tfunction uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\\r\\n\\r\\n\\t\\t\\t\\tTriangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\\r\\n\\r\\n\\t\\t\\t\\tuv1.multiplyScalar( barycoord.x );\\r\\n\\t\\t\\t\\tuv2.multiplyScalar( barycoord.y );\\r\\n\\t\\t\\t\\tuv3.multiplyScalar( barycoord.z );\\r\\n\\r\\n\\t\\t\\t\\tuv1.add( uv2 ).add( uv3 );\\r\\n\\r\\n\\t\\t\\t\\treturn uv1.clone();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfunction checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {\\r\\n\\r\\n\\t\\t\\t\\tvar intersect;\\r\\n\\r\\n\\t\\t\\t\\tif ( material.side === BackSide ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( intersect === null ) return null;\\r\\n\\r\\n\\t\\t\\t\\tintersectionPointWorld.copy( point );\\r\\n\\t\\t\\t\\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\\r\\n\\r\\n\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\\r\\n\\r\\n\\t\\t\\t\\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\\r\\n\\r\\n\\t\\t\\t\\treturn {\\r\\n\\t\\t\\t\\t\\tdistance: distance,\\r\\n\\t\\t\\t\\t\\tpoint: intersectionPointWorld.clone(),\\r\\n\\t\\t\\t\\t\\tobject: object\\r\\n\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfunction checkBufferGeometryIntersection( object, raycaster, ray, position, uv, a, b, c ) {\\r\\n\\r\\n\\t\\t\\t\\tvA.fromBufferAttribute( position, a );\\r\\n\\t\\t\\t\\tvB.fromBufferAttribute( position, b );\\r\\n\\t\\t\\t\\tvC.fromBufferAttribute( position, c );\\r\\n\\r\\n\\t\\t\\t\\tvar intersection = checkIntersection( object, object.material, raycaster, ray, vA, vB, vC, intersectionPoint );\\r\\n\\r\\n\\t\\t\\t\\tif ( intersection ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( uv ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tuvA.fromBufferAttribute( uv, a );\\r\\n\\t\\t\\t\\t\\t\\tuvB.fromBufferAttribute( uv, b );\\r\\n\\t\\t\\t\\t\\t\\tuvC.fromBufferAttribute( uv, c );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tintersection.uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tintersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );\\r\\n\\t\\t\\t\\t\\tintersection.faceIndex = a;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn intersection;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn function raycast( raycaster, intersects ) {\\r\\n\\r\\n\\t\\t\\t\\tvar geometry = this.geometry;\\r\\n\\t\\t\\t\\tvar material = this.material;\\r\\n\\t\\t\\t\\tvar matrixWorld = this.matrixWorld;\\r\\n\\r\\n\\t\\t\\t\\tif ( material === undefined ) return;\\r\\n\\r\\n\\t\\t\\t\\t// Checking boundingSphere distance to ray\\r\\n\\r\\n\\t\\t\\t\\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\\r\\n\\r\\n\\t\\t\\t\\tsphere.copy( geometry.boundingSphere );\\r\\n\\t\\t\\t\\tsphere.applyMatrix4( matrixWorld );\\r\\n\\r\\n\\t\\t\\t\\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\\r\\n\\r\\n\\t\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\t\\tinverseMatrix.getInverse( matrixWorld );\\r\\n\\t\\t\\t\\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\\r\\n\\r\\n\\t\\t\\t\\t// Check boundingBox before continuing\\r\\n\\r\\n\\t\\t\\t\\tif ( geometry.boundingBox !== null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tvar intersection;\\r\\n\\r\\n\\t\\t\\t\\tif ( geometry.isBufferGeometry ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar a, b, c;\\r\\n\\t\\t\\t\\t\\tvar index = geometry.index;\\r\\n\\t\\t\\t\\t\\tvar position = geometry.attributes.position;\\r\\n\\t\\t\\t\\t\\tvar uv = geometry.attributes.uv;\\r\\n\\t\\t\\t\\t\\tvar i, l;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( index !== null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// indexed buffer geometry\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( i = 0, l = index.count; i < l; i += 3 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\ta = index.getX( i );\\r\\n\\t\\t\\t\\t\\t\\t\\tb = index.getX( i + 1 );\\r\\n\\t\\t\\t\\t\\t\\t\\tc = index.getX( i + 2 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( intersection ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tintersects.push( intersection );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t} else if ( position !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// non-indexed buffer geometry\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( i = 0, l = position.count; i < l; i += 3 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\ta = i;\\r\\n\\t\\t\\t\\t\\t\\t\\tb = i + 1;\\r\\n\\t\\t\\t\\t\\t\\t\\tc = i + 2;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( intersection ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tintersection.index = a; // triangle number in positions buffer semantics\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tintersects.push( intersection );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else if ( geometry.isGeometry ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar fvA, fvB, fvC;\\r\\n\\t\\t\\t\\t\\tvar isMultiMaterial = Array.isArray( material );\\r\\n\\r\\n\\t\\t\\t\\t\\tvar vertices = geometry.vertices;\\r\\n\\t\\t\\t\\t\\tvar faces = geometry.faces;\\r\\n\\t\\t\\t\\t\\tvar uvs;\\r\\n\\r\\n\\t\\t\\t\\t\\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\\r\\n\\t\\t\\t\\t\\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar face = faces[ f ];\\r\\n\\t\\t\\t\\t\\t\\tvar faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( faceMaterial === undefined ) continue;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfvA = vertices[ face.a ];\\r\\n\\t\\t\\t\\t\\t\\tfvB = vertices[ face.b ];\\r\\n\\t\\t\\t\\t\\t\\tfvC = vertices[ face.c ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( faceMaterial.morphTargets === true ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar morphTargets = geometry.morphTargets;\\r\\n\\t\\t\\t\\t\\t\\t\\tvar morphInfluences = this.morphTargetInfluences;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvA.set( 0, 0, 0 );\\r\\n\\t\\t\\t\\t\\t\\t\\tvB.set( 0, 0, 0 );\\r\\n\\t\\t\\t\\t\\t\\t\\tvC.set( 0, 0, 0 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tvar influence = morphInfluences[ t ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( influence === 0 ) continue;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tvar targets = morphTargets[ t ].vertices;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tvA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tvB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tvC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvA.add( fvA );\\r\\n\\t\\t\\t\\t\\t\\t\\tvB.add( fvB );\\r\\n\\t\\t\\t\\t\\t\\t\\tvC.add( fvC );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tfvA = vA;\\r\\n\\t\\t\\t\\t\\t\\t\\tfvB = vB;\\r\\n\\t\\t\\t\\t\\t\\t\\tfvC = vC;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tintersection = checkIntersection( this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( intersection ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( uvs && uvs[ f ] ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tvar uvs_f = uvs[ f ];\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tuvA.copy( uvs_f[ 0 ] );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tuvB.copy( uvs_f[ 1 ] );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tuvC.copy( uvs_f[ 2 ] );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tintersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tintersection.face = face;\\r\\n\\t\\t\\t\\t\\t\\t\\tintersection.faceIndex = f;\\r\\n\\t\\t\\t\\t\\t\\t\\tintersects.push( intersection );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}() ),\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor( this.geometry, this.material ).copy( this );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction WebGLBackground( renderer, state, geometries, premultipliedAlpha ) {\\r\\n\\r\\n\\t\\tvar clearColor = new Color( 0x000000 );\\r\\n\\t\\tvar clearAlpha = 0;\\r\\n\\r\\n\\t\\tvar planeCamera, planeMesh;\\r\\n\\t\\tvar boxMesh;\\r\\n\\r\\n\\t\\tfunction render( renderList, scene, camera, forceClear ) {\\r\\n\\r\\n\\t\\t\\tvar background = scene.background;\\r\\n\\r\\n\\t\\t\\tif ( background === null ) {\\r\\n\\r\\n\\t\\t\\t\\tsetClear( clearColor, clearAlpha );\\r\\n\\r\\n\\t\\t\\t} else if ( background && background.isColor ) {\\r\\n\\r\\n\\t\\t\\t\\tsetClear( background, 1 );\\r\\n\\t\\t\\t\\tforceClear = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( renderer.autoClear || forceClear ) {\\r\\n\\r\\n\\t\\t\\t\\trenderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( background && background.isCubeTexture ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( boxMesh === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tboxMesh = new Mesh(\\r\\n\\t\\t\\t\\t\\t\\tnew BoxBufferGeometry( 1, 1, 1 ),\\r\\n\\t\\t\\t\\t\\t\\tnew ShaderMaterial( {\\r\\n\\t\\t\\t\\t\\t\\t\\tuniforms: ShaderLib.cube.uniforms,\\r\\n\\t\\t\\t\\t\\t\\t\\tvertexShader: ShaderLib.cube.vertexShader,\\r\\n\\t\\t\\t\\t\\t\\t\\tfragmentShader: ShaderLib.cube.fragmentShader,\\r\\n\\t\\t\\t\\t\\t\\t\\tside: BackSide,\\r\\n\\t\\t\\t\\t\\t\\t\\tdepthTest: true,\\r\\n\\t\\t\\t\\t\\t\\t\\tdepthWrite: false,\\r\\n\\t\\t\\t\\t\\t\\t\\tfog: false\\r\\n\\t\\t\\t\\t\\t\\t} )\\r\\n\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\tboxMesh.geometry.removeAttribute( 'normal' );\\r\\n\\t\\t\\t\\t\\tboxMesh.geometry.removeAttribute( 'uv' );\\r\\n\\r\\n\\t\\t\\t\\t\\tboxMesh.onBeforeRender = function ( renderer, scene, camera ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tthis.matrixWorld.copyPosition( camera.matrixWorld );\\r\\n\\r\\n\\t\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t\\t\\tgeometries.update( boxMesh.geometry );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tboxMesh.material.uniforms.tCube.value = background;\\r\\n\\r\\n\\t\\t\\t\\trenderList.push( boxMesh, boxMesh.geometry, boxMesh.material, 0, null );\\r\\n\\r\\n\\t\\t\\t} else if ( background && background.isTexture ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( planeCamera === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tplaneCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\\r\\n\\r\\n\\t\\t\\t\\t\\tplaneMesh = new Mesh(\\r\\n\\t\\t\\t\\t\\t\\tnew PlaneBufferGeometry( 2, 2 ),\\r\\n\\t\\t\\t\\t\\t\\tnew MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )\\r\\n\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\tgeometries.update( planeMesh.geometry );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tplaneMesh.material.map = background;\\r\\n\\r\\n\\t\\t\\t\\t// TODO Push this to renderList\\r\\n\\r\\n\\t\\t\\t\\trenderer.renderBufferDirect( planeCamera, null, planeMesh.geometry, planeMesh.material, planeMesh, null );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction setClear( color, alpha ) {\\r\\n\\r\\n\\t\\t\\tstate.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn {\\r\\n\\r\\n\\t\\t\\tgetClearColor: function () {\\r\\n\\r\\n\\t\\t\\t\\treturn clearColor;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tsetClearColor: function ( color, alpha ) {\\r\\n\\r\\n\\t\\t\\t\\tclearColor.set( color );\\r\\n\\t\\t\\t\\tclearAlpha = alpha !== undefined ? alpha : 1;\\r\\n\\t\\t\\t\\tsetClear( clearColor, clearAlpha );\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tgetClearAlpha: function () {\\r\\n\\r\\n\\t\\t\\t\\treturn clearAlpha;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tsetClearAlpha: function ( alpha ) {\\r\\n\\r\\n\\t\\t\\t\\tclearAlpha = alpha;\\r\\n\\t\\t\\t\\tsetClear( clearColor, clearAlpha );\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\trender: render\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction painterSortStable( a, b ) {\\r\\n\\r\\n\\t\\tif ( a.renderOrder !== b.renderOrder ) {\\r\\n\\r\\n\\t\\t\\treturn a.renderOrder - b.renderOrder;\\r\\n\\r\\n\\t\\t} else if ( a.program && b.program && a.program !== b.program ) {\\r\\n\\r\\n\\t\\t\\treturn a.program.id - b.program.id;\\r\\n\\r\\n\\t\\t} else if ( a.material.id !== b.material.id ) {\\r\\n\\r\\n\\t\\t\\treturn a.material.id - b.material.id;\\r\\n\\r\\n\\t\\t} else if ( a.z !== b.z ) {\\r\\n\\r\\n\\t\\t\\treturn a.z - b.z;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\treturn a.id - b.id;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction reversePainterSortStable( a, b ) {\\r\\n\\r\\n\\t\\tif ( a.renderOrder !== b.renderOrder ) {\\r\\n\\r\\n\\t\\t\\treturn a.renderOrder - b.renderOrder;\\r\\n\\r\\n\\t\\t} if ( a.z !== b.z ) {\\r\\n\\r\\n\\t\\t\\treturn b.z - a.z;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\treturn a.id - b.id;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction WebGLRenderList() {\\r\\n\\r\\n\\t\\tvar renderItems = [];\\r\\n\\t\\tvar renderItemsIndex = 0;\\r\\n\\r\\n\\t\\tvar opaque = [];\\r\\n\\t\\tvar transparent = [];\\r\\n\\r\\n\\t\\tfunction init() {\\r\\n\\r\\n\\t\\t\\trenderItemsIndex = 0;\\r\\n\\r\\n\\t\\t\\topaque.length = 0;\\r\\n\\t\\t\\ttransparent.length = 0;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction push( object, geometry, material, z, group ) {\\r\\n\\r\\n\\t\\t\\tvar renderItem = renderItems[ renderItemsIndex ];\\r\\n\\r\\n\\t\\t\\tif ( renderItem === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\trenderItem = {\\r\\n\\t\\t\\t\\t\\tid: object.id,\\r\\n\\t\\t\\t\\t\\tobject: object,\\r\\n\\t\\t\\t\\t\\tgeometry: geometry,\\r\\n\\t\\t\\t\\t\\tmaterial: material,\\r\\n\\t\\t\\t\\t\\tprogram: material.program,\\r\\n\\t\\t\\t\\t\\trenderOrder: object.renderOrder,\\r\\n\\t\\t\\t\\t\\tz: z,\\r\\n\\t\\t\\t\\t\\tgroup: group\\r\\n\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t\\trenderItems[ renderItemsIndex ] = renderItem;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\trenderItem.id = object.id;\\r\\n\\t\\t\\t\\trenderItem.object = object;\\r\\n\\t\\t\\t\\trenderItem.geometry = geometry;\\r\\n\\t\\t\\t\\trenderItem.material = material;\\r\\n\\t\\t\\t\\trenderItem.program = material.program;\\r\\n\\t\\t\\t\\trenderItem.renderOrder = object.renderOrder;\\r\\n\\t\\t\\t\\trenderItem.z = z;\\r\\n\\t\\t\\t\\trenderItem.group = group;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t( material.transparent === true ? transparent : opaque ).push( renderItem );\\r\\n\\r\\n\\t\\t\\trenderItemsIndex ++;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction sort() {\\r\\n\\r\\n\\t\\t\\tif ( opaque.length > 1 ) opaque.sort( painterSortStable );\\r\\n\\t\\t\\tif ( transparent.length > 1 ) transparent.sort( reversePainterSortStable );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn {\\r\\n\\t\\t\\topaque: opaque,\\r\\n\\t\\t\\ttransparent: transparent,\\r\\n\\r\\n\\t\\t\\tinit: init,\\r\\n\\t\\t\\tpush: push,\\r\\n\\r\\n\\t\\t\\tsort: sort\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction WebGLRenderLists() {\\r\\n\\r\\n\\t\\tvar lists = {};\\r\\n\\r\\n\\t\\tfunction get( scene, camera ) {\\r\\n\\r\\n\\t\\t\\tvar hash = scene.id + ',' + camera.id;\\r\\n\\t\\t\\tvar list = lists[ hash ];\\r\\n\\r\\n\\t\\t\\tif ( list === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t// console.log( 'THREE.WebGLRenderLists:', hash );\\r\\n\\r\\n\\t\\t\\t\\tlist = new WebGLRenderList();\\r\\n\\t\\t\\t\\tlists[ hash ] = list;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn list;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction dispose() {\\r\\n\\r\\n\\t\\t\\tlists = {};\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn {\\r\\n\\t\\t\\tget: get,\\r\\n\\t\\t\\tdispose: dispose\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction absNumericalSort( a, b ) {\\r\\n\\r\\n\\t\\treturn Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction WebGLMorphtargets( gl ) {\\r\\n\\r\\n\\t\\tvar influencesList = {};\\r\\n\\t\\tvar morphInfluences = new Float32Array( 8 );\\r\\n\\r\\n\\t\\tfunction update( object, geometry, material, program ) {\\r\\n\\r\\n\\t\\t\\tvar objectInfluences = object.morphTargetInfluences;\\r\\n\\r\\n\\t\\t\\tvar length = objectInfluences.length;\\r\\n\\r\\n\\t\\t\\tvar influences = influencesList[ geometry.id ];\\r\\n\\r\\n\\t\\t\\tif ( influences === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t// initialise list\\r\\n\\r\\n\\t\\t\\t\\tinfluences = [];\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0; i < length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tinfluences[ i ] = [ i, 0 ];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tinfluencesList[ geometry.id ] = influences;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar morphTargets = material.morphTargets && geometry.morphAttributes.position;\\r\\n\\t\\t\\tvar morphNormals = material.morphNormals && geometry.morphAttributes.normal;\\r\\n\\r\\n\\t\\t\\t// Remove current morphAttributes\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar influence = influences[ i ];\\r\\n\\r\\n\\t\\t\\t\\tif ( influence[ 1 ] !== 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( morphTargets ) geometry.removeAttribute( 'morphTarget' + i );\\r\\n\\t\\t\\t\\t\\tif ( morphNormals ) geometry.removeAttribute( 'morphNormal' + i );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// Collect influences\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar influence = influences[ i ];\\r\\n\\r\\n\\t\\t\\t\\tinfluence[ 0 ] = i;\\r\\n\\t\\t\\t\\tinfluence[ 1 ] = objectInfluences[ i ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tinfluences.sort( absNumericalSort );\\r\\n\\r\\n\\t\\t\\t// Add morphAttributes\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < 8; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar influence = influences[ i ];\\r\\n\\r\\n\\t\\t\\t\\tif ( influence ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar index = influence[ 0 ];\\r\\n\\t\\t\\t\\t\\tvar value = influence[ 1 ];\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( value ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( morphTargets ) geometry.addAttribute( 'morphTarget' + i, morphTargets[ index ] );\\r\\n\\t\\t\\t\\t\\t\\tif ( morphNormals ) geometry.addAttribute( 'morphNormal' + i, morphNormals[ index ] );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tmorphInfluences[ i ] = value;\\r\\n\\t\\t\\t\\t\\t\\tcontinue;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tmorphInfluences[ i ] = 0;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tprogram.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn {\\r\\n\\r\\n\\t\\t\\tupdate: update\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {\\r\\n\\r\\n\\t\\tvar mode;\\r\\n\\r\\n\\t\\tfunction setMode( value ) {\\r\\n\\r\\n\\t\\t\\tmode = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar type, bytesPerElement;\\r\\n\\r\\n\\t\\tfunction setIndex( value ) {\\r\\n\\r\\n\\t\\t\\ttype = value.type;\\r\\n\\t\\t\\tbytesPerElement = value.bytesPerElement;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction render( start, count ) {\\r\\n\\r\\n\\t\\t\\tgl.drawElements( mode, count, type, start * bytesPerElement );\\r\\n\\r\\n\\t\\t\\tinfoRender.calls ++;\\r\\n\\t\\t\\tinfoRender.vertices += count;\\r\\n\\r\\n\\t\\t\\tif ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;\\r\\n\\t\\t\\telse if ( mode === gl.POINTS ) infoRender.points += count;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction renderInstances( geometry, start, count ) {\\r\\n\\r\\n\\t\\t\\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\\r\\n\\r\\n\\t\\t\\tif ( extension === null ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\\r\\n\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\textension.drawElementsInstancedANGLE( mode, count, type, start * bytesPerElement, geometry.maxInstancedCount );\\r\\n\\r\\n\\t\\t\\tinfoRender.calls ++;\\r\\n\\t\\t\\tinfoRender.vertices += count * geometry.maxInstancedCount;\\r\\n\\r\\n\\t\\t\\tif ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;\\r\\n\\t\\t\\telse if ( mode === gl.POINTS ) infoRender.points += geometry.maxInstancedCount * count;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tthis.setMode = setMode;\\r\\n\\t\\tthis.setIndex = setIndex;\\r\\n\\t\\tthis.render = render;\\r\\n\\t\\tthis.renderInstances = renderInstances;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction WebGLBufferRenderer( gl, extensions, infoRender ) {\\r\\n\\r\\n\\t\\tvar mode;\\r\\n\\r\\n\\t\\tfunction setMode( value ) {\\r\\n\\r\\n\\t\\t\\tmode = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction render( start, count ) {\\r\\n\\r\\n\\t\\t\\tgl.drawArrays( mode, start, count );\\r\\n\\r\\n\\t\\t\\tinfoRender.calls ++;\\r\\n\\t\\t\\tinfoRender.vertices += count;\\r\\n\\r\\n\\t\\t\\tif ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;\\r\\n\\t\\t\\telse if ( mode === gl.POINTS ) infoRender.points += count;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction renderInstances( geometry, start, count ) {\\r\\n\\r\\n\\t\\t\\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\\r\\n\\r\\n\\t\\t\\tif ( extension === null ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\\r\\n\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar position = geometry.attributes.position;\\r\\n\\r\\n\\t\\t\\tif ( position.isInterleavedBufferAttribute ) {\\r\\n\\r\\n\\t\\t\\t\\tcount = position.data.count;\\r\\n\\r\\n\\t\\t\\t\\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\textension.drawArraysInstancedANGLE( mode, start, count, geometry.maxInstancedCount );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tinfoRender.calls ++;\\r\\n\\t\\t\\tinfoRender.vertices += count * geometry.maxInstancedCount;\\r\\n\\r\\n\\t\\t\\tif ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;\\r\\n\\t\\t\\telse if ( mode === gl.POINTS ) infoRender.points += geometry.maxInstancedCount * count;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tthis.setMode = setMode;\\r\\n\\t\\tthis.render = render;\\r\\n\\t\\tthis.renderInstances = renderInstances;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction WebGLGeometries( gl, attributes, infoMemory ) {\\r\\n\\r\\n\\t\\tvar geometries = {};\\r\\n\\t\\tvar wireframeAttributes = {};\\r\\n\\r\\n\\t\\tfunction onGeometryDispose( event ) {\\r\\n\\r\\n\\t\\t\\tvar geometry = event.target;\\r\\n\\t\\t\\tvar buffergeometry = geometries[ geometry.id ];\\r\\n\\r\\n\\t\\t\\tif ( buffergeometry.index !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tattributes.remove( buffergeometry.index );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfor ( var name in buffergeometry.attributes ) {\\r\\n\\r\\n\\t\\t\\t\\tattributes.remove( buffergeometry.attributes[ name ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\\r\\n\\r\\n\\t\\t\\tdelete geometries[ geometry.id ];\\r\\n\\r\\n\\t\\t\\t// TODO Remove duplicate code\\r\\n\\r\\n\\t\\t\\tvar attribute = wireframeAttributes[ geometry.id ];\\r\\n\\r\\n\\t\\t\\tif ( attribute ) {\\r\\n\\r\\n\\t\\t\\t\\tattributes.remove( attribute );\\r\\n\\t\\t\\t\\tdelete wireframeAttributes[ geometry.id ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tattribute = wireframeAttributes[ buffergeometry.id ];\\r\\n\\r\\n\\t\\t\\tif ( attribute ) {\\r\\n\\r\\n\\t\\t\\t\\tattributes.remove( attribute );\\r\\n\\t\\t\\t\\tdelete wireframeAttributes[ buffergeometry.id ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\tinfoMemory.geometries --;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction get( object, geometry ) {\\r\\n\\r\\n\\t\\t\\tvar buffergeometry = geometries[ geometry.id ];\\r\\n\\r\\n\\t\\t\\tif ( buffergeometry ) return buffergeometry;\\r\\n\\r\\n\\t\\t\\tgeometry.addEventListener( 'dispose', onGeometryDispose );\\r\\n\\r\\n\\t\\t\\tif ( geometry.isBufferGeometry ) {\\r\\n\\r\\n\\t\\t\\t\\tbuffergeometry = geometry;\\r\\n\\r\\n\\t\\t\\t} else if ( geometry.isGeometry ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( geometry._bufferGeometry === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tgeometry._bufferGeometry = new BufferGeometry().setFromObject( object );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tbuffergeometry = geometry._bufferGeometry;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tgeometries[ geometry.id ] = buffergeometry;\\r\\n\\r\\n\\t\\t\\tinfoMemory.geometries ++;\\r\\n\\r\\n\\t\\t\\treturn buffergeometry;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction update( geometry ) {\\r\\n\\r\\n\\t\\t\\tvar index = geometry.index;\\r\\n\\t\\t\\tvar geometryAttributes = geometry.attributes;\\r\\n\\r\\n\\t\\t\\tif ( index !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tattributes.update( index, gl.ELEMENT_ARRAY_BUFFER );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfor ( var name in geometryAttributes ) {\\r\\n\\r\\n\\t\\t\\t\\tattributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// morph targets\\r\\n\\r\\n\\t\\t\\tvar morphAttributes = geometry.morphAttributes;\\r\\n\\r\\n\\t\\t\\tfor ( var name in morphAttributes ) {\\r\\n\\r\\n\\t\\t\\t\\tvar array = morphAttributes[ name ];\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tattributes.update( array[ i ], gl.ARRAY_BUFFER );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction getWireframeAttribute( geometry ) {\\r\\n\\r\\n\\t\\t\\tvar attribute = wireframeAttributes[ geometry.id ];\\r\\n\\r\\n\\t\\t\\tif ( attribute ) return attribute;\\r\\n\\r\\n\\t\\t\\tvar indices = [];\\r\\n\\r\\n\\t\\t\\tvar geometryIndex = geometry.index;\\r\\n\\t\\t\\tvar geometryAttributes = geometry.attributes;\\r\\n\\r\\n\\t\\t\\t// console.time( 'wireframe' );\\r\\n\\r\\n\\t\\t\\tif ( geometryIndex !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tvar array = geometryIndex.array;\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar a = array[ i + 0 ];\\r\\n\\t\\t\\t\\t\\tvar b = array[ i + 1 ];\\r\\n\\t\\t\\t\\t\\tvar c = array[ i + 2 ];\\r\\n\\r\\n\\t\\t\\t\\t\\tindices.push( a, b, b, c, c, a );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tvar array = geometryAttributes.position.array;\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar a = i + 0;\\r\\n\\t\\t\\t\\t\\tvar b = i + 1;\\r\\n\\t\\t\\t\\t\\tvar c = i + 2;\\r\\n\\r\\n\\t\\t\\t\\t\\tindices.push( a, b, b, c, c, a );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// console.timeEnd( 'wireframe' );\\r\\n\\r\\n\\t\\t\\tattribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );\\r\\n\\r\\n\\t\\t\\tattributes.update( attribute, gl.ELEMENT_ARRAY_BUFFER );\\r\\n\\r\\n\\t\\t\\twireframeAttributes[ geometry.id ] = attribute;\\r\\n\\r\\n\\t\\t\\treturn attribute;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn {\\r\\n\\r\\n\\t\\t\\tget: get,\\r\\n\\t\\t\\tupdate: update,\\r\\n\\r\\n\\t\\t\\tgetWireframeAttribute: getWireframeAttribute\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction UniformsCache() {\\r\\n\\r\\n\\t\\tvar lights = {};\\r\\n\\r\\n\\t\\treturn {\\r\\n\\r\\n\\t\\t\\tget: function ( light ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( lights[ light.id ] !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn lights[ light.id ];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tvar uniforms;\\r\\n\\r\\n\\t\\t\\t\\tswitch ( light.type ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'DirectionalLight':\\r\\n\\t\\t\\t\\t\\t\\tuniforms = {\\r\\n\\t\\t\\t\\t\\t\\t\\tdirection: new Vector3(),\\r\\n\\t\\t\\t\\t\\t\\t\\tcolor: new Color(),\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tshadow: false,\\r\\n\\t\\t\\t\\t\\t\\t\\tshadowBias: 0,\\r\\n\\t\\t\\t\\t\\t\\t\\tshadowRadius: 1,\\r\\n\\t\\t\\t\\t\\t\\t\\tshadowMapSize: new Vector2()\\r\\n\\t\\t\\t\\t\\t\\t};\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'SpotLight':\\r\\n\\t\\t\\t\\t\\t\\tuniforms = {\\r\\n\\t\\t\\t\\t\\t\\t\\tposition: new Vector3(),\\r\\n\\t\\t\\t\\t\\t\\t\\tdirection: new Vector3(),\\r\\n\\t\\t\\t\\t\\t\\t\\tcolor: new Color(),\\r\\n\\t\\t\\t\\t\\t\\t\\tdistance: 0,\\r\\n\\t\\t\\t\\t\\t\\t\\tconeCos: 0,\\r\\n\\t\\t\\t\\t\\t\\t\\tpenumbraCos: 0,\\r\\n\\t\\t\\t\\t\\t\\t\\tdecay: 0,\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tshadow: false,\\r\\n\\t\\t\\t\\t\\t\\t\\tshadowBias: 0,\\r\\n\\t\\t\\t\\t\\t\\t\\tshadowRadius: 1,\\r\\n\\t\\t\\t\\t\\t\\t\\tshadowMapSize: new Vector2()\\r\\n\\t\\t\\t\\t\\t\\t};\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'PointLight':\\r\\n\\t\\t\\t\\t\\t\\tuniforms = {\\r\\n\\t\\t\\t\\t\\t\\t\\tposition: new Vector3(),\\r\\n\\t\\t\\t\\t\\t\\t\\tcolor: new Color(),\\r\\n\\t\\t\\t\\t\\t\\t\\tdistance: 0,\\r\\n\\t\\t\\t\\t\\t\\t\\tdecay: 0,\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tshadow: false,\\r\\n\\t\\t\\t\\t\\t\\t\\tshadowBias: 0,\\r\\n\\t\\t\\t\\t\\t\\t\\tshadowRadius: 1,\\r\\n\\t\\t\\t\\t\\t\\t\\tshadowMapSize: new Vector2(),\\r\\n\\t\\t\\t\\t\\t\\t\\tshadowCameraNear: 1,\\r\\n\\t\\t\\t\\t\\t\\t\\tshadowCameraFar: 1000\\r\\n\\t\\t\\t\\t\\t\\t};\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'HemisphereLight':\\r\\n\\t\\t\\t\\t\\t\\tuniforms = {\\r\\n\\t\\t\\t\\t\\t\\t\\tdirection: new Vector3(),\\r\\n\\t\\t\\t\\t\\t\\t\\tskyColor: new Color(),\\r\\n\\t\\t\\t\\t\\t\\t\\tgroundColor: new Color()\\r\\n\\t\\t\\t\\t\\t\\t};\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'RectAreaLight':\\r\\n\\t\\t\\t\\t\\t\\tuniforms = {\\r\\n\\t\\t\\t\\t\\t\\t\\tcolor: new Color(),\\r\\n\\t\\t\\t\\t\\t\\t\\tposition: new Vector3(),\\r\\n\\t\\t\\t\\t\\t\\t\\thalfWidth: new Vector3(),\\r\\n\\t\\t\\t\\t\\t\\t\\thalfHeight: new Vector3()\\r\\n\\t\\t\\t\\t\\t\\t\\t// TODO (abelnation): set RectAreaLight shadow uniforms\\r\\n\\t\\t\\t\\t\\t\\t};\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tlights[ light.id ] = uniforms;\\r\\n\\r\\n\\t\\t\\t\\treturn uniforms;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction WebGLLights() {\\r\\n\\r\\n\\t\\tvar cache = new UniformsCache();\\r\\n\\r\\n\\t\\tvar state = {\\r\\n\\r\\n\\t\\t\\thash: '',\\r\\n\\r\\n\\t\\t\\tambient: [ 0, 0, 0 ],\\r\\n\\t\\t\\tdirectional: [],\\r\\n\\t\\t\\tdirectionalShadowMap: [],\\r\\n\\t\\t\\tdirectionalShadowMatrix: [],\\r\\n\\t\\t\\tspot: [],\\r\\n\\t\\t\\tspotShadowMap: [],\\r\\n\\t\\t\\tspotShadowMatrix: [],\\r\\n\\t\\t\\trectArea: [],\\r\\n\\t\\t\\tpoint: [],\\r\\n\\t\\t\\tpointShadowMap: [],\\r\\n\\t\\t\\tpointShadowMatrix: [],\\r\\n\\t\\t\\themi: []\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tvar vector3 = new Vector3();\\r\\n\\t\\tvar matrix4 = new Matrix4();\\r\\n\\t\\tvar matrix42 = new Matrix4();\\r\\n\\r\\n\\t\\tfunction setup( lights, shadows, camera ) {\\r\\n\\r\\n\\t\\t\\tvar r = 0, g = 0, b = 0;\\r\\n\\r\\n\\t\\t\\tvar directionalLength = 0;\\r\\n\\t\\t\\tvar pointLength = 0;\\r\\n\\t\\t\\tvar spotLength = 0;\\r\\n\\t\\t\\tvar rectAreaLength = 0;\\r\\n\\t\\t\\tvar hemiLength = 0;\\r\\n\\r\\n\\t\\t\\tvar viewMatrix = camera.matrixWorldInverse;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar light = lights[ i ];\\r\\n\\r\\n\\t\\t\\t\\tvar color = light.color;\\r\\n\\t\\t\\t\\tvar intensity = light.intensity;\\r\\n\\t\\t\\t\\tvar distance = light.distance;\\r\\n\\r\\n\\t\\t\\t\\tvar shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\\r\\n\\r\\n\\t\\t\\t\\tif ( light.isAmbientLight ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tr += color.r * intensity;\\r\\n\\t\\t\\t\\t\\tg += color.g * intensity;\\r\\n\\t\\t\\t\\t\\tb += color.b * intensity;\\r\\n\\r\\n\\t\\t\\t\\t} else if ( light.isDirectionalLight ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar uniforms = cache.get( light );\\r\\n\\r\\n\\t\\t\\t\\t\\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\\r\\n\\t\\t\\t\\t\\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\\r\\n\\t\\t\\t\\t\\tvector3.setFromMatrixPosition( light.target.matrixWorld );\\r\\n\\t\\t\\t\\t\\tuniforms.direction.sub( vector3 );\\r\\n\\t\\t\\t\\t\\tuniforms.direction.transformDirection( viewMatrix );\\r\\n\\r\\n\\t\\t\\t\\t\\tuniforms.shadow = light.castShadow;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( light.castShadow ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar shadow = light.shadow;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tuniforms.shadowBias = shadow.bias;\\r\\n\\t\\t\\t\\t\\t\\tuniforms.shadowRadius = shadow.radius;\\r\\n\\t\\t\\t\\t\\t\\tuniforms.shadowMapSize = shadow.mapSize;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tstate.directionalShadowMap[ directionalLength ] = shadowMap;\\r\\n\\t\\t\\t\\t\\tstate.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\\r\\n\\t\\t\\t\\t\\tstate.directional[ directionalLength ] = uniforms;\\r\\n\\r\\n\\t\\t\\t\\t\\tdirectionalLength ++;\\r\\n\\r\\n\\t\\t\\t\\t} else if ( light.isSpotLight ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar uniforms = cache.get( light );\\r\\n\\r\\n\\t\\t\\t\\t\\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\\r\\n\\t\\t\\t\\t\\tuniforms.position.applyMatrix4( viewMatrix );\\r\\n\\r\\n\\t\\t\\t\\t\\tuniforms.color.copy( color ).multiplyScalar( intensity );\\r\\n\\t\\t\\t\\t\\tuniforms.distance = distance;\\r\\n\\r\\n\\t\\t\\t\\t\\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\\r\\n\\t\\t\\t\\t\\tvector3.setFromMatrixPosition( light.target.matrixWorld );\\r\\n\\t\\t\\t\\t\\tuniforms.direction.sub( vector3 );\\r\\n\\t\\t\\t\\t\\tuniforms.direction.transformDirection( viewMatrix );\\r\\n\\r\\n\\t\\t\\t\\t\\tuniforms.coneCos = Math.cos( light.angle );\\r\\n\\t\\t\\t\\t\\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\\r\\n\\t\\t\\t\\t\\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\\r\\n\\r\\n\\t\\t\\t\\t\\tuniforms.shadow = light.castShadow;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( light.castShadow ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar shadow = light.shadow;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tuniforms.shadowBias = shadow.bias;\\r\\n\\t\\t\\t\\t\\t\\tuniforms.shadowRadius = shadow.radius;\\r\\n\\t\\t\\t\\t\\t\\tuniforms.shadowMapSize = shadow.mapSize;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tstate.spotShadowMap[ spotLength ] = shadowMap;\\r\\n\\t\\t\\t\\t\\tstate.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\\r\\n\\t\\t\\t\\t\\tstate.spot[ spotLength ] = uniforms;\\r\\n\\r\\n\\t\\t\\t\\t\\tspotLength ++;\\r\\n\\r\\n\\t\\t\\t\\t} else if ( light.isRectAreaLight ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar uniforms = cache.get( light );\\r\\n\\r\\n\\t\\t\\t\\t\\t// (a) intensity controls irradiance of entire light\\r\\n\\t\\t\\t\\t\\tuniforms.color\\r\\n\\t\\t\\t\\t\\t\\t.copy( color )\\r\\n\\t\\t\\t\\t\\t\\t.multiplyScalar( intensity / ( light.width * light.height ) );\\r\\n\\r\\n\\t\\t\\t\\t\\t// (b) intensity controls the radiance per light area\\r\\n\\t\\t\\t\\t\\t// uniforms.color.copy( color ).multiplyScalar( intensity );\\r\\n\\r\\n\\t\\t\\t\\t\\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\\r\\n\\t\\t\\t\\t\\tuniforms.position.applyMatrix4( viewMatrix );\\r\\n\\r\\n\\t\\t\\t\\t\\t// extract local rotation of light to derive width/height half vectors\\r\\n\\t\\t\\t\\t\\tmatrix42.identity();\\r\\n\\t\\t\\t\\t\\tmatrix4.copy( light.matrixWorld );\\r\\n\\t\\t\\t\\t\\tmatrix4.premultiply( viewMatrix );\\r\\n\\t\\t\\t\\t\\tmatrix42.extractRotation( matrix4 );\\r\\n\\r\\n\\t\\t\\t\\t\\tuniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );\\r\\n\\t\\t\\t\\t\\tuniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );\\r\\n\\r\\n\\t\\t\\t\\t\\tuniforms.halfWidth.applyMatrix4( matrix42 );\\r\\n\\t\\t\\t\\t\\tuniforms.halfHeight.applyMatrix4( matrix42 );\\r\\n\\r\\n\\t\\t\\t\\t\\t// TODO (abelnation): RectAreaLight distance?\\r\\n\\t\\t\\t\\t\\t// uniforms.distance = distance;\\r\\n\\r\\n\\t\\t\\t\\t\\tstate.rectArea[ rectAreaLength ] = uniforms;\\r\\n\\r\\n\\t\\t\\t\\t\\trectAreaLength ++;\\r\\n\\r\\n\\t\\t\\t\\t} else if ( light.isPointLight ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar uniforms = cache.get( light );\\r\\n\\r\\n\\t\\t\\t\\t\\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\\r\\n\\t\\t\\t\\t\\tuniforms.position.applyMatrix4( viewMatrix );\\r\\n\\r\\n\\t\\t\\t\\t\\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\\r\\n\\t\\t\\t\\t\\tuniforms.distance = light.distance;\\r\\n\\t\\t\\t\\t\\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\\r\\n\\r\\n\\t\\t\\t\\t\\tuniforms.shadow = light.castShadow;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( light.castShadow ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar shadow = light.shadow;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tuniforms.shadowBias = shadow.bias;\\r\\n\\t\\t\\t\\t\\t\\tuniforms.shadowRadius = shadow.radius;\\r\\n\\t\\t\\t\\t\\t\\tuniforms.shadowMapSize = shadow.mapSize;\\r\\n\\t\\t\\t\\t\\t\\tuniforms.shadowCameraNear = shadow.camera.near;\\r\\n\\t\\t\\t\\t\\t\\tuniforms.shadowCameraFar = shadow.camera.far;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tstate.pointShadowMap[ pointLength ] = shadowMap;\\r\\n\\t\\t\\t\\t\\tstate.pointShadowMatrix[ pointLength ] = light.shadow.matrix;\\r\\n\\t\\t\\t\\t\\tstate.point[ pointLength ] = uniforms;\\r\\n\\r\\n\\t\\t\\t\\t\\tpointLength ++;\\r\\n\\r\\n\\t\\t\\t\\t} else if ( light.isHemisphereLight ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar uniforms = cache.get( light );\\r\\n\\r\\n\\t\\t\\t\\t\\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\\r\\n\\t\\t\\t\\t\\tuniforms.direction.transformDirection( viewMatrix );\\r\\n\\t\\t\\t\\t\\tuniforms.direction.normalize();\\r\\n\\r\\n\\t\\t\\t\\t\\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\\r\\n\\t\\t\\t\\t\\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\\r\\n\\r\\n\\t\\t\\t\\t\\tstate.hemi[ hemiLength ] = uniforms;\\r\\n\\r\\n\\t\\t\\t\\t\\themiLength ++;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tstate.ambient[ 0 ] = r;\\r\\n\\t\\t\\tstate.ambient[ 1 ] = g;\\r\\n\\t\\t\\tstate.ambient[ 2 ] = b;\\r\\n\\r\\n\\t\\t\\tstate.directional.length = directionalLength;\\r\\n\\t\\t\\tstate.spot.length = spotLength;\\r\\n\\t\\t\\tstate.rectArea.length = rectAreaLength;\\r\\n\\t\\t\\tstate.point.length = pointLength;\\r\\n\\t\\t\\tstate.hemi.length = hemiLength;\\r\\n\\r\\n\\t\\t\\t// TODO (sam-g-steel) why aren't we using join\\r\\n\\t\\t\\tstate.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + rectAreaLength + ',' + hemiLength + ',' + shadows.length;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn {\\r\\n\\t\\t\\tsetup: setup,\\r\\n\\t\\t\\tstate: state\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction WebGLObjects( geometries, infoRender ) {\\r\\n\\r\\n\\t\\tvar updateList = {};\\r\\n\\r\\n\\t\\tfunction update( object ) {\\r\\n\\r\\n\\t\\t\\tvar frame = infoRender.frame;\\r\\n\\r\\n\\t\\t\\tvar geometry = object.geometry;\\r\\n\\t\\t\\tvar buffergeometry = geometries.get( object, geometry );\\r\\n\\r\\n\\t\\t\\t// Update once per frame\\r\\n\\r\\n\\t\\t\\tif ( updateList[ buffergeometry.id ] !== frame ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( geometry.isGeometry ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tbuffergeometry.updateFromObject( object );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tgeometries.update( buffergeometry );\\r\\n\\r\\n\\t\\t\\t\\tupdateList[ buffergeometry.id ] = frame;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn buffergeometry;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction clear() {\\r\\n\\r\\n\\t\\t\\tupdateList = {};\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn {\\r\\n\\r\\n\\t\\t\\tupdate: update,\\r\\n\\t\\t\\tclear: clear\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction addLineNumbers( string ) {\\r\\n\\r\\n\\t\\tvar lines = string.split( '\\\\n' );\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < lines.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn lines.join( '\\\\n' );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction WebGLShader( gl, type, string ) {\\r\\n\\r\\n\\t\\tvar shader = gl.createShader( type );\\r\\n\\r\\n\\t\\tgl.shaderSource( shader, string );\\r\\n\\t\\tgl.compileShader( shader );\\r\\n\\r\\n\\t\\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.WebGLShader: Shader couldn\\\\'t compile.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// --enable-privileged-webgl-extension\\r\\n\\t\\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\\r\\n\\r\\n\\t\\treturn shader;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tvar programIdCount = 0;\\r\\n\\r\\n\\tfunction getEncodingComponents( encoding ) {\\r\\n\\r\\n\\t\\tswitch ( encoding ) {\\r\\n\\r\\n\\t\\t\\tcase LinearEncoding:\\r\\n\\t\\t\\t\\treturn [ 'Linear', '( value )' ];\\r\\n\\t\\t\\tcase sRGBEncoding:\\r\\n\\t\\t\\t\\treturn [ 'sRGB', '( value )' ];\\r\\n\\t\\t\\tcase RGBEEncoding:\\r\\n\\t\\t\\t\\treturn [ 'RGBE', '( value )' ];\\r\\n\\t\\t\\tcase RGBM7Encoding:\\r\\n\\t\\t\\t\\treturn [ 'RGBM', '( value, 7.0 )' ];\\r\\n\\t\\t\\tcase RGBM16Encoding:\\r\\n\\t\\t\\t\\treturn [ 'RGBM', '( value, 16.0 )' ];\\r\\n\\t\\t\\tcase RGBDEncoding:\\r\\n\\t\\t\\t\\treturn [ 'RGBD', '( value, 256.0 )' ];\\r\\n\\t\\t\\tcase GammaEncoding:\\r\\n\\t\\t\\t\\treturn [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];\\r\\n\\t\\t\\tdefault:\\r\\n\\t\\t\\t\\tthrow new Error( 'unsupported encoding: ' + encoding );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction getTexelDecodingFunction( functionName, encoding ) {\\r\\n\\r\\n\\t\\tvar components = getEncodingComponents( encoding );\\r\\n\\t\\treturn 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction getTexelEncodingFunction( functionName, encoding ) {\\r\\n\\r\\n\\t\\tvar components = getEncodingComponents( encoding );\\r\\n\\t\\treturn 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction getToneMappingFunction( functionName, toneMapping ) {\\r\\n\\r\\n\\t\\tvar toneMappingName;\\r\\n\\r\\n\\t\\tswitch ( toneMapping ) {\\r\\n\\r\\n\\t\\t\\tcase LinearToneMapping:\\r\\n\\t\\t\\t\\ttoneMappingName = 'Linear';\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase ReinhardToneMapping:\\r\\n\\t\\t\\t\\ttoneMappingName = 'Reinhard';\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase Uncharted2ToneMapping:\\r\\n\\t\\t\\t\\ttoneMappingName = 'Uncharted2';\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase CineonToneMapping:\\r\\n\\t\\t\\t\\ttoneMappingName = 'OptimizedCineon';\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tdefault:\\r\\n\\t\\t\\t\\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction generateExtensions( extensions, parameters, rendererExtensions ) {\\r\\n\\r\\n\\t\\textensions = extensions || {};\\r\\n\\r\\n\\t\\tvar chunks = [\\r\\n\\t\\t\\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\\r\\n\\t\\t\\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\\r\\n\\t\\t\\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\\r\\n\\t\\t\\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''\\r\\n\\t\\t];\\r\\n\\r\\n\\t\\treturn chunks.filter( filterEmptyLine ).join( '\\\\n' );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction generateDefines( defines ) {\\r\\n\\r\\n\\t\\tvar chunks = [];\\r\\n\\r\\n\\t\\tfor ( var name in defines ) {\\r\\n\\r\\n\\t\\t\\tvar value = defines[ name ];\\r\\n\\r\\n\\t\\t\\tif ( value === false ) continue;\\r\\n\\r\\n\\t\\t\\tchunks.push( '#define ' + name + ' ' + value );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn chunks.join( '\\\\n' );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction fetchAttributeLocations( gl, program ) {\\r\\n\\r\\n\\t\\tvar attributes = {};\\r\\n\\r\\n\\t\\tvar n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < n; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar info = gl.getActiveAttrib( program, i );\\r\\n\\t\\t\\tvar name = info.name;\\r\\n\\r\\n\\t\\t\\t// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );\\r\\n\\r\\n\\t\\t\\tattributes[ name ] = gl.getAttribLocation( program, name );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn attributes;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction filterEmptyLine( string ) {\\r\\n\\r\\n\\t\\treturn string !== '';\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction replaceLightNums( string, parameters ) {\\r\\n\\r\\n\\t\\treturn string\\r\\n\\t\\t\\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\\r\\n\\t\\t\\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\\r\\n\\t\\t\\t.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )\\r\\n\\t\\t\\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\\r\\n\\t\\t\\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction parseIncludes( string ) {\\r\\n\\r\\n\\t\\tvar pattern = /^[ \\\\t]*#include +<([\\\\w\\\\d.]+)>/gm;\\r\\n\\r\\n\\t\\tfunction replace( match, include ) {\\r\\n\\r\\n\\t\\t\\tvar replace = ShaderChunk[ include ];\\r\\n\\r\\n\\t\\t\\tif ( replace === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tthrow new Error( 'Can not resolve #include <' + include + '>' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn parseIncludes( replace );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn string.replace( pattern, replace );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction unrollLoops( string ) {\\r\\n\\r\\n\\t\\tvar pattern = /for \\\\( int i \\\\= (\\\\d+)\\\\; i < (\\\\d+)\\\\; i \\\\+\\\\+ \\\\) \\\\{([\\\\s\\\\S]+?)(?=\\\\})\\\\}/g;\\r\\n\\r\\n\\t\\tfunction replace( match, start, end, snippet ) {\\r\\n\\r\\n\\t\\t\\tvar unroll = '';\\r\\n\\r\\n\\t\\t\\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tunroll += snippet.replace( /\\\\[ i \\\\]/g, '[ ' + i + ' ]' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn unroll;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn string.replace( pattern, replace );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction WebGLProgram( renderer, extensions, code, material, shader, parameters ) {\\r\\n\\r\\n\\t\\tvar gl = renderer.context;\\r\\n\\r\\n\\t\\tvar defines = material.defines;\\r\\n\\r\\n\\t\\tvar vertexShader = shader.vertexShader;\\r\\n\\t\\tvar fragmentShader = shader.fragmentShader;\\r\\n\\r\\n\\t\\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\\r\\n\\r\\n\\t\\tif ( parameters.shadowMapType === PCFShadowMap ) {\\r\\n\\r\\n\\t\\t\\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\\r\\n\\r\\n\\t\\t} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {\\r\\n\\r\\n\\t\\t\\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\\r\\n\\t\\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\\r\\n\\t\\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\\r\\n\\r\\n\\t\\tif ( parameters.envMap ) {\\r\\n\\r\\n\\t\\t\\tswitch ( material.envMap.mapping ) {\\r\\n\\r\\n\\t\\t\\t\\tcase CubeReflectionMapping:\\r\\n\\t\\t\\t\\tcase CubeRefractionMapping:\\r\\n\\t\\t\\t\\t\\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tcase CubeUVReflectionMapping:\\r\\n\\t\\t\\t\\tcase CubeUVRefractionMapping:\\r\\n\\t\\t\\t\\t\\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tcase EquirectangularReflectionMapping:\\r\\n\\t\\t\\t\\tcase EquirectangularRefractionMapping:\\r\\n\\t\\t\\t\\t\\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tcase SphericalReflectionMapping:\\r\\n\\t\\t\\t\\t\\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tswitch ( material.envMap.mapping ) {\\r\\n\\r\\n\\t\\t\\t\\tcase CubeRefractionMapping:\\r\\n\\t\\t\\t\\tcase EquirectangularRefractionMapping:\\r\\n\\t\\t\\t\\t\\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tswitch ( material.combine ) {\\r\\n\\r\\n\\t\\t\\t\\tcase MultiplyOperation:\\r\\n\\t\\t\\t\\t\\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tcase MixOperation:\\r\\n\\t\\t\\t\\t\\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tcase AddOperation:\\r\\n\\t\\t\\t\\t\\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\\r\\n\\r\\n\\t\\t// console.log( 'building new program ' );\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tvar customExtensions = generateExtensions( material.extensions, parameters, extensions );\\r\\n\\r\\n\\t\\tvar customDefines = generateDefines( defines );\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tvar program = gl.createProgram();\\r\\n\\r\\n\\t\\tvar prefixVertex, prefixFragment;\\r\\n\\r\\n\\t\\tif ( material.isRawShaderMaterial ) {\\r\\n\\r\\n\\t\\t\\tprefixVertex = [\\r\\n\\r\\n\\t\\t\\t\\tcustomDefines\\r\\n\\r\\n\\t\\t\\t].filter( filterEmptyLine ).join( '\\\\n' );\\r\\n\\r\\n\\t\\t\\tif ( prefixVertex.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tprefixVertex += '\\\\n';\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tprefixFragment = [\\r\\n\\r\\n\\t\\t\\t\\tcustomExtensions,\\r\\n\\t\\t\\t\\tcustomDefines\\r\\n\\r\\n\\t\\t\\t].filter( filterEmptyLine ).join( '\\\\n' );\\r\\n\\r\\n\\t\\t\\tif ( prefixFragment.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tprefixFragment += '\\\\n';\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tprefixVertex = [\\r\\n\\r\\n\\t\\t\\t\\t'precision ' + parameters.precision + ' float;',\\r\\n\\t\\t\\t\\t'precision ' + parameters.precision + ' int;',\\r\\n\\r\\n\\t\\t\\t\\t'#define SHADER_NAME ' + shader.name,\\r\\n\\r\\n\\t\\t\\t\\tcustomDefines,\\r\\n\\r\\n\\t\\t\\t\\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\\r\\n\\r\\n\\t\\t\\t\\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\\r\\n\\r\\n\\t\\t\\t\\t'#define MAX_BONES ' + parameters.maxBones,\\r\\n\\t\\t\\t\\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\\r\\n\\t\\t\\t\\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\\r\\n\\r\\n\\t\\t\\t\\tparameters.map ? '#define USE_MAP' : '',\\r\\n\\t\\t\\t\\tparameters.envMap ? '#define USE_ENVMAP' : '',\\r\\n\\t\\t\\t\\tparameters.envMap ? '#define ' + envMapModeDefine : '',\\r\\n\\t\\t\\t\\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\\r\\n\\t\\t\\t\\tparameters.aoMap ? '#define USE_AOMAP' : '',\\r\\n\\t\\t\\t\\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\\r\\n\\t\\t\\t\\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\\r\\n\\t\\t\\t\\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\\r\\n\\t\\t\\t\\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\\r\\n\\t\\t\\t\\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\\r\\n\\t\\t\\t\\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\\r\\n\\t\\t\\t\\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\\r\\n\\t\\t\\t\\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\\r\\n\\t\\t\\t\\tparameters.vertexColors ? '#define USE_COLOR' : '',\\r\\n\\r\\n\\t\\t\\t\\tparameters.flatShading ? '#define FLAT_SHADED' : '',\\r\\n\\r\\n\\t\\t\\t\\tparameters.skinning ? '#define USE_SKINNING' : '',\\r\\n\\t\\t\\t\\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\\r\\n\\r\\n\\t\\t\\t\\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\\r\\n\\t\\t\\t\\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\\r\\n\\t\\t\\t\\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\\r\\n\\t\\t\\t\\tparameters.flipSided ? '#define FLIP_SIDED' : '',\\r\\n\\r\\n\\t\\t\\t\\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\\r\\n\\r\\n\\t\\t\\t\\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\\r\\n\\t\\t\\t\\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\\r\\n\\r\\n\\t\\t\\t\\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\\r\\n\\r\\n\\t\\t\\t\\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\\r\\n\\t\\t\\t\\tparameters.logarithmicDepthBuffer && extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\\r\\n\\r\\n\\t\\t\\t\\t'uniform mat4 modelMatrix;',\\r\\n\\t\\t\\t\\t'uniform mat4 modelViewMatrix;',\\r\\n\\t\\t\\t\\t'uniform mat4 projectionMatrix;',\\r\\n\\t\\t\\t\\t'uniform mat4 viewMatrix;',\\r\\n\\t\\t\\t\\t'uniform mat3 normalMatrix;',\\r\\n\\t\\t\\t\\t'uniform vec3 cameraPosition;',\\r\\n\\r\\n\\t\\t\\t\\t'attribute vec3 position;',\\r\\n\\t\\t\\t\\t'attribute vec3 normal;',\\r\\n\\t\\t\\t\\t'attribute vec2 uv;',\\r\\n\\r\\n\\t\\t\\t\\t'#ifdef USE_COLOR',\\r\\n\\r\\n\\t\\t\\t\\t'\\tattribute vec3 color;',\\r\\n\\r\\n\\t\\t\\t\\t'#endif',\\r\\n\\r\\n\\t\\t\\t\\t'#ifdef USE_MORPHTARGETS',\\r\\n\\r\\n\\t\\t\\t\\t'\\tattribute vec3 morphTarget0;',\\r\\n\\t\\t\\t\\t'\\tattribute vec3 morphTarget1;',\\r\\n\\t\\t\\t\\t'\\tattribute vec3 morphTarget2;',\\r\\n\\t\\t\\t\\t'\\tattribute vec3 morphTarget3;',\\r\\n\\r\\n\\t\\t\\t\\t'\\t#ifdef USE_MORPHNORMALS',\\r\\n\\r\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphNormal0;',\\r\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphNormal1;',\\r\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphNormal2;',\\r\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphNormal3;',\\r\\n\\r\\n\\t\\t\\t\\t'\\t#else',\\r\\n\\r\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphTarget4;',\\r\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphTarget5;',\\r\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphTarget6;',\\r\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphTarget7;',\\r\\n\\r\\n\\t\\t\\t\\t'\\t#endif',\\r\\n\\r\\n\\t\\t\\t\\t'#endif',\\r\\n\\r\\n\\t\\t\\t\\t'#ifdef USE_SKINNING',\\r\\n\\r\\n\\t\\t\\t\\t'\\tattribute vec4 skinIndex;',\\r\\n\\t\\t\\t\\t'\\tattribute vec4 skinWeight;',\\r\\n\\r\\n\\t\\t\\t\\t'#endif',\\r\\n\\r\\n\\t\\t\\t\\t'\\\\n'\\r\\n\\r\\n\\t\\t\\t].filter( filterEmptyLine ).join( '\\\\n' );\\r\\n\\r\\n\\t\\t\\tprefixFragment = [\\r\\n\\r\\n\\t\\t\\t\\tcustomExtensions,\\r\\n\\r\\n\\t\\t\\t\\t'precision ' + parameters.precision + ' float;',\\r\\n\\t\\t\\t\\t'precision ' + parameters.precision + ' int;',\\r\\n\\r\\n\\t\\t\\t\\t'#define SHADER_NAME ' + shader.name,\\r\\n\\r\\n\\t\\t\\t\\tcustomDefines,\\r\\n\\r\\n\\t\\t\\t\\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\\r\\n\\r\\n\\t\\t\\t\\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\\r\\n\\r\\n\\t\\t\\t\\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\\r\\n\\t\\t\\t\\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\\r\\n\\r\\n\\t\\t\\t\\tparameters.map ? '#define USE_MAP' : '',\\r\\n\\t\\t\\t\\tparameters.envMap ? '#define USE_ENVMAP' : '',\\r\\n\\t\\t\\t\\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\\r\\n\\t\\t\\t\\tparameters.envMap ? '#define ' + envMapModeDefine : '',\\r\\n\\t\\t\\t\\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\\r\\n\\t\\t\\t\\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\\r\\n\\t\\t\\t\\tparameters.aoMap ? '#define USE_AOMAP' : '',\\r\\n\\t\\t\\t\\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\\r\\n\\t\\t\\t\\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\\r\\n\\t\\t\\t\\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\\r\\n\\t\\t\\t\\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\\r\\n\\t\\t\\t\\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\\r\\n\\t\\t\\t\\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\\r\\n\\t\\t\\t\\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\\r\\n\\t\\t\\t\\tparameters.vertexColors ? '#define USE_COLOR' : '',\\r\\n\\r\\n\\t\\t\\t\\tparameters.gradientMap ? '#define USE_GRADIENTMAP' : '',\\r\\n\\r\\n\\t\\t\\t\\tparameters.flatShading ? '#define FLAT_SHADED' : '',\\r\\n\\r\\n\\t\\t\\t\\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\\r\\n\\t\\t\\t\\tparameters.flipSided ? '#define FLIP_SIDED' : '',\\r\\n\\r\\n\\t\\t\\t\\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\\r\\n\\t\\t\\t\\t'#define UNION_CLIPPING_PLANES ' + ( parameters.numClippingPlanes - parameters.numClipIntersection ),\\r\\n\\r\\n\\t\\t\\t\\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\\r\\n\\t\\t\\t\\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\\r\\n\\r\\n\\t\\t\\t\\tparameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',\\r\\n\\r\\n\\t\\t\\t\\tparameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',\\r\\n\\r\\n\\t\\t\\t\\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\\r\\n\\t\\t\\t\\tparameters.logarithmicDepthBuffer && extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\\r\\n\\r\\n\\t\\t\\t\\tparameters.envMap && extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',\\r\\n\\r\\n\\t\\t\\t\\t'uniform mat4 viewMatrix;',\\r\\n\\t\\t\\t\\t'uniform vec3 cameraPosition;',\\r\\n\\r\\n\\t\\t\\t\\t( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',\\r\\n\\t\\t\\t\\t( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below\\r\\n\\t\\t\\t\\t( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',\\r\\n\\r\\n\\t\\t\\t\\tparameters.dithering ? '#define DITHERING' : '',\\r\\n\\r\\n\\t\\t\\t\\t( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\\r\\n\\t\\t\\t\\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\\r\\n\\t\\t\\t\\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\\r\\n\\t\\t\\t\\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\\r\\n\\t\\t\\t\\tparameters.outputEncoding ? getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ) : '',\\r\\n\\r\\n\\t\\t\\t\\tparameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : '',\\r\\n\\r\\n\\t\\t\\t\\t'\\\\n'\\r\\n\\r\\n\\t\\t\\t].filter( filterEmptyLine ).join( '\\\\n' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvertexShader = parseIncludes( vertexShader );\\r\\n\\t\\tvertexShader = replaceLightNums( vertexShader, parameters );\\r\\n\\r\\n\\t\\tfragmentShader = parseIncludes( fragmentShader );\\r\\n\\t\\tfragmentShader = replaceLightNums( fragmentShader, parameters );\\r\\n\\r\\n\\t\\tif ( ! material.isShaderMaterial ) {\\r\\n\\r\\n\\t\\t\\tvertexShader = unrollLoops( vertexShader );\\r\\n\\t\\t\\tfragmentShader = unrollLoops( fragmentShader );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar vertexGlsl = prefixVertex + vertexShader;\\r\\n\\t\\tvar fragmentGlsl = prefixFragment + fragmentShader;\\r\\n\\r\\n\\t\\t// console.log( '*VERTEX*', vertexGlsl );\\r\\n\\t\\t// console.log( '*FRAGMENT*', fragmentGlsl );\\r\\n\\r\\n\\t\\tvar glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\\r\\n\\t\\tvar glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\\r\\n\\r\\n\\t\\tgl.attachShader( program, glVertexShader );\\r\\n\\t\\tgl.attachShader( program, glFragmentShader );\\r\\n\\r\\n\\t\\t// Force a particular attribute to index 0.\\r\\n\\r\\n\\t\\tif ( material.index0AttributeName !== undefined ) {\\r\\n\\r\\n\\t\\t\\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\\r\\n\\r\\n\\t\\t} else if ( parameters.morphTargets === true ) {\\r\\n\\r\\n\\t\\t\\t// programs with morphTargets displace position out of attribute 0\\r\\n\\t\\t\\tgl.bindAttribLocation( program, 0, 'position' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tgl.linkProgram( program );\\r\\n\\r\\n\\t\\tvar programLog = gl.getProgramInfoLog( program );\\r\\n\\t\\tvar vertexLog = gl.getShaderInfoLog( glVertexShader );\\r\\n\\t\\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader );\\r\\n\\r\\n\\t\\tvar runnable = true;\\r\\n\\t\\tvar haveDiagnostics = true;\\r\\n\\r\\n\\t\\t// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\\r\\n\\t\\t// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\\r\\n\\r\\n\\t\\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\\r\\n\\r\\n\\t\\t\\trunnable = false;\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\\r\\n\\r\\n\\t\\t} else if ( programLog !== '' ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\\r\\n\\r\\n\\t\\t} else if ( vertexLog === '' || fragmentLog === '' ) {\\r\\n\\r\\n\\t\\t\\thaveDiagnostics = false;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( haveDiagnostics ) {\\r\\n\\r\\n\\t\\t\\tthis.diagnostics = {\\r\\n\\r\\n\\t\\t\\t\\trunnable: runnable,\\r\\n\\t\\t\\t\\tmaterial: material,\\r\\n\\r\\n\\t\\t\\t\\tprogramLog: programLog,\\r\\n\\r\\n\\t\\t\\t\\tvertexShader: {\\r\\n\\r\\n\\t\\t\\t\\t\\tlog: vertexLog,\\r\\n\\t\\t\\t\\t\\tprefix: prefixVertex\\r\\n\\r\\n\\t\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t\\tfragmentShader: {\\r\\n\\r\\n\\t\\t\\t\\t\\tlog: fragmentLog,\\r\\n\\t\\t\\t\\t\\tprefix: prefixFragment\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// clean up\\r\\n\\r\\n\\t\\tgl.deleteShader( glVertexShader );\\r\\n\\t\\tgl.deleteShader( glFragmentShader );\\r\\n\\r\\n\\t\\t// set up caching for uniform locations\\r\\n\\r\\n\\t\\tvar cachedUniforms;\\r\\n\\r\\n\\t\\tthis.getUniforms = function () {\\r\\n\\r\\n\\t\\t\\tif ( cachedUniforms === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tcachedUniforms = new WebGLUniforms( gl, program, renderer );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn cachedUniforms;\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\t// set up caching for attribute locations\\r\\n\\r\\n\\t\\tvar cachedAttributes;\\r\\n\\r\\n\\t\\tthis.getAttributes = function () {\\r\\n\\r\\n\\t\\t\\tif ( cachedAttributes === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tcachedAttributes = fetchAttributeLocations( gl, program );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn cachedAttributes;\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\t// free resource\\r\\n\\r\\n\\t\\tthis.destroy = function () {\\r\\n\\r\\n\\t\\t\\tgl.deleteProgram( program );\\r\\n\\t\\t\\tthis.program = undefined;\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\t// DEPRECATED\\r\\n\\r\\n\\t\\tObject.defineProperties( this, {\\r\\n\\r\\n\\t\\t\\tuniforms: {\\r\\n\\t\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\\r\\n\\t\\t\\t\\t\\treturn this.getUniforms();\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tattributes: {\\r\\n\\t\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\\r\\n\\t\\t\\t\\t\\treturn this.getAttributes();\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} );\\r\\n\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tthis.id = programIdCount ++;\\r\\n\\t\\tthis.code = code;\\r\\n\\t\\tthis.usedTimes = 1;\\r\\n\\t\\tthis.program = program;\\r\\n\\t\\tthis.vertexShader = glVertexShader;\\r\\n\\t\\tthis.fragmentShader = glFragmentShader;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction WebGLPrograms( renderer, extensions, capabilities ) {\\r\\n\\r\\n\\t\\tvar programs = [];\\r\\n\\r\\n\\t\\tvar shaderIDs = {\\r\\n\\t\\t\\tMeshDepthMaterial: 'depth',\\r\\n\\t\\t\\tMeshDistanceMaterial: 'distanceRGBA',\\r\\n\\t\\t\\tMeshNormalMaterial: 'normal',\\r\\n\\t\\t\\tMeshBasicMaterial: 'basic',\\r\\n\\t\\t\\tMeshLambertMaterial: 'lambert',\\r\\n\\t\\t\\tMeshPhongMaterial: 'phong',\\r\\n\\t\\t\\tMeshToonMaterial: 'phong',\\r\\n\\t\\t\\tMeshStandardMaterial: 'physical',\\r\\n\\t\\t\\tMeshPhysicalMaterial: 'physical',\\r\\n\\t\\t\\tLineBasicMaterial: 'basic',\\r\\n\\t\\t\\tLineDashedMaterial: 'dashed',\\r\\n\\t\\t\\tPointsMaterial: 'points',\\r\\n\\t\\t\\tShadowMaterial: 'shadow'\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tvar parameterNames = [\\r\\n\\t\\t\\t\\\"precision\\\", \\\"supportsVertexTextures\\\", \\\"map\\\", \\\"mapEncoding\\\", \\\"envMap\\\", \\\"envMapMode\\\", \\\"envMapEncoding\\\",\\r\\n\\t\\t\\t\\\"lightMap\\\", \\\"aoMap\\\", \\\"emissiveMap\\\", \\\"emissiveMapEncoding\\\", \\\"bumpMap\\\", \\\"normalMap\\\", \\\"displacementMap\\\", \\\"specularMap\\\",\\r\\n\\t\\t\\t\\\"roughnessMap\\\", \\\"metalnessMap\\\", \\\"gradientMap\\\",\\r\\n\\t\\t\\t\\\"alphaMap\\\", \\\"combine\\\", \\\"vertexColors\\\", \\\"fog\\\", \\\"useFog\\\", \\\"fogExp\\\",\\r\\n\\t\\t\\t\\\"flatShading\\\", \\\"sizeAttenuation\\\", \\\"logarithmicDepthBuffer\\\", \\\"skinning\\\",\\r\\n\\t\\t\\t\\\"maxBones\\\", \\\"useVertexTexture\\\", \\\"morphTargets\\\", \\\"morphNormals\\\",\\r\\n\\t\\t\\t\\\"maxMorphTargets\\\", \\\"maxMorphNormals\\\", \\\"premultipliedAlpha\\\",\\r\\n\\t\\t\\t\\\"numDirLights\\\", \\\"numPointLights\\\", \\\"numSpotLights\\\", \\\"numHemiLights\\\", \\\"numRectAreaLights\\\",\\r\\n\\t\\t\\t\\\"shadowMapEnabled\\\", \\\"shadowMapType\\\", \\\"toneMapping\\\", 'physicallyCorrectLights',\\r\\n\\t\\t\\t\\\"alphaTest\\\", \\\"doubleSided\\\", \\\"flipSided\\\", \\\"numClippingPlanes\\\", \\\"numClipIntersection\\\", \\\"depthPacking\\\", \\\"dithering\\\"\\r\\n\\t\\t];\\r\\n\\r\\n\\r\\n\\t\\tfunction allocateBones( object ) {\\r\\n\\r\\n\\t\\t\\tvar skeleton = object.skeleton;\\r\\n\\t\\t\\tvar bones = skeleton.bones;\\r\\n\\r\\n\\t\\t\\tif ( capabilities.floatVertexTextures ) {\\r\\n\\r\\n\\t\\t\\t\\treturn 1024;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t// default for when object is not specified\\r\\n\\t\\t\\t\\t// ( for example when prebuilding shader to be used with multiple objects )\\r\\n\\t\\t\\t\\t//\\r\\n\\t\\t\\t\\t//  - leave some extra space for other uniforms\\r\\n\\t\\t\\t\\t//  - limit here is ANGLE's 254 max uniform vectors\\r\\n\\t\\t\\t\\t//    (up to 54 should be safe)\\r\\n\\r\\n\\t\\t\\t\\tvar nVertexUniforms = capabilities.maxVertexUniforms;\\r\\n\\t\\t\\t\\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\\r\\n\\r\\n\\t\\t\\t\\tvar maxBones = Math.min( nVertexMatrices, bones.length );\\r\\n\\r\\n\\t\\t\\t\\tif ( maxBones < bones.length ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );\\r\\n\\t\\t\\t\\t\\treturn 0;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn maxBones;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\\r\\n\\r\\n\\t\\t\\tvar encoding;\\r\\n\\r\\n\\t\\t\\tif ( ! map ) {\\r\\n\\r\\n\\t\\t\\t\\tencoding = LinearEncoding;\\r\\n\\r\\n\\t\\t\\t} else if ( map.isTexture ) {\\r\\n\\r\\n\\t\\t\\t\\tencoding = map.encoding;\\r\\n\\r\\n\\t\\t\\t} else if ( map.isWebGLRenderTarget ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( \\\"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\\\" );\\r\\n\\t\\t\\t\\tencoding = map.texture.encoding;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\\r\\n\\t\\t\\tif ( encoding === LinearEncoding && gammaOverrideLinear ) {\\r\\n\\r\\n\\t\\t\\t\\tencoding = GammaEncoding;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn encoding;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.getParameters = function ( material, lights, shadows, fog, nClipPlanes, nClipIntersection, object ) {\\r\\n\\r\\n\\t\\t\\tvar shaderID = shaderIDs[ material.type ];\\r\\n\\r\\n\\t\\t\\t// heuristics to create shader parameters according to lights in the scene\\r\\n\\t\\t\\t// (not to blow over maxLights budget)\\r\\n\\r\\n\\t\\t\\tvar maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;\\r\\n\\t\\t\\tvar precision = capabilities.precision;\\r\\n\\r\\n\\t\\t\\tif ( material.precision !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tprecision = capabilities.getMaxPrecision( material.precision );\\r\\n\\r\\n\\t\\t\\t\\tif ( precision !== material.precision ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar currentRenderTarget = renderer.getRenderTarget();\\r\\n\\r\\n\\t\\t\\tvar parameters = {\\r\\n\\r\\n\\t\\t\\t\\tshaderID: shaderID,\\r\\n\\r\\n\\t\\t\\t\\tprecision: precision,\\r\\n\\t\\t\\t\\tsupportsVertexTextures: capabilities.vertexTextures,\\r\\n\\t\\t\\t\\toutputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),\\r\\n\\t\\t\\t\\tmap: !! material.map,\\r\\n\\t\\t\\t\\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\\r\\n\\t\\t\\t\\tenvMap: !! material.envMap,\\r\\n\\t\\t\\t\\tenvMapMode: material.envMap && material.envMap.mapping,\\r\\n\\t\\t\\t\\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\\r\\n\\t\\t\\t\\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),\\r\\n\\t\\t\\t\\tlightMap: !! material.lightMap,\\r\\n\\t\\t\\t\\taoMap: !! material.aoMap,\\r\\n\\t\\t\\t\\temissiveMap: !! material.emissiveMap,\\r\\n\\t\\t\\t\\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\\r\\n\\t\\t\\t\\tbumpMap: !! material.bumpMap,\\r\\n\\t\\t\\t\\tnormalMap: !! material.normalMap,\\r\\n\\t\\t\\t\\tdisplacementMap: !! material.displacementMap,\\r\\n\\t\\t\\t\\troughnessMap: !! material.roughnessMap,\\r\\n\\t\\t\\t\\tmetalnessMap: !! material.metalnessMap,\\r\\n\\t\\t\\t\\tspecularMap: !! material.specularMap,\\r\\n\\t\\t\\t\\talphaMap: !! material.alphaMap,\\r\\n\\r\\n\\t\\t\\t\\tgradientMap: !! material.gradientMap,\\r\\n\\r\\n\\t\\t\\t\\tcombine: material.combine,\\r\\n\\r\\n\\t\\t\\t\\tvertexColors: material.vertexColors,\\r\\n\\r\\n\\t\\t\\t\\tfog: !! fog,\\r\\n\\t\\t\\t\\tuseFog: material.fog,\\r\\n\\t\\t\\t\\tfogExp: ( fog && fog.isFogExp2 ),\\r\\n\\r\\n\\t\\t\\t\\tflatShading: material.flatShading,\\r\\n\\r\\n\\t\\t\\t\\tsizeAttenuation: material.sizeAttenuation,\\r\\n\\t\\t\\t\\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\\r\\n\\r\\n\\t\\t\\t\\tskinning: material.skinning && maxBones > 0,\\r\\n\\t\\t\\t\\tmaxBones: maxBones,\\r\\n\\t\\t\\t\\tuseVertexTexture: capabilities.floatVertexTextures,\\r\\n\\r\\n\\t\\t\\t\\tmorphTargets: material.morphTargets,\\r\\n\\t\\t\\t\\tmorphNormals: material.morphNormals,\\r\\n\\t\\t\\t\\tmaxMorphTargets: renderer.maxMorphTargets,\\r\\n\\t\\t\\t\\tmaxMorphNormals: renderer.maxMorphNormals,\\r\\n\\r\\n\\t\\t\\t\\tnumDirLights: lights.directional.length,\\r\\n\\t\\t\\t\\tnumPointLights: lights.point.length,\\r\\n\\t\\t\\t\\tnumSpotLights: lights.spot.length,\\r\\n\\t\\t\\t\\tnumRectAreaLights: lights.rectArea.length,\\r\\n\\t\\t\\t\\tnumHemiLights: lights.hemi.length,\\r\\n\\r\\n\\t\\t\\t\\tnumClippingPlanes: nClipPlanes,\\r\\n\\t\\t\\t\\tnumClipIntersection: nClipIntersection,\\r\\n\\r\\n\\t\\t\\t\\tdithering: material.dithering,\\r\\n\\r\\n\\t\\t\\t\\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,\\r\\n\\t\\t\\t\\tshadowMapType: renderer.shadowMap.type,\\r\\n\\r\\n\\t\\t\\t\\ttoneMapping: renderer.toneMapping,\\r\\n\\t\\t\\t\\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\\r\\n\\r\\n\\t\\t\\t\\tpremultipliedAlpha: material.premultipliedAlpha,\\r\\n\\r\\n\\t\\t\\t\\talphaTest: material.alphaTest,\\r\\n\\t\\t\\t\\tdoubleSided: material.side === DoubleSide,\\r\\n\\t\\t\\t\\tflipSided: material.side === BackSide,\\r\\n\\r\\n\\t\\t\\t\\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\treturn parameters;\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.getProgramCode = function ( material, parameters ) {\\r\\n\\r\\n\\t\\t\\tvar array = [];\\r\\n\\r\\n\\t\\t\\tif ( parameters.shaderID ) {\\r\\n\\r\\n\\t\\t\\t\\tarray.push( parameters.shaderID );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tarray.push( material.fragmentShader );\\r\\n\\t\\t\\t\\tarray.push( material.vertexShader );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( material.defines !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( var name in material.defines ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tarray.push( name );\\r\\n\\t\\t\\t\\t\\tarray.push( material.defines[ name ] );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tarray.push( parameters[ parameterNames[ i ] ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tarray.push( material.onBeforeCompile.toString() );\\r\\n\\r\\n\\t\\t\\tarray.push( renderer.gammaOutput );\\r\\n\\r\\n\\t\\t\\treturn array.join();\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.acquireProgram = function ( material, shader, parameters, code ) {\\r\\n\\r\\n\\t\\t\\tvar program;\\r\\n\\r\\n\\t\\t\\t// Check if code has been already compiled\\r\\n\\t\\t\\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar programInfo = programs[ p ];\\r\\n\\r\\n\\t\\t\\t\\tif ( programInfo.code === code ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tprogram = programInfo;\\r\\n\\t\\t\\t\\t\\t++ program.usedTimes;\\r\\n\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( program === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tprogram = new WebGLProgram( renderer, extensions, code, material, shader, parameters );\\r\\n\\t\\t\\t\\tprograms.push( program );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn program;\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.releaseProgram = function ( program ) {\\r\\n\\r\\n\\t\\t\\tif ( -- program.usedTimes === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t// Remove from unordered set\\r\\n\\t\\t\\t\\tvar i = programs.indexOf( program );\\r\\n\\t\\t\\t\\tprograms[ i ] = programs[ programs.length - 1 ];\\r\\n\\t\\t\\t\\tprograms.pop();\\r\\n\\r\\n\\t\\t\\t\\t// Free WebGL resources\\r\\n\\t\\t\\t\\tprogram.destroy();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\t// Exposed for resource monitoring & error feedback via renderer.info:\\r\\n\\t\\tthis.programs = programs;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils, infoMemory ) {\\r\\n\\r\\n\\t\\tvar _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof window.WebGL2RenderingContext );\\r\\n\\t\\tvar _videoTextures = {};\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tfunction clampToMaxSize( image, maxSize ) {\\r\\n\\r\\n\\t\\t\\tif ( image.width > maxSize || image.height > maxSize ) {\\r\\n\\r\\n\\t\\t\\t\\t// Warning: Scaling through the canvas will only work with images that use\\r\\n\\t\\t\\t\\t// premultiplied alpha.\\r\\n\\r\\n\\t\\t\\t\\tvar scale = maxSize / Math.max( image.width, image.height );\\r\\n\\r\\n\\t\\t\\t\\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\\r\\n\\t\\t\\t\\tcanvas.width = Math.floor( image.width * scale );\\r\\n\\t\\t\\t\\tcanvas.height = Math.floor( image.height * scale );\\r\\n\\r\\n\\t\\t\\t\\tvar context = canvas.getContext( '2d' );\\r\\n\\t\\t\\t\\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\\r\\n\\r\\n\\t\\t\\t\\treturn canvas;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn image;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction isPowerOfTwo( image ) {\\r\\n\\r\\n\\t\\t\\treturn _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction makePowerOfTwo( image ) {\\r\\n\\r\\n\\t\\t\\tif ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof ImageBitmap ) {\\r\\n\\r\\n\\t\\t\\t\\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\\r\\n\\t\\t\\t\\tcanvas.width = _Math.floorPowerOfTwo( image.width );\\r\\n\\t\\t\\t\\tcanvas.height = _Math.floorPowerOfTwo( image.height );\\r\\n\\r\\n\\t\\t\\t\\tvar context = canvas.getContext( '2d' );\\r\\n\\t\\t\\t\\tcontext.drawImage( image, 0, 0, canvas.width, canvas.height );\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\\r\\n\\r\\n\\t\\t\\t\\treturn canvas;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn image;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction textureNeedsPowerOfTwo( texture ) {\\r\\n\\r\\n\\t\\t\\treturn ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||\\r\\n\\t\\t\\t\\t( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction textureNeedsGenerateMipmaps( texture, isPowerOfTwo ) {\\r\\n\\r\\n\\t\\t\\treturn texture.generateMipmaps && isPowerOfTwo &&\\r\\n\\t\\t\\t\\ttexture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Fallback filters for non-power-of-2 textures\\r\\n\\r\\n\\t\\tfunction filterFallback( f ) {\\r\\n\\r\\n\\t\\t\\tif ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {\\r\\n\\r\\n\\t\\t\\t\\treturn _gl.NEAREST;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn _gl.LINEAR;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tfunction onTextureDispose( event ) {\\r\\n\\r\\n\\t\\t\\tvar texture = event.target;\\r\\n\\r\\n\\t\\t\\ttexture.removeEventListener( 'dispose', onTextureDispose );\\r\\n\\r\\n\\t\\t\\tdeallocateTexture( texture );\\r\\n\\r\\n\\t\\t\\tif ( texture.isVideoTexture ) {\\r\\n\\r\\n\\t\\t\\t\\tdelete _videoTextures[ texture.id ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tinfoMemory.textures --;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction onRenderTargetDispose( event ) {\\r\\n\\r\\n\\t\\t\\tvar renderTarget = event.target;\\r\\n\\r\\n\\t\\t\\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\\r\\n\\r\\n\\t\\t\\tdeallocateRenderTarget( renderTarget );\\r\\n\\r\\n\\t\\t\\tinfoMemory.textures --;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tfunction deallocateTexture( texture ) {\\r\\n\\r\\n\\t\\t\\tvar textureProperties = properties.get( texture );\\r\\n\\r\\n\\t\\t\\tif ( texture.image && textureProperties.__image__webglTextureCube ) {\\r\\n\\r\\n\\t\\t\\t\\t// cube texture\\r\\n\\r\\n\\t\\t\\t\\t_gl.deleteTexture( textureProperties.__image__webglTextureCube );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t// 2D texture\\r\\n\\r\\n\\t\\t\\t\\tif ( textureProperties.__webglInit === undefined ) return;\\r\\n\\r\\n\\t\\t\\t\\t_gl.deleteTexture( textureProperties.__webglTexture );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// remove all webgl properties\\r\\n\\t\\t\\tproperties.remove( texture );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction deallocateRenderTarget( renderTarget ) {\\r\\n\\r\\n\\t\\t\\tvar renderTargetProperties = properties.get( renderTarget );\\r\\n\\t\\t\\tvar textureProperties = properties.get( renderTarget.texture );\\r\\n\\r\\n\\t\\t\\tif ( ! renderTarget ) return;\\r\\n\\r\\n\\t\\t\\tif ( textureProperties.__webglTexture !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t_gl.deleteTexture( textureProperties.__webglTexture );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( renderTarget.depthTexture ) {\\r\\n\\r\\n\\t\\t\\t\\trenderTarget.depthTexture.dispose();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( renderTarget.isWebGLRenderTargetCube ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\\r\\n\\t\\t\\t\\t\\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\\r\\n\\t\\t\\t\\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tproperties.remove( renderTarget.texture );\\r\\n\\t\\t\\tproperties.remove( renderTarget );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\r\\n\\r\\n\\t\\tfunction setTexture2D( texture, slot ) {\\r\\n\\r\\n\\t\\t\\tvar textureProperties = properties.get( texture );\\r\\n\\r\\n\\t\\t\\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\\r\\n\\r\\n\\t\\t\\t\\tvar image = texture.image;\\r\\n\\r\\n\\t\\t\\t\\tif ( image === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\\r\\n\\r\\n\\t\\t\\t\\t} else if ( image.complete === false ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tuploadTexture( textureProperties, texture, slot );\\r\\n\\t\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tstate.activeTexture( _gl.TEXTURE0 + slot );\\r\\n\\t\\t\\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction setTextureCube( texture, slot ) {\\r\\n\\r\\n\\t\\t\\tvar textureProperties = properties.get( texture );\\r\\n\\r\\n\\t\\t\\tif ( texture.image.length === 6 ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( ! textureProperties.__image__webglTextureCube ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ttexture.addEventListener( 'dispose', onTextureDispose );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ttextureProperties.__image__webglTextureCube = _gl.createTexture();\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tinfoMemory.textures ++;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tstate.activeTexture( _gl.TEXTURE0 + slot );\\r\\n\\t\\t\\t\\t\\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\\r\\n\\r\\n\\t\\t\\t\\t\\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\\r\\n\\r\\n\\t\\t\\t\\t\\tvar isCompressed = ( texture && texture.isCompressedTexture );\\r\\n\\t\\t\\t\\t\\tvar isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );\\r\\n\\r\\n\\t\\t\\t\\t\\tvar cubeImage = [];\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( ! isCompressed && ! isDataTexture ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tvar image = cubeImage[ 0 ],\\r\\n\\t\\t\\t\\t\\t\\tisPowerOfTwoImage = isPowerOfTwo( image ),\\r\\n\\t\\t\\t\\t\\t\\tglFormat = utils.convert( texture.format ),\\r\\n\\t\\t\\t\\t\\t\\tglType = utils.convert( texture.type );\\r\\n\\r\\n\\t\\t\\t\\t\\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( ! isCompressed ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( isDataTexture ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tmipmap = mipmaps[ j ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\ttextureProperties.__version = texture.version;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( texture.onUpdate ) texture.onUpdate( texture );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tstate.activeTexture( _gl.TEXTURE0 + slot );\\r\\n\\t\\t\\t\\t\\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction setTextureCubeDynamic( texture, slot ) {\\r\\n\\r\\n\\t\\t\\tstate.activeTexture( _gl.TEXTURE0 + slot );\\r\\n\\t\\t\\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction setTextureParameters( textureType, texture, isPowerOfTwoImage ) {\\r\\n\\r\\n\\t\\t\\tvar extension;\\r\\n\\r\\n\\t\\t\\tif ( isPowerOfTwoImage ) {\\r\\n\\r\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, utils.convert( texture.wrapS ) );\\r\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, utils.convert( texture.wrapT ) );\\r\\n\\r\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, utils.convert( texture.magFilter ) );\\r\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, utils.convert( texture.minFilter ) );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\\r\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\\r\\n\\r\\n\\t\\t\\t\\tif ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\\r\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\\r\\n\\r\\n\\t\\t\\t\\tif ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\\r\\n\\r\\n\\t\\t\\tif ( extension ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\\r\\n\\t\\t\\t\\tif ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\\r\\n\\r\\n\\t\\t\\t\\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\\r\\n\\t\\t\\t\\t\\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction uploadTexture( textureProperties, texture, slot ) {\\r\\n\\r\\n\\t\\t\\tif ( textureProperties.__webglInit === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\ttextureProperties.__webglInit = true;\\r\\n\\r\\n\\t\\t\\t\\ttexture.addEventListener( 'dispose', onTextureDispose );\\r\\n\\r\\n\\t\\t\\t\\ttextureProperties.__webglTexture = _gl.createTexture();\\r\\n\\r\\n\\t\\t\\t\\tif ( texture.isVideoTexture ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t_videoTextures[ texture.id ] = texture;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tinfoMemory.textures ++;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tstate.activeTexture( _gl.TEXTURE0 + slot );\\r\\n\\t\\t\\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\\r\\n\\r\\n\\t\\t\\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\\r\\n\\t\\t\\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\\r\\n\\t\\t\\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\\r\\n\\r\\n\\t\\t\\tvar image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\\r\\n\\r\\n\\t\\t\\tif ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\\r\\n\\r\\n\\t\\t\\t\\timage = makePowerOfTwo( image );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar isPowerOfTwoImage = isPowerOfTwo( image ),\\r\\n\\t\\t\\t\\tglFormat = utils.convert( texture.format ),\\r\\n\\t\\t\\t\\tglType = utils.convert( texture.type );\\r\\n\\r\\n\\t\\t\\tsetTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\\r\\n\\r\\n\\t\\t\\tvar mipmap, mipmaps = texture.mipmaps;\\r\\n\\r\\n\\t\\t\\tif ( texture.isDepthTexture ) {\\r\\n\\r\\n\\t\\t\\t\\t// populate depth texture with dummy data\\r\\n\\r\\n\\t\\t\\t\\tvar internalFormat = _gl.DEPTH_COMPONENT;\\r\\n\\r\\n\\t\\t\\t\\tif ( texture.type === FloatType ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( ! _isWebGL2 ) throw new Error( 'Float Depth Texture only supported in WebGL2.0' );\\r\\n\\t\\t\\t\\t\\tinternalFormat = _gl.DEPTH_COMPONENT32F;\\r\\n\\r\\n\\t\\t\\t\\t} else if ( _isWebGL2 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// WebGL 2.0 requires signed internalformat for glTexImage2D\\r\\n\\t\\t\\t\\t\\tinternalFormat = _gl.DEPTH_COMPONENT16;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( texture.format === DepthFormat && internalFormat === _gl.DEPTH_COMPONENT ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\\r\\n\\t\\t\\t\\t\\t// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT\\r\\n\\t\\t\\t\\t\\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\\r\\n\\t\\t\\t\\t\\tif ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ttexture.type = UnsignedShortType;\\r\\n\\t\\t\\t\\t\\t\\tglType = utils.convert( texture.type );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// Depth stencil textures need the DEPTH_STENCIL internal format\\r\\n\\t\\t\\t\\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\\r\\n\\t\\t\\t\\tif ( texture.format === DepthStencilFormat ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tinternalFormat = _gl.DEPTH_STENCIL;\\r\\n\\r\\n\\t\\t\\t\\t\\t// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\\r\\n\\t\\t\\t\\t\\t// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.\\r\\n\\t\\t\\t\\t\\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\\r\\n\\t\\t\\t\\t\\tif ( texture.type !== UnsignedInt248Type ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ttexture.type = UnsignedInt248Type;\\r\\n\\t\\t\\t\\t\\t\\tglType = utils.convert( texture.type );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );\\r\\n\\r\\n\\t\\t\\t} else if ( texture.isDataTexture ) {\\r\\n\\r\\n\\t\\t\\t\\t// use manually created mipmaps if available\\r\\n\\t\\t\\t\\t// if there are no manual mipmaps\\r\\n\\t\\t\\t\\t// set 0 level mipmap and then use GL to generate other mipmap levels\\r\\n\\r\\n\\t\\t\\t\\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tmipmap = mipmaps[ i ];\\r\\n\\t\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\ttexture.generateMipmaps = false;\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else if ( texture.isCompressedTexture ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tmipmap = mipmaps[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t// regular Texture (image, video, canvas)\\r\\n\\r\\n\\t\\t\\t\\t// use manually created mipmaps if available\\r\\n\\t\\t\\t\\t// if there are no manual mipmaps\\r\\n\\t\\t\\t\\t// set 0 level mipmap and then use GL to generate other mipmap levels\\r\\n\\r\\n\\t\\t\\t\\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tmipmap = mipmaps[ i ];\\r\\n\\t\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\ttexture.generateMipmaps = false;\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) _gl.generateMipmap( _gl.TEXTURE_2D );\\r\\n\\r\\n\\t\\t\\ttextureProperties.__version = texture.version;\\r\\n\\r\\n\\t\\t\\tif ( texture.onUpdate ) texture.onUpdate( texture );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Render targets\\r\\n\\r\\n\\t\\t// Setup storage for target texture and bind it to correct framebuffer\\r\\n\\t\\tfunction setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {\\r\\n\\r\\n\\t\\t\\tvar glFormat = utils.convert( renderTarget.texture.format );\\r\\n\\t\\t\\tvar glType = utils.convert( renderTarget.texture.type );\\r\\n\\t\\t\\tstate.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\\r\\n\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\\r\\n\\t\\t\\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\\r\\n\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\\r\\n\\t\\tfunction setupRenderBufferStorage( renderbuffer, renderTarget ) {\\r\\n\\r\\n\\t\\t\\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\\r\\n\\r\\n\\t\\t\\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\\r\\n\\r\\n\\t\\t\\t\\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\\r\\n\\t\\t\\t\\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\\r\\n\\r\\n\\t\\t\\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\\r\\n\\r\\n\\t\\t\\t\\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\\r\\n\\t\\t\\t\\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t// FIXME: We don't support !depth !stencil\\r\\n\\t\\t\\t\\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Setup resources for a Depth Texture for a FBO (needs an extension)\\r\\n\\t\\tfunction setupDepthTexture( framebuffer, renderTarget ) {\\r\\n\\r\\n\\t\\t\\tvar isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );\\r\\n\\t\\t\\tif ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );\\r\\n\\r\\n\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\\r\\n\\r\\n\\t\\t\\tif ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {\\r\\n\\r\\n\\t\\t\\t\\tthrow new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// upload an empty depth texture with framebuffer size\\r\\n\\t\\t\\tif ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||\\r\\n\\t\\t\\t\\t\\trenderTarget.depthTexture.image.width !== renderTarget.width ||\\r\\n\\t\\t\\t\\t\\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\\r\\n\\r\\n\\t\\t\\t\\trenderTarget.depthTexture.image.width = renderTarget.width;\\r\\n\\t\\t\\t\\trenderTarget.depthTexture.image.height = renderTarget.height;\\r\\n\\t\\t\\t\\trenderTarget.depthTexture.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tsetTexture2D( renderTarget.depthTexture, 0 );\\r\\n\\r\\n\\t\\t\\tvar webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\\r\\n\\r\\n\\t\\t\\tif ( renderTarget.depthTexture.format === DepthFormat ) {\\r\\n\\r\\n\\t\\t\\t\\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\\r\\n\\r\\n\\t\\t\\t} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {\\r\\n\\r\\n\\t\\t\\t\\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tthrow new Error( 'Unknown depthTexture format' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Setup GL resources for a non-texture depth buffer\\r\\n\\t\\tfunction setupDepthRenderbuffer( renderTarget ) {\\r\\n\\r\\n\\t\\t\\tvar renderTargetProperties = properties.get( renderTarget );\\r\\n\\r\\n\\t\\t\\tvar isCube = ( renderTarget.isWebGLRenderTargetCube === true );\\r\\n\\r\\n\\t\\t\\tif ( renderTarget.depthTexture ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );\\r\\n\\r\\n\\t\\t\\t\\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tif ( isCube ) {\\r\\n\\r\\n\\t\\t\\t\\t\\trenderTargetProperties.__webglDepthbuffer = [];\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\\r\\n\\t\\t\\t\\t\\t\\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\\r\\n\\t\\t\\t\\t\\t\\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\\r\\n\\t\\t\\t\\t\\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\\r\\n\\t\\t\\t\\t\\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Set up GL resources for the render target\\r\\n\\t\\tfunction setupRenderTarget( renderTarget ) {\\r\\n\\r\\n\\t\\t\\tvar renderTargetProperties = properties.get( renderTarget );\\r\\n\\t\\t\\tvar textureProperties = properties.get( renderTarget.texture );\\r\\n\\r\\n\\t\\t\\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\\r\\n\\r\\n\\t\\t\\ttextureProperties.__webglTexture = _gl.createTexture();\\r\\n\\r\\n\\t\\t\\tinfoMemory.textures ++;\\r\\n\\r\\n\\t\\t\\tvar isCube = ( renderTarget.isWebGLRenderTargetCube === true );\\r\\n\\t\\t\\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\\r\\n\\r\\n\\t\\t\\t// Setup framebuffer\\r\\n\\r\\n\\t\\t\\tif ( isCube ) {\\r\\n\\r\\n\\t\\t\\t\\trenderTargetProperties.__webglFramebuffer = [];\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// Setup color buffer\\r\\n\\r\\n\\t\\t\\tif ( isCube ) {\\r\\n\\r\\n\\t\\t\\t\\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\\r\\n\\t\\t\\t\\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\\r\\n\\t\\t\\t\\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\\r\\n\\t\\t\\t\\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\\r\\n\\t\\t\\t\\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\\r\\n\\r\\n\\t\\t\\t\\tif ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) _gl.generateMipmap( _gl.TEXTURE_2D );\\r\\n\\t\\t\\t\\tstate.bindTexture( _gl.TEXTURE_2D, null );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// Setup depth and stencil buffers\\r\\n\\r\\n\\t\\t\\tif ( renderTarget.depthBuffer ) {\\r\\n\\r\\n\\t\\t\\t\\tsetupDepthRenderbuffer( renderTarget );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction updateRenderTargetMipmap( renderTarget ) {\\r\\n\\r\\n\\t\\t\\tvar texture = renderTarget.texture;\\r\\n\\t\\t\\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\\r\\n\\r\\n\\t\\t\\tif ( textureNeedsGenerateMipmaps( texture, isTargetPowerOfTwo ) ) {\\r\\n\\r\\n\\t\\t\\t\\tvar target = renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\\r\\n\\t\\t\\t\\tvar webglTexture = properties.get( texture ).__webglTexture;\\r\\n\\r\\n\\t\\t\\t\\tstate.bindTexture( target, webglTexture );\\r\\n\\t\\t\\t\\t_gl.generateMipmap( target );\\r\\n\\t\\t\\t\\tstate.bindTexture( target, null );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction updateVideoTextures() {\\r\\n\\r\\n\\t\\t\\tfor ( var id in _videoTextures ) {\\r\\n\\r\\n\\t\\t\\t\\t_videoTextures[ id ].update();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.setTexture2D = setTexture2D;\\r\\n\\t\\tthis.setTextureCube = setTextureCube;\\r\\n\\t\\tthis.setTextureCubeDynamic = setTextureCubeDynamic;\\r\\n\\t\\tthis.setupRenderTarget = setupRenderTarget;\\r\\n\\t\\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\\r\\n\\t\\tthis.updateVideoTextures = updateVideoTextures;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @author fordacious / fordacious.github.io\\r\\n\\t */\\r\\n\\r\\n\\tfunction WebGLProperties() {\\r\\n\\r\\n\\t\\tvar properties = {};\\r\\n\\r\\n\\t\\tfunction get( object ) {\\r\\n\\r\\n\\t\\t\\tvar uuid = object.uuid;\\r\\n\\t\\t\\tvar map = properties[ uuid ];\\r\\n\\r\\n\\t\\t\\tif ( map === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tmap = {};\\r\\n\\t\\t\\t\\tproperties[ uuid ] = map;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn map;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction remove( object ) {\\r\\n\\r\\n\\t\\t\\tdelete properties[ object.uuid ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction clear() {\\r\\n\\r\\n\\t\\t\\tproperties = {};\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn {\\r\\n\\t\\t\\tget: get,\\r\\n\\t\\t\\tremove: remove,\\r\\n\\t\\t\\tclear: clear\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction WebGLState( gl, extensions, utils ) {\\r\\n\\r\\n\\t\\tfunction ColorBuffer() {\\r\\n\\r\\n\\t\\t\\tvar locked = false;\\r\\n\\r\\n\\t\\t\\tvar color = new Vector4();\\r\\n\\t\\t\\tvar currentColorMask = null;\\r\\n\\t\\t\\tvar currentColorClear = new Vector4( 0, 0, 0, 0 );\\r\\n\\r\\n\\t\\t\\treturn {\\r\\n\\r\\n\\t\\t\\t\\tsetMask: function ( colorMask ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( currentColorMask !== colorMask && ! locked ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\\r\\n\\t\\t\\t\\t\\t\\tcurrentColorMask = colorMask;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t\\tsetLocked: function ( lock ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tlocked = lock;\\r\\n\\r\\n\\t\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t\\tsetClear: function ( r, g, b, a, premultipliedAlpha ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( premultipliedAlpha === true ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tr *= a; g *= a; b *= a;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tcolor.set( r, g, b, a );\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( currentColorClear.equals( color ) === false ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgl.clearColor( r, g, b, a );\\r\\n\\t\\t\\t\\t\\t\\tcurrentColorClear.copy( color );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t\\treset: function () {\\r\\n\\r\\n\\t\\t\\t\\t\\tlocked = false;\\r\\n\\r\\n\\t\\t\\t\\t\\tcurrentColorMask = null;\\r\\n\\t\\t\\t\\t\\tcurrentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction DepthBuffer() {\\r\\n\\r\\n\\t\\t\\tvar locked = false;\\r\\n\\r\\n\\t\\t\\tvar currentDepthMask = null;\\r\\n\\t\\t\\tvar currentDepthFunc = null;\\r\\n\\t\\t\\tvar currentDepthClear = null;\\r\\n\\r\\n\\t\\t\\treturn {\\r\\n\\r\\n\\t\\t\\t\\tsetTest: function ( depthTest ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( depthTest ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tenable( gl.DEPTH_TEST );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tdisable( gl.DEPTH_TEST );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t\\tsetMask: function ( depthMask ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( currentDepthMask !== depthMask && ! locked ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgl.depthMask( depthMask );\\r\\n\\t\\t\\t\\t\\t\\tcurrentDepthMask = depthMask;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t\\tsetFunc: function ( depthFunc ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( currentDepthFunc !== depthFunc ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( depthFunc ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tswitch ( depthFunc ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tcase NeverDepth:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.NEVER );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tcase AlwaysDepth:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.ALWAYS );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tcase LessDepth:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.LESS );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tcase LessEqualDepth:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.LEQUAL );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tcase EqualDepth:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.EQUAL );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tcase GreaterEqualDepth:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.GEQUAL );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tcase GreaterDepth:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.GREATER );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tcase NotEqualDepth:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.NOTEQUAL );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdefault:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.LEQUAL );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.LEQUAL );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcurrentDepthFunc = depthFunc;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t\\tsetLocked: function ( lock ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tlocked = lock;\\r\\n\\r\\n\\t\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t\\tsetClear: function ( depth ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( currentDepthClear !== depth ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgl.clearDepth( depth );\\r\\n\\t\\t\\t\\t\\t\\tcurrentDepthClear = depth;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t\\treset: function () {\\r\\n\\r\\n\\t\\t\\t\\t\\tlocked = false;\\r\\n\\r\\n\\t\\t\\t\\t\\tcurrentDepthMask = null;\\r\\n\\t\\t\\t\\t\\tcurrentDepthFunc = null;\\r\\n\\t\\t\\t\\t\\tcurrentDepthClear = null;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction StencilBuffer() {\\r\\n\\r\\n\\t\\t\\tvar locked = false;\\r\\n\\r\\n\\t\\t\\tvar currentStencilMask = null;\\r\\n\\t\\t\\tvar currentStencilFunc = null;\\r\\n\\t\\t\\tvar currentStencilRef = null;\\r\\n\\t\\t\\tvar currentStencilFuncMask = null;\\r\\n\\t\\t\\tvar currentStencilFail = null;\\r\\n\\t\\t\\tvar currentStencilZFail = null;\\r\\n\\t\\t\\tvar currentStencilZPass = null;\\r\\n\\t\\t\\tvar currentStencilClear = null;\\r\\n\\r\\n\\t\\t\\treturn {\\r\\n\\r\\n\\t\\t\\t\\tsetTest: function ( stencilTest ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( stencilTest ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tenable( gl.STENCIL_TEST );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tdisable( gl.STENCIL_TEST );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t\\tsetMask: function ( stencilMask ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( currentStencilMask !== stencilMask && ! locked ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgl.stencilMask( stencilMask );\\r\\n\\t\\t\\t\\t\\t\\tcurrentStencilMask = stencilMask;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t\\tsetFunc: function ( stencilFunc, stencilRef, stencilMask ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( currentStencilFunc !== stencilFunc ||\\r\\n\\t\\t\\t\\t\\t     currentStencilRef \\t!== stencilRef \\t||\\r\\n\\t\\t\\t\\t\\t     currentStencilFuncMask !== stencilMask ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgl.stencilFunc( stencilFunc, stencilRef, stencilMask );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcurrentStencilFunc = stencilFunc;\\r\\n\\t\\t\\t\\t\\t\\tcurrentStencilRef = stencilRef;\\r\\n\\t\\t\\t\\t\\t\\tcurrentStencilFuncMask = stencilMask;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t\\tsetOp: function ( stencilFail, stencilZFail, stencilZPass ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( currentStencilFail\\t !== stencilFail \\t||\\r\\n\\t\\t\\t\\t\\t     currentStencilZFail !== stencilZFail ||\\r\\n\\t\\t\\t\\t\\t     currentStencilZPass !== stencilZPass ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgl.stencilOp( stencilFail, stencilZFail, stencilZPass );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcurrentStencilFail = stencilFail;\\r\\n\\t\\t\\t\\t\\t\\tcurrentStencilZFail = stencilZFail;\\r\\n\\t\\t\\t\\t\\t\\tcurrentStencilZPass = stencilZPass;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t\\tsetLocked: function ( lock ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tlocked = lock;\\r\\n\\r\\n\\t\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t\\tsetClear: function ( stencil ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( currentStencilClear !== stencil ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgl.clearStencil( stencil );\\r\\n\\t\\t\\t\\t\\t\\tcurrentStencilClear = stencil;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t\\treset: function () {\\r\\n\\r\\n\\t\\t\\t\\t\\tlocked = false;\\r\\n\\r\\n\\t\\t\\t\\t\\tcurrentStencilMask = null;\\r\\n\\t\\t\\t\\t\\tcurrentStencilFunc = null;\\r\\n\\t\\t\\t\\t\\tcurrentStencilRef = null;\\r\\n\\t\\t\\t\\t\\tcurrentStencilFuncMask = null;\\r\\n\\t\\t\\t\\t\\tcurrentStencilFail = null;\\r\\n\\t\\t\\t\\t\\tcurrentStencilZFail = null;\\r\\n\\t\\t\\t\\t\\tcurrentStencilZPass = null;\\r\\n\\t\\t\\t\\t\\tcurrentStencilClear = null;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tvar colorBuffer = new ColorBuffer();\\r\\n\\t\\tvar depthBuffer = new DepthBuffer();\\r\\n\\t\\tvar stencilBuffer = new StencilBuffer();\\r\\n\\r\\n\\t\\tvar maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\\r\\n\\t\\tvar newAttributes = new Uint8Array( maxVertexAttributes );\\r\\n\\t\\tvar enabledAttributes = new Uint8Array( maxVertexAttributes );\\r\\n\\t\\tvar attributeDivisors = new Uint8Array( maxVertexAttributes );\\r\\n\\r\\n\\t\\tvar capabilities = {};\\r\\n\\r\\n\\t\\tvar compressedTextureFormats = null;\\r\\n\\r\\n\\t\\tvar currentProgram = null;\\r\\n\\r\\n\\t\\tvar currentBlending = null;\\r\\n\\t\\tvar currentBlendEquation = null;\\r\\n\\t\\tvar currentBlendSrc = null;\\r\\n\\t\\tvar currentBlendDst = null;\\r\\n\\t\\tvar currentBlendEquationAlpha = null;\\r\\n\\t\\tvar currentBlendSrcAlpha = null;\\r\\n\\t\\tvar currentBlendDstAlpha = null;\\r\\n\\t\\tvar currentPremultipledAlpha = false;\\r\\n\\r\\n\\t\\tvar currentFlipSided = null;\\r\\n\\t\\tvar currentCullFace = null;\\r\\n\\r\\n\\t\\tvar currentLineWidth = null;\\r\\n\\r\\n\\t\\tvar currentPolygonOffsetFactor = null;\\r\\n\\t\\tvar currentPolygonOffsetUnits = null;\\r\\n\\r\\n\\t\\tvar maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );\\r\\n\\r\\n\\t\\tvar version = parseFloat( /^WebGL\\\\ ([0-9])/.exec( gl.getParameter( gl.VERSION ) )[ 1 ] );\\r\\n\\t\\tvar lineWidthAvailable = parseFloat( version ) >= 1.0;\\r\\n\\r\\n\\t\\tvar currentTextureSlot = null;\\r\\n\\t\\tvar currentBoundTextures = {};\\r\\n\\r\\n\\t\\tvar currentScissor = new Vector4();\\r\\n\\t\\tvar currentViewport = new Vector4();\\r\\n\\r\\n\\t\\tfunction createTexture( type, target, count ) {\\r\\n\\r\\n\\t\\t\\tvar data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\\r\\n\\t\\t\\tvar texture = gl.createTexture();\\r\\n\\r\\n\\t\\t\\tgl.bindTexture( type, texture );\\r\\n\\t\\t\\tgl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\\r\\n\\t\\t\\tgl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < count; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tgl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn texture;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar emptyTextures = {};\\r\\n\\t\\temptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );\\r\\n\\t\\temptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );\\r\\n\\r\\n\\t\\t// init\\r\\n\\r\\n\\t\\tcolorBuffer.setClear( 0, 0, 0, 1 );\\r\\n\\t\\tdepthBuffer.setClear( 1 );\\r\\n\\t\\tstencilBuffer.setClear( 0 );\\r\\n\\r\\n\\t\\tenable( gl.DEPTH_TEST );\\r\\n\\t\\tdepthBuffer.setFunc( LessEqualDepth );\\r\\n\\r\\n\\t\\tsetFlipSided( false );\\r\\n\\t\\tsetCullFace( CullFaceBack );\\r\\n\\t\\tenable( gl.CULL_FACE );\\r\\n\\r\\n\\t\\tenable( gl.BLEND );\\r\\n\\t\\tsetBlending( NormalBlending );\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tfunction initAttributes() {\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tnewAttributes[ i ] = 0;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction enableAttribute( attribute ) {\\r\\n\\r\\n\\t\\t\\tnewAttributes[ attribute ] = 1;\\r\\n\\r\\n\\t\\t\\tif ( enabledAttributes[ attribute ] === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tgl.enableVertexAttribArray( attribute );\\r\\n\\t\\t\\t\\tenabledAttributes[ attribute ] = 1;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( attributeDivisors[ attribute ] !== 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\\r\\n\\r\\n\\t\\t\\t\\textension.vertexAttribDivisorANGLE( attribute, 0 );\\r\\n\\t\\t\\t\\tattributeDivisors[ attribute ] = 0;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction enableAttributeAndDivisor( attribute, meshPerAttribute ) {\\r\\n\\r\\n\\t\\t\\tnewAttributes[ attribute ] = 1;\\r\\n\\r\\n\\t\\t\\tif ( enabledAttributes[ attribute ] === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tgl.enableVertexAttribArray( attribute );\\r\\n\\t\\t\\t\\tenabledAttributes[ attribute ] = 1;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\\r\\n\\r\\n\\t\\t\\t\\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\\r\\n\\r\\n\\t\\t\\t\\textension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );\\r\\n\\t\\t\\t\\tattributeDivisors[ attribute ] = meshPerAttribute;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction disableUnusedAttributes() {\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tgl.disableVertexAttribArray( i );\\r\\n\\t\\t\\t\\t\\tenabledAttributes[ i ] = 0;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction enable( id ) {\\r\\n\\r\\n\\t\\t\\tif ( capabilities[ id ] !== true ) {\\r\\n\\r\\n\\t\\t\\t\\tgl.enable( id );\\r\\n\\t\\t\\t\\tcapabilities[ id ] = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction disable( id ) {\\r\\n\\r\\n\\t\\t\\tif ( capabilities[ id ] !== false ) {\\r\\n\\r\\n\\t\\t\\t\\tgl.disable( id );\\r\\n\\t\\t\\t\\tcapabilities[ id ] = false;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction getCompressedTextureFormats() {\\r\\n\\r\\n\\t\\t\\tif ( compressedTextureFormats === null ) {\\r\\n\\r\\n\\t\\t\\t\\tcompressedTextureFormats = [];\\r\\n\\r\\n\\t\\t\\t\\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\\r\\n\\t\\t\\t\\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\\r\\n\\t\\t\\t\\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < formats.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcompressedTextureFormats.push( formats[ i ] );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn compressedTextureFormats;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction useProgram( program ) {\\r\\n\\r\\n\\t\\t\\tif ( currentProgram !== program ) {\\r\\n\\r\\n\\t\\t\\t\\tgl.useProgram( program );\\r\\n\\r\\n\\t\\t\\t\\tcurrentProgram = program;\\r\\n\\r\\n\\t\\t\\t\\treturn true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn false;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\\r\\n\\r\\n\\t\\t\\tif ( blending !== NoBlending ) {\\r\\n\\r\\n\\t\\t\\t\\tenable( gl.BLEND );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tdisable( gl.BLEND );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( blending !== CustomBlending ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tswitch ( blending ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase AdditiveBlending:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( premultipliedAlpha ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquation( gl.FUNC_ADD );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase SubtractiveBlending:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( premultipliedAlpha ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquation( gl.FUNC_ADD );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase MultiplyBlending:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( premultipliedAlpha ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquation( gl.FUNC_ADD );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tdefault:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( premultipliedAlpha ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tcurrentBlendEquation = null;\\r\\n\\t\\t\\t\\tcurrentBlendSrc = null;\\r\\n\\t\\t\\t\\tcurrentBlendDst = null;\\r\\n\\t\\t\\t\\tcurrentBlendEquationAlpha = null;\\r\\n\\t\\t\\t\\tcurrentBlendSrcAlpha = null;\\r\\n\\t\\t\\t\\tcurrentBlendDstAlpha = null;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tblendEquationAlpha = blendEquationAlpha || blendEquation;\\r\\n\\t\\t\\t\\tblendSrcAlpha = blendSrcAlpha || blendSrc;\\r\\n\\t\\t\\t\\tblendDstAlpha = blendDstAlpha || blendDst;\\r\\n\\r\\n\\t\\t\\t\\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tgl.blendEquationSeparate( utils.convert( blendEquation ), utils.convert( blendEquationAlpha ) );\\r\\n\\r\\n\\t\\t\\t\\t\\tcurrentBlendEquation = blendEquation;\\r\\n\\t\\t\\t\\t\\tcurrentBlendEquationAlpha = blendEquationAlpha;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tgl.blendFuncSeparate( utils.convert( blendSrc ), utils.convert( blendDst ), utils.convert( blendSrcAlpha ), utils.convert( blendDstAlpha ) );\\r\\n\\r\\n\\t\\t\\t\\t\\tcurrentBlendSrc = blendSrc;\\r\\n\\t\\t\\t\\t\\tcurrentBlendDst = blendDst;\\r\\n\\t\\t\\t\\t\\tcurrentBlendSrcAlpha = blendSrcAlpha;\\r\\n\\t\\t\\t\\t\\tcurrentBlendDstAlpha = blendDstAlpha;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tcurrentBlending = blending;\\r\\n\\t\\t\\tcurrentPremultipledAlpha = premultipliedAlpha;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction setMaterial( material, frontFaceCW ) {\\r\\n\\r\\n\\t\\t\\tmaterial.side === DoubleSide\\r\\n\\t\\t\\t\\t? disable( gl.CULL_FACE )\\r\\n\\t\\t\\t\\t: enable( gl.CULL_FACE );\\r\\n\\r\\n\\t\\t\\tvar flipSided = ( material.side === BackSide );\\r\\n\\t\\t\\tif ( frontFaceCW ) flipSided = ! flipSided;\\r\\n\\r\\n\\t\\t\\tsetFlipSided( flipSided );\\r\\n\\r\\n\\t\\t\\tmaterial.transparent === true\\r\\n\\t\\t\\t\\t? setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )\\r\\n\\t\\t\\t\\t: setBlending( NoBlending );\\r\\n\\r\\n\\t\\t\\tdepthBuffer.setFunc( material.depthFunc );\\r\\n\\t\\t\\tdepthBuffer.setTest( material.depthTest );\\r\\n\\t\\t\\tdepthBuffer.setMask( material.depthWrite );\\r\\n\\t\\t\\tcolorBuffer.setMask( material.colorWrite );\\r\\n\\r\\n\\t\\t\\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tfunction setFlipSided( flipSided ) {\\r\\n\\r\\n\\t\\t\\tif ( currentFlipSided !== flipSided ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( flipSided ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tgl.frontFace( gl.CW );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tgl.frontFace( gl.CCW );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tcurrentFlipSided = flipSided;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction setCullFace( cullFace ) {\\r\\n\\r\\n\\t\\t\\tif ( cullFace !== CullFaceNone ) {\\r\\n\\r\\n\\t\\t\\t\\tenable( gl.CULL_FACE );\\r\\n\\r\\n\\t\\t\\t\\tif ( cullFace !== currentCullFace ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( cullFace === CullFaceBack ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgl.cullFace( gl.BACK );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else if ( cullFace === CullFaceFront ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgl.cullFace( gl.FRONT );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgl.cullFace( gl.FRONT_AND_BACK );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tdisable( gl.CULL_FACE );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tcurrentCullFace = cullFace;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction setLineWidth( width ) {\\r\\n\\r\\n\\t\\t\\tif ( width !== currentLineWidth ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( lineWidthAvailable ) gl.lineWidth( width );\\r\\n\\r\\n\\t\\t\\t\\tcurrentLineWidth = width;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction setPolygonOffset( polygonOffset, factor, units ) {\\r\\n\\r\\n\\t\\t\\tif ( polygonOffset ) {\\r\\n\\r\\n\\t\\t\\t\\tenable( gl.POLYGON_OFFSET_FILL );\\r\\n\\r\\n\\t\\t\\t\\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tgl.polygonOffset( factor, units );\\r\\n\\r\\n\\t\\t\\t\\t\\tcurrentPolygonOffsetFactor = factor;\\r\\n\\t\\t\\t\\t\\tcurrentPolygonOffsetUnits = units;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tdisable( gl.POLYGON_OFFSET_FILL );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction setScissorTest( scissorTest ) {\\r\\n\\r\\n\\t\\t\\tif ( scissorTest ) {\\r\\n\\r\\n\\t\\t\\t\\tenable( gl.SCISSOR_TEST );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tdisable( gl.SCISSOR_TEST );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// texture\\r\\n\\r\\n\\t\\tfunction activeTexture( webglSlot ) {\\r\\n\\r\\n\\t\\t\\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\\r\\n\\r\\n\\t\\t\\tif ( currentTextureSlot !== webglSlot ) {\\r\\n\\r\\n\\t\\t\\t\\tgl.activeTexture( webglSlot );\\r\\n\\t\\t\\t\\tcurrentTextureSlot = webglSlot;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction bindTexture( webglType, webglTexture ) {\\r\\n\\r\\n\\t\\t\\tif ( currentTextureSlot === null ) {\\r\\n\\r\\n\\t\\t\\t\\tactiveTexture();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\\r\\n\\r\\n\\t\\t\\tif ( boundTexture === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tboundTexture = { type: undefined, texture: undefined };\\r\\n\\t\\t\\t\\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\\r\\n\\r\\n\\t\\t\\t\\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\\r\\n\\r\\n\\t\\t\\t\\tboundTexture.type = webglType;\\r\\n\\t\\t\\t\\tboundTexture.texture = webglTexture;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction compressedTexImage2D() {\\r\\n\\r\\n\\t\\t\\ttry {\\r\\n\\r\\n\\t\\t\\t\\tgl.compressedTexImage2D.apply( gl, arguments );\\r\\n\\r\\n\\t\\t\\t} catch ( error ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLState:', error );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction texImage2D() {\\r\\n\\r\\n\\t\\t\\ttry {\\r\\n\\r\\n\\t\\t\\t\\tgl.texImage2D.apply( gl, arguments );\\r\\n\\r\\n\\t\\t\\t} catch ( error ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLState:', error );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tfunction scissor( scissor ) {\\r\\n\\r\\n\\t\\t\\tif ( currentScissor.equals( scissor ) === false ) {\\r\\n\\r\\n\\t\\t\\t\\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\\r\\n\\t\\t\\t\\tcurrentScissor.copy( scissor );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction viewport( viewport ) {\\r\\n\\r\\n\\t\\t\\tif ( currentViewport.equals( viewport ) === false ) {\\r\\n\\r\\n\\t\\t\\t\\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\\r\\n\\t\\t\\t\\tcurrentViewport.copy( viewport );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tfunction reset() {\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( enabledAttributes[ i ] === 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tgl.disableVertexAttribArray( i );\\r\\n\\t\\t\\t\\t\\tenabledAttributes[ i ] = 0;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tcapabilities = {};\\r\\n\\r\\n\\t\\t\\tcompressedTextureFormats = null;\\r\\n\\r\\n\\t\\t\\tcurrentTextureSlot = null;\\r\\n\\t\\t\\tcurrentBoundTextures = {};\\r\\n\\r\\n\\t\\t\\tcurrentProgram = null;\\r\\n\\r\\n\\t\\t\\tcurrentBlending = null;\\r\\n\\r\\n\\t\\t\\tcurrentFlipSided = null;\\r\\n\\t\\t\\tcurrentCullFace = null;\\r\\n\\r\\n\\t\\t\\tcolorBuffer.reset();\\r\\n\\t\\t\\tdepthBuffer.reset();\\r\\n\\t\\t\\tstencilBuffer.reset();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn {\\r\\n\\r\\n\\t\\t\\tbuffers: {\\r\\n\\t\\t\\t\\tcolor: colorBuffer,\\r\\n\\t\\t\\t\\tdepth: depthBuffer,\\r\\n\\t\\t\\t\\tstencil: stencilBuffer\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tinitAttributes: initAttributes,\\r\\n\\t\\t\\tenableAttribute: enableAttribute,\\r\\n\\t\\t\\tenableAttributeAndDivisor: enableAttributeAndDivisor,\\r\\n\\t\\t\\tdisableUnusedAttributes: disableUnusedAttributes,\\r\\n\\t\\t\\tenable: enable,\\r\\n\\t\\t\\tdisable: disable,\\r\\n\\t\\t\\tgetCompressedTextureFormats: getCompressedTextureFormats,\\r\\n\\r\\n\\t\\t\\tuseProgram: useProgram,\\r\\n\\r\\n\\t\\t\\tsetBlending: setBlending,\\r\\n\\t\\t\\tsetMaterial: setMaterial,\\r\\n\\r\\n\\t\\t\\tsetFlipSided: setFlipSided,\\r\\n\\t\\t\\tsetCullFace: setCullFace,\\r\\n\\r\\n\\t\\t\\tsetLineWidth: setLineWidth,\\r\\n\\t\\t\\tsetPolygonOffset: setPolygonOffset,\\r\\n\\r\\n\\t\\t\\tsetScissorTest: setScissorTest,\\r\\n\\r\\n\\t\\t\\tactiveTexture: activeTexture,\\r\\n\\t\\t\\tbindTexture: bindTexture,\\r\\n\\t\\t\\tcompressedTexImage2D: compressedTexImage2D,\\r\\n\\t\\t\\ttexImage2D: texImage2D,\\r\\n\\r\\n\\t\\t\\tscissor: scissor,\\r\\n\\t\\t\\tviewport: viewport,\\r\\n\\r\\n\\t\\t\\treset: reset\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction WebGLCapabilities( gl, extensions, parameters ) {\\r\\n\\r\\n\\t\\tvar maxAnisotropy;\\r\\n\\r\\n\\t\\tfunction getMaxAnisotropy() {\\r\\n\\r\\n\\t\\t\\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\\r\\n\\r\\n\\t\\t\\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\\r\\n\\r\\n\\t\\t\\tif ( extension !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tmaxAnisotropy = 0;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn maxAnisotropy;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction getMaxPrecision( precision ) {\\r\\n\\r\\n\\t\\t\\tif ( precision === 'highp' ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\\r\\n\\t\\t\\t\\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn 'highp';\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tprecision = 'mediump';\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( precision === 'mediump' ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\\r\\n\\t\\t\\t\\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn 'mediump';\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn 'lowp';\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar precision = parameters.precision !== undefined ? parameters.precision : 'highp';\\r\\n\\t\\tvar maxPrecision = getMaxPrecision( precision );\\r\\n\\r\\n\\t\\tif ( maxPrecision !== precision ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );\\r\\n\\t\\t\\tprecision = maxPrecision;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;\\r\\n\\r\\n\\t\\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\\r\\n\\t\\tvar maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\\r\\n\\t\\tvar maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\\r\\n\\t\\tvar maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\\r\\n\\r\\n\\t\\tvar maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\\r\\n\\t\\tvar maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\\r\\n\\t\\tvar maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\\r\\n\\t\\tvar maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\\r\\n\\r\\n\\t\\tvar vertexTextures = maxVertexTextures > 0;\\r\\n\\t\\tvar floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\\r\\n\\t\\tvar floatVertexTextures = vertexTextures && floatFragmentTextures;\\r\\n\\r\\n\\t\\treturn {\\r\\n\\r\\n\\t\\t\\tgetMaxAnisotropy: getMaxAnisotropy,\\r\\n\\t\\t\\tgetMaxPrecision: getMaxPrecision,\\r\\n\\r\\n\\t\\t\\tprecision: precision,\\r\\n\\t\\t\\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\\r\\n\\r\\n\\t\\t\\tmaxTextures: maxTextures,\\r\\n\\t\\t\\tmaxVertexTextures: maxVertexTextures,\\r\\n\\t\\t\\tmaxTextureSize: maxTextureSize,\\r\\n\\t\\t\\tmaxCubemapSize: maxCubemapSize,\\r\\n\\r\\n\\t\\t\\tmaxAttributes: maxAttributes,\\r\\n\\t\\t\\tmaxVertexUniforms: maxVertexUniforms,\\r\\n\\t\\t\\tmaxVaryings: maxVaryings,\\r\\n\\t\\t\\tmaxFragmentUniforms: maxFragmentUniforms,\\r\\n\\r\\n\\t\\t\\tvertexTextures: vertexTextures,\\r\\n\\t\\t\\tfloatFragmentTextures: floatFragmentTextures,\\r\\n\\t\\t\\tfloatVertexTextures: floatVertexTextures\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author greggman / http://games.greggman.com/\\r\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\r\\n\\t * @author tschw\\r\\n\\t */\\r\\n\\r\\n\\tfunction PerspectiveCamera( fov, aspect, near, far ) {\\r\\n\\r\\n\\t\\tCamera.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'PerspectiveCamera';\\r\\n\\r\\n\\t\\tthis.fov = fov !== undefined ? fov : 50;\\r\\n\\t\\tthis.zoom = 1;\\r\\n\\r\\n\\t\\tthis.near = near !== undefined ? near : 0.1;\\r\\n\\t\\tthis.far = far !== undefined ? far : 2000;\\r\\n\\t\\tthis.focus = 10;\\r\\n\\r\\n\\t\\tthis.aspect = aspect !== undefined ? aspect : 1;\\r\\n\\t\\tthis.view = null;\\r\\n\\r\\n\\t\\tthis.filmGauge = 35;\\t// width of the film (default in millimeters)\\r\\n\\t\\tthis.filmOffset = 0;\\t// horizontal film offset (same unit as gauge)\\r\\n\\r\\n\\t\\tthis.updateProjectionMatrix();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tPerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: PerspectiveCamera,\\r\\n\\r\\n\\t\\tisPerspectiveCamera: true,\\r\\n\\r\\n\\t\\tcopy: function ( source, recursive ) {\\r\\n\\r\\n\\t\\t\\tCamera.prototype.copy.call( this, source, recursive );\\r\\n\\r\\n\\t\\t\\tthis.fov = source.fov;\\r\\n\\t\\t\\tthis.zoom = source.zoom;\\r\\n\\r\\n\\t\\t\\tthis.near = source.near;\\r\\n\\t\\t\\tthis.far = source.far;\\r\\n\\t\\t\\tthis.focus = source.focus;\\r\\n\\r\\n\\t\\t\\tthis.aspect = source.aspect;\\r\\n\\t\\t\\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\\r\\n\\r\\n\\t\\t\\tthis.filmGauge = source.filmGauge;\\r\\n\\t\\t\\tthis.filmOffset = source.filmOffset;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t * Sets the FOV by focal length in respect to the current .filmGauge.\\r\\n\\t\\t *\\r\\n\\t\\t * The default film gauge is 35, so that the focal length can be specified for\\r\\n\\t\\t * a 35mm (full frame) camera.\\r\\n\\t\\t *\\r\\n\\t\\t * Values for focal length and film gauge must have the same unit.\\r\\n\\t\\t */\\r\\n\\t\\tsetFocalLength: function ( focalLength ) {\\r\\n\\r\\n\\t\\t\\t// see http://www.bobatkins.com/photography/technical/field_of_view.html\\r\\n\\t\\t\\tvar vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\\r\\n\\r\\n\\t\\t\\tthis.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\\r\\n\\t\\t\\tthis.updateProjectionMatrix();\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t * Calculates the focal length from the current .fov and .filmGauge.\\r\\n\\t\\t */\\r\\n\\t\\tgetFocalLength: function () {\\r\\n\\r\\n\\t\\t\\tvar vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );\\r\\n\\r\\n\\t\\t\\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetEffectiveFOV: function () {\\r\\n\\r\\n\\t\\t\\treturn _Math.RAD2DEG * 2 * Math.atan(\\r\\n\\t\\t\\t\\tMath.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetFilmWidth: function () {\\r\\n\\r\\n\\t\\t\\t// film not completely covered in portrait format (aspect < 1)\\r\\n\\t\\t\\treturn this.filmGauge * Math.min( this.aspect, 1 );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetFilmHeight: function () {\\r\\n\\r\\n\\t\\t\\t// film not completely covered in landscape format (aspect > 1)\\r\\n\\t\\t\\treturn this.filmGauge / Math.max( this.aspect, 1 );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t * Sets an offset in a larger frustum. This is useful for multi-window or\\r\\n\\t\\t * multi-monitor/multi-machine setups.\\r\\n\\t\\t *\\r\\n\\t\\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\\r\\n\\t\\t * the monitors are in grid like this\\r\\n\\t\\t *\\r\\n\\t\\t *   +---+---+---+\\r\\n\\t\\t *   | A | B | C |\\r\\n\\t\\t *   +---+---+---+\\r\\n\\t\\t *   | D | E | F |\\r\\n\\t\\t *   +---+---+---+\\r\\n\\t\\t *\\r\\n\\t\\t * then for each monitor you would call it like this\\r\\n\\t\\t *\\r\\n\\t\\t *   var w = 1920;\\r\\n\\t\\t *   var h = 1080;\\r\\n\\t\\t *   var fullWidth = w * 3;\\r\\n\\t\\t *   var fullHeight = h * 2;\\r\\n\\t\\t *\\r\\n\\t\\t *   --A--\\r\\n\\t\\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\\r\\n\\t\\t *   --B--\\r\\n\\t\\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\\r\\n\\t\\t *   --C--\\r\\n\\t\\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\\r\\n\\t\\t *   --D--\\r\\n\\t\\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\\r\\n\\t\\t *   --E--\\r\\n\\t\\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\\r\\n\\t\\t *   --F--\\r\\n\\t\\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\\r\\n\\t\\t *\\r\\n\\t\\t *   Note there is no reason monitors have to be the same size or in a grid.\\r\\n\\t\\t */\\r\\n\\t\\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\\r\\n\\r\\n\\t\\t\\tthis.aspect = fullWidth / fullHeight;\\r\\n\\r\\n\\t\\t\\tif ( this.view === null ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.view = {\\r\\n\\t\\t\\t\\t\\tenabled: true,\\r\\n\\t\\t\\t\\t\\tfullWidth: 1,\\r\\n\\t\\t\\t\\t\\tfullHeight: 1,\\r\\n\\t\\t\\t\\t\\toffsetX: 0,\\r\\n\\t\\t\\t\\t\\toffsetY: 0,\\r\\n\\t\\t\\t\\t\\twidth: 1,\\r\\n\\t\\t\\t\\t\\theight: 1\\r\\n\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.view.enabled = true;\\r\\n\\t\\t\\tthis.view.fullWidth = fullWidth;\\r\\n\\t\\t\\tthis.view.fullHeight = fullHeight;\\r\\n\\t\\t\\tthis.view.offsetX = x;\\r\\n\\t\\t\\tthis.view.offsetY = y;\\r\\n\\t\\t\\tthis.view.width = width;\\r\\n\\t\\t\\tthis.view.height = height;\\r\\n\\r\\n\\t\\t\\tthis.updateProjectionMatrix();\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclearViewOffset: function () {\\r\\n\\r\\n\\t\\t\\tif ( this.view !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.view.enabled = false;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.updateProjectionMatrix();\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tupdateProjectionMatrix: function () {\\r\\n\\r\\n\\t\\t\\tvar near = this.near,\\r\\n\\t\\t\\t\\ttop = near * Math.tan(\\r\\n\\t\\t\\t\\t\\t_Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,\\r\\n\\t\\t\\t\\theight = 2 * top,\\r\\n\\t\\t\\t\\twidth = this.aspect * height,\\r\\n\\t\\t\\t\\tleft = - 0.5 * width,\\r\\n\\t\\t\\t\\tview = this.view;\\r\\n\\r\\n\\t\\t\\tif ( this.view !== null && this.view.enabled ) {\\r\\n\\r\\n\\t\\t\\t\\tvar fullWidth = view.fullWidth,\\r\\n\\t\\t\\t\\t\\tfullHeight = view.fullHeight;\\r\\n\\r\\n\\t\\t\\t\\tleft += view.offsetX * width / fullWidth;\\r\\n\\t\\t\\t\\ttop -= view.offsetY * height / fullHeight;\\r\\n\\t\\t\\t\\twidth *= view.width / fullWidth;\\r\\n\\t\\t\\t\\theight *= view.height / fullHeight;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar skew = this.filmOffset;\\r\\n\\t\\t\\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\\r\\n\\r\\n\\t\\t\\tthis.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttoJSON: function ( meta ) {\\r\\n\\r\\n\\t\\t\\tvar data = Object3D.prototype.toJSON.call( this, meta );\\r\\n\\r\\n\\t\\t\\tdata.object.fov = this.fov;\\r\\n\\t\\t\\tdata.object.zoom = this.zoom;\\r\\n\\r\\n\\t\\t\\tdata.object.near = this.near;\\r\\n\\t\\t\\tdata.object.far = this.far;\\r\\n\\t\\t\\tdata.object.focus = this.focus;\\r\\n\\r\\n\\t\\t\\tdata.object.aspect = this.aspect;\\r\\n\\r\\n\\t\\t\\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\\r\\n\\r\\n\\t\\t\\tdata.object.filmGauge = this.filmGauge;\\r\\n\\t\\t\\tdata.object.filmOffset = this.filmOffset;\\r\\n\\r\\n\\t\\t\\treturn data;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction ArrayCamera( array ) {\\r\\n\\r\\n\\t\\tPerspectiveCamera.call( this );\\r\\n\\r\\n\\t\\tthis.cameras = array || [];\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: ArrayCamera,\\r\\n\\r\\n\\t\\tisArrayCamera: true\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction WebVRManager( renderer ) {\\r\\n\\r\\n\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\tvar device = null;\\r\\n\\t\\tvar frameData = null;\\r\\n\\r\\n\\t\\tvar poseTarget = null;\\r\\n\\r\\n\\t\\tif ( typeof window !== 'undefined' && 'VRFrameData' in window ) {\\r\\n\\r\\n\\t\\t\\tframeData = new window.VRFrameData();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar matrixWorldInverse = new Matrix4();\\r\\n\\r\\n\\t\\tvar cameraL = new PerspectiveCamera();\\r\\n\\t\\tcameraL.bounds = new Vector4( 0.0, 0.0, 0.5, 1.0 );\\r\\n\\t\\tcameraL.layers.enable( 1 );\\r\\n\\r\\n\\t\\tvar cameraR = new PerspectiveCamera();\\r\\n\\t\\tcameraR.bounds = new Vector4( 0.5, 0.0, 0.5, 1.0 );\\r\\n\\t\\tcameraR.layers.enable( 2 );\\r\\n\\r\\n\\t\\tvar cameraVR = new ArrayCamera( [ cameraL, cameraR ] );\\r\\n\\t\\tcameraVR.layers.enable( 1 );\\r\\n\\t\\tcameraVR.layers.enable( 2 );\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tvar currentSize, currentPixelRatio;\\r\\n\\r\\n\\t\\tfunction onVRDisplayPresentChange() {\\r\\n\\r\\n\\t\\t\\tif ( device !== null && device.isPresenting ) {\\r\\n\\r\\n\\t\\t\\t\\tvar eyeParameters = device.getEyeParameters( 'left' );\\r\\n\\t\\t\\t\\tvar renderWidth = eyeParameters.renderWidth;\\r\\n\\t\\t\\t\\tvar renderHeight = eyeParameters.renderHeight;\\r\\n\\r\\n\\t\\t\\t\\tcurrentPixelRatio = renderer.getPixelRatio();\\r\\n\\t\\t\\t\\tcurrentSize = renderer.getSize();\\r\\n\\r\\n\\t\\t\\t\\trenderer.setDrawingBufferSize( renderWidth * 2, renderHeight, 1 );\\r\\n\\r\\n\\t\\t\\t} else if ( scope.enabled ) {\\r\\n\\r\\n\\t\\t\\t\\trenderer.setDrawingBufferSize( currentSize.width, currentSize.height, currentPixelRatio );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( typeof window !== 'undefined' ) {\\r\\n\\r\\n\\t\\t\\twindow.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tthis.enabled = false;\\r\\n\\r\\n\\t\\tthis.getDevice = function () {\\r\\n\\r\\n\\t\\t\\treturn device;\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.setDevice = function ( value ) {\\r\\n\\r\\n\\t\\t\\tif ( value !== undefined ) device = value;\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.setPoseTarget = function ( object ) {\\r\\n\\r\\n\\t\\t\\tif ( object !== undefined ) poseTarget = object;\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.getCamera = function ( camera ) {\\r\\n\\r\\n\\t\\t\\tif ( device === null ) return camera;\\r\\n\\r\\n\\t\\t\\tdevice.depthNear = camera.near;\\r\\n\\t\\t\\tdevice.depthFar = camera.far;\\r\\n\\r\\n\\t\\t\\tdevice.getFrameData( frameData );\\r\\n\\r\\n\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\tvar pose = frameData.pose;\\r\\n\\t\\t\\tvar poseObject = poseTarget !== null ? poseTarget : camera;\\r\\n\\r\\n\\t\\t\\tif ( pose.position !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tposeObject.position.fromArray( pose.position );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tposeObject.position.set( 0, 0, 0 );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( pose.orientation !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tposeObject.quaternion.fromArray( pose.orientation );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tposeObject.updateMatrixWorld();\\r\\n\\r\\n\\t\\t\\tif ( device.isPresenting === false ) return camera;\\r\\n\\r\\n\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\tcameraL.near = camera.near;\\r\\n\\t\\t\\tcameraR.near = camera.near;\\r\\n\\r\\n\\t\\t\\tcameraL.far = camera.far;\\r\\n\\t\\t\\tcameraR.far = camera.far;\\r\\n\\r\\n\\t\\t\\tcameraVR.matrixWorld.copy( camera.matrixWorld );\\r\\n\\t\\t\\tcameraVR.matrixWorldInverse.copy( camera.matrixWorldInverse );\\r\\n\\r\\n\\t\\t\\tcameraL.matrixWorldInverse.fromArray( frameData.leftViewMatrix );\\r\\n\\t\\t\\tcameraR.matrixWorldInverse.fromArray( frameData.rightViewMatrix );\\r\\n\\r\\n\\t\\t\\tvar parent = poseObject.parent;\\r\\n\\r\\n\\t\\t\\tif ( parent !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tmatrixWorldInverse.getInverse( parent.matrixWorld );\\r\\n\\r\\n\\t\\t\\t\\tcameraL.matrixWorldInverse.multiply( matrixWorldInverse );\\r\\n\\t\\t\\t\\tcameraR.matrixWorldInverse.multiply( matrixWorldInverse );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// envMap and Mirror needs camera.matrixWorld\\r\\n\\r\\n\\t\\t\\tcameraL.matrixWorld.getInverse( cameraL.matrixWorldInverse );\\r\\n\\t\\t\\tcameraR.matrixWorld.getInverse( cameraR.matrixWorldInverse );\\r\\n\\r\\n\\t\\t\\tcameraL.projectionMatrix.fromArray( frameData.leftProjectionMatrix );\\r\\n\\t\\t\\tcameraR.projectionMatrix.fromArray( frameData.rightProjectionMatrix );\\r\\n\\r\\n\\t\\t\\t// HACK @mrdoob\\r\\n\\t\\t\\t// https://github.com/w3c/webvr/issues/203\\r\\n\\r\\n\\t\\t\\tcameraVR.projectionMatrix.copy( cameraL.projectionMatrix );\\r\\n\\r\\n\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\tvar layers = device.getLayers();\\r\\n\\r\\n\\t\\t\\tif ( layers.length ) {\\r\\n\\r\\n\\t\\t\\t\\tvar layer = layers[ 0 ];\\r\\n\\r\\n\\t\\t\\t\\tif ( layer.leftBounds !== null && layer.leftBounds.length === 4 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcameraL.bounds.fromArray( layer.leftBounds );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( layer.rightBounds !== null && layer.rightBounds.length === 4 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcameraR.bounds.fromArray( layer.rightBounds );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn cameraVR;\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.submitFrame = function () {\\r\\n\\r\\n\\t\\t\\tif ( device && device.isPresenting ) device.submitFrame();\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.dispose = function () {\\r\\n\\r\\n\\t\\t\\tif ( typeof window !== 'undefined' ) {\\r\\n\\r\\n\\t\\t\\t\\twindow.removeEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction WebGLExtensions( gl ) {\\r\\n\\r\\n\\t\\tvar extensions = {};\\r\\n\\r\\n\\t\\treturn {\\r\\n\\r\\n\\t\\t\\tget: function ( name ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( extensions[ name ] !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn extensions[ name ];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tvar extension;\\r\\n\\r\\n\\t\\t\\t\\tswitch ( name ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'WEBGL_depth_texture':\\r\\n\\t\\t\\t\\t\\t\\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'EXT_texture_filter_anisotropic':\\r\\n\\t\\t\\t\\t\\t\\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'WEBGL_compressed_texture_s3tc':\\r\\n\\t\\t\\t\\t\\t\\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'WEBGL_compressed_texture_pvrtc':\\r\\n\\t\\t\\t\\t\\t\\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'WEBGL_compressed_texture_etc1':\\r\\n\\t\\t\\t\\t\\t\\textension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tdefault:\\r\\n\\t\\t\\t\\t\\t\\textension = gl.getExtension( name );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( extension === null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\textensions[ name ] = extension;\\r\\n\\r\\n\\t\\t\\t\\treturn extension;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @author tschw\\r\\n\\t */\\r\\n\\r\\n\\tfunction WebGLClipping() {\\r\\n\\r\\n\\t\\tvar scope = this,\\r\\n\\r\\n\\t\\t\\tglobalState = null,\\r\\n\\t\\t\\tnumGlobalPlanes = 0,\\r\\n\\t\\t\\tlocalClippingEnabled = false,\\r\\n\\t\\t\\trenderingShadows = false,\\r\\n\\r\\n\\t\\t\\tplane = new Plane(),\\r\\n\\t\\t\\tviewNormalMatrix = new Matrix3(),\\r\\n\\r\\n\\t\\t\\tuniform = { value: null, needsUpdate: false };\\r\\n\\r\\n\\t\\tthis.uniform = uniform;\\r\\n\\t\\tthis.numPlanes = 0;\\r\\n\\t\\tthis.numIntersection = 0;\\r\\n\\r\\n\\t\\tthis.init = function ( planes, enableLocalClipping, camera ) {\\r\\n\\r\\n\\t\\t\\tvar enabled =\\r\\n\\t\\t\\t\\tplanes.length !== 0 ||\\r\\n\\t\\t\\t\\tenableLocalClipping ||\\r\\n\\t\\t\\t\\t// enable state of previous frame - the clipping code has to\\r\\n\\t\\t\\t\\t// run another frame in order to reset the state:\\r\\n\\t\\t\\t\\tnumGlobalPlanes !== 0 ||\\r\\n\\t\\t\\t\\tlocalClippingEnabled;\\r\\n\\r\\n\\t\\t\\tlocalClippingEnabled = enableLocalClipping;\\r\\n\\r\\n\\t\\t\\tglobalState = projectPlanes( planes, camera, 0 );\\r\\n\\t\\t\\tnumGlobalPlanes = planes.length;\\r\\n\\r\\n\\t\\t\\treturn enabled;\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.beginShadows = function () {\\r\\n\\r\\n\\t\\t\\trenderingShadows = true;\\r\\n\\t\\t\\tprojectPlanes( null );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.endShadows = function () {\\r\\n\\r\\n\\t\\t\\trenderingShadows = false;\\r\\n\\t\\t\\tresetGlobalState();\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.setState = function ( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {\\r\\n\\r\\n\\t\\t\\tif ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {\\r\\n\\r\\n\\t\\t\\t\\t// there's no local clipping\\r\\n\\r\\n\\t\\t\\t\\tif ( renderingShadows ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// there's no global clipping\\r\\n\\r\\n\\t\\t\\t\\t\\tprojectPlanes( null );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tresetGlobalState();\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tvar nGlobal = renderingShadows ? 0 : numGlobalPlanes,\\r\\n\\t\\t\\t\\t\\tlGlobal = nGlobal * 4,\\r\\n\\r\\n\\t\\t\\t\\t\\tdstArray = cache.clippingState || null;\\r\\n\\r\\n\\t\\t\\t\\tuniform.value = dstArray; // ensure unique state\\r\\n\\r\\n\\t\\t\\t\\tdstArray = projectPlanes( planes, camera, lGlobal, fromCache );\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0; i !== lGlobal; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tdstArray[ i ] = globalState[ i ];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tcache.clippingState = dstArray;\\r\\n\\t\\t\\t\\tthis.numIntersection = clipIntersection ? this.numPlanes : 0;\\r\\n\\t\\t\\t\\tthis.numPlanes += nGlobal;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tfunction resetGlobalState() {\\r\\n\\r\\n\\t\\t\\tif ( uniform.value !== globalState ) {\\r\\n\\r\\n\\t\\t\\t\\tuniform.value = globalState;\\r\\n\\t\\t\\t\\tuniform.needsUpdate = numGlobalPlanes > 0;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tscope.numPlanes = numGlobalPlanes;\\r\\n\\t\\t\\tscope.numIntersection = 0;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\\r\\n\\r\\n\\t\\t\\tvar nPlanes = planes !== null ? planes.length : 0,\\r\\n\\t\\t\\t\\tdstArray = null;\\r\\n\\r\\n\\t\\t\\tif ( nPlanes !== 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tdstArray = uniform.value;\\r\\n\\r\\n\\t\\t\\t\\tif ( skipTransform !== true || dstArray === null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar flatSize = dstOffset + nPlanes * 4,\\r\\n\\t\\t\\t\\t\\t\\tviewMatrix = camera.matrixWorldInverse;\\r\\n\\r\\n\\t\\t\\t\\t\\tviewNormalMatrix.getNormalMatrix( viewMatrix );\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( dstArray === null || dstArray.length < flatSize ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tdstArray = new Float32Array( flatSize );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tplane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tplane.normal.toArray( dstArray, i4 );\\r\\n\\t\\t\\t\\t\\t\\tdstArray[ i4 + 3 ] = plane.constant;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tuniform.value = dstArray;\\r\\n\\t\\t\\t\\tuniform.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tscope.numPlanes = nPlanes;\\r\\n\\r\\n\\t\\t\\treturn dstArray;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @author thespite / http://www.twitter.com/thespite\\r\\n\\t */\\r\\n\\r\\n\\tfunction WebGLUtils( gl, extensions ) {\\r\\n\\r\\n\\t\\tfunction convert( p ) {\\r\\n\\r\\n\\t\\t\\tvar extension;\\r\\n\\r\\n\\t\\t\\tif ( p === RepeatWrapping ) return gl.REPEAT;\\r\\n\\t\\t\\tif ( p === ClampToEdgeWrapping ) return gl.CLAMP_TO_EDGE;\\r\\n\\t\\t\\tif ( p === MirroredRepeatWrapping ) return gl.MIRRORED_REPEAT;\\r\\n\\r\\n\\t\\t\\tif ( p === NearestFilter ) return gl.NEAREST;\\r\\n\\t\\t\\tif ( p === NearestMipMapNearestFilter ) return gl.NEAREST_MIPMAP_NEAREST;\\r\\n\\t\\t\\tif ( p === NearestMipMapLinearFilter ) return gl.NEAREST_MIPMAP_LINEAR;\\r\\n\\r\\n\\t\\t\\tif ( p === LinearFilter ) return gl.LINEAR;\\r\\n\\t\\t\\tif ( p === LinearMipMapNearestFilter ) return gl.LINEAR_MIPMAP_NEAREST;\\r\\n\\t\\t\\tif ( p === LinearMipMapLinearFilter ) return gl.LINEAR_MIPMAP_LINEAR;\\r\\n\\r\\n\\t\\t\\tif ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;\\r\\n\\t\\t\\tif ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;\\r\\n\\t\\t\\tif ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;\\r\\n\\t\\t\\tif ( p === UnsignedShort565Type ) return gl.UNSIGNED_SHORT_5_6_5;\\r\\n\\r\\n\\t\\t\\tif ( p === ByteType ) return gl.BYTE;\\r\\n\\t\\t\\tif ( p === ShortType ) return gl.SHORT;\\r\\n\\t\\t\\tif ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;\\r\\n\\t\\t\\tif ( p === IntType ) return gl.INT;\\r\\n\\t\\t\\tif ( p === UnsignedIntType ) return gl.UNSIGNED_INT;\\r\\n\\t\\t\\tif ( p === FloatType ) return gl.FLOAT;\\r\\n\\r\\n\\t\\t\\tif ( p === HalfFloatType ) {\\r\\n\\r\\n\\t\\t\\t\\textension = extensions.get( 'OES_texture_half_float' );\\r\\n\\r\\n\\t\\t\\t\\tif ( extension !== null ) return extension.HALF_FLOAT_OES;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( p === AlphaFormat ) return gl.ALPHA;\\r\\n\\t\\t\\tif ( p === RGBFormat ) return gl.RGB;\\r\\n\\t\\t\\tif ( p === RGBAFormat ) return gl.RGBA;\\r\\n\\t\\t\\tif ( p === LuminanceFormat ) return gl.LUMINANCE;\\r\\n\\t\\t\\tif ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;\\r\\n\\t\\t\\tif ( p === DepthFormat ) return gl.DEPTH_COMPONENT;\\r\\n\\t\\t\\tif ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;\\r\\n\\r\\n\\t\\t\\tif ( p === AddEquation ) return gl.FUNC_ADD;\\r\\n\\t\\t\\tif ( p === SubtractEquation ) return gl.FUNC_SUBTRACT;\\r\\n\\t\\t\\tif ( p === ReverseSubtractEquation ) return gl.FUNC_REVERSE_SUBTRACT;\\r\\n\\r\\n\\t\\t\\tif ( p === ZeroFactor ) return gl.ZERO;\\r\\n\\t\\t\\tif ( p === OneFactor ) return gl.ONE;\\r\\n\\t\\t\\tif ( p === SrcColorFactor ) return gl.SRC_COLOR;\\r\\n\\t\\t\\tif ( p === OneMinusSrcColorFactor ) return gl.ONE_MINUS_SRC_COLOR;\\r\\n\\t\\t\\tif ( p === SrcAlphaFactor ) return gl.SRC_ALPHA;\\r\\n\\t\\t\\tif ( p === OneMinusSrcAlphaFactor ) return gl.ONE_MINUS_SRC_ALPHA;\\r\\n\\t\\t\\tif ( p === DstAlphaFactor ) return gl.DST_ALPHA;\\r\\n\\t\\t\\tif ( p === OneMinusDstAlphaFactor ) return gl.ONE_MINUS_DST_ALPHA;\\r\\n\\r\\n\\t\\t\\tif ( p === DstColorFactor ) return gl.DST_COLOR;\\r\\n\\t\\t\\tif ( p === OneMinusDstColorFactor ) return gl.ONE_MINUS_DST_COLOR;\\r\\n\\t\\t\\tif ( p === SrcAlphaSaturateFactor ) return gl.SRC_ALPHA_SATURATE;\\r\\n\\r\\n\\t\\t\\tif ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||\\r\\n\\t\\t\\t\\tp === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {\\r\\n\\r\\n\\t\\t\\t\\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\\r\\n\\r\\n\\t\\t\\t\\tif ( extension !== null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\\r\\n\\t\\t\\t\\t\\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\\r\\n\\t\\t\\t\\t\\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\\r\\n\\t\\t\\t\\t\\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||\\r\\n\\t\\t\\t\\tp === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {\\r\\n\\r\\n\\t\\t\\t\\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\\r\\n\\r\\n\\t\\t\\t\\tif ( extension !== null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\\r\\n\\t\\t\\t\\t\\tif ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\\r\\n\\t\\t\\t\\t\\tif ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\\r\\n\\t\\t\\t\\t\\tif ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( p === RGB_ETC1_Format ) {\\r\\n\\r\\n\\t\\t\\t\\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\\r\\n\\r\\n\\t\\t\\t\\tif ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( p === MinEquation || p === MaxEquation ) {\\r\\n\\r\\n\\t\\t\\t\\textension = extensions.get( 'EXT_blend_minmax' );\\r\\n\\r\\n\\t\\t\\t\\tif ( extension !== null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( p === MinEquation ) return extension.MIN_EXT;\\r\\n\\t\\t\\t\\t\\tif ( p === MaxEquation ) return extension.MAX_EXT;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( p === UnsignedInt248Type ) {\\r\\n\\r\\n\\t\\t\\t\\textension = extensions.get( 'WEBGL_depth_texture' );\\r\\n\\r\\n\\t\\t\\t\\tif ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn 0;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn { convert: convert };\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @author supereggbert / http://www.paulbrunt.co.uk/\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t * @author szimek / https://github.com/szimek/\\r\\n\\t * @author tschw\\r\\n\\t */\\r\\n\\r\\n\\tfunction WebGLRenderer( parameters ) {\\r\\n\\r\\n\\t\\tconsole.log( 'THREE.WebGLRenderer', REVISION );\\r\\n\\r\\n\\t\\tparameters = parameters || {};\\r\\n\\r\\n\\t\\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),\\r\\n\\t\\t\\t_context = parameters.context !== undefined ? parameters.context : null,\\r\\n\\r\\n\\t\\t\\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\\r\\n\\t\\t\\t_depth = parameters.depth !== undefined ? parameters.depth : true,\\r\\n\\t\\t\\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\\r\\n\\t\\t\\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\\r\\n\\t\\t\\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\\r\\n\\t\\t\\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\\r\\n\\t\\t\\t_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default';\\r\\n\\r\\n\\t\\tvar lightsArray = [];\\r\\n\\t\\tvar shadowsArray = [];\\r\\n\\r\\n\\t\\tvar currentRenderList = null;\\r\\n\\r\\n\\t\\tvar spritesArray = [];\\r\\n\\t\\tvar flaresArray = [];\\r\\n\\r\\n\\t\\t// public properties\\r\\n\\r\\n\\t\\tthis.domElement = _canvas;\\r\\n\\t\\tthis.context = null;\\r\\n\\r\\n\\t\\t// clearing\\r\\n\\r\\n\\t\\tthis.autoClear = true;\\r\\n\\t\\tthis.autoClearColor = true;\\r\\n\\t\\tthis.autoClearDepth = true;\\r\\n\\t\\tthis.autoClearStencil = true;\\r\\n\\r\\n\\t\\t// scene graph\\r\\n\\r\\n\\t\\tthis.sortObjects = true;\\r\\n\\r\\n\\t\\t// user-defined clipping\\r\\n\\r\\n\\t\\tthis.clippingPlanes = [];\\r\\n\\t\\tthis.localClippingEnabled = false;\\r\\n\\r\\n\\t\\t// physically based shading\\r\\n\\r\\n\\t\\tthis.gammaFactor = 2.0;\\t// for backwards compatibility\\r\\n\\t\\tthis.gammaInput = false;\\r\\n\\t\\tthis.gammaOutput = false;\\r\\n\\r\\n\\t\\t// physical lights\\r\\n\\r\\n\\t\\tthis.physicallyCorrectLights = false;\\r\\n\\r\\n\\t\\t// tone mapping\\r\\n\\r\\n\\t\\tthis.toneMapping = LinearToneMapping;\\r\\n\\t\\tthis.toneMappingExposure = 1.0;\\r\\n\\t\\tthis.toneMappingWhitePoint = 1.0;\\r\\n\\r\\n\\t\\t// morphs\\r\\n\\r\\n\\t\\tthis.maxMorphTargets = 8;\\r\\n\\t\\tthis.maxMorphNormals = 4;\\r\\n\\r\\n\\t\\t// internal properties\\r\\n\\r\\n\\t\\tvar _this = this,\\r\\n\\r\\n\\t\\t\\t_isContextLost = false,\\r\\n\\r\\n\\t\\t\\t// internal state cache\\r\\n\\r\\n\\t\\t\\t_currentRenderTarget = null,\\r\\n\\t\\t\\t_currentFramebuffer = null,\\r\\n\\t\\t\\t_currentMaterialId = - 1,\\r\\n\\t\\t\\t_currentGeometryProgram = '',\\r\\n\\r\\n\\t\\t\\t_currentCamera = null,\\r\\n\\t\\t\\t_currentArrayCamera = null,\\r\\n\\r\\n\\t\\t\\t_currentViewport = new Vector4(),\\r\\n\\t\\t\\t_currentScissor = new Vector4(),\\r\\n\\t\\t\\t_currentScissorTest = null,\\r\\n\\r\\n\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\t_usedTextureUnits = 0,\\r\\n\\r\\n\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\t_width = _canvas.width,\\r\\n\\t\\t\\t_height = _canvas.height,\\r\\n\\r\\n\\t\\t\\t_pixelRatio = 1,\\r\\n\\r\\n\\t\\t\\t_viewport = new Vector4( 0, 0, _width, _height ),\\r\\n\\t\\t\\t_scissor = new Vector4( 0, 0, _width, _height ),\\r\\n\\t\\t\\t_scissorTest = false,\\r\\n\\r\\n\\t\\t\\t// frustum\\r\\n\\r\\n\\t\\t\\t_frustum = new Frustum(),\\r\\n\\r\\n\\t\\t\\t// clipping\\r\\n\\r\\n\\t\\t\\t_clipping = new WebGLClipping(),\\r\\n\\t\\t\\t_clippingEnabled = false,\\r\\n\\t\\t\\t_localClippingEnabled = false,\\r\\n\\r\\n\\t\\t\\t// camera matrices cache\\r\\n\\r\\n\\t\\t\\t_projScreenMatrix = new Matrix4(),\\r\\n\\r\\n\\t\\t\\t_vector3 = new Vector3(),\\r\\n\\r\\n\\t\\t\\t// info\\r\\n\\r\\n\\t\\t\\t_infoMemory = {\\r\\n\\t\\t\\t\\tgeometries: 0,\\r\\n\\t\\t\\t\\ttextures: 0\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t_infoRender = {\\r\\n\\r\\n\\t\\t\\t\\tframe: 0,\\r\\n\\t\\t\\t\\tcalls: 0,\\r\\n\\t\\t\\t\\tvertices: 0,\\r\\n\\t\\t\\t\\tfaces: 0,\\r\\n\\t\\t\\t\\tpoints: 0\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\tthis.info = {\\r\\n\\r\\n\\t\\t\\trender: _infoRender,\\r\\n\\t\\t\\tmemory: _infoMemory,\\r\\n\\t\\t\\tprograms: null\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tfunction getTargetPixelRatio() {\\r\\n\\r\\n\\t\\t\\treturn _currentRenderTarget === null ? _pixelRatio : 1;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// initialize\\r\\n\\r\\n\\t\\tvar _gl;\\r\\n\\r\\n\\t\\ttry {\\r\\n\\r\\n\\t\\t\\tvar contextAttributes = {\\r\\n\\t\\t\\t\\talpha: _alpha,\\r\\n\\t\\t\\t\\tdepth: _depth,\\r\\n\\t\\t\\t\\tstencil: _stencil,\\r\\n\\t\\t\\t\\tantialias: _antialias,\\r\\n\\t\\t\\t\\tpremultipliedAlpha: _premultipliedAlpha,\\r\\n\\t\\t\\t\\tpreserveDrawingBuffer: _preserveDrawingBuffer,\\r\\n\\t\\t\\t\\tpowerPreference: _powerPreference\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t// event listeners must be registered before WebGL context is created, see #12753\\r\\n\\r\\n\\t\\t\\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\\r\\n\\t\\t\\t_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );\\r\\n\\r\\n\\t\\t\\t_gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );\\r\\n\\r\\n\\t\\t\\tif ( _gl === null ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( _canvas.getContext( 'webgl' ) !== null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthrow new Error( 'Error creating WebGL context with your selected attributes.' );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tthrow new Error( 'Error creating WebGL context.' );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\\r\\n\\r\\n\\t\\t\\tif ( _gl.getShaderPrecisionFormat === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t_gl.getShaderPrecisionFormat = function () {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\\r\\n\\r\\n\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} catch ( error ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.WebGLRenderer: ' + error.message );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar extensions, capabilities, state;\\r\\n\\t\\tvar properties, textures, attributes, geometries, objects, lights;\\r\\n\\t\\tvar programCache, renderLists;\\r\\n\\r\\n\\t\\tvar background, morphtargets, bufferRenderer, indexedBufferRenderer;\\r\\n\\t\\tvar flareRenderer, spriteRenderer;\\r\\n\\r\\n\\t\\tvar utils;\\r\\n\\r\\n\\t\\tfunction initGLContext() {\\r\\n\\r\\n\\t\\t\\textensions = new WebGLExtensions( _gl );\\r\\n\\t\\t\\textensions.get( 'WEBGL_depth_texture' );\\r\\n\\t\\t\\textensions.get( 'OES_texture_float' );\\r\\n\\t\\t\\textensions.get( 'OES_texture_float_linear' );\\r\\n\\t\\t\\textensions.get( 'OES_texture_half_float' );\\r\\n\\t\\t\\textensions.get( 'OES_texture_half_float_linear' );\\r\\n\\t\\t\\textensions.get( 'OES_standard_derivatives' );\\r\\n\\t\\t\\textensions.get( 'OES_element_index_uint' );\\r\\n\\t\\t\\textensions.get( 'ANGLE_instanced_arrays' );\\r\\n\\r\\n\\t\\t\\tutils = new WebGLUtils( _gl, extensions );\\r\\n\\r\\n\\t\\t\\tcapabilities = new WebGLCapabilities( _gl, extensions, parameters );\\r\\n\\r\\n\\t\\t\\tstate = new WebGLState( _gl, extensions, utils );\\r\\n\\t\\t\\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\\r\\n\\t\\t\\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\\r\\n\\r\\n\\t\\t\\tproperties = new WebGLProperties();\\r\\n\\t\\t\\ttextures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, _infoMemory );\\r\\n\\t\\t\\tattributes = new WebGLAttributes( _gl );\\r\\n\\t\\t\\tgeometries = new WebGLGeometries( _gl, attributes, _infoMemory );\\r\\n\\t\\t\\tobjects = new WebGLObjects( geometries, _infoRender );\\r\\n\\t\\t\\tmorphtargets = new WebGLMorphtargets( _gl );\\r\\n\\t\\t\\tprogramCache = new WebGLPrograms( _this, extensions, capabilities );\\r\\n\\t\\t\\tlights = new WebGLLights();\\r\\n\\t\\t\\trenderLists = new WebGLRenderLists();\\r\\n\\r\\n\\t\\t\\tbackground = new WebGLBackground( _this, state, geometries, _premultipliedAlpha );\\r\\n\\r\\n\\t\\t\\tbufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );\\r\\n\\t\\t\\tindexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\\r\\n\\r\\n\\t\\t\\tflareRenderer = new WebGLFlareRenderer( _this, _gl, state, textures, capabilities );\\r\\n\\t\\t\\tspriteRenderer = new WebGLSpriteRenderer( _this, _gl, state, textures, capabilities );\\r\\n\\r\\n\\t\\t\\t_this.info.programs = programCache.programs;\\r\\n\\r\\n\\t\\t\\t_this.context = _gl;\\r\\n\\t\\t\\t_this.capabilities = capabilities;\\r\\n\\t\\t\\t_this.extensions = extensions;\\r\\n\\t\\t\\t_this.properties = properties;\\r\\n\\t\\t\\t_this.renderLists = renderLists;\\r\\n\\t\\t\\t_this.state = state;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tinitGLContext();\\r\\n\\r\\n\\t\\t// vr\\r\\n\\r\\n\\t\\tvar vr = new WebVRManager( _this );\\r\\n\\r\\n\\t\\tthis.vr = vr;\\r\\n\\r\\n\\t\\t// shadow map\\r\\n\\r\\n\\t\\tvar shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );\\r\\n\\r\\n\\t\\tthis.shadowMap = shadowMap;\\r\\n\\r\\n\\t\\t// API\\r\\n\\r\\n\\t\\tthis.getContext = function () {\\r\\n\\r\\n\\t\\t\\treturn _gl;\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.getContextAttributes = function () {\\r\\n\\r\\n\\t\\t\\treturn _gl.getContextAttributes();\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.forceContextLoss = function () {\\r\\n\\r\\n\\t\\t\\tvar extension = extensions.get( 'WEBGL_lose_context' );\\r\\n\\t\\t\\tif ( extension ) extension.loseContext();\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.forceContextRestore = function () {\\r\\n\\r\\n\\t\\t\\tvar extension = extensions.get( 'WEBGL_lose_context' );\\r\\n\\t\\t\\tif ( extension ) extension.restoreContext();\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.getPixelRatio = function () {\\r\\n\\r\\n\\t\\t\\treturn _pixelRatio;\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.setPixelRatio = function ( value ) {\\r\\n\\r\\n\\t\\t\\tif ( value === undefined ) return;\\r\\n\\r\\n\\t\\t\\t_pixelRatio = value;\\r\\n\\r\\n\\t\\t\\tthis.setSize( _width, _height, false );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.getSize = function () {\\r\\n\\r\\n\\t\\t\\treturn {\\r\\n\\t\\t\\t\\twidth: _width,\\r\\n\\t\\t\\t\\theight: _height\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.setSize = function ( width, height, updateStyle ) {\\r\\n\\r\\n\\t\\t\\tvar device = vr.getDevice();\\r\\n\\r\\n\\t\\t\\tif ( device && device.isPresenting ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Can\\\\'t change size while VR device is presenting.' );\\r\\n\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t_width = width;\\r\\n\\t\\t\\t_height = height;\\r\\n\\r\\n\\t\\t\\t_canvas.width = width * _pixelRatio;\\r\\n\\t\\t\\t_canvas.height = height * _pixelRatio;\\r\\n\\r\\n\\t\\t\\tif ( updateStyle !== false ) {\\r\\n\\r\\n\\t\\t\\t\\t_canvas.style.width = width + 'px';\\r\\n\\t\\t\\t\\t_canvas.style.height = height + 'px';\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.setViewport( 0, 0, width, height );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.getDrawingBufferSize = function () {\\r\\n\\r\\n\\t\\t\\treturn {\\r\\n\\t\\t\\t\\twidth: _width * _pixelRatio,\\r\\n\\t\\t\\t\\theight: _height * _pixelRatio\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.setDrawingBufferSize = function ( width, height, pixelRatio ) {\\r\\n\\r\\n\\t\\t\\t_width = width;\\r\\n\\t\\t\\t_height = height;\\r\\n\\r\\n\\t\\t\\t_pixelRatio = pixelRatio;\\r\\n\\r\\n\\t\\t\\t_canvas.width = width * pixelRatio;\\r\\n\\t\\t\\t_canvas.height = height * pixelRatio;\\r\\n\\r\\n\\t\\t\\tthis.setViewport( 0, 0, width, height );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.setViewport = function ( x, y, width, height ) {\\r\\n\\r\\n\\t\\t\\t_viewport.set( x, _height - y - height, width, height );\\r\\n\\t\\t\\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.setScissor = function ( x, y, width, height ) {\\r\\n\\r\\n\\t\\t\\t_scissor.set( x, _height - y - height, width, height );\\r\\n\\t\\t\\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.setScissorTest = function ( boolean ) {\\r\\n\\r\\n\\t\\t\\tstate.setScissorTest( _scissorTest = boolean );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\t// Clearing\\r\\n\\r\\n\\t\\tthis.getClearColor = function () {\\r\\n\\r\\n\\t\\t\\treturn background.getClearColor();\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.setClearColor = function () {\\r\\n\\r\\n\\t\\t\\tbackground.setClearColor.apply( background, arguments );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.getClearAlpha = function () {\\r\\n\\r\\n\\t\\t\\treturn background.getClearAlpha();\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.setClearAlpha = function () {\\r\\n\\r\\n\\t\\t\\tbackground.setClearAlpha.apply( background, arguments );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.clear = function ( color, depth, stencil ) {\\r\\n\\r\\n\\t\\t\\tvar bits = 0;\\r\\n\\r\\n\\t\\t\\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\\r\\n\\t\\t\\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\\r\\n\\t\\t\\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\\r\\n\\r\\n\\t\\t\\t_gl.clear( bits );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.clearColor = function () {\\r\\n\\r\\n\\t\\t\\tthis.clear( true, false, false );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.clearDepth = function () {\\r\\n\\r\\n\\t\\t\\tthis.clear( false, true, false );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.clearStencil = function () {\\r\\n\\r\\n\\t\\t\\tthis.clear( false, false, true );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\\r\\n\\r\\n\\t\\t\\tthis.setRenderTarget( renderTarget );\\r\\n\\t\\t\\tthis.clear( color, depth, stencil );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tthis.dispose = function () {\\r\\n\\r\\n\\t\\t\\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\\r\\n\\t\\t\\t_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );\\r\\n\\r\\n\\t\\t\\trenderLists.dispose();\\r\\n\\r\\n\\t\\t\\tvr.dispose();\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\t// Events\\r\\n\\r\\n\\t\\tfunction onContextLost( event ) {\\r\\n\\r\\n\\t\\t\\tevent.preventDefault();\\r\\n\\r\\n\\t\\t\\tconsole.log( 'THREE.WebGLRenderer: Context Lost.' );\\r\\n\\r\\n\\t\\t\\t_isContextLost = true;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction onContextRestore( /* event */ ) {\\r\\n\\r\\n\\t\\t\\tconsole.log( 'THREE.WebGLRenderer: Context Restored.' );\\r\\n\\r\\n\\t\\t\\t_isContextLost = false;\\r\\n\\r\\n\\t\\t\\tinitGLContext();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction onMaterialDispose( event ) {\\r\\n\\r\\n\\t\\t\\tvar material = event.target;\\r\\n\\r\\n\\t\\t\\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\\r\\n\\r\\n\\t\\t\\tdeallocateMaterial( material );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Buffer deallocation\\r\\n\\r\\n\\t\\tfunction deallocateMaterial( material ) {\\r\\n\\r\\n\\t\\t\\treleaseMaterialProgramReference( material );\\r\\n\\r\\n\\t\\t\\tproperties.remove( material );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\tfunction releaseMaterialProgramReference( material ) {\\r\\n\\r\\n\\t\\t\\tvar programInfo = properties.get( material ).program;\\r\\n\\r\\n\\t\\t\\tmaterial.program = undefined;\\r\\n\\r\\n\\t\\t\\tif ( programInfo !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tprogramCache.releaseProgram( programInfo );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Buffer rendering\\r\\n\\r\\n\\t\\tfunction renderObjectImmediate( object, program, material ) {\\r\\n\\r\\n\\t\\t\\tobject.render( function ( object ) {\\r\\n\\r\\n\\t\\t\\t\\t_this.renderBufferImmediate( object, program, material );\\r\\n\\r\\n\\t\\t\\t} );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.renderBufferImmediate = function ( object, program, material ) {\\r\\n\\r\\n\\t\\t\\tstate.initAttributes();\\r\\n\\r\\n\\t\\t\\tvar buffers = properties.get( object );\\r\\n\\r\\n\\t\\t\\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\\r\\n\\t\\t\\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\\r\\n\\t\\t\\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\\r\\n\\t\\t\\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\\r\\n\\r\\n\\t\\t\\tvar programAttributes = program.getAttributes();\\r\\n\\r\\n\\t\\t\\tif ( object.hasPositions ) {\\r\\n\\r\\n\\t\\t\\t\\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\\r\\n\\t\\t\\t\\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\\r\\n\\r\\n\\t\\t\\t\\tstate.enableAttribute( programAttributes.position );\\r\\n\\t\\t\\t\\t_gl.vertexAttribPointer( programAttributes.position, 3, _gl.FLOAT, false, 0, 0 );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( object.hasNormals ) {\\r\\n\\r\\n\\t\\t\\t\\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\\r\\n\\r\\n\\t\\t\\t\\tif ( ! material.isMeshPhongMaterial &&\\r\\n\\t\\t\\t\\t\\t! material.isMeshStandardMaterial &&\\r\\n\\t\\t\\t\\t\\t! material.isMeshNormalMaterial &&\\r\\n\\t\\t\\t\\t\\tmaterial.flatShading === true ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar array = object.normalArray;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\\r\\n\\t\\t\\t\\t\\t\\tvar ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\\r\\n\\t\\t\\t\\t\\t\\tvar nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tarray[ i + 0 ] = nx;\\r\\n\\t\\t\\t\\t\\t\\tarray[ i + 1 ] = ny;\\r\\n\\t\\t\\t\\t\\t\\tarray[ i + 2 ] = nz;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tarray[ i + 3 ] = nx;\\r\\n\\t\\t\\t\\t\\t\\tarray[ i + 4 ] = ny;\\r\\n\\t\\t\\t\\t\\t\\tarray[ i + 5 ] = nz;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tarray[ i + 6 ] = nx;\\r\\n\\t\\t\\t\\t\\t\\tarray[ i + 7 ] = ny;\\r\\n\\t\\t\\t\\t\\t\\tarray[ i + 8 ] = nz;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\\r\\n\\r\\n\\t\\t\\t\\tstate.enableAttribute( programAttributes.normal );\\r\\n\\r\\n\\t\\t\\t\\t_gl.vertexAttribPointer( programAttributes.normal, 3, _gl.FLOAT, false, 0, 0 );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( object.hasUvs && material.map ) {\\r\\n\\r\\n\\t\\t\\t\\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\\r\\n\\t\\t\\t\\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\\r\\n\\r\\n\\t\\t\\t\\tstate.enableAttribute( programAttributes.uv );\\r\\n\\r\\n\\t\\t\\t\\t_gl.vertexAttribPointer( programAttributes.uv, 2, _gl.FLOAT, false, 0, 0 );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( object.hasColors && material.vertexColors !== NoColors ) {\\r\\n\\r\\n\\t\\t\\t\\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\\r\\n\\t\\t\\t\\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\\r\\n\\r\\n\\t\\t\\t\\tstate.enableAttribute( programAttributes.color );\\r\\n\\r\\n\\t\\t\\t\\t_gl.vertexAttribPointer( programAttributes.color, 3, _gl.FLOAT, false, 0, 0 );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tstate.disableUnusedAttributes();\\r\\n\\r\\n\\t\\t\\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\\r\\n\\r\\n\\t\\t\\tobject.count = 0;\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\\r\\n\\r\\n\\t\\t\\tvar frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );\\r\\n\\r\\n\\t\\t\\tstate.setMaterial( material, frontFaceCW );\\r\\n\\r\\n\\t\\t\\tvar program = setProgram( camera, fog, material, object );\\r\\n\\t\\t\\tvar geometryProgram = geometry.id + '_' + program.id + '_' + ( material.wireframe === true );\\r\\n\\r\\n\\t\\t\\tvar updateBuffers = false;\\r\\n\\r\\n\\t\\t\\tif ( geometryProgram !== _currentGeometryProgram ) {\\r\\n\\r\\n\\t\\t\\t\\t_currentGeometryProgram = geometryProgram;\\r\\n\\t\\t\\t\\tupdateBuffers = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( object.morphTargetInfluences ) {\\r\\n\\r\\n\\t\\t\\t\\tmorphtargets.update( object, geometry, material, program );\\r\\n\\r\\n\\t\\t\\t\\tupdateBuffers = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\tvar index = geometry.index;\\r\\n\\t\\t\\tvar position = geometry.attributes.position;\\r\\n\\t\\t\\tvar rangeFactor = 1;\\r\\n\\r\\n\\t\\t\\tif ( material.wireframe === true ) {\\r\\n\\r\\n\\t\\t\\t\\tindex = geometries.getWireframeAttribute( geometry );\\r\\n\\t\\t\\t\\trangeFactor = 2;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar attribute;\\r\\n\\t\\t\\tvar renderer = bufferRenderer;\\r\\n\\r\\n\\t\\t\\tif ( index !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tattribute = attributes.get( index );\\r\\n\\r\\n\\t\\t\\t\\trenderer = indexedBufferRenderer;\\r\\n\\t\\t\\t\\trenderer.setIndex( attribute );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( updateBuffers ) {\\r\\n\\r\\n\\t\\t\\t\\tsetupVertexAttributes( material, program, geometry );\\r\\n\\r\\n\\t\\t\\t\\tif ( index !== null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attribute.buffer );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\tvar dataCount = 0;\\r\\n\\r\\n\\t\\t\\tif ( index !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tdataCount = index.count;\\r\\n\\r\\n\\t\\t\\t} else if ( position !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tdataCount = position.count;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar rangeStart = geometry.drawRange.start * rangeFactor;\\r\\n\\t\\t\\tvar rangeCount = geometry.drawRange.count * rangeFactor;\\r\\n\\r\\n\\t\\t\\tvar groupStart = group !== null ? group.start * rangeFactor : 0;\\r\\n\\t\\t\\tvar groupCount = group !== null ? group.count * rangeFactor : Infinity;\\r\\n\\r\\n\\t\\t\\tvar drawStart = Math.max( rangeStart, groupStart );\\r\\n\\t\\t\\tvar drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\\r\\n\\r\\n\\t\\t\\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\\r\\n\\r\\n\\t\\t\\tif ( drawCount === 0 ) return;\\r\\n\\r\\n\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\tif ( object.isMesh ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( material.wireframe === true ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\\r\\n\\t\\t\\t\\t\\trenderer.setMode( _gl.LINES );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tswitch ( object.drawMode ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase TrianglesDrawMode:\\r\\n\\t\\t\\t\\t\\t\\t\\trenderer.setMode( _gl.TRIANGLES );\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase TriangleStripDrawMode:\\r\\n\\t\\t\\t\\t\\t\\t\\trenderer.setMode( _gl.TRIANGLE_STRIP );\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase TriangleFanDrawMode:\\r\\n\\t\\t\\t\\t\\t\\t\\trenderer.setMode( _gl.TRIANGLE_FAN );\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\t\\t} else if ( object.isLine ) {\\r\\n\\r\\n\\t\\t\\t\\tvar lineWidth = material.linewidth;\\r\\n\\r\\n\\t\\t\\t\\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\\r\\n\\r\\n\\t\\t\\t\\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\\r\\n\\r\\n\\t\\t\\t\\tif ( object.isLineSegments ) {\\r\\n\\r\\n\\t\\t\\t\\t\\trenderer.setMode( _gl.LINES );\\r\\n\\r\\n\\t\\t\\t\\t} else if ( object.isLineLoop ) {\\r\\n\\r\\n\\t\\t\\t\\t\\trenderer.setMode( _gl.LINE_LOOP );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\trenderer.setMode( _gl.LINE_STRIP );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else if ( object.isPoints ) {\\r\\n\\r\\n\\t\\t\\t\\trenderer.setMode( _gl.POINTS );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( geometry && geometry.isInstancedBufferGeometry ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( geometry.maxInstancedCount > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\trenderer.renderInstances( geometry, drawStart, drawCount );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\trenderer.render( drawStart, drawCount );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\\r\\n\\r\\n\\t\\t\\tif ( geometry && geometry.isInstancedBufferGeometry ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\\r\\n\\t\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( startIndex === undefined ) startIndex = 0;\\r\\n\\r\\n\\t\\t\\tstate.initAttributes();\\r\\n\\r\\n\\t\\t\\tvar geometryAttributes = geometry.attributes;\\r\\n\\r\\n\\t\\t\\tvar programAttributes = program.getAttributes();\\r\\n\\r\\n\\t\\t\\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\\r\\n\\r\\n\\t\\t\\tfor ( var name in programAttributes ) {\\r\\n\\r\\n\\t\\t\\t\\tvar programAttribute = programAttributes[ name ];\\r\\n\\r\\n\\t\\t\\t\\tif ( programAttribute >= 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar geometryAttribute = geometryAttributes[ name ];\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( geometryAttribute !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar normalized = geometryAttribute.normalized;\\r\\n\\t\\t\\t\\t\\t\\tvar size = geometryAttribute.itemSize;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar attribute = attributes.get( geometryAttribute );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// TODO Attribute may not be available on context restore\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( attribute === undefined ) continue;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar buffer = attribute.buffer;\\r\\n\\t\\t\\t\\t\\t\\tvar type = attribute.type;\\r\\n\\t\\t\\t\\t\\t\\tvar bytesPerElement = attribute.bytesPerElement;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( geometryAttribute.isInterleavedBufferAttribute ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar data = geometryAttribute.data;\\r\\n\\t\\t\\t\\t\\t\\t\\tvar stride = data.stride;\\r\\n\\t\\t\\t\\t\\t\\t\\tvar offset = geometryAttribute.offset;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( data && data.isInstancedInterleavedBuffer ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( geometry.maxInstancedCount === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstate.enableAttribute( programAttribute );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\\r\\n\\t\\t\\t\\t\\t\\t\\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, ( startIndex * stride + offset ) * bytesPerElement );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( geometryAttribute.isInstancedBufferAttribute ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( geometry.maxInstancedCount === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstate.enableAttribute( programAttribute );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\\r\\n\\t\\t\\t\\t\\t\\t\\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * bytesPerElement );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t} else if ( materialDefaultAttributeValues !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar value = materialDefaultAttributeValues[ name ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( value !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tswitch ( value.length ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tcase 2:\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t_gl.vertexAttrib2fv( programAttribute, value );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tcase 3:\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t_gl.vertexAttrib3fv( programAttribute, value );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tcase 4:\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t_gl.vertexAttrib4fv( programAttribute, value );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdefault:\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t_gl.vertexAttrib1fv( programAttribute, value );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tstate.disableUnusedAttributes();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Compile\\r\\n\\r\\n\\t\\tthis.compile = function ( scene, camera ) {\\r\\n\\r\\n\\t\\t\\tlightsArray.length = 0;\\r\\n\\t\\t\\tshadowsArray.length = 0;\\r\\n\\r\\n\\t\\t\\tscene.traverse( function ( object ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( object.isLight ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tlightsArray.push( object );\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( object.castShadow ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tshadowsArray.push( object );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\tlights.setup( lightsArray, shadowsArray, camera );\\r\\n\\r\\n\\t\\t\\tscene.traverse( function ( object ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( object.material ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( Array.isArray( object.material ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0; i < object.material.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tinitMaterial( object.material[ i ], scene.fog, object );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tinitMaterial( object.material, scene.fog, object );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\t// Animation Loop\\r\\n\\r\\n\\t\\tvar isAnimating = false;\\r\\n\\t\\tvar onAnimationFrame = null;\\r\\n\\r\\n\\t\\tfunction start() {\\r\\n\\r\\n\\t\\t\\tif ( isAnimating ) return;\\r\\n\\r\\n\\t\\t\\tvar device = vr.getDevice();\\r\\n\\r\\n\\t\\t\\tif ( device && device.isPresenting ) {\\r\\n\\r\\n\\t\\t\\t\\tdevice.requestAnimationFrame( loop );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\twindow.requestAnimationFrame( loop );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tisAnimating = true;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction loop( time ) {\\r\\n\\r\\n\\t\\t\\tif ( onAnimationFrame !== null ) onAnimationFrame( time );\\r\\n\\r\\n\\t\\t\\tvar device = vr.getDevice();\\r\\n\\r\\n\\t\\t\\tif ( device && device.isPresenting ) {\\r\\n\\r\\n\\t\\t\\t\\tdevice.requestAnimationFrame( loop );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\twindow.requestAnimationFrame( loop );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.animate = function ( callback ) {\\r\\n\\r\\n\\t\\t\\tonAnimationFrame = callback;\\r\\n\\t\\t\\tstart();\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\t// Rendering\\r\\n\\r\\n\\t\\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\\r\\n\\r\\n\\t\\t\\tif ( ! ( camera && camera.isCamera ) ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\\r\\n\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( _isContextLost ) return;\\r\\n\\r\\n\\t\\t\\t// reset caching for this frame\\r\\n\\r\\n\\t\\t\\t_currentGeometryProgram = '';\\r\\n\\t\\t\\t_currentMaterialId = - 1;\\r\\n\\t\\t\\t_currentCamera = null;\\r\\n\\r\\n\\t\\t\\t// update scene graph\\r\\n\\r\\n\\t\\t\\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\\r\\n\\r\\n\\t\\t\\t// update camera matrices and frustum\\r\\n\\r\\n\\t\\t\\tif ( camera.parent === null ) camera.updateMatrixWorld();\\r\\n\\r\\n\\t\\t\\tif ( vr.enabled ) {\\r\\n\\r\\n\\t\\t\\t\\tcamera = vr.getCamera( camera );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\\r\\n\\t\\t\\t_frustum.setFromMatrix( _projScreenMatrix );\\r\\n\\r\\n\\t\\t\\tlightsArray.length = 0;\\r\\n\\t\\t\\tshadowsArray.length = 0;\\r\\n\\r\\n\\t\\t\\tspritesArray.length = 0;\\r\\n\\t\\t\\tflaresArray.length = 0;\\r\\n\\r\\n\\t\\t\\t_localClippingEnabled = this.localClippingEnabled;\\r\\n\\t\\t\\t_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\\r\\n\\r\\n\\t\\t\\tcurrentRenderList = renderLists.get( scene, camera );\\r\\n\\t\\t\\tcurrentRenderList.init();\\r\\n\\r\\n\\t\\t\\tprojectObject( scene, camera, _this.sortObjects );\\r\\n\\r\\n\\t\\t\\tif ( _this.sortObjects === true ) {\\r\\n\\r\\n\\t\\t\\t\\tcurrentRenderList.sort();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\ttextures.updateVideoTextures();\\r\\n\\r\\n\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\tif ( _clippingEnabled ) _clipping.beginShadows();\\r\\n\\r\\n\\t\\t\\tshadowMap.render( shadowsArray, scene, camera );\\r\\n\\r\\n\\t\\t\\tlights.setup( lightsArray, shadowsArray, camera );\\r\\n\\r\\n\\t\\t\\tif ( _clippingEnabled ) _clipping.endShadows();\\r\\n\\r\\n\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\t_infoRender.frame ++;\\r\\n\\t\\t\\t_infoRender.calls = 0;\\r\\n\\t\\t\\t_infoRender.vertices = 0;\\r\\n\\t\\t\\t_infoRender.faces = 0;\\r\\n\\t\\t\\t_infoRender.points = 0;\\r\\n\\r\\n\\t\\t\\tif ( renderTarget === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\trenderTarget = null;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.setRenderTarget( renderTarget );\\r\\n\\r\\n\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\tbackground.render( currentRenderList, scene, camera, forceClear );\\r\\n\\r\\n\\t\\t\\t// render scene\\r\\n\\r\\n\\t\\t\\tvar opaqueObjects = currentRenderList.opaque;\\r\\n\\t\\t\\tvar transparentObjects = currentRenderList.transparent;\\r\\n\\r\\n\\t\\t\\tif ( scene.overrideMaterial ) {\\r\\n\\r\\n\\t\\t\\t\\tvar overrideMaterial = scene.overrideMaterial;\\r\\n\\r\\n\\t\\t\\t\\tif ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera, overrideMaterial );\\r\\n\\t\\t\\t\\tif ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera, overrideMaterial );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t// opaque pass (front-to-back order)\\r\\n\\r\\n\\t\\t\\t\\tif ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera );\\r\\n\\r\\n\\t\\t\\t\\t// transparent pass (back-to-front order)\\r\\n\\r\\n\\t\\t\\t\\tif ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// custom renderers\\r\\n\\r\\n\\t\\t\\tspriteRenderer.render( spritesArray, scene, camera );\\r\\n\\t\\t\\tflareRenderer.render( flaresArray, scene, camera, _currentViewport );\\r\\n\\r\\n\\t\\t\\t// Generate mipmap if we're using any kind of mipmap filtering\\r\\n\\r\\n\\t\\t\\tif ( renderTarget ) {\\r\\n\\r\\n\\t\\t\\t\\ttextures.updateRenderTargetMipmap( renderTarget );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// Ensure depth buffer writing is enabled so it can be cleared on next render\\r\\n\\r\\n\\t\\t\\tstate.buffers.depth.setTest( true );\\r\\n\\t\\t\\tstate.buffers.depth.setMask( true );\\r\\n\\t\\t\\tstate.buffers.color.setMask( true );\\r\\n\\r\\n\\t\\t\\tstate.setPolygonOffset( false );\\r\\n\\r\\n\\t\\t\\tif ( vr.enabled ) {\\r\\n\\r\\n\\t\\t\\t\\tvr.submitFrame();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// _gl.finish();\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\t/*\\r\\n\\t\\t// TODO Duplicated code (Frustum)\\r\\n\\r\\n\\t\\tvar _sphere = new Sphere();\\r\\n\\r\\n\\t\\tfunction isObjectViewable( object ) {\\r\\n\\r\\n\\t\\t\\tvar geometry = object.geometry;\\r\\n\\r\\n\\t\\t\\tif ( geometry.boundingSphere === null )\\r\\n\\t\\t\\t\\tgeometry.computeBoundingSphere();\\r\\n\\r\\n\\t\\t\\t_sphere.copy( geometry.boundingSphere ).\\r\\n\\t\\t\\tapplyMatrix4( object.matrixWorld );\\r\\n\\r\\n\\t\\t\\treturn isSphereViewable( _sphere );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction isSpriteViewable( sprite ) {\\r\\n\\r\\n\\t\\t\\t_sphere.center.set( 0, 0, 0 );\\r\\n\\t\\t\\t_sphere.radius = 0.7071067811865476;\\r\\n\\t\\t\\t_sphere.applyMatrix4( sprite.matrixWorld );\\r\\n\\r\\n\\t\\t\\treturn isSphereViewable( _sphere );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction isSphereViewable( sphere ) {\\r\\n\\r\\n\\t\\t\\tif ( ! _frustum.intersectsSphere( sphere ) ) return false;\\r\\n\\r\\n\\t\\t\\tvar numPlanes = _clipping.numPlanes;\\r\\n\\r\\n\\t\\t\\tif ( numPlanes === 0 ) return true;\\r\\n\\r\\n\\t\\t\\tvar planes = _this.clippingPlanes,\\r\\n\\r\\n\\t\\t\\t\\tcenter = sphere.center,\\r\\n\\t\\t\\t\\tnegRad = - sphere.radius,\\r\\n\\t\\t\\t\\ti = 0;\\r\\n\\r\\n\\t\\t\\tdo {\\r\\n\\r\\n\\t\\t\\t\\t// out when deeper than radius in the negative halfspace\\r\\n\\t\\t\\t\\tif ( planes[ i ].distanceToPoint( center ) < negRad ) return false;\\r\\n\\r\\n\\t\\t\\t} while ( ++ i !== numPlanes );\\r\\n\\r\\n\\t\\t\\treturn true;\\r\\n\\r\\n\\t\\t}\\r\\n\\t\\t*/\\r\\n\\r\\n\\t\\tfunction projectObject( object, camera, sortObjects ) {\\r\\n\\r\\n\\t\\t\\tif ( object.visible === false ) return;\\r\\n\\r\\n\\t\\t\\tvar visible = object.layers.test( camera.layers );\\r\\n\\r\\n\\t\\t\\tif ( visible ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( object.isLight ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tlightsArray.push( object );\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( object.castShadow ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tshadowsArray.push( object );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else if ( object.isSprite ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tspritesArray.push( object );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else if ( object.isLensFlare ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tflaresArray.push( object );\\r\\n\\r\\n\\t\\t\\t\\t} else if ( object.isImmediateRenderObject ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( sortObjects ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t_vector3.setFromMatrixPosition( object.matrixWorld )\\r\\n\\t\\t\\t\\t\\t\\t\\t.applyMatrix4( _projScreenMatrix );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tcurrentRenderList.push( object, null, object.material, _vector3.z, null );\\r\\n\\r\\n\\t\\t\\t\\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( object.isSkinnedMesh ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tobject.skeleton.update();\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( sortObjects ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t_vector3.setFromMatrixPosition( object.matrixWorld )\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t.applyMatrix4( _projScreenMatrix );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar geometry = objects.update( object );\\r\\n\\t\\t\\t\\t\\t\\tvar material = object.material;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( Array.isArray( material ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar groups = geometry.groups;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tvar group = groups[ i ];\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tvar groupMaterial = material[ group.materialIndex ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( groupMaterial && groupMaterial.visible ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcurrentRenderList.push( object, geometry, groupMaterial, _vector3.z, group );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t} else if ( material.visible ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tcurrentRenderList.push( object, geometry, material, _vector3.z, null );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar children = object.children;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tprojectObject( children[ i ], camera, sortObjects );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction renderObjects( renderList, scene, camera, overrideMaterial ) {\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar renderItem = renderList[ i ];\\r\\n\\r\\n\\t\\t\\t\\tvar object = renderItem.object;\\r\\n\\t\\t\\t\\tvar geometry = renderItem.geometry;\\r\\n\\t\\t\\t\\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\\r\\n\\t\\t\\t\\tvar group = renderItem.group;\\r\\n\\r\\n\\t\\t\\t\\tif ( camera.isArrayCamera ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t_currentArrayCamera = camera;\\r\\n\\r\\n\\t\\t\\t\\t\\tvar cameras = camera.cameras;\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var j = 0, jl = cameras.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar camera2 = cameras[ j ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( object.layers.test( camera2.layers ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar bounds = camera2.bounds;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar x = bounds.x * _width;\\r\\n\\t\\t\\t\\t\\t\\t\\tvar y = bounds.y * _height;\\r\\n\\t\\t\\t\\t\\t\\t\\tvar width = bounds.z * _width;\\r\\n\\t\\t\\t\\t\\t\\t\\tvar height = bounds.w * _height;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tstate.viewport( _currentViewport.set( x, y, width, height ).multiplyScalar( _pixelRatio ) );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\trenderObject( object, scene, camera2, geometry, material, group );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t_currentArrayCamera = null;\\r\\n\\r\\n\\t\\t\\t\\t\\trenderObject( object, scene, camera, geometry, material, group );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction renderObject( object, scene, camera, geometry, material, group ) {\\r\\n\\r\\n\\t\\t\\tobject.onBeforeRender( _this, scene, camera, geometry, material, group );\\r\\n\\r\\n\\t\\t\\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\\r\\n\\t\\t\\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\\r\\n\\r\\n\\t\\t\\tif ( object.isImmediateRenderObject ) {\\r\\n\\r\\n\\t\\t\\t\\tvar frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );\\r\\n\\r\\n\\t\\t\\t\\tstate.setMaterial( material, frontFaceCW );\\r\\n\\r\\n\\t\\t\\t\\tvar program = setProgram( camera, scene.fog, material, object );\\r\\n\\r\\n\\t\\t\\t\\t_currentGeometryProgram = '';\\r\\n\\r\\n\\t\\t\\t\\trenderObjectImmediate( object, program, material );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tobject.onAfterRender( _this, scene, camera, geometry, material, group );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction initMaterial( material, fog, object ) {\\r\\n\\r\\n\\t\\t\\tvar materialProperties = properties.get( material );\\r\\n\\r\\n\\t\\t\\tvar parameters = programCache.getParameters(\\r\\n\\t\\t\\t\\tmaterial, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object );\\r\\n\\r\\n\\t\\t\\tvar code = programCache.getProgramCode( material, parameters );\\r\\n\\r\\n\\t\\t\\tvar program = materialProperties.program;\\r\\n\\t\\t\\tvar programChange = true;\\r\\n\\r\\n\\t\\t\\tif ( program === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t// new material\\r\\n\\t\\t\\t\\tmaterial.addEventListener( 'dispose', onMaterialDispose );\\r\\n\\r\\n\\t\\t\\t} else if ( program.code !== code ) {\\r\\n\\r\\n\\t\\t\\t\\t// changed glsl or parameters\\r\\n\\t\\t\\t\\treleaseMaterialProgramReference( material );\\r\\n\\r\\n\\t\\t\\t} else if ( parameters.shaderID !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t// same glsl and uniform list\\r\\n\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t// only rebuild uniform list\\r\\n\\t\\t\\t\\tprogramChange = false;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( programChange ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( parameters.shaderID ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar shader = ShaderLib[ parameters.shaderID ];\\r\\n\\r\\n\\t\\t\\t\\t\\tmaterialProperties.shader = {\\r\\n\\t\\t\\t\\t\\t\\tname: material.type,\\r\\n\\t\\t\\t\\t\\t\\tuniforms: UniformsUtils.clone( shader.uniforms ),\\r\\n\\t\\t\\t\\t\\t\\tvertexShader: shader.vertexShader,\\r\\n\\t\\t\\t\\t\\t\\tfragmentShader: shader.fragmentShader\\r\\n\\t\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tmaterialProperties.shader = {\\r\\n\\t\\t\\t\\t\\t\\tname: material.type,\\r\\n\\t\\t\\t\\t\\t\\tuniforms: material.uniforms,\\r\\n\\t\\t\\t\\t\\t\\tvertexShader: material.vertexShader,\\r\\n\\t\\t\\t\\t\\t\\tfragmentShader: material.fragmentShader\\r\\n\\t\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tmaterial.onBeforeCompile( materialProperties.shader );\\r\\n\\r\\n\\t\\t\\t\\tprogram = programCache.acquireProgram( material, materialProperties.shader, parameters, code );\\r\\n\\r\\n\\t\\t\\t\\tmaterialProperties.program = program;\\r\\n\\t\\t\\t\\tmaterial.program = program;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar programAttributes = program.getAttributes();\\r\\n\\r\\n\\t\\t\\tif ( material.morphTargets ) {\\r\\n\\r\\n\\t\\t\\t\\tmaterial.numSupportedMorphTargets = 0;\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( programAttributes[ 'morphTarget' + i ] >= 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tmaterial.numSupportedMorphTargets ++;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( material.morphNormals ) {\\r\\n\\r\\n\\t\\t\\t\\tmaterial.numSupportedMorphNormals = 0;\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( programAttributes[ 'morphNormal' + i ] >= 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tmaterial.numSupportedMorphNormals ++;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar uniforms = materialProperties.shader.uniforms;\\r\\n\\r\\n\\t\\t\\tif ( ! material.isShaderMaterial &&\\r\\n\\t\\t\\t\\t! material.isRawShaderMaterial ||\\r\\n\\t\\t\\t\\tmaterial.clipping === true ) {\\r\\n\\r\\n\\t\\t\\t\\tmaterialProperties.numClippingPlanes = _clipping.numPlanes;\\r\\n\\t\\t\\t\\tmaterialProperties.numIntersection = _clipping.numIntersection;\\r\\n\\t\\t\\t\\tuniforms.clippingPlanes = _clipping.uniform;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tmaterialProperties.fog = fog;\\r\\n\\r\\n\\t\\t\\t// store the light setup it was created for\\r\\n\\r\\n\\t\\t\\tmaterialProperties.lightsHash = lights.state.hash;\\r\\n\\r\\n\\t\\t\\tif ( material.lights ) {\\r\\n\\r\\n\\t\\t\\t\\t// wire up the material to this renderer's lighting state\\r\\n\\r\\n\\t\\t\\t\\tuniforms.ambientLightColor.value = lights.state.ambient;\\r\\n\\t\\t\\t\\tuniforms.directionalLights.value = lights.state.directional;\\r\\n\\t\\t\\t\\tuniforms.spotLights.value = lights.state.spot;\\r\\n\\t\\t\\t\\tuniforms.rectAreaLights.value = lights.state.rectArea;\\r\\n\\t\\t\\t\\tuniforms.pointLights.value = lights.state.point;\\r\\n\\t\\t\\t\\tuniforms.hemisphereLights.value = lights.state.hemi;\\r\\n\\r\\n\\t\\t\\t\\tuniforms.directionalShadowMap.value = lights.state.directionalShadowMap;\\r\\n\\t\\t\\t\\tuniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;\\r\\n\\t\\t\\t\\tuniforms.spotShadowMap.value = lights.state.spotShadowMap;\\r\\n\\t\\t\\t\\tuniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;\\r\\n\\t\\t\\t\\tuniforms.pointShadowMap.value = lights.state.pointShadowMap;\\r\\n\\t\\t\\t\\tuniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;\\r\\n\\t\\t\\t\\t// TODO (abelnation): add area lights shadow info to uniforms\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar progUniforms = materialProperties.program.getUniforms(),\\r\\n\\t\\t\\t\\tuniformsList =\\r\\n\\t\\t\\t\\t\\tWebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\\r\\n\\r\\n\\t\\t\\tmaterialProperties.uniformsList = uniformsList;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction setProgram( camera, fog, material, object ) {\\r\\n\\r\\n\\t\\t\\t_usedTextureUnits = 0;\\r\\n\\r\\n\\t\\t\\tvar materialProperties = properties.get( material );\\r\\n\\r\\n\\t\\t\\tif ( _clippingEnabled ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( _localClippingEnabled || camera !== _currentCamera ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar useCache =\\r\\n\\t\\t\\t\\t\\t\\tcamera === _currentCamera &&\\r\\n\\t\\t\\t\\t\\t\\tmaterial.id === _currentMaterialId;\\r\\n\\r\\n\\t\\t\\t\\t\\t// we might want to call this function with some ClippingGroup\\r\\n\\t\\t\\t\\t\\t// object instead of the material, once it becomes feasible\\r\\n\\t\\t\\t\\t\\t// (#8465, #8379)\\r\\n\\t\\t\\t\\t\\t_clipping.setState(\\r\\n\\t\\t\\t\\t\\t\\tmaterial.clippingPlanes, material.clipIntersection, material.clipShadows,\\r\\n\\t\\t\\t\\t\\t\\tcamera, materialProperties, useCache );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( material.needsUpdate === false ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( materialProperties.program === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tmaterial.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t\\t} else if ( material.fog && materialProperties.fog !== fog ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tmaterial.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t\\t} else if ( material.lights && materialProperties.lightsHash !== lights.state.hash ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tmaterial.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t\\t} else if ( materialProperties.numClippingPlanes !== undefined &&\\r\\n\\t\\t\\t\\t\\t( materialProperties.numClippingPlanes !== _clipping.numPlanes ||\\r\\n\\t\\t\\t\\t\\tmaterialProperties.numIntersection !== _clipping.numIntersection ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tmaterial.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( material.needsUpdate ) {\\r\\n\\r\\n\\t\\t\\t\\tinitMaterial( material, fog, object );\\r\\n\\t\\t\\t\\tmaterial.needsUpdate = false;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar refreshProgram = false;\\r\\n\\t\\t\\tvar refreshMaterial = false;\\r\\n\\t\\t\\tvar refreshLights = false;\\r\\n\\r\\n\\t\\t\\tvar program = materialProperties.program,\\r\\n\\t\\t\\t\\tp_uniforms = program.getUniforms(),\\r\\n\\t\\t\\t\\tm_uniforms = materialProperties.shader.uniforms;\\r\\n\\r\\n\\t\\t\\tif ( state.useProgram( program.program ) ) {\\r\\n\\r\\n\\t\\t\\t\\trefreshProgram = true;\\r\\n\\t\\t\\t\\trefreshMaterial = true;\\r\\n\\t\\t\\t\\trefreshLights = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( material.id !== _currentMaterialId ) {\\r\\n\\r\\n\\t\\t\\t\\t_currentMaterialId = material.id;\\r\\n\\r\\n\\t\\t\\t\\trefreshMaterial = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( refreshProgram || camera !== _currentCamera ) {\\r\\n\\r\\n\\t\\t\\t\\tp_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );\\r\\n\\r\\n\\t\\t\\t\\tif ( capabilities.logarithmicDepthBuffer ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tp_uniforms.setValue( _gl, 'logDepthBufFC',\\r\\n\\t\\t\\t\\t\\t\\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// Avoid unneeded uniform updates per ArrayCamera's sub-camera\\r\\n\\r\\n\\t\\t\\t\\tif ( _currentCamera !== ( _currentArrayCamera || camera ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t_currentCamera = ( _currentArrayCamera || camera );\\r\\n\\r\\n\\t\\t\\t\\t\\t// lighting uniforms depend on the camera so enforce an update\\r\\n\\t\\t\\t\\t\\t// now, in case this material supports lights - or later, when\\r\\n\\t\\t\\t\\t\\t// the next material that does gets activated:\\r\\n\\r\\n\\t\\t\\t\\t\\trefreshMaterial = true;\\t\\t// set to true on material change\\r\\n\\t\\t\\t\\t\\trefreshLights = true;\\t\\t// remains set until update done\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// load material specific uniforms\\r\\n\\t\\t\\t\\t// (shader material also gets them for the sake of genericity)\\r\\n\\r\\n\\t\\t\\t\\tif ( material.isShaderMaterial ||\\r\\n\\t\\t\\t\\t\\tmaterial.isMeshPhongMaterial ||\\r\\n\\t\\t\\t\\t\\tmaterial.isMeshStandardMaterial ||\\r\\n\\t\\t\\t\\t\\tmaterial.envMap ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar uCamPos = p_uniforms.map.cameraPosition;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( uCamPos !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tuCamPos.setValue( _gl,\\r\\n\\t\\t\\t\\t\\t\\t\\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( material.isMeshPhongMaterial ||\\r\\n\\t\\t\\t\\t\\tmaterial.isMeshLambertMaterial ||\\r\\n\\t\\t\\t\\t\\tmaterial.isMeshBasicMaterial ||\\r\\n\\t\\t\\t\\t\\tmaterial.isMeshStandardMaterial ||\\r\\n\\t\\t\\t\\t\\tmaterial.isShaderMaterial ||\\r\\n\\t\\t\\t\\t\\tmaterial.skinning ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// skinning uniforms must be set even if material didn't change\\r\\n\\t\\t\\t// auto-setting of texture unit for bone texture must go before other textures\\r\\n\\t\\t\\t// not sure why, but otherwise weird things happen\\r\\n\\r\\n\\t\\t\\tif ( material.skinning ) {\\r\\n\\r\\n\\t\\t\\t\\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\\r\\n\\t\\t\\t\\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\\r\\n\\r\\n\\t\\t\\t\\tvar skeleton = object.skeleton;\\r\\n\\r\\n\\t\\t\\t\\tif ( skeleton ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar bones = skeleton.bones;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( capabilities.floatVertexTextures ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( skeleton.boneTexture === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t// layout (1 matrix = 4 pixels)\\r\\n\\t\\t\\t\\t\\t\\t\\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\\r\\n\\t\\t\\t\\t\\t\\t\\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\\r\\n\\t\\t\\t\\t\\t\\t\\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\\r\\n\\t\\t\\t\\t\\t\\t\\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\\r\\n\\t\\t\\t\\t\\t\\t\\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\\r\\n\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix\\r\\n\\t\\t\\t\\t\\t\\t\\tsize = _Math.ceilPowerOfTwo( size );\\r\\n\\t\\t\\t\\t\\t\\t\\tsize = Math.max( size, 4 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel\\r\\n\\t\\t\\t\\t\\t\\t\\tboneMatrices.set( skeleton.boneMatrices ); // copy current values\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tskeleton.boneMatrices = boneMatrices;\\r\\n\\t\\t\\t\\t\\t\\t\\tskeleton.boneTexture = boneTexture;\\r\\n\\t\\t\\t\\t\\t\\t\\tskeleton.boneTextureSize = size;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tp_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture );\\r\\n\\t\\t\\t\\t\\t\\tp_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( refreshMaterial ) {\\r\\n\\r\\n\\t\\t\\t\\tp_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );\\r\\n\\t\\t\\t\\tp_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );\\r\\n\\r\\n\\t\\t\\t\\tif ( material.lights ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// the current material requires lighting info\\r\\n\\r\\n\\t\\t\\t\\t\\t// note: all lighting uniforms are always set correctly\\r\\n\\t\\t\\t\\t\\t// they simply reference the renderer's state for their\\r\\n\\t\\t\\t\\t\\t// values\\r\\n\\t\\t\\t\\t\\t//\\r\\n\\t\\t\\t\\t\\t// use the current material's .needsUpdate flags to set\\r\\n\\t\\t\\t\\t\\t// the GL state when required\\r\\n\\r\\n\\t\\t\\t\\t\\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// refresh uniforms common to several materials\\r\\n\\r\\n\\t\\t\\t\\tif ( fog && material.fog ) {\\r\\n\\r\\n\\t\\t\\t\\t\\trefreshUniformsFog( m_uniforms, fog );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( material.isMeshBasicMaterial ) {\\r\\n\\r\\n\\t\\t\\t\\t\\trefreshUniformsCommon( m_uniforms, material );\\r\\n\\r\\n\\t\\t\\t\\t} else if ( material.isMeshLambertMaterial ) {\\r\\n\\r\\n\\t\\t\\t\\t\\trefreshUniformsCommon( m_uniforms, material );\\r\\n\\t\\t\\t\\t\\trefreshUniformsLambert( m_uniforms, material );\\r\\n\\r\\n\\t\\t\\t\\t} else if ( material.isMeshPhongMaterial ) {\\r\\n\\r\\n\\t\\t\\t\\t\\trefreshUniformsCommon( m_uniforms, material );\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( material.isMeshToonMaterial ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\trefreshUniformsToon( m_uniforms, material );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\trefreshUniformsPhong( m_uniforms, material );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else if ( material.isMeshStandardMaterial ) {\\r\\n\\r\\n\\t\\t\\t\\t\\trefreshUniformsCommon( m_uniforms, material );\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( material.isMeshPhysicalMaterial ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\trefreshUniformsPhysical( m_uniforms, material );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\trefreshUniformsStandard( m_uniforms, material );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else if ( material.isMeshDepthMaterial ) {\\r\\n\\r\\n\\t\\t\\t\\t\\trefreshUniformsCommon( m_uniforms, material );\\r\\n\\t\\t\\t\\t\\trefreshUniformsDepth( m_uniforms, material );\\r\\n\\r\\n\\t\\t\\t\\t} else if ( material.isMeshDistanceMaterial ) {\\r\\n\\r\\n\\t\\t\\t\\t\\trefreshUniformsCommon( m_uniforms, material );\\r\\n\\t\\t\\t\\t\\trefreshUniformsDistance( m_uniforms, material );\\r\\n\\r\\n\\t\\t\\t\\t} else if ( material.isMeshNormalMaterial ) {\\r\\n\\r\\n\\t\\t\\t\\t\\trefreshUniformsCommon( m_uniforms, material );\\r\\n\\t\\t\\t\\t\\trefreshUniformsNormal( m_uniforms, material );\\r\\n\\r\\n\\t\\t\\t\\t} else if ( material.isLineBasicMaterial ) {\\r\\n\\r\\n\\t\\t\\t\\t\\trefreshUniformsLine( m_uniforms, material );\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( material.isLineDashedMaterial ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\trefreshUniformsDash( m_uniforms, material );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else if ( material.isPointsMaterial ) {\\r\\n\\r\\n\\t\\t\\t\\t\\trefreshUniformsPoints( m_uniforms, material );\\r\\n\\r\\n\\t\\t\\t\\t} else if ( material.isShadowMaterial ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tm_uniforms.color.value = material.color;\\r\\n\\t\\t\\t\\t\\tm_uniforms.opacity.value = material.opacity;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// RectAreaLight Texture\\r\\n\\t\\t\\t\\t// TODO (mrdoob): Find a nicer implementation\\r\\n\\r\\n\\t\\t\\t\\tif ( m_uniforms.ltcMat !== undefined ) m_uniforms.ltcMat.value = UniformsLib.LTC_MAT_TEXTURE;\\r\\n\\t\\t\\t\\tif ( m_uniforms.ltcMag !== undefined ) m_uniforms.ltcMag.value = UniformsLib.LTC_MAG_TEXTURE;\\r\\n\\r\\n\\t\\t\\t\\tWebGLUniforms.upload(\\r\\n\\t\\t\\t\\t\\t_gl, materialProperties.uniformsList, m_uniforms, _this );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\t\\t// common matrices\\r\\n\\r\\n\\t\\t\\tp_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );\\r\\n\\t\\t\\tp_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );\\r\\n\\t\\t\\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\\r\\n\\r\\n\\t\\t\\treturn program;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Uniforms (refresh uniforms objects)\\r\\n\\r\\n\\t\\tfunction refreshUniformsCommon( uniforms, material ) {\\r\\n\\r\\n\\t\\t\\tuniforms.opacity.value = material.opacity;\\r\\n\\r\\n\\t\\t\\tif ( material.color ) {\\r\\n\\r\\n\\t\\t\\t\\tuniforms.diffuse.value = material.color;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( material.emissive ) {\\r\\n\\r\\n\\t\\t\\t\\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( material.map ) {\\r\\n\\r\\n\\t\\t\\t\\tuniforms.map.value = material.map;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( material.alphaMap ) {\\r\\n\\r\\n\\t\\t\\t\\tuniforms.alphaMap.value = material.alphaMap;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( material.specularMap ) {\\r\\n\\r\\n\\t\\t\\t\\tuniforms.specularMap.value = material.specularMap;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( material.envMap ) {\\r\\n\\r\\n\\t\\t\\t\\tuniforms.envMap.value = material.envMap;\\r\\n\\r\\n\\t\\t\\t\\t// don't flip CubeTexture envMaps, flip everything else:\\r\\n\\t\\t\\t\\t//  WebGLRenderTargetCube will be flipped for backwards compatibility\\r\\n\\t\\t\\t\\t//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\\r\\n\\t\\t\\t\\t// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\\r\\n\\t\\t\\t\\tuniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;\\r\\n\\r\\n\\t\\t\\t\\tuniforms.reflectivity.value = material.reflectivity;\\r\\n\\t\\t\\t\\tuniforms.refractionRatio.value = material.refractionRatio;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( material.lightMap ) {\\r\\n\\r\\n\\t\\t\\t\\tuniforms.lightMap.value = material.lightMap;\\r\\n\\t\\t\\t\\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( material.aoMap ) {\\r\\n\\r\\n\\t\\t\\t\\tuniforms.aoMap.value = material.aoMap;\\r\\n\\t\\t\\t\\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// uv repeat and offset setting priorities\\r\\n\\t\\t\\t// 1. color map\\r\\n\\t\\t\\t// 2. specular map\\r\\n\\t\\t\\t// 3. normal map\\r\\n\\t\\t\\t// 4. bump map\\r\\n\\t\\t\\t// 5. alpha map\\r\\n\\t\\t\\t// 6. emissive map\\r\\n\\r\\n\\t\\t\\tvar uvScaleMap;\\r\\n\\r\\n\\t\\t\\tif ( material.map ) {\\r\\n\\r\\n\\t\\t\\t\\tuvScaleMap = material.map;\\r\\n\\r\\n\\t\\t\\t} else if ( material.specularMap ) {\\r\\n\\r\\n\\t\\t\\t\\tuvScaleMap = material.specularMap;\\r\\n\\r\\n\\t\\t\\t} else if ( material.displacementMap ) {\\r\\n\\r\\n\\t\\t\\t\\tuvScaleMap = material.displacementMap;\\r\\n\\r\\n\\t\\t\\t} else if ( material.normalMap ) {\\r\\n\\r\\n\\t\\t\\t\\tuvScaleMap = material.normalMap;\\r\\n\\r\\n\\t\\t\\t} else if ( material.bumpMap ) {\\r\\n\\r\\n\\t\\t\\t\\tuvScaleMap = material.bumpMap;\\r\\n\\r\\n\\t\\t\\t} else if ( material.roughnessMap ) {\\r\\n\\r\\n\\t\\t\\t\\tuvScaleMap = material.roughnessMap;\\r\\n\\r\\n\\t\\t\\t} else if ( material.metalnessMap ) {\\r\\n\\r\\n\\t\\t\\t\\tuvScaleMap = material.metalnessMap;\\r\\n\\r\\n\\t\\t\\t} else if ( material.alphaMap ) {\\r\\n\\r\\n\\t\\t\\t\\tuvScaleMap = material.alphaMap;\\r\\n\\r\\n\\t\\t\\t} else if ( material.emissiveMap ) {\\r\\n\\r\\n\\t\\t\\t\\tuvScaleMap = material.emissiveMap;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( uvScaleMap !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t// backwards compatibility\\r\\n\\t\\t\\t\\tif ( uvScaleMap.isWebGLRenderTarget ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tuvScaleMap = uvScaleMap.texture;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( uvScaleMap.matrixAutoUpdate === true ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar offset = uvScaleMap.offset;\\r\\n\\t\\t\\t\\t\\tvar repeat = uvScaleMap.repeat;\\r\\n\\t\\t\\t\\t\\tvar rotation = uvScaleMap.rotation;\\r\\n\\t\\t\\t\\t\\tvar center = uvScaleMap.center;\\r\\n\\r\\n\\t\\t\\t\\t\\tuvScaleMap.matrix.setUvTransform( offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tuniforms.uvTransform.value.copy( uvScaleMap.matrix );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction refreshUniformsLine( uniforms, material ) {\\r\\n\\r\\n\\t\\t\\tuniforms.diffuse.value = material.color;\\r\\n\\t\\t\\tuniforms.opacity.value = material.opacity;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction refreshUniformsDash( uniforms, material ) {\\r\\n\\r\\n\\t\\t\\tuniforms.dashSize.value = material.dashSize;\\r\\n\\t\\t\\tuniforms.totalSize.value = material.dashSize + material.gapSize;\\r\\n\\t\\t\\tuniforms.scale.value = material.scale;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction refreshUniformsPoints( uniforms, material ) {\\r\\n\\r\\n\\t\\t\\tuniforms.diffuse.value = material.color;\\r\\n\\t\\t\\tuniforms.opacity.value = material.opacity;\\r\\n\\t\\t\\tuniforms.size.value = material.size * _pixelRatio;\\r\\n\\t\\t\\tuniforms.scale.value = _height * 0.5;\\r\\n\\r\\n\\t\\t\\tuniforms.map.value = material.map;\\r\\n\\r\\n\\t\\t\\tif ( material.map !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( material.map.matrixAutoUpdate === true ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar offset = material.map.offset;\\r\\n\\t\\t\\t\\t\\tvar repeat = material.map.repeat;\\r\\n\\t\\t\\t\\t\\tvar rotation = material.map.rotation;\\r\\n\\t\\t\\t\\t\\tvar center = material.map.center;\\r\\n\\r\\n\\t\\t\\t\\t\\tmaterial.map.matrix.setUvTransform( offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tuniforms.uvTransform.value.copy( material.map.matrix );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction refreshUniformsFog( uniforms, fog ) {\\r\\n\\r\\n\\t\\t\\tuniforms.fogColor.value = fog.color;\\r\\n\\r\\n\\t\\t\\tif ( fog.isFog ) {\\r\\n\\r\\n\\t\\t\\t\\tuniforms.fogNear.value = fog.near;\\r\\n\\t\\t\\t\\tuniforms.fogFar.value = fog.far;\\r\\n\\r\\n\\t\\t\\t} else if ( fog.isFogExp2 ) {\\r\\n\\r\\n\\t\\t\\t\\tuniforms.fogDensity.value = fog.density;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction refreshUniformsLambert( uniforms, material ) {\\r\\n\\r\\n\\t\\t\\tif ( material.emissiveMap ) {\\r\\n\\r\\n\\t\\t\\t\\tuniforms.emissiveMap.value = material.emissiveMap;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction refreshUniformsPhong( uniforms, material ) {\\r\\n\\r\\n\\t\\t\\tuniforms.specular.value = material.specular;\\r\\n\\t\\t\\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\\r\\n\\r\\n\\t\\t\\tif ( material.emissiveMap ) {\\r\\n\\r\\n\\t\\t\\t\\tuniforms.emissiveMap.value = material.emissiveMap;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( material.bumpMap ) {\\r\\n\\r\\n\\t\\t\\t\\tuniforms.bumpMap.value = material.bumpMap;\\r\\n\\t\\t\\t\\tuniforms.bumpScale.value = material.bumpScale;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( material.normalMap ) {\\r\\n\\r\\n\\t\\t\\t\\tuniforms.normalMap.value = material.normalMap;\\r\\n\\t\\t\\t\\tuniforms.normalScale.value.copy( material.normalScale );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( material.displacementMap ) {\\r\\n\\r\\n\\t\\t\\t\\tuniforms.displacementMap.value = material.displacementMap;\\r\\n\\t\\t\\t\\tuniforms.displacementScale.value = material.displacementScale;\\r\\n\\t\\t\\t\\tuniforms.displacementBias.value = material.displacementBias;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction refreshUniformsToon( uniforms, material ) {\\r\\n\\r\\n\\t\\t\\trefreshUniformsPhong( uniforms, material );\\r\\n\\r\\n\\t\\t\\tif ( material.gradientMap ) {\\r\\n\\r\\n\\t\\t\\t\\tuniforms.gradientMap.value = material.gradientMap;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction refreshUniformsStandard( uniforms, material ) {\\r\\n\\r\\n\\t\\t\\tuniforms.roughness.value = material.roughness;\\r\\n\\t\\t\\tuniforms.metalness.value = material.metalness;\\r\\n\\r\\n\\t\\t\\tif ( material.roughnessMap ) {\\r\\n\\r\\n\\t\\t\\t\\tuniforms.roughnessMap.value = material.roughnessMap;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( material.metalnessMap ) {\\r\\n\\r\\n\\t\\t\\t\\tuniforms.metalnessMap.value = material.metalnessMap;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( material.emissiveMap ) {\\r\\n\\r\\n\\t\\t\\t\\tuniforms.emissiveMap.value = material.emissiveMap;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( material.bumpMap ) {\\r\\n\\r\\n\\t\\t\\t\\tuniforms.bumpMap.value = material.bumpMap;\\r\\n\\t\\t\\t\\tuniforms.bumpScale.value = material.bumpScale;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( material.normalMap ) {\\r\\n\\r\\n\\t\\t\\t\\tuniforms.normalMap.value = material.normalMap;\\r\\n\\t\\t\\t\\tuniforms.normalScale.value.copy( material.normalScale );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( material.displacementMap ) {\\r\\n\\r\\n\\t\\t\\t\\tuniforms.displacementMap.value = material.displacementMap;\\r\\n\\t\\t\\t\\tuniforms.displacementScale.value = material.displacementScale;\\r\\n\\t\\t\\t\\tuniforms.displacementBias.value = material.displacementBias;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( material.envMap ) {\\r\\n\\r\\n\\t\\t\\t\\t//uniforms.envMap.value = material.envMap; // part of uniforms common\\r\\n\\t\\t\\t\\tuniforms.envMapIntensity.value = material.envMapIntensity;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction refreshUniformsPhysical( uniforms, material ) {\\r\\n\\r\\n\\t\\t\\tuniforms.clearCoat.value = material.clearCoat;\\r\\n\\t\\t\\tuniforms.clearCoatRoughness.value = material.clearCoatRoughness;\\r\\n\\r\\n\\t\\t\\trefreshUniformsStandard( uniforms, material );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction refreshUniformsDepth( uniforms, material ) {\\r\\n\\r\\n\\t\\t\\tif ( material.displacementMap ) {\\r\\n\\r\\n\\t\\t\\t\\tuniforms.displacementMap.value = material.displacementMap;\\r\\n\\t\\t\\t\\tuniforms.displacementScale.value = material.displacementScale;\\r\\n\\t\\t\\t\\tuniforms.displacementBias.value = material.displacementBias;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction refreshUniformsDistance( uniforms, material ) {\\r\\n\\r\\n\\t\\t\\tif ( material.displacementMap ) {\\r\\n\\r\\n\\t\\t\\t\\tuniforms.displacementMap.value = material.displacementMap;\\r\\n\\t\\t\\t\\tuniforms.displacementScale.value = material.displacementScale;\\r\\n\\t\\t\\t\\tuniforms.displacementBias.value = material.displacementBias;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tuniforms.referencePosition.value.copy( material.referencePosition );\\r\\n\\t\\t\\tuniforms.nearDistance.value = material.nearDistance;\\r\\n\\t\\t\\tuniforms.farDistance.value = material.farDistance;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction refreshUniformsNormal( uniforms, material ) {\\r\\n\\r\\n\\t\\t\\tif ( material.bumpMap ) {\\r\\n\\r\\n\\t\\t\\t\\tuniforms.bumpMap.value = material.bumpMap;\\r\\n\\t\\t\\t\\tuniforms.bumpScale.value = material.bumpScale;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( material.normalMap ) {\\r\\n\\r\\n\\t\\t\\t\\tuniforms.normalMap.value = material.normalMap;\\r\\n\\t\\t\\t\\tuniforms.normalScale.value.copy( material.normalScale );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( material.displacementMap ) {\\r\\n\\r\\n\\t\\t\\t\\tuniforms.displacementMap.value = material.displacementMap;\\r\\n\\t\\t\\t\\tuniforms.displacementScale.value = material.displacementScale;\\r\\n\\t\\t\\t\\tuniforms.displacementBias.value = material.displacementBias;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\\r\\n\\r\\n\\t\\tfunction markUniformsLightsNeedsUpdate( uniforms, value ) {\\r\\n\\r\\n\\t\\t\\tuniforms.ambientLightColor.needsUpdate = value;\\r\\n\\r\\n\\t\\t\\tuniforms.directionalLights.needsUpdate = value;\\r\\n\\t\\t\\tuniforms.pointLights.needsUpdate = value;\\r\\n\\t\\t\\tuniforms.spotLights.needsUpdate = value;\\r\\n\\t\\t\\tuniforms.rectAreaLights.needsUpdate = value;\\r\\n\\t\\t\\tuniforms.hemisphereLights.needsUpdate = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// GL state setting\\r\\n\\r\\n\\t\\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\\r\\n\\r\\n\\t\\t\\tstate.setCullFace( cullFace );\\r\\n\\t\\t\\tstate.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\t// Textures\\r\\n\\r\\n\\t\\tfunction allocTextureUnit() {\\r\\n\\r\\n\\t\\t\\tvar textureUnit = _usedTextureUnits;\\r\\n\\r\\n\\t\\t\\tif ( textureUnit >= capabilities.maxTextures ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t_usedTextureUnits += 1;\\r\\n\\r\\n\\t\\t\\treturn textureUnit;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.allocTextureUnit = allocTextureUnit;\\r\\n\\r\\n\\t\\t// this.setTexture2D = setTexture2D;\\r\\n\\t\\tthis.setTexture2D = ( function () {\\r\\n\\r\\n\\t\\t\\tvar warned = false;\\r\\n\\r\\n\\t\\t\\t// backwards compatibility: peel texture.texture\\r\\n\\t\\t\\treturn function setTexture2D( texture, slot ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( texture && texture.isWebGLRenderTarget ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( ! warned ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tconsole.warn( \\\"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\\\" );\\r\\n\\t\\t\\t\\t\\t\\twarned = true;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\ttexture = texture.texture;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\ttextures.setTexture2D( texture, slot );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}() );\\r\\n\\r\\n\\t\\tthis.setTexture = ( function () {\\r\\n\\r\\n\\t\\t\\tvar warned = false;\\r\\n\\r\\n\\t\\t\\treturn function setTexture( texture, slot ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( ! warned ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( \\\"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\\\" );\\r\\n\\t\\t\\t\\t\\twarned = true;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\ttextures.setTexture2D( texture, slot );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}() );\\r\\n\\r\\n\\t\\tthis.setTextureCube = ( function () {\\r\\n\\r\\n\\t\\t\\tvar warned = false;\\r\\n\\r\\n\\t\\t\\treturn function setTextureCube( texture, slot ) {\\r\\n\\r\\n\\t\\t\\t\\t// backwards compatibility: peel texture.texture\\r\\n\\t\\t\\t\\tif ( texture && texture.isWebGLRenderTargetCube ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( ! warned ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tconsole.warn( \\\"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\\\" );\\r\\n\\t\\t\\t\\t\\t\\twarned = true;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\ttexture = texture.texture;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture\\r\\n\\t\\t\\t\\t// TODO: unify these code paths\\r\\n\\t\\t\\t\\tif ( ( texture && texture.isCubeTexture ) ||\\r\\n\\t\\t\\t\\t\\t( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// CompressedTexture can have Array in image :/\\r\\n\\r\\n\\t\\t\\t\\t\\t// this function alone should take care of cube textures\\r\\n\\t\\t\\t\\t\\ttextures.setTextureCube( texture, slot );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t// assumed: texture property of THREE.WebGLRenderTargetCube\\r\\n\\r\\n\\t\\t\\t\\t\\ttextures.setTextureCubeDynamic( texture, slot );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}() );\\r\\n\\r\\n\\t\\tthis.getRenderTarget = function () {\\r\\n\\r\\n\\t\\t\\treturn _currentRenderTarget;\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.setRenderTarget = function ( renderTarget ) {\\r\\n\\r\\n\\t\\t\\t_currentRenderTarget = renderTarget;\\r\\n\\r\\n\\t\\t\\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\ttextures.setupRenderTarget( renderTarget );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar framebuffer = null;\\r\\n\\t\\t\\tvar isCube = false;\\r\\n\\r\\n\\t\\t\\tif ( renderTarget ) {\\r\\n\\r\\n\\t\\t\\t\\tvar __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;\\r\\n\\r\\n\\t\\t\\t\\tif ( renderTarget.isWebGLRenderTargetCube ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tframebuffer = __webglFramebuffer[ renderTarget.activeCubeFace ];\\r\\n\\t\\t\\t\\t\\tisCube = true;\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tframebuffer = __webglFramebuffer;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t_currentViewport.copy( renderTarget.viewport );\\r\\n\\t\\t\\t\\t_currentScissor.copy( renderTarget.scissor );\\r\\n\\t\\t\\t\\t_currentScissorTest = renderTarget.scissorTest;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\\r\\n\\t\\t\\t\\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\\r\\n\\t\\t\\t\\t_currentScissorTest = _scissorTest;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( _currentFramebuffer !== framebuffer ) {\\r\\n\\r\\n\\t\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\\r\\n\\t\\t\\t\\t_currentFramebuffer = framebuffer;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tstate.viewport( _currentViewport );\\r\\n\\t\\t\\tstate.scissor( _currentScissor );\\r\\n\\t\\t\\tstate.setScissorTest( _currentScissorTest );\\r\\n\\r\\n\\t\\t\\tif ( isCube ) {\\r\\n\\r\\n\\t\\t\\t\\tvar textureProperties = properties.get( renderTarget.texture );\\r\\n\\t\\t\\t\\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\\r\\n\\r\\n\\t\\t\\tif ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\\r\\n\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\\r\\n\\r\\n\\t\\t\\tif ( framebuffer ) {\\r\\n\\r\\n\\t\\t\\t\\tvar restore = false;\\r\\n\\r\\n\\t\\t\\t\\tif ( framebuffer !== _currentFramebuffer ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\\r\\n\\r\\n\\t\\t\\t\\t\\trestore = true;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\ttry {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar texture = renderTarget.texture;\\r\\n\\t\\t\\t\\t\\tvar textureFormat = texture.format;\\r\\n\\t\\t\\t\\t\\tvar textureType = texture.type;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\\r\\n\\t\\t\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)\\r\\n\\t\\t\\t\\t\\t\\t! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox\\r\\n\\t\\t\\t\\t\\t\\t! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\\r\\n\\t\\t\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} finally {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( restore ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction FogExp2( color, density ) {\\r\\n\\r\\n\\t\\tthis.name = '';\\r\\n\\r\\n\\t\\tthis.color = new Color( color );\\r\\n\\t\\tthis.density = ( density !== undefined ) ? density : 0.00025;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tFogExp2.prototype.isFogExp2 = true;\\r\\n\\r\\n\\tFogExp2.prototype.clone = function () {\\r\\n\\r\\n\\t\\treturn new FogExp2( this.color.getHex(), this.density );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tFogExp2.prototype.toJSON = function ( /* meta */ ) {\\r\\n\\r\\n\\t\\treturn {\\r\\n\\t\\t\\ttype: 'FogExp2',\\r\\n\\t\\t\\tcolor: this.color.getHex(),\\r\\n\\t\\t\\tdensity: this.density\\r\\n\\t\\t};\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction Fog( color, near, far ) {\\r\\n\\r\\n\\t\\tthis.name = '';\\r\\n\\r\\n\\t\\tthis.color = new Color( color );\\r\\n\\r\\n\\t\\tthis.near = ( near !== undefined ) ? near : 1;\\r\\n\\t\\tthis.far = ( far !== undefined ) ? far : 1000;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tFog.prototype.isFog = true;\\r\\n\\r\\n\\tFog.prototype.clone = function () {\\r\\n\\r\\n\\t\\treturn new Fog( this.color.getHex(), this.near, this.far );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tFog.prototype.toJSON = function ( /* meta */ ) {\\r\\n\\r\\n\\t\\treturn {\\r\\n\\t\\t\\ttype: 'Fog',\\r\\n\\t\\t\\tcolor: this.color.getHex(),\\r\\n\\t\\t\\tnear: this.near,\\r\\n\\t\\t\\tfar: this.far\\r\\n\\t\\t};\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction Scene() {\\r\\n\\r\\n\\t\\tObject3D.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'Scene';\\r\\n\\r\\n\\t\\tthis.background = null;\\r\\n\\t\\tthis.fog = null;\\r\\n\\t\\tthis.overrideMaterial = null;\\r\\n\\r\\n\\t\\tthis.autoUpdate = true; // checked by the renderer\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tScene.prototype = Object.assign( Object.create( Object3D.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: Scene,\\r\\n\\r\\n\\t\\tcopy: function ( source, recursive ) {\\r\\n\\r\\n\\t\\t\\tObject3D.prototype.copy.call( this, source, recursive );\\r\\n\\r\\n\\t\\t\\tif ( source.background !== null ) this.background = source.background.clone();\\r\\n\\t\\t\\tif ( source.fog !== null ) this.fog = source.fog.clone();\\r\\n\\t\\t\\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\\r\\n\\r\\n\\t\\t\\tthis.autoUpdate = source.autoUpdate;\\r\\n\\t\\t\\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttoJSON: function ( meta ) {\\r\\n\\r\\n\\t\\t\\tvar data = Object3D.prototype.toJSON.call( this, meta );\\r\\n\\r\\n\\t\\t\\tif ( this.background !== null ) data.object.background = this.background.toJSON( meta );\\r\\n\\t\\t\\tif ( this.fog !== null ) data.object.fog = this.fog.toJSON();\\r\\n\\r\\n\\t\\t\\treturn data;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mikael emtinger / http://gomo.se/\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction LensFlare( texture, size, distance, blending, color ) {\\r\\n\\r\\n\\t\\tObject3D.call( this );\\r\\n\\r\\n\\t\\tthis.lensFlares = [];\\r\\n\\r\\n\\t\\tthis.positionScreen = new Vector3();\\r\\n\\t\\tthis.customUpdateCallback = undefined;\\r\\n\\r\\n\\t\\tif ( texture !== undefined ) {\\r\\n\\r\\n\\t\\t\\tthis.add( texture, size, distance, blending, color );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tLensFlare.prototype = Object.assign( Object.create( Object3D.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: LensFlare,\\r\\n\\r\\n\\t\\tisLensFlare: true,\\r\\n\\r\\n\\t\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\t\\tObject3D.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\t\\tthis.positionScreen.copy( source.positionScreen );\\r\\n\\t\\t\\tthis.customUpdateCallback = source.customUpdateCallback;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.lensFlares.push( source.lensFlares[ i ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tadd: function ( texture, size, distance, blending, color, opacity ) {\\r\\n\\r\\n\\t\\t\\tif ( size === undefined ) size = - 1;\\r\\n\\t\\t\\tif ( distance === undefined ) distance = 0;\\r\\n\\t\\t\\tif ( opacity === undefined ) opacity = 1;\\r\\n\\t\\t\\tif ( color === undefined ) color = new Color( 0xffffff );\\r\\n\\t\\t\\tif ( blending === undefined ) blending = NormalBlending;\\r\\n\\r\\n\\t\\t\\tdistance = Math.min( distance, Math.max( 0, distance ) );\\r\\n\\r\\n\\t\\t\\tthis.lensFlares.push( {\\r\\n\\t\\t\\t\\ttexture: texture,\\t// THREE.Texture\\r\\n\\t\\t\\t\\tsize: size, \\t\\t// size in pixels (-1 = use texture.width)\\r\\n\\t\\t\\t\\tdistance: distance, \\t// distance (0-1) from light source (0=at light source)\\r\\n\\t\\t\\t\\tx: 0, y: 0, z: 0,\\t// screen position (-1 => 1) z = 0 is in front z = 1 is back\\r\\n\\t\\t\\t\\tscale: 1, \\t\\t// scale\\r\\n\\t\\t\\t\\trotation: 0, \\t\\t// rotation\\r\\n\\t\\t\\t\\topacity: opacity,\\t// opacity\\r\\n\\t\\t\\t\\tcolor: color,\\t\\t// color\\r\\n\\t\\t\\t\\tblending: blending\\t// blending\\r\\n\\t\\t\\t} );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t/*\\r\\n\\t\\t * Update lens flares update positions on all flares based on the screen position\\r\\n\\t\\t * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\\r\\n\\t\\t */\\r\\n\\r\\n\\t\\tupdateLensFlares: function () {\\r\\n\\r\\n\\t\\t\\tvar f, fl = this.lensFlares.length;\\r\\n\\t\\t\\tvar flare;\\r\\n\\t\\t\\tvar vecX = - this.positionScreen.x * 2;\\r\\n\\t\\t\\tvar vecY = - this.positionScreen.y * 2;\\r\\n\\r\\n\\t\\t\\tfor ( f = 0; f < fl; f ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tflare = this.lensFlares[ f ];\\r\\n\\r\\n\\t\\t\\t\\tflare.x = this.positionScreen.x + vecX * flare.distance;\\r\\n\\t\\t\\t\\tflare.y = this.positionScreen.y + vecY * flare.distance;\\r\\n\\r\\n\\t\\t\\t\\tflare.wantedRotation = flare.x * Math.PI * 0.25;\\r\\n\\t\\t\\t\\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t *\\r\\n\\t * parameters = {\\r\\n\\t *  color: <hex>,\\r\\n\\t *  opacity: <float>,\\r\\n\\t *  map: new THREE.Texture( <Image> ),\\r\\n\\t *\\r\\n\\t *\\tuvOffset: new THREE.Vector2(),\\r\\n\\t *\\tuvScale: new THREE.Vector2()\\r\\n\\t * }\\r\\n\\t */\\r\\n\\r\\n\\tfunction SpriteMaterial( parameters ) {\\r\\n\\r\\n\\t\\tMaterial.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'SpriteMaterial';\\r\\n\\r\\n\\t\\tthis.color = new Color( 0xffffff );\\r\\n\\t\\tthis.map = null;\\r\\n\\r\\n\\t\\tthis.rotation = 0;\\r\\n\\r\\n\\t\\tthis.fog = false;\\r\\n\\t\\tthis.lights = false;\\r\\n\\r\\n\\t\\tthis.setValues( parameters );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tSpriteMaterial.prototype = Object.create( Material.prototype );\\r\\n\\tSpriteMaterial.prototype.constructor = SpriteMaterial;\\r\\n\\tSpriteMaterial.prototype.isSpriteMaterial = true;\\r\\n\\r\\n\\tSpriteMaterial.prototype.copy = function ( source ) {\\r\\n\\r\\n\\t\\tMaterial.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.color.copy( source.color );\\r\\n\\t\\tthis.map = source.map;\\r\\n\\r\\n\\t\\tthis.rotation = source.rotation;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mikael emtinger / http://gomo.se/\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction Sprite( material ) {\\r\\n\\r\\n\\t\\tObject3D.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'Sprite';\\r\\n\\r\\n\\t\\tthis.material = ( material !== undefined ) ? material : new SpriteMaterial();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tSprite.prototype = Object.assign( Object.create( Object3D.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: Sprite,\\r\\n\\r\\n\\t\\tisSprite: true,\\r\\n\\r\\n\\t\\traycast: ( function () {\\r\\n\\r\\n\\t\\t\\tvar intersectPoint = new Vector3();\\r\\n\\t\\t\\tvar worldPosition = new Vector3();\\r\\n\\t\\t\\tvar worldScale = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function raycast( raycaster, intersects ) {\\r\\n\\r\\n\\t\\t\\t\\tworldPosition.setFromMatrixPosition( this.matrixWorld );\\r\\n\\t\\t\\t\\traycaster.ray.closestPointToPoint( worldPosition, intersectPoint );\\r\\n\\r\\n\\t\\t\\t\\tworldScale.setFromMatrixScale( this.matrixWorld );\\r\\n\\t\\t\\t\\tvar guessSizeSq = worldScale.x * worldScale.y / 4;\\r\\n\\r\\n\\t\\t\\t\\tif ( worldPosition.distanceToSquared( intersectPoint ) > guessSizeSq ) return;\\r\\n\\r\\n\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\\r\\n\\r\\n\\t\\t\\t\\tif ( distance < raycaster.near || distance > raycaster.far ) return;\\r\\n\\r\\n\\t\\t\\t\\tintersects.push( {\\r\\n\\r\\n\\t\\t\\t\\t\\tdistance: distance,\\r\\n\\t\\t\\t\\t\\tpoint: intersectPoint.clone(),\\r\\n\\t\\t\\t\\t\\tface: null,\\r\\n\\t\\t\\t\\t\\tobject: this\\r\\n\\r\\n\\t\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}() ),\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor( this.material ).copy( this );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mikael emtinger / http://gomo.se/\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction LOD() {\\r\\n\\r\\n\\t\\tObject3D.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'LOD';\\r\\n\\r\\n\\t\\tObject.defineProperties( this, {\\r\\n\\t\\t\\tlevels: {\\r\\n\\t\\t\\t\\tenumerable: true,\\r\\n\\t\\t\\t\\tvalue: []\\r\\n\\t\\t\\t}\\r\\n\\t\\t} );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tLOD.prototype = Object.assign( Object.create( Object3D.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: LOD,\\r\\n\\r\\n\\t\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\t\\tObject3D.prototype.copy.call( this, source, false );\\r\\n\\r\\n\\t\\t\\tvar levels = source.levels;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar level = levels[ i ];\\r\\n\\r\\n\\t\\t\\t\\tthis.addLevel( level.object.clone(), level.distance );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\taddLevel: function ( object, distance ) {\\r\\n\\r\\n\\t\\t\\tif ( distance === undefined ) distance = 0;\\r\\n\\r\\n\\t\\t\\tdistance = Math.abs( distance );\\r\\n\\r\\n\\t\\t\\tvar levels = this.levels;\\r\\n\\r\\n\\t\\t\\tfor ( var l = 0; l < levels.length; l ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( distance < levels[ l ].distance ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tlevels.splice( l, 0, { distance: distance, object: object } );\\r\\n\\r\\n\\t\\t\\tthis.add( object );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetObjectForDistance: function ( distance ) {\\r\\n\\r\\n\\t\\t\\tvar levels = this.levels;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( distance < levels[ i ].distance ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn levels[ i - 1 ].object;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\traycast: ( function () {\\r\\n\\r\\n\\t\\t\\tvar matrixPosition = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function raycast( raycaster, intersects ) {\\r\\n\\r\\n\\t\\t\\t\\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\\r\\n\\r\\n\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\\r\\n\\r\\n\\t\\t\\t\\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}() ),\\r\\n\\r\\n\\t\\tupdate: function () {\\r\\n\\r\\n\\t\\t\\tvar v1 = new Vector3();\\r\\n\\t\\t\\tvar v2 = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function update( camera ) {\\r\\n\\r\\n\\t\\t\\t\\tvar levels = this.levels;\\r\\n\\r\\n\\t\\t\\t\\tif ( levels.length > 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tv1.setFromMatrixPosition( camera.matrixWorld );\\r\\n\\t\\t\\t\\t\\tv2.setFromMatrixPosition( this.matrixWorld );\\r\\n\\r\\n\\t\\t\\t\\t\\tvar distance = v1.distanceTo( v2 );\\r\\n\\r\\n\\t\\t\\t\\t\\tlevels[ 0 ].object.visible = true;\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( distance >= levels[ i ].distance ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tlevels[ i - 1 ].object.visible = false;\\r\\n\\t\\t\\t\\t\\t\\t\\tlevels[ i ].object.visible = true;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( ; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tlevels[ i ].object.visible = false;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\ttoJSON: function ( meta ) {\\r\\n\\r\\n\\t\\t\\tvar data = Object3D.prototype.toJSON.call( this, meta );\\r\\n\\r\\n\\t\\t\\tdata.object.levels = [];\\r\\n\\r\\n\\t\\t\\tvar levels = this.levels;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar level = levels[ i ];\\r\\n\\r\\n\\t\\t\\t\\tdata.object.levels.push( {\\r\\n\\t\\t\\t\\t\\tobject: level.object.uuid,\\r\\n\\t\\t\\t\\t\\tdistance: level.distance\\r\\n\\t\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn data;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mikael emtinger / http://gomo.se/\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t * @author michael guerrero / http://realitymeltdown.com\\r\\n\\t * @author ikerr / http://verold.com\\r\\n\\t */\\r\\n\\r\\n\\tfunction Skeleton( bones, boneInverses ) {\\r\\n\\r\\n\\t\\t// copy the bone array\\r\\n\\r\\n\\t\\tbones = bones || [];\\r\\n\\r\\n\\t\\tthis.bones = bones.slice( 0 );\\r\\n\\t\\tthis.boneMatrices = new Float32Array( this.bones.length * 16 );\\r\\n\\r\\n\\t\\t// use the supplied bone inverses or calculate the inverses\\r\\n\\r\\n\\t\\tif ( boneInverses === undefined ) {\\r\\n\\r\\n\\t\\t\\tthis.calculateInverses();\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tif ( this.bones.length === boneInverses.length ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.boneInverses = boneInverses.slice( 0 );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Skeleton boneInverses is the wrong length.' );\\r\\n\\r\\n\\t\\t\\t\\tthis.boneInverses = [];\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, il = this.bones.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.boneInverses.push( new Matrix4() );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( Skeleton.prototype, {\\r\\n\\r\\n\\t\\tcalculateInverses: function () {\\r\\n\\r\\n\\t\\t\\tthis.boneInverses = [];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, il = this.bones.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar inverse = new Matrix4();\\r\\n\\r\\n\\t\\t\\t\\tif ( this.bones[ i ] ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tinverse.getInverse( this.bones[ i ].matrixWorld );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tthis.boneInverses.push( inverse );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tpose: function () {\\r\\n\\r\\n\\t\\t\\tvar bone, i, il;\\r\\n\\r\\n\\t\\t\\t// recover the bind-time world matrices\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, il = this.bones.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tbone = this.bones[ i ];\\r\\n\\r\\n\\t\\t\\t\\tif ( bone ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tbone.matrixWorld.getInverse( this.boneInverses[ i ] );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// compute the local matrices, positions, rotations and scales\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, il = this.bones.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tbone = this.bones[ i ];\\r\\n\\r\\n\\t\\t\\t\\tif ( bone ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( bone.parent && bone.parent.isBone ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbone.matrix.getInverse( bone.parent.matrixWorld );\\r\\n\\t\\t\\t\\t\\t\\tbone.matrix.multiply( bone.matrixWorld );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbone.matrix.copy( bone.matrixWorld );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tupdate: ( function () {\\r\\n\\r\\n\\t\\t\\tvar offsetMatrix = new Matrix4();\\r\\n\\t\\t\\tvar identityMatrix = new Matrix4();\\r\\n\\r\\n\\t\\t\\treturn function update() {\\r\\n\\r\\n\\t\\t\\t\\tvar bones = this.bones;\\r\\n\\t\\t\\t\\tvar boneInverses = this.boneInverses;\\r\\n\\t\\t\\t\\tvar boneMatrices = this.boneMatrices;\\r\\n\\t\\t\\t\\tvar boneTexture = this.boneTexture;\\r\\n\\r\\n\\t\\t\\t\\t// flatten bone matrices to array\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, il = bones.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// compute the offset between the current and the original transform\\r\\n\\r\\n\\t\\t\\t\\t\\tvar matrix = bones[ i ] ? bones[ i ].matrixWorld : identityMatrix;\\r\\n\\r\\n\\t\\t\\t\\t\\toffsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );\\r\\n\\t\\t\\t\\t\\toffsetMatrix.toArray( boneMatrices, i * 16 );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( boneTexture !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tboneTexture.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t} )(),\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new Skeleton( this.bones, this.boneInverses );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mikael emtinger / http://gomo.se/\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t * @author ikerr / http://verold.com\\r\\n\\t */\\r\\n\\r\\n\\tfunction Bone() {\\r\\n\\r\\n\\t\\tObject3D.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'Bone';\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tBone.prototype = Object.assign( Object.create( Object3D.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: Bone,\\r\\n\\r\\n\\t\\tisBone: true\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mikael emtinger / http://gomo.se/\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t * @author ikerr / http://verold.com\\r\\n\\t */\\r\\n\\r\\n\\tfunction SkinnedMesh( geometry, material ) {\\r\\n\\r\\n\\t\\tMesh.call( this, geometry, material );\\r\\n\\r\\n\\t\\tthis.type = 'SkinnedMesh';\\r\\n\\r\\n\\t\\tthis.bindMode = 'attached';\\r\\n\\t\\tthis.bindMatrix = new Matrix4();\\r\\n\\t\\tthis.bindMatrixInverse = new Matrix4();\\r\\n\\r\\n\\t\\tvar bones = this.initBones();\\r\\n\\t\\tvar skeleton = new Skeleton( bones );\\r\\n\\r\\n\\t\\tthis.bind( skeleton, this.matrixWorld );\\r\\n\\r\\n\\t\\tthis.normalizeSkinWeights();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tSkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: SkinnedMesh,\\r\\n\\r\\n\\t\\tisSkinnedMesh: true,\\r\\n\\r\\n\\t\\tinitBones: function () {\\r\\n\\r\\n\\t\\t\\tvar bones = [], bone, gbone;\\r\\n\\t\\t\\tvar i, il;\\r\\n\\r\\n\\t\\t\\tif ( this.geometry && this.geometry.bones !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t// first, create array of 'Bone' objects from geometry data\\r\\n\\r\\n\\t\\t\\t\\tfor ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tgbone = this.geometry.bones[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\t// create new 'Bone' object\\r\\n\\r\\n\\t\\t\\t\\t\\tbone = new Bone();\\r\\n\\t\\t\\t\\t\\tbones.push( bone );\\r\\n\\r\\n\\t\\t\\t\\t\\t// apply values\\r\\n\\r\\n\\t\\t\\t\\t\\tbone.name = gbone.name;\\r\\n\\t\\t\\t\\t\\tbone.position.fromArray( gbone.pos );\\r\\n\\t\\t\\t\\t\\tbone.quaternion.fromArray( gbone.rotq );\\r\\n\\t\\t\\t\\t\\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// second, create bone hierarchy\\r\\n\\r\\n\\t\\t\\t\\tfor ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tgbone = this.geometry.bones[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( ( gbone.parent !== - 1 ) && ( gbone.parent !== null ) && ( bones[ gbone.parent ] !== undefined ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// subsequent bones in the hierarchy\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbones[ gbone.parent ].add( bones[ i ] );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// topmost bone, immediate child of the skinned mesh\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tthis.add( bones[ i ] );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// now the bones are part of the scene graph and children of the skinned mesh.\\r\\n\\t\\t\\t// let's update the corresponding matrices\\r\\n\\r\\n\\t\\t\\tthis.updateMatrixWorld( true );\\r\\n\\r\\n\\t\\t\\treturn bones;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tbind: function ( skeleton, bindMatrix ) {\\r\\n\\r\\n\\t\\t\\tthis.skeleton = skeleton;\\r\\n\\r\\n\\t\\t\\tif ( bindMatrix === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.updateMatrixWorld( true );\\r\\n\\r\\n\\t\\t\\t\\tthis.skeleton.calculateInverses();\\r\\n\\r\\n\\t\\t\\t\\tbindMatrix = this.matrixWorld;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.bindMatrix.copy( bindMatrix );\\r\\n\\t\\t\\tthis.bindMatrixInverse.getInverse( bindMatrix );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tpose: function () {\\r\\n\\r\\n\\t\\t\\tthis.skeleton.pose();\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tnormalizeSkinWeights: function () {\\r\\n\\r\\n\\t\\t\\tvar scale, i;\\r\\n\\r\\n\\t\\t\\tif ( this.geometry && this.geometry.isGeometry ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( i = 0; i < this.geometry.skinWeights.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar sw = this.geometry.skinWeights[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\tscale = 1.0 / sw.manhattanLength();\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( scale !== Infinity ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tsw.multiplyScalar( scale );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tsw.set( 1, 0, 0, 0 ); // do something reasonable\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else if ( this.geometry && this.geometry.isBufferGeometry ) {\\r\\n\\r\\n\\t\\t\\t\\tvar vec = new Vector4();\\r\\n\\r\\n\\t\\t\\t\\tvar skinWeight = this.geometry.attributes.skinWeight;\\r\\n\\r\\n\\t\\t\\t\\tfor ( i = 0; i < skinWeight.count; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvec.x = skinWeight.getX( i );\\r\\n\\t\\t\\t\\t\\tvec.y = skinWeight.getY( i );\\r\\n\\t\\t\\t\\t\\tvec.z = skinWeight.getZ( i );\\r\\n\\t\\t\\t\\t\\tvec.w = skinWeight.getW( i );\\r\\n\\r\\n\\t\\t\\t\\t\\tscale = 1.0 / vec.manhattanLength();\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( scale !== Infinity ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvec.multiplyScalar( scale );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvec.set( 1, 0, 0, 0 ); // do something reasonable\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tskinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tupdateMatrixWorld: function ( force ) {\\r\\n\\r\\n\\t\\t\\tMesh.prototype.updateMatrixWorld.call( this, force );\\r\\n\\r\\n\\t\\t\\tif ( this.bindMode === 'attached' ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\\r\\n\\r\\n\\t\\t\\t} else if ( this.bindMode === 'detached' ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor( this.geometry, this.material ).copy( this );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t *\\r\\n\\t * parameters = {\\r\\n\\t *  color: <hex>,\\r\\n\\t *  opacity: <float>,\\r\\n\\t *\\r\\n\\t *  linewidth: <float>,\\r\\n\\t *  linecap: \\\"round\\\",\\r\\n\\t *  linejoin: \\\"round\\\"\\r\\n\\t * }\\r\\n\\t */\\r\\n\\r\\n\\tfunction LineBasicMaterial( parameters ) {\\r\\n\\r\\n\\t\\tMaterial.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'LineBasicMaterial';\\r\\n\\r\\n\\t\\tthis.color = new Color( 0xffffff );\\r\\n\\r\\n\\t\\tthis.linewidth = 1;\\r\\n\\t\\tthis.linecap = 'round';\\r\\n\\t\\tthis.linejoin = 'round';\\r\\n\\r\\n\\t\\tthis.lights = false;\\r\\n\\r\\n\\t\\tthis.setValues( parameters );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tLineBasicMaterial.prototype = Object.create( Material.prototype );\\r\\n\\tLineBasicMaterial.prototype.constructor = LineBasicMaterial;\\r\\n\\r\\n\\tLineBasicMaterial.prototype.isLineBasicMaterial = true;\\r\\n\\r\\n\\tLineBasicMaterial.prototype.copy = function ( source ) {\\r\\n\\r\\n\\t\\tMaterial.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.color.copy( source.color );\\r\\n\\r\\n\\t\\tthis.linewidth = source.linewidth;\\r\\n\\t\\tthis.linecap = source.linecap;\\r\\n\\t\\tthis.linejoin = source.linejoin;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction Line( geometry, material, mode ) {\\r\\n\\r\\n\\t\\tif ( mode === 1 ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\\r\\n\\t\\t\\treturn new LineSegments( geometry, material );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tObject3D.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'Line';\\r\\n\\r\\n\\t\\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\\r\\n\\t\\tthis.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tLine.prototype = Object.assign( Object.create( Object3D.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: Line,\\r\\n\\r\\n\\t\\tisLine: true,\\r\\n\\r\\n\\t\\traycast: ( function () {\\r\\n\\r\\n\\t\\t\\tvar inverseMatrix = new Matrix4();\\r\\n\\t\\t\\tvar ray = new Ray();\\r\\n\\t\\t\\tvar sphere = new Sphere();\\r\\n\\r\\n\\t\\t\\treturn function raycast( raycaster, intersects ) {\\r\\n\\r\\n\\t\\t\\t\\tvar precision = raycaster.linePrecision;\\r\\n\\t\\t\\t\\tvar precisionSq = precision * precision;\\r\\n\\r\\n\\t\\t\\t\\tvar geometry = this.geometry;\\r\\n\\t\\t\\t\\tvar matrixWorld = this.matrixWorld;\\r\\n\\r\\n\\t\\t\\t\\t// Checking boundingSphere distance to ray\\r\\n\\r\\n\\t\\t\\t\\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\\r\\n\\r\\n\\t\\t\\t\\tsphere.copy( geometry.boundingSphere );\\r\\n\\t\\t\\t\\tsphere.applyMatrix4( matrixWorld );\\r\\n\\r\\n\\t\\t\\t\\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\\r\\n\\r\\n\\t\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\t\\tinverseMatrix.getInverse( matrixWorld );\\r\\n\\t\\t\\t\\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\\r\\n\\r\\n\\t\\t\\t\\tvar vStart = new Vector3();\\r\\n\\t\\t\\t\\tvar vEnd = new Vector3();\\r\\n\\t\\t\\t\\tvar interSegment = new Vector3();\\r\\n\\t\\t\\t\\tvar interRay = new Vector3();\\r\\n\\t\\t\\t\\tvar step = ( this && this.isLineSegments ) ? 2 : 1;\\r\\n\\r\\n\\t\\t\\t\\tif ( geometry.isBufferGeometry ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar index = geometry.index;\\r\\n\\t\\t\\t\\t\\tvar attributes = geometry.attributes;\\r\\n\\t\\t\\t\\t\\tvar positions = attributes.position.array;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( index !== null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar indices = index.array;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar a = indices[ i ];\\r\\n\\t\\t\\t\\t\\t\\t\\tvar b = indices[ i + 1 ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvStart.fromArray( positions, a * 3 );\\r\\n\\t\\t\\t\\t\\t\\t\\tvEnd.fromArray( positions, b * 3 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( distSq > precisionSq ) continue;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( interRay );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tintersects.push( {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdistance: distance,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t// What do we want? intersection point on the ray or on the segment??\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t// point: raycaster.ray.at( distance ),\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tindex: i,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tface: null,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tfaceIndex: null,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tobject: this\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvStart.fromArray( positions, 3 * i );\\r\\n\\t\\t\\t\\t\\t\\t\\tvEnd.fromArray( positions, 3 * i + 3 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( distSq > precisionSq ) continue;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( interRay );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tintersects.push( {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdistance: distance,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t// What do we want? intersection point on the ray or on the segment??\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t// point: raycaster.ray.at( distance ),\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tindex: i,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tface: null,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tfaceIndex: null,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tobject: this\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else if ( geometry.isGeometry ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar vertices = geometry.vertices;\\r\\n\\t\\t\\t\\t\\tvar nbVertices = vertices.length;\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( distSq > precisionSq ) continue;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( interRay );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tintersects.push( {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tdistance: distance,\\r\\n\\t\\t\\t\\t\\t\\t\\t// What do we want? intersection point on the ray or on the segment??\\r\\n\\t\\t\\t\\t\\t\\t\\t// point: raycaster.ray.at( distance ),\\r\\n\\t\\t\\t\\t\\t\\t\\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\\r\\n\\t\\t\\t\\t\\t\\t\\tindex: i,\\r\\n\\t\\t\\t\\t\\t\\t\\tface: null,\\r\\n\\t\\t\\t\\t\\t\\t\\tfaceIndex: null,\\r\\n\\t\\t\\t\\t\\t\\t\\tobject: this\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}() ),\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor( this.geometry, this.material ).copy( this );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction LineSegments( geometry, material ) {\\r\\n\\r\\n\\t\\tLine.call( this, geometry, material );\\r\\n\\r\\n\\t\\tthis.type = 'LineSegments';\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tLineSegments.prototype = Object.assign( Object.create( Line.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: LineSegments,\\r\\n\\r\\n\\t\\tisLineSegments: true\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mgreter / http://github.com/mgreter\\r\\n\\t */\\r\\n\\r\\n\\tfunction LineLoop( geometry, material ) {\\r\\n\\r\\n\\t\\tLine.call( this, geometry, material );\\r\\n\\r\\n\\t\\tthis.type = 'LineLoop';\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tLineLoop.prototype = Object.assign( Object.create( Line.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: LineLoop,\\r\\n\\r\\n\\t\\tisLineLoop: true,\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t *\\r\\n\\t * parameters = {\\r\\n\\t *  color: <hex>,\\r\\n\\t *  opacity: <float>,\\r\\n\\t *  map: new THREE.Texture( <Image> ),\\r\\n\\t *\\r\\n\\t *  size: <float>,\\r\\n\\t *  sizeAttenuation: <bool>\\r\\n\\t * }\\r\\n\\t */\\r\\n\\r\\n\\tfunction PointsMaterial( parameters ) {\\r\\n\\r\\n\\t\\tMaterial.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'PointsMaterial';\\r\\n\\r\\n\\t\\tthis.color = new Color( 0xffffff );\\r\\n\\r\\n\\t\\tthis.map = null;\\r\\n\\r\\n\\t\\tthis.size = 1;\\r\\n\\t\\tthis.sizeAttenuation = true;\\r\\n\\r\\n\\t\\tthis.lights = false;\\r\\n\\r\\n\\t\\tthis.setValues( parameters );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tPointsMaterial.prototype = Object.create( Material.prototype );\\r\\n\\tPointsMaterial.prototype.constructor = PointsMaterial;\\r\\n\\r\\n\\tPointsMaterial.prototype.isPointsMaterial = true;\\r\\n\\r\\n\\tPointsMaterial.prototype.copy = function ( source ) {\\r\\n\\r\\n\\t\\tMaterial.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.color.copy( source.color );\\r\\n\\r\\n\\t\\tthis.map = source.map;\\r\\n\\r\\n\\t\\tthis.size = source.size;\\r\\n\\t\\tthis.sizeAttenuation = source.sizeAttenuation;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction Points( geometry, material ) {\\r\\n\\r\\n\\t\\tObject3D.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'Points';\\r\\n\\r\\n\\t\\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\\r\\n\\t\\tthis.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tPoints.prototype = Object.assign( Object.create( Object3D.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: Points,\\r\\n\\r\\n\\t\\tisPoints: true,\\r\\n\\r\\n\\t\\traycast: ( function () {\\r\\n\\r\\n\\t\\t\\tvar inverseMatrix = new Matrix4();\\r\\n\\t\\t\\tvar ray = new Ray();\\r\\n\\t\\t\\tvar sphere = new Sphere();\\r\\n\\r\\n\\t\\t\\treturn function raycast( raycaster, intersects ) {\\r\\n\\r\\n\\t\\t\\t\\tvar object = this;\\r\\n\\t\\t\\t\\tvar geometry = this.geometry;\\r\\n\\t\\t\\t\\tvar matrixWorld = this.matrixWorld;\\r\\n\\t\\t\\t\\tvar threshold = raycaster.params.Points.threshold;\\r\\n\\r\\n\\t\\t\\t\\t// Checking boundingSphere distance to ray\\r\\n\\r\\n\\t\\t\\t\\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\\r\\n\\r\\n\\t\\t\\t\\tsphere.copy( geometry.boundingSphere );\\r\\n\\t\\t\\t\\tsphere.applyMatrix4( matrixWorld );\\r\\n\\t\\t\\t\\tsphere.radius += threshold;\\r\\n\\r\\n\\t\\t\\t\\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\\r\\n\\r\\n\\t\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\t\\tinverseMatrix.getInverse( matrixWorld );\\r\\n\\t\\t\\t\\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\\r\\n\\r\\n\\t\\t\\t\\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\\r\\n\\t\\t\\t\\tvar localThresholdSq = localThreshold * localThreshold;\\r\\n\\t\\t\\t\\tvar position = new Vector3();\\r\\n\\r\\n\\t\\t\\t\\tfunction testPoint( point, index ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( rayPointDistanceSq < localThresholdSq ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar intersectPoint = ray.closestPointToPoint( point );\\r\\n\\t\\t\\t\\t\\t\\tintersectPoint.applyMatrix4( matrixWorld );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( distance < raycaster.near || distance > raycaster.far ) return;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tintersects.push( {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tdistance: distance,\\r\\n\\t\\t\\t\\t\\t\\t\\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\\r\\n\\t\\t\\t\\t\\t\\t\\tpoint: intersectPoint.clone(),\\r\\n\\t\\t\\t\\t\\t\\t\\tindex: index,\\r\\n\\t\\t\\t\\t\\t\\t\\tface: null,\\r\\n\\t\\t\\t\\t\\t\\t\\tobject: object\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( geometry.isBufferGeometry ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar index = geometry.index;\\r\\n\\t\\t\\t\\t\\tvar attributes = geometry.attributes;\\r\\n\\t\\t\\t\\t\\tvar positions = attributes.position.array;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( index !== null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar indices = index.array;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar a = indices[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tposition.fromArray( positions, a * 3 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\ttestPoint( position, a );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tposition.fromArray( positions, i * 3 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\ttestPoint( position, i );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar vertices = geometry.vertices;\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ttestPoint( vertices[ i ], i );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}() ),\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor( this.geometry, this.material ).copy( this );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction Group() {\\r\\n\\r\\n\\t\\tObject3D.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'Group';\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tGroup.prototype = Object.assign( Object.create( Object3D.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: Group,\\r\\n\\r\\n\\t\\tisGroup: true\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\\r\\n\\r\\n\\t\\tTexture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\\r\\n\\r\\n\\t\\tthis.generateMipmaps = false;\\r\\n\\r\\n\\t\\t// Set needsUpdate when first frame is ready\\r\\n\\r\\n\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\tfunction onLoaded() {\\r\\n\\r\\n\\t\\t\\tvideo.removeEventListener( 'loadeddata', onLoaded, false );\\r\\n\\t\\t\\tscope.needsUpdate = true;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvideo.addEventListener( 'loadeddata', onLoaded, false );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tVideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: VideoTexture,\\r\\n\\r\\n\\t\\tisVideoTexture: true,\\r\\n\\r\\n\\t\\tupdate: function () {\\r\\n\\r\\n\\t\\t\\tvar video = this.image;\\r\\n\\r\\n\\t\\t\\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\\r\\n\\r\\n\\t\\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\\r\\n\\r\\n\\t\\tthis.image = { width: width, height: height };\\r\\n\\t\\tthis.mipmaps = mipmaps;\\r\\n\\r\\n\\t\\t// no flipping for cube textures\\r\\n\\t\\t// (also flipping doesn't work for compressed textures )\\r\\n\\r\\n\\t\\tthis.flipY = false;\\r\\n\\r\\n\\t\\t// can't generate mipmaps for compressed textures\\r\\n\\t\\t// mips must be embedded in DDS files\\r\\n\\r\\n\\t\\tthis.generateMipmaps = false;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tCompressedTexture.prototype = Object.create( Texture.prototype );\\r\\n\\tCompressedTexture.prototype.constructor = CompressedTexture;\\r\\n\\r\\n\\tCompressedTexture.prototype.isCompressedTexture = true;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author Matt DesLauriers / @mattdesl\\r\\n\\t * @author atix / arthursilber.de\\r\\n\\t */\\r\\n\\r\\n\\tfunction DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {\\r\\n\\r\\n\\t\\tformat = format !== undefined ? format : DepthFormat;\\r\\n\\r\\n\\t\\tif ( format !== DepthFormat && format !== DepthStencilFormat ) {\\r\\n\\r\\n\\t\\t\\tthrow new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( type === undefined && format === DepthFormat ) type = UnsignedShortType;\\r\\n\\t\\tif ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;\\r\\n\\r\\n\\t\\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\\r\\n\\r\\n\\t\\tthis.image = { width: width, height: height };\\r\\n\\r\\n\\t\\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\\r\\n\\t\\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\\r\\n\\r\\n\\t\\tthis.flipY = false;\\r\\n\\t\\tthis.generateMipmaps\\t= false;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tDepthTexture.prototype = Object.create( Texture.prototype );\\r\\n\\tDepthTexture.prototype.constructor = DepthTexture;\\r\\n\\tDepthTexture.prototype.isDepthTexture = true;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author Mugen87 / https://github.com/Mugen87\\r\\n\\t */\\r\\n\\r\\n\\tfunction WireframeGeometry( geometry ) {\\r\\n\\r\\n\\t\\tBufferGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'WireframeGeometry';\\r\\n\\r\\n\\t\\t// buffer\\r\\n\\r\\n\\t\\tvar vertices = [];\\r\\n\\r\\n\\t\\t// helper variables\\r\\n\\r\\n\\t\\tvar i, j, l, o, ol;\\r\\n\\t\\tvar edge = [ 0, 0 ], edges = {}, e, edge1, edge2;\\r\\n\\t\\tvar key, keys = [ 'a', 'b', 'c' ];\\r\\n\\t\\tvar vertex;\\r\\n\\r\\n\\t\\t// different logic for Geometry and BufferGeometry\\r\\n\\r\\n\\t\\tif ( geometry && geometry.isGeometry ) {\\r\\n\\r\\n\\t\\t\\t// create a data structure that contains all edges without duplicates\\r\\n\\r\\n\\t\\t\\tvar faces = geometry.faces;\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, l = faces.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar face = faces[ i ];\\r\\n\\r\\n\\t\\t\\t\\tfor ( j = 0; j < 3; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tedge1 = face[ keys[ j ] ];\\r\\n\\t\\t\\t\\t\\tedge2 = face[ keys[ ( j + 1 ) % 3 ] ];\\r\\n\\t\\t\\t\\t\\tedge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates\\r\\n\\t\\t\\t\\t\\tedge[ 1 ] = Math.max( edge1, edge2 );\\r\\n\\r\\n\\t\\t\\t\\t\\tkey = edge[ 0 ] + ',' + edge[ 1 ];\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( edges[ key ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// generate vertices\\r\\n\\r\\n\\t\\t\\tfor ( key in edges ) {\\r\\n\\r\\n\\t\\t\\t\\te = edges[ key ];\\r\\n\\r\\n\\t\\t\\t\\tvertex = geometry.vertices[ e.index1 ];\\r\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\t\\tvertex = geometry.vertices[ e.index2 ];\\r\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else if ( geometry && geometry.isBufferGeometry ) {\\r\\n\\r\\n\\t\\t\\tvar position, indices, groups;\\r\\n\\t\\t\\tvar group, start, count;\\r\\n\\t\\t\\tvar index1, index2;\\r\\n\\r\\n\\t\\t\\tvertex = new Vector3();\\r\\n\\r\\n\\t\\t\\tif ( geometry.index !== null ) {\\r\\n\\r\\n\\t\\t\\t\\t// indexed BufferGeometry\\r\\n\\r\\n\\t\\t\\t\\tposition = geometry.attributes.position;\\r\\n\\t\\t\\t\\tindices = geometry.index;\\r\\n\\t\\t\\t\\tgroups = geometry.groups;\\r\\n\\r\\n\\t\\t\\t\\tif ( groups.length === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tgroups = [ { start: 0, count: indices.count, materialIndex: 0 } ];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// create a data structure that contains all eges without duplicates\\r\\n\\r\\n\\t\\t\\t\\tfor ( o = 0, ol = groups.length; o < ol; ++ o ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tgroup = groups[ o ];\\r\\n\\r\\n\\t\\t\\t\\t\\tstart = group.start;\\r\\n\\t\\t\\t\\t\\tcount = group.count;\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( i = start, l = ( start + count ); i < l; i += 3 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( j = 0; j < 3; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tedge1 = indices.getX( i + j );\\r\\n\\t\\t\\t\\t\\t\\t\\tedge2 = indices.getX( i + ( j + 1 ) % 3 );\\r\\n\\t\\t\\t\\t\\t\\t\\tedge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates\\r\\n\\t\\t\\t\\t\\t\\t\\tedge[ 1 ] = Math.max( edge1, edge2 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tkey = edge[ 0 ] + ',' + edge[ 1 ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( edges[ key ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// generate vertices\\r\\n\\r\\n\\t\\t\\t\\tfor ( key in edges ) {\\r\\n\\r\\n\\t\\t\\t\\t\\te = edges[ key ];\\r\\n\\r\\n\\t\\t\\t\\t\\tvertex.fromBufferAttribute( position, e.index1 );\\r\\n\\t\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\t\\t\\tvertex.fromBufferAttribute( position, e.index2 );\\r\\n\\t\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t// non-indexed BufferGeometry\\r\\n\\r\\n\\t\\t\\t\\tposition = geometry.attributes.position;\\r\\n\\r\\n\\t\\t\\t\\tfor ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( j = 0; j < 3; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// three edges per triangle, an edge is represented as (index1, index2)\\r\\n\\t\\t\\t\\t\\t\\t// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tindex1 = 3 * i + j;\\r\\n\\t\\t\\t\\t\\t\\tvertex.fromBufferAttribute( position, index1 );\\r\\n\\t\\t\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tindex2 = 3 * i + ( ( j + 1 ) % 3 );\\r\\n\\t\\t\\t\\t\\t\\tvertex.fromBufferAttribute( position, index2 );\\r\\n\\t\\t\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// build geometry\\r\\n\\r\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tWireframeGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\n\\tWireframeGeometry.prototype.constructor = WireframeGeometry;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author zz85 / https://github.com/zz85\\r\\n\\t * @author Mugen87 / https://github.com/Mugen87\\r\\n\\t *\\r\\n\\t * Parametric Surfaces Geometry\\r\\n\\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\\r\\n\\t */\\r\\n\\r\\n\\t// ParametricGeometry\\r\\n\\r\\n\\tfunction ParametricGeometry( func, slices, stacks ) {\\r\\n\\r\\n\\t\\tGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'ParametricGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tfunc: func,\\r\\n\\t\\t\\tslices: slices,\\r\\n\\t\\t\\tstacks: stacks\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );\\r\\n\\t\\tthis.mergeVertices();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tParametricGeometry.prototype = Object.create( Geometry.prototype );\\r\\n\\tParametricGeometry.prototype.constructor = ParametricGeometry;\\r\\n\\r\\n\\t// ParametricBufferGeometry\\r\\n\\r\\n\\tfunction ParametricBufferGeometry( func, slices, stacks ) {\\r\\n\\r\\n\\t\\tBufferGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'ParametricBufferGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tfunc: func,\\r\\n\\t\\t\\tslices: slices,\\r\\n\\t\\t\\tstacks: stacks\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\t// buffers\\r\\n\\r\\n\\t\\tvar indices = [];\\r\\n\\t\\tvar vertices = [];\\r\\n\\t\\tvar normals = [];\\r\\n\\t\\tvar uvs = [];\\r\\n\\r\\n\\t\\tvar EPS = 0.00001;\\r\\n\\r\\n\\t\\tvar normal = new Vector3();\\r\\n\\r\\n\\t\\tvar p0 = new Vector3(), p1 = new Vector3();\\r\\n\\t\\tvar pu = new Vector3(), pv = new Vector3();\\r\\n\\r\\n\\t\\tvar i, j;\\r\\n\\r\\n\\t\\t// generate vertices, normals and uvs\\r\\n\\r\\n\\t\\tvar sliceCount = slices + 1;\\r\\n\\r\\n\\t\\tfor ( i = 0; i <= stacks; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar v = i / stacks;\\r\\n\\r\\n\\t\\t\\tfor ( j = 0; j <= slices; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar u = j / slices;\\r\\n\\r\\n\\t\\t\\t\\t// vertex\\r\\n\\r\\n\\t\\t\\t\\tp0 = func( u, v, p0 );\\r\\n\\t\\t\\t\\tvertices.push( p0.x, p0.y, p0.z );\\r\\n\\r\\n\\t\\t\\t\\t// normal\\r\\n\\r\\n\\t\\t\\t\\t// approximate tangent vectors via finite differences\\r\\n\\r\\n\\t\\t\\t\\tif ( u - EPS >= 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tp1 = func( u - EPS, v, p1 );\\r\\n\\t\\t\\t\\t\\tpu.subVectors( p0, p1 );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tp1 = func( u + EPS, v, p1 );\\r\\n\\t\\t\\t\\t\\tpu.subVectors( p1, p0 );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( v - EPS >= 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tp1 = func( u, v - EPS, p1 );\\r\\n\\t\\t\\t\\t\\tpv.subVectors( p0, p1 );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tp1 = func( u, v + EPS, p1 );\\r\\n\\t\\t\\t\\t\\tpv.subVectors( p1, p0 );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// cross product of tangent vectors returns surface normal\\r\\n\\r\\n\\t\\t\\t\\tnormal.crossVectors( pu, pv ).normalize();\\r\\n\\t\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\r\\n\\r\\n\\t\\t\\t\\t// uv\\r\\n\\r\\n\\t\\t\\t\\tuvs.push( u, v );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// generate indices\\r\\n\\r\\n\\t\\tfor ( i = 0; i < stacks; i ++ ) {\\r\\n\\r\\n\\t\\t\\tfor ( j = 0; j < slices; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar a = i * sliceCount + j;\\r\\n\\t\\t\\t\\tvar b = i * sliceCount + j + 1;\\r\\n\\t\\t\\t\\tvar c = ( i + 1 ) * sliceCount + j + 1;\\r\\n\\t\\t\\t\\tvar d = ( i + 1 ) * sliceCount + j;\\r\\n\\r\\n\\t\\t\\t\\t// faces one and two\\r\\n\\r\\n\\t\\t\\t\\tindices.push( a, b, d );\\r\\n\\t\\t\\t\\tindices.push( b, c, d );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// build geometry\\r\\n\\r\\n\\t\\tthis.setIndex( indices );\\r\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\r\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\n\\tParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author clockworkgeek / https://github.com/clockworkgeek\\r\\n\\t * @author timothypratley / https://github.com/timothypratley\\r\\n\\t * @author WestLangley / http://github.com/WestLangley\\r\\n\\t * @author Mugen87 / https://github.com/Mugen87\\r\\n\\t */\\r\\n\\r\\n\\t// PolyhedronGeometry\\r\\n\\r\\n\\tfunction PolyhedronGeometry( vertices, indices, radius, detail ) {\\r\\n\\r\\n\\t\\tGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'PolyhedronGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tvertices: vertices,\\r\\n\\t\\t\\tindices: indices,\\r\\n\\t\\t\\tradius: radius,\\r\\n\\t\\t\\tdetail: detail\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );\\r\\n\\t\\tthis.mergeVertices();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tPolyhedronGeometry.prototype = Object.create( Geometry.prototype );\\r\\n\\tPolyhedronGeometry.prototype.constructor = PolyhedronGeometry;\\r\\n\\r\\n\\t// PolyhedronBufferGeometry\\r\\n\\r\\n\\tfunction PolyhedronBufferGeometry( vertices, indices, radius, detail ) {\\r\\n\\r\\n\\t\\tBufferGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'PolyhedronBufferGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tvertices: vertices,\\r\\n\\t\\t\\tindices: indices,\\r\\n\\t\\t\\tradius: radius,\\r\\n\\t\\t\\tdetail: detail\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tradius = radius || 1;\\r\\n\\t\\tdetail = detail || 0;\\r\\n\\r\\n\\t\\t// default buffer data\\r\\n\\r\\n\\t\\tvar vertexBuffer = [];\\r\\n\\t\\tvar uvBuffer = [];\\r\\n\\r\\n\\t\\t// the subdivision creates the vertex buffer data\\r\\n\\r\\n\\t\\tsubdivide( detail );\\r\\n\\r\\n\\t\\t// all vertices should lie on a conceptual sphere with a given radius\\r\\n\\r\\n\\t\\tappplyRadius( radius );\\r\\n\\r\\n\\t\\t// finally, create the uv data\\r\\n\\r\\n\\t\\tgenerateUVs();\\r\\n\\r\\n\\t\\t// build non-indexed geometry\\r\\n\\r\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );\\r\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );\\r\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );\\r\\n\\r\\n\\t\\tif ( detail === 0 ) {\\r\\n\\r\\n\\t\\t\\tthis.computeVertexNormals(); // flat normals\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tthis.normalizeNormals(); // smooth normals\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// helper functions\\r\\n\\r\\n\\t\\tfunction subdivide( detail ) {\\r\\n\\r\\n\\t\\t\\tvar a = new Vector3();\\r\\n\\t\\t\\tvar b = new Vector3();\\r\\n\\t\\t\\tvar c = new Vector3();\\r\\n\\r\\n\\t\\t\\t// iterate over all faces and apply a subdivison with the given detail value\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < indices.length; i += 3 ) {\\r\\n\\r\\n\\t\\t\\t\\t// get the vertices of the face\\r\\n\\r\\n\\t\\t\\t\\tgetVertexByIndex( indices[ i + 0 ], a );\\r\\n\\t\\t\\t\\tgetVertexByIndex( indices[ i + 1 ], b );\\r\\n\\t\\t\\t\\tgetVertexByIndex( indices[ i + 2 ], c );\\r\\n\\r\\n\\t\\t\\t\\t// perform subdivision\\r\\n\\r\\n\\t\\t\\t\\tsubdivideFace( a, b, c, detail );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction subdivideFace( a, b, c, detail ) {\\r\\n\\r\\n\\t\\t\\tvar cols = Math.pow( 2, detail );\\r\\n\\r\\n\\t\\t\\t// we use this multidimensional array as a data structure for creating the subdivision\\r\\n\\r\\n\\t\\t\\tvar v = [];\\r\\n\\r\\n\\t\\t\\tvar i, j;\\r\\n\\r\\n\\t\\t\\t// construct all of the vertices for this subdivision\\r\\n\\r\\n\\t\\t\\tfor ( i = 0; i <= cols; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tv[ i ] = [];\\r\\n\\r\\n\\t\\t\\t\\tvar aj = a.clone().lerp( c, i / cols );\\r\\n\\t\\t\\t\\tvar bj = b.clone().lerp( c, i / cols );\\r\\n\\r\\n\\t\\t\\t\\tvar rows = cols - i;\\r\\n\\r\\n\\t\\t\\t\\tfor ( j = 0; j <= rows; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( j === 0 && i === cols ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tv[ i ][ j ] = aj;\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// construct all of the faces\\r\\n\\r\\n\\t\\t\\tfor ( i = 0; i < cols; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar k = Math.floor( j / 2 );\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( j % 2 === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tpushVertex( v[ i ][ k + 1 ] );\\r\\n\\t\\t\\t\\t\\t\\tpushVertex( v[ i + 1 ][ k ] );\\r\\n\\t\\t\\t\\t\\t\\tpushVertex( v[ i ][ k ] );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tpushVertex( v[ i ][ k + 1 ] );\\r\\n\\t\\t\\t\\t\\t\\tpushVertex( v[ i + 1 ][ k + 1 ] );\\r\\n\\t\\t\\t\\t\\t\\tpushVertex( v[ i + 1 ][ k ] );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction appplyRadius( radius ) {\\r\\n\\r\\n\\t\\t\\tvar vertex = new Vector3();\\r\\n\\r\\n\\t\\t\\t// iterate over the entire buffer and apply the radius to each vertex\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\\r\\n\\r\\n\\t\\t\\t\\tvertex.x = vertexBuffer[ i + 0 ];\\r\\n\\t\\t\\t\\tvertex.y = vertexBuffer[ i + 1 ];\\r\\n\\t\\t\\t\\tvertex.z = vertexBuffer[ i + 2 ];\\r\\n\\r\\n\\t\\t\\t\\tvertex.normalize().multiplyScalar( radius );\\r\\n\\r\\n\\t\\t\\t\\tvertexBuffer[ i + 0 ] = vertex.x;\\r\\n\\t\\t\\t\\tvertexBuffer[ i + 1 ] = vertex.y;\\r\\n\\t\\t\\t\\tvertexBuffer[ i + 2 ] = vertex.z;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction generateUVs() {\\r\\n\\r\\n\\t\\t\\tvar vertex = new Vector3();\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\\r\\n\\r\\n\\t\\t\\t\\tvertex.x = vertexBuffer[ i + 0 ];\\r\\n\\t\\t\\t\\tvertex.y = vertexBuffer[ i + 1 ];\\r\\n\\t\\t\\t\\tvertex.z = vertexBuffer[ i + 2 ];\\r\\n\\r\\n\\t\\t\\t\\tvar u = azimuth( vertex ) / 2 / Math.PI + 0.5;\\r\\n\\t\\t\\t\\tvar v = inclination( vertex ) / Math.PI + 0.5;\\r\\n\\t\\t\\t\\tuvBuffer.push( u, 1 - v );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tcorrectUVs();\\r\\n\\r\\n\\t\\t\\tcorrectSeam();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction correctSeam() {\\r\\n\\r\\n\\t\\t\\t// handle case when face straddles the seam, see #3269\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < uvBuffer.length; i += 6 ) {\\r\\n\\r\\n\\t\\t\\t\\t// uv data of a single face\\r\\n\\r\\n\\t\\t\\t\\tvar x0 = uvBuffer[ i + 0 ];\\r\\n\\t\\t\\t\\tvar x1 = uvBuffer[ i + 2 ];\\r\\n\\t\\t\\t\\tvar x2 = uvBuffer[ i + 4 ];\\r\\n\\r\\n\\t\\t\\t\\tvar max = Math.max( x0, x1, x2 );\\r\\n\\t\\t\\t\\tvar min = Math.min( x0, x1, x2 );\\r\\n\\r\\n\\t\\t\\t\\t// 0.9 is somewhat arbitrary\\r\\n\\r\\n\\t\\t\\t\\tif ( max > 0.9 && min < 0.1 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\\r\\n\\t\\t\\t\\t\\tif ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\\r\\n\\t\\t\\t\\t\\tif ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction pushVertex( vertex ) {\\r\\n\\r\\n\\t\\t\\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction getVertexByIndex( index, vertex ) {\\r\\n\\r\\n\\t\\t\\tvar stride = index * 3;\\r\\n\\r\\n\\t\\t\\tvertex.x = vertices[ stride + 0 ];\\r\\n\\t\\t\\tvertex.y = vertices[ stride + 1 ];\\r\\n\\t\\t\\tvertex.z = vertices[ stride + 2 ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction correctUVs() {\\r\\n\\r\\n\\t\\t\\tvar a = new Vector3();\\r\\n\\t\\t\\tvar b = new Vector3();\\r\\n\\t\\t\\tvar c = new Vector3();\\r\\n\\r\\n\\t\\t\\tvar centroid = new Vector3();\\r\\n\\r\\n\\t\\t\\tvar uvA = new Vector2();\\r\\n\\t\\t\\tvar uvB = new Vector2();\\r\\n\\t\\t\\tvar uvC = new Vector2();\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\\r\\n\\r\\n\\t\\t\\t\\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\\r\\n\\t\\t\\t\\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\\r\\n\\t\\t\\t\\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\\r\\n\\r\\n\\t\\t\\t\\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\\r\\n\\t\\t\\t\\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\\r\\n\\t\\t\\t\\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\\r\\n\\r\\n\\t\\t\\t\\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\\r\\n\\r\\n\\t\\t\\t\\tvar azi = azimuth( centroid );\\r\\n\\r\\n\\t\\t\\t\\tcorrectUV( uvA, j + 0, a, azi );\\r\\n\\t\\t\\t\\tcorrectUV( uvB, j + 2, b, azi );\\r\\n\\t\\t\\t\\tcorrectUV( uvC, j + 4, c, azi );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction correctUV( uv, stride, vector, azimuth ) {\\r\\n\\r\\n\\t\\t\\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\\r\\n\\r\\n\\t\\t\\t\\tuvBuffer[ stride ] = uv.x - 1;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\\r\\n\\r\\n\\t\\t\\t\\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Angle around the Y axis, counter-clockwise when looking from above.\\r\\n\\r\\n\\t\\tfunction azimuth( vector ) {\\r\\n\\r\\n\\t\\t\\treturn Math.atan2( vector.z, - vector.x );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\t// Angle above the XZ plane.\\r\\n\\r\\n\\t\\tfunction inclination( vector ) {\\r\\n\\r\\n\\t\\t\\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tPolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\n\\tPolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author timothypratley / https://github.com/timothypratley\\r\\n\\t * @author Mugen87 / https://github.com/Mugen87\\r\\n\\t */\\r\\n\\r\\n\\t// TetrahedronGeometry\\r\\n\\r\\n\\tfunction TetrahedronGeometry( radius, detail ) {\\r\\n\\r\\n\\t\\tGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'TetrahedronGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tradius: radius,\\r\\n\\t\\t\\tdetail: detail\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );\\r\\n\\t\\tthis.mergeVertices();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tTetrahedronGeometry.prototype = Object.create( Geometry.prototype );\\r\\n\\tTetrahedronGeometry.prototype.constructor = TetrahedronGeometry;\\r\\n\\r\\n\\t// TetrahedronBufferGeometry\\r\\n\\r\\n\\tfunction TetrahedronBufferGeometry( radius, detail ) {\\r\\n\\r\\n\\t\\tvar vertices = [\\r\\n\\t\\t\\t1, 1, 1, \\t- 1, - 1, 1, \\t- 1, 1, - 1, \\t1, - 1, - 1\\r\\n\\t\\t];\\r\\n\\r\\n\\t\\tvar indices = [\\r\\n\\t\\t\\t2, 1, 0, \\t0, 3, 2,\\t1, 3, 0,\\t2, 3, 1\\r\\n\\t\\t];\\r\\n\\r\\n\\t\\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\\r\\n\\r\\n\\t\\tthis.type = 'TetrahedronBufferGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tradius: radius,\\r\\n\\t\\t\\tdetail: detail\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tTetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\\r\\n\\tTetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author timothypratley / https://github.com/timothypratley\\r\\n\\t * @author Mugen87 / https://github.com/Mugen87\\r\\n\\t */\\r\\n\\r\\n\\t// OctahedronGeometry\\r\\n\\r\\n\\tfunction OctahedronGeometry( radius, detail ) {\\r\\n\\r\\n\\t\\tGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'OctahedronGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tradius: radius,\\r\\n\\t\\t\\tdetail: detail\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );\\r\\n\\t\\tthis.mergeVertices();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tOctahedronGeometry.prototype = Object.create( Geometry.prototype );\\r\\n\\tOctahedronGeometry.prototype.constructor = OctahedronGeometry;\\r\\n\\r\\n\\t// OctahedronBufferGeometry\\r\\n\\r\\n\\tfunction OctahedronBufferGeometry( radius, detail ) {\\r\\n\\r\\n\\t\\tvar vertices = [\\r\\n\\t\\t\\t1, 0, 0, \\t- 1, 0, 0,\\t0, 1, 0,\\r\\n\\t\\t\\t0, - 1, 0, \\t0, 0, 1,\\t0, 0, - 1\\r\\n\\t\\t];\\r\\n\\r\\n\\t\\tvar indices = [\\r\\n\\t\\t\\t0, 2, 4,\\t0, 4, 3,\\t0, 3, 5,\\r\\n\\t\\t\\t0, 5, 2,\\t1, 2, 5,\\t1, 5, 3,\\r\\n\\t\\t\\t1, 3, 4,\\t1, 4, 2\\r\\n\\t\\t];\\r\\n\\r\\n\\t\\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\\r\\n\\r\\n\\t\\tthis.type = 'OctahedronBufferGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tradius: radius,\\r\\n\\t\\t\\tdetail: detail\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tOctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\\r\\n\\tOctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author timothypratley / https://github.com/timothypratley\\r\\n\\t * @author Mugen87 / https://github.com/Mugen87\\r\\n\\t */\\r\\n\\r\\n\\t// IcosahedronGeometry\\r\\n\\r\\n\\tfunction IcosahedronGeometry( radius, detail ) {\\r\\n\\r\\n\\t\\tGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'IcosahedronGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tradius: radius,\\r\\n\\t\\t\\tdetail: detail\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );\\r\\n\\t\\tthis.mergeVertices();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tIcosahedronGeometry.prototype = Object.create( Geometry.prototype );\\r\\n\\tIcosahedronGeometry.prototype.constructor = IcosahedronGeometry;\\r\\n\\r\\n\\t// IcosahedronBufferGeometry\\r\\n\\r\\n\\tfunction IcosahedronBufferGeometry( radius, detail ) {\\r\\n\\r\\n\\t\\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\\r\\n\\r\\n\\t\\tvar vertices = [\\r\\n\\t\\t\\t- 1, t, 0, \\t1, t, 0, \\t- 1, - t, 0, \\t1, - t, 0,\\r\\n\\t\\t\\t 0, - 1, t, \\t0, 1, t,\\t0, - 1, - t, \\t0, 1, - t,\\r\\n\\t\\t\\t t, 0, - 1, \\tt, 0, 1, \\t- t, 0, - 1, \\t- t, 0, 1\\r\\n\\t\\t];\\r\\n\\r\\n\\t\\tvar indices = [\\r\\n\\t\\t\\t 0, 11, 5, \\t0, 5, 1, \\t0, 1, 7, \\t0, 7, 10, \\t0, 10, 11,\\r\\n\\t\\t\\t 1, 5, 9, \\t5, 11, 4,\\t11, 10, 2,\\t10, 7, 6,\\t7, 1, 8,\\r\\n\\t\\t\\t 3, 9, 4, \\t3, 4, 2,\\t3, 2, 6,\\t3, 6, 8,\\t3, 8, 9,\\r\\n\\t\\t\\t 4, 9, 5, \\t2, 4, 11,\\t6, 2, 10,\\t8, 6, 7,\\t9, 8, 1\\r\\n\\t\\t];\\r\\n\\r\\n\\t\\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\\r\\n\\r\\n\\t\\tthis.type = 'IcosahedronBufferGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tradius: radius,\\r\\n\\t\\t\\tdetail: detail\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tIcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\\r\\n\\tIcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author Abe Pazos / https://hamoid.com\\r\\n\\t * @author Mugen87 / https://github.com/Mugen87\\r\\n\\t */\\r\\n\\r\\n\\t// DodecahedronGeometry\\r\\n\\r\\n\\tfunction DodecahedronGeometry( radius, detail ) {\\r\\n\\r\\n\\t\\tGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'DodecahedronGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tradius: radius,\\r\\n\\t\\t\\tdetail: detail\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );\\r\\n\\t\\tthis.mergeVertices();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tDodecahedronGeometry.prototype = Object.create( Geometry.prototype );\\r\\n\\tDodecahedronGeometry.prototype.constructor = DodecahedronGeometry;\\r\\n\\r\\n\\t// DodecahedronBufferGeometry\\r\\n\\r\\n\\tfunction DodecahedronBufferGeometry( radius, detail ) {\\r\\n\\r\\n\\t\\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\\r\\n\\t\\tvar r = 1 / t;\\r\\n\\r\\n\\t\\tvar vertices = [\\r\\n\\r\\n\\t\\t\\t// (1, 1, 1)\\r\\n\\t\\t\\t- 1, - 1, - 1,\\t- 1, - 1, 1,\\r\\n\\t\\t\\t- 1, 1, - 1, - 1, 1, 1,\\r\\n\\t\\t\\t1, - 1, - 1, 1, - 1, 1,\\r\\n\\t\\t\\t1, 1, - 1, 1, 1, 1,\\r\\n\\r\\n\\t\\t\\t// (0, 1/, )\\r\\n\\t\\t\\t 0, - r, - t, 0, - r, t,\\r\\n\\t\\t\\t 0, r, - t, 0, r, t,\\r\\n\\r\\n\\t\\t\\t// (1/, , 0)\\r\\n\\t\\t\\t- r, - t, 0, - r, t, 0,\\r\\n\\t\\t\\t r, - t, 0, r, t, 0,\\r\\n\\r\\n\\t\\t\\t// (, 0, 1/)\\r\\n\\t\\t\\t- t, 0, - r, t, 0, - r,\\r\\n\\t\\t\\t- t, 0, r, t, 0, r\\r\\n\\t\\t];\\r\\n\\r\\n\\t\\tvar indices = [\\r\\n\\t\\t\\t3, 11, 7, \\t3, 7, 15, \\t3, 15, 13,\\r\\n\\t\\t\\t7, 19, 17, \\t7, 17, 6, \\t7, 6, 15,\\r\\n\\t\\t\\t17, 4, 8, \\t17, 8, 10, \\t17, 10, 6,\\r\\n\\t\\t\\t8, 0, 16, \\t8, 16, 2, \\t8, 2, 10,\\r\\n\\t\\t\\t0, 12, 1, \\t0, 1, 18, \\t0, 18, 16,\\r\\n\\t\\t\\t6, 10, 2, \\t6, 2, 13, \\t6, 13, 15,\\r\\n\\t\\t\\t2, 16, 18, \\t2, 18, 3, \\t2, 3, 13,\\r\\n\\t\\t\\t18, 1, 9, \\t18, 9, 11, \\t18, 11, 3,\\r\\n\\t\\t\\t4, 14, 12, \\t4, 12, 0, \\t4, 0, 8,\\r\\n\\t\\t\\t11, 9, 5, \\t11, 5, 19, \\t11, 19, 7,\\r\\n\\t\\t\\t19, 5, 14, \\t19, 14, 4, \\t19, 4, 17,\\r\\n\\t\\t\\t1, 12, 14, \\t1, 14, 5, \\t1, 5, 9\\r\\n\\t\\t];\\r\\n\\r\\n\\t\\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\\r\\n\\r\\n\\t\\tthis.type = 'DodecahedronBufferGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tradius: radius,\\r\\n\\t\\t\\tdetail: detail\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tDodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\\r\\n\\tDodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author oosmoxiecode / https://github.com/oosmoxiecode\\r\\n\\t * @author WestLangley / https://github.com/WestLangley\\r\\n\\t * @author zz85 / https://github.com/zz85\\r\\n\\t * @author miningold / https://github.com/miningold\\r\\n\\t * @author jonobr1 / https://github.com/jonobr1\\r\\n\\t * @author Mugen87 / https://github.com/Mugen87\\r\\n\\t *\\r\\n\\t */\\r\\n\\r\\n\\t// TubeGeometry\\r\\n\\r\\n\\tfunction TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {\\r\\n\\r\\n\\t\\tGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'TubeGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tpath: path,\\r\\n\\t\\t\\ttubularSegments: tubularSegments,\\r\\n\\t\\t\\tradius: radius,\\r\\n\\t\\t\\tradialSegments: radialSegments,\\r\\n\\t\\t\\tclosed: closed\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tif ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );\\r\\n\\r\\n\\t\\tvar bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );\\r\\n\\r\\n\\t\\t// expose internals\\r\\n\\r\\n\\t\\tthis.tangents = bufferGeometry.tangents;\\r\\n\\t\\tthis.normals = bufferGeometry.normals;\\r\\n\\t\\tthis.binormals = bufferGeometry.binormals;\\r\\n\\r\\n\\t\\t// create geometry\\r\\n\\r\\n\\t\\tthis.fromBufferGeometry( bufferGeometry );\\r\\n\\t\\tthis.mergeVertices();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tTubeGeometry.prototype = Object.create( Geometry.prototype );\\r\\n\\tTubeGeometry.prototype.constructor = TubeGeometry;\\r\\n\\r\\n\\t// TubeBufferGeometry\\r\\n\\r\\n\\tfunction TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {\\r\\n\\r\\n\\t\\tBufferGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'TubeBufferGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tpath: path,\\r\\n\\t\\t\\ttubularSegments: tubularSegments,\\r\\n\\t\\t\\tradius: radius,\\r\\n\\t\\t\\tradialSegments: radialSegments,\\r\\n\\t\\t\\tclosed: closed\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\ttubularSegments = tubularSegments || 64;\\r\\n\\t\\tradius = radius || 1;\\r\\n\\t\\tradialSegments = radialSegments || 8;\\r\\n\\t\\tclosed = closed || false;\\r\\n\\r\\n\\t\\tvar frames = path.computeFrenetFrames( tubularSegments, closed );\\r\\n\\r\\n\\t\\t// expose internals\\r\\n\\r\\n\\t\\tthis.tangents = frames.tangents;\\r\\n\\t\\tthis.normals = frames.normals;\\r\\n\\t\\tthis.binormals = frames.binormals;\\r\\n\\r\\n\\t\\t// helper variables\\r\\n\\r\\n\\t\\tvar vertex = new Vector3();\\r\\n\\t\\tvar normal = new Vector3();\\r\\n\\t\\tvar uv = new Vector2();\\r\\n\\t\\tvar P = new Vector3();\\r\\n\\r\\n\\t\\tvar i, j;\\r\\n\\r\\n\\t\\t// buffer\\r\\n\\r\\n\\t\\tvar vertices = [];\\r\\n\\t\\tvar normals = [];\\r\\n\\t\\tvar uvs = [];\\r\\n\\t\\tvar indices = [];\\r\\n\\r\\n\\t\\t// create buffer data\\r\\n\\r\\n\\t\\tgenerateBufferData();\\r\\n\\r\\n\\t\\t// build geometry\\r\\n\\r\\n\\t\\tthis.setIndex( indices );\\r\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\r\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\r\\n\\r\\n\\t\\t// functions\\r\\n\\r\\n\\t\\tfunction generateBufferData() {\\r\\n\\r\\n\\t\\t\\tfor ( i = 0; i < tubularSegments; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tgenerateSegment( i );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// if the geometry is not closed, generate the last row of vertices and normals\\r\\n\\t\\t\\t// at the regular position on the given path\\r\\n\\t\\t\\t//\\r\\n\\t\\t\\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\\r\\n\\r\\n\\t\\t\\tgenerateSegment( ( closed === false ) ? tubularSegments : 0 );\\r\\n\\r\\n\\t\\t\\t// uvs are generated in a separate function.\\r\\n\\t\\t\\t// this makes it easy compute correct values for closed geometries\\r\\n\\r\\n\\t\\t\\tgenerateUVs();\\r\\n\\r\\n\\t\\t\\t// finally create faces\\r\\n\\r\\n\\t\\t\\tgenerateIndices();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction generateSegment( i ) {\\r\\n\\r\\n\\t\\t\\t// we use getPointAt to sample evenly distributed points from the given path\\r\\n\\r\\n\\t\\t\\tP = path.getPointAt( i / tubularSegments, P );\\r\\n\\r\\n\\t\\t\\t// retrieve corresponding normal and binormal\\r\\n\\r\\n\\t\\t\\tvar N = frames.normals[ i ];\\r\\n\\t\\t\\tvar B = frames.binormals[ i ];\\r\\n\\r\\n\\t\\t\\t// generate normals and vertices for the current segment\\r\\n\\r\\n\\t\\t\\tfor ( j = 0; j <= radialSegments; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar v = j / radialSegments * Math.PI * 2;\\r\\n\\r\\n\\t\\t\\t\\tvar sin = Math.sin( v );\\r\\n\\t\\t\\t\\tvar cos = - Math.cos( v );\\r\\n\\r\\n\\t\\t\\t\\t// normal\\r\\n\\r\\n\\t\\t\\t\\tnormal.x = ( cos * N.x + sin * B.x );\\r\\n\\t\\t\\t\\tnormal.y = ( cos * N.y + sin * B.y );\\r\\n\\t\\t\\t\\tnormal.z = ( cos * N.z + sin * B.z );\\r\\n\\t\\t\\t\\tnormal.normalize();\\r\\n\\r\\n\\t\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\r\\n\\r\\n\\t\\t\\t\\t// vertex\\r\\n\\r\\n\\t\\t\\t\\tvertex.x = P.x + radius * normal.x;\\r\\n\\t\\t\\t\\tvertex.y = P.y + radius * normal.y;\\r\\n\\t\\t\\t\\tvertex.z = P.z + radius * normal.z;\\r\\n\\r\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction generateIndices() {\\r\\n\\r\\n\\t\\t\\tfor ( j = 1; j <= tubularSegments; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( i = 1; i <= radialSegments; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\\r\\n\\t\\t\\t\\t\\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\\r\\n\\t\\t\\t\\t\\tvar c = ( radialSegments + 1 ) * j + i;\\r\\n\\t\\t\\t\\t\\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\\r\\n\\r\\n\\t\\t\\t\\t\\t// faces\\r\\n\\r\\n\\t\\t\\t\\t\\tindices.push( a, b, d );\\r\\n\\t\\t\\t\\t\\tindices.push( b, c, d );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction generateUVs() {\\r\\n\\r\\n\\t\\t\\tfor ( i = 0; i <= tubularSegments; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( j = 0; j <= radialSegments; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tuv.x = i / tubularSegments;\\r\\n\\t\\t\\t\\t\\tuv.y = j / radialSegments;\\r\\n\\r\\n\\t\\t\\t\\t\\tuvs.push( uv.x, uv.y );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tTubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\n\\tTubeBufferGeometry.prototype.constructor = TubeBufferGeometry;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author oosmoxiecode\\r\\n\\t * @author Mugen87 / https://github.com/Mugen87\\r\\n\\t *\\r\\n\\t * based on http://www.blackpawn.com/texts/pqtorus/\\r\\n\\t */\\r\\n\\r\\n\\t// TorusKnotGeometry\\r\\n\\r\\n\\tfunction TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\\r\\n\\r\\n\\t\\tGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'TorusKnotGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tradius: radius,\\r\\n\\t\\t\\ttube: tube,\\r\\n\\t\\t\\ttubularSegments: tubularSegments,\\r\\n\\t\\t\\tradialSegments: radialSegments,\\r\\n\\t\\t\\tp: p,\\r\\n\\t\\t\\tq: q\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tif ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\\r\\n\\r\\n\\t\\tthis.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\\r\\n\\t\\tthis.mergeVertices();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tTorusKnotGeometry.prototype = Object.create( Geometry.prototype );\\r\\n\\tTorusKnotGeometry.prototype.constructor = TorusKnotGeometry;\\r\\n\\r\\n\\t// TorusKnotBufferGeometry\\r\\n\\r\\n\\tfunction TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {\\r\\n\\r\\n\\t\\tBufferGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'TorusKnotBufferGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tradius: radius,\\r\\n\\t\\t\\ttube: tube,\\r\\n\\t\\t\\ttubularSegments: tubularSegments,\\r\\n\\t\\t\\tradialSegments: radialSegments,\\r\\n\\t\\t\\tp: p,\\r\\n\\t\\t\\tq: q\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tradius = radius || 1;\\r\\n\\t\\ttube = tube || 0.4;\\r\\n\\t\\ttubularSegments = Math.floor( tubularSegments ) || 64;\\r\\n\\t\\tradialSegments = Math.floor( radialSegments ) || 8;\\r\\n\\t\\tp = p || 2;\\r\\n\\t\\tq = q || 3;\\r\\n\\r\\n\\t\\t// buffers\\r\\n\\r\\n\\t\\tvar indices = [];\\r\\n\\t\\tvar vertices = [];\\r\\n\\t\\tvar normals = [];\\r\\n\\t\\tvar uvs = [];\\r\\n\\r\\n\\t\\t// helper variables\\r\\n\\r\\n\\t\\tvar i, j;\\r\\n\\r\\n\\t\\tvar vertex = new Vector3();\\r\\n\\t\\tvar normal = new Vector3();\\r\\n\\r\\n\\t\\tvar P1 = new Vector3();\\r\\n\\t\\tvar P2 = new Vector3();\\r\\n\\r\\n\\t\\tvar B = new Vector3();\\r\\n\\t\\tvar T = new Vector3();\\r\\n\\t\\tvar N = new Vector3();\\r\\n\\r\\n\\t\\t// generate vertices, normals and uvs\\r\\n\\r\\n\\t\\tfor ( i = 0; i <= tubularSegments; ++ i ) {\\r\\n\\r\\n\\t\\t\\t// the radian \\\"u\\\" is used to calculate the position on the torus curve of the current tubular segement\\r\\n\\r\\n\\t\\t\\tvar u = i / tubularSegments * p * Math.PI * 2;\\r\\n\\r\\n\\t\\t\\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\\r\\n\\t\\t\\t// these points are used to create a special \\\"coordinate space\\\", which is necessary to calculate the correct vertex positions\\r\\n\\r\\n\\t\\t\\tcalculatePositionOnCurve( u, p, q, radius, P1 );\\r\\n\\t\\t\\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\\r\\n\\r\\n\\t\\t\\t// calculate orthonormal basis\\r\\n\\r\\n\\t\\t\\tT.subVectors( P2, P1 );\\r\\n\\t\\t\\tN.addVectors( P2, P1 );\\r\\n\\t\\t\\tB.crossVectors( T, N );\\r\\n\\t\\t\\tN.crossVectors( B, T );\\r\\n\\r\\n\\t\\t\\t// normalize B, N. T can be ignored, we don't use it\\r\\n\\r\\n\\t\\t\\tB.normalize();\\r\\n\\t\\t\\tN.normalize();\\r\\n\\r\\n\\t\\t\\tfor ( j = 0; j <= radialSegments; ++ j ) {\\r\\n\\r\\n\\t\\t\\t\\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\\r\\n\\t\\t\\t\\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\\r\\n\\r\\n\\t\\t\\t\\tvar v = j / radialSegments * Math.PI * 2;\\r\\n\\t\\t\\t\\tvar cx = - tube * Math.cos( v );\\r\\n\\t\\t\\t\\tvar cy = tube * Math.sin( v );\\r\\n\\r\\n\\t\\t\\t\\t// now calculate the final vertex position.\\r\\n\\t\\t\\t\\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\\r\\n\\r\\n\\t\\t\\t\\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\\r\\n\\t\\t\\t\\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\\r\\n\\t\\t\\t\\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\\r\\n\\r\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\t\\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\\r\\n\\r\\n\\t\\t\\t\\tnormal.subVectors( vertex, P1 ).normalize();\\r\\n\\r\\n\\t\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\r\\n\\r\\n\\t\\t\\t\\t// uv\\r\\n\\r\\n\\t\\t\\t\\tuvs.push( i / tubularSegments );\\r\\n\\t\\t\\t\\tuvs.push( j / radialSegments );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// generate indices\\r\\n\\r\\n\\t\\tfor ( j = 1; j <= tubularSegments; j ++ ) {\\r\\n\\r\\n\\t\\t\\tfor ( i = 1; i <= radialSegments; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t// indices\\r\\n\\r\\n\\t\\t\\t\\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\\r\\n\\t\\t\\t\\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\\r\\n\\t\\t\\t\\tvar c = ( radialSegments + 1 ) * j + i;\\r\\n\\t\\t\\t\\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\\r\\n\\r\\n\\t\\t\\t\\t// faces\\r\\n\\r\\n\\t\\t\\t\\tindices.push( a, b, d );\\r\\n\\t\\t\\t\\tindices.push( b, c, d );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// build geometry\\r\\n\\r\\n\\t\\tthis.setIndex( indices );\\r\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\r\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\r\\n\\r\\n\\t\\t// this function calculates the current position on the torus curve\\r\\n\\r\\n\\t\\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\\r\\n\\r\\n\\t\\t\\tvar cu = Math.cos( u );\\r\\n\\t\\t\\tvar su = Math.sin( u );\\r\\n\\t\\t\\tvar quOverP = q / p * u;\\r\\n\\t\\t\\tvar cs = Math.cos( quOverP );\\r\\n\\r\\n\\t\\t\\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\\r\\n\\t\\t\\tposition.y = radius * ( 2 + cs ) * su * 0.5;\\r\\n\\t\\t\\tposition.z = radius * Math.sin( quOverP ) * 0.5;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tTorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\n\\tTorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author oosmoxiecode\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author Mugen87 / https://github.com/Mugen87\\r\\n\\t */\\r\\n\\r\\n\\t// TorusGeometry\\r\\n\\r\\n\\tfunction TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\\r\\n\\r\\n\\t\\tGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'TorusGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tradius: radius,\\r\\n\\t\\t\\ttube: tube,\\r\\n\\t\\t\\tradialSegments: radialSegments,\\r\\n\\t\\t\\ttubularSegments: tubularSegments,\\r\\n\\t\\t\\tarc: arc\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\\r\\n\\t\\tthis.mergeVertices();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tTorusGeometry.prototype = Object.create( Geometry.prototype );\\r\\n\\tTorusGeometry.prototype.constructor = TorusGeometry;\\r\\n\\r\\n\\t// TorusBufferGeometry\\r\\n\\r\\n\\tfunction TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\\r\\n\\r\\n\\t\\tBufferGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'TorusBufferGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tradius: radius,\\r\\n\\t\\t\\ttube: tube,\\r\\n\\t\\t\\tradialSegments: radialSegments,\\r\\n\\t\\t\\ttubularSegments: tubularSegments,\\r\\n\\t\\t\\tarc: arc\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tradius = radius || 1;\\r\\n\\t\\ttube = tube || 0.4;\\r\\n\\t\\tradialSegments = Math.floor( radialSegments ) || 8;\\r\\n\\t\\ttubularSegments = Math.floor( tubularSegments ) || 6;\\r\\n\\t\\tarc = arc || Math.PI * 2;\\r\\n\\r\\n\\t\\t// buffers\\r\\n\\r\\n\\t\\tvar indices = [];\\r\\n\\t\\tvar vertices = [];\\r\\n\\t\\tvar normals = [];\\r\\n\\t\\tvar uvs = [];\\r\\n\\r\\n\\t\\t// helper variables\\r\\n\\r\\n\\t\\tvar center = new Vector3();\\r\\n\\t\\tvar vertex = new Vector3();\\r\\n\\t\\tvar normal = new Vector3();\\r\\n\\r\\n\\t\\tvar j, i;\\r\\n\\r\\n\\t\\t// generate vertices, normals and uvs\\r\\n\\r\\n\\t\\tfor ( j = 0; j <= radialSegments; j ++ ) {\\r\\n\\r\\n\\t\\t\\tfor ( i = 0; i <= tubularSegments; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar u = i / tubularSegments * arc;\\r\\n\\t\\t\\t\\tvar v = j / radialSegments * Math.PI * 2;\\r\\n\\r\\n\\t\\t\\t\\t// vertex\\r\\n\\r\\n\\t\\t\\t\\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\\r\\n\\t\\t\\t\\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\\r\\n\\t\\t\\t\\tvertex.z = tube * Math.sin( v );\\r\\n\\r\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\t\\t// normal\\r\\n\\r\\n\\t\\t\\t\\tcenter.x = radius * Math.cos( u );\\r\\n\\t\\t\\t\\tcenter.y = radius * Math.sin( u );\\r\\n\\t\\t\\t\\tnormal.subVectors( vertex, center ).normalize();\\r\\n\\r\\n\\t\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\r\\n\\r\\n\\t\\t\\t\\t// uv\\r\\n\\r\\n\\t\\t\\t\\tuvs.push( i / tubularSegments );\\r\\n\\t\\t\\t\\tuvs.push( j / radialSegments );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// generate indices\\r\\n\\r\\n\\t\\tfor ( j = 1; j <= radialSegments; j ++ ) {\\r\\n\\r\\n\\t\\t\\tfor ( i = 1; i <= tubularSegments; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t// indices\\r\\n\\r\\n\\t\\t\\t\\tvar a = ( tubularSegments + 1 ) * j + i - 1;\\r\\n\\t\\t\\t\\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\\r\\n\\t\\t\\t\\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\\r\\n\\t\\t\\t\\tvar d = ( tubularSegments + 1 ) * j + i;\\r\\n\\r\\n\\t\\t\\t\\t// faces\\r\\n\\r\\n\\t\\t\\t\\tindices.push( a, b, d );\\r\\n\\t\\t\\t\\tindices.push( b, c, d );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// build geometry\\r\\n\\r\\n\\t\\tthis.setIndex( indices );\\r\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\r\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tTorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\n\\tTorusBufferGeometry.prototype.constructor = TorusBufferGeometry;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author Mugen87 / https://github.com/Mugen87\\r\\n\\t * Port from https://github.com/mapbox/earcut (v2.1.2)\\r\\n\\t */\\r\\n\\r\\n\\tvar Earcut = {\\r\\n\\r\\n\\t\\ttriangulate: function ( data, holeIndices, dim ) {\\r\\n\\r\\n\\t\\t\\tdim = dim || 2;\\r\\n\\r\\n\\t\\t\\tvar hasHoles = holeIndices && holeIndices.length,\\r\\n\\t\\t\\t\\touterLen = hasHoles ? holeIndices[ 0 ] * dim : data.length,\\r\\n\\t\\t\\t\\touterNode = linkedList( data, 0, outerLen, dim, true ),\\r\\n\\t\\t\\t\\ttriangles = [];\\r\\n\\r\\n\\t\\t\\tif ( ! outerNode ) return triangles;\\r\\n\\r\\n\\t\\t\\tvar minX, minY, maxX, maxY, x, y, invSize;\\r\\n\\r\\n\\t\\t\\tif ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );\\r\\n\\r\\n\\t\\t\\t// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\\r\\n\\r\\n\\t\\t\\tif ( data.length > 80 * dim ) {\\r\\n\\r\\n\\t\\t\\t\\tminX = maxX = data[ 0 ];\\r\\n\\t\\t\\t\\tminY = maxY = data[ 1 ];\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = dim; i < outerLen; i += dim ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tx = data[ i ];\\r\\n\\t\\t\\t\\t\\ty = data[ i + 1 ];\\r\\n\\t\\t\\t\\t\\tif ( x < minX ) minX = x;\\r\\n\\t\\t\\t\\t\\tif ( y < minY ) minY = y;\\r\\n\\t\\t\\t\\t\\tif ( x > maxX ) maxX = x;\\r\\n\\t\\t\\t\\t\\tif ( y > maxY ) maxY = y;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// minX, minY and invSize are later used to transform coords into integers for z-order calculation\\r\\n\\r\\n\\t\\t\\t\\tinvSize = Math.max( maxX - minX, maxY - minY );\\r\\n\\t\\t\\t\\tinvSize = invSize !== 0 ? 1 / invSize : 0;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tearcutLinked( outerNode, triangles, dim, minX, minY, invSize );\\r\\n\\r\\n\\t\\t\\treturn triangles;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t// create a circular doubly linked list from polygon points in the specified winding order\\r\\n\\r\\n\\tfunction linkedList( data, start, end, dim, clockwise ) {\\r\\n\\r\\n\\t\\tvar i, last;\\r\\n\\r\\n\\t\\tif ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {\\r\\n\\r\\n\\t\\t\\tfor ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tfor ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( last && equals( last, last.next ) ) {\\r\\n\\r\\n\\t\\t\\tremoveNode( last );\\r\\n\\t\\t\\tlast = last.next;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn last;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// eliminate colinear or duplicate points\\r\\n\\r\\n\\tfunction filterPoints( start, end ) {\\r\\n\\r\\n\\t\\tif ( ! start ) return start;\\r\\n\\t\\tif ( ! end ) end = start;\\r\\n\\r\\n\\t\\tvar p = start, again;\\r\\n\\r\\n\\t\\tdo {\\r\\n\\r\\n\\t\\t\\tagain = false;\\r\\n\\r\\n\\t\\t\\tif ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {\\r\\n\\r\\n\\t\\t\\t\\tremoveNode( p );\\r\\n\\t\\t\\t\\tp = end = p.prev;\\r\\n\\t\\t\\t\\tif ( p === p.next ) break;\\r\\n\\t\\t\\t\\tagain = true;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tp = p.next;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} while ( again || p !== end );\\r\\n\\r\\n\\t\\treturn end;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// main ear slicing loop which triangulates a polygon (given as a linked list)\\r\\n\\r\\n\\tfunction earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {\\r\\n\\r\\n\\t\\tif ( ! ear ) return;\\r\\n\\r\\n\\t\\t// interlink polygon nodes in z-order\\r\\n\\r\\n\\t\\tif ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );\\r\\n\\r\\n\\t\\tvar stop = ear, prev, next;\\r\\n\\r\\n\\t\\t// iterate through ears, slicing them one by one\\r\\n\\r\\n\\t\\twhile ( ear.prev !== ear.next ) {\\r\\n\\r\\n\\t\\t\\tprev = ear.prev;\\r\\n\\t\\t\\tnext = ear.next;\\r\\n\\r\\n\\t\\t\\tif ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {\\r\\n\\r\\n\\t\\t\\t\\t// cut off the triangle\\r\\n\\t\\t\\t\\ttriangles.push( prev.i / dim );\\r\\n\\t\\t\\t\\ttriangles.push( ear.i / dim );\\r\\n\\t\\t\\t\\ttriangles.push( next.i / dim );\\r\\n\\r\\n\\t\\t\\t\\tremoveNode( ear );\\r\\n\\r\\n\\t\\t\\t\\t// skipping the next vertice leads to less sliver triangles\\r\\n\\t\\t\\t\\tear = next.next;\\r\\n\\t\\t\\t\\tstop = next.next;\\r\\n\\r\\n\\t\\t\\t\\tcontinue;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tear = next;\\r\\n\\r\\n\\t\\t\\t// if we looped through the whole remaining polygon and can't find any more ears\\r\\n\\r\\n\\t\\t\\tif ( ear === stop ) {\\r\\n\\r\\n\\t\\t\\t\\t// try filtering points and slicing again\\r\\n\\r\\n\\t\\t\\t\\tif ( ! pass ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tearcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );\\r\\n\\r\\n\\t\\t\\t\\t\\t// if this didn't work, try curing all small self-intersections locally\\r\\n\\r\\n\\t\\t\\t\\t} else if ( pass === 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tear = cureLocalIntersections( ear, triangles, dim );\\r\\n\\t\\t\\t\\t\\tearcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );\\r\\n\\r\\n\\t\\t\\t\\t// as a last resort, try splitting the remaining polygon into two\\r\\n\\r\\n\\t\\t\\t\\t} else if ( pass === 2 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tsplitEarcut( ear, triangles, dim, minX, minY, invSize );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// check whether a polygon node forms a valid ear with adjacent nodes\\r\\n\\r\\n\\tfunction isEar( ear ) {\\r\\n\\r\\n\\t\\tvar a = ear.prev,\\r\\n\\t\\t\\tb = ear,\\r\\n\\t\\t\\tc = ear.next;\\r\\n\\r\\n\\t\\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\\r\\n\\r\\n\\t\\t// now make sure we don't have other points inside the potential ear\\r\\n\\t\\tvar p = ear.next.next;\\r\\n\\r\\n\\t\\twhile ( p !== ear.prev ) {\\r\\n\\r\\n\\t\\t\\tif ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) {\\r\\n\\r\\n\\t\\t\\t\\treturn false;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tp = p.next;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn true;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction isEarHashed( ear, minX, minY, invSize ) {\\r\\n\\r\\n\\t\\tvar a = ear.prev,\\r\\n\\t\\t\\tb = ear,\\r\\n\\t\\t\\tc = ear.next;\\r\\n\\r\\n\\t\\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\\r\\n\\r\\n\\t\\t// triangle bbox; min & max are calculated like this for speed\\r\\n\\r\\n\\t\\tvar minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),\\r\\n\\t\\t\\tminTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),\\r\\n\\t\\t\\tmaxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),\\r\\n\\t\\t\\tmaxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );\\r\\n\\r\\n\\t\\t// z-order range for the current triangle bbox;\\r\\n\\r\\n\\t\\tvar minZ = zOrder( minTX, minTY, minX, minY, invSize ),\\r\\n\\t\\t\\tmaxZ = zOrder( maxTX, maxTY, minX, minY, invSize );\\r\\n\\r\\n\\t\\t// first look for points inside the triangle in increasing z-order\\r\\n\\r\\n\\t\\tvar p = ear.nextZ;\\r\\n\\r\\n\\t\\twhile ( p && p.z <= maxZ ) {\\r\\n\\r\\n\\t\\t\\tif ( p !== ear.prev && p !== ear.next &&\\r\\n\\t\\t\\t\\t\\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\\r\\n\\t\\t\\t\\t\\tarea( p.prev, p, p.next ) >= 0 ) return false;\\r\\n\\t\\t\\tp = p.nextZ;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// then look for points in decreasing z-order\\r\\n\\r\\n\\t\\tp = ear.prevZ;\\r\\n\\r\\n\\t\\twhile ( p && p.z >= minZ ) {\\r\\n\\r\\n\\t\\t\\tif ( p !== ear.prev && p !== ear.next &&\\r\\n\\t\\t\\t\\t\\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\\r\\n\\t\\t\\t\\t\\tarea( p.prev, p, p.next ) >= 0 ) return false;\\r\\n\\r\\n\\t\\t\\tp = p.prevZ;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn true;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// go through all polygon nodes and cure small local self-intersections\\r\\n\\r\\n\\tfunction cureLocalIntersections( start, triangles, dim ) {\\r\\n\\r\\n\\t\\tvar p = start;\\r\\n\\r\\n\\t\\tdo {\\r\\n\\r\\n\\t\\t\\tvar a = p.prev, b = p.next.next;\\r\\n\\r\\n\\t\\t\\tif ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {\\r\\n\\r\\n\\t\\t\\t\\ttriangles.push( a.i / dim );\\r\\n\\t\\t\\t\\ttriangles.push( p.i / dim );\\r\\n\\t\\t\\t\\ttriangles.push( b.i / dim );\\r\\n\\r\\n\\t\\t\\t\\t// remove two nodes involved\\r\\n\\r\\n\\t\\t\\t\\tremoveNode( p );\\r\\n\\t\\t\\t\\tremoveNode( p.next );\\r\\n\\r\\n\\t\\t\\t\\tp = start = b;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tp = p.next;\\r\\n\\r\\n\\t\\t} while ( p !== start );\\r\\n\\r\\n\\t\\treturn p;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// try splitting polygon into two and triangulate them independently\\r\\n\\r\\n\\tfunction splitEarcut( start, triangles, dim, minX, minY, invSize ) {\\r\\n\\r\\n\\t\\t// look for a valid diagonal that divides the polygon into two\\r\\n\\r\\n\\t\\tvar a = start;\\r\\n\\r\\n\\t\\tdo {\\r\\n\\r\\n\\t\\t\\tvar b = a.next.next;\\r\\n\\r\\n\\t\\t\\twhile ( b !== a.prev ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( a.i !== b.i && isValidDiagonal( a, b ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// split the polygon in two by the diagonal\\r\\n\\r\\n\\t\\t\\t\\t\\tvar c = splitPolygon( a, b );\\r\\n\\r\\n\\t\\t\\t\\t\\t// filter colinear points around the cuts\\r\\n\\r\\n\\t\\t\\t\\t\\ta = filterPoints( a, a.next );\\r\\n\\t\\t\\t\\t\\tc = filterPoints( c, c.next );\\r\\n\\r\\n\\t\\t\\t\\t\\t// run earcut on each half\\r\\n\\r\\n\\t\\t\\t\\t\\tearcutLinked( a, triangles, dim, minX, minY, invSize );\\r\\n\\t\\t\\t\\t\\tearcutLinked( c, triangles, dim, minX, minY, invSize );\\r\\n\\t\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tb = b.next;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\ta = a.next;\\r\\n\\r\\n\\t\\t} while ( a !== start );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// link every hole into the outer loop, producing a single-ring polygon without holes\\r\\n\\r\\n\\tfunction eliminateHoles( data, holeIndices, outerNode, dim ) {\\r\\n\\r\\n\\t\\tvar queue = [], i, len, start, end, list;\\r\\n\\r\\n\\t\\tfor ( i = 0, len = holeIndices.length; i < len; i ++ ) {\\r\\n\\r\\n\\t\\t\\tstart = holeIndices[ i ] * dim;\\r\\n\\t\\t\\tend = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;\\r\\n\\t\\t\\tlist = linkedList( data, start, end, dim, false );\\r\\n\\t\\t\\tif ( list === list.next ) list.steiner = true;\\r\\n\\t\\t\\tqueue.push( getLeftmost( list ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tqueue.sort( compareX );\\r\\n\\r\\n\\t\\t// process holes from left to right\\r\\n\\r\\n\\t\\tfor ( i = 0; i < queue.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\teliminateHole( queue[ i ], outerNode );\\r\\n\\t\\t\\touterNode = filterPoints( outerNode, outerNode.next );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn outerNode;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction compareX( a, b ) {\\r\\n\\r\\n\\t\\treturn a.x - b.x;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// find a bridge between vertices that connects hole with an outer ring and and link it\\r\\n\\r\\n\\tfunction eliminateHole( hole, outerNode ) {\\r\\n\\r\\n\\t\\touterNode = findHoleBridge( hole, outerNode );\\r\\n\\r\\n\\t\\tif ( outerNode ) {\\r\\n\\r\\n\\t\\t\\tvar b = splitPolygon( outerNode, hole );\\r\\n\\r\\n\\t\\t\\tfilterPoints( b, b.next );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// David Eberly's algorithm for finding a bridge between hole and outer polygon\\r\\n\\r\\n\\tfunction findHoleBridge( hole, outerNode ) {\\r\\n\\r\\n\\t\\tvar p = outerNode,\\r\\n\\t\\t\\thx = hole.x,\\r\\n\\t\\t\\thy = hole.y,\\r\\n\\t\\t\\tqx = - Infinity,\\r\\n\\t\\t\\tm;\\r\\n\\r\\n\\t\\t// find a segment intersected by a ray from the hole's leftmost point to the left;\\r\\n\\t\\t// segment's endpoint with lesser x will be potential connection point\\r\\n\\r\\n\\t\\tdo {\\r\\n\\r\\n\\t\\t\\tif ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {\\r\\n\\r\\n\\t\\t\\t\\tvar x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );\\r\\n\\r\\n\\t\\t\\t\\tif ( x <= hx && x > qx ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tqx = x;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( x === hx ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( hy === p.y ) return p;\\r\\n\\t\\t\\t\\t\\t\\tif ( hy === p.next.y ) return p.next;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tm = p.x < p.next.x ? p : p.next;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tp = p.next;\\r\\n\\r\\n\\t\\t} while ( p !== outerNode );\\r\\n\\r\\n\\t\\tif ( ! m ) return null;\\r\\n\\r\\n\\t\\tif ( hx === qx ) return m.prev; // hole touches outer segment; pick lower endpoint\\r\\n\\r\\n\\t\\t// look for points inside the triangle of hole point, segment intersection and endpoint;\\r\\n\\t\\t// if there are no points found, we have a valid connection;\\r\\n\\t\\t// otherwise choose the point of the minimum angle with the ray as connection point\\r\\n\\r\\n\\t\\tvar stop = m,\\r\\n\\t\\t\\tmx = m.x,\\r\\n\\t\\t\\tmy = m.y,\\r\\n\\t\\t\\ttanMin = Infinity,\\r\\n\\t\\t\\ttan;\\r\\n\\r\\n\\t\\tp = m.next;\\r\\n\\r\\n\\t\\twhile ( p !== stop ) {\\r\\n\\r\\n\\t\\t\\tif ( hx >= p.x && p.x >= mx && hx !== p.x &&\\r\\n\\t\\t\\t\\t\\t\\t\\tpointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {\\r\\n\\r\\n\\t\\t\\t\\ttan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential\\r\\n\\r\\n\\t\\t\\t\\tif ( ( tan < tanMin || ( tan === tanMin && p.x > m.x ) ) && locallyInside( p, hole ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tm = p;\\r\\n\\t\\t\\t\\t\\ttanMin = tan;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tp = p.next;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn m;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// interlink polygon nodes in z-order\\r\\n\\r\\n\\tfunction indexCurve( start, minX, minY, invSize ) {\\r\\n\\r\\n\\t\\tvar p = start;\\r\\n\\r\\n\\t\\tdo {\\r\\n\\r\\n\\t\\t\\tif ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );\\r\\n\\t\\t\\tp.prevZ = p.prev;\\r\\n\\t\\t\\tp.nextZ = p.next;\\r\\n\\t\\t\\tp = p.next;\\r\\n\\r\\n\\t\\t} while ( p !== start );\\r\\n\\r\\n\\t\\tp.prevZ.nextZ = null;\\r\\n\\t\\tp.prevZ = null;\\r\\n\\r\\n\\t\\tsortLinked( p );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// Simon Tatham's linked list merge sort algorithm\\r\\n\\t// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\\r\\n\\r\\n\\tfunction sortLinked( list ) {\\r\\n\\r\\n\\t\\tvar i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;\\r\\n\\r\\n\\t\\tdo {\\r\\n\\r\\n\\t\\t\\tp = list;\\r\\n\\t\\t\\tlist = null;\\r\\n\\t\\t\\ttail = null;\\r\\n\\t\\t\\tnumMerges = 0;\\r\\n\\r\\n\\t\\t\\twhile ( p ) {\\r\\n\\r\\n\\t\\t\\t\\tnumMerges ++;\\r\\n\\t\\t\\t\\tq = p;\\r\\n\\t\\t\\t\\tpSize = 0;\\r\\n\\r\\n\\t\\t\\t\\tfor ( i = 0; i < inSize; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tpSize ++;\\r\\n\\t\\t\\t\\t\\tq = q.nextZ;\\r\\n\\t\\t\\t\\t\\tif ( ! q ) break;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tqSize = inSize;\\r\\n\\r\\n\\t\\t\\t\\twhile ( pSize > 0 || ( qSize > 0 && q ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\te = p;\\r\\n\\t\\t\\t\\t\\t\\tp = p.nextZ;\\r\\n\\t\\t\\t\\t\\t\\tpSize --;\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\te = q;\\r\\n\\t\\t\\t\\t\\t\\tq = q.nextZ;\\r\\n\\t\\t\\t\\t\\t\\tqSize --;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( tail ) tail.nextZ = e;\\r\\n\\t\\t\\t\\t\\telse list = e;\\r\\n\\r\\n\\t\\t\\t\\t\\te.prevZ = tail;\\r\\n\\t\\t\\t\\t\\ttail = e;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tp = q;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\ttail.nextZ = null;\\r\\n\\t\\t\\tinSize *= 2;\\r\\n\\r\\n\\t\\t} while ( numMerges > 1 );\\r\\n\\r\\n\\t\\treturn list;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// z-order of a point given coords and inverse of the longer side of data bbox\\r\\n\\r\\n\\tfunction zOrder( x, y, minX, minY, invSize ) {\\r\\n\\r\\n\\t\\t// coords are transformed into non-negative 15-bit integer range\\r\\n\\r\\n\\t\\tx = 32767 * ( x - minX ) * invSize;\\r\\n\\t\\ty = 32767 * ( y - minY ) * invSize;\\r\\n\\r\\n\\t\\tx = ( x | ( x << 8 ) ) & 0x00FF00FF;\\r\\n\\t\\tx = ( x | ( x << 4 ) ) & 0x0F0F0F0F;\\r\\n\\t\\tx = ( x | ( x << 2 ) ) & 0x33333333;\\r\\n\\t\\tx = ( x | ( x << 1 ) ) & 0x55555555;\\r\\n\\r\\n\\t\\ty = ( y | ( y << 8 ) ) & 0x00FF00FF;\\r\\n\\t\\ty = ( y | ( y << 4 ) ) & 0x0F0F0F0F;\\r\\n\\t\\ty = ( y | ( y << 2 ) ) & 0x33333333;\\r\\n\\t\\ty = ( y | ( y << 1 ) ) & 0x55555555;\\r\\n\\r\\n\\t\\treturn x | ( y << 1 );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// find the leftmost node of a polygon ring\\r\\n\\r\\n\\tfunction getLeftmost( start ) {\\r\\n\\r\\n\\t\\tvar p = start, leftmost = start;\\r\\n\\r\\n\\t\\tdo {\\r\\n\\r\\n\\t\\t\\tif ( p.x < leftmost.x ) leftmost = p;\\r\\n\\t\\t\\tp = p.next;\\r\\n\\r\\n\\t\\t} while ( p !== start );\\r\\n\\r\\n\\t\\treturn leftmost;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// check if a point lies within a convex triangle\\r\\n\\r\\n\\tfunction pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {\\r\\n\\r\\n\\t\\treturn ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&\\r\\n\\t\\t ( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&\\r\\n\\t\\t ( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\\r\\n\\r\\n\\tfunction isValidDiagonal( a, b ) {\\r\\n\\r\\n\\t\\treturn a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) &&\\r\\n\\t\\t\\tlocallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// signed area of a triangle\\r\\n\\r\\n\\tfunction area( p, q, r ) {\\r\\n\\r\\n\\t\\treturn ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// check if two points are equal\\r\\n\\r\\n\\tfunction equals( p1, p2 ) {\\r\\n\\r\\n\\t\\treturn p1.x === p2.x && p1.y === p2.y;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// check if two segments intersect\\r\\n\\r\\n\\tfunction intersects( p1, q1, p2, q2 ) {\\r\\n\\r\\n\\t\\tif ( ( equals( p1, q1 ) && equals( p2, q2 ) ) ||\\r\\n\\t\\t\\t\\t( equals( p1, q2 ) && equals( p2, q1 ) ) ) return true;\\r\\n\\r\\n\\t\\treturn area( p1, q1, p2 ) > 0 !== area( p1, q1, q2 ) > 0 &&\\r\\n\\t\\t\\t\\t\\t area( p2, q2, p1 ) > 0 !== area( p2, q2, q1 ) > 0;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// check if a polygon diagonal intersects any polygon segments\\r\\n\\r\\n\\tfunction intersectsPolygon( a, b ) {\\r\\n\\r\\n\\t\\tvar p = a;\\r\\n\\r\\n\\t\\tdo {\\r\\n\\r\\n\\t\\t\\tif ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\\r\\n\\t\\t\\t\\t\\t\\t\\tintersects( p, p.next, a, b ) ) {\\r\\n\\r\\n\\t\\t\\t\\treturn true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tp = p.next;\\r\\n\\r\\n\\t\\t} while ( p !== a );\\r\\n\\r\\n\\t\\treturn false;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// check if a polygon diagonal is locally inside the polygon\\r\\n\\r\\n\\tfunction locallyInside( a, b ) {\\r\\n\\r\\n\\t\\treturn area( a.prev, a, a.next ) < 0 ?\\r\\n\\t\\t\\tarea( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :\\r\\n\\t\\t\\tarea( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// check if the middle point of a polygon diagonal is inside the polygon\\r\\n\\r\\n\\tfunction middleInside( a, b ) {\\r\\n\\r\\n\\t\\tvar p = a,\\r\\n\\t\\t\\tinside = false,\\r\\n\\t\\t\\tpx = ( a.x + b.x ) / 2,\\r\\n\\t\\t\\tpy = ( a.y + b.y ) / 2;\\r\\n\\r\\n\\t\\tdo {\\r\\n\\r\\n\\t\\t\\tif ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&\\r\\n\\t\\t\\t\\t\\t\\t\\t( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) ) {\\r\\n\\r\\n\\t\\t\\t\\tinside = ! inside;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tp = p.next;\\r\\n\\r\\n\\t\\t} while ( p !== a );\\r\\n\\r\\n\\t\\treturn inside;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\\r\\n\\t// if one belongs to the outer ring and another to a hole, it merges it into a single ring\\r\\n\\r\\n\\tfunction splitPolygon( a, b ) {\\r\\n\\r\\n\\t\\tvar a2 = new Node( a.i, a.x, a.y ),\\r\\n\\t\\t\\tb2 = new Node( b.i, b.x, b.y ),\\r\\n\\t\\t\\tan = a.next,\\r\\n\\t\\t\\tbp = b.prev;\\r\\n\\r\\n\\t\\ta.next = b;\\r\\n\\t\\tb.prev = a;\\r\\n\\r\\n\\t\\ta2.next = an;\\r\\n\\t\\tan.prev = a2;\\r\\n\\r\\n\\t\\tb2.next = a2;\\r\\n\\t\\ta2.prev = b2;\\r\\n\\r\\n\\t\\tbp.next = b2;\\r\\n\\t\\tb2.prev = bp;\\r\\n\\r\\n\\t\\treturn b2;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// create a node and optionally link it with previous one (in a circular doubly linked list)\\r\\n\\r\\n\\tfunction insertNode( i, x, y, last ) {\\r\\n\\r\\n\\t\\tvar p = new Node( i, x, y );\\r\\n\\r\\n\\t\\tif ( ! last ) {\\r\\n\\r\\n\\t\\t\\tp.prev = p;\\r\\n\\t\\t\\tp.next = p;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tp.next = last.next;\\r\\n\\t\\t\\tp.prev = last;\\r\\n\\t\\t\\tlast.next.prev = p;\\r\\n\\t\\t\\tlast.next = p;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn p;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction removeNode( p ) {\\r\\n\\r\\n\\t\\tp.next.prev = p.prev;\\r\\n\\t\\tp.prev.next = p.next;\\r\\n\\r\\n\\t\\tif ( p.prevZ ) p.prevZ.nextZ = p.nextZ;\\r\\n\\t\\tif ( p.nextZ ) p.nextZ.prevZ = p.prevZ;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction Node( i, x, y ) {\\r\\n\\r\\n\\t\\t// vertice index in coordinates array\\r\\n\\t\\tthis.i = i;\\r\\n\\r\\n\\t\\t// vertex coordinates\\r\\n\\t\\tthis.x = x;\\r\\n\\t\\tthis.y = y;\\r\\n\\r\\n\\t\\t// previous and next vertice nodes in a polygon ring\\r\\n\\t\\tthis.prev = null;\\r\\n\\t\\tthis.next = null;\\r\\n\\r\\n\\t\\t// z-order curve value\\r\\n\\t\\tthis.z = null;\\r\\n\\r\\n\\t\\t// previous and next nodes in z-order\\r\\n\\t\\tthis.prevZ = null;\\r\\n\\t\\tthis.nextZ = null;\\r\\n\\r\\n\\t\\t// indicates whether this is a steiner point\\r\\n\\t\\tthis.steiner = false;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction signedArea( data, start, end, dim ) {\\r\\n\\r\\n\\t\\tvar sum = 0;\\r\\n\\r\\n\\t\\tfor ( var i = start, j = end - dim; i < end; i += dim ) {\\r\\n\\r\\n\\t\\t\\tsum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );\\r\\n\\t\\t\\tj = i;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn sum;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\r\\n\\t */\\r\\n\\r\\n\\tvar ShapeUtils = {\\r\\n\\r\\n\\t\\t// calculate area of the contour polygon\\r\\n\\r\\n\\t\\tarea: function ( contour ) {\\r\\n\\r\\n\\t\\t\\tvar n = contour.length;\\r\\n\\t\\t\\tvar a = 0.0;\\r\\n\\r\\n\\t\\t\\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\\r\\n\\r\\n\\t\\t\\t\\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn a * 0.5;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tisClockWise: function ( pts ) {\\r\\n\\r\\n\\t\\t\\treturn ShapeUtils.area( pts ) < 0;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttriangulateShape: function ( contour, holes ) {\\r\\n\\r\\n\\t\\t\\tfunction removeDupEndPts( points ) {\\r\\n\\r\\n\\t\\t\\t\\tvar l = points.length;\\r\\n\\r\\n\\t\\t\\t\\tif ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tpoints.pop();\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfunction addContour( vertices, contour ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0; i < contour.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvertices.push( contour[ i ].x );\\r\\n\\t\\t\\t\\t\\tvertices.push( contour[ i ].y );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]\\r\\n\\t\\t\\tvar holeIndices = []; // array of hole indices\\r\\n\\t\\t\\tvar faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]\\r\\n\\r\\n\\t\\t\\tremoveDupEndPts( contour );\\r\\n\\t\\t\\taddContour( vertices, contour );\\r\\n\\r\\n\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\tvar holeIndex = contour.length;\\r\\n\\t\\t\\tholes.forEach( removeDupEndPts );\\r\\n\\r\\n\\t\\t\\tfor ( i = 0; i < holes.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tholeIndices.push( holeIndex );\\r\\n\\t\\t\\t\\tholeIndex += holes[ i ].length;\\r\\n\\t\\t\\t\\taddContour( vertices, holes[ i ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\tvar triangles = Earcut.triangulate( vertices, holeIndices );\\r\\n\\r\\n\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < triangles.length; i += 3 ) {\\r\\n\\r\\n\\t\\t\\t\\tfaces.push( triangles.slice( i, i + 3 ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn faces;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\r\\n\\t *\\r\\n\\t * Creates extruded geometry from a path shape.\\r\\n\\t *\\r\\n\\t * parameters = {\\r\\n\\t *\\r\\n\\t *  curveSegments: <int>, // number of points on the curves\\r\\n\\t *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\\r\\n\\t *  amount: <int>, // Depth to extrude the shape\\r\\n\\t *\\r\\n\\t *  bevelEnabled: <bool>, // turn on bevel\\r\\n\\t *  bevelThickness: <float>, // how deep into the original shape bevel goes\\r\\n\\t *  bevelSize: <float>, // how far from shape outline is bevel\\r\\n\\t *  bevelSegments: <int>, // number of bevel layers\\r\\n\\t *\\r\\n\\t *  extrudePath: <THREE.Curve> // curve to extrude shape along\\r\\n\\t *  frames: <Object> // containing arrays of tangents, normals, binormals\\r\\n\\t *\\r\\n\\t *  UVGenerator: <Object> // object that provides UV generator functions\\r\\n\\t *\\r\\n\\t * }\\r\\n\\t */\\r\\n\\r\\n\\t// ExtrudeGeometry\\r\\n\\r\\n\\tfunction ExtrudeGeometry( shapes, options ) {\\r\\n\\r\\n\\t\\tGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'ExtrudeGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tshapes: shapes,\\r\\n\\t\\t\\toptions: options\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );\\r\\n\\t\\tthis.mergeVertices();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tExtrudeGeometry.prototype = Object.create( Geometry.prototype );\\r\\n\\tExtrudeGeometry.prototype.constructor = ExtrudeGeometry;\\r\\n\\r\\n\\t// ExtrudeBufferGeometry\\r\\n\\r\\n\\tfunction ExtrudeBufferGeometry( shapes, options ) {\\r\\n\\r\\n\\t\\tif ( typeof ( shapes ) === \\\"undefined\\\" ) {\\r\\n\\r\\n\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tBufferGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'ExtrudeBufferGeometry';\\r\\n\\r\\n\\t\\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\\r\\n\\r\\n\\t\\tthis.addShapeList( shapes, options );\\r\\n\\r\\n\\t\\tthis.computeVertexNormals();\\r\\n\\r\\n\\t\\t// can't really use automatic vertex normals\\r\\n\\t\\t// as then front and back sides get smoothed too\\r\\n\\t\\t// should do separate smoothing just for sides\\r\\n\\r\\n\\t\\t//this.computeVertexNormals();\\r\\n\\r\\n\\t\\t//console.log( \\\"took\\\", ( Date.now() - startTime ) );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\n\\tExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;\\r\\n\\r\\n\\tExtrudeBufferGeometry.prototype.getArrays = function () {\\r\\n\\r\\n\\t\\tvar positionAttribute = this.getAttribute( \\\"position\\\" );\\r\\n\\t\\tvar verticesArray = positionAttribute ? Array.prototype.slice.call( positionAttribute.array ) : [];\\r\\n\\r\\n\\t\\tvar uvAttribute = this.getAttribute( \\\"uv\\\" );\\r\\n\\t\\tvar uvArray = uvAttribute ? Array.prototype.slice.call( uvAttribute.array ) : [];\\r\\n\\r\\n\\t\\tvar IndexAttribute = this.index;\\r\\n\\t\\tvar indicesArray = IndexAttribute ? Array.prototype.slice.call( IndexAttribute.array ) : [];\\r\\n\\r\\n\\t\\treturn {\\r\\n\\t\\t\\tposition: verticesArray,\\r\\n\\t\\t\\tuv: uvArray,\\r\\n\\t\\t\\tindex: indicesArray\\r\\n\\t\\t};\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tExtrudeBufferGeometry.prototype.addShapeList = function ( shapes, options ) {\\r\\n\\r\\n\\t\\tvar sl = shapes.length;\\r\\n\\t\\toptions.arrays = this.getArrays();\\r\\n\\r\\n\\t\\tfor ( var s = 0; s < sl; s ++ ) {\\r\\n\\r\\n\\t\\t\\tvar shape = shapes[ s ];\\r\\n\\t\\t\\tthis.addShape( shape, options );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.setIndex( options.arrays.index );\\r\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( options.arrays.position, 3 ) );\\r\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( options.arrays.uv, 2 ) );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tExtrudeBufferGeometry.prototype.addShape = function ( shape, options ) {\\r\\n\\r\\n\\t\\tvar arrays = options.arrays ? options.arrays : this.getArrays();\\r\\n\\t\\tvar verticesArray = arrays.position;\\r\\n\\t\\tvar indicesArray = arrays.index;\\r\\n\\t\\tvar uvArray = arrays.uv;\\r\\n\\r\\n\\t\\tvar placeholder = [];\\r\\n\\r\\n\\r\\n\\t\\tvar amount = options.amount !== undefined ? options.amount : 100;\\r\\n\\r\\n\\t\\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\\r\\n\\t\\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\\r\\n\\t\\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\\r\\n\\r\\n\\t\\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\\r\\n\\r\\n\\t\\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\\r\\n\\r\\n\\t\\tvar steps = options.steps !== undefined ? options.steps : 1;\\r\\n\\r\\n\\t\\tvar extrudePath = options.extrudePath;\\r\\n\\t\\tvar extrudePts, extrudeByPath = false;\\r\\n\\r\\n\\t\\t// Use default WorldUVGenerator if no UV generators are specified.\\r\\n\\t\\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;\\r\\n\\r\\n\\t\\tvar splineTube, binormal, normal, position2;\\r\\n\\t\\tif ( extrudePath ) {\\r\\n\\r\\n\\t\\t\\textrudePts = extrudePath.getSpacedPoints( steps );\\r\\n\\r\\n\\t\\t\\textrudeByPath = true;\\r\\n\\t\\t\\tbevelEnabled = false; // bevels not supported for path extrusion\\r\\n\\r\\n\\t\\t\\t// SETUP TNB variables\\r\\n\\r\\n\\t\\t\\t// TODO1 - have a .isClosed in spline?\\r\\n\\r\\n\\t\\t\\tsplineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );\\r\\n\\r\\n\\t\\t\\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\\r\\n\\r\\n\\t\\t\\tbinormal = new Vector3();\\r\\n\\t\\t\\tnormal = new Vector3();\\r\\n\\t\\t\\tposition2 = new Vector3();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Safeguards if bevels are not enabled\\r\\n\\r\\n\\t\\tif ( ! bevelEnabled ) {\\r\\n\\r\\n\\t\\t\\tbevelSegments = 0;\\r\\n\\t\\t\\tbevelThickness = 0;\\r\\n\\t\\t\\tbevelSize = 0;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Variables initialization\\r\\n\\r\\n\\t\\tvar ahole, h, hl; // looping of holes\\r\\n\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\tvar shapePoints = shape.extractPoints( curveSegments );\\r\\n\\r\\n\\t\\tvar vertices = shapePoints.shape;\\r\\n\\t\\tvar holes = shapePoints.holes;\\r\\n\\r\\n\\t\\tvar reverse = ! ShapeUtils.isClockWise( vertices );\\r\\n\\r\\n\\t\\tif ( reverse ) {\\r\\n\\r\\n\\t\\t\\tvertices = vertices.reverse();\\r\\n\\r\\n\\t\\t\\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\\r\\n\\r\\n\\t\\t\\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tahole = holes[ h ];\\r\\n\\r\\n\\t\\t\\t\\tif ( ShapeUtils.isClockWise( ahole ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tholes[ h ] = ahole.reverse();\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\tvar faces = ShapeUtils.triangulateShape( vertices, holes );\\r\\n\\r\\n\\t\\t/* Vertices */\\r\\n\\r\\n\\t\\tvar contour = vertices; // vertices has all points but contour has only points of circumference\\r\\n\\r\\n\\t\\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\\r\\n\\r\\n\\t\\t\\tahole = holes[ h ];\\r\\n\\r\\n\\t\\t\\tvertices = vertices.concat( ahole );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\tfunction scalePt2( pt, vec, size ) {\\r\\n\\r\\n\\t\\t\\tif ( ! vec ) console.error( \\\"THREE.ExtrudeGeometry: vec does not exist\\\" );\\r\\n\\r\\n\\t\\t\\treturn vec.clone().multiplyScalar( size ).add( pt );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar b, bs, t, z,\\r\\n\\t\\t\\tvert, vlen = vertices.length,\\r\\n\\t\\t\\tface, flen = faces.length;\\r\\n\\r\\n\\r\\n\\t\\t// Find directions for point movement\\r\\n\\r\\n\\r\\n\\t\\tfunction getBevelVec( inPt, inPrev, inNext ) {\\r\\n\\r\\n\\t\\t\\t// computes for inPt the corresponding point inPt' on a new contour\\r\\n\\t\\t\\t//   shifted by 1 unit (length of normalized vector) to the left\\r\\n\\t\\t\\t// if we walk along contour clockwise, this new contour is outside the old one\\r\\n\\t\\t\\t//\\r\\n\\t\\t\\t// inPt' is the intersection of the two lines parallel to the two\\r\\n\\t\\t\\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\\r\\n\\r\\n\\t\\t\\tvar v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\\r\\n\\r\\n\\t\\t\\t// good reading for geometry algorithms (here: line-line intersection)\\r\\n\\t\\t\\t// http://geomalgorithms.com/a05-_intersect-1.html\\r\\n\\r\\n\\t\\t\\tvar v_prev_x = inPt.x - inPrev.x,\\r\\n\\t\\t\\t\\tv_prev_y = inPt.y - inPrev.y;\\r\\n\\t\\t\\tvar v_next_x = inNext.x - inPt.x,\\r\\n\\t\\t\\t\\tv_next_y = inNext.y - inPt.y;\\r\\n\\r\\n\\t\\t\\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\\r\\n\\r\\n\\t\\t\\t// check for collinear edges\\r\\n\\t\\t\\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\\r\\n\\r\\n\\t\\t\\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\\r\\n\\r\\n\\t\\t\\t\\t// not collinear\\r\\n\\r\\n\\t\\t\\t\\t// length of vectors for normalizing\\r\\n\\r\\n\\t\\t\\t\\tvar v_prev_len = Math.sqrt( v_prev_lensq );\\r\\n\\t\\t\\t\\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\\r\\n\\r\\n\\t\\t\\t\\t// shift adjacent points by unit vectors to the left\\r\\n\\r\\n\\t\\t\\t\\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\\r\\n\\t\\t\\t\\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\\r\\n\\r\\n\\t\\t\\t\\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\\r\\n\\t\\t\\t\\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\\r\\n\\r\\n\\t\\t\\t\\t// scaling factor for v_prev to intersection point\\r\\n\\r\\n\\t\\t\\t\\tvar sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\\r\\n\\t\\t\\t\\t\\t\\t( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /\\r\\n\\t\\t\\t\\t\\t( v_prev_x * v_next_y - v_prev_y * v_next_x );\\r\\n\\r\\n\\t\\t\\t\\t// vector from inPt to intersection point\\r\\n\\r\\n\\t\\t\\t\\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\\r\\n\\t\\t\\t\\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\\r\\n\\r\\n\\t\\t\\t\\t// Don't normalize!, otherwise sharp corners become ugly\\r\\n\\t\\t\\t\\t//  but prevent crazy spikes\\r\\n\\t\\t\\t\\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\\r\\n\\t\\t\\t\\tif ( v_trans_lensq <= 2 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn new Vector2( v_trans_x, v_trans_y );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t// handle special case of collinear edges\\r\\n\\r\\n\\t\\t\\t\\tvar direction_eq = false; // assumes: opposite\\r\\n\\t\\t\\t\\tif ( v_prev_x > Number.EPSILON ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( v_next_x > Number.EPSILON ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tdirection_eq = true;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( v_prev_x < - Number.EPSILON ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( v_next_x < - Number.EPSILON ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tdirection_eq = true;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tdirection_eq = true;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( direction_eq ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// console.log(\\\"Warning: lines are a straight sequence\\\");\\r\\n\\t\\t\\t\\t\\tv_trans_x = - v_prev_y;\\r\\n\\t\\t\\t\\t\\tv_trans_y = v_prev_x;\\r\\n\\t\\t\\t\\t\\tshrink_by = Math.sqrt( v_prev_lensq );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t// console.log(\\\"Warning: lines are a straight spike\\\");\\r\\n\\t\\t\\t\\t\\tv_trans_x = v_prev_x;\\r\\n\\t\\t\\t\\t\\tv_trans_y = v_prev_y;\\r\\n\\t\\t\\t\\t\\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\tvar contourMovements = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\\r\\n\\r\\n\\t\\t\\tif ( j === il ) j = 0;\\r\\n\\t\\t\\tif ( k === il ) k = 0;\\r\\n\\r\\n\\t\\t\\t//  (j)---(i)---(k)\\r\\n\\t\\t\\t// console.log('i,j,k', i, j , k)\\r\\n\\r\\n\\t\\t\\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar holesMovements = [],\\r\\n\\t\\t\\toneHoleMovements, verticesMovements = contourMovements.concat();\\r\\n\\r\\n\\t\\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\\r\\n\\r\\n\\t\\t\\tahole = holes[ h ];\\r\\n\\r\\n\\t\\t\\toneHoleMovements = [];\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( j === il ) j = 0;\\r\\n\\t\\t\\t\\tif ( k === il ) k = 0;\\r\\n\\r\\n\\t\\t\\t\\t//  (j)---(i)---(k)\\r\\n\\t\\t\\t\\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tholesMovements.push( oneHoleMovements );\\r\\n\\t\\t\\tverticesMovements = verticesMovements.concat( oneHoleMovements );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\t// Loop bevelSegments, 1 for the front, 1 for the back\\r\\n\\r\\n\\t\\tfor ( b = 0; b < bevelSegments; b ++ ) {\\r\\n\\r\\n\\t\\t\\t//for ( b = bevelSegments; b > 0; b -- ) {\\r\\n\\r\\n\\t\\t\\tt = b / bevelSegments;\\r\\n\\t\\t\\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\\r\\n\\t\\t\\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\\r\\n\\r\\n\\t\\t\\t// contract shape\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\\r\\n\\r\\n\\t\\t\\t\\tv( vert.x, vert.y, - z );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// expand holes\\r\\n\\r\\n\\t\\t\\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tahole = holes[ h ];\\r\\n\\t\\t\\t\\toneHoleMovements = holesMovements[ h ];\\r\\n\\r\\n\\t\\t\\t\\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\\r\\n\\r\\n\\t\\t\\t\\t\\tv( vert.x, vert.y, - z );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tbs = bevelSize;\\r\\n\\r\\n\\t\\t// Back facing vertices\\r\\n\\r\\n\\t\\tfor ( i = 0; i < vlen; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\\r\\n\\r\\n\\t\\t\\tif ( ! extrudeByPath ) {\\r\\n\\r\\n\\t\\t\\t\\tv( vert.x, vert.y, 0 );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\\r\\n\\r\\n\\t\\t\\t\\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\\r\\n\\t\\t\\t\\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\\r\\n\\r\\n\\t\\t\\t\\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\\r\\n\\r\\n\\t\\t\\t\\tv( position2.x, position2.y, position2.z );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Add stepped vertices...\\r\\n\\t\\t// Including front facing vertices\\r\\n\\r\\n\\t\\tvar s;\\r\\n\\r\\n\\t\\tfor ( s = 1; s <= steps; s ++ ) {\\r\\n\\r\\n\\t\\t\\tfor ( i = 0; i < vlen; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\\r\\n\\r\\n\\t\\t\\t\\tif ( ! extrudeByPath ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tv( vert.x, vert.y, amount / steps * s );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\\r\\n\\r\\n\\t\\t\\t\\t\\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\\r\\n\\t\\t\\t\\t\\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\\r\\n\\r\\n\\t\\t\\t\\t\\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\\r\\n\\r\\n\\t\\t\\t\\t\\tv( position2.x, position2.y, position2.z );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\t// Add bevel segments planes\\r\\n\\r\\n\\t\\t//for ( b = 1; b <= bevelSegments; b ++ ) {\\r\\n\\t\\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\\r\\n\\r\\n\\t\\t\\tt = b / bevelSegments;\\r\\n\\t\\t\\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\\r\\n\\t\\t\\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\\r\\n\\r\\n\\t\\t\\t// contract shape\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\\r\\n\\t\\t\\t\\tv( vert.x, vert.y, amount + z );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// expand holes\\r\\n\\r\\n\\t\\t\\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tahole = holes[ h ];\\r\\n\\t\\t\\t\\toneHoleMovements = holesMovements[ h ];\\r\\n\\r\\n\\t\\t\\t\\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( ! extrudeByPath ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tv( vert.x, vert.y, amount + z );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t/* Faces */\\r\\n\\r\\n\\t\\t// Top and bottom faces\\r\\n\\r\\n\\t\\tbuildLidFaces();\\r\\n\\r\\n\\t\\t// Sides faces\\r\\n\\r\\n\\t\\tbuildSideFaces();\\r\\n\\r\\n\\r\\n\\t\\t/////  Internal functions\\r\\n\\r\\n\\t\\tfunction buildLidFaces() {\\r\\n\\r\\n\\t\\t\\tvar start = verticesArray.length / 3;\\r\\n\\r\\n\\t\\t\\tif ( bevelEnabled ) {\\r\\n\\r\\n\\t\\t\\t\\tvar layer = 0; // steps + 1\\r\\n\\t\\t\\t\\tvar offset = vlen * layer;\\r\\n\\r\\n\\t\\t\\t\\t// Bottom faces\\r\\n\\r\\n\\t\\t\\t\\tfor ( i = 0; i < flen; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tface = faces[ i ];\\r\\n\\t\\t\\t\\t\\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tlayer = steps + bevelSegments * 2;\\r\\n\\t\\t\\t\\toffset = vlen * layer;\\r\\n\\r\\n\\t\\t\\t\\t// Top faces\\r\\n\\r\\n\\t\\t\\t\\tfor ( i = 0; i < flen; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tface = faces[ i ];\\r\\n\\t\\t\\t\\t\\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t// Bottom faces\\r\\n\\r\\n\\t\\t\\t\\tfor ( i = 0; i < flen; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tface = faces[ i ];\\r\\n\\t\\t\\t\\t\\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// Top faces\\r\\n\\r\\n\\t\\t\\t\\tfor ( i = 0; i < flen; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tface = faces[ i ];\\r\\n\\t\\t\\t\\t\\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tscope.addGroup( start, verticesArray.length / 3 - start, options.material !== undefined ? options.material : 0 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Create faces for the z-sides of the shape\\r\\n\\r\\n\\t\\tfunction buildSideFaces() {\\r\\n\\r\\n\\t\\t\\tvar start = verticesArray.length / 3;\\r\\n\\t\\t\\tvar layeroffset = 0;\\r\\n\\t\\t\\tsidewalls( contour, layeroffset );\\r\\n\\t\\t\\tlayeroffset += contour.length;\\r\\n\\r\\n\\t\\t\\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tahole = holes[ h ];\\r\\n\\t\\t\\t\\tsidewalls( ahole, layeroffset );\\r\\n\\r\\n\\t\\t\\t\\t//, true\\r\\n\\t\\t\\t\\tlayeroffset += ahole.length;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\t\\tscope.addGroup( start, verticesArray.length / 3 - start, options.extrudeMaterial !== undefined ? options.extrudeMaterial : 1 );\\r\\n\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction sidewalls( contour, layeroffset ) {\\r\\n\\r\\n\\t\\t\\tvar j, k;\\r\\n\\t\\t\\ti = contour.length;\\r\\n\\r\\n\\t\\t\\twhile ( -- i >= 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tj = i;\\r\\n\\t\\t\\t\\tk = i - 1;\\r\\n\\t\\t\\t\\tif ( k < 0 ) k = contour.length - 1;\\r\\n\\r\\n\\t\\t\\t\\t//console.log('b', i,j, i-1, k,vertices.length);\\r\\n\\r\\n\\t\\t\\t\\tvar s = 0,\\r\\n\\t\\t\\t\\t\\tsl = steps + bevelSegments * 2;\\r\\n\\r\\n\\t\\t\\t\\tfor ( s = 0; s < sl; s ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar slen1 = vlen * s;\\r\\n\\t\\t\\t\\t\\tvar slen2 = vlen * ( s + 1 );\\r\\n\\r\\n\\t\\t\\t\\t\\tvar a = layeroffset + j + slen1,\\r\\n\\t\\t\\t\\t\\t\\tb = layeroffset + k + slen1,\\r\\n\\t\\t\\t\\t\\t\\tc = layeroffset + k + slen2,\\r\\n\\t\\t\\t\\t\\t\\td = layeroffset + j + slen2;\\r\\n\\r\\n\\t\\t\\t\\t\\tf4( a, b, c, d );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction v( x, y, z ) {\\r\\n\\r\\n\\t\\t\\tplaceholder.push( x );\\r\\n\\t\\t\\tplaceholder.push( y );\\r\\n\\t\\t\\tplaceholder.push( z );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\tfunction f3( a, b, c ) {\\r\\n\\r\\n\\t\\t\\taddVertex( a );\\r\\n\\t\\t\\taddVertex( b );\\r\\n\\t\\t\\taddVertex( c );\\r\\n\\r\\n\\t\\t\\tvar nextIndex = verticesArray.length / 3;\\r\\n\\t\\t\\tvar uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\\r\\n\\r\\n\\t\\t\\taddUV( uvs[ 0 ] );\\r\\n\\t\\t\\taddUV( uvs[ 1 ] );\\r\\n\\t\\t\\taddUV( uvs[ 2 ] );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction f4( a, b, c, d ) {\\r\\n\\r\\n\\t\\t\\taddVertex( a );\\r\\n\\t\\t\\taddVertex( b );\\r\\n\\t\\t\\taddVertex( d );\\r\\n\\r\\n\\t\\t\\taddVertex( b );\\r\\n\\t\\t\\taddVertex( c );\\r\\n\\t\\t\\taddVertex( d );\\r\\n\\r\\n\\r\\n\\t\\t\\tvar nextIndex = verticesArray.length / 3;\\r\\n\\t\\t\\tvar uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\\r\\n\\r\\n\\t\\t\\taddUV( uvs[ 0 ] );\\r\\n\\t\\t\\taddUV( uvs[ 1 ] );\\r\\n\\t\\t\\taddUV( uvs[ 3 ] );\\r\\n\\r\\n\\t\\t\\taddUV( uvs[ 1 ] );\\r\\n\\t\\t\\taddUV( uvs[ 2 ] );\\r\\n\\t\\t\\taddUV( uvs[ 3 ] );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction addVertex( index ) {\\r\\n\\r\\n\\t\\t\\tindicesArray.push( verticesArray.length / 3 );\\r\\n\\t\\t\\tverticesArray.push( placeholder[ index * 3 + 0 ] );\\r\\n\\t\\t\\tverticesArray.push( placeholder[ index * 3 + 1 ] );\\r\\n\\t\\t\\tverticesArray.push( placeholder[ index * 3 + 2 ] );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\tfunction addUV( vector2 ) {\\r\\n\\r\\n\\t\\t\\tuvArray.push( vector2.x );\\r\\n\\t\\t\\tuvArray.push( vector2.y );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( ! options.arrays ) {\\r\\n\\r\\n\\t\\t\\tthis.setIndex( indicesArray );\\r\\n\\t\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );\\r\\n\\t\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tExtrudeGeometry.WorldUVGenerator = {\\r\\n\\r\\n\\t\\tgenerateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {\\r\\n\\r\\n\\t\\t\\tvar a_x = vertices[ indexA * 3 ];\\r\\n\\t\\t\\tvar a_y = vertices[ indexA * 3 + 1 ];\\r\\n\\t\\t\\tvar b_x = vertices[ indexB * 3 ];\\r\\n\\t\\t\\tvar b_y = vertices[ indexB * 3 + 1 ];\\r\\n\\t\\t\\tvar c_x = vertices[ indexC * 3 ];\\r\\n\\t\\t\\tvar c_y = vertices[ indexC * 3 + 1 ];\\r\\n\\r\\n\\t\\t\\treturn [\\r\\n\\t\\t\\t\\tnew Vector2( a_x, a_y ),\\r\\n\\t\\t\\t\\tnew Vector2( b_x, b_y ),\\r\\n\\t\\t\\t\\tnew Vector2( c_x, c_y )\\r\\n\\t\\t\\t];\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgenerateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {\\r\\n\\r\\n\\t\\t\\tvar a_x = vertices[ indexA * 3 ];\\r\\n\\t\\t\\tvar a_y = vertices[ indexA * 3 + 1 ];\\r\\n\\t\\t\\tvar a_z = vertices[ indexA * 3 + 2 ];\\r\\n\\t\\t\\tvar b_x = vertices[ indexB * 3 ];\\r\\n\\t\\t\\tvar b_y = vertices[ indexB * 3 + 1 ];\\r\\n\\t\\t\\tvar b_z = vertices[ indexB * 3 + 2 ];\\r\\n\\t\\t\\tvar c_x = vertices[ indexC * 3 ];\\r\\n\\t\\t\\tvar c_y = vertices[ indexC * 3 + 1 ];\\r\\n\\t\\t\\tvar c_z = vertices[ indexC * 3 + 2 ];\\r\\n\\t\\t\\tvar d_x = vertices[ indexD * 3 ];\\r\\n\\t\\t\\tvar d_y = vertices[ indexD * 3 + 1 ];\\r\\n\\t\\t\\tvar d_z = vertices[ indexD * 3 + 2 ];\\r\\n\\r\\n\\t\\t\\tif ( Math.abs( a_y - b_y ) < 0.01 ) {\\r\\n\\r\\n\\t\\t\\t\\treturn [\\r\\n\\t\\t\\t\\t\\tnew Vector2( a_x, 1 - a_z ),\\r\\n\\t\\t\\t\\t\\tnew Vector2( b_x, 1 - b_z ),\\r\\n\\t\\t\\t\\t\\tnew Vector2( c_x, 1 - c_z ),\\r\\n\\t\\t\\t\\t\\tnew Vector2( d_x, 1 - d_z )\\r\\n\\t\\t\\t\\t];\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\treturn [\\r\\n\\t\\t\\t\\t\\tnew Vector2( a_y, 1 - a_z ),\\r\\n\\t\\t\\t\\t\\tnew Vector2( b_y, 1 - b_z ),\\r\\n\\t\\t\\t\\t\\tnew Vector2( c_y, 1 - c_z ),\\r\\n\\t\\t\\t\\t\\tnew Vector2( d_y, 1 - d_z )\\r\\n\\t\\t\\t\\t];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t *\\r\\n\\t * Text = 3D Text\\r\\n\\t *\\r\\n\\t * parameters = {\\r\\n\\t *  font: <THREE.Font>, // font\\r\\n\\t *\\r\\n\\t *  size: <float>, // size of the text\\r\\n\\t *  height: <float>, // thickness to extrude text\\r\\n\\t *  curveSegments: <int>, // number of points on the curves\\r\\n\\t *\\r\\n\\t *  bevelEnabled: <bool>, // turn on bevel\\r\\n\\t *  bevelThickness: <float>, // how deep into text bevel goes\\r\\n\\t *  bevelSize: <float> // how far from text outline is bevel\\r\\n\\t * }\\r\\n\\t */\\r\\n\\r\\n\\t// TextGeometry\\r\\n\\r\\n\\tfunction TextGeometry( text, parameters ) {\\r\\n\\r\\n\\t\\tGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'TextGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\ttext: text,\\r\\n\\t\\t\\tparameters: parameters\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.fromBufferGeometry( new TextBufferGeometry( text, parameters ) );\\r\\n\\t\\tthis.mergeVertices();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tTextGeometry.prototype = Object.create( Geometry.prototype );\\r\\n\\tTextGeometry.prototype.constructor = TextGeometry;\\r\\n\\r\\n\\t// TextBufferGeometry\\r\\n\\r\\n\\tfunction TextBufferGeometry( text, parameters ) {\\r\\n\\r\\n\\t\\tparameters = parameters || {};\\r\\n\\r\\n\\t\\tvar font = parameters.font;\\r\\n\\r\\n\\t\\tif ( ! ( font && font.isFont ) ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\\r\\n\\t\\t\\treturn new Geometry();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );\\r\\n\\r\\n\\t\\t// translate parameters to ExtrudeGeometry API\\r\\n\\r\\n\\t\\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\\r\\n\\r\\n\\t\\t// defaults\\r\\n\\r\\n\\t\\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\\r\\n\\t\\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\\r\\n\\t\\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\\r\\n\\r\\n\\t\\tExtrudeBufferGeometry.call( this, shapes, parameters );\\r\\n\\r\\n\\t\\tthis.type = 'TextBufferGeometry';\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tTextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype );\\r\\n\\tTextBufferGeometry.prototype.constructor = TextBufferGeometry;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author benaadams / https://twitter.com/ben_a_adams\\r\\n\\t * @author Mugen87 / https://github.com/Mugen87\\r\\n\\t */\\r\\n\\r\\n\\t// SphereGeometry\\r\\n\\r\\n\\tfunction SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\\r\\n\\r\\n\\t\\tGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'SphereGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tradius: radius,\\r\\n\\t\\t\\twidthSegments: widthSegments,\\r\\n\\t\\t\\theightSegments: heightSegments,\\r\\n\\t\\t\\tphiStart: phiStart,\\r\\n\\t\\t\\tphiLength: phiLength,\\r\\n\\t\\t\\tthetaStart: thetaStart,\\r\\n\\t\\t\\tthetaLength: thetaLength\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\\r\\n\\t\\tthis.mergeVertices();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tSphereGeometry.prototype = Object.create( Geometry.prototype );\\r\\n\\tSphereGeometry.prototype.constructor = SphereGeometry;\\r\\n\\r\\n\\t// SphereBufferGeometry\\r\\n\\r\\n\\tfunction SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\\r\\n\\r\\n\\t\\tBufferGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'SphereBufferGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tradius: radius,\\r\\n\\t\\t\\twidthSegments: widthSegments,\\r\\n\\t\\t\\theightSegments: heightSegments,\\r\\n\\t\\t\\tphiStart: phiStart,\\r\\n\\t\\t\\tphiLength: phiLength,\\r\\n\\t\\t\\tthetaStart: thetaStart,\\r\\n\\t\\t\\tthetaLength: thetaLength\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tradius = radius || 1;\\r\\n\\r\\n\\t\\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\\r\\n\\t\\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\\r\\n\\r\\n\\t\\tphiStart = phiStart !== undefined ? phiStart : 0;\\r\\n\\t\\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\\r\\n\\r\\n\\t\\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\\r\\n\\t\\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\\r\\n\\r\\n\\t\\tvar thetaEnd = thetaStart + thetaLength;\\r\\n\\r\\n\\t\\tvar ix, iy;\\r\\n\\r\\n\\t\\tvar index = 0;\\r\\n\\t\\tvar grid = [];\\r\\n\\r\\n\\t\\tvar vertex = new Vector3();\\r\\n\\t\\tvar normal = new Vector3();\\r\\n\\r\\n\\t\\t// buffers\\r\\n\\r\\n\\t\\tvar indices = [];\\r\\n\\t\\tvar vertices = [];\\r\\n\\t\\tvar normals = [];\\r\\n\\t\\tvar uvs = [];\\r\\n\\r\\n\\t\\t// generate vertices, normals and uvs\\r\\n\\r\\n\\t\\tfor ( iy = 0; iy <= heightSegments; iy ++ ) {\\r\\n\\r\\n\\t\\t\\tvar verticesRow = [];\\r\\n\\r\\n\\t\\t\\tvar v = iy / heightSegments;\\r\\n\\r\\n\\t\\t\\tfor ( ix = 0; ix <= widthSegments; ix ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar u = ix / widthSegments;\\r\\n\\r\\n\\t\\t\\t\\t// vertex\\r\\n\\r\\n\\t\\t\\t\\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\\r\\n\\t\\t\\t\\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\\r\\n\\t\\t\\t\\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\\r\\n\\r\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\t\\t// normal\\r\\n\\r\\n\\t\\t\\t\\tnormal.set( vertex.x, vertex.y, vertex.z ).normalize();\\r\\n\\t\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\r\\n\\r\\n\\t\\t\\t\\t// uv\\r\\n\\r\\n\\t\\t\\t\\tuvs.push( u, 1 - v );\\r\\n\\r\\n\\t\\t\\t\\tverticesRow.push( index ++ );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tgrid.push( verticesRow );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// indices\\r\\n\\r\\n\\t\\tfor ( iy = 0; iy < heightSegments; iy ++ ) {\\r\\n\\r\\n\\t\\t\\tfor ( ix = 0; ix < widthSegments; ix ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar a = grid[ iy ][ ix + 1 ];\\r\\n\\t\\t\\t\\tvar b = grid[ iy ][ ix ];\\r\\n\\t\\t\\t\\tvar c = grid[ iy + 1 ][ ix ];\\r\\n\\t\\t\\t\\tvar d = grid[ iy + 1 ][ ix + 1 ];\\r\\n\\r\\n\\t\\t\\t\\tif ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );\\r\\n\\t\\t\\t\\tif ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// build geometry\\r\\n\\r\\n\\t\\tthis.setIndex( indices );\\r\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\r\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tSphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\n\\tSphereBufferGeometry.prototype.constructor = SphereBufferGeometry;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author Kaleb Murphy\\r\\n\\t * @author Mugen87 / https://github.com/Mugen87\\r\\n\\t */\\r\\n\\r\\n\\t// RingGeometry\\r\\n\\r\\n\\tfunction RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\\r\\n\\r\\n\\t\\tGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'RingGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tinnerRadius: innerRadius,\\r\\n\\t\\t\\touterRadius: outerRadius,\\r\\n\\t\\t\\tthetaSegments: thetaSegments,\\r\\n\\t\\t\\tphiSegments: phiSegments,\\r\\n\\t\\t\\tthetaStart: thetaStart,\\r\\n\\t\\t\\tthetaLength: thetaLength\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\\r\\n\\t\\tthis.mergeVertices();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tRingGeometry.prototype = Object.create( Geometry.prototype );\\r\\n\\tRingGeometry.prototype.constructor = RingGeometry;\\r\\n\\r\\n\\t// RingBufferGeometry\\r\\n\\r\\n\\tfunction RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\\r\\n\\r\\n\\t\\tBufferGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'RingBufferGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tinnerRadius: innerRadius,\\r\\n\\t\\t\\touterRadius: outerRadius,\\r\\n\\t\\t\\tthetaSegments: thetaSegments,\\r\\n\\t\\t\\tphiSegments: phiSegments,\\r\\n\\t\\t\\tthetaStart: thetaStart,\\r\\n\\t\\t\\tthetaLength: thetaLength\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tinnerRadius = innerRadius || 0.5;\\r\\n\\t\\touterRadius = outerRadius || 1;\\r\\n\\r\\n\\t\\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\\r\\n\\t\\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\\r\\n\\r\\n\\t\\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\\r\\n\\t\\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\\r\\n\\r\\n\\t\\t// buffers\\r\\n\\r\\n\\t\\tvar indices = [];\\r\\n\\t\\tvar vertices = [];\\r\\n\\t\\tvar normals = [];\\r\\n\\t\\tvar uvs = [];\\r\\n\\r\\n\\t\\t// some helper variables\\r\\n\\r\\n\\t\\tvar segment;\\r\\n\\t\\tvar radius = innerRadius;\\r\\n\\t\\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\\r\\n\\t\\tvar vertex = new Vector3();\\r\\n\\t\\tvar uv = new Vector2();\\r\\n\\t\\tvar j, i;\\r\\n\\r\\n\\t\\t// generate vertices, normals and uvs\\r\\n\\r\\n\\t\\tfor ( j = 0; j <= phiSegments; j ++ ) {\\r\\n\\r\\n\\t\\t\\tfor ( i = 0; i <= thetaSegments; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t// values are generate from the inside of the ring to the outside\\r\\n\\r\\n\\t\\t\\t\\tsegment = thetaStart + i / thetaSegments * thetaLength;\\r\\n\\r\\n\\t\\t\\t\\t// vertex\\r\\n\\r\\n\\t\\t\\t\\tvertex.x = radius * Math.cos( segment );\\r\\n\\t\\t\\t\\tvertex.y = radius * Math.sin( segment );\\r\\n\\r\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\t\\t// normal\\r\\n\\r\\n\\t\\t\\t\\tnormals.push( 0, 0, 1 );\\r\\n\\r\\n\\t\\t\\t\\t// uv\\r\\n\\r\\n\\t\\t\\t\\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\\r\\n\\t\\t\\t\\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\\r\\n\\r\\n\\t\\t\\t\\tuvs.push( uv.x, uv.y );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// increase the radius for next row of vertices\\r\\n\\r\\n\\t\\t\\tradius += radiusStep;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// indices\\r\\n\\r\\n\\t\\tfor ( j = 0; j < phiSegments; j ++ ) {\\r\\n\\r\\n\\t\\t\\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\\r\\n\\r\\n\\t\\t\\tfor ( i = 0; i < thetaSegments; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tsegment = i + thetaSegmentLevel;\\r\\n\\r\\n\\t\\t\\t\\tvar a = segment;\\r\\n\\t\\t\\t\\tvar b = segment + thetaSegments + 1;\\r\\n\\t\\t\\t\\tvar c = segment + thetaSegments + 2;\\r\\n\\t\\t\\t\\tvar d = segment + 1;\\r\\n\\r\\n\\t\\t\\t\\t// faces\\r\\n\\r\\n\\t\\t\\t\\tindices.push( a, b, d );\\r\\n\\t\\t\\t\\tindices.push( b, c, d );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// build geometry\\r\\n\\r\\n\\t\\tthis.setIndex( indices );\\r\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\r\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tRingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\n\\tRingBufferGeometry.prototype.constructor = RingBufferGeometry;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author astrodud / http://astrodud.isgreat.org/\\r\\n\\t * @author zz85 / https://github.com/zz85\\r\\n\\t * @author bhouston / http://clara.io\\r\\n\\t * @author Mugen87 / https://github.com/Mugen87\\r\\n\\t */\\r\\n\\r\\n\\t// LatheGeometry\\r\\n\\r\\n\\tfunction LatheGeometry( points, segments, phiStart, phiLength ) {\\r\\n\\r\\n\\t\\tGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'LatheGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tpoints: points,\\r\\n\\t\\t\\tsegments: segments,\\r\\n\\t\\t\\tphiStart: phiStart,\\r\\n\\t\\t\\tphiLength: phiLength\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );\\r\\n\\t\\tthis.mergeVertices();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tLatheGeometry.prototype = Object.create( Geometry.prototype );\\r\\n\\tLatheGeometry.prototype.constructor = LatheGeometry;\\r\\n\\r\\n\\t// LatheBufferGeometry\\r\\n\\r\\n\\tfunction LatheBufferGeometry( points, segments, phiStart, phiLength ) {\\r\\n\\r\\n\\t\\tBufferGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'LatheBufferGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tpoints: points,\\r\\n\\t\\t\\tsegments: segments,\\r\\n\\t\\t\\tphiStart: phiStart,\\r\\n\\t\\t\\tphiLength: phiLength\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tsegments = Math.floor( segments ) || 12;\\r\\n\\t\\tphiStart = phiStart || 0;\\r\\n\\t\\tphiLength = phiLength || Math.PI * 2;\\r\\n\\r\\n\\t\\t// clamp phiLength so it's in range of [ 0, 2PI ]\\r\\n\\r\\n\\t\\tphiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );\\r\\n\\r\\n\\r\\n\\t\\t// buffers\\r\\n\\r\\n\\t\\tvar indices = [];\\r\\n\\t\\tvar vertices = [];\\r\\n\\t\\tvar uvs = [];\\r\\n\\r\\n\\t\\t// helper variables\\r\\n\\r\\n\\t\\tvar base;\\r\\n\\t\\tvar inverseSegments = 1.0 / segments;\\r\\n\\t\\tvar vertex = new Vector3();\\r\\n\\t\\tvar uv = new Vector2();\\r\\n\\t\\tvar i, j;\\r\\n\\r\\n\\t\\t// generate vertices and uvs\\r\\n\\r\\n\\t\\tfor ( i = 0; i <= segments; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar phi = phiStart + i * inverseSegments * phiLength;\\r\\n\\r\\n\\t\\t\\tvar sin = Math.sin( phi );\\r\\n\\t\\t\\tvar cos = Math.cos( phi );\\r\\n\\r\\n\\t\\t\\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t// vertex\\r\\n\\r\\n\\t\\t\\t\\tvertex.x = points[ j ].x * sin;\\r\\n\\t\\t\\t\\tvertex.y = points[ j ].y;\\r\\n\\t\\t\\t\\tvertex.z = points[ j ].x * cos;\\r\\n\\r\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\t\\t// uv\\r\\n\\r\\n\\t\\t\\t\\tuv.x = i / segments;\\r\\n\\t\\t\\t\\tuv.y = j / ( points.length - 1 );\\r\\n\\r\\n\\t\\t\\t\\tuvs.push( uv.x, uv.y );\\r\\n\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// indices\\r\\n\\r\\n\\t\\tfor ( i = 0; i < segments; i ++ ) {\\r\\n\\r\\n\\t\\t\\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tbase = j + i * points.length;\\r\\n\\r\\n\\t\\t\\t\\tvar a = base;\\r\\n\\t\\t\\t\\tvar b = base + points.length;\\r\\n\\t\\t\\t\\tvar c = base + points.length + 1;\\r\\n\\t\\t\\t\\tvar d = base + 1;\\r\\n\\r\\n\\t\\t\\t\\t// faces\\r\\n\\r\\n\\t\\t\\t\\tindices.push( a, b, d );\\r\\n\\t\\t\\t\\tindices.push( b, c, d );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// build geometry\\r\\n\\r\\n\\t\\tthis.setIndex( indices );\\r\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\r\\n\\r\\n\\t\\t// generate normals\\r\\n\\r\\n\\t\\tthis.computeVertexNormals();\\r\\n\\r\\n\\t\\t// if the geometry is closed, we need to average the normals along the seam.\\r\\n\\t\\t// because the corresponding vertices are identical (but still have different UVs).\\r\\n\\r\\n\\t\\tif ( phiLength === Math.PI * 2 ) {\\r\\n\\r\\n\\t\\t\\tvar normals = this.attributes.normal.array;\\r\\n\\t\\t\\tvar n1 = new Vector3();\\r\\n\\t\\t\\tvar n2 = new Vector3();\\r\\n\\t\\t\\tvar n = new Vector3();\\r\\n\\r\\n\\t\\t\\t// this is the buffer offset for the last line of vertices\\r\\n\\r\\n\\t\\t\\tbase = segments * points.length * 3;\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\\r\\n\\r\\n\\t\\t\\t\\t// select the normal of the vertex in the first line\\r\\n\\r\\n\\t\\t\\t\\tn1.x = normals[ j + 0 ];\\r\\n\\t\\t\\t\\tn1.y = normals[ j + 1 ];\\r\\n\\t\\t\\t\\tn1.z = normals[ j + 2 ];\\r\\n\\r\\n\\t\\t\\t\\t// select the normal of the vertex in the last line\\r\\n\\r\\n\\t\\t\\t\\tn2.x = normals[ base + j + 0 ];\\r\\n\\t\\t\\t\\tn2.y = normals[ base + j + 1 ];\\r\\n\\t\\t\\t\\tn2.z = normals[ base + j + 2 ];\\r\\n\\r\\n\\t\\t\\t\\t// average normals\\r\\n\\r\\n\\t\\t\\t\\tn.addVectors( n1, n2 ).normalize();\\r\\n\\r\\n\\t\\t\\t\\t// assign the new values to both normals\\r\\n\\r\\n\\t\\t\\t\\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\\r\\n\\t\\t\\t\\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\\r\\n\\t\\t\\t\\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tLatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\n\\tLatheBufferGeometry.prototype.constructor = LatheBufferGeometry;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author jonobr1 / http://jonobr1.com\\r\\n\\t * @author Mugen87 / https://github.com/Mugen87\\r\\n\\t */\\r\\n\\r\\n\\t// ShapeGeometry\\r\\n\\r\\n\\tfunction ShapeGeometry( shapes, curveSegments ) {\\r\\n\\r\\n\\t\\tGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'ShapeGeometry';\\r\\n\\r\\n\\t\\tif ( typeof curveSegments === 'object' ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );\\r\\n\\r\\n\\t\\t\\tcurveSegments = curveSegments.curveSegments;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tshapes: shapes,\\r\\n\\t\\t\\tcurveSegments: curveSegments\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );\\r\\n\\t\\tthis.mergeVertices();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tShapeGeometry.prototype = Object.create( Geometry.prototype );\\r\\n\\tShapeGeometry.prototype.constructor = ShapeGeometry;\\r\\n\\r\\n\\tShapeGeometry.prototype.toJSON = function () {\\r\\n\\r\\n\\t\\tvar data = Geometry.prototype.toJSON.call( this );\\r\\n\\r\\n\\t\\tvar shapes = this.parameters.shapes;\\r\\n\\r\\n\\t\\treturn toJSON( shapes, data );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t// ShapeBufferGeometry\\r\\n\\r\\n\\tfunction ShapeBufferGeometry( shapes, curveSegments ) {\\r\\n\\r\\n\\t\\tBufferGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'ShapeBufferGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tshapes: shapes,\\r\\n\\t\\t\\tcurveSegments: curveSegments\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tcurveSegments = curveSegments || 12;\\r\\n\\r\\n\\t\\t// buffers\\r\\n\\r\\n\\t\\tvar indices = [];\\r\\n\\t\\tvar vertices = [];\\r\\n\\t\\tvar normals = [];\\r\\n\\t\\tvar uvs = [];\\r\\n\\r\\n\\t\\t// helper variables\\r\\n\\r\\n\\t\\tvar groupStart = 0;\\r\\n\\t\\tvar groupCount = 0;\\r\\n\\r\\n\\t\\t// allow single and array values for \\\"shapes\\\" parameter\\r\\n\\r\\n\\t\\tif ( Array.isArray( shapes ) === false ) {\\r\\n\\r\\n\\t\\t\\taddShape( shapes );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < shapes.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\taddShape( shapes[ i ] );\\r\\n\\r\\n\\t\\t\\t\\tthis.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support\\r\\n\\r\\n\\t\\t\\t\\tgroupStart += groupCount;\\r\\n\\t\\t\\t\\tgroupCount = 0;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// build geometry\\r\\n\\r\\n\\t\\tthis.setIndex( indices );\\r\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\r\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\r\\n\\r\\n\\r\\n\\t\\t// helper functions\\r\\n\\r\\n\\t\\tfunction addShape( shape ) {\\r\\n\\r\\n\\t\\t\\tvar i, l, shapeHole;\\r\\n\\r\\n\\t\\t\\tvar indexOffset = vertices.length / 3;\\r\\n\\t\\t\\tvar points = shape.extractPoints( curveSegments );\\r\\n\\r\\n\\t\\t\\tvar shapeVertices = points.shape;\\r\\n\\t\\t\\tvar shapeHoles = points.holes;\\r\\n\\r\\n\\t\\t\\t// check direction of vertices\\r\\n\\r\\n\\t\\t\\tif ( ShapeUtils.isClockWise( shapeVertices ) === false ) {\\r\\n\\r\\n\\t\\t\\t\\tshapeVertices = shapeVertices.reverse();\\r\\n\\r\\n\\t\\t\\t\\t// also check if holes are in the opposite direction\\r\\n\\r\\n\\t\\t\\t\\tfor ( i = 0, l = shapeHoles.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tshapeHole = shapeHoles[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( ShapeUtils.isClockWise( shapeHole ) === true ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tshapeHoles[ i ] = shapeHole.reverse();\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );\\r\\n\\r\\n\\t\\t\\t// join vertices of inner and outer paths to a single array\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, l = shapeHoles.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tshapeHole = shapeHoles[ i ];\\r\\n\\t\\t\\t\\tshapeVertices = shapeVertices.concat( shapeHole );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// vertices, normals, uvs\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, l = shapeVertices.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar vertex = shapeVertices[ i ];\\r\\n\\r\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, 0 );\\r\\n\\t\\t\\t\\tnormals.push( 0, 0, 1 );\\r\\n\\t\\t\\t\\tuvs.push( vertex.x, vertex.y ); // world uvs\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// incides\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, l = faces.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar face = faces[ i ];\\r\\n\\r\\n\\t\\t\\t\\tvar a = face[ 0 ] + indexOffset;\\r\\n\\t\\t\\t\\tvar b = face[ 1 ] + indexOffset;\\r\\n\\t\\t\\t\\tvar c = face[ 2 ] + indexOffset;\\r\\n\\r\\n\\t\\t\\t\\tindices.push( a, b, c );\\r\\n\\t\\t\\t\\tgroupCount += 3;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\n\\tShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;\\r\\n\\r\\n\\tShapeBufferGeometry.prototype.toJSON = function () {\\r\\n\\r\\n\\t\\tvar data = BufferGeometry.prototype.toJSON.call( this );\\r\\n\\r\\n\\t\\tvar shapes = this.parameters.shapes;\\r\\n\\r\\n\\t\\treturn toJSON( shapes, data );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tfunction toJSON( shapes, data ) {\\r\\n\\r\\n\\t\\tdata.shapes = [];\\r\\n\\r\\n\\t\\tif ( Array.isArray( shapes ) ) {\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar shape = shapes[ i ];\\r\\n\\r\\n\\t\\t\\t\\tdata.shapes.push( shape.uuid );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tdata.shapes.push( shapes.uuid );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn data;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @author WestLangley / http://github.com/WestLangley\\r\\n\\t * @author Mugen87 / https://github.com/Mugen87\\r\\n\\t */\\r\\n\\r\\n\\tfunction EdgesGeometry( geometry, thresholdAngle ) {\\r\\n\\r\\n\\t\\tBufferGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'EdgesGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tthresholdAngle: thresholdAngle\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\\r\\n\\r\\n\\t\\t// buffer\\r\\n\\r\\n\\t\\tvar vertices = [];\\r\\n\\r\\n\\t\\t// helper variables\\r\\n\\r\\n\\t\\tvar thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );\\r\\n\\t\\tvar edge = [ 0, 0 ], edges = {}, edge1, edge2;\\r\\n\\t\\tvar key, keys = [ 'a', 'b', 'c' ];\\r\\n\\r\\n\\t\\t// prepare source geometry\\r\\n\\r\\n\\t\\tvar geometry2;\\r\\n\\r\\n\\t\\tif ( geometry.isBufferGeometry ) {\\r\\n\\r\\n\\t\\t\\tgeometry2 = new Geometry();\\r\\n\\t\\t\\tgeometry2.fromBufferGeometry( geometry );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tgeometry2 = geometry.clone();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tgeometry2.mergeVertices();\\r\\n\\t\\tgeometry2.computeFaceNormals();\\r\\n\\r\\n\\t\\tvar sourceVertices = geometry2.vertices;\\r\\n\\t\\tvar faces = geometry2.faces;\\r\\n\\r\\n\\t\\t// now create a data structure where each entry represents an edge with its adjoining faces\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar face = faces[ i ];\\r\\n\\r\\n\\t\\t\\tfor ( var j = 0; j < 3; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tedge1 = face[ keys[ j ] ];\\r\\n\\t\\t\\t\\tedge2 = face[ keys[ ( j + 1 ) % 3 ] ];\\r\\n\\t\\t\\t\\tedge[ 0 ] = Math.min( edge1, edge2 );\\r\\n\\t\\t\\t\\tedge[ 1 ] = Math.max( edge1, edge2 );\\r\\n\\r\\n\\t\\t\\t\\tkey = edge[ 0 ] + ',' + edge[ 1 ];\\r\\n\\r\\n\\t\\t\\t\\tif ( edges[ key ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tedges[ key ].face2 = i;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// generate vertices\\r\\n\\r\\n\\t\\tfor ( key in edges ) {\\r\\n\\r\\n\\t\\t\\tvar e = edges[ key ];\\r\\n\\r\\n\\t\\t\\t// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.\\r\\n\\r\\n\\t\\t\\tif ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {\\r\\n\\r\\n\\t\\t\\t\\tvar vertex = sourceVertices[ e.index1 ];\\r\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\t\\tvertex = sourceVertices[ e.index2 ];\\r\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// build geometry\\r\\n\\r\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tEdgesGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\n\\tEdgesGeometry.prototype.constructor = EdgesGeometry;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author Mugen87 / https://github.com/Mugen87\\r\\n\\t */\\r\\n\\r\\n\\t// CylinderGeometry\\r\\n\\r\\n\\tfunction CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\\r\\n\\r\\n\\t\\tGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'CylinderGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tradiusTop: radiusTop,\\r\\n\\t\\t\\tradiusBottom: radiusBottom,\\r\\n\\t\\t\\theight: height,\\r\\n\\t\\t\\tradialSegments: radialSegments,\\r\\n\\t\\t\\theightSegments: heightSegments,\\r\\n\\t\\t\\topenEnded: openEnded,\\r\\n\\t\\t\\tthetaStart: thetaStart,\\r\\n\\t\\t\\tthetaLength: thetaLength\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\\r\\n\\t\\tthis.mergeVertices();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tCylinderGeometry.prototype = Object.create( Geometry.prototype );\\r\\n\\tCylinderGeometry.prototype.constructor = CylinderGeometry;\\r\\n\\r\\n\\t// CylinderBufferGeometry\\r\\n\\r\\n\\tfunction CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\\r\\n\\r\\n\\t\\tBufferGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'CylinderBufferGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tradiusTop: radiusTop,\\r\\n\\t\\t\\tradiusBottom: radiusBottom,\\r\\n\\t\\t\\theight: height,\\r\\n\\t\\t\\tradialSegments: radialSegments,\\r\\n\\t\\t\\theightSegments: heightSegments,\\r\\n\\t\\t\\topenEnded: openEnded,\\r\\n\\t\\t\\tthetaStart: thetaStart,\\r\\n\\t\\t\\tthetaLength: thetaLength\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\tradiusTop = radiusTop !== undefined ? radiusTop : 1;\\r\\n\\t\\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 1;\\r\\n\\t\\theight = height || 1;\\r\\n\\r\\n\\t\\tradialSegments = Math.floor( radialSegments ) || 8;\\r\\n\\t\\theightSegments = Math.floor( heightSegments ) || 1;\\r\\n\\r\\n\\t\\topenEnded = openEnded !== undefined ? openEnded : false;\\r\\n\\t\\tthetaStart = thetaStart !== undefined ? thetaStart : 0.0;\\r\\n\\t\\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\\r\\n\\r\\n\\t\\t// buffers\\r\\n\\r\\n\\t\\tvar indices = [];\\r\\n\\t\\tvar vertices = [];\\r\\n\\t\\tvar normals = [];\\r\\n\\t\\tvar uvs = [];\\r\\n\\r\\n\\t\\t// helper variables\\r\\n\\r\\n\\t\\tvar index = 0;\\r\\n\\t\\tvar indexArray = [];\\r\\n\\t\\tvar halfHeight = height / 2;\\r\\n\\t\\tvar groupStart = 0;\\r\\n\\r\\n\\t\\t// generate geometry\\r\\n\\r\\n\\t\\tgenerateTorso();\\r\\n\\r\\n\\t\\tif ( openEnded === false ) {\\r\\n\\r\\n\\t\\t\\tif ( radiusTop > 0 ) generateCap( true );\\r\\n\\t\\t\\tif ( radiusBottom > 0 ) generateCap( false );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// build geometry\\r\\n\\r\\n\\t\\tthis.setIndex( indices );\\r\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\r\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\r\\n\\r\\n\\t\\tfunction generateTorso() {\\r\\n\\r\\n\\t\\t\\tvar x, y;\\r\\n\\t\\t\\tvar normal = new Vector3();\\r\\n\\t\\t\\tvar vertex = new Vector3();\\r\\n\\r\\n\\t\\t\\tvar groupCount = 0;\\r\\n\\r\\n\\t\\t\\t// this will be used to calculate the normal\\r\\n\\t\\t\\tvar slope = ( radiusBottom - radiusTop ) / height;\\r\\n\\r\\n\\t\\t\\t// generate vertices, normals and uvs\\r\\n\\r\\n\\t\\t\\tfor ( y = 0; y <= heightSegments; y ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar indexRow = [];\\r\\n\\r\\n\\t\\t\\t\\tvar v = y / heightSegments;\\r\\n\\r\\n\\t\\t\\t\\t// calculate the radius of the current row\\r\\n\\r\\n\\t\\t\\t\\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\\r\\n\\r\\n\\t\\t\\t\\tfor ( x = 0; x <= radialSegments; x ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar u = x / radialSegments;\\r\\n\\r\\n\\t\\t\\t\\t\\tvar theta = u * thetaLength + thetaStart;\\r\\n\\r\\n\\t\\t\\t\\t\\tvar sinTheta = Math.sin( theta );\\r\\n\\t\\t\\t\\t\\tvar cosTheta = Math.cos( theta );\\r\\n\\r\\n\\t\\t\\t\\t\\t// vertex\\r\\n\\r\\n\\t\\t\\t\\t\\tvertex.x = radius * sinTheta;\\r\\n\\t\\t\\t\\t\\tvertex.y = - v * height + halfHeight;\\r\\n\\t\\t\\t\\t\\tvertex.z = radius * cosTheta;\\r\\n\\t\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\t\\t\\t// normal\\r\\n\\r\\n\\t\\t\\t\\t\\tnormal.set( sinTheta, slope, cosTheta ).normalize();\\r\\n\\t\\t\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\r\\n\\r\\n\\t\\t\\t\\t\\t// uv\\r\\n\\r\\n\\t\\t\\t\\t\\tuvs.push( u, 1 - v );\\r\\n\\r\\n\\t\\t\\t\\t\\t// save index of vertex in respective row\\r\\n\\r\\n\\t\\t\\t\\t\\tindexRow.push( index ++ );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// now save vertices of the row in our index array\\r\\n\\r\\n\\t\\t\\t\\tindexArray.push( indexRow );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// generate indices\\r\\n\\r\\n\\t\\t\\tfor ( x = 0; x < radialSegments; x ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( y = 0; y < heightSegments; y ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// we use the index array to access the correct indices\\r\\n\\r\\n\\t\\t\\t\\t\\tvar a = indexArray[ y ][ x ];\\r\\n\\t\\t\\t\\t\\tvar b = indexArray[ y + 1 ][ x ];\\r\\n\\t\\t\\t\\t\\tvar c = indexArray[ y + 1 ][ x + 1 ];\\r\\n\\t\\t\\t\\t\\tvar d = indexArray[ y ][ x + 1 ];\\r\\n\\r\\n\\t\\t\\t\\t\\t// faces\\r\\n\\r\\n\\t\\t\\t\\t\\tindices.push( a, b, d );\\r\\n\\t\\t\\t\\t\\tindices.push( b, c, d );\\r\\n\\r\\n\\t\\t\\t\\t\\t// update group counter\\r\\n\\r\\n\\t\\t\\t\\t\\tgroupCount += 6;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// add a group to the geometry. this will ensure multi material support\\r\\n\\r\\n\\t\\t\\tscope.addGroup( groupStart, groupCount, 0 );\\r\\n\\r\\n\\t\\t\\t// calculate new start value for groups\\r\\n\\r\\n\\t\\t\\tgroupStart += groupCount;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction generateCap( top ) {\\r\\n\\r\\n\\t\\t\\tvar x, centerIndexStart, centerIndexEnd;\\r\\n\\r\\n\\t\\t\\tvar uv = new Vector2();\\r\\n\\t\\t\\tvar vertex = new Vector3();\\r\\n\\r\\n\\t\\t\\tvar groupCount = 0;\\r\\n\\r\\n\\t\\t\\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\\r\\n\\t\\t\\tvar sign = ( top === true ) ? 1 : - 1;\\r\\n\\r\\n\\t\\t\\t// save the index of the first center vertex\\r\\n\\t\\t\\tcenterIndexStart = index;\\r\\n\\r\\n\\t\\t\\t// first we generate the center vertex data of the cap.\\r\\n\\t\\t\\t// because the geometry needs one set of uvs per face,\\r\\n\\t\\t\\t// we must generate a center vertex per face/segment\\r\\n\\r\\n\\t\\t\\tfor ( x = 1; x <= radialSegments; x ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t// vertex\\r\\n\\r\\n\\t\\t\\t\\tvertices.push( 0, halfHeight * sign, 0 );\\r\\n\\r\\n\\t\\t\\t\\t// normal\\r\\n\\r\\n\\t\\t\\t\\tnormals.push( 0, sign, 0 );\\r\\n\\r\\n\\t\\t\\t\\t// uv\\r\\n\\r\\n\\t\\t\\t\\tuvs.push( 0.5, 0.5 );\\r\\n\\r\\n\\t\\t\\t\\t// increase index\\r\\n\\r\\n\\t\\t\\t\\tindex ++;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// save the index of the last center vertex\\r\\n\\r\\n\\t\\t\\tcenterIndexEnd = index;\\r\\n\\r\\n\\t\\t\\t// now we generate the surrounding vertices, normals and uvs\\r\\n\\r\\n\\t\\t\\tfor ( x = 0; x <= radialSegments; x ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar u = x / radialSegments;\\r\\n\\t\\t\\t\\tvar theta = u * thetaLength + thetaStart;\\r\\n\\r\\n\\t\\t\\t\\tvar cosTheta = Math.cos( theta );\\r\\n\\t\\t\\t\\tvar sinTheta = Math.sin( theta );\\r\\n\\r\\n\\t\\t\\t\\t// vertex\\r\\n\\r\\n\\t\\t\\t\\tvertex.x = radius * sinTheta;\\r\\n\\t\\t\\t\\tvertex.y = halfHeight * sign;\\r\\n\\t\\t\\t\\tvertex.z = radius * cosTheta;\\r\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\t\\t// normal\\r\\n\\r\\n\\t\\t\\t\\tnormals.push( 0, sign, 0 );\\r\\n\\r\\n\\t\\t\\t\\t// uv\\r\\n\\r\\n\\t\\t\\t\\tuv.x = ( cosTheta * 0.5 ) + 0.5;\\r\\n\\t\\t\\t\\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\\r\\n\\t\\t\\t\\tuvs.push( uv.x, uv.y );\\r\\n\\r\\n\\t\\t\\t\\t// increase index\\r\\n\\r\\n\\t\\t\\t\\tindex ++;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// generate indices\\r\\n\\r\\n\\t\\t\\tfor ( x = 0; x < radialSegments; x ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar c = centerIndexStart + x;\\r\\n\\t\\t\\t\\tvar i = centerIndexEnd + x;\\r\\n\\r\\n\\t\\t\\t\\tif ( top === true ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// face top\\r\\n\\r\\n\\t\\t\\t\\t\\tindices.push( i, i + 1, c );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t// face bottom\\r\\n\\r\\n\\t\\t\\t\\t\\tindices.push( i + 1, i, c );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tgroupCount += 3;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// add a group to the geometry. this will ensure multi material support\\r\\n\\r\\n\\t\\t\\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\\r\\n\\r\\n\\t\\t\\t// calculate new start value for groups\\r\\n\\r\\n\\t\\t\\tgroupStart += groupCount;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tCylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\n\\tCylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author abelnation / http://github.com/abelnation\\r\\n\\t */\\r\\n\\r\\n\\t// ConeGeometry\\r\\n\\r\\n\\tfunction ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\\r\\n\\r\\n\\t\\tCylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\\r\\n\\r\\n\\t\\tthis.type = 'ConeGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tradius: radius,\\r\\n\\t\\t\\theight: height,\\r\\n\\t\\t\\tradialSegments: radialSegments,\\r\\n\\t\\t\\theightSegments: heightSegments,\\r\\n\\t\\t\\topenEnded: openEnded,\\r\\n\\t\\t\\tthetaStart: thetaStart,\\r\\n\\t\\t\\tthetaLength: thetaLength\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tConeGeometry.prototype = Object.create( CylinderGeometry.prototype );\\r\\n\\tConeGeometry.prototype.constructor = ConeGeometry;\\r\\n\\r\\n\\t// ConeBufferGeometry\\r\\n\\r\\n\\tfunction ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\\r\\n\\r\\n\\t\\tCylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\\r\\n\\r\\n\\t\\tthis.type = 'ConeBufferGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tradius: radius,\\r\\n\\t\\t\\theight: height,\\r\\n\\t\\t\\tradialSegments: radialSegments,\\r\\n\\t\\t\\theightSegments: heightSegments,\\r\\n\\t\\t\\topenEnded: openEnded,\\r\\n\\t\\t\\tthetaStart: thetaStart,\\r\\n\\t\\t\\tthetaLength: thetaLength\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );\\r\\n\\tConeBufferGeometry.prototype.constructor = ConeBufferGeometry;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author benaadams / https://twitter.com/ben_a_adams\\r\\n\\t * @author Mugen87 / https://github.com/Mugen87\\r\\n\\t * @author hughes\\r\\n\\t */\\r\\n\\r\\n\\t// CircleGeometry\\r\\n\\r\\n\\tfunction CircleGeometry( radius, segments, thetaStart, thetaLength ) {\\r\\n\\r\\n\\t\\tGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'CircleGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tradius: radius,\\r\\n\\t\\t\\tsegments: segments,\\r\\n\\t\\t\\tthetaStart: thetaStart,\\r\\n\\t\\t\\tthetaLength: thetaLength\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\\r\\n\\t\\tthis.mergeVertices();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tCircleGeometry.prototype = Object.create( Geometry.prototype );\\r\\n\\tCircleGeometry.prototype.constructor = CircleGeometry;\\r\\n\\r\\n\\t// CircleBufferGeometry\\r\\n\\r\\n\\tfunction CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {\\r\\n\\r\\n\\t\\tBufferGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'CircleBufferGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\tradius: radius,\\r\\n\\t\\t\\tsegments: segments,\\r\\n\\t\\t\\tthetaStart: thetaStart,\\r\\n\\t\\t\\tthetaLength: thetaLength\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tradius = radius || 1;\\r\\n\\t\\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\\r\\n\\r\\n\\t\\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\\r\\n\\t\\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\\r\\n\\r\\n\\t\\t// buffers\\r\\n\\r\\n\\t\\tvar indices = [];\\r\\n\\t\\tvar vertices = [];\\r\\n\\t\\tvar normals = [];\\r\\n\\t\\tvar uvs = [];\\r\\n\\r\\n\\t\\t// helper variables\\r\\n\\r\\n\\t\\tvar i, s;\\r\\n\\t\\tvar vertex = new Vector3();\\r\\n\\t\\tvar uv = new Vector2();\\r\\n\\r\\n\\t\\t// center point\\r\\n\\r\\n\\t\\tvertices.push( 0, 0, 0 );\\r\\n\\t\\tnormals.push( 0, 0, 1 );\\r\\n\\t\\tuvs.push( 0.5, 0.5 );\\r\\n\\r\\n\\t\\tfor ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {\\r\\n\\r\\n\\t\\t\\tvar segment = thetaStart + s / segments * thetaLength;\\r\\n\\r\\n\\t\\t\\t// vertex\\r\\n\\r\\n\\t\\t\\tvertex.x = radius * Math.cos( segment );\\r\\n\\t\\t\\tvertex.y = radius * Math.sin( segment );\\r\\n\\r\\n\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\t// normal\\r\\n\\r\\n\\t\\t\\tnormals.push( 0, 0, 1 );\\r\\n\\r\\n\\t\\t\\t// uvs\\r\\n\\r\\n\\t\\t\\tuv.x = ( vertices[ i ] / radius + 1 ) / 2;\\r\\n\\t\\t\\tuv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;\\r\\n\\r\\n\\t\\t\\tuvs.push( uv.x, uv.y );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// indices\\r\\n\\r\\n\\t\\tfor ( i = 1; i <= segments; i ++ ) {\\r\\n\\r\\n\\t\\t\\tindices.push( i, i + 1, 0 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// build geometry\\r\\n\\r\\n\\t\\tthis.setIndex( indices );\\r\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\r\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tCircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\n\\tCircleBufferGeometry.prototype.constructor = CircleBufferGeometry;\\r\\n\\r\\n\\r\\n\\r\\n\\tvar Geometries = Object.freeze({\\r\\n\\t\\tWireframeGeometry: WireframeGeometry,\\r\\n\\t\\tParametricGeometry: ParametricGeometry,\\r\\n\\t\\tParametricBufferGeometry: ParametricBufferGeometry,\\r\\n\\t\\tTetrahedronGeometry: TetrahedronGeometry,\\r\\n\\t\\tTetrahedronBufferGeometry: TetrahedronBufferGeometry,\\r\\n\\t\\tOctahedronGeometry: OctahedronGeometry,\\r\\n\\t\\tOctahedronBufferGeometry: OctahedronBufferGeometry,\\r\\n\\t\\tIcosahedronGeometry: IcosahedronGeometry,\\r\\n\\t\\tIcosahedronBufferGeometry: IcosahedronBufferGeometry,\\r\\n\\t\\tDodecahedronGeometry: DodecahedronGeometry,\\r\\n\\t\\tDodecahedronBufferGeometry: DodecahedronBufferGeometry,\\r\\n\\t\\tPolyhedronGeometry: PolyhedronGeometry,\\r\\n\\t\\tPolyhedronBufferGeometry: PolyhedronBufferGeometry,\\r\\n\\t\\tTubeGeometry: TubeGeometry,\\r\\n\\t\\tTubeBufferGeometry: TubeBufferGeometry,\\r\\n\\t\\tTorusKnotGeometry: TorusKnotGeometry,\\r\\n\\t\\tTorusKnotBufferGeometry: TorusKnotBufferGeometry,\\r\\n\\t\\tTorusGeometry: TorusGeometry,\\r\\n\\t\\tTorusBufferGeometry: TorusBufferGeometry,\\r\\n\\t\\tTextGeometry: TextGeometry,\\r\\n\\t\\tTextBufferGeometry: TextBufferGeometry,\\r\\n\\t\\tSphereGeometry: SphereGeometry,\\r\\n\\t\\tSphereBufferGeometry: SphereBufferGeometry,\\r\\n\\t\\tRingGeometry: RingGeometry,\\r\\n\\t\\tRingBufferGeometry: RingBufferGeometry,\\r\\n\\t\\tPlaneGeometry: PlaneGeometry,\\r\\n\\t\\tPlaneBufferGeometry: PlaneBufferGeometry,\\r\\n\\t\\tLatheGeometry: LatheGeometry,\\r\\n\\t\\tLatheBufferGeometry: LatheBufferGeometry,\\r\\n\\t\\tShapeGeometry: ShapeGeometry,\\r\\n\\t\\tShapeBufferGeometry: ShapeBufferGeometry,\\r\\n\\t\\tExtrudeGeometry: ExtrudeGeometry,\\r\\n\\t\\tExtrudeBufferGeometry: ExtrudeBufferGeometry,\\r\\n\\t\\tEdgesGeometry: EdgesGeometry,\\r\\n\\t\\tConeGeometry: ConeGeometry,\\r\\n\\t\\tConeBufferGeometry: ConeBufferGeometry,\\r\\n\\t\\tCylinderGeometry: CylinderGeometry,\\r\\n\\t\\tCylinderBufferGeometry: CylinderBufferGeometry,\\r\\n\\t\\tCircleGeometry: CircleGeometry,\\r\\n\\t\\tCircleBufferGeometry: CircleBufferGeometry,\\r\\n\\t\\tBoxGeometry: BoxGeometry,\\r\\n\\t\\tBoxBufferGeometry: BoxBufferGeometry\\r\\n\\t});\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t *\\r\\n\\t * parameters = {\\r\\n\\t *  color: <THREE.Color>,\\r\\n\\t *  opacity: <float>\\r\\n\\t * }\\r\\n\\t */\\r\\n\\r\\n\\tfunction ShadowMaterial( parameters ) {\\r\\n\\r\\n\\t\\tMaterial.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'ShadowMaterial';\\r\\n\\r\\n\\t\\tthis.color = new Color( 0x000000 );\\r\\n\\t\\tthis.opacity = 1.0;\\r\\n\\r\\n\\t\\tthis.lights = true;\\r\\n\\t\\tthis.transparent = true;\\r\\n\\r\\n\\t\\tthis.setValues( parameters );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tShadowMaterial.prototype = Object.create( Material.prototype );\\r\\n\\tShadowMaterial.prototype.constructor = ShadowMaterial;\\r\\n\\r\\n\\tShadowMaterial.prototype.isShadowMaterial = true;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction RawShaderMaterial( parameters ) {\\r\\n\\r\\n\\t\\tShaderMaterial.call( this, parameters );\\r\\n\\r\\n\\t\\tthis.type = 'RawShaderMaterial';\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tRawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );\\r\\n\\tRawShaderMaterial.prototype.constructor = RawShaderMaterial;\\r\\n\\r\\n\\tRawShaderMaterial.prototype.isRawShaderMaterial = true;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author WestLangley / http://github.com/WestLangley\\r\\n\\t *\\r\\n\\t * parameters = {\\r\\n\\t *  color: <hex>,\\r\\n\\t *  roughness: <float>,\\r\\n\\t *  metalness: <float>,\\r\\n\\t *  opacity: <float>,\\r\\n\\t *\\r\\n\\t *  map: new THREE.Texture( <Image> ),\\r\\n\\t *\\r\\n\\t *  lightMap: new THREE.Texture( <Image> ),\\r\\n\\t *  lightMapIntensity: <float>\\r\\n\\t *\\r\\n\\t *  aoMap: new THREE.Texture( <Image> ),\\r\\n\\t *  aoMapIntensity: <float>\\r\\n\\t *\\r\\n\\t *  emissive: <hex>,\\r\\n\\t *  emissiveIntensity: <float>\\r\\n\\t *  emissiveMap: new THREE.Texture( <Image> ),\\r\\n\\t *\\r\\n\\t *  bumpMap: new THREE.Texture( <Image> ),\\r\\n\\t *  bumpScale: <float>,\\r\\n\\t *\\r\\n\\t *  normalMap: new THREE.Texture( <Image> ),\\r\\n\\t *  normalScale: <Vector2>,\\r\\n\\t *\\r\\n\\t *  displacementMap: new THREE.Texture( <Image> ),\\r\\n\\t *  displacementScale: <float>,\\r\\n\\t *  displacementBias: <float>,\\r\\n\\t *\\r\\n\\t *  roughnessMap: new THREE.Texture( <Image> ),\\r\\n\\t *\\r\\n\\t *  metalnessMap: new THREE.Texture( <Image> ),\\r\\n\\t *\\r\\n\\t *  alphaMap: new THREE.Texture( <Image> ),\\r\\n\\t *\\r\\n\\t *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\\r\\n\\t *  envMapIntensity: <float>\\r\\n\\t *\\r\\n\\t *  refractionRatio: <float>,\\r\\n\\t *\\r\\n\\t *  wireframe: <boolean>,\\r\\n\\t *  wireframeLinewidth: <float>,\\r\\n\\t *\\r\\n\\t *  skinning: <bool>,\\r\\n\\t *  morphTargets: <bool>,\\r\\n\\t *  morphNormals: <bool>\\r\\n\\t * }\\r\\n\\t */\\r\\n\\r\\n\\tfunction MeshStandardMaterial( parameters ) {\\r\\n\\r\\n\\t\\tMaterial.call( this );\\r\\n\\r\\n\\t\\tthis.defines = { 'STANDARD': '' };\\r\\n\\r\\n\\t\\tthis.type = 'MeshStandardMaterial';\\r\\n\\r\\n\\t\\tthis.color = new Color( 0xffffff ); // diffuse\\r\\n\\t\\tthis.roughness = 0.5;\\r\\n\\t\\tthis.metalness = 0.5;\\r\\n\\r\\n\\t\\tthis.map = null;\\r\\n\\r\\n\\t\\tthis.lightMap = null;\\r\\n\\t\\tthis.lightMapIntensity = 1.0;\\r\\n\\r\\n\\t\\tthis.aoMap = null;\\r\\n\\t\\tthis.aoMapIntensity = 1.0;\\r\\n\\r\\n\\t\\tthis.emissive = new Color( 0x000000 );\\r\\n\\t\\tthis.emissiveIntensity = 1.0;\\r\\n\\t\\tthis.emissiveMap = null;\\r\\n\\r\\n\\t\\tthis.bumpMap = null;\\r\\n\\t\\tthis.bumpScale = 1;\\r\\n\\r\\n\\t\\tthis.normalMap = null;\\r\\n\\t\\tthis.normalScale = new Vector2( 1, 1 );\\r\\n\\r\\n\\t\\tthis.displacementMap = null;\\r\\n\\t\\tthis.displacementScale = 1;\\r\\n\\t\\tthis.displacementBias = 0;\\r\\n\\r\\n\\t\\tthis.roughnessMap = null;\\r\\n\\r\\n\\t\\tthis.metalnessMap = null;\\r\\n\\r\\n\\t\\tthis.alphaMap = null;\\r\\n\\r\\n\\t\\tthis.envMap = null;\\r\\n\\t\\tthis.envMapIntensity = 1.0;\\r\\n\\r\\n\\t\\tthis.refractionRatio = 0.98;\\r\\n\\r\\n\\t\\tthis.wireframe = false;\\r\\n\\t\\tthis.wireframeLinewidth = 1;\\r\\n\\t\\tthis.wireframeLinecap = 'round';\\r\\n\\t\\tthis.wireframeLinejoin = 'round';\\r\\n\\r\\n\\t\\tthis.skinning = false;\\r\\n\\t\\tthis.morphTargets = false;\\r\\n\\t\\tthis.morphNormals = false;\\r\\n\\r\\n\\t\\tthis.setValues( parameters );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tMeshStandardMaterial.prototype = Object.create( Material.prototype );\\r\\n\\tMeshStandardMaterial.prototype.constructor = MeshStandardMaterial;\\r\\n\\r\\n\\tMeshStandardMaterial.prototype.isMeshStandardMaterial = true;\\r\\n\\r\\n\\tMeshStandardMaterial.prototype.copy = function ( source ) {\\r\\n\\r\\n\\t\\tMaterial.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.defines = { 'STANDARD': '' };\\r\\n\\r\\n\\t\\tthis.color.copy( source.color );\\r\\n\\t\\tthis.roughness = source.roughness;\\r\\n\\t\\tthis.metalness = source.metalness;\\r\\n\\r\\n\\t\\tthis.map = source.map;\\r\\n\\r\\n\\t\\tthis.lightMap = source.lightMap;\\r\\n\\t\\tthis.lightMapIntensity = source.lightMapIntensity;\\r\\n\\r\\n\\t\\tthis.aoMap = source.aoMap;\\r\\n\\t\\tthis.aoMapIntensity = source.aoMapIntensity;\\r\\n\\r\\n\\t\\tthis.emissive.copy( source.emissive );\\r\\n\\t\\tthis.emissiveMap = source.emissiveMap;\\r\\n\\t\\tthis.emissiveIntensity = source.emissiveIntensity;\\r\\n\\r\\n\\t\\tthis.bumpMap = source.bumpMap;\\r\\n\\t\\tthis.bumpScale = source.bumpScale;\\r\\n\\r\\n\\t\\tthis.normalMap = source.normalMap;\\r\\n\\t\\tthis.normalScale.copy( source.normalScale );\\r\\n\\r\\n\\t\\tthis.displacementMap = source.displacementMap;\\r\\n\\t\\tthis.displacementScale = source.displacementScale;\\r\\n\\t\\tthis.displacementBias = source.displacementBias;\\r\\n\\r\\n\\t\\tthis.roughnessMap = source.roughnessMap;\\r\\n\\r\\n\\t\\tthis.metalnessMap = source.metalnessMap;\\r\\n\\r\\n\\t\\tthis.alphaMap = source.alphaMap;\\r\\n\\r\\n\\t\\tthis.envMap = source.envMap;\\r\\n\\t\\tthis.envMapIntensity = source.envMapIntensity;\\r\\n\\r\\n\\t\\tthis.refractionRatio = source.refractionRatio;\\r\\n\\r\\n\\t\\tthis.wireframe = source.wireframe;\\r\\n\\t\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\r\\n\\t\\tthis.wireframeLinecap = source.wireframeLinecap;\\r\\n\\t\\tthis.wireframeLinejoin = source.wireframeLinejoin;\\r\\n\\r\\n\\t\\tthis.skinning = source.skinning;\\r\\n\\t\\tthis.morphTargets = source.morphTargets;\\r\\n\\t\\tthis.morphNormals = source.morphNormals;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author WestLangley / http://github.com/WestLangley\\r\\n\\t *\\r\\n\\t * parameters = {\\r\\n\\t *  reflectivity: <float>\\r\\n\\t * }\\r\\n\\t */\\r\\n\\r\\n\\tfunction MeshPhysicalMaterial( parameters ) {\\r\\n\\r\\n\\t\\tMeshStandardMaterial.call( this );\\r\\n\\r\\n\\t\\tthis.defines = { 'PHYSICAL': '' };\\r\\n\\r\\n\\t\\tthis.type = 'MeshPhysicalMaterial';\\r\\n\\r\\n\\t\\tthis.reflectivity = 0.5; // maps to F0 = 0.04\\r\\n\\r\\n\\t\\tthis.clearCoat = 0.0;\\r\\n\\t\\tthis.clearCoatRoughness = 0.0;\\r\\n\\r\\n\\t\\tthis.setValues( parameters );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tMeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );\\r\\n\\tMeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;\\r\\n\\r\\n\\tMeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;\\r\\n\\r\\n\\tMeshPhysicalMaterial.prototype.copy = function ( source ) {\\r\\n\\r\\n\\t\\tMeshStandardMaterial.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.defines = { 'PHYSICAL': '' };\\r\\n\\r\\n\\t\\tthis.reflectivity = source.reflectivity;\\r\\n\\r\\n\\t\\tthis.clearCoat = source.clearCoat;\\r\\n\\t\\tthis.clearCoatRoughness = source.clearCoatRoughness;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t *\\r\\n\\t * parameters = {\\r\\n\\t *  color: <hex>,\\r\\n\\t *  specular: <hex>,\\r\\n\\t *  shininess: <float>,\\r\\n\\t *  opacity: <float>,\\r\\n\\t *\\r\\n\\t *  map: new THREE.Texture( <Image> ),\\r\\n\\t *\\r\\n\\t *  lightMap: new THREE.Texture( <Image> ),\\r\\n\\t *  lightMapIntensity: <float>\\r\\n\\t *\\r\\n\\t *  aoMap: new THREE.Texture( <Image> ),\\r\\n\\t *  aoMapIntensity: <float>\\r\\n\\t *\\r\\n\\t *  emissive: <hex>,\\r\\n\\t *  emissiveIntensity: <float>\\r\\n\\t *  emissiveMap: new THREE.Texture( <Image> ),\\r\\n\\t *\\r\\n\\t *  bumpMap: new THREE.Texture( <Image> ),\\r\\n\\t *  bumpScale: <float>,\\r\\n\\t *\\r\\n\\t *  normalMap: new THREE.Texture( <Image> ),\\r\\n\\t *  normalScale: <Vector2>,\\r\\n\\t *\\r\\n\\t *  displacementMap: new THREE.Texture( <Image> ),\\r\\n\\t *  displacementScale: <float>,\\r\\n\\t *  displacementBias: <float>,\\r\\n\\t *\\r\\n\\t *  specularMap: new THREE.Texture( <Image> ),\\r\\n\\t *\\r\\n\\t *  alphaMap: new THREE.Texture( <Image> ),\\r\\n\\t *\\r\\n\\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\\r\\n\\t *  combine: THREE.Multiply,\\r\\n\\t *  reflectivity: <float>,\\r\\n\\t *  refractionRatio: <float>,\\r\\n\\t *\\r\\n\\t *  wireframe: <boolean>,\\r\\n\\t *  wireframeLinewidth: <float>,\\r\\n\\t *\\r\\n\\t *  skinning: <bool>,\\r\\n\\t *  morphTargets: <bool>,\\r\\n\\t *  morphNormals: <bool>\\r\\n\\t * }\\r\\n\\t */\\r\\n\\r\\n\\tfunction MeshPhongMaterial( parameters ) {\\r\\n\\r\\n\\t\\tMaterial.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'MeshPhongMaterial';\\r\\n\\r\\n\\t\\tthis.color = new Color( 0xffffff ); // diffuse\\r\\n\\t\\tthis.specular = new Color( 0x111111 );\\r\\n\\t\\tthis.shininess = 30;\\r\\n\\r\\n\\t\\tthis.map = null;\\r\\n\\r\\n\\t\\tthis.lightMap = null;\\r\\n\\t\\tthis.lightMapIntensity = 1.0;\\r\\n\\r\\n\\t\\tthis.aoMap = null;\\r\\n\\t\\tthis.aoMapIntensity = 1.0;\\r\\n\\r\\n\\t\\tthis.emissive = new Color( 0x000000 );\\r\\n\\t\\tthis.emissiveIntensity = 1.0;\\r\\n\\t\\tthis.emissiveMap = null;\\r\\n\\r\\n\\t\\tthis.bumpMap = null;\\r\\n\\t\\tthis.bumpScale = 1;\\r\\n\\r\\n\\t\\tthis.normalMap = null;\\r\\n\\t\\tthis.normalScale = new Vector2( 1, 1 );\\r\\n\\r\\n\\t\\tthis.displacementMap = null;\\r\\n\\t\\tthis.displacementScale = 1;\\r\\n\\t\\tthis.displacementBias = 0;\\r\\n\\r\\n\\t\\tthis.specularMap = null;\\r\\n\\r\\n\\t\\tthis.alphaMap = null;\\r\\n\\r\\n\\t\\tthis.envMap = null;\\r\\n\\t\\tthis.combine = MultiplyOperation;\\r\\n\\t\\tthis.reflectivity = 1;\\r\\n\\t\\tthis.refractionRatio = 0.98;\\r\\n\\r\\n\\t\\tthis.wireframe = false;\\r\\n\\t\\tthis.wireframeLinewidth = 1;\\r\\n\\t\\tthis.wireframeLinecap = 'round';\\r\\n\\t\\tthis.wireframeLinejoin = 'round';\\r\\n\\r\\n\\t\\tthis.skinning = false;\\r\\n\\t\\tthis.morphTargets = false;\\r\\n\\t\\tthis.morphNormals = false;\\r\\n\\r\\n\\t\\tthis.setValues( parameters );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tMeshPhongMaterial.prototype = Object.create( Material.prototype );\\r\\n\\tMeshPhongMaterial.prototype.constructor = MeshPhongMaterial;\\r\\n\\r\\n\\tMeshPhongMaterial.prototype.isMeshPhongMaterial = true;\\r\\n\\r\\n\\tMeshPhongMaterial.prototype.copy = function ( source ) {\\r\\n\\r\\n\\t\\tMaterial.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.color.copy( source.color );\\r\\n\\t\\tthis.specular.copy( source.specular );\\r\\n\\t\\tthis.shininess = source.shininess;\\r\\n\\r\\n\\t\\tthis.map = source.map;\\r\\n\\r\\n\\t\\tthis.lightMap = source.lightMap;\\r\\n\\t\\tthis.lightMapIntensity = source.lightMapIntensity;\\r\\n\\r\\n\\t\\tthis.aoMap = source.aoMap;\\r\\n\\t\\tthis.aoMapIntensity = source.aoMapIntensity;\\r\\n\\r\\n\\t\\tthis.emissive.copy( source.emissive );\\r\\n\\t\\tthis.emissiveMap = source.emissiveMap;\\r\\n\\t\\tthis.emissiveIntensity = source.emissiveIntensity;\\r\\n\\r\\n\\t\\tthis.bumpMap = source.bumpMap;\\r\\n\\t\\tthis.bumpScale = source.bumpScale;\\r\\n\\r\\n\\t\\tthis.normalMap = source.normalMap;\\r\\n\\t\\tthis.normalScale.copy( source.normalScale );\\r\\n\\r\\n\\t\\tthis.displacementMap = source.displacementMap;\\r\\n\\t\\tthis.displacementScale = source.displacementScale;\\r\\n\\t\\tthis.displacementBias = source.displacementBias;\\r\\n\\r\\n\\t\\tthis.specularMap = source.specularMap;\\r\\n\\r\\n\\t\\tthis.alphaMap = source.alphaMap;\\r\\n\\r\\n\\t\\tthis.envMap = source.envMap;\\r\\n\\t\\tthis.combine = source.combine;\\r\\n\\t\\tthis.reflectivity = source.reflectivity;\\r\\n\\t\\tthis.refractionRatio = source.refractionRatio;\\r\\n\\r\\n\\t\\tthis.wireframe = source.wireframe;\\r\\n\\t\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\r\\n\\t\\tthis.wireframeLinecap = source.wireframeLinecap;\\r\\n\\t\\tthis.wireframeLinejoin = source.wireframeLinejoin;\\r\\n\\r\\n\\t\\tthis.skinning = source.skinning;\\r\\n\\t\\tthis.morphTargets = source.morphTargets;\\r\\n\\t\\tthis.morphNormals = source.morphNormals;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author takahirox / http://github.com/takahirox\\r\\n\\t *\\r\\n\\t * parameters = {\\r\\n\\t *  gradientMap: new THREE.Texture( <Image> )\\r\\n\\t * }\\r\\n\\t */\\r\\n\\r\\n\\tfunction MeshToonMaterial( parameters ) {\\r\\n\\r\\n\\t\\tMeshPhongMaterial.call( this );\\r\\n\\r\\n\\t\\tthis.defines = { 'TOON': '' };\\r\\n\\r\\n\\t\\tthis.type = 'MeshToonMaterial';\\r\\n\\r\\n\\t\\tthis.gradientMap = null;\\r\\n\\r\\n\\t\\tthis.setValues( parameters );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tMeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );\\r\\n\\tMeshToonMaterial.prototype.constructor = MeshToonMaterial;\\r\\n\\r\\n\\tMeshToonMaterial.prototype.isMeshToonMaterial = true;\\r\\n\\r\\n\\tMeshToonMaterial.prototype.copy = function ( source ) {\\r\\n\\r\\n\\t\\tMeshPhongMaterial.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.gradientMap = source.gradientMap;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author WestLangley / http://github.com/WestLangley\\r\\n\\t *\\r\\n\\t * parameters = {\\r\\n\\t *  opacity: <float>,\\r\\n\\t *\\r\\n\\t *  bumpMap: new THREE.Texture( <Image> ),\\r\\n\\t *  bumpScale: <float>,\\r\\n\\t *\\r\\n\\t *  normalMap: new THREE.Texture( <Image> ),\\r\\n\\t *  normalScale: <Vector2>,\\r\\n\\t *\\r\\n\\t *  displacementMap: new THREE.Texture( <Image> ),\\r\\n\\t *  displacementScale: <float>,\\r\\n\\t *  displacementBias: <float>,\\r\\n\\t *\\r\\n\\t *  wireframe: <boolean>,\\r\\n\\t *  wireframeLinewidth: <float>\\r\\n\\t *\\r\\n\\t *  skinning: <bool>,\\r\\n\\t *  morphTargets: <bool>,\\r\\n\\t *  morphNormals: <bool>\\r\\n\\t * }\\r\\n\\t */\\r\\n\\r\\n\\tfunction MeshNormalMaterial( parameters ) {\\r\\n\\r\\n\\t\\tMaterial.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'MeshNormalMaterial';\\r\\n\\r\\n\\t\\tthis.bumpMap = null;\\r\\n\\t\\tthis.bumpScale = 1;\\r\\n\\r\\n\\t\\tthis.normalMap = null;\\r\\n\\t\\tthis.normalScale = new Vector2( 1, 1 );\\r\\n\\r\\n\\t\\tthis.displacementMap = null;\\r\\n\\t\\tthis.displacementScale = 1;\\r\\n\\t\\tthis.displacementBias = 0;\\r\\n\\r\\n\\t\\tthis.wireframe = false;\\r\\n\\t\\tthis.wireframeLinewidth = 1;\\r\\n\\r\\n\\t\\tthis.fog = false;\\r\\n\\t\\tthis.lights = false;\\r\\n\\r\\n\\t\\tthis.skinning = false;\\r\\n\\t\\tthis.morphTargets = false;\\r\\n\\t\\tthis.morphNormals = false;\\r\\n\\r\\n\\t\\tthis.setValues( parameters );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tMeshNormalMaterial.prototype = Object.create( Material.prototype );\\r\\n\\tMeshNormalMaterial.prototype.constructor = MeshNormalMaterial;\\r\\n\\r\\n\\tMeshNormalMaterial.prototype.isMeshNormalMaterial = true;\\r\\n\\r\\n\\tMeshNormalMaterial.prototype.copy = function ( source ) {\\r\\n\\r\\n\\t\\tMaterial.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.bumpMap = source.bumpMap;\\r\\n\\t\\tthis.bumpScale = source.bumpScale;\\r\\n\\r\\n\\t\\tthis.normalMap = source.normalMap;\\r\\n\\t\\tthis.normalScale.copy( source.normalScale );\\r\\n\\r\\n\\t\\tthis.displacementMap = source.displacementMap;\\r\\n\\t\\tthis.displacementScale = source.displacementScale;\\r\\n\\t\\tthis.displacementBias = source.displacementBias;\\r\\n\\r\\n\\t\\tthis.wireframe = source.wireframe;\\r\\n\\t\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\r\\n\\r\\n\\t\\tthis.skinning = source.skinning;\\r\\n\\t\\tthis.morphTargets = source.morphTargets;\\r\\n\\t\\tthis.morphNormals = source.morphNormals;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t *\\r\\n\\t * parameters = {\\r\\n\\t *  color: <hex>,\\r\\n\\t *  opacity: <float>,\\r\\n\\t *\\r\\n\\t *  map: new THREE.Texture( <Image> ),\\r\\n\\t *\\r\\n\\t *  lightMap: new THREE.Texture( <Image> ),\\r\\n\\t *  lightMapIntensity: <float>\\r\\n\\t *\\r\\n\\t *  aoMap: new THREE.Texture( <Image> ),\\r\\n\\t *  aoMapIntensity: <float>\\r\\n\\t *\\r\\n\\t *  emissive: <hex>,\\r\\n\\t *  emissiveIntensity: <float>\\r\\n\\t *  emissiveMap: new THREE.Texture( <Image> ),\\r\\n\\t *\\r\\n\\t *  specularMap: new THREE.Texture( <Image> ),\\r\\n\\t *\\r\\n\\t *  alphaMap: new THREE.Texture( <Image> ),\\r\\n\\t *\\r\\n\\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\\r\\n\\t *  combine: THREE.Multiply,\\r\\n\\t *  reflectivity: <float>,\\r\\n\\t *  refractionRatio: <float>,\\r\\n\\t *\\r\\n\\t *  wireframe: <boolean>,\\r\\n\\t *  wireframeLinewidth: <float>,\\r\\n\\t *\\r\\n\\t *  skinning: <bool>,\\r\\n\\t *  morphTargets: <bool>,\\r\\n\\t *  morphNormals: <bool>\\r\\n\\t * }\\r\\n\\t */\\r\\n\\r\\n\\tfunction MeshLambertMaterial( parameters ) {\\r\\n\\r\\n\\t\\tMaterial.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'MeshLambertMaterial';\\r\\n\\r\\n\\t\\tthis.color = new Color( 0xffffff ); // diffuse\\r\\n\\r\\n\\t\\tthis.map = null;\\r\\n\\r\\n\\t\\tthis.lightMap = null;\\r\\n\\t\\tthis.lightMapIntensity = 1.0;\\r\\n\\r\\n\\t\\tthis.aoMap = null;\\r\\n\\t\\tthis.aoMapIntensity = 1.0;\\r\\n\\r\\n\\t\\tthis.emissive = new Color( 0x000000 );\\r\\n\\t\\tthis.emissiveIntensity = 1.0;\\r\\n\\t\\tthis.emissiveMap = null;\\r\\n\\r\\n\\t\\tthis.specularMap = null;\\r\\n\\r\\n\\t\\tthis.alphaMap = null;\\r\\n\\r\\n\\t\\tthis.envMap = null;\\r\\n\\t\\tthis.combine = MultiplyOperation;\\r\\n\\t\\tthis.reflectivity = 1;\\r\\n\\t\\tthis.refractionRatio = 0.98;\\r\\n\\r\\n\\t\\tthis.wireframe = false;\\r\\n\\t\\tthis.wireframeLinewidth = 1;\\r\\n\\t\\tthis.wireframeLinecap = 'round';\\r\\n\\t\\tthis.wireframeLinejoin = 'round';\\r\\n\\r\\n\\t\\tthis.skinning = false;\\r\\n\\t\\tthis.morphTargets = false;\\r\\n\\t\\tthis.morphNormals = false;\\r\\n\\r\\n\\t\\tthis.setValues( parameters );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tMeshLambertMaterial.prototype = Object.create( Material.prototype );\\r\\n\\tMeshLambertMaterial.prototype.constructor = MeshLambertMaterial;\\r\\n\\r\\n\\tMeshLambertMaterial.prototype.isMeshLambertMaterial = true;\\r\\n\\r\\n\\tMeshLambertMaterial.prototype.copy = function ( source ) {\\r\\n\\r\\n\\t\\tMaterial.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.color.copy( source.color );\\r\\n\\r\\n\\t\\tthis.map = source.map;\\r\\n\\r\\n\\t\\tthis.lightMap = source.lightMap;\\r\\n\\t\\tthis.lightMapIntensity = source.lightMapIntensity;\\r\\n\\r\\n\\t\\tthis.aoMap = source.aoMap;\\r\\n\\t\\tthis.aoMapIntensity = source.aoMapIntensity;\\r\\n\\r\\n\\t\\tthis.emissive.copy( source.emissive );\\r\\n\\t\\tthis.emissiveMap = source.emissiveMap;\\r\\n\\t\\tthis.emissiveIntensity = source.emissiveIntensity;\\r\\n\\r\\n\\t\\tthis.specularMap = source.specularMap;\\r\\n\\r\\n\\t\\tthis.alphaMap = source.alphaMap;\\r\\n\\r\\n\\t\\tthis.envMap = source.envMap;\\r\\n\\t\\tthis.combine = source.combine;\\r\\n\\t\\tthis.reflectivity = source.reflectivity;\\r\\n\\t\\tthis.refractionRatio = source.refractionRatio;\\r\\n\\r\\n\\t\\tthis.wireframe = source.wireframe;\\r\\n\\t\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\r\\n\\t\\tthis.wireframeLinecap = source.wireframeLinecap;\\r\\n\\t\\tthis.wireframeLinejoin = source.wireframeLinejoin;\\r\\n\\r\\n\\t\\tthis.skinning = source.skinning;\\r\\n\\t\\tthis.morphTargets = source.morphTargets;\\r\\n\\t\\tthis.morphNormals = source.morphNormals;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t *\\r\\n\\t * parameters = {\\r\\n\\t *  color: <hex>,\\r\\n\\t *  opacity: <float>,\\r\\n\\t *\\r\\n\\t *  linewidth: <float>,\\r\\n\\t *\\r\\n\\t *  scale: <float>,\\r\\n\\t *  dashSize: <float>,\\r\\n\\t *  gapSize: <float>\\r\\n\\t * }\\r\\n\\t */\\r\\n\\r\\n\\tfunction LineDashedMaterial( parameters ) {\\r\\n\\r\\n\\t\\tLineBasicMaterial.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'LineDashedMaterial';\\r\\n\\r\\n\\t\\tthis.scale = 1;\\r\\n\\t\\tthis.dashSize = 3;\\r\\n\\t\\tthis.gapSize = 1;\\r\\n\\r\\n\\t\\tthis.setValues( parameters );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tLineDashedMaterial.prototype = Object.create( LineBasicMaterial.prototype );\\r\\n\\tLineDashedMaterial.prototype.constructor = LineDashedMaterial;\\r\\n\\r\\n\\tLineDashedMaterial.prototype.isLineDashedMaterial = true;\\r\\n\\r\\n\\tLineDashedMaterial.prototype.copy = function ( source ) {\\r\\n\\r\\n\\t\\tLineBasicMaterial.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.scale = source.scale;\\r\\n\\t\\tthis.dashSize = source.dashSize;\\r\\n\\t\\tthis.gapSize = source.gapSize;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\r\\n\\tvar Materials = Object.freeze({\\r\\n\\t\\tShadowMaterial: ShadowMaterial,\\r\\n\\t\\tSpriteMaterial: SpriteMaterial,\\r\\n\\t\\tRawShaderMaterial: RawShaderMaterial,\\r\\n\\t\\tShaderMaterial: ShaderMaterial,\\r\\n\\t\\tPointsMaterial: PointsMaterial,\\r\\n\\t\\tMeshPhysicalMaterial: MeshPhysicalMaterial,\\r\\n\\t\\tMeshStandardMaterial: MeshStandardMaterial,\\r\\n\\t\\tMeshPhongMaterial: MeshPhongMaterial,\\r\\n\\t\\tMeshToonMaterial: MeshToonMaterial,\\r\\n\\t\\tMeshNormalMaterial: MeshNormalMaterial,\\r\\n\\t\\tMeshLambertMaterial: MeshLambertMaterial,\\r\\n\\t\\tMeshDepthMaterial: MeshDepthMaterial,\\r\\n\\t\\tMeshDistanceMaterial: MeshDistanceMaterial,\\r\\n\\t\\tMeshBasicMaterial: MeshBasicMaterial,\\r\\n\\t\\tLineDashedMaterial: LineDashedMaterial,\\r\\n\\t\\tLineBasicMaterial: LineBasicMaterial,\\r\\n\\t\\tMaterial: Material\\r\\n\\t});\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tvar Cache = {\\r\\n\\r\\n\\t\\tenabled: false,\\r\\n\\r\\n\\t\\tfiles: {},\\r\\n\\r\\n\\t\\tadd: function ( key, file ) {\\r\\n\\r\\n\\t\\t\\tif ( this.enabled === false ) return;\\r\\n\\r\\n\\t\\t\\t// console.log( 'THREE.Cache', 'Adding key:', key );\\r\\n\\r\\n\\t\\t\\tthis.files[ key ] = file;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tget: function ( key ) {\\r\\n\\r\\n\\t\\t\\tif ( this.enabled === false ) return;\\r\\n\\r\\n\\t\\t\\t// console.log( 'THREE.Cache', 'Checking key:', key );\\r\\n\\r\\n\\t\\t\\treturn this.files[ key ];\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tremove: function ( key ) {\\r\\n\\r\\n\\t\\t\\tdelete this.files[ key ];\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclear: function () {\\r\\n\\r\\n\\t\\t\\tthis.files = {};\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction LoadingManager( onLoad, onProgress, onError ) {\\r\\n\\r\\n\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\tvar isLoading = false;\\r\\n\\t\\tvar itemsLoaded = 0;\\r\\n\\t\\tvar itemsTotal = 0;\\r\\n\\t\\tvar urlModifier = undefined;\\r\\n\\r\\n\\t\\tthis.onStart = undefined;\\r\\n\\t\\tthis.onLoad = onLoad;\\r\\n\\t\\tthis.onProgress = onProgress;\\r\\n\\t\\tthis.onError = onError;\\r\\n\\r\\n\\t\\tthis.itemStart = function ( url ) {\\r\\n\\r\\n\\t\\t\\titemsTotal ++;\\r\\n\\r\\n\\t\\t\\tif ( isLoading === false ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( scope.onStart !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tscope.onStart( url, itemsLoaded, itemsTotal );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tisLoading = true;\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.itemEnd = function ( url ) {\\r\\n\\r\\n\\t\\t\\titemsLoaded ++;\\r\\n\\r\\n\\t\\t\\tif ( scope.onProgress !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tscope.onProgress( url, itemsLoaded, itemsTotal );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( itemsLoaded === itemsTotal ) {\\r\\n\\r\\n\\t\\t\\t\\tisLoading = false;\\r\\n\\r\\n\\t\\t\\t\\tif ( scope.onLoad !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tscope.onLoad();\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.itemError = function ( url ) {\\r\\n\\r\\n\\t\\t\\tif ( scope.onError !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tscope.onError( url );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.resolveURL = function ( url ) {\\r\\n\\r\\n\\t\\t\\tif ( urlModifier ) {\\r\\n\\r\\n\\t\\t\\t\\treturn urlModifier( url );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn url;\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.setURLModifier = function ( transform ) {\\r\\n\\r\\n\\t\\t\\turlModifier = transform;\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tvar DefaultLoadingManager = new LoadingManager();\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tvar loading = {};\\r\\n\\r\\n\\tfunction FileLoader( manager ) {\\r\\n\\r\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( FileLoader.prototype, {\\r\\n\\r\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\r\\n\\r\\n\\t\\t\\tif ( url === undefined ) url = '';\\r\\n\\r\\n\\t\\t\\tif ( this.path !== undefined ) url = this.path + url;\\r\\n\\r\\n\\t\\t\\turl = this.manager.resolveURL( url );\\r\\n\\r\\n\\t\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\t\\tvar cached = Cache.get( url );\\r\\n\\r\\n\\t\\t\\tif ( cached !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tscope.manager.itemStart( url );\\r\\n\\r\\n\\t\\t\\t\\tsetTimeout( function () {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( onLoad ) onLoad( cached );\\r\\n\\r\\n\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\r\\n\\r\\n\\t\\t\\t\\t}, 0 );\\r\\n\\r\\n\\t\\t\\t\\treturn cached;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// Check if request is duplicate\\r\\n\\r\\n\\t\\t\\tif ( loading[ url ] !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tloading[ url ].push( {\\r\\n\\r\\n\\t\\t\\t\\t\\tonLoad: onLoad,\\r\\n\\t\\t\\t\\t\\tonProgress: onProgress,\\r\\n\\t\\t\\t\\t\\tonError: onError\\r\\n\\r\\n\\t\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// Check for data: URI\\r\\n\\t\\t\\tvar dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\\r\\n\\t\\t\\tvar dataUriRegexResult = url.match( dataUriRegex );\\r\\n\\r\\n\\t\\t\\t// Safari can not handle Data URIs through XMLHttpRequest so process manually\\r\\n\\t\\t\\tif ( dataUriRegexResult ) {\\r\\n\\r\\n\\t\\t\\t\\tvar mimeType = dataUriRegexResult[ 1 ];\\r\\n\\t\\t\\t\\tvar isBase64 = !! dataUriRegexResult[ 2 ];\\r\\n\\t\\t\\t\\tvar data = dataUriRegexResult[ 3 ];\\r\\n\\r\\n\\t\\t\\t\\tdata = window.decodeURIComponent( data );\\r\\n\\r\\n\\t\\t\\t\\tif ( isBase64 ) data = window.atob( data );\\r\\n\\r\\n\\t\\t\\t\\ttry {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar response;\\r\\n\\t\\t\\t\\t\\tvar responseType = ( this.responseType || '' ).toLowerCase();\\r\\n\\r\\n\\t\\t\\t\\t\\tswitch ( responseType ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase 'arraybuffer':\\r\\n\\t\\t\\t\\t\\t\\tcase 'blob':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar view = new Uint8Array( data.length );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tfor ( var i = 0; i < data.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tview[ i ] = data.charCodeAt( i );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( responseType === 'blob' ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tresponse = new Blob( [ view.buffer ], { type: mimeType } );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tresponse = view.buffer;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase 'document':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar parser = new DOMParser();\\r\\n\\t\\t\\t\\t\\t\\t\\tresponse = parser.parseFromString( data, mimeType );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase 'json':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tresponse = JSON.parse( data );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tdefault: // 'text' or other\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tresponse = data;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t// Wait for next browser tick like standard XMLHttpRequest event dispatching does\\r\\n\\t\\t\\t\\t\\twindow.setTimeout( function () {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( onLoad ) onLoad( response );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\r\\n\\r\\n\\t\\t\\t\\t\\t}, 0 );\\r\\n\\r\\n\\t\\t\\t\\t} catch ( error ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// Wait for next browser tick like standard XMLHttpRequest event dispatching does\\r\\n\\t\\t\\t\\t\\twindow.setTimeout( function () {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( onError ) onError( error );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\r\\n\\t\\t\\t\\t\\t\\tscope.manager.itemError( url );\\r\\n\\r\\n\\t\\t\\t\\t\\t}, 0 );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t// Initialise array for duplicate requests\\r\\n\\r\\n\\t\\t\\t\\tloading[ url ] = [];\\r\\n\\r\\n\\t\\t\\t\\tloading[ url ].push( {\\r\\n\\r\\n\\t\\t\\t\\t\\tonLoad: onLoad,\\r\\n\\t\\t\\t\\t\\tonProgress: onProgress,\\r\\n\\t\\t\\t\\t\\tonError: onError\\r\\n\\r\\n\\t\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\t\\tvar request = new XMLHttpRequest();\\r\\n\\r\\n\\t\\t\\t\\trequest.open( 'GET', url, true );\\r\\n\\r\\n\\t\\t\\t\\trequest.addEventListener( 'load', function ( event ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar response = this.response;\\r\\n\\r\\n\\t\\t\\t\\t\\tCache.add( url, response );\\r\\n\\r\\n\\t\\t\\t\\t\\tvar callbacks = loading[ url ];\\r\\n\\r\\n\\t\\t\\t\\t\\tdelete loading[ url ];\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( this.status === 200 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar callback = callbacks[ i ];\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( callback.onLoad ) callback.onLoad( response );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else if ( this.status === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// Some browsers return HTTP Status 0 when using non-http protocol\\r\\n\\t\\t\\t\\t\\t\\t// e.g. 'file://' or 'data://'. Handle as success.\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.FileLoader: HTTP Status 0 received.' );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar callback = callbacks[ i ];\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( callback.onLoad ) callback.onLoad( response );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar callback = callbacks[ i ];\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( callback.onError ) callback.onError( event );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\r\\n\\t\\t\\t\\t\\t\\tscope.manager.itemError( url );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}, false );\\r\\n\\r\\n\\t\\t\\t\\trequest.addEventListener( 'progress', function ( event ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar callbacks = loading[ url ];\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar callback = callbacks[ i ];\\r\\n\\t\\t\\t\\t\\t\\tif ( callback.onProgress ) callback.onProgress( event );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}, false );\\r\\n\\r\\n\\t\\t\\t\\trequest.addEventListener( 'error', function ( event ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar callbacks = loading[ url ];\\r\\n\\r\\n\\t\\t\\t\\t\\tdelete loading[ url ];\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar callback = callbacks[ i ];\\r\\n\\t\\t\\t\\t\\t\\tif ( callback.onError ) callback.onError( event );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\r\\n\\t\\t\\t\\t\\tscope.manager.itemError( url );\\r\\n\\r\\n\\t\\t\\t\\t}, false );\\r\\n\\r\\n\\t\\t\\t\\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\\r\\n\\t\\t\\t\\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\\r\\n\\r\\n\\t\\t\\t\\tif ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );\\r\\n\\r\\n\\t\\t\\t\\tfor ( var header in this.requestHeader ) {\\r\\n\\r\\n\\t\\t\\t\\t\\trequest.setRequestHeader( header, this.requestHeader[ header ] );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\trequest.send( null );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tscope.manager.itemStart( url );\\r\\n\\r\\n\\t\\t\\treturn request;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetPath: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.path = value;\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetResponseType: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.responseType = value;\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetWithCredentials: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.withCredentials = value;\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetMimeType: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.mimeType = value;\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetRequestHeader: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.requestHeader = value;\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t *\\r\\n\\t * Abstract Base class to block based textures loader (dds, pvr, ...)\\r\\n\\t */\\r\\n\\r\\n\\tfunction CompressedTextureLoader( manager ) {\\r\\n\\r\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\r\\n\\r\\n\\t\\t// override in sub classes\\r\\n\\t\\tthis._parser = null;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( CompressedTextureLoader.prototype, {\\r\\n\\r\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\r\\n\\r\\n\\t\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\t\\tvar images = [];\\r\\n\\r\\n\\t\\t\\tvar texture = new CompressedTexture();\\r\\n\\t\\t\\ttexture.image = images;\\r\\n\\r\\n\\t\\t\\tvar loader = new FileLoader( this.manager );\\r\\n\\t\\t\\tloader.setPath( this.path );\\r\\n\\t\\t\\tloader.setResponseType( 'arraybuffer' );\\r\\n\\r\\n\\t\\t\\tfunction loadTexture( i ) {\\r\\n\\r\\n\\t\\t\\t\\tloader.load( url[ i ], function ( buffer ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar texDatas = scope._parser( buffer, true );\\r\\n\\r\\n\\t\\t\\t\\t\\timages[ i ] = {\\r\\n\\t\\t\\t\\t\\t\\twidth: texDatas.width,\\r\\n\\t\\t\\t\\t\\t\\theight: texDatas.height,\\r\\n\\t\\t\\t\\t\\t\\tformat: texDatas.format,\\r\\n\\t\\t\\t\\t\\t\\tmipmaps: texDatas.mipmaps\\r\\n\\t\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t\\t\\tloaded += 1;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( loaded === 6 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( texDatas.mipmapCount === 1 )\\r\\n\\t\\t\\t\\t\\t\\t\\ttexture.minFilter = LinearFilter;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ttexture.format = texDatas.format;\\r\\n\\t\\t\\t\\t\\t\\ttexture.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( onLoad ) onLoad( texture );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}, onProgress, onError );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( Array.isArray( url ) ) {\\r\\n\\r\\n\\t\\t\\t\\tvar loaded = 0;\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tloadTexture( i );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t// compressed cubemap texture stored in a single DDS file\\r\\n\\r\\n\\t\\t\\t\\tloader.load( url, function ( buffer ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar texDatas = scope._parser( buffer, true );\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( texDatas.isCubemap ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var f = 0; f < faces; f ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\timages[ f ] = { mipmaps: [] };\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\timages[ f ].format = texDatas.format;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\timages[ f ].width = texDatas.width;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\timages[ f ].height = texDatas.height;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ttexture.image.width = texDatas.width;\\r\\n\\t\\t\\t\\t\\t\\ttexture.image.height = texDatas.height;\\r\\n\\t\\t\\t\\t\\t\\ttexture.mipmaps = texDatas.mipmaps;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( texDatas.mipmapCount === 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ttexture.minFilter = LinearFilter;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\ttexture.format = texDatas.format;\\r\\n\\t\\t\\t\\t\\ttexture.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( onLoad ) onLoad( texture );\\r\\n\\r\\n\\t\\t\\t\\t}, onProgress, onError );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn texture;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetPath: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.path = value;\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author Nikos M. / https://github.com/foo123/\\r\\n\\t *\\r\\n\\t * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\\r\\n\\t */\\r\\n\\r\\n\\tfunction DataTextureLoader( manager ) {\\r\\n\\r\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\r\\n\\r\\n\\t\\t// override in sub classes\\r\\n\\t\\tthis._parser = null;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( DataTextureLoader.prototype, {\\r\\n\\r\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\r\\n\\r\\n\\t\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\t\\tvar texture = new DataTexture();\\r\\n\\r\\n\\t\\t\\tvar loader = new FileLoader( this.manager );\\r\\n\\t\\t\\tloader.setResponseType( 'arraybuffer' );\\r\\n\\r\\n\\t\\t\\tloader.load( url, function ( buffer ) {\\r\\n\\r\\n\\t\\t\\t\\tvar texData = scope._parser( buffer );\\r\\n\\r\\n\\t\\t\\t\\tif ( ! texData ) return;\\r\\n\\r\\n\\t\\t\\t\\tif ( undefined !== texData.image ) {\\r\\n\\r\\n\\t\\t\\t\\t\\ttexture.image = texData.image;\\r\\n\\r\\n\\t\\t\\t\\t} else if ( undefined !== texData.data ) {\\r\\n\\r\\n\\t\\t\\t\\t\\ttexture.image.width = texData.width;\\r\\n\\t\\t\\t\\t\\ttexture.image.height = texData.height;\\r\\n\\t\\t\\t\\t\\ttexture.image.data = texData.data;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;\\r\\n\\t\\t\\t\\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;\\r\\n\\r\\n\\t\\t\\t\\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;\\r\\n\\t\\t\\t\\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;\\r\\n\\r\\n\\t\\t\\t\\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\\r\\n\\r\\n\\t\\t\\t\\tif ( undefined !== texData.format ) {\\r\\n\\r\\n\\t\\t\\t\\t\\ttexture.format = texData.format;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif ( undefined !== texData.type ) {\\r\\n\\r\\n\\t\\t\\t\\t\\ttexture.type = texData.type;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( undefined !== texData.mipmaps ) {\\r\\n\\r\\n\\t\\t\\t\\t\\ttexture.mipmaps = texData.mipmaps;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( 1 === texData.mipmapCount ) {\\r\\n\\r\\n\\t\\t\\t\\t\\ttexture.minFilter = LinearFilter;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\ttexture.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t\\tif ( onLoad ) onLoad( texture, texData );\\r\\n\\r\\n\\t\\t\\t}, onProgress, onError );\\r\\n\\r\\n\\r\\n\\t\\t\\treturn texture;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction ImageLoader( manager ) {\\r\\n\\r\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( ImageLoader.prototype, {\\r\\n\\r\\n\\t\\tcrossOrigin: 'Anonymous',\\r\\n\\r\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\r\\n\\r\\n\\t\\t\\tif ( url === undefined ) url = '';\\r\\n\\r\\n\\t\\t\\tif ( this.path !== undefined ) url = this.path + url;\\r\\n\\r\\n\\t\\t\\turl = this.manager.resolveURL( url );\\r\\n\\r\\n\\t\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\t\\tvar cached = Cache.get( url );\\r\\n\\r\\n\\t\\t\\tif ( cached !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tscope.manager.itemStart( url );\\r\\n\\r\\n\\t\\t\\t\\tsetTimeout( function () {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( onLoad ) onLoad( cached );\\r\\n\\r\\n\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\r\\n\\r\\n\\t\\t\\t\\t}, 0 );\\r\\n\\r\\n\\t\\t\\t\\treturn cached;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\\r\\n\\r\\n\\t\\t\\timage.addEventListener( 'load', function () {\\r\\n\\r\\n\\t\\t\\t\\tCache.add( url, this );\\r\\n\\r\\n\\t\\t\\t\\tif ( onLoad ) onLoad( this );\\r\\n\\r\\n\\t\\t\\t\\tscope.manager.itemEnd( url );\\r\\n\\r\\n\\t\\t\\t}, false );\\r\\n\\r\\n\\t\\t\\t/*\\r\\n\\t\\t\\timage.addEventListener( 'progress', function ( event ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( onProgress ) onProgress( event );\\r\\n\\r\\n\\t\\t\\t}, false );\\r\\n\\t\\t\\t*/\\r\\n\\r\\n\\t\\t\\timage.addEventListener( 'error', function ( event ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( onError ) onError( event );\\r\\n\\r\\n\\t\\t\\t\\tscope.manager.itemEnd( url );\\r\\n\\t\\t\\t\\tscope.manager.itemError( url );\\r\\n\\r\\n\\t\\t\\t}, false );\\r\\n\\r\\n\\t\\t\\tif ( url.substr( 0, 5 ) !== 'data:' ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tscope.manager.itemStart( url );\\r\\n\\r\\n\\t\\t\\timage.src = url;\\r\\n\\r\\n\\t\\t\\treturn image;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetCrossOrigin: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.crossOrigin = value;\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetPath: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.path = value;\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction CubeTextureLoader( manager ) {\\r\\n\\r\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( CubeTextureLoader.prototype, {\\r\\n\\r\\n\\t\\tcrossOrigin: 'Anonymous',\\r\\n\\r\\n\\t\\tload: function ( urls, onLoad, onProgress, onError ) {\\r\\n\\r\\n\\t\\t\\tvar texture = new CubeTexture();\\r\\n\\r\\n\\t\\t\\tvar loader = new ImageLoader( this.manager );\\r\\n\\t\\t\\tloader.setCrossOrigin( this.crossOrigin );\\r\\n\\t\\t\\tloader.setPath( this.path );\\r\\n\\r\\n\\t\\t\\tvar loaded = 0;\\r\\n\\r\\n\\t\\t\\tfunction loadTexture( i ) {\\r\\n\\r\\n\\t\\t\\t\\tloader.load( urls[ i ], function ( image ) {\\r\\n\\r\\n\\t\\t\\t\\t\\ttexture.images[ i ] = image;\\r\\n\\r\\n\\t\\t\\t\\t\\tloaded ++;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( loaded === 6 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ttexture.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( onLoad ) onLoad( texture );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}, undefined, onError );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < urls.length; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tloadTexture( i );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn texture;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetCrossOrigin: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.crossOrigin = value;\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetPath: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.path = value;\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction TextureLoader( manager ) {\\r\\n\\r\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( TextureLoader.prototype, {\\r\\n\\r\\n\\t\\tcrossOrigin: 'Anonymous',\\r\\n\\r\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\r\\n\\r\\n\\t\\t\\tvar texture = new Texture();\\r\\n\\r\\n\\t\\t\\tvar loader = new ImageLoader( this.manager );\\r\\n\\t\\t\\tloader.setCrossOrigin( this.crossOrigin );\\r\\n\\t\\t\\tloader.setPath( this.path );\\r\\n\\r\\n\\t\\t\\tloader.load( url, function ( image ) {\\r\\n\\r\\n\\t\\t\\t\\ttexture.image = image;\\r\\n\\r\\n\\t\\t\\t\\t// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\\r\\n\\t\\t\\t\\tvar isJPEG = url.search( /\\\\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\\\\:image\\\\/jpeg/ ) === 0;\\r\\n\\r\\n\\t\\t\\t\\ttexture.format = isJPEG ? RGBFormat : RGBAFormat;\\r\\n\\t\\t\\t\\ttexture.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t\\tif ( onLoad !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tonLoad( texture );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}, onProgress, onError );\\r\\n\\r\\n\\t\\t\\treturn texture;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetCrossOrigin: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.crossOrigin = value;\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetPath: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.path = value;\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\r\\n\\t * Extensible curve object\\r\\n\\t *\\r\\n\\t * Some common of curve methods:\\r\\n\\t * .getPoint( t, optionalTarget ), .getTangent( t )\\r\\n\\t * .getPointAt( u, optionalTarget ), .getTangentAt( u )\\r\\n\\t * .getPoints(), .getSpacedPoints()\\r\\n\\t * .getLength()\\r\\n\\t * .updateArcLengths()\\r\\n\\t *\\r\\n\\t * This following curves inherit from THREE.Curve:\\r\\n\\t *\\r\\n\\t * -- 2D curves --\\r\\n\\t * THREE.ArcCurve\\r\\n\\t * THREE.CubicBezierCurve\\r\\n\\t * THREE.EllipseCurve\\r\\n\\t * THREE.LineCurve\\r\\n\\t * THREE.QuadraticBezierCurve\\r\\n\\t * THREE.SplineCurve\\r\\n\\t *\\r\\n\\t * -- 3D curves --\\r\\n\\t * THREE.CatmullRomCurve3\\r\\n\\t * THREE.CubicBezierCurve3\\r\\n\\t * THREE.LineCurve3\\r\\n\\t * THREE.QuadraticBezierCurve3\\r\\n\\t *\\r\\n\\t * A series of curves can be represented as a THREE.CurvePath.\\r\\n\\t *\\r\\n\\t **/\\r\\n\\r\\n\\t/**************************************************************\\r\\n\\t *\\tAbstract Curve base class\\r\\n\\t **************************************************************/\\r\\n\\r\\n\\tfunction Curve() {\\r\\n\\r\\n\\t\\tthis.type = 'Curve';\\r\\n\\r\\n\\t\\tthis.arcLengthDivisions = 200;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( Curve.prototype, {\\r\\n\\r\\n\\t\\t// Virtual base class method to overwrite and implement in subclasses\\r\\n\\t\\t//\\t- t [0 .. 1]\\r\\n\\r\\n\\t\\tgetPoint: function ( /* t, optionalTarget */ ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Curve: .getPoint() not implemented.' );\\r\\n\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// Get point at relative position in curve according to arc length\\r\\n\\t\\t// - u [0 .. 1]\\r\\n\\r\\n\\t\\tgetPointAt: function ( u, optionalTarget ) {\\r\\n\\r\\n\\t\\t\\tvar t = this.getUtoTmapping( u );\\r\\n\\t\\t\\treturn this.getPoint( t, optionalTarget );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// Get sequence of points using getPoint( t )\\r\\n\\r\\n\\t\\tgetPoints: function ( divisions ) {\\r\\n\\r\\n\\t\\t\\tif ( divisions === undefined ) divisions = 5;\\r\\n\\r\\n\\t\\t\\tvar points = [];\\r\\n\\r\\n\\t\\t\\tfor ( var d = 0; d <= divisions; d ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tpoints.push( this.getPoint( d / divisions ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn points;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// Get sequence of points using getPointAt( u )\\r\\n\\r\\n\\t\\tgetSpacedPoints: function ( divisions ) {\\r\\n\\r\\n\\t\\t\\tif ( divisions === undefined ) divisions = 5;\\r\\n\\r\\n\\t\\t\\tvar points = [];\\r\\n\\r\\n\\t\\t\\tfor ( var d = 0; d <= divisions; d ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tpoints.push( this.getPointAt( d / divisions ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn points;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// Get total curve arc length\\r\\n\\r\\n\\t\\tgetLength: function () {\\r\\n\\r\\n\\t\\t\\tvar lengths = this.getLengths();\\r\\n\\t\\t\\treturn lengths[ lengths.length - 1 ];\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// Get list of cumulative segment lengths\\r\\n\\r\\n\\t\\tgetLengths: function ( divisions ) {\\r\\n\\r\\n\\t\\t\\tif ( divisions === undefined ) divisions = this.arcLengthDivisions;\\r\\n\\r\\n\\t\\t\\tif ( this.cacheArcLengths &&\\r\\n\\t\\t\\t\\t( this.cacheArcLengths.length === divisions + 1 ) &&\\r\\n\\t\\t\\t\\t! this.needsUpdate ) {\\r\\n\\r\\n\\t\\t\\t\\treturn this.cacheArcLengths;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.needsUpdate = false;\\r\\n\\r\\n\\t\\t\\tvar cache = [];\\r\\n\\t\\t\\tvar current, last = this.getPoint( 0 );\\r\\n\\t\\t\\tvar p, sum = 0;\\r\\n\\r\\n\\t\\t\\tcache.push( 0 );\\r\\n\\r\\n\\t\\t\\tfor ( p = 1; p <= divisions; p ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tcurrent = this.getPoint( p / divisions );\\r\\n\\t\\t\\t\\tsum += current.distanceTo( last );\\r\\n\\t\\t\\t\\tcache.push( sum );\\r\\n\\t\\t\\t\\tlast = current;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.cacheArcLengths = cache;\\r\\n\\r\\n\\t\\t\\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tupdateArcLengths: function () {\\r\\n\\r\\n\\t\\t\\tthis.needsUpdate = true;\\r\\n\\t\\t\\tthis.getLengths();\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\\r\\n\\r\\n\\t\\tgetUtoTmapping: function ( u, distance ) {\\r\\n\\r\\n\\t\\t\\tvar arcLengths = this.getLengths();\\r\\n\\r\\n\\t\\t\\tvar i = 0, il = arcLengths.length;\\r\\n\\r\\n\\t\\t\\tvar targetArcLength; // The targeted u distance value to get\\r\\n\\r\\n\\t\\t\\tif ( distance ) {\\r\\n\\r\\n\\t\\t\\t\\ttargetArcLength = distance;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\ttargetArcLength = u * arcLengths[ il - 1 ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// binary search for the index with largest value smaller than target u distance\\r\\n\\r\\n\\t\\t\\tvar low = 0, high = il - 1, comparison;\\r\\n\\r\\n\\t\\t\\twhile ( low <= high ) {\\r\\n\\r\\n\\t\\t\\t\\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\\r\\n\\r\\n\\t\\t\\t\\tcomparison = arcLengths[ i ] - targetArcLength;\\r\\n\\r\\n\\t\\t\\t\\tif ( comparison < 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tlow = i + 1;\\r\\n\\r\\n\\t\\t\\t\\t} else if ( comparison > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\thigh = i - 1;\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\thigh = i;\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t// DONE\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\ti = high;\\r\\n\\r\\n\\t\\t\\tif ( arcLengths[ i ] === targetArcLength ) {\\r\\n\\r\\n\\t\\t\\t\\treturn i / ( il - 1 );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// we could get finer grain at lengths, or use simple interpolation between two points\\r\\n\\r\\n\\t\\t\\tvar lengthBefore = arcLengths[ i ];\\r\\n\\t\\t\\tvar lengthAfter = arcLengths[ i + 1 ];\\r\\n\\r\\n\\t\\t\\tvar segmentLength = lengthAfter - lengthBefore;\\r\\n\\r\\n\\t\\t\\t// determine where we are between the 'before' and 'after' points\\r\\n\\r\\n\\t\\t\\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\\r\\n\\r\\n\\t\\t\\t// add that fractional amount to t\\r\\n\\r\\n\\t\\t\\tvar t = ( i + segmentFraction ) / ( il - 1 );\\r\\n\\r\\n\\t\\t\\treturn t;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// Returns a unit vector tangent at t\\r\\n\\t\\t// In case any sub curve does not implement its tangent derivation,\\r\\n\\t\\t// 2 points a small delta apart will be used to find its gradient\\r\\n\\t\\t// which seems to give a reasonable approximation\\r\\n\\r\\n\\t\\tgetTangent: function ( t ) {\\r\\n\\r\\n\\t\\t\\tvar delta = 0.0001;\\r\\n\\t\\t\\tvar t1 = t - delta;\\r\\n\\t\\t\\tvar t2 = t + delta;\\r\\n\\r\\n\\t\\t\\t// Capping in case of danger\\r\\n\\r\\n\\t\\t\\tif ( t1 < 0 ) t1 = 0;\\r\\n\\t\\t\\tif ( t2 > 1 ) t2 = 1;\\r\\n\\r\\n\\t\\t\\tvar pt1 = this.getPoint( t1 );\\r\\n\\t\\t\\tvar pt2 = this.getPoint( t2 );\\r\\n\\r\\n\\t\\t\\tvar vec = pt2.clone().sub( pt1 );\\r\\n\\t\\t\\treturn vec.normalize();\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetTangentAt: function ( u ) {\\r\\n\\r\\n\\t\\t\\tvar t = this.getUtoTmapping( u );\\r\\n\\t\\t\\treturn this.getTangent( t );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcomputeFrenetFrames: function ( segments, closed ) {\\r\\n\\r\\n\\t\\t\\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\\r\\n\\r\\n\\t\\t\\tvar normal = new Vector3();\\r\\n\\r\\n\\t\\t\\tvar tangents = [];\\r\\n\\t\\t\\tvar normals = [];\\r\\n\\t\\t\\tvar binormals = [];\\r\\n\\r\\n\\t\\t\\tvar vec = new Vector3();\\r\\n\\t\\t\\tvar mat = new Matrix4();\\r\\n\\r\\n\\t\\t\\tvar i, u, theta;\\r\\n\\r\\n\\t\\t\\t// compute the tangent vectors for each segment on the curve\\r\\n\\r\\n\\t\\t\\tfor ( i = 0; i <= segments; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tu = i / segments;\\r\\n\\r\\n\\t\\t\\t\\ttangents[ i ] = this.getTangentAt( u );\\r\\n\\t\\t\\t\\ttangents[ i ].normalize();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// select an initial normal vector perpendicular to the first tangent vector,\\r\\n\\t\\t\\t// and in the direction of the minimum tangent xyz component\\r\\n\\r\\n\\t\\t\\tnormals[ 0 ] = new Vector3();\\r\\n\\t\\t\\tbinormals[ 0 ] = new Vector3();\\r\\n\\t\\t\\tvar min = Number.MAX_VALUE;\\r\\n\\t\\t\\tvar tx = Math.abs( tangents[ 0 ].x );\\r\\n\\t\\t\\tvar ty = Math.abs( tangents[ 0 ].y );\\r\\n\\t\\t\\tvar tz = Math.abs( tangents[ 0 ].z );\\r\\n\\r\\n\\t\\t\\tif ( tx <= min ) {\\r\\n\\r\\n\\t\\t\\t\\tmin = tx;\\r\\n\\t\\t\\t\\tnormal.set( 1, 0, 0 );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( ty <= min ) {\\r\\n\\r\\n\\t\\t\\t\\tmin = ty;\\r\\n\\t\\t\\t\\tnormal.set( 0, 1, 0 );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( tz <= min ) {\\r\\n\\r\\n\\t\\t\\t\\tnormal.set( 0, 0, 1 );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\\r\\n\\r\\n\\t\\t\\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\\r\\n\\t\\t\\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\\r\\n\\r\\n\\r\\n\\t\\t\\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\\r\\n\\r\\n\\t\\t\\tfor ( i = 1; i <= segments; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tnormals[ i ] = normals[ i - 1 ].clone();\\r\\n\\r\\n\\t\\t\\t\\tbinormals[ i ] = binormals[ i - 1 ].clone();\\r\\n\\r\\n\\t\\t\\t\\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\\r\\n\\r\\n\\t\\t\\t\\tif ( vec.length() > Number.EPSILON ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvec.normalize();\\r\\n\\r\\n\\t\\t\\t\\t\\ttheta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\\r\\n\\r\\n\\t\\t\\t\\t\\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\\r\\n\\r\\n\\t\\t\\tif ( closed === true ) {\\r\\n\\r\\n\\t\\t\\t\\ttheta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\\r\\n\\t\\t\\t\\ttheta /= segments;\\r\\n\\r\\n\\t\\t\\t\\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\ttheta = - theta;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tfor ( i = 1; i <= segments; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// twist a little...\\r\\n\\t\\t\\t\\t\\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\\r\\n\\t\\t\\t\\t\\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn {\\r\\n\\t\\t\\t\\ttangents: tangents,\\r\\n\\t\\t\\t\\tnormals: normals,\\r\\n\\t\\t\\t\\tbinormals: binormals\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\t\\tthis.arcLengthDivisions = source.arcLengthDivisions;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttoJSON: function () {\\r\\n\\r\\n\\t\\t\\tvar data = {\\r\\n\\t\\t\\t\\tmetadata: {\\r\\n\\t\\t\\t\\t\\tversion: 4.5,\\r\\n\\t\\t\\t\\t\\ttype: 'Curve',\\r\\n\\t\\t\\t\\t\\tgenerator: 'Curve.toJSON'\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\tdata.arcLengthDivisions = this.arcLengthDivisions;\\r\\n\\t\\t\\tdata.type = this.type;\\r\\n\\r\\n\\t\\t\\treturn data;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tfromJSON: function ( json ) {\\r\\n\\r\\n\\t\\t\\tthis.arcLengthDivisions = json.arcLengthDivisions;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tfunction EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\\r\\n\\r\\n\\t\\tCurve.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'EllipseCurve';\\r\\n\\r\\n\\t\\tthis.aX = aX || 0;\\r\\n\\t\\tthis.aY = aY || 0;\\r\\n\\r\\n\\t\\tthis.xRadius = xRadius || 1;\\r\\n\\t\\tthis.yRadius = yRadius || 1;\\r\\n\\r\\n\\t\\tthis.aStartAngle = aStartAngle || 0;\\r\\n\\t\\tthis.aEndAngle = aEndAngle || 2 * Math.PI;\\r\\n\\r\\n\\t\\tthis.aClockwise = aClockwise || false;\\r\\n\\r\\n\\t\\tthis.aRotation = aRotation || 0;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tEllipseCurve.prototype = Object.create( Curve.prototype );\\r\\n\\tEllipseCurve.prototype.constructor = EllipseCurve;\\r\\n\\r\\n\\tEllipseCurve.prototype.isEllipseCurve = true;\\r\\n\\r\\n\\tEllipseCurve.prototype.getPoint = function ( t, optionalTarget ) {\\r\\n\\r\\n\\t\\tvar point = optionalTarget || new Vector2();\\r\\n\\r\\n\\t\\tvar twoPi = Math.PI * 2;\\r\\n\\t\\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\\r\\n\\t\\tvar samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\\r\\n\\r\\n\\t\\t// ensures that deltaAngle is 0 .. 2 PI\\r\\n\\t\\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\\r\\n\\t\\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\\r\\n\\r\\n\\t\\tif ( deltaAngle < Number.EPSILON ) {\\r\\n\\r\\n\\t\\t\\tif ( samePoints ) {\\r\\n\\r\\n\\t\\t\\t\\tdeltaAngle = 0;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tdeltaAngle = twoPi;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this.aClockwise === true && ! samePoints ) {\\r\\n\\r\\n\\t\\t\\tif ( deltaAngle === twoPi ) {\\r\\n\\r\\n\\t\\t\\t\\tdeltaAngle = - twoPi;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tdeltaAngle = deltaAngle - twoPi;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar angle = this.aStartAngle + t * deltaAngle;\\r\\n\\t\\tvar x = this.aX + this.xRadius * Math.cos( angle );\\r\\n\\t\\tvar y = this.aY + this.yRadius * Math.sin( angle );\\r\\n\\r\\n\\t\\tif ( this.aRotation !== 0 ) {\\r\\n\\r\\n\\t\\t\\tvar cos = Math.cos( this.aRotation );\\r\\n\\t\\t\\tvar sin = Math.sin( this.aRotation );\\r\\n\\r\\n\\t\\t\\tvar tx = x - this.aX;\\r\\n\\t\\t\\tvar ty = y - this.aY;\\r\\n\\r\\n\\t\\t\\t// Rotate the point about the center of the ellipse.\\r\\n\\t\\t\\tx = tx * cos - ty * sin + this.aX;\\r\\n\\t\\t\\ty = tx * sin + ty * cos + this.aY;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn point.set( x, y );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tEllipseCurve.prototype.copy = function ( source ) {\\r\\n\\r\\n\\t\\tCurve.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.aX = source.aX;\\r\\n\\t\\tthis.aY = source.aY;\\r\\n\\r\\n\\t\\tthis.xRadius = source.xRadius;\\r\\n\\t\\tthis.yRadius = source.yRadius;\\r\\n\\r\\n\\t\\tthis.aStartAngle = source.aStartAngle;\\r\\n\\t\\tthis.aEndAngle = source.aEndAngle;\\r\\n\\r\\n\\t\\tthis.aClockwise = source.aClockwise;\\r\\n\\r\\n\\t\\tthis.aRotation = source.aRotation;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\tEllipseCurve.prototype.toJSON = function () {\\r\\n\\r\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\r\\n\\r\\n\\t\\tdata.aX = this.aX;\\r\\n\\t\\tdata.aY = this.aY;\\r\\n\\r\\n\\t\\tdata.xRadius = this.xRadius;\\r\\n\\t\\tdata.yRadius = this.yRadius;\\r\\n\\r\\n\\t\\tdata.aStartAngle = this.aStartAngle;\\r\\n\\t\\tdata.aEndAngle = this.aEndAngle;\\r\\n\\r\\n\\t\\tdata.aClockwise = this.aClockwise;\\r\\n\\r\\n\\t\\tdata.aRotation = this.aRotation;\\r\\n\\r\\n\\t\\treturn data;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tEllipseCurve.prototype.fromJSON = function ( json ) {\\r\\n\\r\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\r\\n\\r\\n\\t\\tthis.aX = json.aX;\\r\\n\\t\\tthis.aY = json.aY;\\r\\n\\r\\n\\t\\tthis.xRadius = json.xRadius;\\r\\n\\t\\tthis.yRadius = json.yRadius;\\r\\n\\r\\n\\t\\tthis.aStartAngle = json.aStartAngle;\\r\\n\\t\\tthis.aEndAngle = json.aEndAngle;\\r\\n\\r\\n\\t\\tthis.aClockwise = json.aClockwise;\\r\\n\\r\\n\\t\\tthis.aRotation = json.aRotation;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tfunction ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\\r\\n\\r\\n\\t\\tEllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\\r\\n\\r\\n\\t\\tthis.type = 'ArcCurve';\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tArcCurve.prototype = Object.create( EllipseCurve.prototype );\\r\\n\\tArcCurve.prototype.constructor = ArcCurve;\\r\\n\\r\\n\\tArcCurve.prototype.isArcCurve = true;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author zz85 https://github.com/zz85\\r\\n\\t *\\r\\n\\t * Centripetal CatmullRom Curve - which is useful for avoiding\\r\\n\\t * cusps and self-intersections in non-uniform catmull rom curves.\\r\\n\\t * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\\r\\n\\t *\\r\\n\\t * curve.type accepts centripetal(default), chordal and catmullrom\\r\\n\\t * curve.tension is used for catmullrom which defaults to 0.5\\r\\n\\t */\\r\\n\\r\\n\\r\\n\\t/*\\r\\n\\tBased on an optimized c++ solution in\\r\\n\\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\\r\\n\\t - http://ideone.com/NoEbVM\\r\\n\\r\\n\\tThis CubicPoly class could be used for reusing some variables and calculations,\\r\\n\\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\\r\\n\\twhich can be placed in CurveUtils.\\r\\n\\t*/\\r\\n\\r\\n\\tfunction CubicPoly() {\\r\\n\\r\\n\\t\\tvar c0 = 0, c1 = 0, c2 = 0, c3 = 0;\\r\\n\\r\\n\\t\\t/*\\r\\n\\t\\t * Compute coefficients for a cubic polynomial\\r\\n\\t\\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\\r\\n\\t\\t * such that\\r\\n\\t\\t *   p(0) = x0, p(1) = x1\\r\\n\\t\\t *  and\\r\\n\\t\\t *   p'(0) = t0, p'(1) = t1.\\r\\n\\t\\t */\\r\\n\\t\\tfunction init( x0, x1, t0, t1 ) {\\r\\n\\r\\n\\t\\t\\tc0 = x0;\\r\\n\\t\\t\\tc1 = t0;\\r\\n\\t\\t\\tc2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\\r\\n\\t\\t\\tc3 = 2 * x0 - 2 * x1 + t0 + t1;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn {\\r\\n\\r\\n\\t\\t\\tinitCatmullRom: function ( x0, x1, x2, x3, tension ) {\\r\\n\\r\\n\\t\\t\\t\\tinit( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tinitNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {\\r\\n\\r\\n\\t\\t\\t\\t// compute tangents when parameterized in [t1,t2]\\r\\n\\t\\t\\t\\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\\r\\n\\t\\t\\t\\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\\r\\n\\r\\n\\t\\t\\t\\t// rescale tangents for parametrization in [0,1]\\r\\n\\t\\t\\t\\tt1 *= dt1;\\r\\n\\t\\t\\t\\tt2 *= dt1;\\r\\n\\r\\n\\t\\t\\t\\tinit( x1, x2, t1, t2 );\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tcalc: function ( t ) {\\r\\n\\r\\n\\t\\t\\t\\tvar t2 = t * t;\\r\\n\\t\\t\\t\\tvar t3 = t2 * t;\\r\\n\\t\\t\\t\\treturn c0 + c1 * t + c2 * t2 + c3 * t3;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tvar tmp = new Vector3();\\r\\n\\tvar px = new CubicPoly();\\r\\n\\tvar py = new CubicPoly();\\r\\n\\tvar pz = new CubicPoly();\\r\\n\\r\\n\\tfunction CatmullRomCurve3( points, closed, curveType, tension ) {\\r\\n\\r\\n\\t\\tCurve.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'CatmullRomCurve3';\\r\\n\\r\\n\\t\\tthis.points = points || [];\\r\\n\\t\\tthis.closed = closed || false;\\r\\n\\t\\tthis.curveType = curveType || 'centripetal';\\r\\n\\t\\tthis.tension = tension || 0.5;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tCatmullRomCurve3.prototype = Object.create( Curve.prototype );\\r\\n\\tCatmullRomCurve3.prototype.constructor = CatmullRomCurve3;\\r\\n\\r\\n\\tCatmullRomCurve3.prototype.isCatmullRomCurve3 = true;\\r\\n\\r\\n\\tCatmullRomCurve3.prototype.getPoint = function ( t, optionalTarget ) {\\r\\n\\r\\n\\t\\tvar point = optionalTarget || new Vector3();\\r\\n\\r\\n\\t\\tvar points = this.points;\\r\\n\\t\\tvar l = points.length;\\r\\n\\r\\n\\t\\tvar p = ( l - ( this.closed ? 0 : 1 ) ) * t;\\r\\n\\t\\tvar intPoint = Math.floor( p );\\r\\n\\t\\tvar weight = p - intPoint;\\r\\n\\r\\n\\t\\tif ( this.closed ) {\\r\\n\\r\\n\\t\\t\\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\\r\\n\\r\\n\\t\\t} else if ( weight === 0 && intPoint === l - 1 ) {\\r\\n\\r\\n\\t\\t\\tintPoint = l - 2;\\r\\n\\t\\t\\tweight = 1;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar p0, p1, p2, p3; // 4 points\\r\\n\\r\\n\\t\\tif ( this.closed || intPoint > 0 ) {\\r\\n\\r\\n\\t\\t\\tp0 = points[ ( intPoint - 1 ) % l ];\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t// extrapolate first point\\r\\n\\t\\t\\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\\r\\n\\t\\t\\tp0 = tmp;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tp1 = points[ intPoint % l ];\\r\\n\\t\\tp2 = points[ ( intPoint + 1 ) % l ];\\r\\n\\r\\n\\t\\tif ( this.closed || intPoint + 2 < l ) {\\r\\n\\r\\n\\t\\t\\tp3 = points[ ( intPoint + 2 ) % l ];\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t// extrapolate last point\\r\\n\\t\\t\\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\\r\\n\\t\\t\\tp3 = tmp;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {\\r\\n\\r\\n\\t\\t\\t// init Centripetal / Chordal Catmull-Rom\\r\\n\\t\\t\\tvar pow = this.curveType === 'chordal' ? 0.5 : 0.25;\\r\\n\\t\\t\\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\\r\\n\\t\\t\\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\\r\\n\\t\\t\\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\\r\\n\\r\\n\\t\\t\\t// safety check for repeated points\\r\\n\\t\\t\\tif ( dt1 < 1e-4 ) dt1 = 1.0;\\r\\n\\t\\t\\tif ( dt0 < 1e-4 ) dt0 = dt1;\\r\\n\\t\\t\\tif ( dt2 < 1e-4 ) dt2 = dt1;\\r\\n\\r\\n\\t\\t\\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\\r\\n\\t\\t\\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\\r\\n\\t\\t\\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\\r\\n\\r\\n\\t\\t} else if ( this.curveType === 'catmullrom' ) {\\r\\n\\r\\n\\t\\t\\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );\\r\\n\\t\\t\\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );\\r\\n\\t\\t\\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tpoint.set(\\r\\n\\t\\t\\tpx.calc( weight ),\\r\\n\\t\\t\\tpy.calc( weight ),\\r\\n\\t\\t\\tpz.calc( weight )\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\treturn point;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tCatmullRomCurve3.prototype.copy = function ( source ) {\\r\\n\\r\\n\\t\\tCurve.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.points = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = source.points.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar point = source.points[ i ];\\r\\n\\r\\n\\t\\t\\tthis.points.push( point.clone() );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.closed = source.closed;\\r\\n\\t\\tthis.curveType = source.curveType;\\r\\n\\t\\tthis.tension = source.tension;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tCatmullRomCurve3.prototype.toJSON = function () {\\r\\n\\r\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\r\\n\\r\\n\\t\\tdata.points = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = this.points.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar point = this.points[ i ];\\r\\n\\t\\t\\tdata.points.push( point.toArray() );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tdata.closed = this.closed;\\r\\n\\t\\tdata.curveType = this.curveType;\\r\\n\\t\\tdata.tension = this.tension;\\r\\n\\r\\n\\t\\treturn data;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tCatmullRomCurve3.prototype.fromJSON = function ( json ) {\\r\\n\\r\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\r\\n\\r\\n\\t\\tthis.points = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = json.points.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar point = json.points[ i ];\\r\\n\\t\\t\\tthis.points.push( new Vector3().fromArray( point ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.closed = json.closed;\\r\\n\\t\\tthis.curveType = json.curveType;\\r\\n\\t\\tthis.tension = json.tension;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\r\\n\\t *\\r\\n\\t * Bezier Curves formulas obtained from\\r\\n\\t * http://en.wikipedia.org/wiki/Bzier_curve\\r\\n\\t */\\r\\n\\r\\n\\tfunction CatmullRom( t, p0, p1, p2, p3 ) {\\r\\n\\r\\n\\t\\tvar v0 = ( p2 - p0 ) * 0.5;\\r\\n\\t\\tvar v1 = ( p3 - p1 ) * 0.5;\\r\\n\\t\\tvar t2 = t * t;\\r\\n\\t\\tvar t3 = t * t2;\\r\\n\\t\\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tfunction QuadraticBezierP0( t, p ) {\\r\\n\\r\\n\\t\\tvar k = 1 - t;\\r\\n\\t\\treturn k * k * p;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction QuadraticBezierP1( t, p ) {\\r\\n\\r\\n\\t\\treturn 2 * ( 1 - t ) * t * p;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction QuadraticBezierP2( t, p ) {\\r\\n\\r\\n\\t\\treturn t * t * p;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction QuadraticBezier( t, p0, p1, p2 ) {\\r\\n\\r\\n\\t\\treturn QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +\\r\\n\\t\\t\\tQuadraticBezierP2( t, p2 );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tfunction CubicBezierP0( t, p ) {\\r\\n\\r\\n\\t\\tvar k = 1 - t;\\r\\n\\t\\treturn k * k * k * p;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction CubicBezierP1( t, p ) {\\r\\n\\r\\n\\t\\tvar k = 1 - t;\\r\\n\\t\\treturn 3 * k * k * t * p;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction CubicBezierP2( t, p ) {\\r\\n\\r\\n\\t\\treturn 3 * ( 1 - t ) * t * t * p;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction CubicBezierP3( t, p ) {\\r\\n\\r\\n\\t\\treturn t * t * t * p;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction CubicBezier( t, p0, p1, p2, p3 ) {\\r\\n\\r\\n\\t\\treturn CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +\\r\\n\\t\\t\\tCubicBezierP3( t, p3 );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction CubicBezierCurve( v0, v1, v2, v3 ) {\\r\\n\\r\\n\\t\\tCurve.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'CubicBezierCurve';\\r\\n\\r\\n\\t\\tthis.v0 = v0 || new Vector2();\\r\\n\\t\\tthis.v1 = v1 || new Vector2();\\r\\n\\t\\tthis.v2 = v2 || new Vector2();\\r\\n\\t\\tthis.v3 = v3 || new Vector2();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tCubicBezierCurve.prototype = Object.create( Curve.prototype );\\r\\n\\tCubicBezierCurve.prototype.constructor = CubicBezierCurve;\\r\\n\\r\\n\\tCubicBezierCurve.prototype.isCubicBezierCurve = true;\\r\\n\\r\\n\\tCubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {\\r\\n\\r\\n\\t\\tvar point = optionalTarget || new Vector2();\\r\\n\\r\\n\\t\\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\\r\\n\\r\\n\\t\\tpoint.set(\\r\\n\\t\\t\\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\\r\\n\\t\\t\\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y )\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\treturn point;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tCubicBezierCurve.prototype.copy = function ( source ) {\\r\\n\\r\\n\\t\\tCurve.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.v0.copy( source.v0 );\\r\\n\\t\\tthis.v1.copy( source.v1 );\\r\\n\\t\\tthis.v2.copy( source.v2 );\\r\\n\\t\\tthis.v3.copy( source.v3 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tCubicBezierCurve.prototype.toJSON = function () {\\r\\n\\r\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\r\\n\\r\\n\\t\\tdata.v0 = this.v0.toArray();\\r\\n\\t\\tdata.v1 = this.v1.toArray();\\r\\n\\t\\tdata.v2 = this.v2.toArray();\\r\\n\\t\\tdata.v3 = this.v3.toArray();\\r\\n\\r\\n\\t\\treturn data;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tCubicBezierCurve.prototype.fromJSON = function ( json ) {\\r\\n\\r\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\r\\n\\r\\n\\t\\tthis.v0.fromArray( json.v0 );\\r\\n\\t\\tthis.v1.fromArray( json.v1 );\\r\\n\\t\\tthis.v2.fromArray( json.v2 );\\r\\n\\t\\tthis.v3.fromArray( json.v3 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tfunction CubicBezierCurve3( v0, v1, v2, v3 ) {\\r\\n\\r\\n\\t\\tCurve.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'CubicBezierCurve3';\\r\\n\\r\\n\\t\\tthis.v0 = v0 || new Vector3();\\r\\n\\t\\tthis.v1 = v1 || new Vector3();\\r\\n\\t\\tthis.v2 = v2 || new Vector3();\\r\\n\\t\\tthis.v3 = v3 || new Vector3();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tCubicBezierCurve3.prototype = Object.create( Curve.prototype );\\r\\n\\tCubicBezierCurve3.prototype.constructor = CubicBezierCurve3;\\r\\n\\r\\n\\tCubicBezierCurve3.prototype.isCubicBezierCurve3 = true;\\r\\n\\r\\n\\tCubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {\\r\\n\\r\\n\\t\\tvar point = optionalTarget || new Vector3();\\r\\n\\r\\n\\t\\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\\r\\n\\r\\n\\t\\tpoint.set(\\r\\n\\t\\t\\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\\r\\n\\t\\t\\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y ),\\r\\n\\t\\t\\tCubicBezier( t, v0.z, v1.z, v2.z, v3.z )\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\treturn point;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tCubicBezierCurve3.prototype.copy = function ( source ) {\\r\\n\\r\\n\\t\\tCurve.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.v0.copy( source.v0 );\\r\\n\\t\\tthis.v1.copy( source.v1 );\\r\\n\\t\\tthis.v2.copy( source.v2 );\\r\\n\\t\\tthis.v3.copy( source.v3 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tCubicBezierCurve3.prototype.toJSON = function () {\\r\\n\\r\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\r\\n\\r\\n\\t\\tdata.v0 = this.v0.toArray();\\r\\n\\t\\tdata.v1 = this.v1.toArray();\\r\\n\\t\\tdata.v2 = this.v2.toArray();\\r\\n\\t\\tdata.v3 = this.v3.toArray();\\r\\n\\r\\n\\t\\treturn data;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tCubicBezierCurve3.prototype.fromJSON = function ( json ) {\\r\\n\\r\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\r\\n\\r\\n\\t\\tthis.v0.fromArray( json.v0 );\\r\\n\\t\\tthis.v1.fromArray( json.v1 );\\r\\n\\t\\tthis.v2.fromArray( json.v2 );\\r\\n\\t\\tthis.v3.fromArray( json.v3 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tfunction LineCurve( v1, v2 ) {\\r\\n\\r\\n\\t\\tCurve.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'LineCurve';\\r\\n\\r\\n\\t\\tthis.v1 = v1 || new Vector2();\\r\\n\\t\\tthis.v2 = v2 || new Vector2();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tLineCurve.prototype = Object.create( Curve.prototype );\\r\\n\\tLineCurve.prototype.constructor = LineCurve;\\r\\n\\r\\n\\tLineCurve.prototype.isLineCurve = true;\\r\\n\\r\\n\\tLineCurve.prototype.getPoint = function ( t, optionalTarget ) {\\r\\n\\r\\n\\t\\tvar point = optionalTarget || new Vector2();\\r\\n\\r\\n\\t\\tif ( t === 1 ) {\\r\\n\\r\\n\\t\\t\\tpoint.copy( this.v2 );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tpoint.copy( this.v2 ).sub( this.v1 );\\r\\n\\t\\t\\tpoint.multiplyScalar( t ).add( this.v1 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn point;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t// Line curve is linear, so we can overwrite default getPointAt\\r\\n\\r\\n\\tLineCurve.prototype.getPointAt = function ( u, optionalTarget ) {\\r\\n\\r\\n\\t\\treturn this.getPoint( u, optionalTarget );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tLineCurve.prototype.getTangent = function ( /* t */ ) {\\r\\n\\r\\n\\t\\tvar tangent = this.v2.clone().sub( this.v1 );\\r\\n\\r\\n\\t\\treturn tangent.normalize();\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tLineCurve.prototype.copy = function ( source ) {\\r\\n\\r\\n\\t\\tCurve.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.v1.copy( source.v1 );\\r\\n\\t\\tthis.v2.copy( source.v2 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tLineCurve.prototype.toJSON = function () {\\r\\n\\r\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\r\\n\\r\\n\\t\\tdata.v1 = this.v1.toArray();\\r\\n\\t\\tdata.v2 = this.v2.toArray();\\r\\n\\r\\n\\t\\treturn data;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tLineCurve.prototype.fromJSON = function ( json ) {\\r\\n\\r\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\r\\n\\r\\n\\t\\tthis.v1.fromArray( json.v1 );\\r\\n\\t\\tthis.v2.fromArray( json.v2 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tfunction LineCurve3( v1, v2 ) {\\r\\n\\r\\n\\t\\tCurve.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'LineCurve3';\\r\\n\\r\\n\\t\\tthis.v1 = v1 || new Vector3();\\r\\n\\t\\tthis.v2 = v2 || new Vector3();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tLineCurve3.prototype = Object.create( Curve.prototype );\\r\\n\\tLineCurve3.prototype.constructor = LineCurve3;\\r\\n\\r\\n\\tLineCurve3.prototype.isLineCurve3 = true;\\r\\n\\r\\n\\tLineCurve3.prototype.getPoint = function ( t, optionalTarget ) {\\r\\n\\r\\n\\t\\tvar point = optionalTarget || new Vector3();\\r\\n\\r\\n\\t\\tif ( t === 1 ) {\\r\\n\\r\\n\\t\\t\\tpoint.copy( this.v2 );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tpoint.copy( this.v2 ).sub( this.v1 );\\r\\n\\t\\t\\tpoint.multiplyScalar( t ).add( this.v1 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn point;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t// Line curve is linear, so we can overwrite default getPointAt\\r\\n\\r\\n\\tLineCurve3.prototype.getPointAt = function ( u, optionalTarget ) {\\r\\n\\r\\n\\t\\treturn this.getPoint( u, optionalTarget );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tLineCurve3.prototype.copy = function ( source ) {\\r\\n\\r\\n\\t\\tCurve.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.v1.copy( source.v1 );\\r\\n\\t\\tthis.v2.copy( source.v2 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tLineCurve3.prototype.toJSON = function () {\\r\\n\\r\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\r\\n\\r\\n\\t\\tdata.v1 = this.v1.toArray();\\r\\n\\t\\tdata.v2 = this.v2.toArray();\\r\\n\\r\\n\\t\\treturn data;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tLineCurve3.prototype.fromJSON = function ( json ) {\\r\\n\\r\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\r\\n\\r\\n\\t\\tthis.v1.fromArray( json.v1 );\\r\\n\\t\\tthis.v2.fromArray( json.v2 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tfunction QuadraticBezierCurve( v0, v1, v2 ) {\\r\\n\\r\\n\\t\\tCurve.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'QuadraticBezierCurve';\\r\\n\\r\\n\\t\\tthis.v0 = v0 || new Vector2();\\r\\n\\t\\tthis.v1 = v1 || new Vector2();\\r\\n\\t\\tthis.v2 = v2 || new Vector2();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tQuadraticBezierCurve.prototype = Object.create( Curve.prototype );\\r\\n\\tQuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;\\r\\n\\r\\n\\tQuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;\\r\\n\\r\\n\\tQuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {\\r\\n\\r\\n\\t\\tvar point = optionalTarget || new Vector2();\\r\\n\\r\\n\\t\\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2;\\r\\n\\r\\n\\t\\tpoint.set(\\r\\n\\t\\t\\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\\r\\n\\t\\t\\tQuadraticBezier( t, v0.y, v1.y, v2.y )\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\treturn point;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tQuadraticBezierCurve.prototype.copy = function ( source ) {\\r\\n\\r\\n\\t\\tCurve.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.v0.copy( source.v0 );\\r\\n\\t\\tthis.v1.copy( source.v1 );\\r\\n\\t\\tthis.v2.copy( source.v2 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tQuadraticBezierCurve.prototype.toJSON = function () {\\r\\n\\r\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\r\\n\\r\\n\\t\\tdata.v0 = this.v0.toArray();\\r\\n\\t\\tdata.v1 = this.v1.toArray();\\r\\n\\t\\tdata.v2 = this.v2.toArray();\\r\\n\\r\\n\\t\\treturn data;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tQuadraticBezierCurve.prototype.fromJSON = function ( json ) {\\r\\n\\r\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\r\\n\\r\\n\\t\\tthis.v0.fromArray( json.v0 );\\r\\n\\t\\tthis.v1.fromArray( json.v1 );\\r\\n\\t\\tthis.v2.fromArray( json.v2 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tfunction QuadraticBezierCurve3( v0, v1, v2 ) {\\r\\n\\r\\n\\t\\tCurve.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'QuadraticBezierCurve3';\\r\\n\\r\\n\\t\\tthis.v0 = v0 || new Vector3();\\r\\n\\t\\tthis.v1 = v1 || new Vector3();\\r\\n\\t\\tthis.v2 = v2 || new Vector3();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tQuadraticBezierCurve3.prototype = Object.create( Curve.prototype );\\r\\n\\tQuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;\\r\\n\\r\\n\\tQuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;\\r\\n\\r\\n\\tQuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {\\r\\n\\r\\n\\t\\tvar point = optionalTarget || new Vector3();\\r\\n\\r\\n\\t\\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2;\\r\\n\\r\\n\\t\\tpoint.set(\\r\\n\\t\\t\\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\\r\\n\\t\\t\\tQuadraticBezier( t, v0.y, v1.y, v2.y ),\\r\\n\\t\\t\\tQuadraticBezier( t, v0.z, v1.z, v2.z )\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\treturn point;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tQuadraticBezierCurve3.prototype.copy = function ( source ) {\\r\\n\\r\\n\\t\\tCurve.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.v0.copy( source.v0 );\\r\\n\\t\\tthis.v1.copy( source.v1 );\\r\\n\\t\\tthis.v2.copy( source.v2 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tQuadraticBezierCurve3.prototype.toJSON = function () {\\r\\n\\r\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\r\\n\\r\\n\\t\\tdata.v0 = this.v0.toArray();\\r\\n\\t\\tdata.v1 = this.v1.toArray();\\r\\n\\t\\tdata.v2 = this.v2.toArray();\\r\\n\\r\\n\\t\\treturn data;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tQuadraticBezierCurve3.prototype.fromJSON = function ( json ) {\\r\\n\\r\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\r\\n\\r\\n\\t\\tthis.v0.fromArray( json.v0 );\\r\\n\\t\\tthis.v1.fromArray( json.v1 );\\r\\n\\t\\tthis.v2.fromArray( json.v2 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tfunction SplineCurve( points /* array of Vector2 */ ) {\\r\\n\\r\\n\\t\\tCurve.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'SplineCurve';\\r\\n\\r\\n\\t\\tthis.points = points || [];\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tSplineCurve.prototype = Object.create( Curve.prototype );\\r\\n\\tSplineCurve.prototype.constructor = SplineCurve;\\r\\n\\r\\n\\tSplineCurve.prototype.isSplineCurve = true;\\r\\n\\r\\n\\tSplineCurve.prototype.getPoint = function ( t, optionalTarget ) {\\r\\n\\r\\n\\t\\tvar point = optionalTarget || new Vector2();\\r\\n\\r\\n\\t\\tvar points = this.points;\\r\\n\\t\\tvar p = ( points.length - 1 ) * t;\\r\\n\\r\\n\\t\\tvar intPoint = Math.floor( p );\\r\\n\\t\\tvar weight = p - intPoint;\\r\\n\\r\\n\\t\\tvar p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\\r\\n\\t\\tvar p1 = points[ intPoint ];\\r\\n\\t\\tvar p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\\r\\n\\t\\tvar p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\\r\\n\\r\\n\\t\\tpoint.set(\\r\\n\\t\\t\\tCatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),\\r\\n\\t\\t\\tCatmullRom( weight, p0.y, p1.y, p2.y, p3.y )\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\treturn point;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tSplineCurve.prototype.copy = function ( source ) {\\r\\n\\r\\n\\t\\tCurve.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.points = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = source.points.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar point = source.points[ i ];\\r\\n\\r\\n\\t\\t\\tthis.points.push( point.clone() );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tSplineCurve.prototype.toJSON = function () {\\r\\n\\r\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\r\\n\\r\\n\\t\\tdata.points = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = this.points.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar point = this.points[ i ];\\r\\n\\t\\t\\tdata.points.push( point.toArray() );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn data;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tSplineCurve.prototype.fromJSON = function ( json ) {\\r\\n\\r\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\r\\n\\r\\n\\t\\tthis.points = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = json.points.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar point = json.points[ i ];\\r\\n\\t\\t\\tthis.points.push( new Vector2().fromArray( point ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\r\\n\\tvar Curves = Object.freeze({\\r\\n\\t\\tArcCurve: ArcCurve,\\r\\n\\t\\tCatmullRomCurve3: CatmullRomCurve3,\\r\\n\\t\\tCubicBezierCurve: CubicBezierCurve,\\r\\n\\t\\tCubicBezierCurve3: CubicBezierCurve3,\\r\\n\\t\\tEllipseCurve: EllipseCurve,\\r\\n\\t\\tLineCurve: LineCurve,\\r\\n\\t\\tLineCurve3: LineCurve3,\\r\\n\\t\\tQuadraticBezierCurve: QuadraticBezierCurve,\\r\\n\\t\\tQuadraticBezierCurve3: QuadraticBezierCurve3,\\r\\n\\t\\tSplineCurve: SplineCurve\\r\\n\\t});\\r\\n\\r\\n\\t/**\\r\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\r\\n\\t *\\r\\n\\t **/\\r\\n\\r\\n\\t/**************************************************************\\r\\n\\t *\\tCurved Path - a curve path is simply a array of connected\\r\\n\\t *  curves, but retains the api of a curve\\r\\n\\t **************************************************************/\\r\\n\\r\\n\\tfunction CurvePath() {\\r\\n\\r\\n\\t\\tCurve.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'CurvePath';\\r\\n\\r\\n\\t\\tthis.curves = [];\\r\\n\\t\\tthis.autoClose = false; // Automatically closes the path\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tCurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: CurvePath,\\r\\n\\r\\n\\t\\tadd: function ( curve ) {\\r\\n\\r\\n\\t\\t\\tthis.curves.push( curve );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclosePath: function () {\\r\\n\\r\\n\\t\\t\\t// Add a line curve if start and end of lines are not connected\\r\\n\\t\\t\\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\\r\\n\\t\\t\\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\\r\\n\\r\\n\\t\\t\\tif ( ! startPoint.equals( endPoint ) ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.curves.push( new LineCurve( endPoint, startPoint ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// To get accurate point with reference to\\r\\n\\t\\t// entire path distance at time t,\\r\\n\\t\\t// following has to be done:\\r\\n\\r\\n\\t\\t// 1. Length of each sub path have to be known\\r\\n\\t\\t// 2. Locate and identify type of curve\\r\\n\\t\\t// 3. Get t for the curve\\r\\n\\t\\t// 4. Return curve.getPointAt(t')\\r\\n\\r\\n\\t\\tgetPoint: function ( t ) {\\r\\n\\r\\n\\t\\t\\tvar d = t * this.getLength();\\r\\n\\t\\t\\tvar curveLengths = this.getCurveLengths();\\r\\n\\t\\t\\tvar i = 0;\\r\\n\\r\\n\\t\\t\\t// To think about boundaries points.\\r\\n\\r\\n\\t\\t\\twhile ( i < curveLengths.length ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( curveLengths[ i ] >= d ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar diff = curveLengths[ i ] - d;\\r\\n\\t\\t\\t\\t\\tvar curve = this.curves[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\tvar segmentLength = curve.getLength();\\r\\n\\t\\t\\t\\t\\tvar u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\\r\\n\\r\\n\\t\\t\\t\\t\\treturn curve.getPointAt( u );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\ti ++;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t\\t// loop where sum != 0, sum > d , sum+1 <d\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\\r\\n\\t\\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\\r\\n\\t\\t// getPoint() depends on getLength\\r\\n\\r\\n\\t\\tgetLength: function () {\\r\\n\\r\\n\\t\\t\\tvar lens = this.getCurveLengths();\\r\\n\\t\\t\\treturn lens[ lens.length - 1 ];\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// cacheLengths must be recalculated.\\r\\n\\t\\tupdateArcLengths: function () {\\r\\n\\r\\n\\t\\t\\tthis.needsUpdate = true;\\r\\n\\t\\t\\tthis.cacheLengths = null;\\r\\n\\t\\t\\tthis.getCurveLengths();\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// Compute lengths and cache them\\r\\n\\t\\t// We cannot overwrite getLengths() because UtoT mapping uses it.\\r\\n\\r\\n\\t\\tgetCurveLengths: function () {\\r\\n\\r\\n\\t\\t\\t// We use cache values if curves and cache array are same length\\r\\n\\r\\n\\t\\t\\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\\r\\n\\r\\n\\t\\t\\t\\treturn this.cacheLengths;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// Get length of sub-curve\\r\\n\\t\\t\\t// Push sums into cached array\\r\\n\\r\\n\\t\\t\\tvar lengths = [], sums = 0;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tsums += this.curves[ i ].getLength();\\r\\n\\t\\t\\t\\tlengths.push( sums );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.cacheLengths = lengths;\\r\\n\\r\\n\\t\\t\\treturn lengths;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetSpacedPoints: function ( divisions ) {\\r\\n\\r\\n\\t\\t\\tif ( divisions === undefined ) divisions = 40;\\r\\n\\r\\n\\t\\t\\tvar points = [];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i <= divisions; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tpoints.push( this.getPoint( i / divisions ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( this.autoClose ) {\\r\\n\\r\\n\\t\\t\\t\\tpoints.push( points[ 0 ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn points;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetPoints: function ( divisions ) {\\r\\n\\r\\n\\t\\t\\tdivisions = divisions || 12;\\r\\n\\r\\n\\t\\t\\tvar points = [], last;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar curve = curves[ i ];\\r\\n\\t\\t\\t\\tvar resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2\\r\\n\\t\\t\\t\\t\\t: ( curve && curve.isLineCurve ) ? 1\\r\\n\\t\\t\\t\\t\\t\\t: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length\\r\\n\\t\\t\\t\\t\\t\\t\\t: divisions;\\r\\n\\r\\n\\t\\t\\t\\tvar pts = curve.getPoints( resolution );\\r\\n\\r\\n\\t\\t\\t\\tfor ( var j = 0; j < pts.length; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar point = pts[ j ];\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\\r\\n\\r\\n\\t\\t\\t\\t\\tpoints.push( point );\\r\\n\\t\\t\\t\\t\\tlast = point;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {\\r\\n\\r\\n\\t\\t\\t\\tpoints.push( points[ 0 ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn points;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\t\\tCurve.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\t\\tthis.curves = [];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = source.curves.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar curve = source.curves[ i ];\\r\\n\\r\\n\\t\\t\\t\\tthis.curves.push( curve.clone() );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.autoClose = source.autoClose;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttoJSON: function () {\\r\\n\\r\\n\\t\\t\\tvar data = Curve.prototype.toJSON.call( this );\\r\\n\\r\\n\\t\\t\\tdata.autoClose = this.autoClose;\\r\\n\\t\\t\\tdata.curves = [];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar curve = this.curves[ i ];\\r\\n\\t\\t\\t\\tdata.curves.push( curve.toJSON() );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn data;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tfromJSON: function ( json ) {\\r\\n\\r\\n\\t\\t\\tCurve.prototype.fromJSON.call( this, json );\\r\\n\\r\\n\\t\\t\\tthis.autoClose = json.autoClose;\\r\\n\\t\\t\\tthis.curves = [];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = json.curves.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar curve = json.curves[ i ];\\r\\n\\t\\t\\t\\tthis.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\r\\n\\t * Creates free form 2d path using series of points, lines or curves.\\r\\n\\t **/\\r\\n\\r\\n\\tfunction Path( points ) {\\r\\n\\r\\n\\t\\tCurvePath.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'Path';\\r\\n\\r\\n\\t\\tthis.currentPoint = new Vector2();\\r\\n\\r\\n\\t\\tif ( points ) {\\r\\n\\r\\n\\t\\t\\tthis.setFromPoints( points );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tPath.prototype = Object.assign( Object.create( CurvePath.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: Path,\\r\\n\\r\\n\\t\\tsetFromPoints: function ( points ) {\\r\\n\\r\\n\\t\\t\\tthis.moveTo( points[ 0 ].x, points[ 0 ].y );\\r\\n\\r\\n\\t\\t\\tfor ( var i = 1, l = points.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.lineTo( points[ i ].x, points[ i ].y );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tmoveTo: function ( x, y ) {\\r\\n\\r\\n\\t\\t\\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tlineTo: function ( x, y ) {\\r\\n\\r\\n\\t\\t\\tvar curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\\r\\n\\t\\t\\tthis.curves.push( curve );\\r\\n\\r\\n\\t\\t\\tthis.currentPoint.set( x, y );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\\r\\n\\r\\n\\t\\t\\tvar curve = new QuadraticBezierCurve(\\r\\n\\t\\t\\t\\tthis.currentPoint.clone(),\\r\\n\\t\\t\\t\\tnew Vector2( aCPx, aCPy ),\\r\\n\\t\\t\\t\\tnew Vector2( aX, aY )\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\tthis.curves.push( curve );\\r\\n\\r\\n\\t\\t\\tthis.currentPoint.set( aX, aY );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\\r\\n\\r\\n\\t\\t\\tvar curve = new CubicBezierCurve(\\r\\n\\t\\t\\t\\tthis.currentPoint.clone(),\\r\\n\\t\\t\\t\\tnew Vector2( aCP1x, aCP1y ),\\r\\n\\t\\t\\t\\tnew Vector2( aCP2x, aCP2y ),\\r\\n\\t\\t\\t\\tnew Vector2( aX, aY )\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\tthis.curves.push( curve );\\r\\n\\r\\n\\t\\t\\tthis.currentPoint.set( aX, aY );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsplineThru: function ( pts /*Array of Vector*/ ) {\\r\\n\\r\\n\\t\\t\\tvar npts = [ this.currentPoint.clone() ].concat( pts );\\r\\n\\r\\n\\t\\t\\tvar curve = new SplineCurve( npts );\\r\\n\\t\\t\\tthis.curves.push( curve );\\r\\n\\r\\n\\t\\t\\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\\r\\n\\r\\n\\t\\t\\tvar x0 = this.currentPoint.x;\\r\\n\\t\\t\\tvar y0 = this.currentPoint.y;\\r\\n\\r\\n\\t\\t\\tthis.absarc( aX + x0, aY + y0, aRadius,\\r\\n\\t\\t\\t\\taStartAngle, aEndAngle, aClockwise );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\\r\\n\\r\\n\\t\\t\\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\\r\\n\\r\\n\\t\\t\\tvar x0 = this.currentPoint.x;\\r\\n\\t\\t\\tvar y0 = this.currentPoint.y;\\r\\n\\r\\n\\t\\t\\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\\r\\n\\r\\n\\t\\t\\tvar curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\\r\\n\\r\\n\\t\\t\\tif ( this.curves.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t// if a previous curve is present, attempt to join\\r\\n\\t\\t\\t\\tvar firstPoint = curve.getPoint( 0 );\\r\\n\\r\\n\\t\\t\\t\\tif ( ! firstPoint.equals( this.currentPoint ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.lineTo( firstPoint.x, firstPoint.y );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.curves.push( curve );\\r\\n\\r\\n\\t\\t\\tvar lastPoint = curve.getPoint( 1 );\\r\\n\\t\\t\\tthis.currentPoint.copy( lastPoint );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\t\\tCurvePath.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\t\\tthis.currentPoint.copy( source.currentPoint );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttoJSON: function () {\\r\\n\\r\\n\\t\\t\\tvar data = CurvePath.prototype.toJSON.call( this );\\r\\n\\r\\n\\t\\t\\tdata.currentPoint = this.currentPoint.toArray();\\r\\n\\r\\n\\t\\t\\treturn data;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tfromJSON: function ( json ) {\\r\\n\\r\\n\\t\\t\\tCurvePath.prototype.fromJSON.call( this, json );\\r\\n\\r\\n\\t\\t\\tthis.currentPoint.fromArray( json.currentPoint );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\r\\n\\t * Defines a 2d shape plane using paths.\\r\\n\\t **/\\r\\n\\r\\n\\t// STEP 1 Create a path.\\r\\n\\t// STEP 2 Turn path into shape.\\r\\n\\t// STEP 3 ExtrudeGeometry takes in Shape/Shapes\\r\\n\\t// STEP 3a - Extract points from each shape, turn to vertices\\r\\n\\t// STEP 3b - Triangulate each shape, add faces.\\r\\n\\r\\n\\tfunction Shape( points ) {\\r\\n\\r\\n\\t\\tPath.call( this, points );\\r\\n\\r\\n\\t\\tthis.uuid = _Math.generateUUID();\\r\\n\\r\\n\\t\\tthis.type = 'Shape';\\r\\n\\r\\n\\t\\tthis.holes = [];\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tShape.prototype = Object.assign( Object.create( Path.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: Shape,\\r\\n\\r\\n\\t\\tgetPointsHoles: function ( divisions ) {\\r\\n\\r\\n\\t\\t\\tvar holesPts = [];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn holesPts;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// get points of shape and holes (keypoints based on segments parameter)\\r\\n\\r\\n\\t\\textractPoints: function ( divisions ) {\\r\\n\\r\\n\\t\\t\\treturn {\\r\\n\\r\\n\\t\\t\\t\\tshape: this.getPoints( divisions ),\\r\\n\\t\\t\\t\\tholes: this.getPointsHoles( divisions )\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\t\\tPath.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\t\\tthis.holes = [];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = source.holes.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar hole = source.holes[ i ];\\r\\n\\r\\n\\t\\t\\t\\tthis.holes.push( hole.clone() );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttoJSON: function () {\\r\\n\\r\\n\\t\\t\\tvar data = Path.prototype.toJSON.call( this );\\r\\n\\r\\n\\t\\t\\tdata.uuid = this.uuid;\\r\\n\\t\\t\\tdata.holes = [];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar hole = this.holes[ i ];\\r\\n\\t\\t\\t\\tdata.holes.push( hole.toJSON() );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn data;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tfromJSON: function ( json ) {\\r\\n\\r\\n\\t\\t\\tPath.prototype.fromJSON.call( this, json );\\r\\n\\r\\n\\t\\t\\tthis.uuid = json.uuid;\\r\\n\\t\\t\\tthis.holes = [];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = json.holes.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar hole = json.holes[ i ];\\r\\n\\t\\t\\t\\tthis.holes.push( new Path().fromJSON( hole ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction Light( color, intensity ) {\\r\\n\\r\\n\\t\\tObject3D.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'Light';\\r\\n\\r\\n\\t\\tthis.color = new Color( color );\\r\\n\\t\\tthis.intensity = intensity !== undefined ? intensity : 1;\\r\\n\\r\\n\\t\\tthis.receiveShadow = undefined;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tLight.prototype = Object.assign( Object.create( Object3D.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: Light,\\r\\n\\r\\n\\t\\tisLight: true,\\r\\n\\r\\n\\t\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\t\\tObject3D.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\t\\tthis.color.copy( source.color );\\r\\n\\t\\t\\tthis.intensity = source.intensity;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttoJSON: function ( meta ) {\\r\\n\\r\\n\\t\\t\\tvar data = Object3D.prototype.toJSON.call( this, meta );\\r\\n\\r\\n\\t\\t\\tdata.object.color = this.color.getHex();\\r\\n\\t\\t\\tdata.object.intensity = this.intensity;\\r\\n\\r\\n\\t\\t\\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\\r\\n\\r\\n\\t\\t\\tif ( this.distance !== undefined ) data.object.distance = this.distance;\\r\\n\\t\\t\\tif ( this.angle !== undefined ) data.object.angle = this.angle;\\r\\n\\t\\t\\tif ( this.decay !== undefined ) data.object.decay = this.decay;\\r\\n\\t\\t\\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\\r\\n\\r\\n\\t\\t\\tif ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();\\r\\n\\r\\n\\t\\t\\treturn data;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction HemisphereLight( skyColor, groundColor, intensity ) {\\r\\n\\r\\n\\t\\tLight.call( this, skyColor, intensity );\\r\\n\\r\\n\\t\\tthis.type = 'HemisphereLight';\\r\\n\\r\\n\\t\\tthis.castShadow = undefined;\\r\\n\\r\\n\\t\\tthis.position.copy( Object3D.DefaultUp );\\r\\n\\t\\tthis.updateMatrix();\\r\\n\\r\\n\\t\\tthis.groundColor = new Color( groundColor );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tHemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: HemisphereLight,\\r\\n\\r\\n\\t\\tisHemisphereLight: true,\\r\\n\\r\\n\\t\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\t\\tLight.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\t\\tthis.groundColor.copy( source.groundColor );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction LightShadow( camera ) {\\r\\n\\r\\n\\t\\tthis.camera = camera;\\r\\n\\r\\n\\t\\tthis.bias = 0;\\r\\n\\t\\tthis.radius = 1;\\r\\n\\r\\n\\t\\tthis.mapSize = new Vector2( 512, 512 );\\r\\n\\r\\n\\t\\tthis.map = null;\\r\\n\\t\\tthis.matrix = new Matrix4();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( LightShadow.prototype, {\\r\\n\\r\\n\\t\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\t\\tthis.camera = source.camera.clone();\\r\\n\\r\\n\\t\\t\\tthis.bias = source.bias;\\r\\n\\t\\t\\tthis.radius = source.radius;\\r\\n\\r\\n\\t\\t\\tthis.mapSize.copy( source.mapSize );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttoJSON: function () {\\r\\n\\r\\n\\t\\t\\tvar object = {};\\r\\n\\r\\n\\t\\t\\tif ( this.bias !== 0 ) object.bias = this.bias;\\r\\n\\t\\t\\tif ( this.radius !== 1 ) object.radius = this.radius;\\r\\n\\t\\t\\tif ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();\\r\\n\\r\\n\\t\\t\\tobject.camera = this.camera.toJSON( false ).object;\\r\\n\\t\\t\\tdelete object.camera.matrix;\\r\\n\\r\\n\\t\\t\\treturn object;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction SpotLightShadow() {\\r\\n\\r\\n\\t\\tLightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tSpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: SpotLightShadow,\\r\\n\\r\\n\\t\\tisSpotLightShadow: true,\\r\\n\\r\\n\\t\\tupdate: function ( light ) {\\r\\n\\r\\n\\t\\t\\tvar camera = this.camera;\\r\\n\\r\\n\\t\\t\\tvar fov = _Math.RAD2DEG * 2 * light.angle;\\r\\n\\t\\t\\tvar aspect = this.mapSize.width / this.mapSize.height;\\r\\n\\t\\t\\tvar far = light.distance || camera.far;\\r\\n\\r\\n\\t\\t\\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\\r\\n\\r\\n\\t\\t\\t\\tcamera.fov = fov;\\r\\n\\t\\t\\t\\tcamera.aspect = aspect;\\r\\n\\t\\t\\t\\tcamera.far = far;\\r\\n\\t\\t\\t\\tcamera.updateProjectionMatrix();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction SpotLight( color, intensity, distance, angle, penumbra, decay ) {\\r\\n\\r\\n\\t\\tLight.call( this, color, intensity );\\r\\n\\r\\n\\t\\tthis.type = 'SpotLight';\\r\\n\\r\\n\\t\\tthis.position.copy( Object3D.DefaultUp );\\r\\n\\t\\tthis.updateMatrix();\\r\\n\\r\\n\\t\\tthis.target = new Object3D();\\r\\n\\r\\n\\t\\tObject.defineProperty( this, 'power', {\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\t// intensity = power per solid angle.\\r\\n\\t\\t\\t\\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\\r\\n\\t\\t\\t\\treturn this.intensity * Math.PI;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tset: function ( power ) {\\r\\n\\r\\n\\t\\t\\t\\t// intensity = power per solid angle.\\r\\n\\t\\t\\t\\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\\r\\n\\t\\t\\t\\tthis.intensity = power / Math.PI;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t} );\\r\\n\\r\\n\\t\\tthis.distance = ( distance !== undefined ) ? distance : 0;\\r\\n\\t\\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\\r\\n\\t\\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\\r\\n\\t\\tthis.decay = ( decay !== undefined ) ? decay : 1;\\t// for physically correct lights, should be 2.\\r\\n\\r\\n\\t\\tthis.shadow = new SpotLightShadow();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tSpotLight.prototype = Object.assign( Object.create( Light.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: SpotLight,\\r\\n\\r\\n\\t\\tisSpotLight: true,\\r\\n\\r\\n\\t\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\t\\tLight.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\t\\tthis.distance = source.distance;\\r\\n\\t\\t\\tthis.angle = source.angle;\\r\\n\\t\\t\\tthis.penumbra = source.penumbra;\\r\\n\\t\\t\\tthis.decay = source.decay;\\r\\n\\r\\n\\t\\t\\tthis.target = source.target.clone();\\r\\n\\r\\n\\t\\t\\tthis.shadow = source.shadow.clone();\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\r\\n\\tfunction PointLight( color, intensity, distance, decay ) {\\r\\n\\r\\n\\t\\tLight.call( this, color, intensity );\\r\\n\\r\\n\\t\\tthis.type = 'PointLight';\\r\\n\\r\\n\\t\\tObject.defineProperty( this, 'power', {\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\t// intensity = power per solid angle.\\r\\n\\t\\t\\t\\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\\r\\n\\t\\t\\t\\treturn this.intensity * 4 * Math.PI;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tset: function ( power ) {\\r\\n\\r\\n\\t\\t\\t\\t// intensity = power per solid angle.\\r\\n\\t\\t\\t\\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\\r\\n\\t\\t\\t\\tthis.intensity = power / ( 4 * Math.PI );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t} );\\r\\n\\r\\n\\t\\tthis.distance = ( distance !== undefined ) ? distance : 0;\\r\\n\\t\\tthis.decay = ( decay !== undefined ) ? decay : 1;\\t// for physically correct lights, should be 2.\\r\\n\\r\\n\\t\\tthis.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tPointLight.prototype = Object.assign( Object.create( Light.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: PointLight,\\r\\n\\r\\n\\t\\tisPointLight: true,\\r\\n\\r\\n\\t\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\t\\tLight.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\t\\tthis.distance = source.distance;\\r\\n\\t\\t\\tthis.decay = source.decay;\\r\\n\\r\\n\\t\\t\\tthis.shadow = source.shadow.clone();\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction DirectionalLightShadow( ) {\\r\\n\\r\\n\\t\\tLightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tDirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: DirectionalLightShadow\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction DirectionalLight( color, intensity ) {\\r\\n\\r\\n\\t\\tLight.call( this, color, intensity );\\r\\n\\r\\n\\t\\tthis.type = 'DirectionalLight';\\r\\n\\r\\n\\t\\tthis.position.copy( Object3D.DefaultUp );\\r\\n\\t\\tthis.updateMatrix();\\r\\n\\r\\n\\t\\tthis.target = new Object3D();\\r\\n\\r\\n\\t\\tthis.shadow = new DirectionalLightShadow();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tDirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: DirectionalLight,\\r\\n\\r\\n\\t\\tisDirectionalLight: true,\\r\\n\\r\\n\\t\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\t\\tLight.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\t\\tthis.target = source.target.clone();\\r\\n\\r\\n\\t\\t\\tthis.shadow = source.shadow.clone();\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction AmbientLight( color, intensity ) {\\r\\n\\r\\n\\t\\tLight.call( this, color, intensity );\\r\\n\\r\\n\\t\\tthis.type = 'AmbientLight';\\r\\n\\r\\n\\t\\tthis.castShadow = undefined;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tAmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: AmbientLight,\\r\\n\\r\\n\\t\\tisAmbientLight: true\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author abelnation / http://github.com/abelnation\\r\\n\\t */\\r\\n\\r\\n\\tfunction RectAreaLight( color, intensity, width, height ) {\\r\\n\\r\\n\\t\\tLight.call( this, color, intensity );\\r\\n\\r\\n\\t\\tthis.type = 'RectAreaLight';\\r\\n\\r\\n\\t\\tthis.position.set( 0, 1, 0 );\\r\\n\\t\\tthis.updateMatrix();\\r\\n\\r\\n\\t\\tthis.width = ( width !== undefined ) ? width : 10;\\r\\n\\t\\tthis.height = ( height !== undefined ) ? height : 10;\\r\\n\\r\\n\\t\\t// TODO (abelnation): distance/decay\\r\\n\\r\\n\\t\\t// TODO (abelnation): update method for RectAreaLight to update transform to lookat target\\r\\n\\r\\n\\t\\t// TODO (abelnation): shadows\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// TODO (abelnation): RectAreaLight update when light shape is changed\\r\\n\\tRectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: RectAreaLight,\\r\\n\\r\\n\\t\\tisRectAreaLight: true,\\r\\n\\r\\n\\t\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\t\\tLight.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\t\\tthis.width = source.width;\\r\\n\\t\\t\\tthis.height = source.height;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttoJSON: function ( meta ) {\\r\\n\\r\\n\\t\\t\\tvar data = Light.prototype.toJSON.call( this, meta );\\r\\n\\r\\n\\t\\t\\tdata.object.width = this.width;\\r\\n\\t\\t\\tdata.object.height = this.height;\\r\\n\\r\\n\\t\\t\\treturn data;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t *\\r\\n\\t * A Track that interpolates Strings\\r\\n\\t *\\r\\n\\t *\\r\\n\\t * @author Ben Houston / http://clara.io/\\r\\n\\t * @author David Sarno / http://lighthaus.us/\\r\\n\\t * @author tschw\\r\\n\\t */\\r\\n\\r\\n\\tfunction StringKeyframeTrack( name, times, values, interpolation ) {\\r\\n\\r\\n\\t\\tKeyframeTrack.call( this, name, times, values, interpolation );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tStringKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: StringKeyframeTrack,\\r\\n\\r\\n\\t\\tValueTypeName: 'string',\\r\\n\\t\\tValueBufferType: Array,\\r\\n\\r\\n\\t\\tDefaultInterpolation: InterpolateDiscrete,\\r\\n\\r\\n\\t\\tInterpolantFactoryMethodLinear: undefined,\\r\\n\\r\\n\\t\\tInterpolantFactoryMethodSmooth: undefined\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t *\\r\\n\\t * A Track of Boolean keyframe values.\\r\\n\\t *\\r\\n\\t *\\r\\n\\t * @author Ben Houston / http://clara.io/\\r\\n\\t * @author David Sarno / http://lighthaus.us/\\r\\n\\t * @author tschw\\r\\n\\t */\\r\\n\\r\\n\\tfunction BooleanKeyframeTrack( name, times, values ) {\\r\\n\\r\\n\\t\\tKeyframeTrack.call( this, name, times, values );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tBooleanKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: BooleanKeyframeTrack,\\r\\n\\r\\n\\t\\tValueTypeName: 'bool',\\r\\n\\t\\tValueBufferType: Array,\\r\\n\\r\\n\\t\\tDefaultInterpolation: InterpolateDiscrete,\\r\\n\\r\\n\\t\\tInterpolantFactoryMethodLinear: undefined,\\r\\n\\t\\tInterpolantFactoryMethodSmooth: undefined\\r\\n\\r\\n\\t\\t// Note: Actually this track could have a optimized / compressed\\r\\n\\t\\t// representation of a single value and a custom interpolant that\\r\\n\\t\\t// computes \\\"firstValue ^ isOdd( index )\\\".\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * Abstract base class of interpolants over parametric samples.\\r\\n\\t *\\r\\n\\t * The parameter domain is one dimensional, typically the time or a path\\r\\n\\t * along a curve defined by the data.\\r\\n\\t *\\r\\n\\t * The sample values can have any dimensionality and derived classes may\\r\\n\\t * apply special interpretations to the data.\\r\\n\\t *\\r\\n\\t * This class provides the interval seek in a Template Method, deferring\\r\\n\\t * the actual interpolation to derived classes.\\r\\n\\t *\\r\\n\\t * Time complexity is O(1) for linear access crossing at most two points\\r\\n\\t * and O(log N) for random access, where N is the number of positions.\\r\\n\\t *\\r\\n\\t * References:\\r\\n\\t *\\r\\n\\t * \\t\\thttp://www.oodesign.com/template-method-pattern.html\\r\\n\\t *\\r\\n\\t * @author tschw\\r\\n\\t */\\r\\n\\r\\n\\tfunction Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\\r\\n\\r\\n\\t\\tthis.parameterPositions = parameterPositions;\\r\\n\\t\\tthis._cachedIndex = 0;\\r\\n\\r\\n\\t\\tthis.resultBuffer = resultBuffer !== undefined ?\\r\\n\\t\\t\\tresultBuffer : new sampleValues.constructor( sampleSize );\\r\\n\\t\\tthis.sampleValues = sampleValues;\\r\\n\\t\\tthis.valueSize = sampleSize;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( Interpolant.prototype, {\\r\\n\\r\\n\\t\\tevaluate: function ( t ) {\\r\\n\\r\\n\\t\\t\\tvar pp = this.parameterPositions,\\r\\n\\t\\t\\t\\ti1 = this._cachedIndex,\\r\\n\\r\\n\\t\\t\\t\\tt1 = pp[ i1 ],\\r\\n\\t\\t\\t\\tt0 = pp[ i1 - 1 ];\\r\\n\\r\\n\\t\\t\\tvalidate_interval: {\\r\\n\\r\\n\\t\\t\\t\\tseek: {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar right;\\r\\n\\r\\n\\t\\t\\t\\t\\tlinear_scan: {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t//- See http://jsperf.com/comparison-to-undefined/3\\r\\n\\t\\t\\t\\t\\t\\t//- slower code:\\r\\n\\t\\t\\t\\t\\t\\t//-\\r\\n\\t\\t\\t\\t\\t\\t//- \\t\\t\\t\\tif ( t >= t1 || t1 === undefined ) {\\r\\n\\t\\t\\t\\t\\t\\tforward_scan: if ( ! ( t < t1 ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tfor ( var giveUpAt = i1 + 2; ; ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( t1 === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( t < t0 ) break forward_scan;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// after end\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ti1 = pp.length;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tthis._cachedIndex = i1;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturn this.afterEnd_( i1 - 1, t, t0 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( i1 === giveUpAt ) break; // this loop\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tt0 = t1;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tt1 = pp[ ++ i1 ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( t < t1 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// we have arrived at the sought interval\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak seek;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t// prepare binary search on the right side of the index\\r\\n\\t\\t\\t\\t\\t\\t\\tright = pp.length;\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak linear_scan;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t//- slower code:\\r\\n\\t\\t\\t\\t\\t\\t//-\\t\\t\\t\\t\\tif ( t < t0 || t0 === undefined ) {\\r\\n\\t\\t\\t\\t\\t\\tif ( ! ( t >= t0 ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t// looping?\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar t1global = pp[ 1 ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( t < t1global ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\ti1 = 2; // + 1, using the scan for the details\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tt0 = t1global;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t// linear reverse scan\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tfor ( var giveUpAt = i1 - 2; ; ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( t0 === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// before start\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tthis._cachedIndex = 0;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturn this.beforeStart_( 0, t, t1 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( i1 === giveUpAt ) break; // this loop\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tt1 = t0;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tt0 = pp[ -- i1 - 1 ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( t >= t0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// we have arrived at the sought interval\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak seek;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t// prepare binary search on the left side of the index\\r\\n\\t\\t\\t\\t\\t\\t\\tright = i1;\\r\\n\\t\\t\\t\\t\\t\\t\\ti1 = 0;\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak linear_scan;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// the interval is valid\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak validate_interval;\\r\\n\\r\\n\\t\\t\\t\\t\\t} // linear scan\\r\\n\\r\\n\\t\\t\\t\\t\\t// binary search\\r\\n\\r\\n\\t\\t\\t\\t\\twhile ( i1 < right ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar mid = ( i1 + right ) >>> 1;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( t < pp[ mid ] ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tright = mid;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\ti1 = mid + 1;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tt1 = pp[ i1 ];\\r\\n\\t\\t\\t\\t\\tt0 = pp[ i1 - 1 ];\\r\\n\\r\\n\\t\\t\\t\\t\\t// check boundary cases, again\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( t0 === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tthis._cachedIndex = 0;\\r\\n\\t\\t\\t\\t\\t\\treturn this.beforeStart_( 0, t, t1 );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( t1 === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ti1 = pp.length;\\r\\n\\t\\t\\t\\t\\t\\tthis._cachedIndex = i1;\\r\\n\\t\\t\\t\\t\\t\\treturn this.afterEnd_( i1 - 1, t0, t );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} // seek\\r\\n\\r\\n\\t\\t\\t\\tthis._cachedIndex = i1;\\r\\n\\r\\n\\t\\t\\t\\tthis.intervalChanged_( i1, t0, t1 );\\r\\n\\r\\n\\t\\t\\t} // validate_interval\\r\\n\\r\\n\\t\\t\\treturn this.interpolate_( i1, t0, t, t1 );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsettings: null, // optional, subclass-specific settings structure\\r\\n\\t\\t// Note: The indirection allows central control of many interpolants.\\r\\n\\r\\n\\t\\t// --- Protected interface\\r\\n\\r\\n\\t\\tDefaultSettings_: {},\\r\\n\\r\\n\\t\\tgetSettings_: function () {\\r\\n\\r\\n\\t\\t\\treturn this.settings || this.DefaultSettings_;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopySampleValue_: function ( index ) {\\r\\n\\r\\n\\t\\t\\t// copies a sample value to the result buffer\\r\\n\\r\\n\\t\\t\\tvar result = this.resultBuffer,\\r\\n\\t\\t\\t\\tvalues = this.sampleValues,\\r\\n\\t\\t\\t\\tstride = this.valueSize,\\r\\n\\t\\t\\t\\toffset = index * stride;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tresult[ i ] = values[ offset + i ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn result;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// Template methods for derived classes:\\r\\n\\r\\n\\t\\tinterpolate_: function ( /* i1, t0, t, t1 */ ) {\\r\\n\\r\\n\\t\\t\\tthrow new Error( 'call to abstract method' );\\r\\n\\t\\t\\t// implementations shall return this.resultBuffer\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tintervalChanged_: function ( /* i1, t0, t1 */ ) {\\r\\n\\r\\n\\t\\t\\t// empty\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t//!\\\\ DECLARE ALIAS AFTER assign prototype !\\r\\n\\tObject.assign( Interpolant.prototype, {\\r\\n\\r\\n\\t\\t//( 0, t, t0 ), returns this.resultBuffer\\r\\n\\t\\tbeforeStart_: Interpolant.prototype.copySampleValue_,\\r\\n\\r\\n\\t\\t//( N-1, tN-1, t ), returns this.resultBuffer\\r\\n\\t\\tafterEnd_: Interpolant.prototype.copySampleValue_,\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * Spherical linear unit quaternion interpolant.\\r\\n\\t *\\r\\n\\t * @author tschw\\r\\n\\t */\\r\\n\\r\\n\\tfunction QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\\r\\n\\r\\n\\t\\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tQuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: QuaternionLinearInterpolant,\\r\\n\\r\\n\\t\\tinterpolate_: function ( i1, t0, t, t1 ) {\\r\\n\\r\\n\\t\\t\\tvar result = this.resultBuffer,\\r\\n\\t\\t\\t\\tvalues = this.sampleValues,\\r\\n\\t\\t\\t\\tstride = this.valueSize,\\r\\n\\r\\n\\t\\t\\t\\toffset = i1 * stride,\\r\\n\\r\\n\\t\\t\\t\\talpha = ( t - t0 ) / ( t1 - t0 );\\r\\n\\r\\n\\t\\t\\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\\r\\n\\r\\n\\t\\t\\t\\tQuaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn result;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t *\\r\\n\\t * A Track of quaternion keyframe values.\\r\\n\\t *\\r\\n\\t * @author Ben Houston / http://clara.io/\\r\\n\\t * @author David Sarno / http://lighthaus.us/\\r\\n\\t * @author tschw\\r\\n\\t */\\r\\n\\r\\n\\tfunction QuaternionKeyframeTrack( name, times, values, interpolation ) {\\r\\n\\r\\n\\t\\tKeyframeTrack.call( this, name, times, values, interpolation );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tQuaternionKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: QuaternionKeyframeTrack,\\r\\n\\r\\n\\t\\tValueTypeName: 'quaternion',\\r\\n\\r\\n\\t\\t// ValueBufferType is inherited\\r\\n\\r\\n\\t\\tDefaultInterpolation: InterpolateLinear,\\r\\n\\r\\n\\t\\tInterpolantFactoryMethodLinear: function ( result ) {\\r\\n\\r\\n\\t\\t\\treturn new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t *\\r\\n\\t * A Track of keyframe values that represent color.\\r\\n\\t *\\r\\n\\t *\\r\\n\\t * @author Ben Houston / http://clara.io/\\r\\n\\t * @author David Sarno / http://lighthaus.us/\\r\\n\\t * @author tschw\\r\\n\\t */\\r\\n\\r\\n\\tfunction ColorKeyframeTrack( name, times, values, interpolation ) {\\r\\n\\r\\n\\t\\tKeyframeTrack.call( this, name, times, values, interpolation );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tColorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: ColorKeyframeTrack,\\r\\n\\r\\n\\t\\tValueTypeName: 'color'\\r\\n\\r\\n\\t\\t// ValueBufferType is inherited\\r\\n\\r\\n\\t\\t// DefaultInterpolation is inherited\\r\\n\\r\\n\\t\\t// Note: Very basic implementation and nothing special yet.\\r\\n\\t\\t// However, this is the place for color space parameterization.\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t *\\r\\n\\t * A Track of numeric keyframe values.\\r\\n\\t *\\r\\n\\t * @author Ben Houston / http://clara.io/\\r\\n\\t * @author David Sarno / http://lighthaus.us/\\r\\n\\t * @author tschw\\r\\n\\t */\\r\\n\\r\\n\\tfunction NumberKeyframeTrack( name, times, values, interpolation ) {\\r\\n\\r\\n\\t\\tKeyframeTrack.call( this, name, times, values, interpolation );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tNumberKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: NumberKeyframeTrack,\\r\\n\\r\\n\\t\\tValueTypeName: 'number'\\r\\n\\r\\n\\t\\t// ValueBufferType is inherited\\r\\n\\r\\n\\t\\t// DefaultInterpolation is inherited\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * Fast and simple cubic spline interpolant.\\r\\n\\t *\\r\\n\\t * It was derived from a Hermitian construction setting the first derivative\\r\\n\\t * at each sample position to the linear slope between neighboring positions\\r\\n\\t * over their parameter interval.\\r\\n\\t *\\r\\n\\t * @author tschw\\r\\n\\t */\\r\\n\\r\\n\\tfunction CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\\r\\n\\r\\n\\t\\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\\r\\n\\r\\n\\t\\tthis._weightPrev = - 0;\\r\\n\\t\\tthis._offsetPrev = - 0;\\r\\n\\t\\tthis._weightNext = - 0;\\r\\n\\t\\tthis._offsetNext = - 0;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tCubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: CubicInterpolant,\\r\\n\\r\\n\\t\\tDefaultSettings_: {\\r\\n\\r\\n\\t\\t\\tendingStart: ZeroCurvatureEnding,\\r\\n\\t\\t\\tendingEnd: ZeroCurvatureEnding\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tintervalChanged_: function ( i1, t0, t1 ) {\\r\\n\\r\\n\\t\\t\\tvar pp = this.parameterPositions,\\r\\n\\t\\t\\t\\tiPrev = i1 - 2,\\r\\n\\t\\t\\t\\tiNext = i1 + 1,\\r\\n\\r\\n\\t\\t\\t\\ttPrev = pp[ iPrev ],\\r\\n\\t\\t\\t\\ttNext = pp[ iNext ];\\r\\n\\r\\n\\t\\t\\tif ( tPrev === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tswitch ( this.getSettings_().endingStart ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcase ZeroSlopeEnding:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// f'(t0) = 0\\r\\n\\t\\t\\t\\t\\t\\tiPrev = i1;\\r\\n\\t\\t\\t\\t\\t\\ttPrev = 2 * t0 - t1;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase WrapAroundEnding:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// use the other end of the curve\\r\\n\\t\\t\\t\\t\\t\\tiPrev = pp.length - 2;\\r\\n\\t\\t\\t\\t\\t\\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tdefault: // ZeroCurvatureEnding\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// f''(t0) = 0 a.k.a. Natural Spline\\r\\n\\t\\t\\t\\t\\t\\tiPrev = i1;\\r\\n\\t\\t\\t\\t\\t\\ttPrev = t1;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( tNext === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tswitch ( this.getSettings_().endingEnd ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcase ZeroSlopeEnding:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// f'(tN) = 0\\r\\n\\t\\t\\t\\t\\t\\tiNext = i1;\\r\\n\\t\\t\\t\\t\\t\\ttNext = 2 * t1 - t0;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase WrapAroundEnding:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// use the other end of the curve\\r\\n\\t\\t\\t\\t\\t\\tiNext = 1;\\r\\n\\t\\t\\t\\t\\t\\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tdefault: // ZeroCurvatureEnding\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// f''(tN) = 0, a.k.a. Natural Spline\\r\\n\\t\\t\\t\\t\\t\\tiNext = i1 - 1;\\r\\n\\t\\t\\t\\t\\t\\ttNext = t0;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar halfDt = ( t1 - t0 ) * 0.5,\\r\\n\\t\\t\\t\\tstride = this.valueSize;\\r\\n\\r\\n\\t\\t\\tthis._weightPrev = halfDt / ( t0 - tPrev );\\r\\n\\t\\t\\tthis._weightNext = halfDt / ( tNext - t1 );\\r\\n\\t\\t\\tthis._offsetPrev = iPrev * stride;\\r\\n\\t\\t\\tthis._offsetNext = iNext * stride;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tinterpolate_: function ( i1, t0, t, t1 ) {\\r\\n\\r\\n\\t\\t\\tvar result = this.resultBuffer,\\r\\n\\t\\t\\t\\tvalues = this.sampleValues,\\r\\n\\t\\t\\t\\tstride = this.valueSize,\\r\\n\\r\\n\\t\\t\\t\\to1 = i1 * stride,\\t\\to0 = o1 - stride,\\r\\n\\t\\t\\t\\toP = this._offsetPrev, \\toN = this._offsetNext,\\r\\n\\t\\t\\t\\twP = this._weightPrev,\\twN = this._weightNext,\\r\\n\\r\\n\\t\\t\\t\\tp = ( t - t0 ) / ( t1 - t0 ),\\r\\n\\t\\t\\t\\tpp = p * p,\\r\\n\\t\\t\\t\\tppp = pp * p;\\r\\n\\r\\n\\t\\t\\t// evaluate polynomials\\r\\n\\r\\n\\t\\t\\tvar sP = - wP * ppp + 2 * wP * pp - wP * p;\\r\\n\\t\\t\\tvar s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;\\r\\n\\t\\t\\tvar s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;\\r\\n\\t\\t\\tvar sN = wN * ppp - wN * pp;\\r\\n\\r\\n\\t\\t\\t// combine data linearly\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tresult[ i ] =\\r\\n\\t\\t\\t\\t\\t\\tsP * values[ oP + i ] +\\r\\n\\t\\t\\t\\t\\t\\ts0 * values[ o0 + i ] +\\r\\n\\t\\t\\t\\t\\t\\ts1 * values[ o1 + i ] +\\r\\n\\t\\t\\t\\t\\t\\tsN * values[ oN + i ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn result;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author tschw\\r\\n\\t */\\r\\n\\r\\n\\tfunction LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\\r\\n\\r\\n\\t\\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: LinearInterpolant,\\r\\n\\r\\n\\t\\tinterpolate_: function ( i1, t0, t, t1 ) {\\r\\n\\r\\n\\t\\t\\tvar result = this.resultBuffer,\\r\\n\\t\\t\\t\\tvalues = this.sampleValues,\\r\\n\\t\\t\\t\\tstride = this.valueSize,\\r\\n\\r\\n\\t\\t\\t\\toffset1 = i1 * stride,\\r\\n\\t\\t\\t\\toffset0 = offset1 - stride,\\r\\n\\r\\n\\t\\t\\t\\tweight1 = ( t - t0 ) / ( t1 - t0 ),\\r\\n\\t\\t\\t\\tweight0 = 1 - weight1;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tresult[ i ] =\\r\\n\\t\\t\\t\\t\\t\\tvalues[ offset0 + i ] * weight0 +\\r\\n\\t\\t\\t\\t\\t\\tvalues[ offset1 + i ] * weight1;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn result;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t *\\r\\n\\t * Interpolant that evaluates to the sample value at the position preceeding\\r\\n\\t * the parameter.\\r\\n\\t *\\r\\n\\t * @author tschw\\r\\n\\t */\\r\\n\\r\\n\\tfunction DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\\r\\n\\r\\n\\t\\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tDiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: DiscreteInterpolant,\\r\\n\\r\\n\\t\\tinterpolate_: function ( i1 /*, t0, t, t1 */ ) {\\r\\n\\r\\n\\t\\t\\treturn this.copySampleValue_( i1 - 1 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author tschw\\r\\n\\t * @author Ben Houston / http://clara.io/\\r\\n\\t * @author David Sarno / http://lighthaus.us/\\r\\n\\t */\\r\\n\\r\\n\\tvar AnimationUtils = {\\r\\n\\r\\n\\t\\t// same as Array.prototype.slice, but also works on typed arrays\\r\\n\\t\\tarraySlice: function ( array, from, to ) {\\r\\n\\r\\n\\t\\t\\tif ( AnimationUtils.isTypedArray( array ) ) {\\r\\n\\r\\n\\t\\t\\t\\t// in ios9 array.subarray(from, undefined) will return empty array\\r\\n\\t\\t\\t\\t// but array.subarray(from) or array.subarray(from, len) is correct\\r\\n\\t\\t\\t\\treturn new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn array.slice( from, to );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// converts an array to a specific type\\r\\n\\t\\tconvertArray: function ( array, type, forceClone ) {\\r\\n\\r\\n\\t\\t\\tif ( ! array || // let 'undefined' and 'null' pass\\r\\n\\t\\t\\t\\t\\t! forceClone && array.constructor === type ) return array;\\r\\n\\r\\n\\t\\t\\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\\r\\n\\r\\n\\t\\t\\t\\treturn new type( array ); // create typed array\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn Array.prototype.slice.call( array ); // create Array\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tisTypedArray: function ( object ) {\\r\\n\\r\\n\\t\\t\\treturn ArrayBuffer.isView( object ) &&\\r\\n\\t\\t\\t\\t\\t! ( object instanceof DataView );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// returns an array by which times and values can be sorted\\r\\n\\t\\tgetKeyframeOrder: function ( times ) {\\r\\n\\r\\n\\t\\t\\tfunction compareTime( i, j ) {\\r\\n\\r\\n\\t\\t\\t\\treturn times[ i ] - times[ j ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar n = times.length;\\r\\n\\t\\t\\tvar result = new Array( n );\\r\\n\\t\\t\\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\\r\\n\\r\\n\\t\\t\\tresult.sort( compareTime );\\r\\n\\r\\n\\t\\t\\treturn result;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// uses the array previously returned by 'getKeyframeOrder' to sort data\\r\\n\\t\\tsortedArray: function ( values, stride, order ) {\\r\\n\\r\\n\\t\\t\\tvar nValues = values.length;\\r\\n\\t\\t\\tvar result = new values.constructor( nValues );\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tvar srcOffset = order[ i ] * stride;\\r\\n\\r\\n\\t\\t\\t\\tfor ( var j = 0; j !== stride; ++ j ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn result;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// function for parsing AOS keyframe formats\\r\\n\\t\\tflattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {\\r\\n\\r\\n\\t\\t\\tvar i = 1, key = jsonKeys[ 0 ];\\r\\n\\r\\n\\t\\t\\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tkey = jsonKeys[ i ++ ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( key === undefined ) return; // no data\\r\\n\\r\\n\\t\\t\\tvar value = key[ valuePropertyName ];\\r\\n\\t\\t\\tif ( value === undefined ) return; // no data\\r\\n\\r\\n\\t\\t\\tif ( Array.isArray( value ) ) {\\r\\n\\r\\n\\t\\t\\t\\tdo {\\r\\n\\r\\n\\t\\t\\t\\t\\tvalue = key[ valuePropertyName ];\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( value !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ttimes.push( key.time );\\r\\n\\t\\t\\t\\t\\t\\tvalues.push.apply( values, value ); // push all elements\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tkey = jsonKeys[ i ++ ];\\r\\n\\r\\n\\t\\t\\t\\t} while ( key !== undefined );\\r\\n\\r\\n\\t\\t\\t} else if ( value.toArray !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t// ...assume THREE.Math-ish\\r\\n\\r\\n\\t\\t\\t\\tdo {\\r\\n\\r\\n\\t\\t\\t\\t\\tvalue = key[ valuePropertyName ];\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( value !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ttimes.push( key.time );\\r\\n\\t\\t\\t\\t\\t\\tvalue.toArray( values, values.length );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tkey = jsonKeys[ i ++ ];\\r\\n\\r\\n\\t\\t\\t\\t} while ( key !== undefined );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t// otherwise push as-is\\r\\n\\r\\n\\t\\t\\t\\tdo {\\r\\n\\r\\n\\t\\t\\t\\t\\tvalue = key[ valuePropertyName ];\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( value !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ttimes.push( key.time );\\r\\n\\t\\t\\t\\t\\t\\tvalues.push( value );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tkey = jsonKeys[ i ++ ];\\r\\n\\r\\n\\t\\t\\t\\t} while ( key !== undefined );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t *\\r\\n\\t * A timed sequence of keyframes for a specific property.\\r\\n\\t *\\r\\n\\t *\\r\\n\\t * @author Ben Houston / http://clara.io/\\r\\n\\t * @author David Sarno / http://lighthaus.us/\\r\\n\\t * @author tschw\\r\\n\\t */\\r\\n\\r\\n\\tfunction KeyframeTrack( name, times, values, interpolation ) {\\r\\n\\r\\n\\t\\tif ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );\\r\\n\\t\\tif ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );\\r\\n\\r\\n\\t\\tthis.name = name;\\r\\n\\r\\n\\t\\tthis.times = AnimationUtils.convertArray( times, this.TimeBufferType );\\r\\n\\t\\tthis.values = AnimationUtils.convertArray( values, this.ValueBufferType );\\r\\n\\r\\n\\t\\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\\r\\n\\r\\n\\t\\tthis.validate();\\r\\n\\t\\tthis.optimize();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// Static methods:\\r\\n\\r\\n\\tObject.assign( KeyframeTrack, {\\r\\n\\r\\n\\t\\t// Serialization (in static context, because of constructor invocation\\r\\n\\t\\t// and automatic invocation of .toJSON):\\r\\n\\r\\n\\t\\tparse: function ( json ) {\\r\\n\\r\\n\\t\\t\\tif ( json.type === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tthrow new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );\\r\\n\\r\\n\\t\\t\\tif ( json.times === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tvar times = [], values = [];\\r\\n\\r\\n\\t\\t\\t\\tAnimationUtils.flattenJSON( json.keys, times, values, 'value' );\\r\\n\\r\\n\\t\\t\\t\\tjson.times = times;\\r\\n\\t\\t\\t\\tjson.values = values;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// derived classes can define a static parse method\\r\\n\\t\\t\\tif ( trackType.parse !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\treturn trackType.parse( json );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t// by default, we assume a constructor compatible with the base\\r\\n\\t\\t\\t\\treturn new trackType( json.name, json.times, json.values, json.interpolation );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttoJSON: function ( track ) {\\r\\n\\r\\n\\t\\t\\tvar trackType = track.constructor;\\r\\n\\r\\n\\t\\t\\tvar json;\\r\\n\\r\\n\\t\\t\\t// derived classes can define a static toJSON method\\r\\n\\t\\t\\tif ( trackType.toJSON !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tjson = trackType.toJSON( track );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t// by default, we assume the data can be serialized as-is\\r\\n\\t\\t\\t\\tjson = {\\r\\n\\r\\n\\t\\t\\t\\t\\t'name': track.name,\\r\\n\\t\\t\\t\\t\\t'times': AnimationUtils.convertArray( track.times, Array ),\\r\\n\\t\\t\\t\\t\\t'values': AnimationUtils.convertArray( track.values, Array )\\r\\n\\r\\n\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t\\tvar interpolation = track.getInterpolation();\\r\\n\\r\\n\\t\\t\\t\\tif ( interpolation !== track.DefaultInterpolation ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tjson.interpolation = interpolation;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tjson.type = track.ValueTypeName; // mandatory\\r\\n\\r\\n\\t\\t\\treturn json;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t_getTrackTypeForValueTypeName: function ( typeName ) {\\r\\n\\r\\n\\t\\t\\tswitch ( typeName.toLowerCase() ) {\\r\\n\\r\\n\\t\\t\\t\\tcase 'scalar':\\r\\n\\t\\t\\t\\tcase 'double':\\r\\n\\t\\t\\t\\tcase 'float':\\r\\n\\t\\t\\t\\tcase 'number':\\r\\n\\t\\t\\t\\tcase 'integer':\\r\\n\\r\\n\\t\\t\\t\\t\\treturn NumberKeyframeTrack;\\r\\n\\r\\n\\t\\t\\t\\tcase 'vector':\\r\\n\\t\\t\\t\\tcase 'vector2':\\r\\n\\t\\t\\t\\tcase 'vector3':\\r\\n\\t\\t\\t\\tcase 'vector4':\\r\\n\\r\\n\\t\\t\\t\\t\\treturn VectorKeyframeTrack;\\r\\n\\r\\n\\t\\t\\t\\tcase 'color':\\r\\n\\r\\n\\t\\t\\t\\t\\treturn ColorKeyframeTrack;\\r\\n\\r\\n\\t\\t\\t\\tcase 'quaternion':\\r\\n\\r\\n\\t\\t\\t\\t\\treturn QuaternionKeyframeTrack;\\r\\n\\r\\n\\t\\t\\t\\tcase 'bool':\\r\\n\\t\\t\\t\\tcase 'boolean':\\r\\n\\r\\n\\t\\t\\t\\t\\treturn BooleanKeyframeTrack;\\r\\n\\r\\n\\t\\t\\t\\tcase 'string':\\r\\n\\r\\n\\t\\t\\t\\t\\treturn StringKeyframeTrack;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthrow new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tObject.assign( KeyframeTrack.prototype, {\\r\\n\\r\\n\\t\\tconstructor: KeyframeTrack,\\r\\n\\r\\n\\t\\tTimeBufferType: Float32Array,\\r\\n\\r\\n\\t\\tValueBufferType: Float32Array,\\r\\n\\r\\n\\t\\tDefaultInterpolation: InterpolateLinear,\\r\\n\\r\\n\\t\\tInterpolantFactoryMethodDiscrete: function ( result ) {\\r\\n\\r\\n\\t\\t\\treturn new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tInterpolantFactoryMethodLinear: function ( result ) {\\r\\n\\r\\n\\t\\t\\treturn new LinearInterpolant( this.times, this.values, this.getValueSize(), result );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tInterpolantFactoryMethodSmooth: function ( result ) {\\r\\n\\r\\n\\t\\t\\treturn new CubicInterpolant( this.times, this.values, this.getValueSize(), result );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetInterpolation: function ( interpolation ) {\\r\\n\\r\\n\\t\\t\\tvar factoryMethod;\\r\\n\\r\\n\\t\\t\\tswitch ( interpolation ) {\\r\\n\\r\\n\\t\\t\\t\\tcase InterpolateDiscrete:\\r\\n\\r\\n\\t\\t\\t\\t\\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\\r\\n\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tcase InterpolateLinear:\\r\\n\\r\\n\\t\\t\\t\\t\\tfactoryMethod = this.InterpolantFactoryMethodLinear;\\r\\n\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tcase InterpolateSmooth:\\r\\n\\r\\n\\t\\t\\t\\t\\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\\r\\n\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( factoryMethod === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tvar message = \\\"unsupported interpolation for \\\" +\\r\\n\\t\\t\\t\\t\\tthis.ValueTypeName + \\\" keyframe track named \\\" + this.name;\\r\\n\\r\\n\\t\\t\\t\\tif ( this.createInterpolant === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// fall back to default, unless the default itself is messed up\\r\\n\\t\\t\\t\\t\\tif ( interpolation !== this.DefaultInterpolation ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tthis.setInterpolation( this.DefaultInterpolation );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tthrow new Error( message ); // fatal, in this case\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.KeyframeTrack:', message );\\r\\n\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.createInterpolant = factoryMethod;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetInterpolation: function () {\\r\\n\\r\\n\\t\\t\\tswitch ( this.createInterpolant ) {\\r\\n\\r\\n\\t\\t\\t\\tcase this.InterpolantFactoryMethodDiscrete:\\r\\n\\r\\n\\t\\t\\t\\t\\treturn InterpolateDiscrete;\\r\\n\\r\\n\\t\\t\\t\\tcase this.InterpolantFactoryMethodLinear:\\r\\n\\r\\n\\t\\t\\t\\t\\treturn InterpolateLinear;\\r\\n\\r\\n\\t\\t\\t\\tcase this.InterpolantFactoryMethodSmooth:\\r\\n\\r\\n\\t\\t\\t\\t\\treturn InterpolateSmooth;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetValueSize: function () {\\r\\n\\r\\n\\t\\t\\treturn this.values.length / this.times.length;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// move all keyframes either forwards or backwards in time\\r\\n\\t\\tshift: function ( timeOffset ) {\\r\\n\\r\\n\\t\\t\\tif ( timeOffset !== 0.0 ) {\\r\\n\\r\\n\\t\\t\\t\\tvar times = this.times;\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, n = times.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\t\\ttimes[ i ] += timeOffset;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\\r\\n\\t\\tscale: function ( timeScale ) {\\r\\n\\r\\n\\t\\t\\tif ( timeScale !== 1.0 ) {\\r\\n\\r\\n\\t\\t\\t\\tvar times = this.times;\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, n = times.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\t\\ttimes[ i ] *= timeScale;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\\r\\n\\t\\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\\r\\n\\t\\ttrim: function ( startTime, endTime ) {\\r\\n\\r\\n\\t\\t\\tvar times = this.times,\\r\\n\\t\\t\\t\\tnKeys = times.length,\\r\\n\\t\\t\\t\\tfrom = 0,\\r\\n\\t\\t\\t\\tto = nKeys - 1;\\r\\n\\r\\n\\t\\t\\twhile ( from !== nKeys && times[ from ] < startTime ) {\\r\\n\\r\\n\\t\\t\\t\\t++ from;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\twhile ( to !== - 1 && times[ to ] > endTime ) {\\r\\n\\r\\n\\t\\t\\t\\t-- to;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t++ to; // inclusive -> exclusive bound\\r\\n\\r\\n\\t\\t\\tif ( from !== 0 || to !== nKeys ) {\\r\\n\\r\\n\\t\\t\\t\\t// empty tracks are forbidden, so keep at least one keyframe\\r\\n\\t\\t\\t\\tif ( from >= to ) to = Math.max( to, 1 ), from = to - 1;\\r\\n\\r\\n\\t\\t\\t\\tvar stride = this.getValueSize();\\r\\n\\t\\t\\t\\tthis.times = AnimationUtils.arraySlice( times, from, to );\\r\\n\\t\\t\\t\\tthis.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\\r\\n\\t\\tvalidate: function () {\\r\\n\\r\\n\\t\\t\\tvar valid = true;\\r\\n\\r\\n\\t\\t\\tvar valueSize = this.getValueSize();\\r\\n\\t\\t\\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );\\r\\n\\t\\t\\t\\tvalid = false;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar times = this.times,\\r\\n\\t\\t\\t\\tvalues = this.values,\\r\\n\\r\\n\\t\\t\\t\\tnKeys = times.length;\\r\\n\\r\\n\\t\\t\\tif ( nKeys === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.KeyframeTrack: Track is empty.', this );\\r\\n\\t\\t\\t\\tvalid = false;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar prevTime = null;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i !== nKeys; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar currTime = times[ i ];\\r\\n\\r\\n\\t\\t\\t\\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );\\r\\n\\t\\t\\t\\t\\tvalid = false;\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( prevTime !== null && prevTime > currTime ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );\\r\\n\\t\\t\\t\\t\\tvalid = false;\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tprevTime = currTime;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( values !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( AnimationUtils.isTypedArray( values ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar value = values[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( isNaN( value ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );\\r\\n\\t\\t\\t\\t\\t\\t\\tvalid = false;\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn valid;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// removes equivalent sequential keys as common in morph target sequences\\r\\n\\t\\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --\x3e (0,0,1,1,0,0)\\r\\n\\t\\toptimize: function () {\\r\\n\\r\\n\\t\\t\\tvar times = this.times,\\r\\n\\t\\t\\t\\tvalues = this.values,\\r\\n\\t\\t\\t\\tstride = this.getValueSize(),\\r\\n\\r\\n\\t\\t\\t\\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\\r\\n\\r\\n\\t\\t\\t\\twriteIndex = 1,\\r\\n\\t\\t\\t\\tlastIndex = times.length - 1;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 1; i < lastIndex; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tvar keep = false;\\r\\n\\r\\n\\t\\t\\t\\tvar time = times[ i ];\\r\\n\\t\\t\\t\\tvar timeNext = times[ i + 1 ];\\r\\n\\r\\n\\t\\t\\t\\t// remove adjacent keyframes scheduled at the same time\\r\\n\\r\\n\\t\\t\\t\\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( ! smoothInterpolation ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// remove unnecessary keyframes same as their neighbors\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar offset = i * stride,\\r\\n\\t\\t\\t\\t\\t\\t\\toffsetP = offset - stride,\\r\\n\\t\\t\\t\\t\\t\\t\\toffsetN = offset + stride;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var j = 0; j !== stride; ++ j ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar value = values[ offset + j ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( value !== values[ offsetP + j ] ||\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tvalue !== values[ offsetN + j ] ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tkeep = true;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tkeep = true;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// in-place compaction\\r\\n\\r\\n\\t\\t\\t\\tif ( keep ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( i !== writeIndex ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ttimes[ writeIndex ] = times[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar readOffset = i * stride,\\r\\n\\t\\t\\t\\t\\t\\t\\twriteOffset = writeIndex * stride;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var j = 0; j !== stride; ++ j ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvalues[ writeOffset + j ] = values[ readOffset + j ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t++ writeIndex;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// flush last keyframe (compaction looks ahead)\\r\\n\\r\\n\\t\\t\\tif ( lastIndex > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\ttimes[ writeIndex ] = times[ lastIndex ];\\r\\n\\r\\n\\t\\t\\t\\tfor ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvalues[ writeOffset + j ] = values[ readOffset + j ];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t++ writeIndex;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( writeIndex !== times.length ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.times = AnimationUtils.arraySlice( times, 0, writeIndex );\\r\\n\\t\\t\\t\\tthis.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t *\\r\\n\\t * A Track of vectored keyframe values.\\r\\n\\t *\\r\\n\\t *\\r\\n\\t * @author Ben Houston / http://clara.io/\\r\\n\\t * @author David Sarno / http://lighthaus.us/\\r\\n\\t * @author tschw\\r\\n\\t */\\r\\n\\r\\n\\tfunction VectorKeyframeTrack( name, times, values, interpolation ) {\\r\\n\\r\\n\\t\\tKeyframeTrack.call( this, name, times, values, interpolation );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tVectorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: VectorKeyframeTrack,\\r\\n\\r\\n\\t\\tValueTypeName: 'vector'\\r\\n\\r\\n\\t\\t// ValueBufferType is inherited\\r\\n\\r\\n\\t\\t// DefaultInterpolation is inherited\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t *\\r\\n\\t * Reusable set of Tracks that represent an animation.\\r\\n\\t *\\r\\n\\t * @author Ben Houston / http://clara.io/\\r\\n\\t * @author David Sarno / http://lighthaus.us/\\r\\n\\t */\\r\\n\\r\\n\\tfunction AnimationClip( name, duration, tracks ) {\\r\\n\\r\\n\\t\\tthis.name = name;\\r\\n\\t\\tthis.tracks = tracks;\\r\\n\\t\\tthis.duration = ( duration !== undefined ) ? duration : - 1;\\r\\n\\r\\n\\t\\tthis.uuid = _Math.generateUUID();\\r\\n\\r\\n\\t\\t// this means it should figure out its duration by scanning the tracks\\r\\n\\t\\tif ( this.duration < 0 ) {\\r\\n\\r\\n\\t\\t\\tthis.resetDuration();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.optimize();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( AnimationClip, {\\r\\n\\r\\n\\t\\tparse: function ( json ) {\\r\\n\\r\\n\\t\\t\\tvar tracks = [],\\r\\n\\t\\t\\t\\tjsonTracks = json.tracks,\\r\\n\\t\\t\\t\\tframeTime = 1.0 / ( json.fps || 1.0 );\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\ttracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn new AnimationClip( json.name, json.duration, tracks );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttoJSON: function ( clip ) {\\r\\n\\r\\n\\t\\t\\tvar tracks = [],\\r\\n\\t\\t\\t\\tclipTracks = clip.tracks;\\r\\n\\r\\n\\t\\t\\tvar json = {\\r\\n\\r\\n\\t\\t\\t\\t'name': clip.name,\\r\\n\\t\\t\\t\\t'duration': clip.duration,\\r\\n\\t\\t\\t\\t'tracks': tracks\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn json;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tCreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {\\r\\n\\r\\n\\t\\t\\tvar numMorphTargets = morphTargetSequence.length;\\r\\n\\t\\t\\tvar tracks = [];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar times = [];\\r\\n\\t\\t\\t\\tvar values = [];\\r\\n\\r\\n\\t\\t\\t\\ttimes.push(\\r\\n\\t\\t\\t\\t\\t( i + numMorphTargets - 1 ) % numMorphTargets,\\r\\n\\t\\t\\t\\t\\ti,\\r\\n\\t\\t\\t\\t\\t( i + 1 ) % numMorphTargets );\\r\\n\\r\\n\\t\\t\\t\\tvalues.push( 0, 1, 0 );\\r\\n\\r\\n\\t\\t\\t\\tvar order = AnimationUtils.getKeyframeOrder( times );\\r\\n\\t\\t\\t\\ttimes = AnimationUtils.sortedArray( times, 1, order );\\r\\n\\t\\t\\t\\tvalues = AnimationUtils.sortedArray( values, 1, order );\\r\\n\\r\\n\\t\\t\\t\\t// if there is a key at the first frame, duplicate it as the\\r\\n\\t\\t\\t\\t// last frame as well for perfect loop.\\r\\n\\t\\t\\t\\tif ( ! noLoop && times[ 0 ] === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\ttimes.push( numMorphTargets );\\r\\n\\t\\t\\t\\t\\tvalues.push( values[ 0 ] );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\ttracks.push(\\r\\n\\t\\t\\t\\t\\tnew NumberKeyframeTrack(\\r\\n\\t\\t\\t\\t\\t\\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\\r\\n\\t\\t\\t\\t\\t\\ttimes, values\\r\\n\\t\\t\\t\\t\\t).scale( 1.0 / fps ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn new AnimationClip( name, - 1, tracks );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tfindByName: function ( objectOrClipArray, name ) {\\r\\n\\r\\n\\t\\t\\tvar clipArray = objectOrClipArray;\\r\\n\\r\\n\\t\\t\\tif ( ! Array.isArray( objectOrClipArray ) ) {\\r\\n\\r\\n\\t\\t\\t\\tvar o = objectOrClipArray;\\r\\n\\t\\t\\t\\tclipArray = o.geometry && o.geometry.animations || o.animations;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < clipArray.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( clipArray[ i ].name === name ) {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn clipArray[ i ];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tCreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {\\r\\n\\r\\n\\t\\t\\tvar animationToMorphTargets = {};\\r\\n\\r\\n\\t\\t\\t// tested with https://regex101.com/ on trick sequences\\r\\n\\t\\t\\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\\r\\n\\t\\t\\tvar pattern = /^([\\\\w-]*?)([\\\\d]+)$/;\\r\\n\\r\\n\\t\\t\\t// sort morph target names into animation groups based\\r\\n\\t\\t\\t// patterns like Walk_001, Walk_002, Run_001, Run_002\\r\\n\\t\\t\\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar morphTarget = morphTargets[ i ];\\r\\n\\t\\t\\t\\tvar parts = morphTarget.name.match( pattern );\\r\\n\\r\\n\\t\\t\\t\\tif ( parts && parts.length > 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar name = parts[ 1 ];\\r\\n\\r\\n\\t\\t\\t\\t\\tvar animationMorphTargets = animationToMorphTargets[ name ];\\r\\n\\t\\t\\t\\t\\tif ( ! animationMorphTargets ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tanimationMorphTargets.push( morphTarget );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar clips = [];\\r\\n\\r\\n\\t\\t\\tfor ( var name in animationToMorphTargets ) {\\r\\n\\r\\n\\t\\t\\t\\tclips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn clips;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// parse the animation.hierarchy format\\r\\n\\t\\tparseAnimation: function ( animation, bones ) {\\r\\n\\r\\n\\t\\t\\tif ( ! animation ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );\\r\\n\\t\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {\\r\\n\\r\\n\\t\\t\\t\\t// only return track if there are actually keys.\\r\\n\\t\\t\\t\\tif ( animationKeys.length !== 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar times = [];\\r\\n\\t\\t\\t\\t\\tvar values = [];\\r\\n\\r\\n\\t\\t\\t\\t\\tAnimationUtils.flattenJSON( animationKeys, times, values, propertyName );\\r\\n\\r\\n\\t\\t\\t\\t\\t// empty keys are filtered out, so check again\\r\\n\\t\\t\\t\\t\\tif ( times.length !== 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tdestTracks.push( new trackType( trackName, times, values ) );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\tvar tracks = [];\\r\\n\\r\\n\\t\\t\\tvar clipName = animation.name || 'default';\\r\\n\\t\\t\\t// automatic length determination in AnimationClip.\\r\\n\\t\\t\\tvar duration = animation.length || - 1;\\r\\n\\t\\t\\tvar fps = animation.fps || 30;\\r\\n\\r\\n\\t\\t\\tvar hierarchyTracks = animation.hierarchy || [];\\r\\n\\r\\n\\t\\t\\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar animationKeys = hierarchyTracks[ h ].keys;\\r\\n\\r\\n\\t\\t\\t\\t// skip empty tracks\\r\\n\\t\\t\\t\\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\\r\\n\\r\\n\\t\\t\\t\\t// process morph targets\\r\\n\\t\\t\\t\\tif ( animationKeys[ 0 ].morphTargets ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// figure out all morph targets used in this track\\r\\n\\t\\t\\t\\t\\tvar morphTargetNames = {};\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( animationKeys[ k ].morphTargets ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tfor ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tmorphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t// create a track for each morph target with all zero\\r\\n\\t\\t\\t\\t\\t// morphTargetInfluences except for the keys in which\\r\\n\\t\\t\\t\\t\\t// the morphTarget is named.\\r\\n\\t\\t\\t\\t\\tfor ( var morphTargetName in morphTargetNames ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar times = [];\\r\\n\\t\\t\\t\\t\\t\\tvar values = [];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar animationKey = animationKeys[ k ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\ttimes.push( animationKey.time );\\r\\n\\t\\t\\t\\t\\t\\t\\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ttracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tduration = morphTargetNames.length * ( fps || 1.0 );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t// ...assume skeletal animation\\r\\n\\r\\n\\t\\t\\t\\t\\tvar boneName = '.bones[' + bones[ h ].name + ']';\\r\\n\\r\\n\\t\\t\\t\\t\\taddNonemptyTrack(\\r\\n\\t\\t\\t\\t\\t\\tVectorKeyframeTrack, boneName + '.position',\\r\\n\\t\\t\\t\\t\\t\\tanimationKeys, 'pos', tracks );\\r\\n\\r\\n\\t\\t\\t\\t\\taddNonemptyTrack(\\r\\n\\t\\t\\t\\t\\t\\tQuaternionKeyframeTrack, boneName + '.quaternion',\\r\\n\\t\\t\\t\\t\\t\\tanimationKeys, 'rot', tracks );\\r\\n\\r\\n\\t\\t\\t\\t\\taddNonemptyTrack(\\r\\n\\t\\t\\t\\t\\t\\tVectorKeyframeTrack, boneName + '.scale',\\r\\n\\t\\t\\t\\t\\t\\tanimationKeys, 'scl', tracks );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( tracks.length === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar clip = new AnimationClip( clipName, duration, tracks );\\r\\n\\r\\n\\t\\t\\treturn clip;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tObject.assign( AnimationClip.prototype, {\\r\\n\\r\\n\\t\\tresetDuration: function () {\\r\\n\\r\\n\\t\\t\\tvar tracks = this.tracks, duration = 0;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tvar track = this.tracks[ i ];\\r\\n\\r\\n\\t\\t\\t\\tduration = Math.max( duration, track.times[ track.times.length - 1 ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.duration = duration;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttrim: function () {\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.tracks[ i ].trim( 0, this.duration );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\toptimize: function () {\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.tracks[ i ].optimize();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction MaterialLoader( manager ) {\\r\\n\\r\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\r\\n\\t\\tthis.textures = {};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( MaterialLoader.prototype, {\\r\\n\\r\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\r\\n\\r\\n\\t\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\t\\tvar loader = new FileLoader( scope.manager );\\r\\n\\t\\t\\tloader.load( url, function ( text ) {\\r\\n\\r\\n\\t\\t\\t\\tonLoad( scope.parse( JSON.parse( text ) ) );\\r\\n\\r\\n\\t\\t\\t}, onProgress, onError );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetTextures: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.textures = value;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tparse: function ( json ) {\\r\\n\\r\\n\\t\\t\\tvar textures = this.textures;\\r\\n\\r\\n\\t\\t\\tfunction getTexture( name ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( textures[ name ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn textures[ name ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar material = new Materials[ json.type ]();\\r\\n\\r\\n\\t\\t\\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\\r\\n\\t\\t\\tif ( json.name !== undefined ) material.name = json.name;\\r\\n\\t\\t\\tif ( json.color !== undefined ) material.color.setHex( json.color );\\r\\n\\t\\t\\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\\r\\n\\t\\t\\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\\r\\n\\t\\t\\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\\r\\n\\t\\t\\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\\r\\n\\t\\t\\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\\r\\n\\t\\t\\tif ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat;\\r\\n\\t\\t\\tif ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness;\\r\\n\\t\\t\\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\\r\\n\\t\\t\\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\\r\\n\\t\\t\\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\\r\\n\\t\\t\\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\\r\\n\\t\\t\\tif ( json.fog !== undefined ) material.fog = json.fog;\\r\\n\\t\\t\\tif ( json.flatShading !== undefined ) material.flatShading = json.flatShading;\\r\\n\\t\\t\\tif ( json.blending !== undefined ) material.blending = json.blending;\\r\\n\\t\\t\\tif ( json.side !== undefined ) material.side = json.side;\\r\\n\\t\\t\\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\\r\\n\\t\\t\\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\\r\\n\\t\\t\\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\\r\\n\\t\\t\\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\\r\\n\\t\\t\\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\\r\\n\\t\\t\\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\\r\\n\\t\\t\\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\\r\\n\\t\\t\\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\\r\\n\\t\\t\\tif ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;\\r\\n\\t\\t\\tif ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;\\r\\n\\r\\n\\t\\t\\tif ( json.rotation !== undefined ) material.rotation = json.rotation;\\r\\n\\r\\n\\t\\t\\tif ( json.linewidth !== 1 ) material.linewidth = json.linewidth;\\r\\n\\t\\t\\tif ( json.dashSize !== undefined ) material.dashSize = json.dashSize;\\r\\n\\t\\t\\tif ( json.gapSize !== undefined ) material.gapSize = json.gapSize;\\r\\n\\t\\t\\tif ( json.scale !== undefined ) material.scale = json.scale;\\r\\n\\r\\n\\t\\t\\tif ( json.skinning !== undefined ) material.skinning = json.skinning;\\r\\n\\t\\t\\tif ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;\\r\\n\\t\\t\\tif ( json.dithering !== undefined ) material.dithering = json.dithering;\\r\\n\\r\\n\\t\\t\\tif ( json.visible !== undefined ) material.visible = json.visible;\\r\\n\\t\\t\\tif ( json.userData !== undefined ) material.userData = json.userData;\\r\\n\\r\\n\\t\\t\\t// Deprecated\\r\\n\\r\\n\\t\\t\\tif ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading\\r\\n\\r\\n\\t\\t\\t// for PointsMaterial\\r\\n\\r\\n\\t\\t\\tif ( json.size !== undefined ) material.size = json.size;\\r\\n\\t\\t\\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\\r\\n\\r\\n\\t\\t\\t// maps\\r\\n\\r\\n\\t\\t\\tif ( json.map !== undefined ) material.map = getTexture( json.map );\\r\\n\\r\\n\\t\\t\\tif ( json.alphaMap !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tmaterial.alphaMap = getTexture( json.alphaMap );\\r\\n\\t\\t\\t\\tmaterial.transparent = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );\\r\\n\\t\\t\\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\\r\\n\\r\\n\\t\\t\\tif ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );\\r\\n\\t\\t\\tif ( json.normalScale !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tvar normalScale = json.normalScale;\\r\\n\\r\\n\\t\\t\\t\\tif ( Array.isArray( normalScale ) === false ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// Blender exporter used to export a scalar. See #7459\\r\\n\\r\\n\\t\\t\\t\\t\\tnormalScale = [ normalScale, normalScale ];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tmaterial.normalScale = new Vector2().fromArray( normalScale );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );\\r\\n\\t\\t\\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\\r\\n\\t\\t\\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\\r\\n\\r\\n\\t\\t\\tif ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );\\r\\n\\t\\t\\tif ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );\\r\\n\\r\\n\\t\\t\\tif ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );\\r\\n\\t\\t\\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\\r\\n\\r\\n\\t\\t\\tif ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );\\r\\n\\r\\n\\t\\t\\tif ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );\\r\\n\\r\\n\\t\\t\\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\\r\\n\\r\\n\\t\\t\\tif ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );\\r\\n\\t\\t\\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\\r\\n\\r\\n\\t\\t\\tif ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );\\r\\n\\t\\t\\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\\r\\n\\r\\n\\t\\t\\tif ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );\\r\\n\\r\\n\\t\\t\\treturn material;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction BufferGeometryLoader( manager ) {\\r\\n\\r\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( BufferGeometryLoader.prototype, {\\r\\n\\r\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\r\\n\\r\\n\\t\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\t\\tvar loader = new FileLoader( scope.manager );\\r\\n\\t\\t\\tloader.load( url, function ( text ) {\\r\\n\\r\\n\\t\\t\\t\\tonLoad( scope.parse( JSON.parse( text ) ) );\\r\\n\\r\\n\\t\\t\\t}, onProgress, onError );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tparse: function ( json ) {\\r\\n\\r\\n\\t\\t\\tvar geometry = new BufferGeometry();\\r\\n\\r\\n\\t\\t\\tvar index = json.data.index;\\r\\n\\r\\n\\t\\t\\tif ( index !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\\r\\n\\t\\t\\t\\tgeometry.setIndex( new BufferAttribute( typedArray, 1 ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar attributes = json.data.attributes;\\r\\n\\r\\n\\t\\t\\tfor ( var key in attributes ) {\\r\\n\\r\\n\\t\\t\\t\\tvar attribute = attributes[ key ];\\r\\n\\t\\t\\t\\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\\r\\n\\r\\n\\t\\t\\t\\tgeometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\\r\\n\\r\\n\\t\\t\\tif ( groups !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar group = groups[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\tgeometry.addGroup( group.start, group.count, group.materialIndex );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar boundingSphere = json.data.boundingSphere;\\r\\n\\r\\n\\t\\t\\tif ( boundingSphere !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tvar center = new Vector3();\\r\\n\\r\\n\\t\\t\\t\\tif ( boundingSphere.center !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcenter.fromArray( boundingSphere.center );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tgeometry.boundingSphere = new Sphere( center, boundingSphere.radius );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn geometry;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tvar TYPED_ARRAYS = {\\r\\n\\t\\tInt8Array: Int8Array,\\r\\n\\t\\tUint8Array: Uint8Array,\\r\\n\\t\\t// Workaround for IE11 pre KB2929437. See #11440\\r\\n\\t\\tUint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,\\r\\n\\t\\tInt16Array: Int16Array,\\r\\n\\t\\tUint16Array: Uint16Array,\\r\\n\\t\\tInt32Array: Int32Array,\\r\\n\\t\\tUint32Array: Uint32Array,\\r\\n\\t\\tFloat32Array: Float32Array,\\r\\n\\t\\tFloat64Array: Float64Array\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction Loader() {\\r\\n\\r\\n\\t\\tthis.onLoadStart = function () {};\\r\\n\\t\\tthis.onLoadProgress = function () {};\\r\\n\\t\\tthis.onLoadComplete = function () {};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tLoader.Handlers = {\\r\\n\\r\\n\\t\\thandlers: [],\\r\\n\\r\\n\\t\\tadd: function ( regex, loader ) {\\r\\n\\r\\n\\t\\t\\tthis.handlers.push( regex, loader );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tget: function ( file ) {\\r\\n\\r\\n\\t\\t\\tvar handlers = this.handlers;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\\r\\n\\r\\n\\t\\t\\t\\tvar regex = handlers[ i ];\\r\\n\\t\\t\\t\\tvar loader = handlers[ i + 1 ];\\r\\n\\r\\n\\t\\t\\t\\tif ( regex.test( file ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn loader;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tObject.assign( Loader.prototype, {\\r\\n\\r\\n\\t\\tcrossOrigin: undefined,\\r\\n\\r\\n\\t\\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\\r\\n\\r\\n\\t\\t\\tvar array = [];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < materials.length; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tarray[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn array;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcreateMaterial: ( function () {\\r\\n\\r\\n\\t\\t\\tvar BlendingMode = {\\r\\n\\t\\t\\t\\tNoBlending: NoBlending,\\r\\n\\t\\t\\t\\tNormalBlending: NormalBlending,\\r\\n\\t\\t\\t\\tAdditiveBlending: AdditiveBlending,\\r\\n\\t\\t\\t\\tSubtractiveBlending: SubtractiveBlending,\\r\\n\\t\\t\\t\\tMultiplyBlending: MultiplyBlending,\\r\\n\\t\\t\\t\\tCustomBlending: CustomBlending\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\tvar color = new Color();\\r\\n\\t\\t\\tvar textureLoader = new TextureLoader();\\r\\n\\t\\t\\tvar materialLoader = new MaterialLoader();\\r\\n\\r\\n\\t\\t\\treturn function createMaterial( m, texturePath, crossOrigin ) {\\r\\n\\r\\n\\t\\t\\t\\t// convert from old material format\\r\\n\\r\\n\\t\\t\\t\\tvar textures = {};\\r\\n\\r\\n\\t\\t\\t\\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar fullPath = texturePath + path;\\r\\n\\t\\t\\t\\t\\tvar loader = Loader.Handlers.get( fullPath );\\r\\n\\r\\n\\t\\t\\t\\t\\tvar texture;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( loader !== null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ttexture = loader.load( fullPath );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ttextureLoader.setCrossOrigin( crossOrigin );\\r\\n\\t\\t\\t\\t\\t\\ttexture = textureLoader.load( fullPath );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( repeat !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ttexture.repeat.fromArray( repeat );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;\\r\\n\\t\\t\\t\\t\\t\\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( offset !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ttexture.offset.fromArray( offset );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( wrap !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;\\r\\n\\t\\t\\t\\t\\t\\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;\\r\\n\\t\\t\\t\\t\\t\\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( anisotropy !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ttexture.anisotropy = anisotropy;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tvar uuid = _Math.generateUUID();\\r\\n\\r\\n\\t\\t\\t\\t\\ttextures[ uuid ] = texture;\\r\\n\\r\\n\\t\\t\\t\\t\\treturn uuid;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\t\\tvar json = {\\r\\n\\t\\t\\t\\t\\tuuid: _Math.generateUUID(),\\r\\n\\t\\t\\t\\t\\ttype: 'MeshLambertMaterial'\\r\\n\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t\\tfor ( var name in m ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar value = m[ name ];\\r\\n\\r\\n\\t\\t\\t\\t\\tswitch ( name ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase 'DbgColor':\\r\\n\\t\\t\\t\\t\\t\\tcase 'DbgIndex':\\r\\n\\t\\t\\t\\t\\t\\tcase 'opticalDensity':\\r\\n\\t\\t\\t\\t\\t\\tcase 'illumination':\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'DbgName':\\r\\n\\t\\t\\t\\t\\t\\t\\tjson.name = value;\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'blending':\\r\\n\\t\\t\\t\\t\\t\\t\\tjson.blending = BlendingMode[ value ];\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'colorAmbient':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapAmbient':\\r\\n\\t\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'colorDiffuse':\\r\\n\\t\\t\\t\\t\\t\\t\\tjson.color = color.fromArray( value ).getHex();\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'colorSpecular':\\r\\n\\t\\t\\t\\t\\t\\t\\tjson.specular = color.fromArray( value ).getHex();\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'colorEmissive':\\r\\n\\t\\t\\t\\t\\t\\t\\tjson.emissive = color.fromArray( value ).getHex();\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'specularCoef':\\r\\n\\t\\t\\t\\t\\t\\t\\tjson.shininess = value;\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'shading':\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapDiffuse':\\r\\n\\t\\t\\t\\t\\t\\t\\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapDiffuseRepeat':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapDiffuseOffset':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapDiffuseWrap':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapDiffuseAnisotropy':\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapEmissive':\\r\\n\\t\\t\\t\\t\\t\\t\\tjson.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapEmissiveRepeat':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapEmissiveOffset':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapEmissiveWrap':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapEmissiveAnisotropy':\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapLight':\\r\\n\\t\\t\\t\\t\\t\\t\\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapLightRepeat':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapLightOffset':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapLightWrap':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapLightAnisotropy':\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapAO':\\r\\n\\t\\t\\t\\t\\t\\t\\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapAORepeat':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapAOOffset':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapAOWrap':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapAOAnisotropy':\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapBump':\\r\\n\\t\\t\\t\\t\\t\\t\\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapBumpScale':\\r\\n\\t\\t\\t\\t\\t\\t\\tjson.bumpScale = value;\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapBumpRepeat':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapBumpOffset':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapBumpWrap':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapBumpAnisotropy':\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapNormal':\\r\\n\\t\\t\\t\\t\\t\\t\\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapNormalFactor':\\r\\n\\t\\t\\t\\t\\t\\t\\tjson.normalScale = [ value, value ];\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapNormalRepeat':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapNormalOffset':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapNormalWrap':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapNormalAnisotropy':\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapSpecular':\\r\\n\\t\\t\\t\\t\\t\\t\\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapSpecularRepeat':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapSpecularOffset':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapSpecularWrap':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapSpecularAnisotropy':\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapMetalness':\\r\\n\\t\\t\\t\\t\\t\\t\\tjson.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapMetalnessRepeat':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapMetalnessOffset':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapMetalnessWrap':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapMetalnessAnisotropy':\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapRoughness':\\r\\n\\t\\t\\t\\t\\t\\t\\tjson.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapRoughnessRepeat':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapRoughnessOffset':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapRoughnessWrap':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapRoughnessAnisotropy':\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapAlpha':\\r\\n\\t\\t\\t\\t\\t\\t\\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapAlphaRepeat':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapAlphaOffset':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapAlphaWrap':\\r\\n\\t\\t\\t\\t\\t\\tcase 'mapAlphaAnisotropy':\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'flipSided':\\r\\n\\t\\t\\t\\t\\t\\t\\tjson.side = BackSide;\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'doubleSided':\\r\\n\\t\\t\\t\\t\\t\\t\\tjson.side = DoubleSide;\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'transparency':\\r\\n\\t\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\\r\\n\\t\\t\\t\\t\\t\\t\\tjson.opacity = value;\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'depthTest':\\r\\n\\t\\t\\t\\t\\t\\tcase 'depthWrite':\\r\\n\\t\\t\\t\\t\\t\\tcase 'colorWrite':\\r\\n\\t\\t\\t\\t\\t\\tcase 'opacity':\\r\\n\\t\\t\\t\\t\\t\\tcase 'reflectivity':\\r\\n\\t\\t\\t\\t\\t\\tcase 'transparent':\\r\\n\\t\\t\\t\\t\\t\\tcase 'visible':\\r\\n\\t\\t\\t\\t\\t\\tcase 'wireframe':\\r\\n\\t\\t\\t\\t\\t\\t\\tjson[ name ] = value;\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tcase 'vertexColors':\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( value === true ) json.vertexColors = VertexColors;\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( value === 'face' ) json.vertexColors = FaceColors;\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\tdefault:\\r\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\\r\\n\\t\\t\\t\\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\\r\\n\\r\\n\\t\\t\\t\\tif ( json.opacity < 1 ) json.transparent = true;\\r\\n\\r\\n\\t\\t\\t\\tmaterialLoader.setTextures( textures );\\r\\n\\r\\n\\t\\t\\t\\treturn materialLoader.parse( json );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t} )()\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author Don McCurdy / https://www.donmccurdy.com\\r\\n\\t */\\r\\n\\r\\n\\tvar LoaderUtils = {\\r\\n\\r\\n\\t\\tdecodeText: function ( array ) {\\r\\n\\r\\n\\t\\t\\tif ( typeof TextDecoder !== 'undefined' ) {\\r\\n\\r\\n\\t\\t\\t\\treturn new TextDecoder().decode( array );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// Avoid the String.fromCharCode.apply(null, array) shortcut, which\\r\\n\\t\\t\\t// throws a \\\"maximum call stack size exceeded\\\" error for large arrays.\\r\\n\\r\\n\\t\\t\\tvar s = '';\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t// Implicitly assumes little-endian.\\r\\n\\t\\t\\t\\ts += String.fromCharCode( array[ i ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn s;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\textractUrlBase: function ( url ) {\\r\\n\\r\\n\\t\\t\\tvar parts = url.split( '/' );\\r\\n\\r\\n\\t\\t\\tif ( parts.length === 1 ) return './';\\r\\n\\r\\n\\t\\t\\tparts.pop();\\r\\n\\r\\n\\t\\t\\treturn parts.join( '/' ) + '/';\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction JSONLoader( manager ) {\\r\\n\\r\\n\\t\\tif ( typeof manager === 'boolean' ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\\r\\n\\t\\t\\tmanager = undefined;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\r\\n\\r\\n\\t\\tthis.withCredentials = false;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( JSONLoader.prototype, {\\r\\n\\r\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\r\\n\\r\\n\\t\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\t\\tvar texturePath = this.texturePath && ( typeof this.texturePath === 'string' ) ? this.texturePath : LoaderUtils.extractUrlBase( url );\\r\\n\\r\\n\\t\\t\\tvar loader = new FileLoader( this.manager );\\r\\n\\t\\t\\tloader.setWithCredentials( this.withCredentials );\\r\\n\\t\\t\\tloader.load( url, function ( text ) {\\r\\n\\r\\n\\t\\t\\t\\tvar json = JSON.parse( text );\\r\\n\\t\\t\\t\\tvar metadata = json.metadata;\\r\\n\\r\\n\\t\\t\\t\\tif ( metadata !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar type = metadata.type;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( type !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( type.toLowerCase() === 'object' ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\\r\\n\\t\\t\\t\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( type.toLowerCase() === 'scene' ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\\r\\n\\t\\t\\t\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tvar object = scope.parse( json, texturePath );\\r\\n\\t\\t\\t\\tonLoad( object.geometry, object.materials );\\r\\n\\r\\n\\t\\t\\t}, onProgress, onError );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetTexturePath: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.texturePath = value;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tparse: ( function () {\\r\\n\\r\\n\\t\\t\\tfunction parseModel( json, geometry ) {\\r\\n\\r\\n\\t\\t\\t\\tfunction isBitSet( value, position ) {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn value & ( 1 << position );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tvar i, j, fi,\\r\\n\\r\\n\\t\\t\\t\\t\\toffset, zLength,\\r\\n\\r\\n\\t\\t\\t\\t\\tcolorIndex, normalIndex, uvIndex, materialIndex,\\r\\n\\r\\n\\t\\t\\t\\t\\ttype,\\r\\n\\t\\t\\t\\t\\tisQuad,\\r\\n\\t\\t\\t\\t\\thasMaterial,\\r\\n\\t\\t\\t\\t\\thasFaceVertexUv,\\r\\n\\t\\t\\t\\t\\thasFaceNormal, hasFaceVertexNormal,\\r\\n\\t\\t\\t\\t\\thasFaceColor, hasFaceVertexColor,\\r\\n\\r\\n\\t\\t\\t\\t\\tvertex, face, faceA, faceB, hex, normal,\\r\\n\\r\\n\\t\\t\\t\\t\\tuvLayer, uv, u, v,\\r\\n\\r\\n\\t\\t\\t\\t\\tfaces = json.faces,\\r\\n\\t\\t\\t\\t\\tvertices = json.vertices,\\r\\n\\t\\t\\t\\t\\tnormals = json.normals,\\r\\n\\t\\t\\t\\t\\tcolors = json.colors,\\r\\n\\r\\n\\t\\t\\t\\t\\tscale = json.scale,\\r\\n\\r\\n\\t\\t\\t\\t\\tnUvLayers = 0;\\r\\n\\r\\n\\r\\n\\t\\t\\t\\tif ( json.uvs !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// disregard empty arrays\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( i = 0; i < json.uvs.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( json.uvs[ i ].length ) nUvLayers ++;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( i = 0; i < nUvLayers; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgeometry.faceVertexUvs[ i ] = [];\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\toffset = 0;\\r\\n\\t\\t\\t\\tzLength = vertices.length;\\r\\n\\r\\n\\t\\t\\t\\twhile ( offset < zLength ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvertex = new Vector3();\\r\\n\\r\\n\\t\\t\\t\\t\\tvertex.x = vertices[ offset ++ ] * scale;\\r\\n\\t\\t\\t\\t\\tvertex.y = vertices[ offset ++ ] * scale;\\r\\n\\t\\t\\t\\t\\tvertex.z = vertices[ offset ++ ] * scale;\\r\\n\\r\\n\\t\\t\\t\\t\\tgeometry.vertices.push( vertex );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\toffset = 0;\\r\\n\\t\\t\\t\\tzLength = faces.length;\\r\\n\\r\\n\\t\\t\\t\\twhile ( offset < zLength ) {\\r\\n\\r\\n\\t\\t\\t\\t\\ttype = faces[ offset ++ ];\\r\\n\\r\\n\\t\\t\\t\\t\\tisQuad = isBitSet( type, 0 );\\r\\n\\t\\t\\t\\t\\thasMaterial = isBitSet( type, 1 );\\r\\n\\t\\t\\t\\t\\thasFaceVertexUv = isBitSet( type, 3 );\\r\\n\\t\\t\\t\\t\\thasFaceNormal = isBitSet( type, 4 );\\r\\n\\t\\t\\t\\t\\thasFaceVertexNormal = isBitSet( type, 5 );\\r\\n\\t\\t\\t\\t\\thasFaceColor = isBitSet( type, 6 );\\r\\n\\t\\t\\t\\t\\thasFaceVertexColor = isBitSet( type, 7 );\\r\\n\\r\\n\\t\\t\\t\\t\\t// console.log(\\\"type\\\", type, \\\"bits\\\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( isQuad ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfaceA = new Face3();\\r\\n\\t\\t\\t\\t\\t\\tfaceA.a = faces[ offset ];\\r\\n\\t\\t\\t\\t\\t\\tfaceA.b = faces[ offset + 1 ];\\r\\n\\t\\t\\t\\t\\t\\tfaceA.c = faces[ offset + 3 ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfaceB = new Face3();\\r\\n\\t\\t\\t\\t\\t\\tfaceB.a = faces[ offset + 1 ];\\r\\n\\t\\t\\t\\t\\t\\tfaceB.b = faces[ offset + 2 ];\\r\\n\\t\\t\\t\\t\\t\\tfaceB.c = faces[ offset + 3 ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\toffset += 4;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( hasMaterial ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tmaterialIndex = faces[ offset ++ ];\\r\\n\\t\\t\\t\\t\\t\\t\\tfaceA.materialIndex = materialIndex;\\r\\n\\t\\t\\t\\t\\t\\t\\tfaceB.materialIndex = materialIndex;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// to get face <=> uv index correspondence\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfi = geometry.faces.length;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( hasFaceVertexUv ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tfor ( i = 0; i < nUvLayers; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tuvLayer = json.uvs[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgeometry.faceVertexUvs[ i ][ fi ] = [];\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tfor ( j = 0; j < 4; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tuvIndex = faces[ offset ++ ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tu = uvLayer[ uvIndex * 2 ];\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tv = uvLayer[ uvIndex * 2 + 1 ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tuv = new Vector2( u, v );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( hasFaceNormal ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tnormalIndex = faces[ offset ++ ] * 3;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tfaceA.normal.set(\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ]\\r\\n\\t\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tfaceB.normal.copy( faceA.normal );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( hasFaceVertexNormal ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tfor ( i = 0; i < 4; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tnormalIndex = faces[ offset ++ ] * 3;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tnormal = new Vector3(\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ]\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( hasFaceColor ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tcolorIndex = faces[ offset ++ ];\\r\\n\\t\\t\\t\\t\\t\\t\\thex = colors[ colorIndex ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tfaceA.color.setHex( hex );\\r\\n\\t\\t\\t\\t\\t\\t\\tfaceB.color.setHex( hex );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( hasFaceVertexColor ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tfor ( i = 0; i < 4; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tcolorIndex = faces[ offset ++ ];\\r\\n\\t\\t\\t\\t\\t\\t\\t\\thex = colors[ colorIndex ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgeometry.faces.push( faceA );\\r\\n\\t\\t\\t\\t\\t\\tgeometry.faces.push( faceB );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tface = new Face3();\\r\\n\\t\\t\\t\\t\\t\\tface.a = faces[ offset ++ ];\\r\\n\\t\\t\\t\\t\\t\\tface.b = faces[ offset ++ ];\\r\\n\\t\\t\\t\\t\\t\\tface.c = faces[ offset ++ ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( hasMaterial ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tmaterialIndex = faces[ offset ++ ];\\r\\n\\t\\t\\t\\t\\t\\t\\tface.materialIndex = materialIndex;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// to get face <=> uv index correspondence\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfi = geometry.faces.length;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( hasFaceVertexUv ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tfor ( i = 0; i < nUvLayers; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tuvLayer = json.uvs[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgeometry.faceVertexUvs[ i ][ fi ] = [];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tfor ( j = 0; j < 3; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tuvIndex = faces[ offset ++ ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tu = uvLayer[ uvIndex * 2 ];\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tv = uvLayer[ uvIndex * 2 + 1 ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tuv = new Vector2( u, v );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( hasFaceNormal ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tnormalIndex = faces[ offset ++ ] * 3;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tface.normal.set(\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ]\\r\\n\\t\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( hasFaceVertexNormal ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tfor ( i = 0; i < 3; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tnormalIndex = faces[ offset ++ ] * 3;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tnormal = new Vector3(\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ]\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tface.vertexNormals.push( normal );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( hasFaceColor ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tcolorIndex = faces[ offset ++ ];\\r\\n\\t\\t\\t\\t\\t\\t\\tface.color.setHex( colors[ colorIndex ] );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( hasFaceVertexColor ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tfor ( i = 0; i < 3; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tcolorIndex = faces[ offset ++ ];\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tface.vertexColors.push( new Color( colors[ colorIndex ] ) );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgeometry.faces.push( face );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfunction parseSkin( json, geometry ) {\\r\\n\\r\\n\\t\\t\\t\\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\\r\\n\\r\\n\\t\\t\\t\\tif ( json.skinWeights ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar x = json.skinWeights[ i ];\\r\\n\\t\\t\\t\\t\\t\\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\\r\\n\\t\\t\\t\\t\\t\\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\\r\\n\\t\\t\\t\\t\\t\\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgeometry.skinWeights.push( new Vector4( x, y, z, w ) );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( json.skinIndices ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar a = json.skinIndices[ i ];\\r\\n\\t\\t\\t\\t\\t\\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\\r\\n\\t\\t\\t\\t\\t\\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\\r\\n\\t\\t\\t\\t\\t\\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgeometry.skinIndices.push( new Vector4( a, b, c, d ) );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tgeometry.bones = json.bones;\\r\\n\\r\\n\\t\\t\\t\\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\\r\\n\\t\\t\\t\\t\\t\\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfunction parseMorphing( json, geometry ) {\\r\\n\\r\\n\\t\\t\\t\\tvar scale = json.scale;\\r\\n\\r\\n\\t\\t\\t\\tif ( json.morphTargets !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgeometry.morphTargets[ i ] = {};\\r\\n\\t\\t\\t\\t\\t\\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\\r\\n\\t\\t\\t\\t\\t\\tgeometry.morphTargets[ i ].vertices = [];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar dstVertices = geometry.morphTargets[ i ].vertices;\\r\\n\\t\\t\\t\\t\\t\\tvar srcVertices = json.morphTargets[ i ].vertices;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar vertex = new Vector3();\\r\\n\\t\\t\\t\\t\\t\\t\\tvertex.x = srcVertices[ v ] * scale;\\r\\n\\t\\t\\t\\t\\t\\t\\tvertex.y = srcVertices[ v + 1 ] * scale;\\r\\n\\t\\t\\t\\t\\t\\t\\tvertex.z = srcVertices[ v + 2 ] * scale;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tdstVertices.push( vertex );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.JSONLoader: \\\"morphColors\\\" no longer supported. Using them as face colors.' );\\r\\n\\r\\n\\t\\t\\t\\t\\tvar faces = geometry.faces;\\r\\n\\t\\t\\t\\t\\tvar morphColors = json.morphColors[ 0 ].colors;\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfaces[ i ].color.fromArray( morphColors, i * 3 );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfunction parseAnimations( json, geometry ) {\\r\\n\\r\\n\\t\\t\\t\\tvar outputAnimations = [];\\r\\n\\r\\n\\t\\t\\t\\t// parse old style Bone/Hierarchy animations\\r\\n\\t\\t\\t\\tvar animations = [];\\r\\n\\r\\n\\t\\t\\t\\tif ( json.animation !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tanimations.push( json.animation );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( json.animations !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( json.animations.length ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tanimations = animations.concat( json.animations );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tanimations.push( json.animations );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0; i < animations.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );\\r\\n\\t\\t\\t\\t\\tif ( clip ) outputAnimations.push( clip );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// parse implicit morph animations\\r\\n\\t\\t\\t\\tif ( geometry.morphTargets ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\\r\\n\\t\\t\\t\\t\\tvar morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\\r\\n\\t\\t\\t\\t\\toutputAnimations = outputAnimations.concat( morphAnimationClips );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn function ( json, texturePath ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( json.data !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// Geometry 4.0 spec\\r\\n\\t\\t\\t\\t\\tjson = json.data;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( json.scale !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tjson.scale = 1.0 / json.scale;\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tjson.scale = 1.0;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tvar geometry = new Geometry();\\r\\n\\r\\n\\t\\t\\t\\tparseModel( json, geometry );\\r\\n\\t\\t\\t\\tparseSkin( json, geometry );\\r\\n\\t\\t\\t\\tparseMorphing( json, geometry );\\r\\n\\t\\t\\t\\tparseAnimations( json, geometry );\\r\\n\\r\\n\\t\\t\\t\\tgeometry.computeFaceNormals();\\r\\n\\t\\t\\t\\tgeometry.computeBoundingSphere();\\r\\n\\r\\n\\t\\t\\t\\tif ( json.materials === undefined || json.materials.length === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn { geometry: geometry };\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\\r\\n\\r\\n\\t\\t\\t\\t\\treturn { geometry: geometry, materials: materials };\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t} )()\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction ObjectLoader( manager ) {\\r\\n\\r\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\r\\n\\t\\tthis.texturePath = '';\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( ObjectLoader.prototype, {\\r\\n\\r\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\r\\n\\r\\n\\t\\t\\tif ( this.texturePath === '' ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\t\\tvar loader = new FileLoader( scope.manager );\\r\\n\\t\\t\\tloader.load( url, function ( text ) {\\r\\n\\r\\n\\t\\t\\t\\tvar json = null;\\r\\n\\r\\n\\t\\t\\t\\ttry {\\r\\n\\r\\n\\t\\t\\t\\t\\tjson = JSON.parse( text );\\r\\n\\r\\n\\t\\t\\t\\t} catch ( error ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( onError !== undefined ) onError( error );\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.error( 'THREE:ObjectLoader: Can\\\\'t parse ' + url + '.', error.message );\\r\\n\\r\\n\\t\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tvar metadata = json.metadata;\\r\\n\\r\\n\\t\\t\\t\\tif ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.ObjectLoader: Can\\\\'t load ' + url + '. Use THREE.JSONLoader instead.' );\\r\\n\\t\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tscope.parse( json, onLoad );\\r\\n\\r\\n\\t\\t\\t}, onProgress, onError );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetTexturePath: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.texturePath = value;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetCrossOrigin: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.crossOrigin = value;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tparse: function ( json, onLoad ) {\\r\\n\\r\\n\\t\\t\\tvar shapes = this.parseShape( json.shapes );\\r\\n\\t\\t\\tvar geometries = this.parseGeometries( json.geometries, shapes );\\r\\n\\r\\n\\t\\t\\tvar images = this.parseImages( json.images, function () {\\r\\n\\r\\n\\t\\t\\t\\tif ( onLoad !== undefined ) onLoad( object );\\r\\n\\r\\n\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\tvar textures = this.parseTextures( json.textures, images );\\r\\n\\t\\t\\tvar materials = this.parseMaterials( json.materials, textures );\\r\\n\\r\\n\\t\\t\\tvar object = this.parseObject( json.object, geometries, materials );\\r\\n\\r\\n\\t\\t\\tif ( json.animations ) {\\r\\n\\r\\n\\t\\t\\t\\tobject.animations = this.parseAnimations( json.animations );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( json.images === undefined || json.images.length === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( onLoad !== undefined ) onLoad( object );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn object;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tparseShape: function ( json ) {\\r\\n\\r\\n\\t\\t\\tvar shapes = {};\\r\\n\\r\\n\\t\\t\\tif ( json !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar shape = new Shape().fromJSON( json[ i ] );\\r\\n\\r\\n\\t\\t\\t\\t\\tshapes[ shape.uuid ] = shape;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn shapes;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tparseGeometries: function ( json, shapes ) {\\r\\n\\r\\n\\t\\t\\tvar geometries = {};\\r\\n\\r\\n\\t\\t\\tif ( json !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tvar geometryLoader = new JSONLoader();\\r\\n\\t\\t\\t\\tvar bufferGeometryLoader = new BufferGeometryLoader();\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar geometry;\\r\\n\\t\\t\\t\\t\\tvar data = json[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\tswitch ( data.type ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase 'PlaneGeometry':\\r\\n\\t\\t\\t\\t\\t\\tcase 'PlaneBufferGeometry':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.width,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.height,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.widthSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.heightSegments\\r\\n\\t\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase 'BoxGeometry':\\r\\n\\t\\t\\t\\t\\t\\tcase 'BoxBufferGeometry':\\r\\n\\t\\t\\t\\t\\t\\tcase 'CubeGeometry': // backwards compatible\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.width,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.height,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.depth,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.widthSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.heightSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.depthSegments\\r\\n\\t\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase 'CircleGeometry':\\r\\n\\t\\t\\t\\t\\t\\tcase 'CircleBufferGeometry':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radius,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.segments,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaStart,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaLength\\r\\n\\t\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase 'CylinderGeometry':\\r\\n\\t\\t\\t\\t\\t\\tcase 'CylinderBufferGeometry':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radiusTop,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radiusBottom,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.height,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radialSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.heightSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.openEnded,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaStart,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaLength\\r\\n\\t\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase 'ConeGeometry':\\r\\n\\t\\t\\t\\t\\t\\tcase 'ConeBufferGeometry':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radius,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.height,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radialSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.heightSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.openEnded,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaStart,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaLength\\r\\n\\t\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase 'SphereGeometry':\\r\\n\\t\\t\\t\\t\\t\\tcase 'SphereBufferGeometry':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radius,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.widthSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.heightSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.phiStart,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.phiLength,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaStart,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaLength\\r\\n\\t\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase 'DodecahedronGeometry':\\r\\n\\t\\t\\t\\t\\t\\tcase 'DodecahedronBufferGeometry':\\r\\n\\t\\t\\t\\t\\t\\tcase 'IcosahedronGeometry':\\r\\n\\t\\t\\t\\t\\t\\tcase 'IcosahedronBufferGeometry':\\r\\n\\t\\t\\t\\t\\t\\tcase 'OctahedronGeometry':\\r\\n\\t\\t\\t\\t\\t\\tcase 'OctahedronBufferGeometry':\\r\\n\\t\\t\\t\\t\\t\\tcase 'TetrahedronGeometry':\\r\\n\\t\\t\\t\\t\\t\\tcase 'TetrahedronBufferGeometry':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radius,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.detail\\r\\n\\t\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase 'RingGeometry':\\r\\n\\t\\t\\t\\t\\t\\tcase 'RingBufferGeometry':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.innerRadius,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.outerRadius,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.phiSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaStart,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaLength\\r\\n\\t\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase 'TorusGeometry':\\r\\n\\t\\t\\t\\t\\t\\tcase 'TorusBufferGeometry':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radius,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.tube,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radialSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.tubularSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.arc\\r\\n\\t\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase 'TorusKnotGeometry':\\r\\n\\t\\t\\t\\t\\t\\tcase 'TorusKnotBufferGeometry':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radius,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.tube,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.tubularSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radialSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.p,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.q\\r\\n\\t\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase 'LatheGeometry':\\r\\n\\t\\t\\t\\t\\t\\tcase 'LatheBufferGeometry':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.points,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.segments,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.phiStart,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.phiLength\\r\\n\\t\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase 'PolyhedronGeometry':\\r\\n\\t\\t\\t\\t\\t\\tcase 'PolyhedronBufferGeometry':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.vertices,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.indices,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radius,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.details\\r\\n\\t\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase 'ShapeGeometry':\\r\\n\\t\\t\\t\\t\\t\\tcase 'ShapeBufferGeometry':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar geometryShapes = [];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tfor ( var i = 0, l = data.shapes.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tvar shape = shapes[ data.shapes[ i ] ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgeometryShapes.push( shape );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgeometryShapes,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.curveSegments\\r\\n\\t\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase 'BufferGeometry':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tgeometry = bufferGeometryLoader.parse( data );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase 'Geometry':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tgeometry = geometryLoader.parse( data, this.texturePath ).geometry;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tdefault:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \\\"' + data.type + '\\\"' );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tgeometry.uuid = data.uuid;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( data.name !== undefined ) geometry.name = data.name;\\r\\n\\r\\n\\t\\t\\t\\t\\tgeometries[ data.uuid ] = geometry;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn geometries;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tparseMaterials: function ( json, textures ) {\\r\\n\\r\\n\\t\\t\\tvar materials = {};\\r\\n\\r\\n\\t\\t\\tif ( json !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tvar loader = new MaterialLoader();\\r\\n\\t\\t\\t\\tloader.setTextures( textures );\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar data = json[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( data.type === 'MultiMaterial' ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// Deprecated\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar array = [];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var j = 0; j < data.materials.length; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tarray.push( loader.parse( data.materials[ j ] ) );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tmaterials[ data.uuid ] = array;\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tmaterials[ data.uuid ] = loader.parse( data );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn materials;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tparseAnimations: function ( json ) {\\r\\n\\r\\n\\t\\t\\tvar animations = [];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < json.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar clip = AnimationClip.parse( json[ i ] );\\r\\n\\r\\n\\t\\t\\t\\tanimations.push( clip );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn animations;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tparseImages: function ( json, onLoad ) {\\r\\n\\r\\n\\t\\t\\tvar scope = this;\\r\\n\\t\\t\\tvar images = {};\\r\\n\\r\\n\\t\\t\\tfunction loadImage( url ) {\\r\\n\\r\\n\\t\\t\\t\\tscope.manager.itemStart( url );\\r\\n\\r\\n\\t\\t\\t\\treturn loader.load( url, function () {\\r\\n\\r\\n\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\r\\n\\r\\n\\t\\t\\t\\t}, undefined, function () {\\r\\n\\r\\n\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\r\\n\\t\\t\\t\\t\\tscope.manager.itemError( url );\\r\\n\\r\\n\\t\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( json !== undefined && json.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tvar manager = new LoadingManager( onLoad );\\r\\n\\r\\n\\t\\t\\t\\tvar loader = new ImageLoader( manager );\\r\\n\\t\\t\\t\\tloader.setCrossOrigin( this.crossOrigin );\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar image = json[ i ];\\r\\n\\t\\t\\t\\t\\tvar path = /^(\\\\/\\\\/)|([a-z]+:(\\\\/\\\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\\r\\n\\r\\n\\t\\t\\t\\t\\timages[ image.uuid ] = loadImage( path );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn images;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tparseTextures: function ( json, images ) {\\r\\n\\r\\n\\t\\t\\tfunction parseConstant( value, type ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( typeof value === 'number' ) return value;\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\\r\\n\\r\\n\\t\\t\\t\\treturn type[ value ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar textures = {};\\r\\n\\r\\n\\t\\t\\tif ( json !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar data = json[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( data.image === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader: No \\\"image\\\" specified for', data.uuid );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( images[ data.image ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tvar texture = new Texture( images[ data.image ] );\\r\\n\\t\\t\\t\\t\\ttexture.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t\\t\\ttexture.uuid = data.uuid;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( data.name !== undefined ) texture.name = data.name;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( data.offset !== undefined ) texture.offset.fromArray( data.offset );\\r\\n\\t\\t\\t\\t\\tif ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );\\r\\n\\t\\t\\t\\t\\tif ( data.center !== undefined ) texture.center.fromArray( data.center );\\r\\n\\t\\t\\t\\t\\tif ( data.rotation !== undefined ) texture.rotation = data.rotation;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( data.wrap !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ttexture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );\\r\\n\\t\\t\\t\\t\\t\\ttexture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );\\r\\n\\t\\t\\t\\t\\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );\\r\\n\\t\\t\\t\\t\\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( data.flipY !== undefined ) texture.flipY = data.flipY;\\r\\n\\r\\n\\t\\t\\t\\t\\ttextures[ data.uuid ] = texture;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn textures;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tparseObject: function () {\\r\\n\\r\\n\\t\\t\\tvar matrix = new Matrix4();\\r\\n\\r\\n\\t\\t\\treturn function parseObject( data, geometries, materials ) {\\r\\n\\r\\n\\t\\t\\t\\tvar object;\\r\\n\\r\\n\\t\\t\\t\\tfunction getGeometry( name ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( geometries[ name ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\treturn geometries[ name ];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tfunction getMaterial( name ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( name === undefined ) return undefined;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( Array.isArray( name ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar array = [];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, l = name.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar uuid = name[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( materials[ uuid ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader: Undefined material', uuid );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tarray.push( materials[ uuid ] );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\treturn array;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( materials[ name ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\treturn materials[ name ];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tswitch ( data.type ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'Scene':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tobject = new Scene();\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( data.background !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( Number.isInteger( data.background ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tobject.background = new Color( data.background );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( data.fog !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( data.fog.type === 'Fog' ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tobject.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t} else if ( data.fog.type === 'FogExp2' ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tobject.fog = new FogExp2( data.fog.color, data.fog.density );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'PerspectiveCamera':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tobject = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( data.focus !== undefined ) object.focus = data.focus;\\r\\n\\t\\t\\t\\t\\t\\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\\r\\n\\t\\t\\t\\t\\t\\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\\r\\n\\t\\t\\t\\t\\t\\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\\r\\n\\t\\t\\t\\t\\t\\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'OrthographicCamera':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tobject = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'AmbientLight':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tobject = new AmbientLight( data.color, data.intensity );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'DirectionalLight':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tobject = new DirectionalLight( data.color, data.intensity );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'PointLight':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tobject = new PointLight( data.color, data.intensity, data.distance, data.decay );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'RectAreaLight':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tobject = new RectAreaLight( data.color, data.intensity, data.width, data.height );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'SpotLight':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tobject = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'HemisphereLight':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tobject = new HemisphereLight( data.color, data.groundColor, data.intensity );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'SkinnedMesh':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' );\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'Mesh':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar geometry = getGeometry( data.geometry );\\r\\n\\t\\t\\t\\t\\t\\tvar material = getMaterial( data.material );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( geometry.bones && geometry.bones.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tobject = new SkinnedMesh( geometry, material );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tobject = new Mesh( geometry, material );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'LOD':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tobject = new LOD();\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'Line':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tobject = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'LineLoop':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tobject = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'LineSegments':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tobject = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'PointCloud':\\r\\n\\t\\t\\t\\t\\tcase 'Points':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tobject = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'Sprite':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tobject = new Sprite( getMaterial( data.material ) );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'Group':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tobject = new Group();\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tdefault:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tobject = new Object3D();\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tobject.uuid = data.uuid;\\r\\n\\r\\n\\t\\t\\t\\tif ( data.name !== undefined ) object.name = data.name;\\r\\n\\t\\t\\t\\tif ( data.matrix !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tmatrix.fromArray( data.matrix );\\r\\n\\t\\t\\t\\t\\tmatrix.decompose( object.position, object.quaternion, object.scale );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( data.position !== undefined ) object.position.fromArray( data.position );\\r\\n\\t\\t\\t\\t\\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\\r\\n\\t\\t\\t\\t\\tif ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );\\r\\n\\t\\t\\t\\t\\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\\r\\n\\t\\t\\t\\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\\r\\n\\r\\n\\t\\t\\t\\tif ( data.shadow ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;\\r\\n\\t\\t\\t\\t\\tif ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;\\r\\n\\t\\t\\t\\t\\tif ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );\\r\\n\\t\\t\\t\\t\\tif ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( data.visible !== undefined ) object.visible = data.visible;\\r\\n\\t\\t\\t\\tif ( data.userData !== undefined ) object.userData = data.userData;\\r\\n\\r\\n\\t\\t\\t\\tif ( data.children !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar children = data.children;\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < children.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tobject.add( this.parseObject( children[ i ], geometries, materials ) );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( data.type === 'LOD' ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar levels = data.levels;\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var l = 0; l < levels.length; l ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar level = levels[ l ];\\r\\n\\t\\t\\t\\t\\t\\tvar child = object.getObjectByProperty( 'uuid', level.object );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( child !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tobject.addLevel( child, level.distance );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn object;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}()\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tvar TEXTURE_MAPPING = {\\r\\n\\t\\tUVMapping: UVMapping,\\r\\n\\t\\tCubeReflectionMapping: CubeReflectionMapping,\\r\\n\\t\\tCubeRefractionMapping: CubeRefractionMapping,\\r\\n\\t\\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\\r\\n\\t\\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\\r\\n\\t\\tSphericalReflectionMapping: SphericalReflectionMapping,\\r\\n\\t\\tCubeUVReflectionMapping: CubeUVReflectionMapping,\\r\\n\\t\\tCubeUVRefractionMapping: CubeUVRefractionMapping\\r\\n\\t};\\r\\n\\r\\n\\tvar TEXTURE_WRAPPING = {\\r\\n\\t\\tRepeatWrapping: RepeatWrapping,\\r\\n\\t\\tClampToEdgeWrapping: ClampToEdgeWrapping,\\r\\n\\t\\tMirroredRepeatWrapping: MirroredRepeatWrapping\\r\\n\\t};\\r\\n\\r\\n\\tvar TEXTURE_FILTER = {\\r\\n\\t\\tNearestFilter: NearestFilter,\\r\\n\\t\\tNearestMipMapNearestFilter: NearestMipMapNearestFilter,\\r\\n\\t\\tNearestMipMapLinearFilter: NearestMipMapLinearFilter,\\r\\n\\t\\tLinearFilter: LinearFilter,\\r\\n\\t\\tLinearMipMapNearestFilter: LinearMipMapNearestFilter,\\r\\n\\t\\tLinearMipMapLinearFilter: LinearMipMapLinearFilter\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author thespite / http://clicktorelease.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction ImageBitmapLoader( manager ) {\\r\\n\\r\\n\\t\\tif ( typeof createImageBitmap === 'undefined' ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( typeof fetch === 'undefined' ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.manager = manager !== undefined ? manager : DefaultLoadingManager;\\r\\n\\t\\tthis.options = undefined;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tImageBitmapLoader.prototype = {\\r\\n\\r\\n\\t\\tconstructor: ImageBitmapLoader,\\r\\n\\r\\n\\t\\tsetOptions: function setOptions( options ) {\\r\\n\\r\\n\\t\\t\\tthis.options = options;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tload: function load( url, onLoad, onProgress, onError ) {\\r\\n\\r\\n\\t\\t\\tif ( url === undefined ) url = '';\\r\\n\\r\\n\\t\\t\\tif ( this.path !== undefined ) url = this.path + url;\\r\\n\\r\\n\\t\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\t\\tvar cached = Cache.get( url );\\r\\n\\r\\n\\t\\t\\tif ( cached !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tscope.manager.itemStart( url );\\r\\n\\r\\n\\t\\t\\t\\tsetTimeout( function () {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( onLoad ) onLoad( cached );\\r\\n\\r\\n\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\r\\n\\r\\n\\t\\t\\t\\t}, 0 );\\r\\n\\r\\n\\t\\t\\t\\treturn cached;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfetch( url ).then( function ( res ) {\\r\\n\\r\\n\\t\\t\\t\\treturn res.blob();\\r\\n\\r\\n\\t\\t\\t} ).then( function ( blob ) {\\r\\n\\r\\n\\t\\t\\t\\treturn createImageBitmap( blob, scope.options );\\r\\n\\r\\n\\t\\t\\t} ).then( function ( imageBitmap ) {\\r\\n\\r\\n\\t\\t\\t\\tCache.add( url, imageBitmap );\\r\\n\\r\\n\\t\\t\\t\\tif ( onLoad ) onLoad( imageBitmap );\\r\\n\\r\\n\\t\\t\\t\\tscope.manager.itemEnd( url );\\r\\n\\r\\n\\t\\t\\t} ).catch( function ( e ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( onError ) onError( e );\\r\\n\\r\\n\\t\\t\\t\\tscope.manager.itemEnd( url );\\r\\n\\t\\t\\t\\tscope.manager.itemError( url );\\r\\n\\r\\n\\t\\t\\t} );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetCrossOrigin: function ( /* value */ ) {\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetPath: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.path = value;\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\r\\n\\t * minimal class for proxing functions to Path. Replaces old \\\"extractSubpaths()\\\"\\r\\n\\t **/\\r\\n\\r\\n\\tfunction ShapePath() {\\r\\n\\r\\n\\t\\tthis.type = 'ShapePath';\\r\\n\\r\\n\\t\\tthis.subPaths = [];\\r\\n\\t\\tthis.currentPath = null;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( ShapePath.prototype, {\\r\\n\\r\\n\\t\\tmoveTo: function ( x, y ) {\\r\\n\\r\\n\\t\\t\\tthis.currentPath = new Path();\\r\\n\\t\\t\\tthis.subPaths.push( this.currentPath );\\r\\n\\t\\t\\tthis.currentPath.moveTo( x, y );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tlineTo: function ( x, y ) {\\r\\n\\r\\n\\t\\t\\tthis.currentPath.lineTo( x, y );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\\r\\n\\r\\n\\t\\t\\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\\r\\n\\r\\n\\t\\t\\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsplineThru: function ( pts ) {\\r\\n\\r\\n\\t\\t\\tthis.currentPath.splineThru( pts );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\ttoShapes: function ( isCCW, noHoles ) {\\r\\n\\r\\n\\t\\t\\tfunction toShapesNoHoles( inSubpaths ) {\\r\\n\\r\\n\\t\\t\\t\\tvar shapes = [];\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar tmpPath = inSubpaths[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\tvar tmpShape = new Shape();\\r\\n\\t\\t\\t\\t\\ttmpShape.curves = tmpPath.curves;\\r\\n\\r\\n\\t\\t\\t\\t\\tshapes.push( tmpShape );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn shapes;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfunction isPointInsidePolygon( inPt, inPolygon ) {\\r\\n\\r\\n\\t\\t\\t\\tvar polyLen = inPolygon.length;\\r\\n\\r\\n\\t\\t\\t\\t// inPt on polygon contour => immediate success    or\\r\\n\\t\\t\\t\\t// toggling of inside/outside at every single! intersection point of an edge\\r\\n\\t\\t\\t\\t//  with the horizontal line through inPt, left of inPt\\r\\n\\t\\t\\t\\t//  not counting lowerY endpoints of edges and whole edges on that line\\r\\n\\t\\t\\t\\tvar inside = false;\\r\\n\\t\\t\\t\\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar edgeLowPt = inPolygon[ p ];\\r\\n\\t\\t\\t\\t\\tvar edgeHighPt = inPolygon[ q ];\\r\\n\\r\\n\\t\\t\\t\\t\\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\\r\\n\\t\\t\\t\\t\\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// not parallel\\r\\n\\t\\t\\t\\t\\t\\tif ( edgeDy < 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tedgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;\\r\\n\\t\\t\\t\\t\\t\\t\\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \\t\\tcontinue;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( inPt.y === edgeLowPt.y ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( inPt.x === edgeLowPt.x )\\t\\treturn\\ttrue;\\t\\t// inPt is on contour ?\\r\\n\\t\\t\\t\\t\\t\\t\\t// continue;\\t\\t\\t\\t// no intersection or edgeLowPt => doesn't count !!!\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( perpEdge === 0 )\\t\\t\\t\\treturn\\ttrue;\\t\\t// inPt is on contour ?\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( perpEdge < 0 ) \\t\\t\\t\\tcontinue;\\r\\n\\t\\t\\t\\t\\t\\t\\tinside = ! inside;\\t\\t// true intersection left of inPt\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// parallel or collinear\\r\\n\\t\\t\\t\\t\\t\\tif ( inPt.y !== edgeLowPt.y ) \\t\\tcontinue;\\t\\t\\t// parallel\\r\\n\\t\\t\\t\\t\\t\\t// edge lies on the same horizontal line as inPt\\r\\n\\t\\t\\t\\t\\t\\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\\r\\n\\t\\t\\t\\t\\t\\t\\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\\t\\treturn\\ttrue;\\t// inPt: Point on contour !\\r\\n\\t\\t\\t\\t\\t\\t// continue;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn\\tinside;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar isClockWise = ShapeUtils.isClockWise;\\r\\n\\r\\n\\t\\t\\tvar subPaths = this.subPaths;\\r\\n\\t\\t\\tif ( subPaths.length === 0 ) return [];\\r\\n\\r\\n\\t\\t\\tif ( noHoles === true )\\treturn\\ttoShapesNoHoles( subPaths );\\r\\n\\r\\n\\r\\n\\t\\t\\tvar solid, tmpPath, tmpShape, shapes = [];\\r\\n\\r\\n\\t\\t\\tif ( subPaths.length === 1 ) {\\r\\n\\r\\n\\t\\t\\t\\ttmpPath = subPaths[ 0 ];\\r\\n\\t\\t\\t\\ttmpShape = new Shape();\\r\\n\\t\\t\\t\\ttmpShape.curves = tmpPath.curves;\\r\\n\\t\\t\\t\\tshapes.push( tmpShape );\\r\\n\\t\\t\\t\\treturn shapes;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\\r\\n\\t\\t\\tholesFirst = isCCW ? ! holesFirst : holesFirst;\\r\\n\\r\\n\\t\\t\\t// console.log(\\\"Holes first\\\", holesFirst);\\r\\n\\r\\n\\t\\t\\tvar betterShapeHoles = [];\\r\\n\\t\\t\\tvar newShapes = [];\\r\\n\\t\\t\\tvar newShapeHoles = [];\\r\\n\\t\\t\\tvar mainIdx = 0;\\r\\n\\t\\t\\tvar tmpPoints;\\r\\n\\r\\n\\t\\t\\tnewShapes[ mainIdx ] = undefined;\\r\\n\\t\\t\\tnewShapeHoles[ mainIdx ] = [];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\ttmpPath = subPaths[ i ];\\r\\n\\t\\t\\t\\ttmpPoints = tmpPath.getPoints();\\r\\n\\t\\t\\t\\tsolid = isClockWise( tmpPoints );\\r\\n\\t\\t\\t\\tsolid = isCCW ? ! solid : solid;\\r\\n\\r\\n\\t\\t\\t\\tif ( solid ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\\tmainIdx ++;\\r\\n\\r\\n\\t\\t\\t\\t\\tnewShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\\r\\n\\t\\t\\t\\t\\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( holesFirst )\\tmainIdx ++;\\r\\n\\t\\t\\t\\t\\tnewShapeHoles[ mainIdx ] = [];\\r\\n\\r\\n\\t\\t\\t\\t\\t//console.log('cw', i);\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\\r\\n\\r\\n\\t\\t\\t\\t\\t//console.log('ccw', i);\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// only Holes? -> probably all Shapes with wrong orientation\\r\\n\\t\\t\\tif ( ! newShapes[ 0 ] )\\treturn\\ttoShapesNoHoles( subPaths );\\r\\n\\r\\n\\r\\n\\t\\t\\tif ( newShapes.length > 1 ) {\\r\\n\\r\\n\\t\\t\\t\\tvar ambiguous = false;\\r\\n\\t\\t\\t\\tvar toChange = [];\\r\\n\\r\\n\\t\\t\\t\\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tbetterShapeHoles[ sIdx ] = [];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar sho = newShapeHoles[ sIdx ];\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar ho = sho[ hIdx ];\\r\\n\\t\\t\\t\\t\\t\\tvar hole_unassigned = true;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( sIdx !== s2Idx )\\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( hole_unassigned ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\thole_unassigned = false;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbetterShapeHoles[ s2Idx ].push( ho );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tambiguous = true;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\tif ( hole_unassigned ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tbetterShapeHoles[ sIdx ].push( ho );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t// console.log(\\\"ambiguous: \\\", ambiguous);\\r\\n\\t\\t\\t\\tif ( toChange.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// console.log(\\\"to change: \\\", toChange);\\r\\n\\t\\t\\t\\t\\tif ( ! ambiguous )\\tnewShapeHoles = betterShapeHoles;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar tmpHoles;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\ttmpShape = newShapes[ i ].s;\\r\\n\\t\\t\\t\\tshapes.push( tmpShape );\\r\\n\\t\\t\\t\\ttmpHoles = newShapeHoles[ i ];\\r\\n\\r\\n\\t\\t\\t\\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\ttmpShape.holes.push( tmpHoles[ j ].h );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t//console.log(\\\"shape\\\", shapes);\\r\\n\\r\\n\\t\\t\\treturn shapes;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction Font( data ) {\\r\\n\\r\\n\\t\\tthis.type = 'Font';\\r\\n\\r\\n\\t\\tthis.data = data;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( Font.prototype, {\\r\\n\\r\\n\\t\\tisFont: true,\\r\\n\\r\\n\\t\\tgenerateShapes: function ( text, size, divisions ) {\\r\\n\\r\\n\\t\\t\\tfunction createPaths( text ) {\\r\\n\\r\\n\\t\\t\\t\\tvar chars = String( text ).split( '' );\\r\\n\\t\\t\\t\\tvar scale = size / data.resolution;\\r\\n\\t\\t\\t\\tvar line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;\\r\\n\\r\\n\\t\\t\\t\\tvar offsetX = 0, offsetY = 0;\\r\\n\\r\\n\\t\\t\\t\\tvar paths = [];\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0; i < chars.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar char = chars[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( char === '\\\\n' ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\toffsetX = 0;\\r\\n\\t\\t\\t\\t\\t\\toffsetY -= line_height;\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar ret = createPath( char, scale, offsetX, offsetY );\\r\\n\\t\\t\\t\\t\\t\\toffsetX += ret.offsetX;\\r\\n\\t\\t\\t\\t\\t\\tpaths.push( ret.path );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn paths;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfunction createPath( c, scale, offsetX, offsetY ) {\\r\\n\\r\\n\\t\\t\\t\\tvar glyph = data.glyphs[ c ] || data.glyphs[ '?' ];\\r\\n\\r\\n\\t\\t\\t\\tif ( ! glyph ) return;\\r\\n\\r\\n\\t\\t\\t\\tvar path = new ShapePath();\\r\\n\\r\\n\\t\\t\\t\\tvar pts = [];\\r\\n\\t\\t\\t\\tvar x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;\\r\\n\\r\\n\\t\\t\\t\\tif ( glyph.o ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = outline.length; i < l; ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar action = outline[ i ++ ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tswitch ( action ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tcase 'm': // moveTo\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tx = outline[ i ++ ] * scale + offsetX;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\ty = outline[ i ++ ] * scale + offsetY;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tpath.moveTo( x, y );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tcase 'l': // lineTo\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tx = outline[ i ++ ] * scale + offsetX;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\ty = outline[ i ++ ] * scale + offsetY;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tpath.lineTo( x, y );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tcase 'q': // quadraticCurveTo\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tcpx = outline[ i ++ ] * scale + offsetX;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tcpy = outline[ i ++ ] * scale + offsetY;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tcpx1 = outline[ i ++ ] * scale + offsetX;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tcpy1 = outline[ i ++ ] * scale + offsetY;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tlaste = pts[ pts.length - 1 ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( laste ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcpx0 = laste.x;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcpy0 = laste.y;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tcase 'b': // bezierCurveTo\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tcpx = outline[ i ++ ] * scale + offsetX;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tcpy = outline[ i ++ ] * scale + offsetY;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tcpx1 = outline[ i ++ ] * scale + offsetX;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tcpy1 = outline[ i ++ ] * scale + offsetY;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tcpx2 = outline[ i ++ ] * scale + offsetX;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tcpy2 = outline[ i ++ ] * scale + offsetY;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tlaste = pts[ pts.length - 1 ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( laste ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcpx0 = laste.x;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcpy0 = laste.y;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn { offsetX: glyph.ha * scale, path: path };\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\tif ( size === undefined ) size = 100;\\r\\n\\t\\t\\tif ( divisions === undefined ) divisions = 4;\\r\\n\\r\\n\\t\\t\\tvar data = this.data;\\r\\n\\r\\n\\t\\t\\tvar paths = createPaths( text );\\r\\n\\t\\t\\tvar shapes = [];\\r\\n\\r\\n\\t\\t\\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn shapes;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction FontLoader( manager ) {\\r\\n\\r\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( FontLoader.prototype, {\\r\\n\\r\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\r\\n\\r\\n\\t\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\t\\tvar loader = new FileLoader( this.manager );\\r\\n\\t\\t\\tloader.setPath( this.path );\\r\\n\\t\\t\\tloader.load( url, function ( text ) {\\r\\n\\r\\n\\t\\t\\t\\tvar json;\\r\\n\\r\\n\\t\\t\\t\\ttry {\\r\\n\\r\\n\\t\\t\\t\\t\\tjson = JSON.parse( text );\\r\\n\\r\\n\\t\\t\\t\\t} catch ( e ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\\r\\n\\t\\t\\t\\t\\tjson = JSON.parse( text.substring( 65, text.length - 2 ) );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tvar font = scope.parse( json );\\r\\n\\r\\n\\t\\t\\t\\tif ( onLoad ) onLoad( font );\\r\\n\\r\\n\\t\\t\\t}, onProgress, onError );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tparse: function ( json ) {\\r\\n\\r\\n\\t\\t\\treturn new Font( json );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetPath: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.path = value;\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tvar context;\\r\\n\\r\\n\\tvar AudioContext = {\\r\\n\\r\\n\\t\\tgetContext: function () {\\r\\n\\r\\n\\t\\t\\tif ( context === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tcontext = new ( window.AudioContext || window.webkitAudioContext )();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn context;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetContext: function ( value ) {\\r\\n\\r\\n\\t\\t\\tcontext = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction AudioLoader( manager ) {\\r\\n\\r\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( AudioLoader.prototype, {\\r\\n\\r\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\r\\n\\r\\n\\t\\t\\tvar loader = new FileLoader( this.manager );\\r\\n\\t\\t\\tloader.setResponseType( 'arraybuffer' );\\r\\n\\t\\t\\tloader.load( url, function ( buffer ) {\\r\\n\\r\\n\\t\\t\\t\\tvar context = AudioContext.getContext();\\r\\n\\r\\n\\t\\t\\t\\tcontext.decodeAudioData( buffer, function ( audioBuffer ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tonLoad( audioBuffer );\\r\\n\\r\\n\\t\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\t}, onProgress, onError );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction StereoCamera() {\\r\\n\\r\\n\\t\\tthis.type = 'StereoCamera';\\r\\n\\r\\n\\t\\tthis.aspect = 1;\\r\\n\\r\\n\\t\\tthis.eyeSep = 0.064;\\r\\n\\r\\n\\t\\tthis.cameraL = new PerspectiveCamera();\\r\\n\\t\\tthis.cameraL.layers.enable( 1 );\\r\\n\\t\\tthis.cameraL.matrixAutoUpdate = false;\\r\\n\\r\\n\\t\\tthis.cameraR = new PerspectiveCamera();\\r\\n\\t\\tthis.cameraR.layers.enable( 2 );\\r\\n\\t\\tthis.cameraR.matrixAutoUpdate = false;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( StereoCamera.prototype, {\\r\\n\\r\\n\\t\\tupdate: ( function () {\\r\\n\\r\\n\\t\\t\\tvar instance, focus, fov, aspect, near, far, zoom, eyeSep;\\r\\n\\r\\n\\t\\t\\tvar eyeRight = new Matrix4();\\r\\n\\t\\t\\tvar eyeLeft = new Matrix4();\\r\\n\\r\\n\\t\\t\\treturn function update( camera ) {\\r\\n\\r\\n\\t\\t\\t\\tvar needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\taspect !== camera.aspect * this.aspect || near !== camera.near ||\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfar !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;\\r\\n\\r\\n\\t\\t\\t\\tif ( needsUpdate ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tinstance = this;\\r\\n\\t\\t\\t\\t\\tfocus = camera.focus;\\r\\n\\t\\t\\t\\t\\tfov = camera.fov;\\r\\n\\t\\t\\t\\t\\taspect = camera.aspect * this.aspect;\\r\\n\\t\\t\\t\\t\\tnear = camera.near;\\r\\n\\t\\t\\t\\t\\tfar = camera.far;\\r\\n\\t\\t\\t\\t\\tzoom = camera.zoom;\\r\\n\\r\\n\\t\\t\\t\\t\\t// Off-axis stereoscopic effect based on\\r\\n\\t\\t\\t\\t\\t// http://paulbourke.net/stereographics/stereorender/\\r\\n\\r\\n\\t\\t\\t\\t\\tvar projectionMatrix = camera.projectionMatrix.clone();\\r\\n\\t\\t\\t\\t\\teyeSep = this.eyeSep / 2;\\r\\n\\t\\t\\t\\t\\tvar eyeSepOnProjection = eyeSep * near / focus;\\r\\n\\t\\t\\t\\t\\tvar ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;\\r\\n\\t\\t\\t\\t\\tvar xmin, xmax;\\r\\n\\r\\n\\t\\t\\t\\t\\t// translate xOffset\\r\\n\\r\\n\\t\\t\\t\\t\\teyeLeft.elements[ 12 ] = - eyeSep;\\r\\n\\t\\t\\t\\t\\teyeRight.elements[ 12 ] = eyeSep;\\r\\n\\r\\n\\t\\t\\t\\t\\t// for left eye\\r\\n\\r\\n\\t\\t\\t\\t\\txmin = - ymax * aspect + eyeSepOnProjection;\\r\\n\\t\\t\\t\\t\\txmax = ymax * aspect + eyeSepOnProjection;\\r\\n\\r\\n\\t\\t\\t\\t\\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\\r\\n\\t\\t\\t\\t\\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\\r\\n\\r\\n\\t\\t\\t\\t\\t// for right eye\\r\\n\\r\\n\\t\\t\\t\\t\\txmin = - ymax * aspect - eyeSepOnProjection;\\r\\n\\t\\t\\t\\t\\txmax = ymax * aspect - eyeSepOnProjection;\\r\\n\\r\\n\\t\\t\\t\\t\\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\\r\\n\\t\\t\\t\\t\\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\\r\\n\\t\\t\\t\\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t} )()\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * Camera for rendering cube maps\\r\\n\\t *\\t- renders scene into axis-aligned cube\\r\\n\\t *\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction CubeCamera( near, far, cubeResolution ) {\\r\\n\\r\\n\\t\\tObject3D.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'CubeCamera';\\r\\n\\r\\n\\t\\tvar fov = 90, aspect = 1;\\r\\n\\r\\n\\t\\tvar cameraPX = new PerspectiveCamera( fov, aspect, near, far );\\r\\n\\t\\tcameraPX.up.set( 0, - 1, 0 );\\r\\n\\t\\tcameraPX.lookAt( new Vector3( 1, 0, 0 ) );\\r\\n\\t\\tthis.add( cameraPX );\\r\\n\\r\\n\\t\\tvar cameraNX = new PerspectiveCamera( fov, aspect, near, far );\\r\\n\\t\\tcameraNX.up.set( 0, - 1, 0 );\\r\\n\\t\\tcameraNX.lookAt( new Vector3( - 1, 0, 0 ) );\\r\\n\\t\\tthis.add( cameraNX );\\r\\n\\r\\n\\t\\tvar cameraPY = new PerspectiveCamera( fov, aspect, near, far );\\r\\n\\t\\tcameraPY.up.set( 0, 0, 1 );\\r\\n\\t\\tcameraPY.lookAt( new Vector3( 0, 1, 0 ) );\\r\\n\\t\\tthis.add( cameraPY );\\r\\n\\r\\n\\t\\tvar cameraNY = new PerspectiveCamera( fov, aspect, near, far );\\r\\n\\t\\tcameraNY.up.set( 0, 0, - 1 );\\r\\n\\t\\tcameraNY.lookAt( new Vector3( 0, - 1, 0 ) );\\r\\n\\t\\tthis.add( cameraNY );\\r\\n\\r\\n\\t\\tvar cameraPZ = new PerspectiveCamera( fov, aspect, near, far );\\r\\n\\t\\tcameraPZ.up.set( 0, - 1, 0 );\\r\\n\\t\\tcameraPZ.lookAt( new Vector3( 0, 0, 1 ) );\\r\\n\\t\\tthis.add( cameraPZ );\\r\\n\\r\\n\\t\\tvar cameraNZ = new PerspectiveCamera( fov, aspect, near, far );\\r\\n\\t\\tcameraNZ.up.set( 0, - 1, 0 );\\r\\n\\t\\tcameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );\\r\\n\\t\\tthis.add( cameraNZ );\\r\\n\\r\\n\\t\\tvar options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };\\r\\n\\r\\n\\t\\tthis.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\\r\\n\\t\\tthis.renderTarget.texture.name = \\\"CubeCamera\\\";\\r\\n\\r\\n\\t\\tthis.update = function ( renderer, scene ) {\\r\\n\\r\\n\\t\\t\\tif ( this.parent === null ) this.updateMatrixWorld();\\r\\n\\r\\n\\t\\t\\tvar renderTarget = this.renderTarget;\\r\\n\\t\\t\\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\\r\\n\\r\\n\\t\\t\\trenderTarget.texture.generateMipmaps = false;\\r\\n\\r\\n\\t\\t\\trenderTarget.activeCubeFace = 0;\\r\\n\\t\\t\\trenderer.render( scene, cameraPX, renderTarget );\\r\\n\\r\\n\\t\\t\\trenderTarget.activeCubeFace = 1;\\r\\n\\t\\t\\trenderer.render( scene, cameraNX, renderTarget );\\r\\n\\r\\n\\t\\t\\trenderTarget.activeCubeFace = 2;\\r\\n\\t\\t\\trenderer.render( scene, cameraPY, renderTarget );\\r\\n\\r\\n\\t\\t\\trenderTarget.activeCubeFace = 3;\\r\\n\\t\\t\\trenderer.render( scene, cameraNY, renderTarget );\\r\\n\\r\\n\\t\\t\\trenderTarget.activeCubeFace = 4;\\r\\n\\t\\t\\trenderer.render( scene, cameraPZ, renderTarget );\\r\\n\\r\\n\\t\\t\\trenderTarget.texture.generateMipmaps = generateMipmaps;\\r\\n\\r\\n\\t\\t\\trenderTarget.activeCubeFace = 5;\\r\\n\\t\\t\\trenderer.render( scene, cameraNZ, renderTarget );\\r\\n\\r\\n\\t\\t\\trenderer.setRenderTarget( null );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.clear = function ( renderer, color, depth, stencil ) {\\r\\n\\r\\n\\t\\t\\tvar renderTarget = this.renderTarget;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\trenderTarget.activeCubeFace = i;\\r\\n\\t\\t\\t\\trenderer.setRenderTarget( renderTarget );\\r\\n\\r\\n\\t\\t\\t\\trenderer.clear( color, depth, stencil );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\trenderer.setRenderTarget( null );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tCubeCamera.prototype = Object.create( Object3D.prototype );\\r\\n\\tCubeCamera.prototype.constructor = CubeCamera;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction AudioListener() {\\r\\n\\r\\n\\t\\tObject3D.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'AudioListener';\\r\\n\\r\\n\\t\\tthis.context = AudioContext.getContext();\\r\\n\\r\\n\\t\\tthis.gain = this.context.createGain();\\r\\n\\t\\tthis.gain.connect( this.context.destination );\\r\\n\\r\\n\\t\\tthis.filter = null;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tAudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: AudioListener,\\r\\n\\r\\n\\t\\tgetInput: function () {\\r\\n\\r\\n\\t\\t\\treturn this.gain;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tremoveFilter: function ( ) {\\r\\n\\r\\n\\t\\t\\tif ( this.filter !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.gain.disconnect( this.filter );\\r\\n\\t\\t\\t\\tthis.filter.disconnect( this.context.destination );\\r\\n\\t\\t\\t\\tthis.gain.connect( this.context.destination );\\r\\n\\t\\t\\t\\tthis.filter = null;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetFilter: function () {\\r\\n\\r\\n\\t\\t\\treturn this.filter;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFilter: function ( value ) {\\r\\n\\r\\n\\t\\t\\tif ( this.filter !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.gain.disconnect( this.filter );\\r\\n\\t\\t\\t\\tthis.filter.disconnect( this.context.destination );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tthis.gain.disconnect( this.context.destination );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.filter = value;\\r\\n\\t\\t\\tthis.gain.connect( this.filter );\\r\\n\\t\\t\\tthis.filter.connect( this.context.destination );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetMasterVolume: function () {\\r\\n\\r\\n\\t\\t\\treturn this.gain.gain.value;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetMasterVolume: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.gain.gain.value = value;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tupdateMatrixWorld: ( function () {\\r\\n\\r\\n\\t\\t\\tvar position = new Vector3();\\r\\n\\t\\t\\tvar quaternion = new Quaternion();\\r\\n\\t\\t\\tvar scale = new Vector3();\\r\\n\\r\\n\\t\\t\\tvar orientation = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function updateMatrixWorld( force ) {\\r\\n\\r\\n\\t\\t\\t\\tObject3D.prototype.updateMatrixWorld.call( this, force );\\r\\n\\r\\n\\t\\t\\t\\tvar listener = this.context.listener;\\r\\n\\t\\t\\t\\tvar up = this.up;\\r\\n\\r\\n\\t\\t\\t\\tthis.matrixWorld.decompose( position, quaternion, scale );\\r\\n\\r\\n\\t\\t\\t\\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\\r\\n\\r\\n\\t\\t\\t\\tif ( listener.positionX ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tlistener.positionX.setValueAtTime( position.x, this.context.currentTime );\\r\\n\\t\\t\\t\\t\\tlistener.positionY.setValueAtTime( position.y, this.context.currentTime );\\r\\n\\t\\t\\t\\t\\tlistener.positionZ.setValueAtTime( position.z, this.context.currentTime );\\r\\n\\t\\t\\t\\t\\tlistener.forwardX.setValueAtTime( orientation.x, this.context.currentTime );\\r\\n\\t\\t\\t\\t\\tlistener.forwardY.setValueAtTime( orientation.y, this.context.currentTime );\\r\\n\\t\\t\\t\\t\\tlistener.forwardZ.setValueAtTime( orientation.z, this.context.currentTime );\\r\\n\\t\\t\\t\\t\\tlistener.upX.setValueAtTime( up.x, this.context.currentTime );\\r\\n\\t\\t\\t\\t\\tlistener.upY.setValueAtTime( up.y, this.context.currentTime );\\r\\n\\t\\t\\t\\t\\tlistener.upZ.setValueAtTime( up.z, this.context.currentTime );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tlistener.setPosition( position.x, position.y, position.z );\\r\\n\\t\\t\\t\\t\\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t} )()\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction Audio( listener ) {\\r\\n\\r\\n\\t\\tObject3D.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'Audio';\\r\\n\\r\\n\\t\\tthis.context = listener.context;\\r\\n\\r\\n\\t\\tthis.gain = this.context.createGain();\\r\\n\\t\\tthis.gain.connect( listener.getInput() );\\r\\n\\r\\n\\t\\tthis.autoplay = false;\\r\\n\\r\\n\\t\\tthis.buffer = null;\\r\\n\\t\\tthis.loop = false;\\r\\n\\t\\tthis.startTime = 0;\\r\\n\\t\\tthis.offset = 0;\\r\\n\\t\\tthis.playbackRate = 1;\\r\\n\\t\\tthis.isPlaying = false;\\r\\n\\t\\tthis.hasPlaybackControl = true;\\r\\n\\t\\tthis.sourceType = 'empty';\\r\\n\\r\\n\\t\\tthis.filters = [];\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tAudio.prototype = Object.assign( Object.create( Object3D.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: Audio,\\r\\n\\r\\n\\t\\tgetOutput: function () {\\r\\n\\r\\n\\t\\t\\treturn this.gain;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetNodeSource: function ( audioNode ) {\\r\\n\\r\\n\\t\\t\\tthis.hasPlaybackControl = false;\\r\\n\\t\\t\\tthis.sourceType = 'audioNode';\\r\\n\\t\\t\\tthis.source = audioNode;\\r\\n\\t\\t\\tthis.connect();\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetBuffer: function ( audioBuffer ) {\\r\\n\\r\\n\\t\\t\\tthis.buffer = audioBuffer;\\r\\n\\t\\t\\tthis.sourceType = 'buffer';\\r\\n\\r\\n\\t\\t\\tif ( this.autoplay ) this.play();\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tplay: function () {\\r\\n\\r\\n\\t\\t\\tif ( this.isPlaying === true ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\\r\\n\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( this.hasPlaybackControl === false ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\\r\\n\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar source = this.context.createBufferSource();\\r\\n\\r\\n\\t\\t\\tsource.buffer = this.buffer;\\r\\n\\t\\t\\tsource.loop = this.loop;\\r\\n\\t\\t\\tsource.onended = this.onEnded.bind( this );\\r\\n\\t\\t\\tsource.playbackRate.setValueAtTime( this.playbackRate, this.startTime );\\r\\n\\t\\t\\tthis.startTime = this.context.currentTime;\\r\\n\\t\\t\\tsource.start( this.startTime, this.offset );\\r\\n\\r\\n\\t\\t\\tthis.isPlaying = true;\\r\\n\\r\\n\\t\\t\\tthis.source = source;\\r\\n\\r\\n\\t\\t\\treturn this.connect();\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tpause: function () {\\r\\n\\r\\n\\t\\t\\tif ( this.hasPlaybackControl === false ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\\r\\n\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( this.isPlaying === true ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.source.stop();\\r\\n\\t\\t\\t\\tthis.offset += ( this.context.currentTime - this.startTime ) * this.playbackRate;\\r\\n\\t\\t\\t\\tthis.isPlaying = false;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tstop: function () {\\r\\n\\r\\n\\t\\t\\tif ( this.hasPlaybackControl === false ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\\r\\n\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.source.stop();\\r\\n\\t\\t\\tthis.offset = 0;\\r\\n\\t\\t\\tthis.isPlaying = false;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tconnect: function () {\\r\\n\\r\\n\\t\\t\\tif ( this.filters.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.source.connect( this.filters[ 0 ] );\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tthis.source.connect( this.getOutput() );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdisconnect: function () {\\r\\n\\r\\n\\t\\t\\tif ( this.filters.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.source.disconnect( this.filters[ 0 ] );\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tthis.source.disconnect( this.getOutput() );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetFilters: function () {\\r\\n\\r\\n\\t\\t\\treturn this.filters;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFilters: function ( value ) {\\r\\n\\r\\n\\t\\t\\tif ( ! value ) value = [];\\r\\n\\r\\n\\t\\t\\tif ( this.isPlaying === true ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.disconnect();\\r\\n\\t\\t\\t\\tthis.filters = value;\\r\\n\\t\\t\\t\\tthis.connect();\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tthis.filters = value;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetFilter: function () {\\r\\n\\r\\n\\t\\t\\treturn this.getFilters()[ 0 ];\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFilter: function ( filter ) {\\r\\n\\r\\n\\t\\t\\treturn this.setFilters( filter ? [ filter ] : [] );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetPlaybackRate: function ( value ) {\\r\\n\\r\\n\\t\\t\\tif ( this.hasPlaybackControl === false ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\\r\\n\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.playbackRate = value;\\r\\n\\r\\n\\t\\t\\tif ( this.isPlaying === true ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.source.playbackRate.setValueAtTime( this.playbackRate, this.context.currentTime );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetPlaybackRate: function () {\\r\\n\\r\\n\\t\\t\\treturn this.playbackRate;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tonEnded: function () {\\r\\n\\r\\n\\t\\t\\tthis.isPlaying = false;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetLoop: function () {\\r\\n\\r\\n\\t\\t\\tif ( this.hasPlaybackControl === false ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\\r\\n\\t\\t\\t\\treturn false;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this.loop;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetLoop: function ( value ) {\\r\\n\\r\\n\\t\\t\\tif ( this.hasPlaybackControl === false ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\\r\\n\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.loop = value;\\r\\n\\r\\n\\t\\t\\tif ( this.isPlaying === true ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.source.loop = this.loop;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetVolume: function () {\\r\\n\\r\\n\\t\\t\\treturn this.gain.gain.value;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetVolume: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.gain.gain.value = value;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction PositionalAudio( listener ) {\\r\\n\\r\\n\\t\\tAudio.call( this, listener );\\r\\n\\r\\n\\t\\tthis.panner = this.context.createPanner();\\r\\n\\t\\tthis.panner.connect( this.gain );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tPositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: PositionalAudio,\\r\\n\\r\\n\\t\\tgetOutput: function () {\\r\\n\\r\\n\\t\\t\\treturn this.panner;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetRefDistance: function () {\\r\\n\\r\\n\\t\\t\\treturn this.panner.refDistance;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetRefDistance: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.panner.refDistance = value;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetRolloffFactor: function () {\\r\\n\\r\\n\\t\\t\\treturn this.panner.rolloffFactor;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetRolloffFactor: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.panner.rolloffFactor = value;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetDistanceModel: function () {\\r\\n\\r\\n\\t\\t\\treturn this.panner.distanceModel;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetDistanceModel: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.panner.distanceModel = value;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetMaxDistance: function () {\\r\\n\\r\\n\\t\\t\\treturn this.panner.maxDistance;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetMaxDistance: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.panner.maxDistance = value;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tupdateMatrixWorld: ( function () {\\r\\n\\r\\n\\t\\t\\tvar position = new Vector3();\\r\\n\\r\\n\\t\\t\\treturn function updateMatrixWorld( force ) {\\r\\n\\r\\n\\t\\t\\t\\tObject3D.prototype.updateMatrixWorld.call( this, force );\\r\\n\\r\\n\\t\\t\\t\\tposition.setFromMatrixPosition( this.matrixWorld );\\r\\n\\r\\n\\t\\t\\t\\tthis.panner.setPosition( position.x, position.y, position.z );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t} )()\\r\\n\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction AudioAnalyser( audio, fftSize ) {\\r\\n\\r\\n\\t\\tthis.analyser = audio.context.createAnalyser();\\r\\n\\t\\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\\r\\n\\r\\n\\t\\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\\r\\n\\r\\n\\t\\taudio.getOutput().connect( this.analyser );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( AudioAnalyser.prototype, {\\r\\n\\r\\n\\t\\tgetFrequencyData: function () {\\r\\n\\r\\n\\t\\t\\tthis.analyser.getByteFrequencyData( this.data );\\r\\n\\r\\n\\t\\t\\treturn this.data;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetAverageFrequency: function () {\\r\\n\\r\\n\\t\\t\\tvar value = 0, data = this.getFrequencyData();\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < data.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvalue += data[ i ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn value / data.length;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t *\\r\\n\\t * Buffered scene graph property that allows weighted accumulation.\\r\\n\\t *\\r\\n\\t *\\r\\n\\t * @author Ben Houston / http://clara.io/\\r\\n\\t * @author David Sarno / http://lighthaus.us/\\r\\n\\t * @author tschw\\r\\n\\t */\\r\\n\\r\\n\\tfunction PropertyMixer( binding, typeName, valueSize ) {\\r\\n\\r\\n\\t\\tthis.binding = binding;\\r\\n\\t\\tthis.valueSize = valueSize;\\r\\n\\r\\n\\t\\tvar bufferType = Float64Array,\\r\\n\\t\\t\\tmixFunction;\\r\\n\\r\\n\\t\\tswitch ( typeName ) {\\r\\n\\r\\n\\t\\t\\tcase 'quaternion':\\r\\n\\t\\t\\t\\tmixFunction = this._slerp;\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'string':\\r\\n\\t\\t\\tcase 'bool':\\r\\n\\t\\t\\t\\tbufferType = Array;\\r\\n\\t\\t\\t\\tmixFunction = this._select;\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tdefault:\\r\\n\\t\\t\\t\\tmixFunction = this._lerp;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.buffer = new bufferType( valueSize * 4 );\\r\\n\\t\\t// layout: [ incoming | accu0 | accu1 | orig ]\\r\\n\\t\\t//\\r\\n\\t\\t// interpolators can use .buffer as their .result\\r\\n\\t\\t// the data then goes to 'incoming'\\r\\n\\t\\t//\\r\\n\\t\\t// 'accu0' and 'accu1' are used frame-interleaved for\\r\\n\\t\\t// the cumulative result and are compared to detect\\r\\n\\t\\t// changes\\r\\n\\t\\t//\\r\\n\\t\\t// 'orig' stores the original state of the property\\r\\n\\r\\n\\t\\tthis._mixBufferRegion = mixFunction;\\r\\n\\r\\n\\t\\tthis.cumulativeWeight = 0;\\r\\n\\r\\n\\t\\tthis.useCount = 0;\\r\\n\\t\\tthis.referenceCount = 0;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( PropertyMixer.prototype, {\\r\\n\\r\\n\\t\\t// accumulate data in the 'incoming' region into 'accu<i>'\\r\\n\\t\\taccumulate: function ( accuIndex, weight ) {\\r\\n\\r\\n\\t\\t\\t// note: happily accumulating nothing when weight = 0, the caller knows\\r\\n\\t\\t\\t// the weight and shouldn't have made the call in the first place\\r\\n\\r\\n\\t\\t\\tvar buffer = this.buffer,\\r\\n\\t\\t\\t\\tstride = this.valueSize,\\r\\n\\t\\t\\t\\toffset = accuIndex * stride + stride,\\r\\n\\r\\n\\t\\t\\t\\tcurrentWeight = this.cumulativeWeight;\\r\\n\\r\\n\\t\\t\\tif ( currentWeight === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t// accuN := incoming * weight\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tbuffer[ offset + i ] = buffer[ i ];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tcurrentWeight = weight;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t// accuN := accuN + incoming * weight\\r\\n\\r\\n\\t\\t\\t\\tcurrentWeight += weight;\\r\\n\\t\\t\\t\\tvar mix = weight / currentWeight;\\r\\n\\t\\t\\t\\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.cumulativeWeight = currentWeight;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// apply the state of 'accu<i>' to the binding when accus differ\\r\\n\\t\\tapply: function ( accuIndex ) {\\r\\n\\r\\n\\t\\t\\tvar stride = this.valueSize,\\r\\n\\t\\t\\t\\tbuffer = this.buffer,\\r\\n\\t\\t\\t\\toffset = accuIndex * stride + stride,\\r\\n\\r\\n\\t\\t\\t\\tweight = this.cumulativeWeight,\\r\\n\\r\\n\\t\\t\\t\\tbinding = this.binding;\\r\\n\\r\\n\\t\\t\\tthis.cumulativeWeight = 0;\\r\\n\\r\\n\\t\\t\\tif ( weight < 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t// accuN := accuN + original * ( 1 - cumulativeWeight )\\r\\n\\r\\n\\t\\t\\t\\tvar originalValueOffset = stride * 3;\\r\\n\\r\\n\\t\\t\\t\\tthis._mixBufferRegion(\\r\\n\\t\\t\\t\\t\\tbuffer, offset, originalValueOffset, 1 - weight, stride );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// value has changed -> update scene graph\\r\\n\\r\\n\\t\\t\\t\\t\\tbinding.setValue( buffer, offset );\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// remember the state of the bound property and copy it to both accus\\r\\n\\t\\tsaveOriginalState: function () {\\r\\n\\r\\n\\t\\t\\tvar binding = this.binding;\\r\\n\\r\\n\\t\\t\\tvar buffer = this.buffer,\\r\\n\\t\\t\\t\\tstride = this.valueSize,\\r\\n\\r\\n\\t\\t\\t\\toriginalValueOffset = stride * 3;\\r\\n\\r\\n\\t\\t\\tbinding.getValue( buffer, originalValueOffset );\\r\\n\\r\\n\\t\\t\\t// accu[0..1] := orig -- initially detect changes against the original\\r\\n\\t\\t\\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.cumulativeWeight = 0;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// apply the state previously taken via 'saveOriginalState' to the binding\\r\\n\\t\\trestoreOriginalState: function () {\\r\\n\\r\\n\\t\\t\\tvar originalValueOffset = this.valueSize * 3;\\r\\n\\t\\t\\tthis.binding.setValue( this.buffer, originalValueOffset );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\r\\n\\t\\t// mix functions\\r\\n\\r\\n\\t\\t_select: function ( buffer, dstOffset, srcOffset, t, stride ) {\\r\\n\\r\\n\\t\\t\\tif ( t >= 0.5 ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t_slerp: function ( buffer, dstOffset, srcOffset, t ) {\\r\\n\\r\\n\\t\\t\\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {\\r\\n\\r\\n\\t\\t\\tvar s = 1 - t;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tvar j = dstOffset + i;\\r\\n\\r\\n\\t\\t\\t\\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t *\\r\\n\\t * A reference to a real property in the scene graph.\\r\\n\\t *\\r\\n\\t *\\r\\n\\t * @author Ben Houston / http://clara.io/\\r\\n\\t * @author David Sarno / http://lighthaus.us/\\r\\n\\t * @author tschw\\r\\n\\t */\\r\\n\\r\\n\\tfunction Composite( targetGroup, path, optionalParsedPath ) {\\r\\n\\r\\n\\t\\tvar parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );\\r\\n\\r\\n\\t\\tthis._targetGroup = targetGroup;\\r\\n\\t\\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( Composite.prototype, {\\r\\n\\r\\n\\t\\tgetValue: function ( array, offset ) {\\r\\n\\r\\n\\t\\t\\tthis.bind(); // bind all binding\\r\\n\\r\\n\\t\\t\\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\\r\\n\\t\\t\\t\\tbinding = this._bindings[ firstValidIndex ];\\r\\n\\r\\n\\t\\t\\t// and only call .getValue on the first\\r\\n\\t\\t\\tif ( binding !== undefined ) binding.getValue( array, offset );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetValue: function ( array, offset ) {\\r\\n\\r\\n\\t\\t\\tvar bindings = this._bindings;\\r\\n\\r\\n\\t\\t\\tfor ( var i = this._targetGroup.nCachedObjects_,\\r\\n\\t\\t\\t\\t\\t  n = bindings.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tbindings[ i ].setValue( array, offset );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tbind: function () {\\r\\n\\r\\n\\t\\t\\tvar bindings = this._bindings;\\r\\n\\r\\n\\t\\t\\tfor ( var i = this._targetGroup.nCachedObjects_,\\r\\n\\t\\t\\t\\t\\t  n = bindings.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tbindings[ i ].bind();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tunbind: function () {\\r\\n\\r\\n\\t\\t\\tvar bindings = this._bindings;\\r\\n\\r\\n\\t\\t\\tfor ( var i = this._targetGroup.nCachedObjects_,\\r\\n\\t\\t\\t\\t\\t  n = bindings.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tbindings[ i ].unbind();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\r\\n\\tfunction PropertyBinding( rootNode, path, parsedPath ) {\\r\\n\\r\\n\\t\\tthis.path = path;\\r\\n\\t\\tthis.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );\\r\\n\\r\\n\\t\\tthis.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;\\r\\n\\r\\n\\t\\tthis.rootNode = rootNode;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( PropertyBinding, {\\r\\n\\r\\n\\t\\tComposite: Composite,\\r\\n\\r\\n\\t\\tcreate: function ( root, path, parsedPath ) {\\r\\n\\r\\n\\t\\t\\tif ( ! ( root && root.isAnimationObjectGroup ) ) {\\r\\n\\r\\n\\t\\t\\t\\treturn new PropertyBinding( root, path, parsedPath );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\treturn new PropertyBinding.Composite( root, path, parsedPath );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t * Replaces spaces with underscores and removes unsupported characters from\\r\\n\\t\\t * node names, to ensure compatibility with parseTrackName().\\r\\n\\t\\t *\\r\\n\\t\\t * @param  {string} name Node name to be sanitized.\\r\\n\\t\\t * @return {string}\\r\\n\\t\\t */\\r\\n\\t\\tsanitizeNodeName: function ( name ) {\\r\\n\\r\\n\\t\\t\\treturn name.replace( /\\\\s/g, '_' ).replace( /[^\\\\w-]/g, '' );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tparseTrackName: function () {\\r\\n\\r\\n\\t\\t\\t// Parent directories, delimited by '/' or ':'. Currently unused, but must\\r\\n\\t\\t\\t// be matched to parse the rest of the track name.\\r\\n\\t\\t\\tvar directoryRe = /((?:[\\\\w-]+[\\\\/:])*)/;\\r\\n\\r\\n\\t\\t\\t// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\\r\\n\\t\\t\\tvar nodeRe = /([\\\\w-\\\\.]+)?/;\\r\\n\\r\\n\\t\\t\\t// Object on target node, and accessor. Name may contain only word\\r\\n\\t\\t\\t// characters. Accessor may contain any character except closing bracket.\\r\\n\\t\\t\\tvar objectRe = /(?:\\\\.([\\\\w-]+)(?:\\\\[(.+)\\\\])?)?/;\\r\\n\\r\\n\\t\\t\\t// Property and accessor. May contain only word characters. Accessor may\\r\\n\\t\\t\\t// contain any non-bracket characters.\\r\\n\\t\\t\\tvar propertyRe = /\\\\.([\\\\w-]+)(?:\\\\[(.+)\\\\])?/;\\r\\n\\r\\n\\t\\t\\tvar trackRe = new RegExp( ''\\r\\n\\t\\t\\t\\t+ '^'\\r\\n\\t\\t\\t\\t+ directoryRe.source\\r\\n\\t\\t\\t\\t+ nodeRe.source\\r\\n\\t\\t\\t\\t+ objectRe.source\\r\\n\\t\\t\\t\\t+ propertyRe.source\\r\\n\\t\\t\\t\\t+ '$'\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\tvar supportedObjectNames = [ 'material', 'materials', 'bones' ];\\r\\n\\r\\n\\t\\t\\treturn function ( trackName ) {\\r\\n\\r\\n\\t\\t\\t\\tvar matches = trackRe.exec( trackName );\\r\\n\\r\\n\\t\\t\\t\\tif ( ! matches ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthrow new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tvar results = {\\r\\n\\t\\t\\t\\t\\t// directoryName: matches[ 1 ], // (tschw) currently unused\\r\\n\\t\\t\\t\\t\\tnodeName: matches[ 2 ],\\r\\n\\t\\t\\t\\t\\tobjectName: matches[ 3 ],\\r\\n\\t\\t\\t\\t\\tobjectIndex: matches[ 4 ],\\r\\n\\t\\t\\t\\t\\tpropertyName: matches[ 5 ], // required\\r\\n\\t\\t\\t\\t\\tpropertyIndex: matches[ 6 ]\\r\\n\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t\\tvar lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );\\r\\n\\r\\n\\t\\t\\t\\tif ( lastDot !== undefined && lastDot !== - 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar objectName = results.nodeName.substring( lastDot + 1 );\\r\\n\\r\\n\\t\\t\\t\\t\\t// Object names must be checked against a whitelist. Otherwise, there\\r\\n\\t\\t\\t\\t\\t// is no way to parse 'foo.bar.baz': 'baz' must be a property, but\\r\\n\\t\\t\\t\\t\\t// 'bar' could be the objectName, or part of a nodeName (which can\\r\\n\\t\\t\\t\\t\\t// include '.' characters).\\r\\n\\t\\t\\t\\t\\tif ( supportedObjectNames.indexOf( objectName ) !== - 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tresults.nodeName = results.nodeName.substring( 0, lastDot );\\r\\n\\t\\t\\t\\t\\t\\tresults.objectName = objectName;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthrow new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn results;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\r\\n\\t\\tfindNode: function ( root, nodeName ) {\\r\\n\\r\\n\\t\\t\\tif ( ! nodeName || nodeName === \\\"\\\" || nodeName === \\\"root\\\" || nodeName === \\\".\\\" || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {\\r\\n\\r\\n\\t\\t\\t\\treturn root;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// search into skeleton bones.\\r\\n\\t\\t\\tif ( root.skeleton ) {\\r\\n\\r\\n\\t\\t\\t\\tvar searchSkeleton = function ( skeleton ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < skeleton.bones.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar bone = skeleton.bones[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( bone.name === nodeName ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\treturn bone;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t\\tvar bone = searchSkeleton( root.skeleton );\\r\\n\\r\\n\\t\\t\\t\\tif ( bone ) {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn bone;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// search into node subtree.\\r\\n\\t\\t\\tif ( root.children ) {\\r\\n\\r\\n\\t\\t\\t\\tvar searchNodeSubtree = function ( children ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < children.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar childNode = children[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\treturn childNode;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar result = searchNodeSubtree( childNode.children );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( result ) return result;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t\\tvar subTreeNode = searchNodeSubtree( root.children );\\r\\n\\r\\n\\t\\t\\t\\tif ( subTreeNode ) {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn subTreeNode;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tObject.assign( PropertyBinding.prototype, { // prototype, continued\\r\\n\\r\\n\\t\\t// these are used to \\\"bind\\\" a nonexistent property\\r\\n\\t\\t_getValue_unavailable: function () {},\\r\\n\\t\\t_setValue_unavailable: function () {},\\r\\n\\r\\n\\t\\tBindingType: {\\r\\n\\t\\t\\tDirect: 0,\\r\\n\\t\\t\\tEntireArray: 1,\\r\\n\\t\\t\\tArrayElement: 2,\\r\\n\\t\\t\\tHasFromToArray: 3\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tVersioning: {\\r\\n\\t\\t\\tNone: 0,\\r\\n\\t\\t\\tNeedsUpdate: 1,\\r\\n\\t\\t\\tMatrixWorldNeedsUpdate: 2\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tGetterByBindingType: [\\r\\n\\r\\n\\t\\t\\tfunction getValue_direct( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\t\\tbuffer[ offset ] = this.node[ this.propertyName ];\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tfunction getValue_array( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\t\\tvar source = this.resolvedProperty;\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tbuffer[ offset ++ ] = source[ i ];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tfunction getValue_arrayElement( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\t\\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tfunction getValue_toArray( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.resolvedProperty.toArray( buffer, offset );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t],\\r\\n\\r\\n\\t\\tSetterByBindingTypeAndVersioning: [\\r\\n\\r\\n\\t\\t\\t[\\r\\n\\t\\t\\t\\t// Direct\\r\\n\\r\\n\\t\\t\\t\\tfunction setValue_direct( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\\r\\n\\r\\n\\t\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t\\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\\r\\n\\t\\t\\t\\t\\tthis.targetObject.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t\\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\\r\\n\\t\\t\\t\\t\\tthis.targetObject.matrixWorldNeedsUpdate = true;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t], [\\r\\n\\r\\n\\t\\t\\t\\t// EntireArray\\r\\n\\r\\n\\t\\t\\t\\tfunction setValue_array( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar dest = this.resolvedProperty;\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tdest[ i ] = buffer[ offset ++ ];\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t\\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar dest = this.resolvedProperty;\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tdest[ i ] = buffer[ offset ++ ];\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.targetObject.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t\\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar dest = this.resolvedProperty;\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tdest[ i ] = buffer[ offset ++ ];\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.targetObject.matrixWorldNeedsUpdate = true;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t], [\\r\\n\\r\\n\\t\\t\\t\\t// ArrayElement\\r\\n\\r\\n\\t\\t\\t\\tfunction setValue_arrayElement( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\\r\\n\\r\\n\\t\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t\\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\\r\\n\\t\\t\\t\\t\\tthis.targetObject.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t\\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\\r\\n\\t\\t\\t\\t\\tthis.targetObject.matrixWorldNeedsUpdate = true;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t], [\\r\\n\\r\\n\\t\\t\\t\\t// HasToFromArray\\r\\n\\r\\n\\t\\t\\t\\tfunction setValue_fromArray( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.resolvedProperty.fromArray( buffer, offset );\\r\\n\\r\\n\\t\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t\\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.resolvedProperty.fromArray( buffer, offset );\\r\\n\\t\\t\\t\\t\\tthis.targetObject.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t\\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.resolvedProperty.fromArray( buffer, offset );\\r\\n\\t\\t\\t\\t\\tthis.targetObject.matrixWorldNeedsUpdate = true;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t]\\r\\n\\r\\n\\t\\t],\\r\\n\\r\\n\\t\\tgetValue: function getValue_unbound( targetArray, offset ) {\\r\\n\\r\\n\\t\\t\\tthis.bind();\\r\\n\\t\\t\\tthis.getValue( targetArray, offset );\\r\\n\\r\\n\\t\\t\\t// Note: This class uses a State pattern on a per-method basis:\\r\\n\\t\\t\\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\\r\\n\\t\\t\\t// prototype version of these methods with one that represents\\r\\n\\t\\t\\t// the bound state. When the property is not found, the methods\\r\\n\\t\\t\\t// become no-ops.\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetValue: function getValue_unbound( sourceArray, offset ) {\\r\\n\\r\\n\\t\\t\\tthis.bind();\\r\\n\\t\\t\\tthis.setValue( sourceArray, offset );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// create getter / setter pair for a property in the scene graph\\r\\n\\t\\tbind: function () {\\r\\n\\r\\n\\t\\t\\tvar targetObject = this.node,\\r\\n\\t\\t\\t\\tparsedPath = this.parsedPath,\\r\\n\\r\\n\\t\\t\\t\\tobjectName = parsedPath.objectName,\\r\\n\\t\\t\\t\\tpropertyName = parsedPath.propertyName,\\r\\n\\t\\t\\t\\tpropertyIndex = parsedPath.propertyIndex;\\r\\n\\r\\n\\t\\t\\tif ( ! targetObject ) {\\r\\n\\r\\n\\t\\t\\t\\ttargetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;\\r\\n\\r\\n\\t\\t\\t\\tthis.node = targetObject;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// set fail state so we can just 'return' on error\\r\\n\\t\\t\\tthis.getValue = this._getValue_unavailable;\\r\\n\\t\\t\\tthis.setValue = this._setValue_unavailable;\\r\\n\\r\\n\\t\\t\\t// ensure there is a value node\\r\\n\\t\\t\\tif ( ! targetObject ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\\\\'t found.' );\\r\\n\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( objectName ) {\\r\\n\\r\\n\\t\\t\\t\\tvar objectIndex = parsedPath.objectIndex;\\r\\n\\r\\n\\t\\t\\t\\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\\r\\n\\t\\t\\t\\tswitch ( objectName ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'materials':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( ! targetObject.material ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\\r\\n\\t\\t\\t\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( ! targetObject.material.materials ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );\\r\\n\\t\\t\\t\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ttargetObject = targetObject.material.materials;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'bones':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( ! targetObject.skeleton ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );\\r\\n\\t\\t\\t\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// potential future optimization: skip this if propertyIndex is already an integer\\r\\n\\t\\t\\t\\t\\t\\t// and convert the integer string to a true integer.\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ttargetObject = targetObject.skeleton.bones;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// support resolving morphTarget names into indices.\\r\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0; i < targetObject.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( targetObject[ i ].name === objectIndex ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tobjectIndex = i;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tdefault:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( targetObject[ objectName ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );\\r\\n\\t\\t\\t\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ttargetObject = targetObject[ objectName ];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\t\\t\\tif ( objectIndex !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( targetObject[ objectIndex ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );\\r\\n\\t\\t\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\ttargetObject = targetObject[ objectIndex ];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// resolve property\\r\\n\\t\\t\\tvar nodeProperty = targetObject[ propertyName ];\\r\\n\\r\\n\\t\\t\\tif ( nodeProperty === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tvar nodeName = parsedPath.nodeName;\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +\\r\\n\\t\\t\\t\\t\\t'.' + propertyName + ' but it wasn\\\\'t found.', targetObject );\\r\\n\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// determine versioning scheme\\r\\n\\t\\t\\tvar versioning = this.Versioning.None;\\r\\n\\r\\n\\t\\t\\tif ( targetObject.needsUpdate !== undefined ) { // material\\r\\n\\r\\n\\t\\t\\t\\tversioning = this.Versioning.NeedsUpdate;\\r\\n\\t\\t\\t\\tthis.targetObject = targetObject;\\r\\n\\r\\n\\t\\t\\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\\r\\n\\r\\n\\t\\t\\t\\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\\r\\n\\t\\t\\t\\tthis.targetObject = targetObject;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// determine how the property gets bound\\r\\n\\t\\t\\tvar bindingType = this.BindingType.Direct;\\r\\n\\r\\n\\t\\t\\tif ( propertyIndex !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t// access a sub element of the property array (only primitives are supported right now)\\r\\n\\r\\n\\t\\t\\t\\tif ( propertyName === \\\"morphTargetInfluences\\\" ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\\r\\n\\r\\n\\t\\t\\t\\t\\t// support resolving morphTarget names into indices.\\r\\n\\t\\t\\t\\t\\tif ( ! targetObject.geometry ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );\\r\\n\\t\\t\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( targetObject.geometry.isBufferGeometry ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( ! targetObject.geometry.morphAttributes ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );\\r\\n\\t\\t\\t\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tpropertyIndex = i;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( ! targetObject.geometry.morphTargets ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this );\\r\\n\\t\\t\\t\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tpropertyIndex = i;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tbindingType = this.BindingType.ArrayElement;\\r\\n\\r\\n\\t\\t\\t\\tthis.resolvedProperty = nodeProperty;\\r\\n\\t\\t\\t\\tthis.propertyIndex = propertyIndex;\\r\\n\\r\\n\\t\\t\\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t// must use copy for Object3D.Euler/Quaternion\\r\\n\\r\\n\\t\\t\\t\\tbindingType = this.BindingType.HasFromToArray;\\r\\n\\r\\n\\t\\t\\t\\tthis.resolvedProperty = nodeProperty;\\r\\n\\r\\n\\t\\t\\t} else if ( Array.isArray( nodeProperty ) ) {\\r\\n\\r\\n\\t\\t\\t\\tbindingType = this.BindingType.EntireArray;\\r\\n\\r\\n\\t\\t\\t\\tthis.resolvedProperty = nodeProperty;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tthis.propertyName = propertyName;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// select getter / setter\\r\\n\\t\\t\\tthis.getValue = this.GetterByBindingType[ bindingType ];\\r\\n\\t\\t\\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tunbind: function () {\\r\\n\\r\\n\\t\\t\\tthis.node = null;\\r\\n\\r\\n\\t\\t\\t// back to the prototype version of getValue / setValue\\r\\n\\t\\t\\t// note: avoiding to mutate the shape of 'this' via 'delete'\\r\\n\\t\\t\\tthis.getValue = this._getValue_unbound;\\r\\n\\t\\t\\tthis.setValue = this._setValue_unbound;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t//!\\\\ DECLARE ALIAS AFTER assign prototype !\\r\\n\\tObject.assign( PropertyBinding.prototype, {\\r\\n\\r\\n\\t\\t// initial state of these methods that calls 'bind'\\r\\n\\t\\t_getValue_unbound: PropertyBinding.prototype.getValue,\\r\\n\\t\\t_setValue_unbound: PropertyBinding.prototype.setValue,\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t *\\r\\n\\t * A group of objects that receives a shared animation state.\\r\\n\\t *\\r\\n\\t * Usage:\\r\\n\\t *\\r\\n\\t * \\t-\\tAdd objects you would otherwise pass as 'root' to the\\r\\n\\t * \\t\\tconstructor or the .clipAction method of AnimationMixer.\\r\\n\\t *\\r\\n\\t * \\t-\\tInstead pass this object as 'root'.\\r\\n\\t *\\r\\n\\t * \\t-\\tYou can also add and remove objects later when the mixer\\r\\n\\t * \\t\\tis running.\\r\\n\\t *\\r\\n\\t * Note:\\r\\n\\t *\\r\\n\\t *  \\tObjects of this class appear as one object to the mixer,\\r\\n\\t *  \\tso cache control of the individual objects must be done\\r\\n\\t *  \\ton the group.\\r\\n\\t *\\r\\n\\t * Limitation:\\r\\n\\t *\\r\\n\\t * \\t- \\tThe animated properties must be compatible among the\\r\\n\\t * \\t\\tall objects in the group.\\r\\n\\t *\\r\\n\\t *  -\\tA single property can either be controlled through a\\r\\n\\t *  \\ttarget group or directly, but not both.\\r\\n\\t *\\r\\n\\t * @author tschw\\r\\n\\t */\\r\\n\\r\\n\\tfunction AnimationObjectGroup() {\\r\\n\\r\\n\\t\\tthis.uuid = _Math.generateUUID();\\r\\n\\r\\n\\t\\t// cached objects followed by the active ones\\r\\n\\t\\tthis._objects = Array.prototype.slice.call( arguments );\\r\\n\\r\\n\\t\\tthis.nCachedObjects_ = 0;\\t\\t\\t// threshold\\r\\n\\t\\t// note: read by PropertyBinding.Composite\\r\\n\\r\\n\\t\\tvar indices = {};\\r\\n\\t\\tthis._indicesByUUID = indices;\\t\\t// for bookkeeping\\r\\n\\r\\n\\t\\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\tindices[ arguments[ i ].uuid ] = i;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis._paths = [];\\t\\t\\t\\t\\t// inside: string\\r\\n\\t\\tthis._parsedPaths = [];\\t\\t\\t\\t// inside: { we don't care, here }\\r\\n\\t\\tthis._bindings = []; \\t\\t\\t\\t// inside: Array< PropertyBinding >\\r\\n\\t\\tthis._bindingsIndicesByPath = {}; \\t// inside: indices in these arrays\\r\\n\\r\\n\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\tthis.stats = {\\r\\n\\r\\n\\t\\t\\tobjects: {\\r\\n\\t\\t\\t\\tget total() {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn scope._objects.length;\\r\\n\\r\\n\\t\\t\\t\\t},\\r\\n\\t\\t\\t\\tget inUse() {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn this.total - scope.nCachedObjects_;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tget bindingsPerObject() {\\r\\n\\r\\n\\t\\t\\t\\treturn scope._bindings.length;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( AnimationObjectGroup.prototype, {\\r\\n\\r\\n\\t\\tisAnimationObjectGroup: true,\\r\\n\\r\\n\\t\\tadd: function () {\\r\\n\\r\\n\\t\\t\\tvar objects = this._objects,\\r\\n\\t\\t\\t\\tnObjects = objects.length,\\r\\n\\t\\t\\t\\tnCachedObjects = this.nCachedObjects_,\\r\\n\\t\\t\\t\\tindicesByUUID = this._indicesByUUID,\\r\\n\\t\\t\\t\\tpaths = this._paths,\\r\\n\\t\\t\\t\\tparsedPaths = this._parsedPaths,\\r\\n\\t\\t\\t\\tbindings = this._bindings,\\r\\n\\t\\t\\t\\tnBindings = bindings.length;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tvar object = arguments[ i ],\\r\\n\\t\\t\\t\\t\\tuuid = object.uuid,\\r\\n\\t\\t\\t\\t\\tindex = indicesByUUID[ uuid ],\\r\\n\\t\\t\\t\\t\\tknownObject = undefined;\\r\\n\\r\\n\\t\\t\\t\\tif ( index === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// unknown object -> add it to the ACTIVE region\\r\\n\\r\\n\\t\\t\\t\\t\\tindex = nObjects ++;\\r\\n\\t\\t\\t\\t\\tindicesByUUID[ uuid ] = index;\\r\\n\\t\\t\\t\\t\\tobjects.push( object );\\r\\n\\r\\n\\t\\t\\t\\t\\t// accounting is done, now do the same for all bindings\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else if ( index < nCachedObjects ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tknownObject = objects[ index ];\\r\\n\\r\\n\\t\\t\\t\\t\\t// move existing object to the ACTIVE region\\r\\n\\r\\n\\t\\t\\t\\t\\tvar firstActiveIndex = -- nCachedObjects,\\r\\n\\t\\t\\t\\t\\t\\tlastCachedObject = objects[ firstActiveIndex ];\\r\\n\\r\\n\\t\\t\\t\\t\\tindicesByUUID[ lastCachedObject.uuid ] = index;\\r\\n\\t\\t\\t\\t\\tobjects[ index ] = lastCachedObject;\\r\\n\\r\\n\\t\\t\\t\\t\\tindicesByUUID[ uuid ] = firstActiveIndex;\\r\\n\\t\\t\\t\\t\\tobjects[ firstActiveIndex ] = object;\\r\\n\\r\\n\\t\\t\\t\\t\\t// accounting is done, now do the same for all bindings\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar bindingsForPath = bindings[ j ],\\r\\n\\t\\t\\t\\t\\t\\t\\tlastCached = bindingsForPath[ firstActiveIndex ],\\r\\n\\t\\t\\t\\t\\t\\t\\tbinding = bindingsForPath[ index ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbindingsForPath[ index ] = lastCached;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( binding === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t// since we do not bother to create new bindings\\r\\n\\t\\t\\t\\t\\t\\t\\t// for objects that are cached, the binding may\\r\\n\\t\\t\\t\\t\\t\\t\\t// or may not exist\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tbinding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbindingsForPath[ firstActiveIndex ] = binding;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else if ( objects[ index ] !== knownObject ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +\\r\\n\\t\\t\\t\\t\\t\\t\\t'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );\\r\\n\\r\\n\\t\\t\\t\\t} // else the object is already where we want it to be\\r\\n\\r\\n\\t\\t\\t} // for arguments\\r\\n\\r\\n\\t\\t\\tthis.nCachedObjects_ = nCachedObjects;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tremove: function () {\\r\\n\\r\\n\\t\\t\\tvar objects = this._objects,\\r\\n\\t\\t\\t\\tnCachedObjects = this.nCachedObjects_,\\r\\n\\t\\t\\t\\tindicesByUUID = this._indicesByUUID,\\r\\n\\t\\t\\t\\tbindings = this._bindings,\\r\\n\\t\\t\\t\\tnBindings = bindings.length;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tvar object = arguments[ i ],\\r\\n\\t\\t\\t\\t\\tuuid = object.uuid,\\r\\n\\t\\t\\t\\t\\tindex = indicesByUUID[ uuid ];\\r\\n\\r\\n\\t\\t\\t\\tif ( index !== undefined && index >= nCachedObjects ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// move existing object into the CACHED region\\r\\n\\r\\n\\t\\t\\t\\t\\tvar lastCachedIndex = nCachedObjects ++,\\r\\n\\t\\t\\t\\t\\t\\tfirstActiveObject = objects[ lastCachedIndex ];\\r\\n\\r\\n\\t\\t\\t\\t\\tindicesByUUID[ firstActiveObject.uuid ] = index;\\r\\n\\t\\t\\t\\t\\tobjects[ index ] = firstActiveObject;\\r\\n\\r\\n\\t\\t\\t\\t\\tindicesByUUID[ uuid ] = lastCachedIndex;\\r\\n\\t\\t\\t\\t\\tobjects[ lastCachedIndex ] = object;\\r\\n\\r\\n\\t\\t\\t\\t\\t// accounting is done, now do the same for all bindings\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar bindingsForPath = bindings[ j ],\\r\\n\\t\\t\\t\\t\\t\\t\\tfirstActive = bindingsForPath[ lastCachedIndex ],\\r\\n\\t\\t\\t\\t\\t\\t\\tbinding = bindingsForPath[ index ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbindingsForPath[ index ] = firstActive;\\r\\n\\t\\t\\t\\t\\t\\tbindingsForPath[ lastCachedIndex ] = binding;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} // for arguments\\r\\n\\r\\n\\t\\t\\tthis.nCachedObjects_ = nCachedObjects;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// remove & forget\\r\\n\\t\\tuncache: function () {\\r\\n\\r\\n\\t\\t\\tvar objects = this._objects,\\r\\n\\t\\t\\t\\tnObjects = objects.length,\\r\\n\\t\\t\\t\\tnCachedObjects = this.nCachedObjects_,\\r\\n\\t\\t\\t\\tindicesByUUID = this._indicesByUUID,\\r\\n\\t\\t\\t\\tbindings = this._bindings,\\r\\n\\t\\t\\t\\tnBindings = bindings.length;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tvar object = arguments[ i ],\\r\\n\\t\\t\\t\\t\\tuuid = object.uuid,\\r\\n\\t\\t\\t\\t\\tindex = indicesByUUID[ uuid ];\\r\\n\\r\\n\\t\\t\\t\\tif ( index !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tdelete indicesByUUID[ uuid ];\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( index < nCachedObjects ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// object is cached, shrink the CACHED region\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar firstActiveIndex = -- nCachedObjects,\\r\\n\\t\\t\\t\\t\\t\\t\\tlastCachedObject = objects[ firstActiveIndex ],\\r\\n\\t\\t\\t\\t\\t\\t\\tlastIndex = -- nObjects,\\r\\n\\t\\t\\t\\t\\t\\t\\tlastObject = objects[ lastIndex ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// last cached object takes this object's place\\r\\n\\t\\t\\t\\t\\t\\tindicesByUUID[ lastCachedObject.uuid ] = index;\\r\\n\\t\\t\\t\\t\\t\\tobjects[ index ] = lastCachedObject;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// last object goes to the activated slot and pop\\r\\n\\t\\t\\t\\t\\t\\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\\r\\n\\t\\t\\t\\t\\t\\tobjects[ firstActiveIndex ] = lastObject;\\r\\n\\t\\t\\t\\t\\t\\tobjects.pop();\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// accounting is done, now do the same for all bindings\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar bindingsForPath = bindings[ j ],\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tlastCached = bindingsForPath[ firstActiveIndex ],\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tlast = bindingsForPath[ lastIndex ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tbindingsForPath[ index ] = lastCached;\\r\\n\\t\\t\\t\\t\\t\\t\\tbindingsForPath[ firstActiveIndex ] = last;\\r\\n\\t\\t\\t\\t\\t\\t\\tbindingsForPath.pop();\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// object is active, just swap with the last and pop\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar lastIndex = -- nObjects,\\r\\n\\t\\t\\t\\t\\t\\t\\tlastObject = objects[ lastIndex ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tindicesByUUID[ lastObject.uuid ] = index;\\r\\n\\t\\t\\t\\t\\t\\tobjects[ index ] = lastObject;\\r\\n\\t\\t\\t\\t\\t\\tobjects.pop();\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// accounting is done, now do the same for all bindings\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar bindingsForPath = bindings[ j ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\\r\\n\\t\\t\\t\\t\\t\\t\\tbindingsForPath.pop();\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t} // cached or active\\r\\n\\r\\n\\t\\t\\t\\t} // if object is known\\r\\n\\r\\n\\t\\t\\t} // for arguments\\r\\n\\r\\n\\t\\t\\tthis.nCachedObjects_ = nCachedObjects;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// Internal interface used by befriended PropertyBinding.Composite:\\r\\n\\r\\n\\t\\tsubscribe_: function ( path, parsedPath ) {\\r\\n\\r\\n\\t\\t\\t// returns an array of bindings for the given path that is changed\\r\\n\\t\\t\\t// according to the contained objects in the group\\r\\n\\r\\n\\t\\t\\tvar indicesByPath = this._bindingsIndicesByPath,\\r\\n\\t\\t\\t\\tindex = indicesByPath[ path ],\\r\\n\\t\\t\\t\\tbindings = this._bindings;\\r\\n\\r\\n\\t\\t\\tif ( index !== undefined ) return bindings[ index ];\\r\\n\\r\\n\\t\\t\\tvar paths = this._paths,\\r\\n\\t\\t\\t\\tparsedPaths = this._parsedPaths,\\r\\n\\t\\t\\t\\tobjects = this._objects,\\r\\n\\t\\t\\t\\tnObjects = objects.length,\\r\\n\\t\\t\\t\\tnCachedObjects = this.nCachedObjects_,\\r\\n\\t\\t\\t\\tbindingsForPath = new Array( nObjects );\\r\\n\\r\\n\\t\\t\\tindex = bindings.length;\\r\\n\\r\\n\\t\\t\\tindicesByPath[ path ] = index;\\r\\n\\r\\n\\t\\t\\tpaths.push( path );\\r\\n\\t\\t\\tparsedPaths.push( parsedPath );\\r\\n\\t\\t\\tbindings.push( bindingsForPath );\\r\\n\\r\\n\\t\\t\\tfor ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tvar object = objects[ i ];\\r\\n\\t\\t\\t\\tbindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn bindingsForPath;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tunsubscribe_: function ( path ) {\\r\\n\\r\\n\\t\\t\\t// tells the group to forget about a property path and no longer\\r\\n\\t\\t\\t// update the array previously obtained with 'subscribe_'\\r\\n\\r\\n\\t\\t\\tvar indicesByPath = this._bindingsIndicesByPath,\\r\\n\\t\\t\\t\\tindex = indicesByPath[ path ];\\r\\n\\r\\n\\t\\t\\tif ( index !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tvar paths = this._paths,\\r\\n\\t\\t\\t\\t\\tparsedPaths = this._parsedPaths,\\r\\n\\t\\t\\t\\t\\tbindings = this._bindings,\\r\\n\\t\\t\\t\\t\\tlastBindingsIndex = bindings.length - 1,\\r\\n\\t\\t\\t\\t\\tlastBindings = bindings[ lastBindingsIndex ],\\r\\n\\t\\t\\t\\t\\tlastBindingsPath = path[ lastBindingsIndex ];\\r\\n\\r\\n\\t\\t\\t\\tindicesByPath[ lastBindingsPath ] = index;\\r\\n\\r\\n\\t\\t\\t\\tbindings[ index ] = lastBindings;\\r\\n\\t\\t\\t\\tbindings.pop();\\r\\n\\r\\n\\t\\t\\t\\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\\r\\n\\t\\t\\t\\tparsedPaths.pop();\\r\\n\\r\\n\\t\\t\\t\\tpaths[ index ] = paths[ lastBindingsIndex ];\\r\\n\\t\\t\\t\\tpaths.pop();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t *\\r\\n\\t * Action provided by AnimationMixer for scheduling clip playback on specific\\r\\n\\t * objects.\\r\\n\\t *\\r\\n\\t * @author Ben Houston / http://clara.io/\\r\\n\\t * @author David Sarno / http://lighthaus.us/\\r\\n\\t * @author tschw\\r\\n\\t *\\r\\n\\t */\\r\\n\\r\\n\\tfunction AnimationAction( mixer, clip, localRoot ) {\\r\\n\\r\\n\\t\\tthis._mixer = mixer;\\r\\n\\t\\tthis._clip = clip;\\r\\n\\t\\tthis._localRoot = localRoot || null;\\r\\n\\r\\n\\t\\tvar tracks = clip.tracks,\\r\\n\\t\\t\\tnTracks = tracks.length,\\r\\n\\t\\t\\tinterpolants = new Array( nTracks );\\r\\n\\r\\n\\t\\tvar interpolantSettings = {\\r\\n\\t\\t\\tendingStart: ZeroCurvatureEnding,\\r\\n\\t\\t\\tendingEnd: ZeroCurvatureEnding\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tfor ( var i = 0; i !== nTracks; ++ i ) {\\r\\n\\r\\n\\t\\t\\tvar interpolant = tracks[ i ].createInterpolant( null );\\r\\n\\t\\t\\tinterpolants[ i ] = interpolant;\\r\\n\\t\\t\\tinterpolant.settings = interpolantSettings;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis._interpolantSettings = interpolantSettings;\\r\\n\\r\\n\\t\\tthis._interpolants = interpolants;\\t// bound by the mixer\\r\\n\\r\\n\\t\\t// inside: PropertyMixer (managed by the mixer)\\r\\n\\t\\tthis._propertyBindings = new Array( nTracks );\\r\\n\\r\\n\\t\\tthis._cacheIndex = null;\\t\\t\\t// for the memory manager\\r\\n\\t\\tthis._byClipCacheIndex = null;\\t\\t// for the memory manager\\r\\n\\r\\n\\t\\tthis._timeScaleInterpolant = null;\\r\\n\\t\\tthis._weightInterpolant = null;\\r\\n\\r\\n\\t\\tthis.loop = LoopRepeat;\\r\\n\\t\\tthis._loopCount = - 1;\\r\\n\\r\\n\\t\\t// global mixer time when the action is to be started\\r\\n\\t\\t// it's set back to 'null' upon start of the action\\r\\n\\t\\tthis._startTime = null;\\r\\n\\r\\n\\t\\t// scaled local time of the action\\r\\n\\t\\t// gets clamped or wrapped to 0..clip.duration according to loop\\r\\n\\t\\tthis.time = 0;\\r\\n\\r\\n\\t\\tthis.timeScale = 1;\\r\\n\\t\\tthis._effectiveTimeScale = 1;\\r\\n\\r\\n\\t\\tthis.weight = 1;\\r\\n\\t\\tthis._effectiveWeight = 1;\\r\\n\\r\\n\\t\\tthis.repetitions = Infinity; \\t\\t// no. of repetitions when looping\\r\\n\\r\\n\\t\\tthis.paused = false;\\t\\t\\t\\t// true -> zero effective time scale\\r\\n\\t\\tthis.enabled = true;\\t\\t\\t\\t// false -> zero effective weight\\r\\n\\r\\n\\t\\tthis.clampWhenFinished \\t= false;\\t// keep feeding the last frame?\\r\\n\\r\\n\\t\\tthis.zeroSlopeAtStart \\t= true;\\t\\t// for smooth interpolation w/o separate\\r\\n\\t\\tthis.zeroSlopeAtEnd\\t\\t= true;\\t\\t// clips for start, loop and end\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( AnimationAction.prototype, {\\r\\n\\r\\n\\t\\t// State & Scheduling\\r\\n\\r\\n\\t\\tplay: function () {\\r\\n\\r\\n\\t\\t\\tthis._mixer._activateAction( this );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tstop: function () {\\r\\n\\r\\n\\t\\t\\tthis._mixer._deactivateAction( this );\\r\\n\\r\\n\\t\\t\\treturn this.reset();\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\treset: function () {\\r\\n\\r\\n\\t\\t\\tthis.paused = false;\\r\\n\\t\\t\\tthis.enabled = true;\\r\\n\\r\\n\\t\\t\\tthis.time = 0;\\t\\t\\t// restart clip\\r\\n\\t\\t\\tthis._loopCount = - 1;\\t// forget previous loops\\r\\n\\t\\t\\tthis._startTime = null;\\t// forget scheduling\\r\\n\\r\\n\\t\\t\\treturn this.stopFading().stopWarping();\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tisRunning: function () {\\r\\n\\r\\n\\t\\t\\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\\r\\n\\t\\t\\t\\t\\tthis._startTime === null && this._mixer._isActiveAction( this );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// return true when play has been called\\r\\n\\t\\tisScheduled: function () {\\r\\n\\r\\n\\t\\t\\treturn this._mixer._isActiveAction( this );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tstartAt: function ( time ) {\\r\\n\\r\\n\\t\\t\\tthis._startTime = time;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetLoop: function ( mode, repetitions ) {\\r\\n\\r\\n\\t\\t\\tthis.loop = mode;\\r\\n\\t\\t\\tthis.repetitions = repetitions;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// Weight\\r\\n\\r\\n\\t\\t// set the weight stopping any scheduled fading\\r\\n\\t\\t// although .enabled = false yields an effective weight of zero, this\\r\\n\\t\\t// method does *not* change .enabled, because it would be confusing\\r\\n\\t\\tsetEffectiveWeight: function ( weight ) {\\r\\n\\r\\n\\t\\t\\tthis.weight = weight;\\r\\n\\r\\n\\t\\t\\t// note: same logic as when updated at runtime\\r\\n\\t\\t\\tthis._effectiveWeight = this.enabled ? weight : 0;\\r\\n\\r\\n\\t\\t\\treturn this.stopFading();\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// return the weight considering fading and .enabled\\r\\n\\t\\tgetEffectiveWeight: function () {\\r\\n\\r\\n\\t\\t\\treturn this._effectiveWeight;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tfadeIn: function ( duration ) {\\r\\n\\r\\n\\t\\t\\treturn this._scheduleFading( duration, 0, 1 );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tfadeOut: function ( duration ) {\\r\\n\\r\\n\\t\\t\\treturn this._scheduleFading( duration, 1, 0 );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcrossFadeFrom: function ( fadeOutAction, duration, warp ) {\\r\\n\\r\\n\\t\\t\\tfadeOutAction.fadeOut( duration );\\r\\n\\t\\t\\tthis.fadeIn( duration );\\r\\n\\r\\n\\t\\t\\tif ( warp ) {\\r\\n\\r\\n\\t\\t\\t\\tvar fadeInDuration = this._clip.duration,\\r\\n\\t\\t\\t\\t\\tfadeOutDuration = fadeOutAction._clip.duration,\\r\\n\\r\\n\\t\\t\\t\\t\\tstartEndRatio = fadeOutDuration / fadeInDuration,\\r\\n\\t\\t\\t\\t\\tendStartRatio = fadeInDuration / fadeOutDuration;\\r\\n\\r\\n\\t\\t\\t\\tfadeOutAction.warp( 1.0, startEndRatio, duration );\\r\\n\\t\\t\\t\\tthis.warp( endStartRatio, 1.0, duration );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcrossFadeTo: function ( fadeInAction, duration, warp ) {\\r\\n\\r\\n\\t\\t\\treturn fadeInAction.crossFadeFrom( this, duration, warp );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tstopFading: function () {\\r\\n\\r\\n\\t\\t\\tvar weightInterpolant = this._weightInterpolant;\\r\\n\\r\\n\\t\\t\\tif ( weightInterpolant !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._weightInterpolant = null;\\r\\n\\t\\t\\t\\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// Time Scale Control\\r\\n\\r\\n\\t\\t// set the time scale stopping any scheduled warping\\r\\n\\t\\t// although .paused = true yields an effective time scale of zero, this\\r\\n\\t\\t// method does *not* change .paused, because it would be confusing\\r\\n\\t\\tsetEffectiveTimeScale: function ( timeScale ) {\\r\\n\\r\\n\\t\\t\\tthis.timeScale = timeScale;\\r\\n\\t\\t\\tthis._effectiveTimeScale = this.paused ? 0 : timeScale;\\r\\n\\r\\n\\t\\t\\treturn this.stopWarping();\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// return the time scale considering warping and .paused\\r\\n\\t\\tgetEffectiveTimeScale: function () {\\r\\n\\r\\n\\t\\t\\treturn this._effectiveTimeScale;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetDuration: function ( duration ) {\\r\\n\\r\\n\\t\\t\\tthis.timeScale = this._clip.duration / duration;\\r\\n\\r\\n\\t\\t\\treturn this.stopWarping();\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsyncWith: function ( action ) {\\r\\n\\r\\n\\t\\t\\tthis.time = action.time;\\r\\n\\t\\t\\tthis.timeScale = action.timeScale;\\r\\n\\r\\n\\t\\t\\treturn this.stopWarping();\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\thalt: function ( duration ) {\\r\\n\\r\\n\\t\\t\\treturn this.warp( this._effectiveTimeScale, 0, duration );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\twarp: function ( startTimeScale, endTimeScale, duration ) {\\r\\n\\r\\n\\t\\t\\tvar mixer = this._mixer, now = mixer.time,\\r\\n\\t\\t\\t\\tinterpolant = this._timeScaleInterpolant,\\r\\n\\r\\n\\t\\t\\t\\ttimeScale = this.timeScale;\\r\\n\\r\\n\\t\\t\\tif ( interpolant === null ) {\\r\\n\\r\\n\\t\\t\\t\\tinterpolant = mixer._lendControlInterpolant();\\r\\n\\t\\t\\t\\tthis._timeScaleInterpolant = interpolant;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar times = interpolant.parameterPositions,\\r\\n\\t\\t\\t\\tvalues = interpolant.sampleValues;\\r\\n\\r\\n\\t\\t\\ttimes[ 0 ] = now;\\r\\n\\t\\t\\ttimes[ 1 ] = now + duration;\\r\\n\\r\\n\\t\\t\\tvalues[ 0 ] = startTimeScale / timeScale;\\r\\n\\t\\t\\tvalues[ 1 ] = endTimeScale / timeScale;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tstopWarping: function () {\\r\\n\\r\\n\\t\\t\\tvar timeScaleInterpolant = this._timeScaleInterpolant;\\r\\n\\r\\n\\t\\t\\tif ( timeScaleInterpolant !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._timeScaleInterpolant = null;\\r\\n\\t\\t\\t\\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// Object Accessors\\r\\n\\r\\n\\t\\tgetMixer: function () {\\r\\n\\r\\n\\t\\t\\treturn this._mixer;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetClip: function () {\\r\\n\\r\\n\\t\\t\\treturn this._clip;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetRoot: function () {\\r\\n\\r\\n\\t\\t\\treturn this._localRoot || this._mixer._root;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// Interna\\r\\n\\r\\n\\t\\t_update: function ( time, deltaTime, timeDirection, accuIndex ) {\\r\\n\\r\\n\\t\\t\\t// called by the mixer\\r\\n\\r\\n\\t\\t\\tif ( ! this.enabled ) {\\r\\n\\r\\n\\t\\t\\t\\t// call ._updateWeight() to update ._effectiveWeight\\r\\n\\r\\n\\t\\t\\t\\tthis._updateWeight( time );\\r\\n\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar startTime = this._startTime;\\r\\n\\r\\n\\t\\t\\tif ( startTime !== null ) {\\r\\n\\r\\n\\t\\t\\t\\t// check for scheduled start of action\\r\\n\\r\\n\\t\\t\\t\\tvar timeRunning = ( time - startTime ) * timeDirection;\\r\\n\\t\\t\\t\\tif ( timeRunning < 0 || timeDirection === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn; // yet to come / don't decide when delta = 0\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// start\\r\\n\\r\\n\\t\\t\\t\\tthis._startTime = null; // unschedule\\r\\n\\t\\t\\t\\tdeltaTime = timeDirection * timeRunning;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// apply time scale and advance time\\r\\n\\r\\n\\t\\t\\tdeltaTime *= this._updateTimeScale( time );\\r\\n\\t\\t\\tvar clipTime = this._updateTime( deltaTime );\\r\\n\\r\\n\\t\\t\\t// note: _updateTime may disable the action resulting in\\r\\n\\t\\t\\t// an effective weight of 0\\r\\n\\r\\n\\t\\t\\tvar weight = this._updateWeight( time );\\r\\n\\r\\n\\t\\t\\tif ( weight > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tvar interpolants = this._interpolants;\\r\\n\\t\\t\\t\\tvar propertyMixers = this._propertyBindings;\\r\\n\\r\\n\\t\\t\\t\\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tinterpolants[ j ].evaluate( clipTime );\\r\\n\\t\\t\\t\\t\\tpropertyMixers[ j ].accumulate( accuIndex, weight );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t_updateWeight: function ( time ) {\\r\\n\\r\\n\\t\\t\\tvar weight = 0;\\r\\n\\r\\n\\t\\t\\tif ( this.enabled ) {\\r\\n\\r\\n\\t\\t\\t\\tweight = this.weight;\\r\\n\\t\\t\\t\\tvar interpolant = this._weightInterpolant;\\r\\n\\r\\n\\t\\t\\t\\tif ( interpolant !== null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\\r\\n\\r\\n\\t\\t\\t\\t\\tweight *= interpolantValue;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( time > interpolant.parameterPositions[ 1 ] ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tthis.stopFading();\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( interpolantValue === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t// faded out, disable\\r\\n\\t\\t\\t\\t\\t\\t\\tthis.enabled = false;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis._effectiveWeight = weight;\\r\\n\\t\\t\\treturn weight;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t_updateTimeScale: function ( time ) {\\r\\n\\r\\n\\t\\t\\tvar timeScale = 0;\\r\\n\\r\\n\\t\\t\\tif ( ! this.paused ) {\\r\\n\\r\\n\\t\\t\\t\\ttimeScale = this.timeScale;\\r\\n\\r\\n\\t\\t\\t\\tvar interpolant = this._timeScaleInterpolant;\\r\\n\\r\\n\\t\\t\\t\\tif ( interpolant !== null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\\r\\n\\r\\n\\t\\t\\t\\t\\ttimeScale *= interpolantValue;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( time > interpolant.parameterPositions[ 1 ] ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tthis.stopWarping();\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( timeScale === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t// motion has halted, pause\\r\\n\\t\\t\\t\\t\\t\\t\\tthis.paused = true;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t// warp done - apply final time scale\\r\\n\\t\\t\\t\\t\\t\\t\\tthis.timeScale = timeScale;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis._effectiveTimeScale = timeScale;\\r\\n\\t\\t\\treturn timeScale;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t_updateTime: function ( deltaTime ) {\\r\\n\\r\\n\\t\\t\\tvar time = this.time + deltaTime;\\r\\n\\r\\n\\t\\t\\tif ( deltaTime === 0 ) return time;\\r\\n\\r\\n\\t\\t\\tvar duration = this._clip.duration,\\r\\n\\r\\n\\t\\t\\t\\tloop = this.loop,\\r\\n\\t\\t\\t\\tloopCount = this._loopCount;\\r\\n\\r\\n\\t\\t\\tif ( loop === LoopOnce ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( loopCount === - 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// just started\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._loopCount = 0;\\r\\n\\t\\t\\t\\t\\tthis._setEndings( true, true, false );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\thandle_stop: {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( time >= duration ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ttime = duration;\\r\\n\\r\\n\\t\\t\\t\\t\\t} else if ( time < 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ttime = 0;\\r\\n\\r\\n\\t\\t\\t\\t\\t} else break handle_stop;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( this.clampWhenFinished ) this.paused = true;\\r\\n\\t\\t\\t\\t\\telse this.enabled = false;\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._mixer.dispatchEvent( {\\r\\n\\t\\t\\t\\t\\t\\ttype: 'finished', action: this,\\r\\n\\t\\t\\t\\t\\t\\tdirection: deltaTime < 0 ? - 1 : 1\\r\\n\\t\\t\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else { // repetitive Repeat or PingPong\\r\\n\\r\\n\\t\\t\\t\\tvar pingPong = ( loop === LoopPingPong );\\r\\n\\r\\n\\t\\t\\t\\tif ( loopCount === - 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// just started\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( deltaTime >= 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tloopCount = 0;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tthis._setEndings( true, this.repetitions === 0, pingPong );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// when looping in reverse direction, the initial\\r\\n\\t\\t\\t\\t\\t\\t// transition through zero counts as a repetition,\\r\\n\\t\\t\\t\\t\\t\\t// so leave loopCount at -1\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tthis._setEndings( this.repetitions === 0, true, pingPong );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( time >= duration || time < 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// wrap around\\r\\n\\r\\n\\t\\t\\t\\t\\tvar loopDelta = Math.floor( time / duration ); // signed\\r\\n\\t\\t\\t\\t\\ttime -= duration * loopDelta;\\r\\n\\r\\n\\t\\t\\t\\t\\tloopCount += Math.abs( loopDelta );\\r\\n\\r\\n\\t\\t\\t\\t\\tvar pending = this.repetitions - loopCount;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( pending < 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// have to stop (switch state, clamp time, fire event)\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( this.clampWhenFinished ) this.paused = true;\\r\\n\\t\\t\\t\\t\\t\\telse this.enabled = false;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ttime = deltaTime > 0 ? duration : 0;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tthis._mixer.dispatchEvent( {\\r\\n\\t\\t\\t\\t\\t\\t\\ttype: 'finished', action: this,\\r\\n\\t\\t\\t\\t\\t\\t\\tdirection: deltaTime > 0 ? 1 : - 1\\r\\n\\t\\t\\t\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// keep running\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( pending === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t// entering the last round\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar atStart = deltaTime < 0;\\r\\n\\t\\t\\t\\t\\t\\t\\tthis._setEndings( atStart, ! atStart, pingPong );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tthis._setEndings( false, false, pingPong );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tthis._loopCount = loopCount;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tthis._mixer.dispatchEvent( {\\r\\n\\t\\t\\t\\t\\t\\t\\ttype: 'loop', action: this, loopDelta: loopDelta\\r\\n\\t\\t\\t\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// invert time for the \\\"pong round\\\"\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.time = time;\\r\\n\\t\\t\\t\\t\\treturn duration - time;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.time = time;\\r\\n\\t\\t\\treturn time;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t_setEndings: function ( atStart, atEnd, pingPong ) {\\r\\n\\r\\n\\t\\t\\tvar settings = this._interpolantSettings;\\r\\n\\r\\n\\t\\t\\tif ( pingPong ) {\\r\\n\\r\\n\\t\\t\\t\\tsettings.endingStart \\t= ZeroSlopeEnding;\\r\\n\\t\\t\\t\\tsettings.endingEnd\\t\\t= ZeroSlopeEnding;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t// assuming for LoopOnce atStart == atEnd == true\\r\\n\\r\\n\\t\\t\\t\\tif ( atStart ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tsettings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tsettings.endingStart = WrapAroundEnding;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( atEnd ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tsettings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tsettings.endingEnd \\t = WrapAroundEnding;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t_scheduleFading: function ( duration, weightNow, weightThen ) {\\r\\n\\r\\n\\t\\t\\tvar mixer = this._mixer, now = mixer.time,\\r\\n\\t\\t\\t\\tinterpolant = this._weightInterpolant;\\r\\n\\r\\n\\t\\t\\tif ( interpolant === null ) {\\r\\n\\r\\n\\t\\t\\t\\tinterpolant = mixer._lendControlInterpolant();\\r\\n\\t\\t\\t\\tthis._weightInterpolant = interpolant;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar times = interpolant.parameterPositions,\\r\\n\\t\\t\\t\\tvalues = interpolant.sampleValues;\\r\\n\\r\\n\\t\\t\\ttimes[ 0 ] = now; \\t\\t\\t\\tvalues[ 0 ] = weightNow;\\r\\n\\t\\t\\ttimes[ 1 ] = now + duration;\\tvalues[ 1 ] = weightThen;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t *\\r\\n\\t * Player for AnimationClips.\\r\\n\\t *\\r\\n\\t *\\r\\n\\t * @author Ben Houston / http://clara.io/\\r\\n\\t * @author David Sarno / http://lighthaus.us/\\r\\n\\t * @author tschw\\r\\n\\t */\\r\\n\\r\\n\\tfunction AnimationMixer( root ) {\\r\\n\\r\\n\\t\\tthis._root = root;\\r\\n\\t\\tthis._initMemoryManager();\\r\\n\\t\\tthis._accuIndex = 0;\\r\\n\\r\\n\\t\\tthis.time = 0;\\r\\n\\r\\n\\t\\tthis.timeScale = 1.0;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tAnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: AnimationMixer,\\r\\n\\r\\n\\t\\t_bindAction: function ( action, prototypeAction ) {\\r\\n\\r\\n\\t\\t\\tvar root = action._localRoot || this._root,\\r\\n\\t\\t\\t\\ttracks = action._clip.tracks,\\r\\n\\t\\t\\t\\tnTracks = tracks.length,\\r\\n\\t\\t\\t\\tbindings = action._propertyBindings,\\r\\n\\t\\t\\t\\tinterpolants = action._interpolants,\\r\\n\\t\\t\\t\\trootUuid = root.uuid,\\r\\n\\t\\t\\t\\tbindingsByRoot = this._bindingsByRootAndName,\\r\\n\\t\\t\\t\\tbindingsByName = bindingsByRoot[ rootUuid ];\\r\\n\\r\\n\\t\\t\\tif ( bindingsByName === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tbindingsByName = {};\\r\\n\\t\\t\\t\\tbindingsByRoot[ rootUuid ] = bindingsByName;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i !== nTracks; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tvar track = tracks[ i ],\\r\\n\\t\\t\\t\\t\\ttrackName = track.name,\\r\\n\\t\\t\\t\\t\\tbinding = bindingsByName[ trackName ];\\r\\n\\r\\n\\t\\t\\t\\tif ( binding !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tbindings[ i ] = binding;\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tbinding = bindings[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( binding !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// existing binding, make sure the cache knows\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( binding._cacheIndex === null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t++ binding.referenceCount;\\r\\n\\t\\t\\t\\t\\t\\t\\tthis._addInactiveBinding( binding, rootUuid, trackName );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcontinue;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tvar path = prototypeAction && prototypeAction.\\r\\n\\t\\t\\t\\t\\t\\t_propertyBindings[ i ].binding.parsedPath;\\r\\n\\r\\n\\t\\t\\t\\t\\tbinding = new PropertyMixer(\\r\\n\\t\\t\\t\\t\\t\\tPropertyBinding.create( root, trackName, path ),\\r\\n\\t\\t\\t\\t\\t\\ttrack.ValueTypeName, track.getValueSize() );\\r\\n\\r\\n\\t\\t\\t\\t\\t++ binding.referenceCount;\\r\\n\\t\\t\\t\\t\\tthis._addInactiveBinding( binding, rootUuid, trackName );\\r\\n\\r\\n\\t\\t\\t\\t\\tbindings[ i ] = binding;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tinterpolants[ i ].resultBuffer = binding.buffer;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t_activateAction: function ( action ) {\\r\\n\\r\\n\\t\\t\\tif ( ! this._isActiveAction( action ) ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( action._cacheIndex === null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// this action has been forgotten by the cache, but the user\\r\\n\\t\\t\\t\\t\\t// appears to be still using it -> rebind\\r\\n\\r\\n\\t\\t\\t\\t\\tvar rootUuid = ( action._localRoot || this._root ).uuid,\\r\\n\\t\\t\\t\\t\\t\\tclipUuid = action._clip.uuid,\\r\\n\\t\\t\\t\\t\\t\\tactionsForClip = this._actionsByClip[ clipUuid ];\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._bindAction( action,\\r\\n\\t\\t\\t\\t\\t\\tactionsForClip && actionsForClip.knownActions[ 0 ] );\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._addInactiveAction( action, clipUuid, rootUuid );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tvar bindings = action._propertyBindings;\\r\\n\\r\\n\\t\\t\\t\\t// increment reference counts / sort out state\\r\\n\\t\\t\\t\\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar binding = bindings[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( binding.useCount ++ === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tthis._lendBinding( binding );\\r\\n\\t\\t\\t\\t\\t\\tbinding.saveOriginalState();\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tthis._lendAction( action );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t_deactivateAction: function ( action ) {\\r\\n\\r\\n\\t\\t\\tif ( this._isActiveAction( action ) ) {\\r\\n\\r\\n\\t\\t\\t\\tvar bindings = action._propertyBindings;\\r\\n\\r\\n\\t\\t\\t\\t// decrement reference counts / sort out state\\r\\n\\t\\t\\t\\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar binding = bindings[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( -- binding.useCount === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbinding.restoreOriginalState();\\r\\n\\t\\t\\t\\t\\t\\tthis._takeBackBinding( binding );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tthis._takeBackAction( action );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// Memory manager\\r\\n\\r\\n\\t\\t_initMemoryManager: function () {\\r\\n\\r\\n\\t\\t\\tthis._actions = []; // 'nActiveActions' followed by inactive ones\\r\\n\\t\\t\\tthis._nActiveActions = 0;\\r\\n\\r\\n\\t\\t\\tthis._actionsByClip = {};\\r\\n\\t\\t\\t// inside:\\r\\n\\t\\t\\t// {\\r\\n\\t\\t\\t// \\t\\tknownActions: Array< AnimationAction >\\t- used as prototypes\\r\\n\\t\\t\\t// \\t\\tactionByRoot: AnimationAction\\t\\t\\t- lookup\\r\\n\\t\\t\\t// }\\r\\n\\r\\n\\r\\n\\t\\t\\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\\r\\n\\t\\t\\tthis._nActiveBindings = 0;\\r\\n\\r\\n\\t\\t\\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\\r\\n\\r\\n\\r\\n\\t\\t\\tthis._controlInterpolants = []; // same game as above\\r\\n\\t\\t\\tthis._nActiveControlInterpolants = 0;\\r\\n\\r\\n\\t\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\t\\tthis.stats = {\\r\\n\\r\\n\\t\\t\\t\\tactions: {\\r\\n\\t\\t\\t\\t\\tget total() {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\treturn scope._actions.length;\\r\\n\\r\\n\\t\\t\\t\\t\\t},\\r\\n\\t\\t\\t\\t\\tget inUse() {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\treturn scope._nActiveActions;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t},\\r\\n\\t\\t\\t\\tbindings: {\\r\\n\\t\\t\\t\\t\\tget total() {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\treturn scope._bindings.length;\\r\\n\\r\\n\\t\\t\\t\\t\\t},\\r\\n\\t\\t\\t\\t\\tget inUse() {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\treturn scope._nActiveBindings;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t},\\r\\n\\t\\t\\t\\tcontrolInterpolants: {\\r\\n\\t\\t\\t\\t\\tget total() {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\treturn scope._controlInterpolants.length;\\r\\n\\r\\n\\t\\t\\t\\t\\t},\\r\\n\\t\\t\\t\\t\\tget inUse() {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\treturn scope._nActiveControlInterpolants;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// Memory management for AnimationAction objects\\r\\n\\r\\n\\t\\t_isActiveAction: function ( action ) {\\r\\n\\r\\n\\t\\t\\tvar index = action._cacheIndex;\\r\\n\\t\\t\\treturn index !== null && index < this._nActiveActions;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t_addInactiveAction: function ( action, clipUuid, rootUuid ) {\\r\\n\\r\\n\\t\\t\\tvar actions = this._actions,\\r\\n\\t\\t\\t\\tactionsByClip = this._actionsByClip,\\r\\n\\t\\t\\t\\tactionsForClip = actionsByClip[ clipUuid ];\\r\\n\\r\\n\\t\\t\\tif ( actionsForClip === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tactionsForClip = {\\r\\n\\r\\n\\t\\t\\t\\t\\tknownActions: [ action ],\\r\\n\\t\\t\\t\\t\\tactionByRoot: {}\\r\\n\\r\\n\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t\\taction._byClipCacheIndex = 0;\\r\\n\\r\\n\\t\\t\\t\\tactionsByClip[ clipUuid ] = actionsForClip;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tvar knownActions = actionsForClip.knownActions;\\r\\n\\r\\n\\t\\t\\t\\taction._byClipCacheIndex = knownActions.length;\\r\\n\\t\\t\\t\\tknownActions.push( action );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\taction._cacheIndex = actions.length;\\r\\n\\t\\t\\tactions.push( action );\\r\\n\\r\\n\\t\\t\\tactionsForClip.actionByRoot[ rootUuid ] = action;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t_removeInactiveAction: function ( action ) {\\r\\n\\r\\n\\t\\t\\tvar actions = this._actions,\\r\\n\\t\\t\\t\\tlastInactiveAction = actions[ actions.length - 1 ],\\r\\n\\t\\t\\t\\tcacheIndex = action._cacheIndex;\\r\\n\\r\\n\\t\\t\\tlastInactiveAction._cacheIndex = cacheIndex;\\r\\n\\t\\t\\tactions[ cacheIndex ] = lastInactiveAction;\\r\\n\\t\\t\\tactions.pop();\\r\\n\\r\\n\\t\\t\\taction._cacheIndex = null;\\r\\n\\r\\n\\r\\n\\t\\t\\tvar clipUuid = action._clip.uuid,\\r\\n\\t\\t\\t\\tactionsByClip = this._actionsByClip,\\r\\n\\t\\t\\t\\tactionsForClip = actionsByClip[ clipUuid ],\\r\\n\\t\\t\\t\\tknownActionsForClip = actionsForClip.knownActions,\\r\\n\\r\\n\\t\\t\\t\\tlastKnownAction =\\r\\n\\t\\t\\t\\t\\tknownActionsForClip[ knownActionsForClip.length - 1 ],\\r\\n\\r\\n\\t\\t\\t\\tbyClipCacheIndex = action._byClipCacheIndex;\\r\\n\\r\\n\\t\\t\\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\\r\\n\\t\\t\\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\\r\\n\\t\\t\\tknownActionsForClip.pop();\\r\\n\\r\\n\\t\\t\\taction._byClipCacheIndex = null;\\r\\n\\r\\n\\r\\n\\t\\t\\tvar actionByRoot = actionsForClip.actionByRoot,\\r\\n\\t\\t\\t\\trootUuid = ( action._localRoot || this._root ).uuid;\\r\\n\\r\\n\\t\\t\\tdelete actionByRoot[ rootUuid ];\\r\\n\\r\\n\\t\\t\\tif ( knownActionsForClip.length === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tdelete actionsByClip[ clipUuid ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis._removeInactiveBindingsForAction( action );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t_removeInactiveBindingsForAction: function ( action ) {\\r\\n\\r\\n\\t\\t\\tvar bindings = action._propertyBindings;\\r\\n\\t\\t\\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tvar binding = bindings[ i ];\\r\\n\\r\\n\\t\\t\\t\\tif ( -- binding.referenceCount === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._removeInactiveBinding( binding );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t_lendAction: function ( action ) {\\r\\n\\r\\n\\t\\t\\t// [ active actions |  inactive actions  ]\\r\\n\\t\\t\\t// [  active actions >| inactive actions ]\\r\\n\\t\\t\\t//                 s        a\\r\\n\\t\\t\\t//                  <-swap->\\r\\n\\t\\t\\t//                 a        s\\r\\n\\r\\n\\t\\t\\tvar actions = this._actions,\\r\\n\\t\\t\\t\\tprevIndex = action._cacheIndex,\\r\\n\\r\\n\\t\\t\\t\\tlastActiveIndex = this._nActiveActions ++,\\r\\n\\r\\n\\t\\t\\t\\tfirstInactiveAction = actions[ lastActiveIndex ];\\r\\n\\r\\n\\t\\t\\taction._cacheIndex = lastActiveIndex;\\r\\n\\t\\t\\tactions[ lastActiveIndex ] = action;\\r\\n\\r\\n\\t\\t\\tfirstInactiveAction._cacheIndex = prevIndex;\\r\\n\\t\\t\\tactions[ prevIndex ] = firstInactiveAction;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t_takeBackAction: function ( action ) {\\r\\n\\r\\n\\t\\t\\t// [  active actions  | inactive actions ]\\r\\n\\t\\t\\t// [ active actions |< inactive actions  ]\\r\\n\\t\\t\\t//        a        s\\r\\n\\t\\t\\t//         <-swap->\\r\\n\\t\\t\\t//        s        a\\r\\n\\r\\n\\t\\t\\tvar actions = this._actions,\\r\\n\\t\\t\\t\\tprevIndex = action._cacheIndex,\\r\\n\\r\\n\\t\\t\\t\\tfirstInactiveIndex = -- this._nActiveActions,\\r\\n\\r\\n\\t\\t\\t\\tlastActiveAction = actions[ firstInactiveIndex ];\\r\\n\\r\\n\\t\\t\\taction._cacheIndex = firstInactiveIndex;\\r\\n\\t\\t\\tactions[ firstInactiveIndex ] = action;\\r\\n\\r\\n\\t\\t\\tlastActiveAction._cacheIndex = prevIndex;\\r\\n\\t\\t\\tactions[ prevIndex ] = lastActiveAction;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// Memory management for PropertyMixer objects\\r\\n\\r\\n\\t\\t_addInactiveBinding: function ( binding, rootUuid, trackName ) {\\r\\n\\r\\n\\t\\t\\tvar bindingsByRoot = this._bindingsByRootAndName,\\r\\n\\t\\t\\t\\tbindingByName = bindingsByRoot[ rootUuid ],\\r\\n\\r\\n\\t\\t\\t\\tbindings = this._bindings;\\r\\n\\r\\n\\t\\t\\tif ( bindingByName === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tbindingByName = {};\\r\\n\\t\\t\\t\\tbindingsByRoot[ rootUuid ] = bindingByName;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tbindingByName[ trackName ] = binding;\\r\\n\\r\\n\\t\\t\\tbinding._cacheIndex = bindings.length;\\r\\n\\t\\t\\tbindings.push( binding );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t_removeInactiveBinding: function ( binding ) {\\r\\n\\r\\n\\t\\t\\tvar bindings = this._bindings,\\r\\n\\t\\t\\t\\tpropBinding = binding.binding,\\r\\n\\t\\t\\t\\trootUuid = propBinding.rootNode.uuid,\\r\\n\\t\\t\\t\\ttrackName = propBinding.path,\\r\\n\\t\\t\\t\\tbindingsByRoot = this._bindingsByRootAndName,\\r\\n\\t\\t\\t\\tbindingByName = bindingsByRoot[ rootUuid ],\\r\\n\\r\\n\\t\\t\\t\\tlastInactiveBinding = bindings[ bindings.length - 1 ],\\r\\n\\t\\t\\t\\tcacheIndex = binding._cacheIndex;\\r\\n\\r\\n\\t\\t\\tlastInactiveBinding._cacheIndex = cacheIndex;\\r\\n\\t\\t\\tbindings[ cacheIndex ] = lastInactiveBinding;\\r\\n\\t\\t\\tbindings.pop();\\r\\n\\r\\n\\t\\t\\tdelete bindingByName[ trackName ];\\r\\n\\r\\n\\t\\t\\tremove_empty_map: {\\r\\n\\r\\n\\t\\t\\t\\tfor ( var _ in bindingByName ) break remove_empty_map; // eslint-disable-line no-unused-vars\\r\\n\\r\\n\\t\\t\\t\\tdelete bindingsByRoot[ rootUuid ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t_lendBinding: function ( binding ) {\\r\\n\\r\\n\\t\\t\\tvar bindings = this._bindings,\\r\\n\\t\\t\\t\\tprevIndex = binding._cacheIndex,\\r\\n\\r\\n\\t\\t\\t\\tlastActiveIndex = this._nActiveBindings ++,\\r\\n\\r\\n\\t\\t\\t\\tfirstInactiveBinding = bindings[ lastActiveIndex ];\\r\\n\\r\\n\\t\\t\\tbinding._cacheIndex = lastActiveIndex;\\r\\n\\t\\t\\tbindings[ lastActiveIndex ] = binding;\\r\\n\\r\\n\\t\\t\\tfirstInactiveBinding._cacheIndex = prevIndex;\\r\\n\\t\\t\\tbindings[ prevIndex ] = firstInactiveBinding;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t_takeBackBinding: function ( binding ) {\\r\\n\\r\\n\\t\\t\\tvar bindings = this._bindings,\\r\\n\\t\\t\\t\\tprevIndex = binding._cacheIndex,\\r\\n\\r\\n\\t\\t\\t\\tfirstInactiveIndex = -- this._nActiveBindings,\\r\\n\\r\\n\\t\\t\\t\\tlastActiveBinding = bindings[ firstInactiveIndex ];\\r\\n\\r\\n\\t\\t\\tbinding._cacheIndex = firstInactiveIndex;\\r\\n\\t\\t\\tbindings[ firstInactiveIndex ] = binding;\\r\\n\\r\\n\\t\\t\\tlastActiveBinding._cacheIndex = prevIndex;\\r\\n\\t\\t\\tbindings[ prevIndex ] = lastActiveBinding;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\r\\n\\t\\t// Memory management of Interpolants for weight and time scale\\r\\n\\r\\n\\t\\t_lendControlInterpolant: function () {\\r\\n\\r\\n\\t\\t\\tvar interpolants = this._controlInterpolants,\\r\\n\\t\\t\\t\\tlastActiveIndex = this._nActiveControlInterpolants ++,\\r\\n\\t\\t\\t\\tinterpolant = interpolants[ lastActiveIndex ];\\r\\n\\r\\n\\t\\t\\tif ( interpolant === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tinterpolant = new LinearInterpolant(\\r\\n\\t\\t\\t\\t\\tnew Float32Array( 2 ), new Float32Array( 2 ),\\r\\n\\t\\t\\t\\t\\t1, this._controlInterpolantsResultBuffer );\\r\\n\\r\\n\\t\\t\\t\\tinterpolant.__cacheIndex = lastActiveIndex;\\r\\n\\t\\t\\t\\tinterpolants[ lastActiveIndex ] = interpolant;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn interpolant;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t_takeBackControlInterpolant: function ( interpolant ) {\\r\\n\\r\\n\\t\\t\\tvar interpolants = this._controlInterpolants,\\r\\n\\t\\t\\t\\tprevIndex = interpolant.__cacheIndex,\\r\\n\\r\\n\\t\\t\\t\\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\\r\\n\\r\\n\\t\\t\\t\\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\\r\\n\\r\\n\\t\\t\\tinterpolant.__cacheIndex = firstInactiveIndex;\\r\\n\\t\\t\\tinterpolants[ firstInactiveIndex ] = interpolant;\\r\\n\\r\\n\\t\\t\\tlastActiveInterpolant.__cacheIndex = prevIndex;\\r\\n\\t\\t\\tinterpolants[ prevIndex ] = lastActiveInterpolant;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t_controlInterpolantsResultBuffer: new Float32Array( 1 ),\\r\\n\\r\\n\\t\\t// return an action for a clip optionally using a custom root target\\r\\n\\t\\t// object (this method allocates a lot of dynamic memory in case a\\r\\n\\t\\t// previously unknown clip/root combination is specified)\\r\\n\\t\\tclipAction: function ( clip, optionalRoot ) {\\r\\n\\r\\n\\t\\t\\tvar root = optionalRoot || this._root,\\r\\n\\t\\t\\t\\trootUuid = root.uuid,\\r\\n\\r\\n\\t\\t\\t\\tclipObject = typeof clip === 'string' ?\\r\\n\\t\\t\\t\\t\\tAnimationClip.findByName( root, clip ) : clip,\\r\\n\\r\\n\\t\\t\\t\\tclipUuid = clipObject !== null ? clipObject.uuid : clip,\\r\\n\\r\\n\\t\\t\\t\\tactionsForClip = this._actionsByClip[ clipUuid ],\\r\\n\\t\\t\\t\\tprototypeAction = null;\\r\\n\\r\\n\\t\\t\\tif ( actionsForClip !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tvar existingAction =\\r\\n\\t\\t\\t\\t\\t\\tactionsForClip.actionByRoot[ rootUuid ];\\r\\n\\r\\n\\t\\t\\t\\tif ( existingAction !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn existingAction;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// we know the clip, so we don't have to parse all\\r\\n\\t\\t\\t\\t// the bindings again but can just copy\\r\\n\\t\\t\\t\\tprototypeAction = actionsForClip.knownActions[ 0 ];\\r\\n\\r\\n\\t\\t\\t\\t// also, take the clip from the prototype action\\r\\n\\t\\t\\t\\tif ( clipObject === null )\\r\\n\\t\\t\\t\\t\\tclipObject = prototypeAction._clip;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// clip must be known when specified via string\\r\\n\\t\\t\\tif ( clipObject === null ) return null;\\r\\n\\r\\n\\t\\t\\t// allocate all resources required to run it\\r\\n\\t\\t\\tvar newAction = new AnimationAction( this, clipObject, optionalRoot );\\r\\n\\r\\n\\t\\t\\tthis._bindAction( newAction, prototypeAction );\\r\\n\\r\\n\\t\\t\\t// and make the action known to the memory manager\\r\\n\\t\\t\\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\\r\\n\\r\\n\\t\\t\\treturn newAction;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// get an existing action\\r\\n\\t\\texistingAction: function ( clip, optionalRoot ) {\\r\\n\\r\\n\\t\\t\\tvar root = optionalRoot || this._root,\\r\\n\\t\\t\\t\\trootUuid = root.uuid,\\r\\n\\r\\n\\t\\t\\t\\tclipObject = typeof clip === 'string' ?\\r\\n\\t\\t\\t\\t\\tAnimationClip.findByName( root, clip ) : clip,\\r\\n\\r\\n\\t\\t\\t\\tclipUuid = clipObject ? clipObject.uuid : clip,\\r\\n\\r\\n\\t\\t\\t\\tactionsForClip = this._actionsByClip[ clipUuid ];\\r\\n\\r\\n\\t\\t\\tif ( actionsForClip !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// deactivates all previously scheduled actions\\r\\n\\t\\tstopAllAction: function () {\\r\\n\\r\\n\\t\\t\\tvar actions = this._actions,\\r\\n\\t\\t\\t\\tnActions = this._nActiveActions,\\r\\n\\t\\t\\t\\tbindings = this._bindings,\\r\\n\\t\\t\\t\\tnBindings = this._nActiveBindings;\\r\\n\\r\\n\\t\\t\\tthis._nActiveActions = 0;\\r\\n\\t\\t\\tthis._nActiveBindings = 0;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i !== nActions; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tactions[ i ].reset();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i !== nBindings; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tbindings[ i ].useCount = 0;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// advance the time and update apply the animation\\r\\n\\t\\tupdate: function ( deltaTime ) {\\r\\n\\r\\n\\t\\t\\tdeltaTime *= this.timeScale;\\r\\n\\r\\n\\t\\t\\tvar actions = this._actions,\\r\\n\\t\\t\\t\\tnActions = this._nActiveActions,\\r\\n\\r\\n\\t\\t\\t\\ttime = this.time += deltaTime,\\r\\n\\t\\t\\t\\ttimeDirection = Math.sign( deltaTime ),\\r\\n\\r\\n\\t\\t\\t\\taccuIndex = this._accuIndex ^= 1;\\r\\n\\r\\n\\t\\t\\t// run active actions\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i !== nActions; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tvar action = actions[ i ];\\r\\n\\r\\n\\t\\t\\t\\taction._update( time, deltaTime, timeDirection, accuIndex );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// update scene graph\\r\\n\\r\\n\\t\\t\\tvar bindings = this._bindings,\\r\\n\\t\\t\\t\\tnBindings = this._nActiveBindings;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i !== nBindings; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tbindings[ i ].apply( accuIndex );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// return this mixer's root target object\\r\\n\\t\\tgetRoot: function () {\\r\\n\\r\\n\\t\\t\\treturn this._root;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// free all resources specific to a particular clip\\r\\n\\t\\tuncacheClip: function ( clip ) {\\r\\n\\r\\n\\t\\t\\tvar actions = this._actions,\\r\\n\\t\\t\\t\\tclipUuid = clip.uuid,\\r\\n\\t\\t\\t\\tactionsByClip = this._actionsByClip,\\r\\n\\t\\t\\t\\tactionsForClip = actionsByClip[ clipUuid ];\\r\\n\\r\\n\\t\\t\\tif ( actionsForClip !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t// note: just calling _removeInactiveAction would mess up the\\r\\n\\t\\t\\t\\t// iteration state and also require updating the state we can\\r\\n\\t\\t\\t\\t// just throw away\\r\\n\\r\\n\\t\\t\\t\\tvar actionsToRemove = actionsForClip.knownActions;\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar action = actionsToRemove[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._deactivateAction( action );\\r\\n\\r\\n\\t\\t\\t\\t\\tvar cacheIndex = action._cacheIndex,\\r\\n\\t\\t\\t\\t\\t\\tlastInactiveAction = actions[ actions.length - 1 ];\\r\\n\\r\\n\\t\\t\\t\\t\\taction._cacheIndex = null;\\r\\n\\t\\t\\t\\t\\taction._byClipCacheIndex = null;\\r\\n\\r\\n\\t\\t\\t\\t\\tlastInactiveAction._cacheIndex = cacheIndex;\\r\\n\\t\\t\\t\\t\\tactions[ cacheIndex ] = lastInactiveAction;\\r\\n\\t\\t\\t\\t\\tactions.pop();\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._removeInactiveBindingsForAction( action );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tdelete actionsByClip[ clipUuid ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// free all resources specific to a particular root target object\\r\\n\\t\\tuncacheRoot: function ( root ) {\\r\\n\\r\\n\\t\\t\\tvar rootUuid = root.uuid,\\r\\n\\t\\t\\t\\tactionsByClip = this._actionsByClip;\\r\\n\\r\\n\\t\\t\\tfor ( var clipUuid in actionsByClip ) {\\r\\n\\r\\n\\t\\t\\t\\tvar actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\\r\\n\\t\\t\\t\\t\\taction = actionByRoot[ rootUuid ];\\r\\n\\r\\n\\t\\t\\t\\tif ( action !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._deactivateAction( action );\\r\\n\\t\\t\\t\\t\\tthis._removeInactiveAction( action );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar bindingsByRoot = this._bindingsByRootAndName,\\r\\n\\t\\t\\t\\tbindingByName = bindingsByRoot[ rootUuid ];\\r\\n\\r\\n\\t\\t\\tif ( bindingByName !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( var trackName in bindingByName ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar binding = bindingByName[ trackName ];\\r\\n\\t\\t\\t\\t\\tbinding.restoreOriginalState();\\r\\n\\t\\t\\t\\t\\tthis._removeInactiveBinding( binding );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// remove a targeted clip from the cache\\r\\n\\t\\tuncacheAction: function ( clip, optionalRoot ) {\\r\\n\\r\\n\\t\\t\\tvar action = this.existingAction( clip, optionalRoot );\\r\\n\\r\\n\\t\\t\\tif ( action !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._deactivateAction( action );\\r\\n\\t\\t\\t\\tthis._removeInactiveAction( action );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction Uniform( value ) {\\r\\n\\r\\n\\t\\tif ( typeof value === 'string' ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\\r\\n\\t\\t\\tvalue = arguments[ 1 ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.value = value;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tUniform.prototype.clone = function () {\\r\\n\\r\\n\\t\\treturn new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author benaadams / https://twitter.com/ben_a_adams\\r\\n\\t */\\r\\n\\r\\n\\tfunction InstancedBufferGeometry() {\\r\\n\\r\\n\\t\\tBufferGeometry.call( this );\\r\\n\\r\\n\\t\\tthis.type = 'InstancedBufferGeometry';\\r\\n\\t\\tthis.maxInstancedCount = undefined;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tInstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: InstancedBufferGeometry,\\r\\n\\r\\n\\t\\tisInstancedBufferGeometry: true,\\r\\n\\r\\n\\t\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\t\\tBufferGeometry.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\t\\tthis.maxInstancedCount = source.maxInstancedCount;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author benaadams / https://twitter.com/ben_a_adams\\r\\n\\t */\\r\\n\\r\\n\\tfunction InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {\\r\\n\\r\\n\\t\\tthis.uuid = _Math.generateUUID();\\r\\n\\r\\n\\t\\tthis.data = interleavedBuffer;\\r\\n\\t\\tthis.itemSize = itemSize;\\r\\n\\t\\tthis.offset = offset;\\r\\n\\r\\n\\t\\tthis.normalized = normalized === true;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.defineProperties( InterleavedBufferAttribute.prototype, {\\r\\n\\r\\n\\t\\tcount: {\\r\\n\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\treturn this.data.count;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tarray: {\\r\\n\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\treturn this.data.array;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tObject.assign( InterleavedBufferAttribute.prototype, {\\r\\n\\r\\n\\t\\tisInterleavedBufferAttribute: true,\\r\\n\\r\\n\\t\\tsetX: function ( index, x ) {\\r\\n\\r\\n\\t\\t\\tthis.data.array[ index * this.data.stride + this.offset ] = x;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetY: function ( index, y ) {\\r\\n\\r\\n\\t\\t\\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetZ: function ( index, z ) {\\r\\n\\r\\n\\t\\t\\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetW: function ( index, w ) {\\r\\n\\r\\n\\t\\t\\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetX: function ( index ) {\\r\\n\\r\\n\\t\\t\\treturn this.data.array[ index * this.data.stride + this.offset ];\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetY: function ( index ) {\\r\\n\\r\\n\\t\\t\\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetZ: function ( index ) {\\r\\n\\r\\n\\t\\t\\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetW: function ( index ) {\\r\\n\\r\\n\\t\\t\\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetXY: function ( index, x, y ) {\\r\\n\\r\\n\\t\\t\\tindex = index * this.data.stride + this.offset;\\r\\n\\r\\n\\t\\t\\tthis.data.array[ index + 0 ] = x;\\r\\n\\t\\t\\tthis.data.array[ index + 1 ] = y;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetXYZ: function ( index, x, y, z ) {\\r\\n\\r\\n\\t\\t\\tindex = index * this.data.stride + this.offset;\\r\\n\\r\\n\\t\\t\\tthis.data.array[ index + 0 ] = x;\\r\\n\\t\\t\\tthis.data.array[ index + 1 ] = y;\\r\\n\\t\\t\\tthis.data.array[ index + 2 ] = z;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetXYZW: function ( index, x, y, z, w ) {\\r\\n\\r\\n\\t\\t\\tindex = index * this.data.stride + this.offset;\\r\\n\\r\\n\\t\\t\\tthis.data.array[ index + 0 ] = x;\\r\\n\\t\\t\\tthis.data.array[ index + 1 ] = y;\\r\\n\\t\\t\\tthis.data.array[ index + 2 ] = z;\\r\\n\\t\\t\\tthis.data.array[ index + 3 ] = w;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author benaadams / https://twitter.com/ben_a_adams\\r\\n\\t */\\r\\n\\r\\n\\tfunction InterleavedBuffer( array, stride ) {\\r\\n\\r\\n\\t\\tthis.uuid = _Math.generateUUID();\\r\\n\\r\\n\\t\\tthis.array = array;\\r\\n\\t\\tthis.stride = stride;\\r\\n\\t\\tthis.count = array !== undefined ? array.length / stride : 0;\\r\\n\\r\\n\\t\\tthis.dynamic = false;\\r\\n\\t\\tthis.updateRange = { offset: 0, count: - 1 };\\r\\n\\r\\n\\t\\tthis.onUploadCallback = function () {};\\r\\n\\r\\n\\t\\tthis.version = 0;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {\\r\\n\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tif ( value === true ) this.version ++;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tObject.assign( InterleavedBuffer.prototype, {\\r\\n\\r\\n\\t\\tisInterleavedBuffer: true,\\r\\n\\r\\n\\t\\tsetArray: function ( array ) {\\r\\n\\r\\n\\t\\t\\tif ( Array.isArray( array ) ) {\\r\\n\\r\\n\\t\\t\\t\\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.count = array !== undefined ? array.length / this.stride : 0;\\r\\n\\t\\t\\tthis.array = array;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetDynamic: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.dynamic = value;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\t\\tthis.array = new source.array.constructor( source.array );\\r\\n\\t\\t\\tthis.count = source.count;\\r\\n\\t\\t\\tthis.stride = source.stride;\\r\\n\\t\\t\\tthis.dynamic = source.dynamic;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopyAt: function ( index1, attribute, index2 ) {\\r\\n\\r\\n\\t\\t\\tindex1 *= this.stride;\\r\\n\\t\\t\\tindex2 *= attribute.stride;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tset: function ( value, offset ) {\\r\\n\\r\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\t\\tthis.array.set( value, offset );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tonUpload: function ( callback ) {\\r\\n\\r\\n\\t\\t\\tthis.onUploadCallback = callback;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author benaadams / https://twitter.com/ben_a_adams\\r\\n\\t */\\r\\n\\r\\n\\tfunction InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {\\r\\n\\r\\n\\t\\tInterleavedBuffer.call( this, array, stride );\\r\\n\\r\\n\\t\\tthis.meshPerAttribute = meshPerAttribute || 1;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tInstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: InstancedInterleavedBuffer,\\r\\n\\r\\n\\t\\tisInstancedInterleavedBuffer: true,\\r\\n\\r\\n\\t\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\t\\tInterleavedBuffer.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\t\\tthis.meshPerAttribute = source.meshPerAttribute;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author benaadams / https://twitter.com/ben_a_adams\\r\\n\\t */\\r\\n\\r\\n\\tfunction InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {\\r\\n\\r\\n\\t\\tBufferAttribute.call( this, array, itemSize );\\r\\n\\r\\n\\t\\tthis.meshPerAttribute = meshPerAttribute || 1;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tInstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {\\r\\n\\r\\n\\t\\tconstructor: InstancedBufferAttribute,\\r\\n\\r\\n\\t\\tisInstancedBufferAttribute: true,\\r\\n\\r\\n\\t\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\t\\tBufferAttribute.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\t\\tthis.meshPerAttribute = source.meshPerAttribute;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author bhouston / http://clara.io/\\r\\n\\t * @author stephomi / http://stephaneginier.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction Raycaster( origin, direction, near, far ) {\\r\\n\\r\\n\\t\\tthis.ray = new Ray( origin, direction );\\r\\n\\t\\t// direction is assumed to be normalized (for accurate distance calculations)\\r\\n\\r\\n\\t\\tthis.near = near || 0;\\r\\n\\t\\tthis.far = far || Infinity;\\r\\n\\r\\n\\t\\tthis.params = {\\r\\n\\t\\t\\tMesh: {},\\r\\n\\t\\t\\tLine: {},\\r\\n\\t\\t\\tLOD: {},\\r\\n\\t\\t\\tPoints: { threshold: 1 },\\r\\n\\t\\t\\tSprite: {}\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tObject.defineProperties( this.params, {\\r\\n\\t\\t\\tPointCloud: {\\r\\n\\t\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\\r\\n\\t\\t\\t\\t\\treturn this.Points;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t} );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction ascSort( a, b ) {\\r\\n\\r\\n\\t\\treturn a.distance - b.distance;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction intersectObject( object, raycaster, intersects, recursive ) {\\r\\n\\r\\n\\t\\tif ( object.visible === false ) return;\\r\\n\\r\\n\\t\\tobject.raycast( raycaster, intersects );\\r\\n\\r\\n\\t\\tif ( recursive === true ) {\\r\\n\\r\\n\\t\\t\\tvar children = object.children;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tintersectObject( children[ i ], raycaster, intersects, true );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( Raycaster.prototype, {\\r\\n\\r\\n\\t\\tlinePrecision: 1,\\r\\n\\r\\n\\t\\tset: function ( origin, direction ) {\\r\\n\\r\\n\\t\\t\\t// direction is assumed to be normalized (for accurate distance calculations)\\r\\n\\r\\n\\t\\t\\tthis.ray.set( origin, direction );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFromCamera: function ( coords, camera ) {\\r\\n\\r\\n\\t\\t\\tif ( ( camera && camera.isPerspectiveCamera ) ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\\r\\n\\t\\t\\t\\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\\r\\n\\r\\n\\t\\t\\t} else if ( ( camera && camera.isOrthographicCamera ) ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\\r\\n\\t\\t\\t\\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tintersectObject: function ( object, recursive ) {\\r\\n\\r\\n\\t\\t\\tvar intersects = [];\\r\\n\\r\\n\\t\\t\\tintersectObject( object, this, intersects, recursive );\\r\\n\\r\\n\\t\\t\\tintersects.sort( ascSort );\\r\\n\\r\\n\\t\\t\\treturn intersects;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tintersectObjects: function ( objects, recursive ) {\\r\\n\\r\\n\\t\\t\\tvar intersects = [];\\r\\n\\r\\n\\t\\t\\tif ( Array.isArray( objects ) === false ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\\r\\n\\t\\t\\t\\treturn intersects;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tintersectObject( objects[ i ], this, intersects, recursive );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tintersects.sort( ascSort );\\r\\n\\r\\n\\t\\t\\treturn intersects;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction Clock( autoStart ) {\\r\\n\\r\\n\\t\\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\\r\\n\\r\\n\\t\\tthis.startTime = 0;\\r\\n\\t\\tthis.oldTime = 0;\\r\\n\\t\\tthis.elapsedTime = 0;\\r\\n\\r\\n\\t\\tthis.running = false;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( Clock.prototype, {\\r\\n\\r\\n\\t\\tstart: function () {\\r\\n\\r\\n\\t\\t\\tthis.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732\\r\\n\\r\\n\\t\\t\\tthis.oldTime = this.startTime;\\r\\n\\t\\t\\tthis.elapsedTime = 0;\\r\\n\\t\\t\\tthis.running = true;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tstop: function () {\\r\\n\\r\\n\\t\\t\\tthis.getElapsedTime();\\r\\n\\t\\t\\tthis.running = false;\\r\\n\\t\\t\\tthis.autoStart = false;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetElapsedTime: function () {\\r\\n\\r\\n\\t\\t\\tthis.getDelta();\\r\\n\\t\\t\\treturn this.elapsedTime;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetDelta: function () {\\r\\n\\r\\n\\t\\t\\tvar diff = 0;\\r\\n\\r\\n\\t\\t\\tif ( this.autoStart && ! this.running ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.start();\\r\\n\\t\\t\\t\\treturn 0;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( this.running ) {\\r\\n\\r\\n\\t\\t\\t\\tvar newTime = ( typeof performance === 'undefined' ? Date : performance ).now();\\r\\n\\r\\n\\t\\t\\t\\tdiff = ( newTime - this.oldTime ) / 1000;\\r\\n\\t\\t\\t\\tthis.oldTime = newTime;\\r\\n\\r\\n\\t\\t\\t\\tthis.elapsedTime += diff;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn diff;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author bhouston / http://clara.io\\r\\n\\t * @author WestLangley / http://github.com/WestLangley\\r\\n\\t *\\r\\n\\t * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\\r\\n\\t *\\r\\n\\t * The poles (phi) are at the positive and negative y axis.\\r\\n\\t * The equator starts at positive z.\\r\\n\\t */\\r\\n\\r\\n\\tfunction Spherical( radius, phi, theta ) {\\r\\n\\r\\n\\t\\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\\r\\n\\t\\tthis.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole\\r\\n\\t\\tthis.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( Spherical.prototype, {\\r\\n\\r\\n\\t\\tset: function ( radius, phi, theta ) {\\r\\n\\r\\n\\t\\t\\tthis.radius = radius;\\r\\n\\t\\t\\tthis.phi = phi;\\r\\n\\t\\t\\tthis.theta = theta;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( other ) {\\r\\n\\r\\n\\t\\t\\tthis.radius = other.radius;\\r\\n\\t\\t\\tthis.phi = other.phi;\\r\\n\\t\\t\\tthis.theta = other.theta;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t// restrict phi to be betwee EPS and PI-EPS\\r\\n\\t\\tmakeSafe: function () {\\r\\n\\r\\n\\t\\t\\tvar EPS = 0.000001;\\r\\n\\t\\t\\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFromVector3: function ( vec3 ) {\\r\\n\\r\\n\\t\\t\\tthis.radius = vec3.length();\\r\\n\\r\\n\\t\\t\\tif ( this.radius === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.theta = 0;\\r\\n\\t\\t\\t\\tthis.phi = 0;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tthis.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis\\r\\n\\t\\t\\t\\tthis.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author Mugen87 / https://github.com/Mugen87\\r\\n\\t *\\r\\n\\t * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system\\r\\n\\t *\\r\\n\\t */\\r\\n\\r\\n\\tfunction Cylindrical( radius, theta, y ) {\\r\\n\\r\\n\\t\\tthis.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane\\r\\n\\t\\tthis.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis\\r\\n\\t\\tthis.y = ( y !== undefined ) ? y : 0; // height above the x-z plane\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject.assign( Cylindrical.prototype, {\\r\\n\\r\\n\\t\\tset: function ( radius, theta, y ) {\\r\\n\\r\\n\\t\\t\\tthis.radius = radius;\\r\\n\\t\\t\\tthis.theta = theta;\\r\\n\\t\\t\\tthis.y = y;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tclone: function () {\\r\\n\\r\\n\\t\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcopy: function ( other ) {\\r\\n\\r\\n\\t\\t\\tthis.radius = other.radius;\\r\\n\\t\\t\\tthis.theta = other.theta;\\r\\n\\t\\t\\tthis.y = other.y;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetFromVector3: function ( vec3 ) {\\r\\n\\r\\n\\t\\t\\tthis.radius = Math.sqrt( vec3.x * vec3.x + vec3.z * vec3.z );\\r\\n\\t\\t\\tthis.theta = Math.atan2( vec3.x, vec3.z );\\r\\n\\t\\t\\tthis.y = vec3.y;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction ImmediateRenderObject( material ) {\\r\\n\\r\\n\\t\\tObject3D.call( this );\\r\\n\\r\\n\\t\\tthis.material = material;\\r\\n\\t\\tthis.render = function ( /* renderCallback */ ) {};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tImmediateRenderObject.prototype = Object.create( Object3D.prototype );\\r\\n\\tImmediateRenderObject.prototype.constructor = ImmediateRenderObject;\\r\\n\\r\\n\\tImmediateRenderObject.prototype.isImmediateRenderObject = true;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author WestLangley / http://github.com/WestLangley\\r\\n\\t */\\r\\n\\r\\n\\tfunction VertexNormalsHelper( object, size, hex, linewidth ) {\\r\\n\\r\\n\\t\\tthis.object = object;\\r\\n\\r\\n\\t\\tthis.size = ( size !== undefined ) ? size : 1;\\r\\n\\r\\n\\t\\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\\r\\n\\r\\n\\t\\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tvar nNormals = 0;\\r\\n\\r\\n\\t\\tvar objGeometry = this.object.geometry;\\r\\n\\r\\n\\t\\tif ( objGeometry && objGeometry.isGeometry ) {\\r\\n\\r\\n\\t\\t\\tnNormals = objGeometry.faces.length * 3;\\r\\n\\r\\n\\t\\t} else if ( objGeometry && objGeometry.isBufferGeometry ) {\\r\\n\\r\\n\\t\\t\\tnNormals = objGeometry.attributes.normal.count;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tvar geometry = new BufferGeometry();\\r\\n\\r\\n\\t\\tvar positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );\\r\\n\\r\\n\\t\\tgeometry.addAttribute( 'position', positions );\\r\\n\\r\\n\\t\\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tthis.matrixAutoUpdate = false;\\r\\n\\r\\n\\t\\tthis.update();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tVertexNormalsHelper.prototype = Object.create( LineSegments.prototype );\\r\\n\\tVertexNormalsHelper.prototype.constructor = VertexNormalsHelper;\\r\\n\\r\\n\\tVertexNormalsHelper.prototype.update = ( function () {\\r\\n\\r\\n\\t\\tvar v1 = new Vector3();\\r\\n\\t\\tvar v2 = new Vector3();\\r\\n\\t\\tvar normalMatrix = new Matrix3();\\r\\n\\r\\n\\t\\treturn function update() {\\r\\n\\r\\n\\t\\t\\tvar keys = [ 'a', 'b', 'c' ];\\r\\n\\r\\n\\t\\t\\tthis.object.updateMatrixWorld( true );\\r\\n\\r\\n\\t\\t\\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\\r\\n\\r\\n\\t\\t\\tvar matrixWorld = this.object.matrixWorld;\\r\\n\\r\\n\\t\\t\\tvar position = this.geometry.attributes.position;\\r\\n\\r\\n\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\tvar objGeometry = this.object.geometry;\\r\\n\\r\\n\\t\\t\\tif ( objGeometry && objGeometry.isGeometry ) {\\r\\n\\r\\n\\t\\t\\t\\tvar vertices = objGeometry.vertices;\\r\\n\\r\\n\\t\\t\\t\\tvar faces = objGeometry.faces;\\r\\n\\r\\n\\t\\t\\t\\tvar idx = 0;\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar face = faces[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar vertex = vertices[ face[ keys[ j ] ] ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar normal = face.vertexNormals[ j ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tv1.copy( vertex ).applyMatrix4( matrixWorld );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tidx = idx + 1;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tidx = idx + 1;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else if ( objGeometry && objGeometry.isBufferGeometry ) {\\r\\n\\r\\n\\t\\t\\t\\tvar objPos = objGeometry.attributes.position;\\r\\n\\r\\n\\t\\t\\t\\tvar objNorm = objGeometry.attributes.normal;\\r\\n\\r\\n\\t\\t\\t\\tvar idx = 0;\\r\\n\\r\\n\\t\\t\\t\\t// for simplicity, ignore index and drawcalls, and render every normal\\r\\n\\r\\n\\t\\t\\t\\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\\r\\n\\r\\n\\t\\t\\t\\t\\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\\r\\n\\r\\n\\t\\t\\t\\t\\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\\r\\n\\r\\n\\t\\t\\t\\t\\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\\r\\n\\r\\n\\t\\t\\t\\t\\tidx = idx + 1;\\r\\n\\r\\n\\t\\t\\t\\t\\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\\r\\n\\r\\n\\t\\t\\t\\t\\tidx = idx + 1;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tposition.needsUpdate = true;\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t}() );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author WestLangley / http://github.com/WestLangley\\r\\n\\t */\\r\\n\\r\\n\\tfunction SpotLightHelper( light, color ) {\\r\\n\\r\\n\\t\\tObject3D.call( this );\\r\\n\\r\\n\\t\\tthis.light = light;\\r\\n\\t\\tthis.light.updateMatrixWorld();\\r\\n\\r\\n\\t\\tthis.matrix = light.matrixWorld;\\r\\n\\t\\tthis.matrixAutoUpdate = false;\\r\\n\\r\\n\\t\\tthis.color = color;\\r\\n\\r\\n\\t\\tvar geometry = new BufferGeometry();\\r\\n\\r\\n\\t\\tvar positions = [\\r\\n\\t\\t\\t0, 0, 0, \\t0, 0, 1,\\r\\n\\t\\t\\t0, 0, 0, \\t1, 0, 1,\\r\\n\\t\\t\\t0, 0, 0,\\t- 1, 0, 1,\\r\\n\\t\\t\\t0, 0, 0, \\t0, 1, 1,\\r\\n\\t\\t\\t0, 0, 0, \\t0, - 1, 1\\r\\n\\t\\t];\\r\\n\\r\\n\\t\\tfor ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\\r\\n\\r\\n\\t\\t\\tvar p1 = ( i / l ) * Math.PI * 2;\\r\\n\\t\\t\\tvar p2 = ( j / l ) * Math.PI * 2;\\r\\n\\r\\n\\t\\t\\tpositions.push(\\r\\n\\t\\t\\t\\tMath.cos( p1 ), Math.sin( p1 ), 1,\\r\\n\\t\\t\\t\\tMath.cos( p2 ), Math.sin( p2 ), 1\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\\r\\n\\r\\n\\t\\tvar material = new LineBasicMaterial( { fog: false } );\\r\\n\\r\\n\\t\\tthis.cone = new LineSegments( geometry, material );\\r\\n\\t\\tthis.add( this.cone );\\r\\n\\r\\n\\t\\tthis.update();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tSpotLightHelper.prototype = Object.create( Object3D.prototype );\\r\\n\\tSpotLightHelper.prototype.constructor = SpotLightHelper;\\r\\n\\r\\n\\tSpotLightHelper.prototype.dispose = function () {\\r\\n\\r\\n\\t\\tthis.cone.geometry.dispose();\\r\\n\\t\\tthis.cone.material.dispose();\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tSpotLightHelper.prototype.update = function () {\\r\\n\\r\\n\\t\\tvar vector = new Vector3();\\r\\n\\t\\tvar vector2 = new Vector3();\\r\\n\\r\\n\\t\\treturn function update() {\\r\\n\\r\\n\\t\\t\\tthis.light.updateMatrixWorld();\\r\\n\\r\\n\\t\\t\\tvar coneLength = this.light.distance ? this.light.distance : 1000;\\r\\n\\t\\t\\tvar coneWidth = coneLength * Math.tan( this.light.angle );\\r\\n\\r\\n\\t\\t\\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\\r\\n\\r\\n\\t\\t\\tvector.setFromMatrixPosition( this.light.matrixWorld );\\r\\n\\t\\t\\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\\r\\n\\r\\n\\t\\t\\tthis.cone.lookAt( vector2.sub( vector ) );\\r\\n\\r\\n\\t\\t\\tif ( this.color !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.cone.material.color.set( this.color );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tthis.cone.material.color.copy( this.light.color );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t}();\\r\\n\\r\\n\\t/**\\r\\n\\t * @author Sean Griffin / http://twitter.com/sgrif\\r\\n\\t * @author Michael Guerrero / http://realitymeltdown.com\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author ikerr / http://verold.com\\r\\n\\t * @author Mugen87 / https://github.com/Mugen87\\r\\n\\t */\\r\\n\\r\\n\\tfunction getBoneList( object ) {\\r\\n\\r\\n\\t\\tvar boneList = [];\\r\\n\\r\\n\\t\\tif ( object && object.isBone ) {\\r\\n\\r\\n\\t\\t\\tboneList.push( object );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < object.children.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\tboneList.push.apply( boneList, getBoneList( object.children[ i ] ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn boneList;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction SkeletonHelper( object ) {\\r\\n\\r\\n\\t\\tvar bones = getBoneList( object );\\r\\n\\r\\n\\t\\tvar geometry = new BufferGeometry();\\r\\n\\r\\n\\t\\tvar vertices = [];\\r\\n\\t\\tvar colors = [];\\r\\n\\r\\n\\t\\tvar color1 = new Color( 0, 0, 1 );\\r\\n\\t\\tvar color2 = new Color( 0, 1, 0 );\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < bones.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar bone = bones[ i ];\\r\\n\\r\\n\\t\\t\\tif ( bone.parent && bone.parent.isBone ) {\\r\\n\\r\\n\\t\\t\\t\\tvertices.push( 0, 0, 0 );\\r\\n\\t\\t\\t\\tvertices.push( 0, 0, 0 );\\r\\n\\t\\t\\t\\tcolors.push( color1.r, color1.g, color1.b );\\r\\n\\t\\t\\t\\tcolors.push( color2.r, color2.g, color2.b );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\t\\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\\r\\n\\r\\n\\t\\tvar material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );\\r\\n\\r\\n\\t\\tLineSegments.call( this, geometry, material );\\r\\n\\r\\n\\t\\tthis.root = object;\\r\\n\\t\\tthis.bones = bones;\\r\\n\\r\\n\\t\\tthis.matrix = object.matrixWorld;\\r\\n\\t\\tthis.matrixAutoUpdate = false;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tSkeletonHelper.prototype = Object.create( LineSegments.prototype );\\r\\n\\tSkeletonHelper.prototype.constructor = SkeletonHelper;\\r\\n\\r\\n\\tSkeletonHelper.prototype.updateMatrixWorld = function () {\\r\\n\\r\\n\\t\\tvar vector = new Vector3();\\r\\n\\r\\n\\t\\tvar boneMatrix = new Matrix4();\\r\\n\\t\\tvar matrixWorldInv = new Matrix4();\\r\\n\\r\\n\\t\\treturn function updateMatrixWorld( force ) {\\r\\n\\r\\n\\t\\t\\tvar bones = this.bones;\\r\\n\\r\\n\\t\\t\\tvar geometry = this.geometry;\\r\\n\\t\\t\\tvar position = geometry.getAttribute( 'position' );\\r\\n\\r\\n\\t\\t\\tmatrixWorldInv.getInverse( this.root.matrixWorld );\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, j = 0; i < bones.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar bone = bones[ i ];\\r\\n\\r\\n\\t\\t\\t\\tif ( bone.parent && bone.parent.isBone ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\\r\\n\\t\\t\\t\\t\\tvector.setFromMatrixPosition( boneMatrix );\\r\\n\\t\\t\\t\\t\\tposition.setXYZ( j, vector.x, vector.y, vector.z );\\r\\n\\r\\n\\t\\t\\t\\t\\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\\r\\n\\t\\t\\t\\t\\tvector.setFromMatrixPosition( boneMatrix );\\r\\n\\t\\t\\t\\t\\tposition.setXYZ( j + 1, vector.x, vector.y, vector.z );\\r\\n\\r\\n\\t\\t\\t\\t\\tj += 2;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tgeometry.getAttribute( 'position' ).needsUpdate = true;\\r\\n\\r\\n\\t\\t\\tObject3D.prototype.updateMatrixWorld.call( this, force );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t}();\\r\\n\\r\\n\\t/**\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction PointLightHelper( light, sphereSize, color ) {\\r\\n\\r\\n\\t\\tthis.light = light;\\r\\n\\t\\tthis.light.updateMatrixWorld();\\r\\n\\r\\n\\t\\tthis.color = color;\\r\\n\\r\\n\\t\\tvar geometry = new SphereBufferGeometry( sphereSize, 4, 2 );\\r\\n\\t\\tvar material = new MeshBasicMaterial( { wireframe: true, fog: false } );\\r\\n\\r\\n\\t\\tMesh.call( this, geometry, material );\\r\\n\\r\\n\\t\\tthis.matrix = this.light.matrixWorld;\\r\\n\\t\\tthis.matrixAutoUpdate = false;\\r\\n\\r\\n\\t\\tthis.update();\\r\\n\\r\\n\\r\\n\\t\\t/*\\r\\n\\t\\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\\r\\n\\t\\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\\r\\n\\r\\n\\t\\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\\r\\n\\t\\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\\r\\n\\r\\n\\t\\tvar d = light.distance;\\r\\n\\r\\n\\t\\tif ( d === 0.0 ) {\\r\\n\\r\\n\\t\\t\\tthis.lightDistance.visible = false;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tthis.lightDistance.scale.set( d, d, d );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.add( this.lightDistance );\\r\\n\\t\\t*/\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tPointLightHelper.prototype = Object.create( Mesh.prototype );\\r\\n\\tPointLightHelper.prototype.constructor = PointLightHelper;\\r\\n\\r\\n\\tPointLightHelper.prototype.dispose = function () {\\r\\n\\r\\n\\t\\tthis.geometry.dispose();\\r\\n\\t\\tthis.material.dispose();\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tPointLightHelper.prototype.update = function () {\\r\\n\\r\\n\\t\\tif ( this.color !== undefined ) {\\r\\n\\r\\n\\t\\t\\tthis.material.color.set( this.color );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tthis.material.color.copy( this.light.color );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t/*\\r\\n\\t\\tvar d = this.light.distance;\\r\\n\\r\\n\\t\\tif ( d === 0.0 ) {\\r\\n\\r\\n\\t\\t\\tthis.lightDistance.visible = false;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tthis.lightDistance.visible = true;\\r\\n\\t\\t\\tthis.lightDistance.scale.set( d, d, d );\\r\\n\\r\\n\\t\\t}\\r\\n\\t\\t*/\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author abelnation / http://github.com/abelnation\\r\\n\\t * @author Mugen87 / http://github.com/Mugen87\\r\\n\\t * @author WestLangley / http://github.com/WestLangley\\r\\n\\t */\\r\\n\\r\\n\\tfunction RectAreaLightHelper( light, color ) {\\r\\n\\r\\n\\t\\tObject3D.call( this );\\r\\n\\r\\n\\t\\tthis.light = light;\\r\\n\\t\\tthis.light.updateMatrixWorld();\\r\\n\\r\\n\\t\\tthis.matrix = light.matrixWorld;\\r\\n\\t\\tthis.matrixAutoUpdate = false;\\r\\n\\r\\n\\t\\tthis.color = color;\\r\\n\\r\\n\\t\\tvar material = new LineBasicMaterial( { fog: false } );\\r\\n\\r\\n\\t\\tvar geometry = new BufferGeometry();\\r\\n\\r\\n\\t\\tgeometry.addAttribute( 'position', new BufferAttribute( new Float32Array( 5 * 3 ), 3 ) );\\r\\n\\r\\n\\t\\tthis.line = new Line( geometry, material );\\r\\n\\t\\tthis.add( this.line );\\r\\n\\r\\n\\r\\n\\t\\tthis.update();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tRectAreaLightHelper.prototype = Object.create( Object3D.prototype );\\r\\n\\tRectAreaLightHelper.prototype.constructor = RectAreaLightHelper;\\r\\n\\r\\n\\tRectAreaLightHelper.prototype.dispose = function () {\\r\\n\\r\\n\\t\\tthis.children[ 0 ].geometry.dispose();\\r\\n\\t\\tthis.children[ 0 ].material.dispose();\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tRectAreaLightHelper.prototype.update = function () {\\r\\n\\r\\n\\t\\t// calculate new dimensions of the helper\\r\\n\\r\\n\\t\\tvar hx = this.light.width * 0.5;\\r\\n\\t\\tvar hy = this.light.height * 0.5;\\r\\n\\r\\n\\t\\tvar position = this.line.geometry.attributes.position;\\r\\n\\t\\tvar array = position.array;\\r\\n\\r\\n\\t\\t// update vertices\\r\\n\\r\\n\\t\\tarray[ 0 ] = hx; array[ 1 ] = - hy; array[ 2 ] = 0;\\r\\n\\t\\tarray[ 3 ] = hx; array[ 4 ] = hy; array[ 5 ] = 0;\\r\\n\\t\\tarray[ 6 ] = - hx; array[ 7 ] = hy; array[ 8 ] = 0;\\r\\n\\t\\tarray[ 9 ] = - hx; array[ 10 ] = - hy; array[ 11 ] = 0;\\r\\n\\t\\tarray[ 12 ] = hx; array[ 13 ] = - hy; array[ 14 ] = 0;\\r\\n\\r\\n\\t\\tposition.needsUpdate = true;\\r\\n\\r\\n\\t\\tif ( this.color !== undefined ) {\\r\\n\\r\\n\\t\\t\\tthis.line.material.color.set( this.color );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tthis.line.material.color.copy( this.light.color );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author Mugen87 / https://github.com/Mugen87\\r\\n\\t */\\r\\n\\r\\n\\tfunction HemisphereLightHelper( light, size, color ) {\\r\\n\\r\\n\\t\\tObject3D.call( this );\\r\\n\\r\\n\\t\\tthis.light = light;\\r\\n\\t\\tthis.light.updateMatrixWorld();\\r\\n\\r\\n\\t\\tthis.matrix = light.matrixWorld;\\r\\n\\t\\tthis.matrixAutoUpdate = false;\\r\\n\\r\\n\\t\\tthis.color = color;\\r\\n\\r\\n\\t\\tvar geometry = new OctahedronBufferGeometry( size );\\r\\n\\t\\tgeometry.rotateY( Math.PI * 0.5 );\\r\\n\\r\\n\\t\\tthis.material = new MeshBasicMaterial( { wireframe: true, fog: false } );\\r\\n\\t\\tif ( this.color === undefined ) this.material.vertexColors = VertexColors;\\r\\n\\r\\n\\t\\tvar position = geometry.getAttribute( 'position' );\\r\\n\\t\\tvar colors = new Float32Array( position.count * 3 );\\r\\n\\r\\n\\t\\tgeometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );\\r\\n\\r\\n\\t\\tthis.add( new Mesh( geometry, this.material ) );\\r\\n\\r\\n\\t\\tthis.update();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tHemisphereLightHelper.prototype = Object.create( Object3D.prototype );\\r\\n\\tHemisphereLightHelper.prototype.constructor = HemisphereLightHelper;\\r\\n\\r\\n\\tHemisphereLightHelper.prototype.dispose = function () {\\r\\n\\r\\n\\t\\tthis.children[ 0 ].geometry.dispose();\\r\\n\\t\\tthis.children[ 0 ].material.dispose();\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tHemisphereLightHelper.prototype.update = function () {\\r\\n\\r\\n\\t\\tvar vector = new Vector3();\\r\\n\\r\\n\\t\\tvar color1 = new Color();\\r\\n\\t\\tvar color2 = new Color();\\r\\n\\r\\n\\t\\treturn function update() {\\r\\n\\r\\n\\t\\t\\tvar mesh = this.children[ 0 ];\\r\\n\\r\\n\\t\\t\\tif ( this.color !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.material.color.set( this.color );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tvar colors = mesh.geometry.getAttribute( 'color' );\\r\\n\\r\\n\\t\\t\\t\\tcolor1.copy( this.light.color );\\r\\n\\t\\t\\t\\tcolor2.copy( this.light.groundColor );\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, l = colors.count; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar color = ( i < ( l / 2 ) ) ? color1 : color2;\\r\\n\\r\\n\\t\\t\\t\\t\\tcolors.setXYZ( i, color.r, color.g, color.b );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tcolors.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tmesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t}();\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction GridHelper( size, divisions, color1, color2 ) {\\r\\n\\r\\n\\t\\tsize = size || 10;\\r\\n\\t\\tdivisions = divisions || 10;\\r\\n\\t\\tcolor1 = new Color( color1 !== undefined ? color1 : 0x444444 );\\r\\n\\t\\tcolor2 = new Color( color2 !== undefined ? color2 : 0x888888 );\\r\\n\\r\\n\\t\\tvar center = divisions / 2;\\r\\n\\t\\tvar step = size / divisions;\\r\\n\\t\\tvar halfSize = size / 2;\\r\\n\\r\\n\\t\\tvar vertices = [], colors = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {\\r\\n\\r\\n\\t\\t\\tvertices.push( - halfSize, 0, k, halfSize, 0, k );\\r\\n\\t\\t\\tvertices.push( k, 0, - halfSize, k, 0, halfSize );\\r\\n\\r\\n\\t\\t\\tvar color = i === center ? color1 : color2;\\r\\n\\r\\n\\t\\t\\tcolor.toArray( colors, j ); j += 3;\\r\\n\\t\\t\\tcolor.toArray( colors, j ); j += 3;\\r\\n\\t\\t\\tcolor.toArray( colors, j ); j += 3;\\r\\n\\t\\t\\tcolor.toArray( colors, j ); j += 3;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar geometry = new BufferGeometry();\\r\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\t\\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\\r\\n\\r\\n\\t\\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\\r\\n\\r\\n\\t\\tLineSegments.call( this, geometry, material );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tGridHelper.prototype = Object.create( LineSegments.prototype );\\r\\n\\tGridHelper.prototype.constructor = GridHelper;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author Mugen87 / http://github.com/Mugen87\\r\\n\\t * @author Hectate / http://www.github.com/Hectate\\r\\n\\t */\\r\\n\\r\\n\\tfunction PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {\\r\\n\\r\\n\\t\\tradius = radius || 10;\\r\\n\\t\\tradials = radials || 16;\\r\\n\\t\\tcircles = circles || 8;\\r\\n\\t\\tdivisions = divisions || 64;\\r\\n\\t\\tcolor1 = new Color( color1 !== undefined ? color1 : 0x444444 );\\r\\n\\t\\tcolor2 = new Color( color2 !== undefined ? color2 : 0x888888 );\\r\\n\\r\\n\\t\\tvar vertices = [];\\r\\n\\t\\tvar colors = [];\\r\\n\\r\\n\\t\\tvar x, z;\\r\\n\\t\\tvar v, i, j, r, color;\\r\\n\\r\\n\\t\\t// create the radials\\r\\n\\r\\n\\t\\tfor ( i = 0; i <= radials; i ++ ) {\\r\\n\\r\\n\\t\\t\\tv = ( i / radials ) * ( Math.PI * 2 );\\r\\n\\r\\n\\t\\t\\tx = Math.sin( v ) * radius;\\r\\n\\t\\t\\tz = Math.cos( v ) * radius;\\r\\n\\r\\n\\t\\t\\tvertices.push( 0, 0, 0 );\\r\\n\\t\\t\\tvertices.push( x, 0, z );\\r\\n\\r\\n\\t\\t\\tcolor = ( i & 1 ) ? color1 : color2;\\r\\n\\r\\n\\t\\t\\tcolors.push( color.r, color.g, color.b );\\r\\n\\t\\t\\tcolors.push( color.r, color.g, color.b );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// create the circles\\r\\n\\r\\n\\t\\tfor ( i = 0; i <= circles; i ++ ) {\\r\\n\\r\\n\\t\\t\\tcolor = ( i & 1 ) ? color1 : color2;\\r\\n\\r\\n\\t\\t\\tr = radius - ( radius / circles * i );\\r\\n\\r\\n\\t\\t\\tfor ( j = 0; j < divisions; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t// first vertex\\r\\n\\r\\n\\t\\t\\t\\tv = ( j / divisions ) * ( Math.PI * 2 );\\r\\n\\r\\n\\t\\t\\t\\tx = Math.sin( v ) * r;\\r\\n\\t\\t\\t\\tz = Math.cos( v ) * r;\\r\\n\\r\\n\\t\\t\\t\\tvertices.push( x, 0, z );\\r\\n\\t\\t\\t\\tcolors.push( color.r, color.g, color.b );\\r\\n\\r\\n\\t\\t\\t\\t// second vertex\\r\\n\\r\\n\\t\\t\\t\\tv = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );\\r\\n\\r\\n\\t\\t\\t\\tx = Math.sin( v ) * r;\\r\\n\\t\\t\\t\\tz = Math.cos( v ) * r;\\r\\n\\r\\n\\t\\t\\t\\tvertices.push( x, 0, z );\\r\\n\\t\\t\\t\\tcolors.push( color.r, color.g, color.b );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar geometry = new BufferGeometry();\\r\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\t\\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\\r\\n\\r\\n\\t\\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\\r\\n\\r\\n\\t\\tLineSegments.call( this, geometry, material );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tPolarGridHelper.prototype = Object.create( LineSegments.prototype );\\r\\n\\tPolarGridHelper.prototype.constructor = PolarGridHelper;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author WestLangley / http://github.com/WestLangley\\r\\n\\t */\\r\\n\\r\\n\\tfunction FaceNormalsHelper( object, size, hex, linewidth ) {\\r\\n\\r\\n\\t\\t// FaceNormalsHelper only supports THREE.Geometry\\r\\n\\r\\n\\t\\tthis.object = object;\\r\\n\\r\\n\\t\\tthis.size = ( size !== undefined ) ? size : 1;\\r\\n\\r\\n\\t\\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\\r\\n\\r\\n\\t\\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tvar nNormals = 0;\\r\\n\\r\\n\\t\\tvar objGeometry = this.object.geometry;\\r\\n\\r\\n\\t\\tif ( objGeometry && objGeometry.isGeometry ) {\\r\\n\\r\\n\\t\\t\\tnNormals = objGeometry.faces.length;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tvar geometry = new BufferGeometry();\\r\\n\\r\\n\\t\\tvar positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );\\r\\n\\r\\n\\t\\tgeometry.addAttribute( 'position', positions );\\r\\n\\r\\n\\t\\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tthis.matrixAutoUpdate = false;\\r\\n\\t\\tthis.update();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tFaceNormalsHelper.prototype = Object.create( LineSegments.prototype );\\r\\n\\tFaceNormalsHelper.prototype.constructor = FaceNormalsHelper;\\r\\n\\r\\n\\tFaceNormalsHelper.prototype.update = ( function () {\\r\\n\\r\\n\\t\\tvar v1 = new Vector3();\\r\\n\\t\\tvar v2 = new Vector3();\\r\\n\\t\\tvar normalMatrix = new Matrix3();\\r\\n\\r\\n\\t\\treturn function update() {\\r\\n\\r\\n\\t\\t\\tthis.object.updateMatrixWorld( true );\\r\\n\\r\\n\\t\\t\\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\\r\\n\\r\\n\\t\\t\\tvar matrixWorld = this.object.matrixWorld;\\r\\n\\r\\n\\t\\t\\tvar position = this.geometry.attributes.position;\\r\\n\\r\\n\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\tvar objGeometry = this.object.geometry;\\r\\n\\r\\n\\t\\t\\tvar vertices = objGeometry.vertices;\\r\\n\\r\\n\\t\\t\\tvar faces = objGeometry.faces;\\r\\n\\r\\n\\t\\t\\tvar idx = 0;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar face = faces[ i ];\\r\\n\\r\\n\\t\\t\\t\\tvar normal = face.normal;\\r\\n\\r\\n\\t\\t\\t\\tv1.copy( vertices[ face.a ] )\\r\\n\\t\\t\\t\\t\\t.add( vertices[ face.b ] )\\r\\n\\t\\t\\t\\t\\t.add( vertices[ face.c ] )\\r\\n\\t\\t\\t\\t\\t.divideScalar( 3 )\\r\\n\\t\\t\\t\\t\\t.applyMatrix4( matrixWorld );\\r\\n\\r\\n\\t\\t\\t\\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\\r\\n\\r\\n\\t\\t\\t\\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\\r\\n\\r\\n\\t\\t\\t\\tidx = idx + 1;\\r\\n\\r\\n\\t\\t\\t\\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\\r\\n\\r\\n\\t\\t\\t\\tidx = idx + 1;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tposition.needsUpdate = true;\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t}() );\\r\\n\\r\\n\\t/**\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author WestLangley / http://github.com/WestLangley\\r\\n\\t */\\r\\n\\r\\n\\tfunction DirectionalLightHelper( light, size, color ) {\\r\\n\\r\\n\\t\\tObject3D.call( this );\\r\\n\\r\\n\\t\\tthis.light = light;\\r\\n\\t\\tthis.light.updateMatrixWorld();\\r\\n\\r\\n\\t\\tthis.matrix = light.matrixWorld;\\r\\n\\t\\tthis.matrixAutoUpdate = false;\\r\\n\\r\\n\\t\\tthis.color = color;\\r\\n\\r\\n\\t\\tif ( size === undefined ) size = 1;\\r\\n\\r\\n\\t\\tvar geometry = new BufferGeometry();\\r\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( [\\r\\n\\t\\t\\t- size, size, 0,\\r\\n\\t\\t\\tsize, size, 0,\\r\\n\\t\\t\\tsize, - size, 0,\\r\\n\\t\\t\\t- size, - size, 0,\\r\\n\\t\\t\\t- size, size, 0\\r\\n\\t\\t], 3 ) );\\r\\n\\r\\n\\t\\tvar material = new LineBasicMaterial( { fog: false } );\\r\\n\\r\\n\\t\\tthis.lightPlane = new Line( geometry, material );\\r\\n\\t\\tthis.add( this.lightPlane );\\r\\n\\r\\n\\t\\tgeometry = new BufferGeometry();\\r\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\\r\\n\\r\\n\\t\\tthis.targetLine = new Line( geometry, material );\\r\\n\\t\\tthis.add( this.targetLine );\\r\\n\\r\\n\\t\\tthis.update();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tDirectionalLightHelper.prototype = Object.create( Object3D.prototype );\\r\\n\\tDirectionalLightHelper.prototype.constructor = DirectionalLightHelper;\\r\\n\\r\\n\\tDirectionalLightHelper.prototype.dispose = function () {\\r\\n\\r\\n\\t\\tthis.lightPlane.geometry.dispose();\\r\\n\\t\\tthis.lightPlane.material.dispose();\\r\\n\\t\\tthis.targetLine.geometry.dispose();\\r\\n\\t\\tthis.targetLine.material.dispose();\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tDirectionalLightHelper.prototype.update = function () {\\r\\n\\r\\n\\t\\tvar v1 = new Vector3();\\r\\n\\t\\tvar v2 = new Vector3();\\r\\n\\t\\tvar v3 = new Vector3();\\r\\n\\r\\n\\t\\treturn function update() {\\r\\n\\r\\n\\t\\t\\tv1.setFromMatrixPosition( this.light.matrixWorld );\\r\\n\\t\\t\\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\\r\\n\\t\\t\\tv3.subVectors( v2, v1 );\\r\\n\\r\\n\\t\\t\\tthis.lightPlane.lookAt( v3 );\\r\\n\\r\\n\\t\\t\\tif ( this.color !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.lightPlane.material.color.set( this.color );\\r\\n\\t\\t\\t\\tthis.targetLine.material.color.set( this.color );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tthis.lightPlane.material.color.copy( this.light.color );\\r\\n\\t\\t\\t\\tthis.targetLine.material.color.copy( this.light.color );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.targetLine.lookAt( v3 );\\r\\n\\t\\t\\tthis.targetLine.scale.z = v3.length();\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t}();\\r\\n\\r\\n\\t/**\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t * @author Mugen87 / https://github.com/Mugen87\\r\\n\\t *\\r\\n\\t *\\t- shows frustum, line of sight and up of the camera\\r\\n\\t *\\t- suitable for fast updates\\r\\n\\t * \\t- based on frustum visualization in lightgl.js shadowmap example\\r\\n\\t *\\t\\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\\r\\n\\t */\\r\\n\\r\\n\\tfunction CameraHelper( camera ) {\\r\\n\\r\\n\\t\\tvar geometry = new BufferGeometry();\\r\\n\\t\\tvar material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );\\r\\n\\r\\n\\t\\tvar vertices = [];\\r\\n\\t\\tvar colors = [];\\r\\n\\r\\n\\t\\tvar pointMap = {};\\r\\n\\r\\n\\t\\t// colors\\r\\n\\r\\n\\t\\tvar colorFrustum = new Color( 0xffaa00 );\\r\\n\\t\\tvar colorCone = new Color( 0xff0000 );\\r\\n\\t\\tvar colorUp = new Color( 0x00aaff );\\r\\n\\t\\tvar colorTarget = new Color( 0xffffff );\\r\\n\\t\\tvar colorCross = new Color( 0x333333 );\\r\\n\\r\\n\\t\\t// near\\r\\n\\r\\n\\t\\taddLine( 'n1', 'n2', colorFrustum );\\r\\n\\t\\taddLine( 'n2', 'n4', colorFrustum );\\r\\n\\t\\taddLine( 'n4', 'n3', colorFrustum );\\r\\n\\t\\taddLine( 'n3', 'n1', colorFrustum );\\r\\n\\r\\n\\t\\t// far\\r\\n\\r\\n\\t\\taddLine( 'f1', 'f2', colorFrustum );\\r\\n\\t\\taddLine( 'f2', 'f4', colorFrustum );\\r\\n\\t\\taddLine( 'f4', 'f3', colorFrustum );\\r\\n\\t\\taddLine( 'f3', 'f1', colorFrustum );\\r\\n\\r\\n\\t\\t// sides\\r\\n\\r\\n\\t\\taddLine( 'n1', 'f1', colorFrustum );\\r\\n\\t\\taddLine( 'n2', 'f2', colorFrustum );\\r\\n\\t\\taddLine( 'n3', 'f3', colorFrustum );\\r\\n\\t\\taddLine( 'n4', 'f4', colorFrustum );\\r\\n\\r\\n\\t\\t// cone\\r\\n\\r\\n\\t\\taddLine( 'p', 'n1', colorCone );\\r\\n\\t\\taddLine( 'p', 'n2', colorCone );\\r\\n\\t\\taddLine( 'p', 'n3', colorCone );\\r\\n\\t\\taddLine( 'p', 'n4', colorCone );\\r\\n\\r\\n\\t\\t// up\\r\\n\\r\\n\\t\\taddLine( 'u1', 'u2', colorUp );\\r\\n\\t\\taddLine( 'u2', 'u3', colorUp );\\r\\n\\t\\taddLine( 'u3', 'u1', colorUp );\\r\\n\\r\\n\\t\\t// target\\r\\n\\r\\n\\t\\taddLine( 'c', 't', colorTarget );\\r\\n\\t\\taddLine( 'p', 'c', colorCross );\\r\\n\\r\\n\\t\\t// cross\\r\\n\\r\\n\\t\\taddLine( 'cn1', 'cn2', colorCross );\\r\\n\\t\\taddLine( 'cn3', 'cn4', colorCross );\\r\\n\\r\\n\\t\\taddLine( 'cf1', 'cf2', colorCross );\\r\\n\\t\\taddLine( 'cf3', 'cf4', colorCross );\\r\\n\\r\\n\\t\\tfunction addLine( a, b, color ) {\\r\\n\\r\\n\\t\\t\\taddPoint( a, color );\\r\\n\\t\\t\\taddPoint( b, color );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction addPoint( id, color ) {\\r\\n\\r\\n\\t\\t\\tvertices.push( 0, 0, 0 );\\r\\n\\t\\t\\tcolors.push( color.r, color.g, color.b );\\r\\n\\r\\n\\t\\t\\tif ( pointMap[ id ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tpointMap[ id ] = [];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tpointMap[ id ].push( ( vertices.length / 3 ) - 1 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\t\\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\\r\\n\\r\\n\\t\\tLineSegments.call( this, geometry, material );\\r\\n\\r\\n\\t\\tthis.camera = camera;\\r\\n\\t\\tif ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\\r\\n\\r\\n\\t\\tthis.matrix = camera.matrixWorld;\\r\\n\\t\\tthis.matrixAutoUpdate = false;\\r\\n\\r\\n\\t\\tthis.pointMap = pointMap;\\r\\n\\r\\n\\t\\tthis.update();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tCameraHelper.prototype = Object.create( LineSegments.prototype );\\r\\n\\tCameraHelper.prototype.constructor = CameraHelper;\\r\\n\\r\\n\\tCameraHelper.prototype.update = function () {\\r\\n\\r\\n\\t\\tvar geometry, pointMap;\\r\\n\\r\\n\\t\\tvar vector = new Vector3();\\r\\n\\t\\tvar camera = new Camera();\\r\\n\\r\\n\\t\\tfunction setPoint( point, x, y, z ) {\\r\\n\\r\\n\\t\\t\\tvector.set( x, y, z ).unproject( camera );\\r\\n\\r\\n\\t\\t\\tvar points = pointMap[ point ];\\r\\n\\r\\n\\t\\t\\tif ( points !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tvar position = geometry.getAttribute( 'position' );\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tposition.setXYZ( points[ i ], vector.x, vector.y, vector.z );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn function update() {\\r\\n\\r\\n\\t\\t\\tgeometry = this.geometry;\\r\\n\\t\\t\\tpointMap = this.pointMap;\\r\\n\\r\\n\\t\\t\\tvar w = 1, h = 1;\\r\\n\\r\\n\\t\\t\\t// we need just camera projection matrix\\r\\n\\t\\t\\t// world matrix must be identity\\r\\n\\r\\n\\t\\t\\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\\r\\n\\r\\n\\t\\t\\t// center / target\\r\\n\\r\\n\\t\\t\\tsetPoint( 'c', 0, 0, - 1 );\\r\\n\\t\\t\\tsetPoint( 't', 0, 0, 1 );\\r\\n\\r\\n\\t\\t\\t// near\\r\\n\\r\\n\\t\\t\\tsetPoint( 'n1', - w, - h, - 1 );\\r\\n\\t\\t\\tsetPoint( 'n2', w, - h, - 1 );\\r\\n\\t\\t\\tsetPoint( 'n3', - w, h, - 1 );\\r\\n\\t\\t\\tsetPoint( 'n4', w, h, - 1 );\\r\\n\\r\\n\\t\\t\\t// far\\r\\n\\r\\n\\t\\t\\tsetPoint( 'f1', - w, - h, 1 );\\r\\n\\t\\t\\tsetPoint( 'f2', w, - h, 1 );\\r\\n\\t\\t\\tsetPoint( 'f3', - w, h, 1 );\\r\\n\\t\\t\\tsetPoint( 'f4', w, h, 1 );\\r\\n\\r\\n\\t\\t\\t// up\\r\\n\\r\\n\\t\\t\\tsetPoint( 'u1', w * 0.7, h * 1.1, - 1 );\\r\\n\\t\\t\\tsetPoint( 'u2', - w * 0.7, h * 1.1, - 1 );\\r\\n\\t\\t\\tsetPoint( 'u3', 0, h * 2, - 1 );\\r\\n\\r\\n\\t\\t\\t// cross\\r\\n\\r\\n\\t\\t\\tsetPoint( 'cf1', - w, 0, 1 );\\r\\n\\t\\t\\tsetPoint( 'cf2', w, 0, 1 );\\r\\n\\t\\t\\tsetPoint( 'cf3', 0, - h, 1 );\\r\\n\\t\\t\\tsetPoint( 'cf4', 0, h, 1 );\\r\\n\\r\\n\\t\\t\\tsetPoint( 'cn1', - w, 0, - 1 );\\r\\n\\t\\t\\tsetPoint( 'cn2', w, 0, - 1 );\\r\\n\\t\\t\\tsetPoint( 'cn3', 0, - h, - 1 );\\r\\n\\t\\t\\tsetPoint( 'cn4', 0, h, - 1 );\\r\\n\\r\\n\\t\\t\\tgeometry.getAttribute( 'position' ).needsUpdate = true;\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t}();\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t * @author Mugen87 / http://github.com/Mugen87\\r\\n\\t */\\r\\n\\r\\n\\tfunction BoxHelper( object, color ) {\\r\\n\\r\\n\\t\\tthis.object = object;\\r\\n\\r\\n\\t\\tif ( color === undefined ) color = 0xffff00;\\r\\n\\r\\n\\t\\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\\r\\n\\t\\tvar positions = new Float32Array( 8 * 3 );\\r\\n\\r\\n\\t\\tvar geometry = new BufferGeometry();\\r\\n\\t\\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\\r\\n\\t\\tgeometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );\\r\\n\\r\\n\\t\\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );\\r\\n\\r\\n\\t\\tthis.matrixAutoUpdate = false;\\r\\n\\r\\n\\t\\tthis.update();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tBoxHelper.prototype = Object.create( LineSegments.prototype );\\r\\n\\tBoxHelper.prototype.constructor = BoxHelper;\\r\\n\\r\\n\\tBoxHelper.prototype.update = ( function () {\\r\\n\\r\\n\\t\\tvar box = new Box3();\\r\\n\\r\\n\\t\\treturn function update( object ) {\\r\\n\\r\\n\\t\\t\\tif ( object !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( this.object !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tbox.setFromObject( this.object );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( box.isEmpty() ) return;\\r\\n\\r\\n\\t\\t\\tvar min = box.min;\\r\\n\\t\\t\\tvar max = box.max;\\r\\n\\r\\n\\t\\t\\t/*\\r\\n\\t\\t\\t  5____4\\r\\n\\t\\t\\t1/___0/|\\r\\n\\t\\t\\t| 6__|_7\\r\\n\\t\\t\\t2/___3/\\r\\n\\r\\n\\t\\t\\t0: max.x, max.y, max.z\\r\\n\\t\\t\\t1: min.x, max.y, max.z\\r\\n\\t\\t\\t2: min.x, min.y, max.z\\r\\n\\t\\t\\t3: max.x, min.y, max.z\\r\\n\\t\\t\\t4: max.x, max.y, min.z\\r\\n\\t\\t\\t5: min.x, max.y, min.z\\r\\n\\t\\t\\t6: min.x, min.y, min.z\\r\\n\\t\\t\\t7: max.x, min.y, min.z\\r\\n\\t\\t\\t*/\\r\\n\\r\\n\\t\\t\\tvar position = this.geometry.attributes.position;\\r\\n\\t\\t\\tvar array = position.array;\\r\\n\\r\\n\\t\\t\\tarray[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;\\r\\n\\t\\t\\tarray[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;\\r\\n\\t\\t\\tarray[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;\\r\\n\\t\\t\\tarray[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\\r\\n\\t\\t\\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\\r\\n\\t\\t\\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\\r\\n\\t\\t\\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\\r\\n\\t\\t\\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\\r\\n\\r\\n\\t\\t\\tposition.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\tthis.geometry.computeBoundingSphere();\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t} )();\\r\\n\\r\\n\\tBoxHelper.prototype.setFromObject = function ( object ) {\\r\\n\\r\\n\\t\\tthis.object = object;\\r\\n\\t\\tthis.update();\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author WestLangley / http://github.com/WestLangley\\r\\n\\t */\\r\\n\\r\\n\\tfunction Box3Helper( box, hex ) {\\r\\n\\r\\n\\t\\tthis.type = 'Box3Helper';\\r\\n\\r\\n\\t\\tthis.box = box;\\r\\n\\r\\n\\t\\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\\r\\n\\r\\n\\t\\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\\r\\n\\r\\n\\t\\tvar positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];\\r\\n\\r\\n\\t\\tvar geometry = new BufferGeometry();\\r\\n\\r\\n\\t\\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\\r\\n\\r\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\\r\\n\\r\\n\\t\\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );\\r\\n\\r\\n\\t\\tthis.geometry.computeBoundingSphere();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tBox3Helper.prototype = Object.create( LineSegments.prototype );\\r\\n\\tBox3Helper.prototype.constructor = Box3Helper;\\r\\n\\r\\n\\tBox3Helper.prototype.updateMatrixWorld = function ( force ) {\\r\\n\\r\\n\\t\\tvar box = this.box;\\r\\n\\r\\n\\t\\tif ( box.isEmpty() ) return;\\r\\n\\r\\n\\t\\tbox.getCenter( this.position );\\r\\n\\r\\n\\t\\tbox.getSize( this.scale );\\r\\n\\r\\n\\t\\tthis.scale.multiplyScalar( 0.5 );\\r\\n\\r\\n\\t\\tObject3D.prototype.updateMatrixWorld.call( this, force );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author WestLangley / http://github.com/WestLangley\\r\\n\\t */\\r\\n\\r\\n\\tfunction PlaneHelper( plane, size, hex ) {\\r\\n\\r\\n\\t\\tthis.type = 'PlaneHelper';\\r\\n\\r\\n\\t\\tthis.plane = plane;\\r\\n\\r\\n\\t\\tthis.size = ( size === undefined ) ? 1 : size;\\r\\n\\r\\n\\t\\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\\r\\n\\r\\n\\t\\tvar positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];\\r\\n\\r\\n\\t\\tvar geometry = new BufferGeometry();\\r\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\\r\\n\\t\\tgeometry.computeBoundingSphere();\\r\\n\\r\\n\\t\\tLine.call( this, geometry, new LineBasicMaterial( { color: color } ) );\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tvar positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];\\r\\n\\r\\n\\t\\tvar geometry2 = new BufferGeometry();\\r\\n\\t\\tgeometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );\\r\\n\\t\\tgeometry2.computeBoundingSphere();\\r\\n\\r\\n\\t\\tthis.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false } ) ) );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tPlaneHelper.prototype = Object.create( Line.prototype );\\r\\n\\tPlaneHelper.prototype.constructor = PlaneHelper;\\r\\n\\r\\n\\tPlaneHelper.prototype.updateMatrixWorld = function ( force ) {\\r\\n\\r\\n\\t\\tvar scale = - this.plane.constant;\\r\\n\\r\\n\\t\\tif ( Math.abs( scale ) < 1e-8 ) scale = 1e-8; // sign does not matter\\r\\n\\r\\n\\t\\tthis.scale.set( 0.5 * this.size, 0.5 * this.size, scale );\\r\\n\\r\\n\\t\\tthis.lookAt( this.plane.normal );\\r\\n\\r\\n\\t\\tObject3D.prototype.updateMatrixWorld.call( this, force );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author WestLangley / http://github.com/WestLangley\\r\\n\\t * @author zz85 / http://github.com/zz85\\r\\n\\t * @author bhouston / http://clara.io\\r\\n\\t *\\r\\n\\t * Creates an arrow for visualizing directions\\r\\n\\t *\\r\\n\\t * Parameters:\\r\\n\\t *  dir - Vector3\\r\\n\\t *  origin - Vector3\\r\\n\\t *  length - Number\\r\\n\\t *  color - color in hex value\\r\\n\\t *  headLength - Number\\r\\n\\t *  headWidth - Number\\r\\n\\t */\\r\\n\\r\\n\\tvar lineGeometry;\\r\\n\\tvar coneGeometry;\\r\\n\\r\\n\\tfunction ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\\r\\n\\r\\n\\t\\t// dir is assumed to be normalized\\r\\n\\r\\n\\t\\tObject3D.call( this );\\r\\n\\r\\n\\t\\tif ( color === undefined ) color = 0xffff00;\\r\\n\\t\\tif ( length === undefined ) length = 1;\\r\\n\\t\\tif ( headLength === undefined ) headLength = 0.2 * length;\\r\\n\\t\\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\\r\\n\\r\\n\\t\\tif ( lineGeometry === undefined ) {\\r\\n\\r\\n\\t\\t\\tlineGeometry = new BufferGeometry();\\r\\n\\t\\t\\tlineGeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\\r\\n\\r\\n\\t\\t\\tconeGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );\\r\\n\\t\\t\\tconeGeometry.translate( 0, - 0.5, 0 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.position.copy( origin );\\r\\n\\r\\n\\t\\tthis.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );\\r\\n\\t\\tthis.line.matrixAutoUpdate = false;\\r\\n\\t\\tthis.add( this.line );\\r\\n\\r\\n\\t\\tthis.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );\\r\\n\\t\\tthis.cone.matrixAutoUpdate = false;\\r\\n\\t\\tthis.add( this.cone );\\r\\n\\r\\n\\t\\tthis.setDirection( dir );\\r\\n\\t\\tthis.setLength( length, headLength, headWidth );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tArrowHelper.prototype = Object.create( Object3D.prototype );\\r\\n\\tArrowHelper.prototype.constructor = ArrowHelper;\\r\\n\\r\\n\\tArrowHelper.prototype.setDirection = ( function () {\\r\\n\\r\\n\\t\\tvar axis = new Vector3();\\r\\n\\t\\tvar radians;\\r\\n\\r\\n\\t\\treturn function setDirection( dir ) {\\r\\n\\r\\n\\t\\t\\t// dir is assumed to be normalized\\r\\n\\r\\n\\t\\t\\tif ( dir.y > 0.99999 ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.quaternion.set( 0, 0, 0, 1 );\\r\\n\\r\\n\\t\\t\\t} else if ( dir.y < - 0.99999 ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.quaternion.set( 1, 0, 0, 0 );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\taxis.set( dir.z, 0, - dir.x ).normalize();\\r\\n\\r\\n\\t\\t\\t\\tradians = Math.acos( dir.y );\\r\\n\\r\\n\\t\\t\\t\\tthis.quaternion.setFromAxisAngle( axis, radians );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t}() );\\r\\n\\r\\n\\tArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\\r\\n\\r\\n\\t\\tif ( headLength === undefined ) headLength = 0.2 * length;\\r\\n\\t\\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\\r\\n\\r\\n\\t\\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\\r\\n\\t\\tthis.line.updateMatrix();\\r\\n\\r\\n\\t\\tthis.cone.scale.set( headWidth, headLength, headWidth );\\r\\n\\t\\tthis.cone.position.y = length;\\r\\n\\t\\tthis.cone.updateMatrix();\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tArrowHelper.prototype.setColor = function ( color ) {\\r\\n\\r\\n\\t\\tthis.line.material.color.copy( color );\\r\\n\\t\\tthis.cone.material.color.copy( color );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author sroucheray / http://sroucheray.org/\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction AxesHelper( size ) {\\r\\n\\r\\n\\t\\tsize = size || 1;\\r\\n\\r\\n\\t\\tvar vertices = [\\r\\n\\t\\t\\t0, 0, 0,\\tsize, 0, 0,\\r\\n\\t\\t\\t0, 0, 0,\\t0, size, 0,\\r\\n\\t\\t\\t0, 0, 0,\\t0, 0, size\\r\\n\\t\\t];\\r\\n\\r\\n\\t\\tvar colors = [\\r\\n\\t\\t\\t1, 0, 0,\\t1, 0.6, 0,\\r\\n\\t\\t\\t0, 1, 0,\\t0.6, 1, 0,\\r\\n\\t\\t\\t0, 0, 1,\\t0, 0.6, 1\\r\\n\\t\\t];\\r\\n\\r\\n\\t\\tvar geometry = new BufferGeometry();\\r\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\t\\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\\r\\n\\r\\n\\t\\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\\r\\n\\r\\n\\t\\tLineSegments.call( this, geometry, material );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tAxesHelper.prototype = Object.create( LineSegments.prototype );\\r\\n\\tAxesHelper.prototype.constructor = AxesHelper;\\r\\n\\r\\n\\t/**\\r\\n\\t * @author alteredq / http://alteredqualia.com/\\r\\n\\t */\\r\\n\\r\\n\\tvar SceneUtils = {\\r\\n\\r\\n\\t\\tcreateMultiMaterialObject: function ( geometry, materials ) {\\r\\n\\r\\n\\t\\t\\tvar group = new Group();\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tgroup.add( new Mesh( geometry, materials[ i ] ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn group;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tdetach: function ( child, parent, scene ) {\\r\\n\\r\\n\\t\\t\\tchild.applyMatrix( parent.matrixWorld );\\r\\n\\t\\t\\tparent.remove( child );\\r\\n\\t\\t\\tscene.add( child );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tattach: function ( child, scene, parent ) {\\r\\n\\r\\n\\t\\t\\tchild.applyMatrix( new Matrix4().getInverse( parent.matrixWorld ) );\\r\\n\\r\\n\\t\\t\\tscene.remove( child );\\r\\n\\t\\t\\tparent.add( child );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/**\\r\\n\\t * @author mrdoob / http://mrdoob.com/\\r\\n\\t */\\r\\n\\r\\n\\tfunction Face4( a, b, c, d, normal, color, materialIndex ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\\r\\n\\t\\treturn new Face3( a, b, c, normal, color, materialIndex );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tvar LineStrip = 0;\\r\\n\\r\\n\\tvar LinePieces = 1;\\r\\n\\r\\n\\tfunction MeshFaceMaterial( materials ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );\\r\\n\\t\\treturn materials;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction MultiMaterial( materials ) {\\r\\n\\r\\n\\t\\tif ( materials === undefined ) materials = [];\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );\\r\\n\\t\\tmaterials.isMultiMaterial = true;\\r\\n\\t\\tmaterials.materials = materials;\\r\\n\\t\\tmaterials.clone = function () {\\r\\n\\r\\n\\t\\t\\treturn materials.slice();\\r\\n\\r\\n\\t\\t};\\r\\n\\t\\treturn materials;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction PointCloud( geometry, material ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\\r\\n\\t\\treturn new Points( geometry, material );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction Particle( material ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );\\r\\n\\t\\treturn new Sprite( material );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction ParticleSystem( geometry, material ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\\r\\n\\t\\treturn new Points( geometry, material );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction PointCloudMaterial( parameters ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\\r\\n\\t\\treturn new PointsMaterial( parameters );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction ParticleBasicMaterial( parameters ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\\r\\n\\t\\treturn new PointsMaterial( parameters );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction ParticleSystemMaterial( parameters ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\\r\\n\\t\\treturn new PointsMaterial( parameters );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction Vertex( x, y, z ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\\r\\n\\t\\treturn new Vector3( x, y, z );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tfunction DynamicBufferAttribute( array, itemSize ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\\r\\n\\t\\treturn new BufferAttribute( array, itemSize ).setDynamic( true );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction Int8Attribute( array, itemSize ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );\\r\\n\\t\\treturn new Int8BufferAttribute( array, itemSize );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction Uint8Attribute( array, itemSize ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );\\r\\n\\t\\treturn new Uint8BufferAttribute( array, itemSize );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction Uint8ClampedAttribute( array, itemSize ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );\\r\\n\\t\\treturn new Uint8ClampedBufferAttribute( array, itemSize );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction Int16Attribute( array, itemSize ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );\\r\\n\\t\\treturn new Int16BufferAttribute( array, itemSize );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction Uint16Attribute( array, itemSize ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );\\r\\n\\t\\treturn new Uint16BufferAttribute( array, itemSize );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction Int32Attribute( array, itemSize ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );\\r\\n\\t\\treturn new Int32BufferAttribute( array, itemSize );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction Uint32Attribute( array, itemSize ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );\\r\\n\\t\\treturn new Uint32BufferAttribute( array, itemSize );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction Float32Attribute( array, itemSize ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );\\r\\n\\t\\treturn new Float32BufferAttribute( array, itemSize );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction Float64Attribute( array, itemSize ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );\\r\\n\\t\\treturn new Float64BufferAttribute( array, itemSize );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tCurve.create = function ( construct, getPoint ) {\\r\\n\\r\\n\\t\\tconsole.log( 'THREE.Curve.create() has been deprecated' );\\r\\n\\r\\n\\t\\tconstruct.prototype = Object.create( Curve.prototype );\\r\\n\\t\\tconstruct.prototype.constructor = construct;\\r\\n\\t\\tconstruct.prototype.getPoint = getPoint;\\r\\n\\r\\n\\t\\treturn construct;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tObject.assign( CurvePath.prototype, {\\r\\n\\r\\n\\t\\tcreatePointsGeometry: function ( divisions ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );\\r\\n\\r\\n\\t\\t\\t// generate geometry from path points (for Line or Points objects)\\r\\n\\r\\n\\t\\t\\tvar pts = this.getPoints( divisions );\\r\\n\\t\\t\\treturn this.createGeometry( pts );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcreateSpacedPointsGeometry: function ( divisions ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );\\r\\n\\r\\n\\t\\t\\t// generate geometry from equidistant sampling along the path\\r\\n\\r\\n\\t\\t\\tvar pts = this.getSpacedPoints( divisions );\\r\\n\\t\\t\\treturn this.createGeometry( pts );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcreateGeometry: function ( points ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );\\r\\n\\r\\n\\t\\t\\tvar geometry = new Geometry();\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar point = points[ i ];\\r\\n\\t\\t\\t\\tgeometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn geometry;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tObject.assign( Path.prototype, {\\r\\n\\r\\n\\t\\tfromPoints: function ( points ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );\\r\\n\\t\\t\\tthis.setFromPoints( points );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tfunction ClosedSplineCurve3( points ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );\\r\\n\\r\\n\\t\\tCatmullRomCurve3.call( this, points );\\r\\n\\t\\tthis.type = 'catmullrom';\\r\\n\\t\\tthis.closed = true;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tfunction SplineCurve3( points ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );\\r\\n\\r\\n\\t\\tCatmullRomCurve3.call( this, points );\\r\\n\\t\\tthis.type = 'catmullrom';\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tfunction Spline( points ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );\\r\\n\\r\\n\\t\\tCatmullRomCurve3.call( this, points );\\r\\n\\t\\tthis.type = 'catmullrom';\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tSpline.prototype = Object.create( CatmullRomCurve3.prototype );\\r\\n\\r\\n\\tObject.assign( Spline.prototype, {\\r\\n\\r\\n\\t\\tinitFromArray: function ( /* a */ ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.Spline: .initFromArray() has been removed.' );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tgetControlPointsArray: function ( /* optionalTarget */ ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\treparametrizeByArcLength: function ( /* samplingCoef */ ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tfunction AxisHelper( size ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );\\r\\n\\t\\treturn new AxesHelper( size );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction BoundingBoxHelper( object, color ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );\\r\\n\\t\\treturn new BoxHelper( object, color );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction EdgesHelper( object, hex ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );\\r\\n\\t\\treturn new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tGridHelper.prototype.setColors = function () {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tSkeletonHelper.prototype.update = function () {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tfunction WireframeHelper( object, hex ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );\\r\\n\\t\\treturn new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tObject.assign( Loader.prototype, {\\r\\n\\r\\n\\t\\textractUrlBase: function ( url ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );\\r\\n\\t\\t\\treturn LoaderUtils.extractUrlBase( url );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tfunction XHRLoader( manager ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );\\r\\n\\t\\treturn new FileLoader( manager );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction BinaryTextureLoader( manager ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );\\r\\n\\t\\treturn new DataTextureLoader( manager );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tObject.assign( Box2.prototype, {\\r\\n\\r\\n\\t\\tcenter: function ( optionalTarget ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );\\r\\n\\t\\t\\treturn this.getCenter( optionalTarget );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tempty: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\\r\\n\\t\\t\\treturn this.isEmpty();\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tisIntersectionBox: function ( box ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\\r\\n\\t\\t\\treturn this.intersectsBox( box );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tsize: function ( optionalTarget ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );\\r\\n\\t\\t\\treturn this.getSize( optionalTarget );\\r\\n\\r\\n\\t\\t}\\r\\n\\t} );\\r\\n\\r\\n\\tObject.assign( Box3.prototype, {\\r\\n\\r\\n\\t\\tcenter: function ( optionalTarget ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );\\r\\n\\t\\t\\treturn this.getCenter( optionalTarget );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tempty: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\\r\\n\\t\\t\\treturn this.isEmpty();\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tisIntersectionBox: function ( box ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\\r\\n\\t\\t\\treturn this.intersectsBox( box );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tisIntersectionSphere: function ( sphere ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\\r\\n\\t\\t\\treturn this.intersectsSphere( sphere );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tsize: function ( optionalTarget ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );\\r\\n\\t\\t\\treturn this.getSize( optionalTarget );\\r\\n\\r\\n\\t\\t}\\r\\n\\t} );\\r\\n\\r\\n\\tLine3.prototype.center = function ( optionalTarget ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );\\r\\n\\t\\treturn this.getCenter( optionalTarget );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tObject.assign( _Math, {\\r\\n\\r\\n\\t\\trandom16: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );\\r\\n\\t\\t\\treturn Math.random();\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tnearestPowerOfTwo: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );\\r\\n\\t\\t\\treturn _Math.floorPowerOfTwo( value );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tnextPowerOfTwo: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );\\r\\n\\t\\t\\treturn _Math.ceilPowerOfTwo( value );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tObject.assign( Matrix3.prototype, {\\r\\n\\r\\n\\t\\tflattenToArrayOffset: function ( array, offset ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( \\\"THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.\\\" );\\r\\n\\t\\t\\treturn this.toArray( array, offset );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tmultiplyVector3: function ( vector ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\\r\\n\\t\\t\\treturn vector.applyMatrix3( this );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tmultiplyVector3Array: function ( /* a */ ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tapplyToBuffer: function ( buffer /*, offset, length */ ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );\\r\\n\\t\\t\\treturn this.applyToBufferAttribute( buffer );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tapplyToVector3Array: function ( /* array, offset, length */ ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tObject.assign( Matrix4.prototype, {\\r\\n\\r\\n\\t\\textractPosition: function ( m ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\\r\\n\\t\\t\\treturn this.copyPosition( m );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tflattenToArrayOffset: function ( array, offset ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( \\\"THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.\\\" );\\r\\n\\t\\t\\treturn this.toArray( array, offset );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tgetPosition: function () {\\r\\n\\r\\n\\t\\t\\tvar v1;\\r\\n\\r\\n\\t\\t\\treturn function getPosition() {\\r\\n\\r\\n\\t\\t\\t\\tif ( v1 === undefined ) v1 = new Vector3();\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\\r\\n\\t\\t\\t\\treturn v1.setFromMatrixColumn( this, 3 );\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}(),\\r\\n\\t\\tsetRotationFromQuaternion: function ( q ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\\r\\n\\t\\t\\treturn this.makeRotationFromQuaternion( q );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tmultiplyToArray: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tmultiplyVector3: function ( vector ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\\r\\n\\t\\t\\treturn vector.applyMatrix4( this );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tmultiplyVector4: function ( vector ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\\r\\n\\t\\t\\treturn vector.applyMatrix4( this );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tmultiplyVector3Array: function ( /* a */ ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\trotateAxis: function ( v ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\\r\\n\\t\\t\\tv.transformDirection( this );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tcrossVector: function ( vector ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\\r\\n\\t\\t\\treturn vector.applyMatrix4( this );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\ttranslate: function () {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\trotateX: function () {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\trotateY: function () {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\trotateZ: function () {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\trotateByAxis: function () {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tapplyToBuffer: function ( buffer /*, offset, length */ ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );\\r\\n\\t\\t\\treturn this.applyToBufferAttribute( buffer );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tapplyToVector3Array: function ( /* array, offset, length */ ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );\\r\\n\\t\\t\\treturn this.makePerspective( left, right, top, bottom, near, far );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tPlane.prototype.isIntersectionLine = function ( line ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\\r\\n\\t\\treturn this.intersectsLine( line );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tQuaternion.prototype.multiplyVector3 = function ( vector ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\\r\\n\\t\\treturn vector.applyQuaternion( this );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tObject.assign( Ray.prototype, {\\r\\n\\r\\n\\t\\tisIntersectionBox: function ( box ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\\r\\n\\t\\t\\treturn this.intersectsBox( box );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tisIntersectionPlane: function ( plane ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\\r\\n\\t\\t\\treturn this.intersectsPlane( plane );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tisIntersectionSphere: function ( sphere ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\\r\\n\\t\\t\\treturn this.intersectsSphere( sphere );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tObject.assign( Shape.prototype, {\\r\\n\\r\\n\\t\\textractAllPoints: function ( divisions ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );\\r\\n\\t\\t\\treturn this.extractPoints( divisions );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\textrude: function ( options ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );\\r\\n\\t\\t\\treturn new ExtrudeGeometry( this, options );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tmakeGeometry: function ( options ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );\\r\\n\\t\\t\\treturn new ShapeGeometry( this, options );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tObject.assign( Vector2.prototype, {\\r\\n\\r\\n\\t\\tfromAttribute: function ( attribute, index, offset ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );\\r\\n\\t\\t\\treturn this.fromBufferAttribute( attribute, index, offset );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tdistanceToManhattan: function ( v ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );\\r\\n\\t\\t\\treturn this.manhattanDistanceTo( v );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tlengthManhattan: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );\\r\\n\\t\\t\\treturn this.manhattanLength();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tObject.assign( Vector3.prototype, {\\r\\n\\r\\n\\t\\tsetEulerFromRotationMatrix: function () {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tsetEulerFromQuaternion: function () {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tgetPositionFromMatrix: function ( m ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\\r\\n\\t\\t\\treturn this.setFromMatrixPosition( m );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tgetScaleFromMatrix: function ( m ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\\r\\n\\t\\t\\treturn this.setFromMatrixScale( m );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tgetColumnFromMatrix: function ( index, matrix ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\\r\\n\\t\\t\\treturn this.setFromMatrixColumn( matrix, index );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tapplyProjection: function ( m ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );\\r\\n\\t\\t\\treturn this.applyMatrix4( m );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tfromAttribute: function ( attribute, index, offset ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );\\r\\n\\t\\t\\treturn this.fromBufferAttribute( attribute, index, offset );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tdistanceToManhattan: function ( v ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );\\r\\n\\t\\t\\treturn this.manhattanDistanceTo( v );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tlengthManhattan: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );\\r\\n\\t\\t\\treturn this.manhattanLength();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tObject.assign( Vector4.prototype, {\\r\\n\\r\\n\\t\\tfromAttribute: function ( attribute, index, offset ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );\\r\\n\\t\\t\\treturn this.fromBufferAttribute( attribute, index, offset );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tlengthManhattan: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );\\r\\n\\t\\t\\treturn this.manhattanLength();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tGeometry.prototype.computeTangents = function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Geometry: .computeTangents() has been removed.' );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tObject.assign( Object3D.prototype, {\\r\\n\\r\\n\\t\\tgetChildByName: function ( name ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\\r\\n\\t\\t\\treturn this.getObjectByName( name );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\trenderDepth: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\ttranslate: function ( distance, axis ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\\r\\n\\t\\t\\treturn this.translateOnAxis( axis, distance );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tObject.defineProperties( Object3D.prototype, {\\r\\n\\r\\n\\t\\teulerOrder: {\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\\r\\n\\t\\t\\t\\treturn this.rotation.order;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\\r\\n\\t\\t\\t\\tthis.rotation.order = value;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\tuseQuaternion: {\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tset: function () {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tObject.defineProperties( LOD.prototype, {\\r\\n\\r\\n\\t\\tobjects: {\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\\r\\n\\t\\t\\t\\treturn this.levels;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tObject.defineProperty( Skeleton.prototype, 'useVertexTexture', {\\r\\n\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tObject.defineProperty( Curve.prototype, '__arcLengthDivisions', {\\r\\n\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );\\r\\n\\t\\t\\treturn this.arcLengthDivisions;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );\\r\\n\\t\\t\\tthis.arcLengthDivisions = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tPerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {\\r\\n\\r\\n\\t\\tconsole.warn( \\\"THREE.PerspectiveCamera.setLens is deprecated. \\\" +\\r\\n\\t\\t\\t\\t\\\"Use .setFocalLength and .filmGauge for a photographic setup.\\\" );\\r\\n\\r\\n\\t\\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\\r\\n\\t\\tthis.setFocalLength( focalLength );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tObject.defineProperties( Light.prototype, {\\r\\n\\t\\tonlyShadow: {\\r\\n\\t\\t\\tset: function () {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\tshadowCameraFov: {\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\\r\\n\\t\\t\\t\\tthis.shadow.camera.fov = value;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\tshadowCameraLeft: {\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\\r\\n\\t\\t\\t\\tthis.shadow.camera.left = value;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\tshadowCameraRight: {\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\\r\\n\\t\\t\\t\\tthis.shadow.camera.right = value;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\tshadowCameraTop: {\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\\r\\n\\t\\t\\t\\tthis.shadow.camera.top = value;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\tshadowCameraBottom: {\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\\r\\n\\t\\t\\t\\tthis.shadow.camera.bottom = value;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\tshadowCameraNear: {\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\\r\\n\\t\\t\\t\\tthis.shadow.camera.near = value;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\tshadowCameraFar: {\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\\r\\n\\t\\t\\t\\tthis.shadow.camera.far = value;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\tshadowCameraVisible: {\\r\\n\\t\\t\\tset: function () {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\tshadowBias: {\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\\r\\n\\t\\t\\t\\tthis.shadow.bias = value;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\tshadowDarkness: {\\r\\n\\t\\t\\tset: function () {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\tshadowMapWidth: {\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\\r\\n\\t\\t\\t\\tthis.shadow.mapSize.width = value;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\tshadowMapHeight: {\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\\r\\n\\t\\t\\t\\tthis.shadow.mapSize.height = value;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t} );\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tObject.defineProperties( BufferAttribute.prototype, {\\r\\n\\r\\n\\t\\tlength: {\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );\\r\\n\\t\\t\\t\\treturn this.array.length;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tObject.assign( BufferGeometry.prototype, {\\r\\n\\r\\n\\t\\taddIndex: function ( index ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\\r\\n\\t\\t\\tthis.setIndex( index );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\taddDrawCall: function ( start, count, indexOffset ) {\\r\\n\\r\\n\\t\\t\\tif ( indexOffset !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\\r\\n\\t\\t\\tthis.addGroup( start, count );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tclearDrawCalls: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\\r\\n\\t\\t\\tthis.clearGroups();\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tcomputeTangents: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tcomputeOffsets: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tObject.defineProperties( BufferGeometry.prototype, {\\r\\n\\r\\n\\t\\tdrawcalls: {\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\\r\\n\\t\\t\\t\\treturn this.groups;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\toffsets: {\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\\r\\n\\t\\t\\t\\treturn this.groups;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tObject.defineProperties( Uniform.prototype, {\\r\\n\\r\\n\\t\\tdynamic: {\\r\\n\\t\\t\\tset: function () {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\tonUpdate: {\\r\\n\\t\\t\\tvalue: function () {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tObject.defineProperties( Material.prototype, {\\r\\n\\r\\n\\t\\twrapAround: {\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Material: .wrapAround has been removed.' );\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tset: function () {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Material: .wrapAround has been removed.' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\twrapRGB: {\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Material: .wrapRGB has been removed.' );\\r\\n\\t\\t\\t\\treturn new Color();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tshading: {\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\\r\\n\\t\\t\\t\\tthis.flatShading = ( value === FlatShading );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tObject.defineProperties( MeshPhongMaterial.prototype, {\\r\\n\\r\\n\\t\\tmetal: {\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\\r\\n\\t\\t\\t\\treturn false;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tset: function () {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tObject.defineProperties( ShaderMaterial.prototype, {\\r\\n\\r\\n\\t\\tderivatives: {\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\\r\\n\\t\\t\\t\\treturn this.extensions.derivatives;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\\r\\n\\t\\t\\t\\tthis.extensions.derivatives = value;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tObject.assign( WebGLRenderer.prototype, {\\r\\n\\r\\n\\t\\tgetCurrentRenderTarget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );\\r\\n\\t\\t\\treturn this.getRenderTarget();\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetMaxAnisotropy: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );\\r\\n\\t\\t\\treturn this.capabilities.getMaxAnisotropy();\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tgetPrecision: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );\\r\\n\\t\\t\\treturn this.capabilities.precision;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tresetGLState: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );\\r\\n\\t\\t\\treturn this.state.reset();\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsupportsFloatTextures: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\\\'OES_texture_float\\\\' ).' );\\r\\n\\t\\t\\treturn this.extensions.get( 'OES_texture_float' );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tsupportsHalfFloatTextures: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\\\'OES_texture_half_float\\\\' ).' );\\r\\n\\t\\t\\treturn this.extensions.get( 'OES_texture_half_float' );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tsupportsStandardDerivatives: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\\\'OES_standard_derivatives\\\\' ).' );\\r\\n\\t\\t\\treturn this.extensions.get( 'OES_standard_derivatives' );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tsupportsCompressedTextureS3TC: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\\\'WEBGL_compressed_texture_s3tc\\\\' ).' );\\r\\n\\t\\t\\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tsupportsCompressedTexturePVRTC: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\\\'WEBGL_compressed_texture_pvrtc\\\\' ).' );\\r\\n\\t\\t\\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tsupportsBlendMinMax: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\\\'EXT_blend_minmax\\\\' ).' );\\r\\n\\t\\t\\treturn this.extensions.get( 'EXT_blend_minmax' );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tsupportsVertexTextures: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );\\r\\n\\t\\t\\treturn this.capabilities.vertexTextures;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tsupportsInstancedArrays: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\\\'ANGLE_instanced_arrays\\\\' ).' );\\r\\n\\t\\t\\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tenableScissorTest: function ( boolean ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\\r\\n\\t\\t\\tthis.setScissorTest( boolean );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tinitMaterial: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\taddPrePlugin: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\taddPostPlugin: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tupdateShadowMap: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tObject.defineProperties( WebGLRenderer.prototype, {\\r\\n\\r\\n\\t\\tshadowMapEnabled: {\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\treturn this.shadowMap.enabled;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\\r\\n\\t\\t\\t\\tthis.shadowMap.enabled = value;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\tshadowMapType: {\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\treturn this.shadowMap.type;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\\r\\n\\t\\t\\t\\tthis.shadowMap.type = value;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\tshadowMapCullFace: {\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\treturn this.shadowMap.cullFace;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );\\r\\n\\t\\t\\t\\tthis.shadowMap.cullFace = value;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t} );\\r\\n\\r\\n\\tObject.defineProperties( WebGLShadowMap.prototype, {\\r\\n\\r\\n\\t\\tcullFace: {\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\treturn this.renderReverseSided ? CullFaceFront : CullFaceBack;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tset: function ( cullFace ) {\\r\\n\\r\\n\\t\\t\\t\\tvar value = ( cullFace !== CullFaceBack );\\r\\n\\t\\t\\t\\tconsole.warn( \\\"WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to \\\" + value + \\\".\\\" );\\r\\n\\t\\t\\t\\tthis.renderReverseSided = value;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tObject.defineProperties( WebGLRenderTarget.prototype, {\\r\\n\\r\\n\\t\\twrapS: {\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\\r\\n\\t\\t\\t\\treturn this.texture.wrapS;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\\r\\n\\t\\t\\t\\tthis.texture.wrapS = value;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\twrapT: {\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\\r\\n\\t\\t\\t\\treturn this.texture.wrapT;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\\r\\n\\t\\t\\t\\tthis.texture.wrapT = value;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\tmagFilter: {\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\\r\\n\\t\\t\\t\\treturn this.texture.magFilter;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\\r\\n\\t\\t\\t\\tthis.texture.magFilter = value;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\tminFilter: {\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\\r\\n\\t\\t\\t\\treturn this.texture.minFilter;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\\r\\n\\t\\t\\t\\tthis.texture.minFilter = value;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\tanisotropy: {\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\\r\\n\\t\\t\\t\\treturn this.texture.anisotropy;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\\r\\n\\t\\t\\t\\tthis.texture.anisotropy = value;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\toffset: {\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\\r\\n\\t\\t\\t\\treturn this.texture.offset;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\\r\\n\\t\\t\\t\\tthis.texture.offset = value;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\trepeat: {\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\\r\\n\\t\\t\\t\\treturn this.texture.repeat;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\\r\\n\\t\\t\\t\\tthis.texture.repeat = value;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\tformat: {\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\\r\\n\\t\\t\\t\\treturn this.texture.format;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\\r\\n\\t\\t\\t\\tthis.texture.format = value;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\ttype: {\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\\r\\n\\t\\t\\t\\treturn this.texture.type;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\\r\\n\\t\\t\\t\\tthis.texture.type = value;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\tgenerateMipmaps: {\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\\r\\n\\t\\t\\t\\treturn this.texture.generateMipmaps;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\\r\\n\\t\\t\\t\\tthis.texture.generateMipmaps = value;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tObject.assign( WebVRManager.prototype, {\\r\\n\\r\\n\\t\\tgetStandingMatrix: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebVRManager: .getStandingMatrix() has been removed.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tObject.defineProperties( WebVRManager.prototype, {\\r\\n\\r\\n\\t\\tstanding: {\\r\\n\\t\\t\\tset: function ( /* value */ ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebVRManager: .standing has been removed.' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tAudio.prototype.load = function ( file ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );\\r\\n\\t\\tvar scope = this;\\r\\n\\t\\tvar audioLoader = new AudioLoader();\\r\\n\\t\\taudioLoader.load( file, function ( buffer ) {\\r\\n\\r\\n\\t\\t\\tscope.setBuffer( buffer );\\r\\n\\r\\n\\t\\t} );\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tAudioAnalyser.prototype.getData = function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );\\r\\n\\t\\treturn this.getFrequencyData();\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tCubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );\\r\\n\\t\\treturn this.update( renderer, scene );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tvar GeometryUtils = {\\r\\n\\r\\n\\t\\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\\r\\n\\t\\t\\tvar matrix;\\r\\n\\r\\n\\t\\t\\tif ( geometry2.isMesh ) {\\r\\n\\r\\n\\t\\t\\t\\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\\r\\n\\r\\n\\t\\t\\t\\tmatrix = geometry2.matrix;\\r\\n\\t\\t\\t\\tgeometry2 = geometry2.geometry;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcenter: function ( geometry ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\\r\\n\\t\\t\\treturn geometry.center();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tvar ImageUtils = {\\r\\n\\r\\n\\t\\tcrossOrigin: undefined,\\r\\n\\r\\n\\t\\tloadTexture: function ( url, mapping, onLoad, onError ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\\r\\n\\r\\n\\t\\t\\tvar loader = new TextureLoader();\\r\\n\\t\\t\\tloader.setCrossOrigin( this.crossOrigin );\\r\\n\\r\\n\\t\\t\\tvar texture = loader.load( url, onLoad, undefined, onError );\\r\\n\\r\\n\\t\\t\\tif ( mapping ) texture.mapping = mapping;\\r\\n\\r\\n\\t\\t\\treturn texture;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tloadTextureCube: function ( urls, mapping, onLoad, onError ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\\r\\n\\r\\n\\t\\t\\tvar loader = new CubeTextureLoader();\\r\\n\\t\\t\\tloader.setCrossOrigin( this.crossOrigin );\\r\\n\\r\\n\\t\\t\\tvar texture = loader.load( urls, onLoad, undefined, onError );\\r\\n\\r\\n\\t\\t\\tif ( mapping ) texture.mapping = mapping;\\r\\n\\r\\n\\t\\t\\treturn texture;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tloadCompressedTexture: function () {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tloadCompressedTextureCube: function () {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tfunction Projector() {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\\r\\n\\r\\n\\t\\tthis.projectVector = function ( vector, camera ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\\r\\n\\t\\t\\tvector.project( camera );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.unprojectVector = function ( vector, camera ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\\r\\n\\t\\t\\tvector.unproject( camera );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.pickingRay = function () {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tfunction CanvasRenderer() {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\\r\\n\\r\\n\\t\\tthis.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\\r\\n\\t\\tthis.clear = function () {};\\r\\n\\t\\tthis.render = function () {};\\r\\n\\t\\tthis.setClearColor = function () {};\\r\\n\\t\\tthis.setSize = function () {};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\texports.WebGLRenderTargetCube = WebGLRenderTargetCube;\\r\\n\\texports.WebGLRenderTarget = WebGLRenderTarget;\\r\\n\\texports.WebGLRenderer = WebGLRenderer;\\r\\n\\texports.ShaderLib = ShaderLib;\\r\\n\\texports.UniformsLib = UniformsLib;\\r\\n\\texports.UniformsUtils = UniformsUtils;\\r\\n\\texports.ShaderChunk = ShaderChunk;\\r\\n\\texports.FogExp2 = FogExp2;\\r\\n\\texports.Fog = Fog;\\r\\n\\texports.Scene = Scene;\\r\\n\\texports.LensFlare = LensFlare;\\r\\n\\texports.Sprite = Sprite;\\r\\n\\texports.LOD = LOD;\\r\\n\\texports.SkinnedMesh = SkinnedMesh;\\r\\n\\texports.Skeleton = Skeleton;\\r\\n\\texports.Bone = Bone;\\r\\n\\texports.Mesh = Mesh;\\r\\n\\texports.LineSegments = LineSegments;\\r\\n\\texports.LineLoop = LineLoop;\\r\\n\\texports.Line = Line;\\r\\n\\texports.Points = Points;\\r\\n\\texports.Group = Group;\\r\\n\\texports.VideoTexture = VideoTexture;\\r\\n\\texports.DataTexture = DataTexture;\\r\\n\\texports.CompressedTexture = CompressedTexture;\\r\\n\\texports.CubeTexture = CubeTexture;\\r\\n\\texports.CanvasTexture = CanvasTexture;\\r\\n\\texports.DepthTexture = DepthTexture;\\r\\n\\texports.Texture = Texture;\\r\\n\\texports.CompressedTextureLoader = CompressedTextureLoader;\\r\\n\\texports.DataTextureLoader = DataTextureLoader;\\r\\n\\texports.CubeTextureLoader = CubeTextureLoader;\\r\\n\\texports.TextureLoader = TextureLoader;\\r\\n\\texports.ObjectLoader = ObjectLoader;\\r\\n\\texports.MaterialLoader = MaterialLoader;\\r\\n\\texports.BufferGeometryLoader = BufferGeometryLoader;\\r\\n\\texports.DefaultLoadingManager = DefaultLoadingManager;\\r\\n\\texports.LoadingManager = LoadingManager;\\r\\n\\texports.JSONLoader = JSONLoader;\\r\\n\\texports.ImageLoader = ImageLoader;\\r\\n\\texports.ImageBitmapLoader = ImageBitmapLoader;\\r\\n\\texports.FontLoader = FontLoader;\\r\\n\\texports.FileLoader = FileLoader;\\r\\n\\texports.Loader = Loader;\\r\\n\\texports.LoaderUtils = LoaderUtils;\\r\\n\\texports.Cache = Cache;\\r\\n\\texports.AudioLoader = AudioLoader;\\r\\n\\texports.SpotLightShadow = SpotLightShadow;\\r\\n\\texports.SpotLight = SpotLight;\\r\\n\\texports.PointLight = PointLight;\\r\\n\\texports.RectAreaLight = RectAreaLight;\\r\\n\\texports.HemisphereLight = HemisphereLight;\\r\\n\\texports.DirectionalLightShadow = DirectionalLightShadow;\\r\\n\\texports.DirectionalLight = DirectionalLight;\\r\\n\\texports.AmbientLight = AmbientLight;\\r\\n\\texports.LightShadow = LightShadow;\\r\\n\\texports.Light = Light;\\r\\n\\texports.StereoCamera = StereoCamera;\\r\\n\\texports.PerspectiveCamera = PerspectiveCamera;\\r\\n\\texports.OrthographicCamera = OrthographicCamera;\\r\\n\\texports.CubeCamera = CubeCamera;\\r\\n\\texports.ArrayCamera = ArrayCamera;\\r\\n\\texports.Camera = Camera;\\r\\n\\texports.AudioListener = AudioListener;\\r\\n\\texports.PositionalAudio = PositionalAudio;\\r\\n\\texports.AudioContext = AudioContext;\\r\\n\\texports.AudioAnalyser = AudioAnalyser;\\r\\n\\texports.Audio = Audio;\\r\\n\\texports.VectorKeyframeTrack = VectorKeyframeTrack;\\r\\n\\texports.StringKeyframeTrack = StringKeyframeTrack;\\r\\n\\texports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;\\r\\n\\texports.NumberKeyframeTrack = NumberKeyframeTrack;\\r\\n\\texports.ColorKeyframeTrack = ColorKeyframeTrack;\\r\\n\\texports.BooleanKeyframeTrack = BooleanKeyframeTrack;\\r\\n\\texports.PropertyMixer = PropertyMixer;\\r\\n\\texports.PropertyBinding = PropertyBinding;\\r\\n\\texports.KeyframeTrack = KeyframeTrack;\\r\\n\\texports.AnimationUtils = AnimationUtils;\\r\\n\\texports.AnimationObjectGroup = AnimationObjectGroup;\\r\\n\\texports.AnimationMixer = AnimationMixer;\\r\\n\\texports.AnimationClip = AnimationClip;\\r\\n\\texports.Uniform = Uniform;\\r\\n\\texports.InstancedBufferGeometry = InstancedBufferGeometry;\\r\\n\\texports.BufferGeometry = BufferGeometry;\\r\\n\\texports.Geometry = Geometry;\\r\\n\\texports.InterleavedBufferAttribute = InterleavedBufferAttribute;\\r\\n\\texports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;\\r\\n\\texports.InterleavedBuffer = InterleavedBuffer;\\r\\n\\texports.InstancedBufferAttribute = InstancedBufferAttribute;\\r\\n\\texports.Face3 = Face3;\\r\\n\\texports.Object3D = Object3D;\\r\\n\\texports.Raycaster = Raycaster;\\r\\n\\texports.Layers = Layers;\\r\\n\\texports.EventDispatcher = EventDispatcher;\\r\\n\\texports.Clock = Clock;\\r\\n\\texports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;\\r\\n\\texports.LinearInterpolant = LinearInterpolant;\\r\\n\\texports.DiscreteInterpolant = DiscreteInterpolant;\\r\\n\\texports.CubicInterpolant = CubicInterpolant;\\r\\n\\texports.Interpolant = Interpolant;\\r\\n\\texports.Triangle = Triangle;\\r\\n\\texports.Math = _Math;\\r\\n\\texports.Spherical = Spherical;\\r\\n\\texports.Cylindrical = Cylindrical;\\r\\n\\texports.Plane = Plane;\\r\\n\\texports.Frustum = Frustum;\\r\\n\\texports.Sphere = Sphere;\\r\\n\\texports.Ray = Ray;\\r\\n\\texports.Matrix4 = Matrix4;\\r\\n\\texports.Matrix3 = Matrix3;\\r\\n\\texports.Box3 = Box3;\\r\\n\\texports.Box2 = Box2;\\r\\n\\texports.Line3 = Line3;\\r\\n\\texports.Euler = Euler;\\r\\n\\texports.Vector4 = Vector4;\\r\\n\\texports.Vector3 = Vector3;\\r\\n\\texports.Vector2 = Vector2;\\r\\n\\texports.Quaternion = Quaternion;\\r\\n\\texports.Color = Color;\\r\\n\\texports.ImmediateRenderObject = ImmediateRenderObject;\\r\\n\\texports.VertexNormalsHelper = VertexNormalsHelper;\\r\\n\\texports.SpotLightHelper = SpotLightHelper;\\r\\n\\texports.SkeletonHelper = SkeletonHelper;\\r\\n\\texports.PointLightHelper = PointLightHelper;\\r\\n\\texports.RectAreaLightHelper = RectAreaLightHelper;\\r\\n\\texports.HemisphereLightHelper = HemisphereLightHelper;\\r\\n\\texports.GridHelper = GridHelper;\\r\\n\\texports.PolarGridHelper = PolarGridHelper;\\r\\n\\texports.FaceNormalsHelper = FaceNormalsHelper;\\r\\n\\texports.DirectionalLightHelper = DirectionalLightHelper;\\r\\n\\texports.CameraHelper = CameraHelper;\\r\\n\\texports.BoxHelper = BoxHelper;\\r\\n\\texports.Box3Helper = Box3Helper;\\r\\n\\texports.PlaneHelper = PlaneHelper;\\r\\n\\texports.ArrowHelper = ArrowHelper;\\r\\n\\texports.AxesHelper = AxesHelper;\\r\\n\\texports.Shape = Shape;\\r\\n\\texports.Path = Path;\\r\\n\\texports.ShapePath = ShapePath;\\r\\n\\texports.Font = Font;\\r\\n\\texports.CurvePath = CurvePath;\\r\\n\\texports.Curve = Curve;\\r\\n\\texports.ShapeUtils = ShapeUtils;\\r\\n\\texports.SceneUtils = SceneUtils;\\r\\n\\texports.WebGLUtils = WebGLUtils;\\r\\n\\texports.WireframeGeometry = WireframeGeometry;\\r\\n\\texports.ParametricGeometry = ParametricGeometry;\\r\\n\\texports.ParametricBufferGeometry = ParametricBufferGeometry;\\r\\n\\texports.TetrahedronGeometry = TetrahedronGeometry;\\r\\n\\texports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;\\r\\n\\texports.OctahedronGeometry = OctahedronGeometry;\\r\\n\\texports.OctahedronBufferGeometry = OctahedronBufferGeometry;\\r\\n\\texports.IcosahedronGeometry = IcosahedronGeometry;\\r\\n\\texports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;\\r\\n\\texports.DodecahedronGeometry = DodecahedronGeometry;\\r\\n\\texports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;\\r\\n\\texports.PolyhedronGeometry = PolyhedronGeometry;\\r\\n\\texports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;\\r\\n\\texports.TubeGeometry = TubeGeometry;\\r\\n\\texports.TubeBufferGeometry = TubeBufferGeometry;\\r\\n\\texports.TorusKnotGeometry = TorusKnotGeometry;\\r\\n\\texports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;\\r\\n\\texports.TorusGeometry = TorusGeometry;\\r\\n\\texports.TorusBufferGeometry = TorusBufferGeometry;\\r\\n\\texports.TextGeometry = TextGeometry;\\r\\n\\texports.TextBufferGeometry = TextBufferGeometry;\\r\\n\\texports.SphereGeometry = SphereGeometry;\\r\\n\\texports.SphereBufferGeometry = SphereBufferGeometry;\\r\\n\\texports.RingGeometry = RingGeometry;\\r\\n\\texports.RingBufferGeometry = RingBufferGeometry;\\r\\n\\texports.PlaneGeometry = PlaneGeometry;\\r\\n\\texports.PlaneBufferGeometry = PlaneBufferGeometry;\\r\\n\\texports.LatheGeometry = LatheGeometry;\\r\\n\\texports.LatheBufferGeometry = LatheBufferGeometry;\\r\\n\\texports.ShapeGeometry = ShapeGeometry;\\r\\n\\texports.ShapeBufferGeometry = ShapeBufferGeometry;\\r\\n\\texports.ExtrudeGeometry = ExtrudeGeometry;\\r\\n\\texports.ExtrudeBufferGeometry = ExtrudeBufferGeometry;\\r\\n\\texports.EdgesGeometry = EdgesGeometry;\\r\\n\\texports.ConeGeometry = ConeGeometry;\\r\\n\\texports.ConeBufferGeometry = ConeBufferGeometry;\\r\\n\\texports.CylinderGeometry = CylinderGeometry;\\r\\n\\texports.CylinderBufferGeometry = CylinderBufferGeometry;\\r\\n\\texports.CircleGeometry = CircleGeometry;\\r\\n\\texports.CircleBufferGeometry = CircleBufferGeometry;\\r\\n\\texports.BoxGeometry = BoxGeometry;\\r\\n\\texports.BoxBufferGeometry = BoxBufferGeometry;\\r\\n\\texports.ShadowMaterial = ShadowMaterial;\\r\\n\\texports.SpriteMaterial = SpriteMaterial;\\r\\n\\texports.RawShaderMaterial = RawShaderMaterial;\\r\\n\\texports.ShaderMaterial = ShaderMaterial;\\r\\n\\texports.PointsMaterial = PointsMaterial;\\r\\n\\texports.MeshPhysicalMaterial = MeshPhysicalMaterial;\\r\\n\\texports.MeshStandardMaterial = MeshStandardMaterial;\\r\\n\\texports.MeshPhongMaterial = MeshPhongMaterial;\\r\\n\\texports.MeshToonMaterial = MeshToonMaterial;\\r\\n\\texports.MeshNormalMaterial = MeshNormalMaterial;\\r\\n\\texports.MeshLambertMaterial = MeshLambertMaterial;\\r\\n\\texports.MeshDepthMaterial = MeshDepthMaterial;\\r\\n\\texports.MeshDistanceMaterial = MeshDistanceMaterial;\\r\\n\\texports.MeshBasicMaterial = MeshBasicMaterial;\\r\\n\\texports.LineDashedMaterial = LineDashedMaterial;\\r\\n\\texports.LineBasicMaterial = LineBasicMaterial;\\r\\n\\texports.Material = Material;\\r\\n\\texports.Float64BufferAttribute = Float64BufferAttribute;\\r\\n\\texports.Float32BufferAttribute = Float32BufferAttribute;\\r\\n\\texports.Uint32BufferAttribute = Uint32BufferAttribute;\\r\\n\\texports.Int32BufferAttribute = Int32BufferAttribute;\\r\\n\\texports.Uint16BufferAttribute = Uint16BufferAttribute;\\r\\n\\texports.Int16BufferAttribute = Int16BufferAttribute;\\r\\n\\texports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;\\r\\n\\texports.Uint8BufferAttribute = Uint8BufferAttribute;\\r\\n\\texports.Int8BufferAttribute = Int8BufferAttribute;\\r\\n\\texports.BufferAttribute = BufferAttribute;\\r\\n\\texports.ArcCurve = ArcCurve;\\r\\n\\texports.CatmullRomCurve3 = CatmullRomCurve3;\\r\\n\\texports.CubicBezierCurve = CubicBezierCurve;\\r\\n\\texports.CubicBezierCurve3 = CubicBezierCurve3;\\r\\n\\texports.EllipseCurve = EllipseCurve;\\r\\n\\texports.LineCurve = LineCurve;\\r\\n\\texports.LineCurve3 = LineCurve3;\\r\\n\\texports.QuadraticBezierCurve = QuadraticBezierCurve;\\r\\n\\texports.QuadraticBezierCurve3 = QuadraticBezierCurve3;\\r\\n\\texports.SplineCurve = SplineCurve;\\r\\n\\texports.REVISION = REVISION;\\r\\n\\texports.MOUSE = MOUSE;\\r\\n\\texports.CullFaceNone = CullFaceNone;\\r\\n\\texports.CullFaceBack = CullFaceBack;\\r\\n\\texports.CullFaceFront = CullFaceFront;\\r\\n\\texports.CullFaceFrontBack = CullFaceFrontBack;\\r\\n\\texports.FrontFaceDirectionCW = FrontFaceDirectionCW;\\r\\n\\texports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;\\r\\n\\texports.BasicShadowMap = BasicShadowMap;\\r\\n\\texports.PCFShadowMap = PCFShadowMap;\\r\\n\\texports.PCFSoftShadowMap = PCFSoftShadowMap;\\r\\n\\texports.FrontSide = FrontSide;\\r\\n\\texports.BackSide = BackSide;\\r\\n\\texports.DoubleSide = DoubleSide;\\r\\n\\texports.FlatShading = FlatShading;\\r\\n\\texports.SmoothShading = SmoothShading;\\r\\n\\texports.NoColors = NoColors;\\r\\n\\texports.FaceColors = FaceColors;\\r\\n\\texports.VertexColors = VertexColors;\\r\\n\\texports.NoBlending = NoBlending;\\r\\n\\texports.NormalBlending = NormalBlending;\\r\\n\\texports.AdditiveBlending = AdditiveBlending;\\r\\n\\texports.SubtractiveBlending = SubtractiveBlending;\\r\\n\\texports.MultiplyBlending = MultiplyBlending;\\r\\n\\texports.CustomBlending = CustomBlending;\\r\\n\\texports.AddEquation = AddEquation;\\r\\n\\texports.SubtractEquation = SubtractEquation;\\r\\n\\texports.ReverseSubtractEquation = ReverseSubtractEquation;\\r\\n\\texports.MinEquation = MinEquation;\\r\\n\\texports.MaxEquation = MaxEquation;\\r\\n\\texports.ZeroFactor = ZeroFactor;\\r\\n\\texports.OneFactor = OneFactor;\\r\\n\\texports.SrcColorFactor = SrcColorFactor;\\r\\n\\texports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;\\r\\n\\texports.SrcAlphaFactor = SrcAlphaFactor;\\r\\n\\texports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;\\r\\n\\texports.DstAlphaFactor = DstAlphaFactor;\\r\\n\\texports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;\\r\\n\\texports.DstColorFactor = DstColorFactor;\\r\\n\\texports.OneMinusDstColorFactor = OneMinusDstColorFactor;\\r\\n\\texports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;\\r\\n\\texports.NeverDepth = NeverDepth;\\r\\n\\texports.AlwaysDepth = AlwaysDepth;\\r\\n\\texports.LessDepth = LessDepth;\\r\\n\\texports.LessEqualDepth = LessEqualDepth;\\r\\n\\texports.EqualDepth = EqualDepth;\\r\\n\\texports.GreaterEqualDepth = GreaterEqualDepth;\\r\\n\\texports.GreaterDepth = GreaterDepth;\\r\\n\\texports.NotEqualDepth = NotEqualDepth;\\r\\n\\texports.MultiplyOperation = MultiplyOperation;\\r\\n\\texports.MixOperation = MixOperation;\\r\\n\\texports.AddOperation = AddOperation;\\r\\n\\texports.NoToneMapping = NoToneMapping;\\r\\n\\texports.LinearToneMapping = LinearToneMapping;\\r\\n\\texports.ReinhardToneMapping = ReinhardToneMapping;\\r\\n\\texports.Uncharted2ToneMapping = Uncharted2ToneMapping;\\r\\n\\texports.CineonToneMapping = CineonToneMapping;\\r\\n\\texports.UVMapping = UVMapping;\\r\\n\\texports.CubeReflectionMapping = CubeReflectionMapping;\\r\\n\\texports.CubeRefractionMapping = CubeRefractionMapping;\\r\\n\\texports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;\\r\\n\\texports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;\\r\\n\\texports.SphericalReflectionMapping = SphericalReflectionMapping;\\r\\n\\texports.CubeUVReflectionMapping = CubeUVReflectionMapping;\\r\\n\\texports.CubeUVRefractionMapping = CubeUVRefractionMapping;\\r\\n\\texports.RepeatWrapping = RepeatWrapping;\\r\\n\\texports.ClampToEdgeWrapping = ClampToEdgeWrapping;\\r\\n\\texports.MirroredRepeatWrapping = MirroredRepeatWrapping;\\r\\n\\texports.NearestFilter = NearestFilter;\\r\\n\\texports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;\\r\\n\\texports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;\\r\\n\\texports.LinearFilter = LinearFilter;\\r\\n\\texports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;\\r\\n\\texports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;\\r\\n\\texports.UnsignedByteType = UnsignedByteType;\\r\\n\\texports.ByteType = ByteType;\\r\\n\\texports.ShortType = ShortType;\\r\\n\\texports.UnsignedShortType = UnsignedShortType;\\r\\n\\texports.IntType = IntType;\\r\\n\\texports.UnsignedIntType = UnsignedIntType;\\r\\n\\texports.FloatType = FloatType;\\r\\n\\texports.HalfFloatType = HalfFloatType;\\r\\n\\texports.UnsignedShort4444Type = UnsignedShort4444Type;\\r\\n\\texports.UnsignedShort5551Type = UnsignedShort5551Type;\\r\\n\\texports.UnsignedShort565Type = UnsignedShort565Type;\\r\\n\\texports.UnsignedInt248Type = UnsignedInt248Type;\\r\\n\\texports.AlphaFormat = AlphaFormat;\\r\\n\\texports.RGBFormat = RGBFormat;\\r\\n\\texports.RGBAFormat = RGBAFormat;\\r\\n\\texports.LuminanceFormat = LuminanceFormat;\\r\\n\\texports.LuminanceAlphaFormat = LuminanceAlphaFormat;\\r\\n\\texports.RGBEFormat = RGBEFormat;\\r\\n\\texports.DepthFormat = DepthFormat;\\r\\n\\texports.DepthStencilFormat = DepthStencilFormat;\\r\\n\\texports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;\\r\\n\\texports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;\\r\\n\\texports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;\\r\\n\\texports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;\\r\\n\\texports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;\\r\\n\\texports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;\\r\\n\\texports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;\\r\\n\\texports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;\\r\\n\\texports.RGB_ETC1_Format = RGB_ETC1_Format;\\r\\n\\texports.LoopOnce = LoopOnce;\\r\\n\\texports.LoopRepeat = LoopRepeat;\\r\\n\\texports.LoopPingPong = LoopPingPong;\\r\\n\\texports.InterpolateDiscrete = InterpolateDiscrete;\\r\\n\\texports.InterpolateLinear = InterpolateLinear;\\r\\n\\texports.InterpolateSmooth = InterpolateSmooth;\\r\\n\\texports.ZeroCurvatureEnding = ZeroCurvatureEnding;\\r\\n\\texports.ZeroSlopeEnding = ZeroSlopeEnding;\\r\\n\\texports.WrapAroundEnding = WrapAroundEnding;\\r\\n\\texports.TrianglesDrawMode = TrianglesDrawMode;\\r\\n\\texports.TriangleStripDrawMode = TriangleStripDrawMode;\\r\\n\\texports.TriangleFanDrawMode = TriangleFanDrawMode;\\r\\n\\texports.LinearEncoding = LinearEncoding;\\r\\n\\texports.sRGBEncoding = sRGBEncoding;\\r\\n\\texports.GammaEncoding = GammaEncoding;\\r\\n\\texports.RGBEEncoding = RGBEEncoding;\\r\\n\\texports.LogLuvEncoding = LogLuvEncoding;\\r\\n\\texports.RGBM7Encoding = RGBM7Encoding;\\r\\n\\texports.RGBM16Encoding = RGBM16Encoding;\\r\\n\\texports.RGBDEncoding = RGBDEncoding;\\r\\n\\texports.BasicDepthPacking = BasicDepthPacking;\\r\\n\\texports.RGBADepthPacking = RGBADepthPacking;\\r\\n\\texports.CubeGeometry = BoxGeometry;\\r\\n\\texports.Face4 = Face4;\\r\\n\\texports.LineStrip = LineStrip;\\r\\n\\texports.LinePieces = LinePieces;\\r\\n\\texports.MeshFaceMaterial = MeshFaceMaterial;\\r\\n\\texports.MultiMaterial = MultiMaterial;\\r\\n\\texports.PointCloud = PointCloud;\\r\\n\\texports.Particle = Particle;\\r\\n\\texports.ParticleSystem = ParticleSystem;\\r\\n\\texports.PointCloudMaterial = PointCloudMaterial;\\r\\n\\texports.ParticleBasicMaterial = ParticleBasicMaterial;\\r\\n\\texports.ParticleSystemMaterial = ParticleSystemMaterial;\\r\\n\\texports.Vertex = Vertex;\\r\\n\\texports.DynamicBufferAttribute = DynamicBufferAttribute;\\r\\n\\texports.Int8Attribute = Int8Attribute;\\r\\n\\texports.Uint8Attribute = Uint8Attribute;\\r\\n\\texports.Uint8ClampedAttribute = Uint8ClampedAttribute;\\r\\n\\texports.Int16Attribute = Int16Attribute;\\r\\n\\texports.Uint16Attribute = Uint16Attribute;\\r\\n\\texports.Int32Attribute = Int32Attribute;\\r\\n\\texports.Uint32Attribute = Uint32Attribute;\\r\\n\\texports.Float32Attribute = Float32Attribute;\\r\\n\\texports.Float64Attribute = Float64Attribute;\\r\\n\\texports.ClosedSplineCurve3 = ClosedSplineCurve3;\\r\\n\\texports.SplineCurve3 = SplineCurve3;\\r\\n\\texports.Spline = Spline;\\r\\n\\texports.AxisHelper = AxisHelper;\\r\\n\\texports.BoundingBoxHelper = BoundingBoxHelper;\\r\\n\\texports.EdgesHelper = EdgesHelper;\\r\\n\\texports.WireframeHelper = WireframeHelper;\\r\\n\\texports.XHRLoader = XHRLoader;\\r\\n\\texports.BinaryTextureLoader = BinaryTextureLoader;\\r\\n\\texports.GeometryUtils = GeometryUtils;\\r\\n\\texports.ImageUtils = ImageUtils;\\r\\n\\texports.Projector = Projector;\\r\\n\\texports.CanvasRenderer = CanvasRenderer;\\r\\n\\r\\n\\tObject.defineProperty(exports, '__esModule', { value: true });\\r\\n\\r\\n})));\\r\\n\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aHJlZS1hdnMtZGFzaC8uL3ZlbmRvci90aHJlZS5qcz9lNGJhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLCtDQUErQyx5TUFBeU0sSUFBSSxLQUFLLDRCQUE0QixjQUFjLHFFQUFxRSxpREFBaUQsV0FBVyxpREFBaUQsMkxBQTJMLHFHQUFxRyxjQUFjLFdBQVcsc0RBQXNELGlKQUFpSiwyREFBMkQsY0FBYyxXQUFXLHlEQUF5RCxxTUFBcU0sZ0NBQWdDLHFGQUFxRixlQUFlLGFBQWEsR0FBRyxXQUFXLDhDQUE4QyxnS0FBZ0ssbURBQW1ELGdFQUFnRSxzRkFBc0YsaUJBQWlCLDhDQUE4QyxvQ0FBb0MsMEJBQTBCLGFBQWEsa0RBQWtELGtFQUFrRSxtREFBbUQsc0ZBQXNGLDhEQUE4RCx1QkFBdUIscUJBQXFCLG1CQUFtQixpQkFBaUIsOEJBQThCLGdCQUFnQixhQUFhLEtBQUssV0FBVyxtSEFBbUgscURBQXFELDJEQUEyRCx3RUFBd0UsOENBQThDLHNEQUFzRCx1Q0FBdUMsZUFBZSxvRUFBb0UsbURBQW1ELGVBQWUsYUFBYSw0REFBNEQsZ0VBQWdFLDhDQUE4QyxzR0FBc0csYUFBYSwrREFBK0QsMERBQTBELDhDQUE4QyxnREFBZ0Qsa0RBQWtELDhEQUE4RCxzQ0FBc0MsbURBQW1ELGlCQUFpQixlQUFlLGFBQWEsZ0RBQWdELDBEQUEwRCw4Q0FBOEMsc0RBQXNELGtEQUFrRCxvQ0FBb0MscURBQXFELGtEQUFrRCxPQUFPLFNBQVMsaURBQWlELGlCQUFpQixlQUFlLGFBQWEsV0FBVyxHQUFHLDhCQUE4QixtQkFBbUIsZ0NBQWdDLDJCQUEyQiwyQkFBMkIsNEJBQTRCLGdDQUFnQyxtQ0FBbUMsb0NBQW9DLDZCQUE2QiwyQkFBMkIsK0JBQStCLHdCQUF3Qix1QkFBdUIseUJBQXlCLDBCQUEwQiw0QkFBNEIsdUJBQXVCLHlCQUF5QiwyQkFBMkIseUJBQXlCLDZCQUE2QiwrQkFBK0Isa0NBQWtDLCtCQUErQiw2QkFBNkIsNEJBQTRC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Z2xvYmFsLCBmYWN0b3J5KSB7XFxyXFxuXFx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XFxyXFxuXFx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XFxyXFxuXFx0KGZhY3RvcnkoKGdsb2JhbC5USFJFRSA9IHt9KSkpO1xcclxcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcXHJcXG5cXHJcXG5cXHQvLyBQb2x5ZmlsbHNcXHJcXG5cXHJcXG5cXHRpZiAoIE51bWJlci5FUFNJTE9OID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0TnVtYmVyLkVQU0lMT04gPSBNYXRoLnBvdyggMiwgLSA1MiApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRpZiAoIE51bWJlci5pc0ludGVnZXIgPT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHQvLyBNaXNzaW5nIGluIElFXFxyXFxuXFx0XFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL2lzSW50ZWdlclxcclxcblxcclxcblxcdFxcdE51bWJlci5pc0ludGVnZXIgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKCB2YWx1ZSApICYmIE1hdGguZmxvb3IoIHZhbHVlICkgPT09IHZhbHVlO1xcclxcblxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8vXFxyXFxuXFxyXFxuXFx0aWYgKCBNYXRoLnNpZ24gPT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3NpZ25cXHJcXG5cXHJcXG5cXHRcXHRNYXRoLnNpZ24gPSBmdW5jdGlvbiAoIHggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuICggeCA8IDAgKSA/IC0gMSA6ICggeCA+IDAgKSA/IDEgOiArIHg7XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0aWYgKCAnbmFtZScgaW4gRnVuY3Rpb24ucHJvdG90eXBlID09PSBmYWxzZSApIHtcXHJcXG5cXHJcXG5cXHRcXHQvLyBNaXNzaW5nIGluIElFXFxyXFxuXFx0XFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vbmFtZVxcclxcblxcclxcblxcdFxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggRnVuY3Rpb24ucHJvdG90eXBlLCAnbmFtZScsIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy50b1N0cmluZygpLm1hdGNoKCAvXlxcXFxzKmZ1bmN0aW9uXFxcXHMqKFteXFxcXChcXFxcc10qKS8gKVsgMSBdO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9ICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdGlmICggT2JqZWN0LmFzc2lnbiA9PT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdC8vIE1pc3NpbmcgaW4gSUVcXHJcXG5cXHRcXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvYXNzaWduXFxyXFxuXFxyXFxuXFx0XFx0KCBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0T2JqZWN0LmFzc2lnbiA9IGZ1bmN0aW9uICggdGFyZ2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggdGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHRocm93IG5ldyBUeXBlRXJyb3IoICdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBvdXRwdXQgPSBPYmplY3QoIHRhcmdldCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXggKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHNvdXJjZSA9IGFyZ3VtZW50c1sgaW5kZXggXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHNvdXJjZSAhPT0gdW5kZWZpbmVkICYmIHNvdXJjZSAhPT0gbnVsbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgbmV4dEtleSBpbiBzb3VyY2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIHNvdXJjZSwgbmV4dEtleSApICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG91dHB1dFsgbmV4dEtleSBdID0gc291cmNlWyBuZXh0S2V5IF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiBvdXRwdXQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR9ICkoKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi9ldmVudGRpc3BhdGNoZXIuanMvXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gRXZlbnREaXNwYXRjaGVyKCkge31cXHJcXG5cXHJcXG5cXHRPYmplY3QuYXNzaWduKCBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLCB7XFxyXFxuXFxyXFxuXFx0XFx0YWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgdGhpcy5fbGlzdGVuZXJzID0ge307XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bGlzdGVuZXJzWyB0eXBlIF0gPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApID09PSAtIDEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bGlzdGVuZXJzWyB0eXBlIF0ucHVzaCggbGlzdGVuZXIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRoYXNFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm4gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gbGlzdGVuZXJzWyB0eXBlIF0gIT09IHVuZGVmaW5lZCAmJiBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApICE9PSAtIDE7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRyZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm47XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcXHJcXG5cXHRcXHRcXHR2YXIgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgdHlwZSBdO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggbGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBpbmRleCA9IGxpc3RlbmVyQXJyYXkuaW5kZXhPZiggbGlzdGVuZXIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGluZGV4ICE9PSAtIDEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0bGlzdGVuZXJBcnJheS5zcGxpY2UoIGluZGV4LCAxICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uICggZXZlbnQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHJldHVybjtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xcclxcblxcdFxcdFxcdHZhciBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzWyBldmVudC50eXBlIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZXZlbnQudGFyZ2V0ID0gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgYXJyYXkgPSBsaXN0ZW5lckFycmF5LnNsaWNlKCAwICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRhcnJheVsgaSBdLmNhbGwoIHRoaXMsIGV2ZW50ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdHZhciBSRVZJU0lPTiA9ICc4OSc7XFxyXFxuXFx0dmFyIE1PVVNFID0geyBMRUZUOiAwLCBNSURETEU6IDEsIFJJR0hUOiAyIH07XFxyXFxuXFx0dmFyIEN1bGxGYWNlTm9uZSA9IDA7XFxyXFxuXFx0dmFyIEN1bGxGYWNlQmFjayA9IDE7XFxyXFxuXFx0dmFyIEN1bGxGYWNlRnJvbnQgPSAyO1xcclxcblxcdHZhciBDdWxsRmFjZUZyb250QmFjayA9IDM7XFxyXFxuXFx0dmFyIEZyb250RmFjZURpcmVjdGlvbkNXID0gMDtcXHJcXG5cXHR2YXIgRnJvbnRGYWNlRGlyZWN0aW9uQ0NXID0gMTtcXHJcXG5cXHR2YXIgQmFzaWNTaGFkb3dNYXAgPSAwO1xcclxcblxcdHZhciBQQ0ZTaGFkb3dNYXAgPSAxO1xcclxcblxcdHZhciBQQ0ZTb2Z0U2hhZG93TWFwID0gMjtcXHJcXG5cXHR2YXIgRnJvbnRTaWRlID0gMDtcXHJcXG5cXHR2YXIgQmFja1NpZGUgPSAxO1xcclxcblxcdHZhciBEb3VibGVTaWRlID0gMjtcXHJcXG5cXHR2YXIgRmxhdFNoYWRpbmcgPSAxO1xcclxcblxcdHZhciBTbW9vdGhTaGFkaW5nID0gMjtcXHJcXG5cXHR2YXIgTm9Db2xvcnMgPSAwO1xcclxcblxcdHZhciBGYWNlQ29sb3JzID0gMTtcXHJcXG5cXHR2YXIgVmVydGV4Q29sb3JzID0gMjtcXHJcXG5cXHR2YXIgTm9CbGVuZGluZyA9IDA7XFxyXFxuXFx0dmFyIE5vcm1hbEJsZW5kaW5nID0gMTtcXHJcXG5cXHR2YXIgQWRkaXRpdmVCbGVuZGluZyA9IDI7XFxyXFxuXFx0dmFyIFN1YnRyYWN0aXZlQmxlbmRpbmcgPSAzO1xcclxcblxcdHZhciBNdWx0aXBseUJsZW5kaW5nID0gNDtcXHJcXG5cXHR2YXIgQ3VzdG9tQmxlbmRpbmcgPSA1O1xcclxcblxcdHZhciBBZGRFcXVhdGlvbiA9IDEwMDtcXHJcXG5cXHR2YXIgU3VidHJhY3RFcXVhdGlvbiA9IDEwMTtcXHJcXG5cXHR2YXIgUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24gPSAxMDI7XFxyXFxuXFx0dmFyIE1pbkVxdWF0aW9uID0gMTAzO1xcclxcblxcdHZhciBNYXhFcXVhdGlvbiA9IDEwNDtcXHJcXG5cXHR2YXIgWmVyb0ZhY3RvciA9IDIwMDtcXHJcXG5cXHR2YXIgT25lRmFjdG9yID0gMjAxO1xcclxcblxcdHZhciBTcmNDb2xvckZhY3RvciA9IDIwMjtcXHJcXG5cXHR2YXIgT25lTWludXNTcmNDb2xvckZhY3RvciA9IDIwMztcXHJcXG5cXHR2YXIgU3JjQWxwaGFGYWN0b3IgPSAyMDQ7XFxyXFxuXFx0dmFyIE9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSAyMDU7XFxyXFxuXFx0dmFyIERzdEFscGhhRmFjdG9yID0gMjA2O1xcclxcblxcdHZhciBPbmVNaW51c0RzdEFscGhhRmFjdG9yID0gMjA3O1xcclxcblxcdHZhciBEc3RDb2xvckZhY3RvciA9IDIwODtcXHJcXG5cXHR2YXIgT25lTWludXNEc3RDb2xvckZhY3RvciA9IDIwOTtcXHJcXG5cXHR2YXIgU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciA9IDIxMDtcXHJcXG5cXHR2YXIgTmV2ZXJEZXB0aCA9IDA7XFxyXFxuXFx0dmFyIEFsd2F5c0RlcHRoID0gMTtcXHJcXG5cXHR2YXIgTGVzc0RlcHRoID0gMjtcXHJcXG5cXHR2YXIgTGVzc0VxdWFsRGVwdGggPSAzO1xcclxcblxcdHZhciBFcXVhbERlcHRoID0gNDtcXHJcXG5cXHR2YXIgR3JlYXRlckVxdWFsRGVwdGggPSA1O1xcclxcblxcdHZhciBHcmVhdGVyRGVwdGggPSA2O1xcclxcblxcdHZhciBOb3RFcXVhbERlcHRoID0gNztcXHJcXG5cXHR2YXIgTXVsdGlwbHlPcGVyYXRpb24gPSAwO1xcclxcblxcdHZhciBNaXhPcGVyYXRpb24gPSAxO1xcclxcblxcdHZhciBBZGRPcGVyYXRpb24gPSAyO1xcclxcblxcdHZhciBOb1RvbmVNYXBwaW5nID0gMDtcXHJcXG5cXHR2YXIgTGluZWFyVG9uZU1hcHBpbmcgPSAxO1xcclxcblxcdHZhciBSZWluaGFyZFRvbmVNYXBwaW5nID0gMjtcXHJcXG5cXHR2YXIgVW5jaGFydGVkMlRvbmVNYXBwaW5nID0gMztcXHJcXG5cXHR2YXIgQ2luZW9uVG9uZU1hcHBpbmcgPSA0O1xcclxcblxcdHZhciBVVk1hcHBpbmcgPSAzMDA7XFxyXFxuXFx0dmFyIEN1YmVSZWZsZWN0aW9uTWFwcGluZyA9IDMwMTtcXHJcXG5cXHR2YXIgQ3ViZVJlZnJhY3Rpb25NYXBwaW5nID0gMzAyO1xcclxcblxcdHZhciBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyA9IDMwMztcXHJcXG5cXHR2YXIgRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcgPSAzMDQ7XFxyXFxuXFx0dmFyIFNwaGVyaWNhbFJlZmxlY3Rpb25NYXBwaW5nID0gMzA1O1xcclxcblxcdHZhciBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZyA9IDMwNjtcXHJcXG5cXHR2YXIgQ3ViZVVWUmVmcmFjdGlvbk1hcHBpbmcgPSAzMDc7XFxyXFxuXFx0dmFyIFJlcGVhdFdyYXBwaW5nID0gMTAwMDtcXHJcXG5cXHR2YXIgQ2xhbXBUb0VkZ2VXcmFwcGluZyA9IDEwMDE7XFxyXFxuXFx0dmFyIE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcgPSAxMDAyO1xcclxcblxcdHZhciBOZWFyZXN0RmlsdGVyID0gMTAwMztcXHJcXG5cXHR2YXIgTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA0O1xcclxcblxcdHZhciBOZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyID0gMTAwNTtcXHJcXG5cXHR2YXIgTGluZWFyRmlsdGVyID0gMTAwNjtcXHJcXG5cXHR2YXIgTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlciA9IDEwMDc7XFxyXFxuXFx0dmFyIExpbmVhck1pcE1hcExpbmVhckZpbHRlciA9IDEwMDg7XFxyXFxuXFx0dmFyIFVuc2lnbmVkQnl0ZVR5cGUgPSAxMDA5O1xcclxcblxcdHZhciBCeXRlVHlwZSA9IDEwMTA7XFxyXFxuXFx0dmFyIFNob3J0VHlwZSA9IDEwMTE7XFxyXFxuXFx0dmFyIFVuc2lnbmVkU2hvcnRUeXBlID0gMTAxMjtcXHJcXG5cXHR2YXIgSW50VHlwZSA9IDEwMTM7XFxyXFxuXFx0dmFyIFVuc2lnbmVkSW50VHlwZSA9IDEwMTQ7XFxyXFxuXFx0dmFyIEZsb2F0VHlwZSA9IDEwMTU7XFxyXFxuXFx0dmFyIEhhbGZGbG9hdFR5cGUgPSAxMDE2O1xcclxcblxcdHZhciBVbnNpZ25lZFNob3J0NDQ0NFR5cGUgPSAxMDE3O1xcclxcblxcdHZhciBVbnNpZ25lZFNob3J0NTU1MVR5cGUgPSAxMDE4O1xcclxcblxcdHZhciBVbnNpZ25lZFNob3J0NTY1VHlwZSA9IDEwMTk7XFxyXFxuXFx0dmFyIFVuc2lnbmVkSW50MjQ4VHlwZSA9IDEwMjA7XFxyXFxuXFx0dmFyIEFscGhhRm9ybWF0ID0gMTAyMTtcXHJcXG5cXHR2YXIgUkdCRm9ybWF0ID0gMTAyMjtcXHJcXG5cXHR2YXIgUkdCQUZvcm1hdCA9IDEwMjM7XFxyXFxuXFx0dmFyIEx1bWluYW5jZUZvcm1hdCA9IDEwMjQ7XFxyXFxuXFx0dmFyIEx1bWluYW5jZUFscGhhRm9ybWF0ID0gMTAyNTtcXHJcXG5cXHR2YXIgUkdCRUZvcm1hdCA9IFJHQkFGb3JtYXQ7XFxyXFxuXFx0dmFyIERlcHRoRm9ybWF0ID0gMTAyNjtcXHJcXG5cXHR2YXIgRGVwdGhTdGVuY2lsRm9ybWF0ID0gMTAyNztcXHJcXG5cXHR2YXIgUkdCX1MzVENfRFhUMV9Gb3JtYXQgPSAyMDAxO1xcclxcblxcdHZhciBSR0JBX1MzVENfRFhUMV9Gb3JtYXQgPSAyMDAyO1xcclxcblxcdHZhciBSR0JBX1MzVENfRFhUM19Gb3JtYXQgPSAyMDAzO1xcclxcblxcdHZhciBSR0JBX1MzVENfRFhUNV9Gb3JtYXQgPSAyMDA0O1xcclxcblxcdHZhciBSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDIxMDA7XFxyXFxuXFx0dmFyIFJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMjEwMTtcXHJcXG5cXHR2YXIgUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0ID0gMjEwMjtcXHJcXG5cXHR2YXIgUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMjEwMztcXHJcXG5cXHR2YXIgUkdCX0VUQzFfRm9ybWF0ID0gMjE1MTtcXHJcXG5cXHR2YXIgTG9vcE9uY2UgPSAyMjAwO1xcclxcblxcdHZhciBMb29wUmVwZWF0ID0gMjIwMTtcXHJcXG5cXHR2YXIgTG9vcFBpbmdQb25nID0gMjIwMjtcXHJcXG5cXHR2YXIgSW50ZXJwb2xhdGVEaXNjcmV0ZSA9IDIzMDA7XFxyXFxuXFx0dmFyIEludGVycG9sYXRlTGluZWFyID0gMjMwMTtcXHJcXG5cXHR2YXIgSW50ZXJwb2xhdGVTbW9vdGggPSAyMzAyO1xcclxcblxcdHZhciBaZXJvQ3VydmF0dXJlRW5kaW5nID0gMjQwMDtcXHJcXG5cXHR2YXIgWmVyb1Nsb3BlRW5kaW5nID0gMjQwMTtcXHJcXG5cXHR2YXIgV3JhcEFyb3VuZEVuZGluZyA9IDI0MDI7XFxyXFxuXFx0dmFyIFRyaWFuZ2xlc0RyYXdNb2RlID0gMDtcXHJcXG5cXHR2YXIgVHJpYW5nbGVTdHJpcERyYXdNb2RlID0gMTtcXHJcXG5cXHR2YXIgVHJpYW5nbGVGYW5EcmF3TW9kZSA9IDI7XFxyXFxuXFx0dmFyIExpbmVhckVuY29kaW5nID0gMzAwMDtcXHJcXG5cXHR2YXIgc1JHQkVuY29kaW5nID0gMzAwMTtcXHJcXG5cXHR2YXIgR2FtbWFFbmNvZGluZyA9IDMwMDc7XFxyXFxuXFx0dmFyIFJHQkVFbmNvZGluZyA9IDMwMDI7XFxyXFxuXFx0dmFyIExvZ0x1dkVuY29kaW5nID0gMzAwMztcXHJcXG5cXHR2YXIgUkdCTTdFbmNvZGluZyA9IDMwMDQ7XFxyXFxuXFx0dmFyIFJHQk0xNkVuY29kaW5nID0gMzAwNTtcXHJcXG5cXHR2YXIgUkdCREVuY29kaW5nID0gMzAwNjtcXHJcXG5cXHR2YXIgQmFzaWNEZXB0aFBhY2tpbmcgPSAzMjAwO1xcclxcblxcdHZhciBSR0JBRGVwdGhQYWNraW5nID0gMzIwMTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0dmFyIF9NYXRoID0ge1xcclxcblxcclxcblxcdFxcdERFRzJSQUQ6IE1hdGguUEkgLyAxODAsXFxyXFxuXFx0XFx0UkFEMkRFRzogMTgwIC8gTWF0aC5QSSxcXHJcXG5cXHJcXG5cXHRcXHRnZW5lcmF0ZVVVSUQ6ICggZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA1MDM0L2hvdy10by1jcmVhdGUtYS1ndWlkLXV1aWQtaW4tamF2YXNjcmlwdC8yMTk2MzEzNiMyMTk2MzEzNlxcclxcblxcclxcblxcdFxcdFxcdHZhciBsdXQgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCAyNTY7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bHV0WyBpIF0gPSAoIGkgPCAxNiA/ICcwJyA6ICcnICkgKyAoIGkgKS50b1N0cmluZyggMTYgKS50b1VwcGVyQ2FzZSgpO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBkMCA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgZDEgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGQyID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xcclxcblxcdFxcdFxcdFxcdHZhciBkMyA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gbHV0WyBkMCAmIDB4ZmYgXSArIGx1dFsgZDAgPj4gOCAmIDB4ZmYgXSArIGx1dFsgZDAgPj4gMTYgJiAweGZmIF0gKyBsdXRbIGQwID4+IDI0ICYgMHhmZiBdICsgJy0nICtcXHJcXG5cXHRcXHRcXHRcXHRcXHRsdXRbIGQxICYgMHhmZiBdICsgbHV0WyBkMSA+PiA4ICYgMHhmZiBdICsgJy0nICsgbHV0WyBkMSA+PiAxNiAmIDB4MGYgfCAweDQwIF0gKyBsdXRbIGQxID4+IDI0ICYgMHhmZiBdICsgJy0nICtcXHJcXG5cXHRcXHRcXHRcXHRcXHRsdXRbIGQyICYgMHgzZiB8IDB4ODAgXSArIGx1dFsgZDIgPj4gOCAmIDB4ZmYgXSArICctJyArIGx1dFsgZDIgPj4gMTYgJiAweGZmIF0gKyBsdXRbIGQyID4+IDI0ICYgMHhmZiBdICtcXHJcXG5cXHRcXHRcXHRcXHRcXHRsdXRbIGQzICYgMHhmZiBdICsgbHV0WyBkMyA+PiA4ICYgMHhmZiBdICsgbHV0WyBkMyA+PiAxNiAmIDB4ZmYgXSArIGx1dFsgZDMgPj4gMjQgJiAweGZmIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR9ICkoKSxcXHJcXG5cXHJcXG5cXHRcXHRjbGFtcDogZnVuY3Rpb24gKCB2YWx1ZSwgbWluLCBtYXggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIHZhbHVlICkgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdC8vIGNvbXB1dGUgZXVjbGlkaWFuIG1vZHVsbyBvZiBtICUgblxcclxcblxcdFxcdC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vZHVsb19vcGVyYXRpb25cXHJcXG5cXHJcXG5cXHRcXHRldWNsaWRlYW5Nb2R1bG86IGZ1bmN0aW9uICggbiwgbSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gKCAoIG4gJSBtICkgKyBtICkgJSBtO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Ly8gTGluZWFyIG1hcHBpbmcgZnJvbSByYW5nZSA8YTEsIGEyPiB0byByYW5nZSA8YjEsIGIyPlxcclxcblxcclxcblxcdFxcdG1hcExpbmVhcjogZnVuY3Rpb24gKCB4LCBhMSwgYTIsIGIxLCBiMiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gYjEgKyAoIHggLSBhMSApICogKCBiMiAtIGIxICkgLyAoIGEyIC0gYTEgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpbmVhcl9pbnRlcnBvbGF0aW9uXFxyXFxuXFxyXFxuXFx0XFx0bGVycDogZnVuY3Rpb24gKCB4LCB5LCB0ICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiAoIDEgLSB0ICkgKiB4ICsgdCAqIHk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHQvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Ntb290aHN0ZXBcXHJcXG5cXHJcXG5cXHRcXHRzbW9vdGhzdGVwOiBmdW5jdGlvbiAoIHgsIG1pbiwgbWF4ICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggeCA8PSBtaW4gKSByZXR1cm4gMDtcXHJcXG5cXHRcXHRcXHRpZiAoIHggPj0gbWF4ICkgcmV0dXJuIDE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0eCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4geCAqIHggKiAoIDMgLSAyICogeCApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c21vb3RoZXJzdGVwOiBmdW5jdGlvbiAoIHgsIG1pbiwgbWF4ICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggeCA8PSBtaW4gKSByZXR1cm4gMDtcXHJcXG5cXHRcXHRcXHRpZiAoIHggPj0gbWF4ICkgcmV0dXJuIDE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0eCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4geCAqIHggKiB4ICogKCB4ICogKCB4ICogNiAtIDE1ICkgKyAxMCApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Ly8gUmFuZG9tIGludGVnZXIgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxcclxcblxcclxcblxcdFxcdHJhbmRJbnQ6IGZ1bmN0aW9uICggbG93LCBoaWdoICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBsb3cgKyBNYXRoLmZsb29yKCBNYXRoLnJhbmRvbSgpICogKCBoaWdoIC0gbG93ICsgMSApICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHQvLyBSYW5kb20gZmxvYXQgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxcclxcblxcclxcblxcdFxcdHJhbmRGbG9hdDogZnVuY3Rpb24gKCBsb3csIGhpZ2ggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGxvdyArIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdC8vIFJhbmRvbSBmbG9hdCBmcm9tIDwtcmFuZ2UvMiwgcmFuZ2UvMj4gaW50ZXJ2YWxcXHJcXG5cXHJcXG5cXHRcXHRyYW5kRmxvYXRTcHJlYWQ6IGZ1bmN0aW9uICggcmFuZ2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHJhbmdlICogKCAwLjUgLSBNYXRoLnJhbmRvbSgpICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRkZWdUb1JhZDogZnVuY3Rpb24gKCBkZWdyZWVzICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBkZWdyZWVzICogX01hdGguREVHMlJBRDtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHJhZFRvRGVnOiBmdW5jdGlvbiAoIHJhZGlhbnMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHJhZGlhbnMgKiBfTWF0aC5SQUQyREVHO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0aXNQb3dlck9mVHdvOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiAoIHZhbHVlICYgKCB2YWx1ZSAtIDEgKSApID09PSAwICYmIHZhbHVlICE9PSAwO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y2VpbFBvd2VyT2ZUd286IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIE1hdGgucG93KCAyLCBNYXRoLmNlaWwoIE1hdGgubG9nKCB2YWx1ZSApIC8gTWF0aC5MTjIgKSApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Zmxvb3JQb3dlck9mVHdvOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBNYXRoLnBvdyggMiwgTWF0aC5mbG9vciggTWF0aC5sb2coIHZhbHVlICkgLyBNYXRoLkxOMiApICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xcclxcblxcdCAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXFxyXFxuXFx0ICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIFZlY3RvcjIoIHgsIHkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy54ID0geCB8fCAwO1xcclxcblxcdFxcdHRoaXMueSA9IHkgfHwgMDtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZlY3RvcjIucHJvdG90eXBlLCB7XFxyXFxuXFxyXFxuXFx0XFx0XFxcIndpZHRoXFxcIjoge1xcclxcblxcclxcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLng7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy54ID0gdmFsdWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0XFxcImhlaWdodFxcXCI6IHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy55O1xcclxcblxcclxcblxcdFxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMueSA9IHZhbHVlO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIFZlY3RvcjIucHJvdG90eXBlLCB7XFxyXFxuXFxyXFxuXFx0XFx0aXNWZWN0b3IyOiB0cnVlLFxcclxcblxcclxcblxcdFxcdHNldDogZnVuY3Rpb24gKCB4LCB5ICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMueCA9IHg7XFxyXFxuXFx0XFx0XFx0dGhpcy55ID0geTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldFNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy54ID0gc2NhbGFyO1xcclxcblxcdFxcdFxcdHRoaXMueSA9IHNjYWxhcjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldFg6IGZ1bmN0aW9uICggeCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggPSB4O1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0WTogZnVuY3Rpb24gKCB5ICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMueSA9IHk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXgsIHZhbHVlICkge1xcclxcblxcclxcblxcdFxcdFxcdHN3aXRjaCAoIGluZGV4ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xcclxcblxcdFxcdFxcdFxcdGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xcclxcblxcdFxcdFxcdFxcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Z2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4ICkge1xcclxcblxcclxcblxcdFxcdFxcdHN3aXRjaCAoIGluZGV4ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcXHJcXG5cXHRcXHRcXHRcXHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XFxyXFxuXFx0XFx0XFx0XFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnkgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggdiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggPSB2Lng7XFxyXFxuXFx0XFx0XFx0dGhpcy55ID0gdi55O1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0YWRkOiBmdW5jdGlvbiAoIHYsIHcgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMjogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHRoaXMueCArPSB2Lng7XFxyXFxuXFx0XFx0XFx0dGhpcy55ICs9IHYueTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMueCArPSBzO1xcclxcblxcdFxcdFxcdHRoaXMueSArPSBzO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0YWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMueCA9IGEueCArIGIueDtcXHJcXG5cXHRcXHRcXHR0aGlzLnkgPSBhLnkgKyBiLnk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRhZGRTY2FsZWRWZWN0b3I6IGZ1bmN0aW9uICggdiwgcyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggKz0gdi54ICogcztcXHJcXG5cXHRcXHRcXHR0aGlzLnkgKz0gdi55ICogcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHN1YjogZnVuY3Rpb24gKCB2LCB3ICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjI6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggLT0gdi54O1xcclxcblxcdFxcdFxcdHRoaXMueSAtPSB2Lnk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzdWJTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggLT0gcztcXHJcXG5cXHRcXHRcXHR0aGlzLnkgLT0gcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHN1YlZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggPSBhLnggLSBiLng7XFxyXFxuXFx0XFx0XFx0dGhpcy55ID0gYS55IC0gYi55O1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0bXVsdGlwbHk6IGZ1bmN0aW9uICggdiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggKj0gdi54O1xcclxcblxcdFxcdFxcdHRoaXMueSAqPSB2Lnk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy54ICo9IHNjYWxhcjtcXHJcXG5cXHRcXHRcXHR0aGlzLnkgKj0gc2NhbGFyO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0ZGl2aWRlOiBmdW5jdGlvbiAoIHYgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy54IC89IHYueDtcXHJcXG5cXHRcXHRcXHR0aGlzLnkgLz0gdi55O1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0ZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggMSAvIHNjYWxhciApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0YXBwbHlNYXRyaXgzOiBmdW5jdGlvbiAoIG0gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnk7XFxyXFxuXFx0XFx0XFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyAzIF0gKiB5ICsgZVsgNiBdO1xcclxcblxcdFxcdFxcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgNyBdO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0bWluOiBmdW5jdGlvbiAoIHYgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy54ID0gTWF0aC5taW4oIHRoaXMueCwgdi54ICk7XFxyXFxuXFx0XFx0XFx0dGhpcy55ID0gTWF0aC5taW4oIHRoaXMueSwgdi55ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRtYXg6IGZ1bmN0aW9uICggdiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggPSBNYXRoLm1heCggdGhpcy54LCB2LnggKTtcXHJcXG5cXHRcXHRcXHR0aGlzLnkgPSBNYXRoLm1heCggdGhpcy55LCB2LnkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNsYW1wOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xcclxcblxcclxcblxcdFxcdFxcdC8vIGFzc3VtZXMgbWluIDwgbWF4LCBjb21wb25lbnR3aXNlXFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy54ID0gTWF0aC5tYXgoIG1pbi54LCBNYXRoLm1pbiggbWF4LngsIHRoaXMueCApICk7XFxyXFxuXFx0XFx0XFx0dGhpcy55ID0gTWF0aC5tYXgoIG1pbi55LCBNYXRoLm1pbiggbWF4LnksIHRoaXMueSApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjbGFtcFNjYWxhcjogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBtaW4gPSBuZXcgVmVjdG9yMigpO1xcclxcblxcdFxcdFxcdHZhciBtYXggPSBuZXcgVmVjdG9yMigpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBjbGFtcFNjYWxhciggbWluVmFsLCBtYXhWYWwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bWluLnNldCggbWluVmFsLCBtaW5WYWwgKTtcXHJcXG5cXHRcXHRcXHRcXHRtYXguc2V0KCBtYXhWYWwsIG1heFZhbCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmNsYW1wKCBtaW4sIG1heCApO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdGNsYW1wTGVuZ3RoOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggbGVuZ3RoIHx8IDEgKS5tdWx0aXBseVNjYWxhciggTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgbGVuZ3RoICkgKSApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcXHJcXG5cXHRcXHRcXHR0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNlaWw6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xcclxcblxcdFxcdFxcdHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRyb3VuZDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xcclxcblxcdFxcdFxcdHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0cm91bmRUb1plcm86IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcXHJcXG5cXHRcXHRcXHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMueCA9IC0gdGhpcy54O1xcclxcblxcdFxcdFxcdHRoaXMueSA9IC0gdGhpcy55O1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGxlbmd0aDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0bWFuaGF0dGFuTGVuZ3RoOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSB8fCAxICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRhbmdsZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdC8vIGNvbXB1dGVzIHRoZSBhbmdsZSBpbiByYWRpYW5zIHdpdGggcmVzcGVjdCB0byB0aGUgcG9zaXRpdmUgeC1heGlzXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGFuZ2xlID0gTWF0aC5hdGFuMiggdGhpcy55LCB0aGlzLnggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGFuZ2xlIDwgMCApIGFuZ2xlICs9IDIgKiBNYXRoLlBJO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBhbmdsZTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGRpc3RhbmNlVG86IGZ1bmN0aW9uICggdiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKCB2ICkgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGRpc3RhbmNlVG9TcXVhcmVkOiBmdW5jdGlvbiAoIHYgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGR4ID0gdGhpcy54IC0gdi54LCBkeSA9IHRoaXMueSAtIHYueTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRtYW5oYXR0YW5EaXN0YW5jZVRvOiBmdW5jdGlvbiAoIHYgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggLSB2LnggKSArIE1hdGguYWJzKCB0aGlzLnkgLSB2LnkgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldExlbmd0aDogZnVuY3Rpb24gKCBsZW5ndGggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIGxlbmd0aCApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0bGVycDogZnVuY3Rpb24gKCB2LCBhbHBoYSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xcclxcblxcdFxcdFxcdHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRsZXJwVmVjdG9yczogZnVuY3Rpb24gKCB2MSwgdjIsIGFscGhhICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGVxdWFsczogZnVuY3Rpb24gKCB2ICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcXHJcXG5cXHRcXHRcXHR0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XFxyXFxuXFx0XFx0XFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xcclxcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGFycmF5O1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0ZnJvbUJ1ZmZlckF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBvZmZzZXQgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IyOiBvZmZzZXQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIC5mcm9tQnVmZmVyQXR0cmlidXRlKCkuJyApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggPSBhdHRyaWJ1dGUuZ2V0WCggaW5kZXggKTtcXHJcXG5cXHRcXHRcXHR0aGlzLnkgPSBhdHRyaWJ1dGUuZ2V0WSggaW5kZXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHJvdGF0ZUFyb3VuZDogZnVuY3Rpb24gKCBjZW50ZXIsIGFuZ2xlICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBjID0gTWF0aC5jb3MoIGFuZ2xlICksIHMgPSBNYXRoLnNpbiggYW5nbGUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgeCA9IHRoaXMueCAtIGNlbnRlci54O1xcclxcblxcdFxcdFxcdHZhciB5ID0gdGhpcy55IC0gY2VudGVyLnk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy54ID0geCAqIGMgLSB5ICogcyArIGNlbnRlci54O1xcclxcblxcdFxcdFxcdHRoaXMueSA9IHggKiBzICsgeSAqIGMgKyBjZW50ZXIueTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICogQGF1dGhvciBzdXBlcmVnZ2JlcnQgLyBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9cXHJcXG5cXHQgKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xcclxcblxcdCAqIEBhdXRob3Igam9yZGlfcm9zIC8gaHR0cDovL3BsYXR0c29mdC5jb21cXHJcXG5cXHQgKiBAYXV0aG9yIEQxcGxvMWQgLyBodHRwOi8vZ2l0aHViLmNvbS9EMXBsbzFkXFxyXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXHJcXG5cXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xcclxcblxcdCAqIEBhdXRob3IgdGlta25pcCAvIGh0dHA6Ly93d3cuZmxvb3JwbGFubmVyLmNvbS9cXHJcXG5cXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXFxyXFxuXFx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gTWF0cml4NCgpIHtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmVsZW1lbnRzID0gW1xcclxcblxcclxcblxcdFxcdFxcdDEsIDAsIDAsIDAsXFxyXFxuXFx0XFx0XFx0MCwgMSwgMCwgMCxcXHJcXG5cXHRcXHRcXHQwLCAwLCAxLCAwLFxcclxcblxcdFxcdFxcdDAsIDAsIDAsIDFcXHJcXG5cXHJcXG5cXHRcXHRdO1xcclxcblxcclxcblxcdFxcdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IHRoZSBjb25zdHJ1Y3RvciBubyBsb25nZXIgcmVhZHMgYXJndW1lbnRzLiB1c2UgLnNldCgpIGluc3RlYWQuJyApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0T2JqZWN0LmFzc2lnbiggTWF0cml4NC5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHRpc01hdHJpeDQ6IHRydWUsXFxyXFxuXFxyXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiAoIG4xMSwgbjEyLCBuMTMsIG4xNCwgbjIxLCBuMjIsIG4yMywgbjI0LCBuMzEsIG4zMiwgbjMzLCBuMzQsIG40MSwgbjQyLCBuNDMsIG40NCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xcclxcblxcclxcblxcdFxcdFxcdHRlWyAwIF0gPSBuMTE7IHRlWyA0IF0gPSBuMTI7IHRlWyA4IF0gPSBuMTM7IHRlWyAxMiBdID0gbjE0O1xcclxcblxcdFxcdFxcdHRlWyAxIF0gPSBuMjE7IHRlWyA1IF0gPSBuMjI7IHRlWyA5IF0gPSBuMjM7IHRlWyAxMyBdID0gbjI0O1xcclxcblxcdFxcdFxcdHRlWyAyIF0gPSBuMzE7IHRlWyA2IF0gPSBuMzI7IHRlWyAxMCBdID0gbjMzOyB0ZVsgMTQgXSA9IG4zNDtcXHJcXG5cXHRcXHRcXHR0ZVsgMyBdID0gbjQxOyB0ZVsgNyBdID0gbjQyOyB0ZVsgMTEgXSA9IG40MzsgdGVbIDE1IF0gPSBuNDQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRpZGVudGl0eTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuc2V0KFxcclxcblxcclxcblxcdFxcdFxcdFxcdDEsIDAsIDAsIDAsXFxyXFxuXFx0XFx0XFx0XFx0MCwgMSwgMCwgMCxcXHJcXG5cXHRcXHRcXHRcXHQwLCAwLCAxLCAwLFxcclxcblxcdFxcdFxcdFxcdDAsIDAsIDAsIDFcXHJcXG5cXHJcXG5cXHRcXHRcXHQpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gbmV3IE1hdHJpeDQoKS5mcm9tQXJyYXkoIHRoaXMuZWxlbWVudHMgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggbSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xcclxcblxcdFxcdFxcdHZhciBtZSA9IG0uZWxlbWVudHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGVbIDAgXSA9IG1lWyAwIF07IHRlWyAxIF0gPSBtZVsgMSBdOyB0ZVsgMiBdID0gbWVbIDIgXTsgdGVbIDMgXSA9IG1lWyAzIF07XFxyXFxuXFx0XFx0XFx0dGVbIDQgXSA9IG1lWyA0IF07IHRlWyA1IF0gPSBtZVsgNSBdOyB0ZVsgNiBdID0gbWVbIDYgXTsgdGVbIDcgXSA9IG1lWyA3IF07XFxyXFxuXFx0XFx0XFx0dGVbIDggXSA9IG1lWyA4IF07IHRlWyA5IF0gPSBtZVsgOSBdOyB0ZVsgMTAgXSA9IG1lWyAxMCBdOyB0ZVsgMTEgXSA9IG1lWyAxMSBdO1xcclxcblxcdFxcdFxcdHRlWyAxMiBdID0gbWVbIDEyIF07IHRlWyAxMyBdID0gbWVbIDEzIF07IHRlWyAxNCBdID0gbWVbIDE0IF07IHRlWyAxNSBdID0gbWVbIDE1IF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjb3B5UG9zaXRpb246IGZ1bmN0aW9uICggbSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzLCBtZSA9IG0uZWxlbWVudHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGVbIDEyIF0gPSBtZVsgMTIgXTtcXHJcXG5cXHRcXHRcXHR0ZVsgMTMgXSA9IG1lWyAxMyBdO1xcclxcblxcdFxcdFxcdHRlWyAxNCBdID0gbWVbIDE0IF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRleHRyYWN0QmFzaXM6IGZ1bmN0aW9uICggeEF4aXMsIHlBeGlzLCB6QXhpcyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR4QXhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCB0aGlzLCAwICk7XFxyXFxuXFx0XFx0XFx0eUF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbiggdGhpcywgMSApO1xcclxcblxcdFxcdFxcdHpBeGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIHRoaXMsIDIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdG1ha2VCYXNpczogZnVuY3Rpb24gKCB4QXhpcywgeUF4aXMsIHpBeGlzICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuc2V0KFxcclxcblxcdFxcdFxcdFxcdHhBeGlzLngsIHlBeGlzLngsIHpBeGlzLngsIDAsXFxyXFxuXFx0XFx0XFx0XFx0eEF4aXMueSwgeUF4aXMueSwgekF4aXMueSwgMCxcXHJcXG5cXHRcXHRcXHRcXHR4QXhpcy56LCB5QXhpcy56LCB6QXhpcy56LCAwLFxcclxcblxcdFxcdFxcdFxcdDAsIDAsIDAsIDFcXHJcXG5cXHRcXHRcXHQpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0ZXh0cmFjdFJvdGF0aW9uOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gZXh0cmFjdFJvdGF0aW9uKCBtICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIG1lID0gbS5lbGVtZW50cztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgc2NhbGVYID0gMSAvIHYxLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDAgKS5sZW5ndGgoKTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgc2NhbGVZID0gMSAvIHYxLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDEgKS5sZW5ndGgoKTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgc2NhbGVaID0gMSAvIHYxLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDIgKS5sZW5ndGgoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0ZVsgMCBdID0gbWVbIDAgXSAqIHNjYWxlWDtcXHJcXG5cXHRcXHRcXHRcXHR0ZVsgMSBdID0gbWVbIDEgXSAqIHNjYWxlWDtcXHJcXG5cXHRcXHRcXHRcXHR0ZVsgMiBdID0gbWVbIDIgXSAqIHNjYWxlWDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0ZVsgNCBdID0gbWVbIDQgXSAqIHNjYWxlWTtcXHJcXG5cXHRcXHRcXHRcXHR0ZVsgNSBdID0gbWVbIDUgXSAqIHNjYWxlWTtcXHJcXG5cXHRcXHRcXHRcXHR0ZVsgNiBdID0gbWVbIDYgXSAqIHNjYWxlWTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0ZVsgOCBdID0gbWVbIDggXSAqIHNjYWxlWjtcXHJcXG5cXHRcXHRcXHRcXHR0ZVsgOSBdID0gbWVbIDkgXSAqIHNjYWxlWjtcXHJcXG5cXHRcXHRcXHRcXHR0ZVsgMTAgXSA9IG1lWyAxMCBdICogc2NhbGVaO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdG1ha2VSb3RhdGlvbkZyb21FdWxlcjogZnVuY3Rpb24gKCBldWxlciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoICEgKCBldWxlciAmJiBldWxlci5pc0V1bGVyICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5tYWtlUm90YXRpb25Gcm9tRXVsZXIoKSBub3cgZXhwZWN0cyBhIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xcclxcblxcclxcblxcdFxcdFxcdHZhciB4ID0gZXVsZXIueCwgeSA9IGV1bGVyLnksIHogPSBldWxlci56O1xcclxcblxcdFxcdFxcdHZhciBhID0gTWF0aC5jb3MoIHggKSwgYiA9IE1hdGguc2luKCB4ICk7XFxyXFxuXFx0XFx0XFx0dmFyIGMgPSBNYXRoLmNvcyggeSApLCBkID0gTWF0aC5zaW4oIHkgKTtcXHJcXG5cXHRcXHRcXHR2YXIgZSA9IE1hdGguY29zKCB6ICksIGYgPSBNYXRoLnNpbiggeiApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggZXVsZXIub3JkZXIgPT09ICdYWVonICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBhZSA9IGEgKiBlLCBhZiA9IGEgKiBmLCBiZSA9IGIgKiBlLCBiZiA9IGIgKiBmO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRlWyAwIF0gPSBjICogZTtcXHJcXG5cXHRcXHRcXHRcXHR0ZVsgNCBdID0gLSBjICogZjtcXHJcXG5cXHRcXHRcXHRcXHR0ZVsgOCBdID0gZDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0ZVsgMSBdID0gYWYgKyBiZSAqIGQ7XFxyXFxuXFx0XFx0XFx0XFx0dGVbIDUgXSA9IGFlIC0gYmYgKiBkO1xcclxcblxcdFxcdFxcdFxcdHRlWyA5IF0gPSAtIGIgKiBjO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRlWyAyIF0gPSBiZiAtIGFlICogZDtcXHJcXG5cXHRcXHRcXHRcXHR0ZVsgNiBdID0gYmUgKyBhZiAqIGQ7XFxyXFxuXFx0XFx0XFx0XFx0dGVbIDEwIF0gPSBhICogYztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1lYWicgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGNlID0gYyAqIGUsIGNmID0gYyAqIGYsIGRlID0gZCAqIGUsIGRmID0gZCAqIGY7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGVbIDAgXSA9IGNlICsgZGYgKiBiO1xcclxcblxcdFxcdFxcdFxcdHRlWyA0IF0gPSBkZSAqIGIgLSBjZjtcXHJcXG5cXHRcXHRcXHRcXHR0ZVsgOCBdID0gYSAqIGQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGVbIDEgXSA9IGEgKiBmO1xcclxcblxcdFxcdFxcdFxcdHRlWyA1IF0gPSBhICogZTtcXHJcXG5cXHRcXHRcXHRcXHR0ZVsgOSBdID0gLSBiO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRlWyAyIF0gPSBjZiAqIGIgLSBkZTtcXHJcXG5cXHRcXHRcXHRcXHR0ZVsgNiBdID0gZGYgKyBjZSAqIGI7XFxyXFxuXFx0XFx0XFx0XFx0dGVbIDEwIF0gPSBhICogYztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pYWScgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGNlID0gYyAqIGUsIGNmID0gYyAqIGYsIGRlID0gZCAqIGUsIGRmID0gZCAqIGY7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGVbIDAgXSA9IGNlIC0gZGYgKiBiO1xcclxcblxcdFxcdFxcdFxcdHRlWyA0IF0gPSAtIGEgKiBmO1xcclxcblxcdFxcdFxcdFxcdHRlWyA4IF0gPSBkZSArIGNmICogYjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0ZVsgMSBdID0gY2YgKyBkZSAqIGI7XFxyXFxuXFx0XFx0XFx0XFx0dGVbIDUgXSA9IGEgKiBlO1xcclxcblxcdFxcdFxcdFxcdHRlWyA5IF0gPSBkZiAtIGNlICogYjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0ZVsgMiBdID0gLSBhICogZDtcXHJcXG5cXHRcXHRcXHRcXHR0ZVsgNiBdID0gYjtcXHJcXG5cXHRcXHRcXHRcXHR0ZVsgMTAgXSA9IGEgKiBjO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWllYJyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgYWUgPSBhICogZSwgYWYgPSBhICogZiwgYmUgPSBiICogZSwgYmYgPSBiICogZjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0ZVsgMCBdID0gYyAqIGU7XFxyXFxuXFx0XFx0XFx0XFx0dGVbIDQgXSA9IGJlICogZCAtIGFmO1xcclxcblxcdFxcdFxcdFxcdHRlWyA4IF0gPSBhZSAqIGQgKyBiZjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0ZVsgMSBdID0gYyAqIGY7XFxyXFxuXFx0XFx0XFx0XFx0dGVbIDUgXSA9IGJmICogZCArIGFlO1xcclxcblxcdFxcdFxcdFxcdHRlWyA5IF0gPSBhZiAqIGQgLSBiZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0ZVsgMiBdID0gLSBkO1xcclxcblxcdFxcdFxcdFxcdHRlWyA2IF0gPSBiICogYztcXHJcXG5cXHRcXHRcXHRcXHR0ZVsgMTAgXSA9IGEgKiBjO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWVpYJyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgYWMgPSBhICogYywgYWQgPSBhICogZCwgYmMgPSBiICogYywgYmQgPSBiICogZDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0ZVsgMCBdID0gYyAqIGU7XFxyXFxuXFx0XFx0XFx0XFx0dGVbIDQgXSA9IGJkIC0gYWMgKiBmO1xcclxcblxcdFxcdFxcdFxcdHRlWyA4IF0gPSBiYyAqIGYgKyBhZDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0ZVsgMSBdID0gZjtcXHJcXG5cXHRcXHRcXHRcXHR0ZVsgNSBdID0gYSAqIGU7XFxyXFxuXFx0XFx0XFx0XFx0dGVbIDkgXSA9IC0gYiAqIGU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGVbIDIgXSA9IC0gZCAqIGU7XFxyXFxuXFx0XFx0XFx0XFx0dGVbIDYgXSA9IGFkICogZiArIGJjO1xcclxcblxcdFxcdFxcdFxcdHRlWyAxMCBdID0gYWMgLSBiZCAqIGY7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdYWlknICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBhYyA9IGEgKiBjLCBhZCA9IGEgKiBkLCBiYyA9IGIgKiBjLCBiZCA9IGIgKiBkO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRlWyAwIF0gPSBjICogZTtcXHJcXG5cXHRcXHRcXHRcXHR0ZVsgNCBdID0gLSBmO1xcclxcblxcdFxcdFxcdFxcdHRlWyA4IF0gPSBkICogZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0ZVsgMSBdID0gYWMgKiBmICsgYmQ7XFxyXFxuXFx0XFx0XFx0XFx0dGVbIDUgXSA9IGEgKiBlO1xcclxcblxcdFxcdFxcdFxcdHRlWyA5IF0gPSBhZCAqIGYgLSBiYztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0ZVsgMiBdID0gYmMgKiBmIC0gYWQ7XFxyXFxuXFx0XFx0XFx0XFx0dGVbIDYgXSA9IGIgKiBlO1xcclxcblxcdFxcdFxcdFxcdHRlWyAxMCBdID0gYmQgKiBmICsgYWM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdC8vIGxhc3QgY29sdW1uXFxyXFxuXFx0XFx0XFx0dGVbIDMgXSA9IDA7XFxyXFxuXFx0XFx0XFx0dGVbIDcgXSA9IDA7XFxyXFxuXFx0XFx0XFx0dGVbIDExIF0gPSAwO1xcclxcblxcclxcblxcdFxcdFxcdC8vIGJvdHRvbSByb3dcXHJcXG5cXHRcXHRcXHR0ZVsgMTIgXSA9IDA7XFxyXFxuXFx0XFx0XFx0dGVbIDEzIF0gPSAwO1xcclxcblxcdFxcdFxcdHRlWyAxNCBdID0gMDtcXHJcXG5cXHRcXHRcXHR0ZVsgMTUgXSA9IDE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRtYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHggPSBxLl94LCB5ID0gcS5feSwgeiA9IHEuX3osIHcgPSBxLl93O1xcclxcblxcdFxcdFxcdHZhciB4MiA9IHggKyB4LCB5MiA9IHkgKyB5LCB6MiA9IHogKyB6O1xcclxcblxcdFxcdFxcdHZhciB4eCA9IHggKiB4MiwgeHkgPSB4ICogeTIsIHh6ID0geCAqIHoyO1xcclxcblxcdFxcdFxcdHZhciB5eSA9IHkgKiB5MiwgeXogPSB5ICogejIsIHp6ID0geiAqIHoyO1xcclxcblxcdFxcdFxcdHZhciB3eCA9IHcgKiB4Miwgd3kgPSB3ICogeTIsIHd6ID0gdyAqIHoyO1xcclxcblxcclxcblxcdFxcdFxcdHRlWyAwIF0gPSAxIC0gKCB5eSArIHp6ICk7XFxyXFxuXFx0XFx0XFx0dGVbIDQgXSA9IHh5IC0gd3o7XFxyXFxuXFx0XFx0XFx0dGVbIDggXSA9IHh6ICsgd3k7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGVbIDEgXSA9IHh5ICsgd3o7XFxyXFxuXFx0XFx0XFx0dGVbIDUgXSA9IDEgLSAoIHh4ICsgenogKTtcXHJcXG5cXHRcXHRcXHR0ZVsgOSBdID0geXogLSB3eDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0ZVsgMiBdID0geHogLSB3eTtcXHJcXG5cXHRcXHRcXHR0ZVsgNiBdID0geXogKyB3eDtcXHJcXG5cXHRcXHRcXHR0ZVsgMTAgXSA9IDEgLSAoIHh4ICsgeXkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBsYXN0IGNvbHVtblxcclxcblxcdFxcdFxcdHRlWyAzIF0gPSAwO1xcclxcblxcdFxcdFxcdHRlWyA3IF0gPSAwO1xcclxcblxcdFxcdFxcdHRlWyAxMSBdID0gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBib3R0b20gcm93XFxyXFxuXFx0XFx0XFx0dGVbIDEyIF0gPSAwO1xcclxcblxcdFxcdFxcdHRlWyAxMyBdID0gMDtcXHJcXG5cXHRcXHRcXHR0ZVsgMTQgXSA9IDA7XFxyXFxuXFx0XFx0XFx0dGVbIDE1IF0gPSAxO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0bG9va0F0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHggPSBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdFxcdHZhciB5ID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHRcXHRcXHR2YXIgeiA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGxvb2tBdCggZXllLCB0YXJnZXQsIHVwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ei5zdWJWZWN0b3JzKCBleWUsIHRhcmdldCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggei5sZW5ndGhTcSgpID09PSAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIGV5ZSBhbmQgdGFyZ2V0IGFyZSBpbiB0aGUgc2FtZSBwb3NpdGlvblxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHoueiA9IDE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHoubm9ybWFsaXplKCk7XFxyXFxuXFx0XFx0XFx0XFx0eC5jcm9zc1ZlY3RvcnMoIHVwLCB6ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB4Lmxlbmd0aFNxKCkgPT09IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdXAgYW5kIHogYXJlIHBhcmFsbGVsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBNYXRoLmFicyggdXAueiApID09PSAxICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHoueCArPSAwLjAwMDE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LnogKz0gMC4wMDAxO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR6Lm5vcm1hbGl6ZSgpO1xcclxcblxcdFxcdFxcdFxcdFxcdHguY3Jvc3NWZWN0b3JzKCB1cCwgeiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR4Lm5vcm1hbGl6ZSgpO1xcclxcblxcdFxcdFxcdFxcdHkuY3Jvc3NWZWN0b3JzKCB6LCB4ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGVbIDAgXSA9IHgueDsgdGVbIDQgXSA9IHkueDsgdGVbIDggXSA9IHoueDtcXHJcXG5cXHRcXHRcXHRcXHR0ZVsgMSBdID0geC55OyB0ZVsgNSBdID0geS55OyB0ZVsgOSBdID0gei55O1xcclxcblxcdFxcdFxcdFxcdHRlWyAyIF0gPSB4Lno7IHRlWyA2IF0gPSB5Lno7IHRlWyAxMCBdID0gei56O1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdG11bHRpcGx5OiBmdW5jdGlvbiAoIG0sIG4gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBuICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlNYXRyaWNlcyggYSwgYiApIGluc3RlYWQuJyApO1xcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIG0sIG4gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggdGhpcywgbSApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0cHJlbXVsdGlwbHk6IGZ1bmN0aW9uICggbSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCBtLCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRtdWx0aXBseU1hdHJpY2VzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGFlID0gYS5lbGVtZW50cztcXHJcXG5cXHRcXHRcXHR2YXIgYmUgPSBiLmVsZW1lbnRzO1xcclxcblxcdFxcdFxcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGExMSA9IGFlWyAwIF0sIGExMiA9IGFlWyA0IF0sIGExMyA9IGFlWyA4IF0sIGExNCA9IGFlWyAxMiBdO1xcclxcblxcdFxcdFxcdHZhciBhMjEgPSBhZVsgMSBdLCBhMjIgPSBhZVsgNSBdLCBhMjMgPSBhZVsgOSBdLCBhMjQgPSBhZVsgMTMgXTtcXHJcXG5cXHRcXHRcXHR2YXIgYTMxID0gYWVbIDIgXSwgYTMyID0gYWVbIDYgXSwgYTMzID0gYWVbIDEwIF0sIGEzNCA9IGFlWyAxNCBdO1xcclxcblxcdFxcdFxcdHZhciBhNDEgPSBhZVsgMyBdLCBhNDIgPSBhZVsgNyBdLCBhNDMgPSBhZVsgMTEgXSwgYTQ0ID0gYWVbIDE1IF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGIxMSA9IGJlWyAwIF0sIGIxMiA9IGJlWyA0IF0sIGIxMyA9IGJlWyA4IF0sIGIxNCA9IGJlWyAxMiBdO1xcclxcblxcdFxcdFxcdHZhciBiMjEgPSBiZVsgMSBdLCBiMjIgPSBiZVsgNSBdLCBiMjMgPSBiZVsgOSBdLCBiMjQgPSBiZVsgMTMgXTtcXHJcXG5cXHRcXHRcXHR2YXIgYjMxID0gYmVbIDIgXSwgYjMyID0gYmVbIDYgXSwgYjMzID0gYmVbIDEwIF0sIGIzNCA9IGJlWyAxNCBdO1xcclxcblxcdFxcdFxcdHZhciBiNDEgPSBiZVsgMyBdLCBiNDIgPSBiZVsgNyBdLCBiNDMgPSBiZVsgMTEgXSwgYjQ0ID0gYmVbIDE1IF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGVbIDAgXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMSArIGExNCAqIGI0MTtcXHJcXG5cXHRcXHRcXHR0ZVsgNCBdID0gYTExICogYjEyICsgYTEyICogYjIyICsgYTEzICogYjMyICsgYTE0ICogYjQyO1xcclxcblxcdFxcdFxcdHRlWyA4IF0gPSBhMTEgKiBiMTMgKyBhMTIgKiBiMjMgKyBhMTMgKiBiMzMgKyBhMTQgKiBiNDM7XFxyXFxuXFx0XFx0XFx0dGVbIDEyIF0gPSBhMTEgKiBiMTQgKyBhMTIgKiBiMjQgKyBhMTMgKiBiMzQgKyBhMTQgKiBiNDQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGVbIDEgXSA9IGEyMSAqIGIxMSArIGEyMiAqIGIyMSArIGEyMyAqIGIzMSArIGEyNCAqIGI0MTtcXHJcXG5cXHRcXHRcXHR0ZVsgNSBdID0gYTIxICogYjEyICsgYTIyICogYjIyICsgYTIzICogYjMyICsgYTI0ICogYjQyO1xcclxcblxcdFxcdFxcdHRlWyA5IF0gPSBhMjEgKiBiMTMgKyBhMjIgKiBiMjMgKyBhMjMgKiBiMzMgKyBhMjQgKiBiNDM7XFxyXFxuXFx0XFx0XFx0dGVbIDEzIF0gPSBhMjEgKiBiMTQgKyBhMjIgKiBiMjQgKyBhMjMgKiBiMzQgKyBhMjQgKiBiNDQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGVbIDIgXSA9IGEzMSAqIGIxMSArIGEzMiAqIGIyMSArIGEzMyAqIGIzMSArIGEzNCAqIGI0MTtcXHJcXG5cXHRcXHRcXHR0ZVsgNiBdID0gYTMxICogYjEyICsgYTMyICogYjIyICsgYTMzICogYjMyICsgYTM0ICogYjQyO1xcclxcblxcdFxcdFxcdHRlWyAxMCBdID0gYTMxICogYjEzICsgYTMyICogYjIzICsgYTMzICogYjMzICsgYTM0ICogYjQzO1xcclxcblxcdFxcdFxcdHRlWyAxNCBdID0gYTMxICogYjE0ICsgYTMyICogYjI0ICsgYTMzICogYjM0ICsgYTM0ICogYjQ0O1xcclxcblxcclxcblxcdFxcdFxcdHRlWyAzIF0gPSBhNDEgKiBiMTEgKyBhNDIgKiBiMjEgKyBhNDMgKiBiMzEgKyBhNDQgKiBiNDE7XFxyXFxuXFx0XFx0XFx0dGVbIDcgXSA9IGE0MSAqIGIxMiArIGE0MiAqIGIyMiArIGE0MyAqIGIzMiArIGE0NCAqIGI0MjtcXHJcXG5cXHRcXHRcXHR0ZVsgMTEgXSA9IGE0MSAqIGIxMyArIGE0MiAqIGIyMyArIGE0MyAqIGIzMyArIGE0NCAqIGI0MztcXHJcXG5cXHRcXHRcXHR0ZVsgMTUgXSA9IGE0MSAqIGIxNCArIGE0MiAqIGIyNCArIGE0MyAqIGIzNCArIGE0NCAqIGI0NDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcXHJcXG5cXHJcXG5cXHRcXHRcXHR0ZVsgMCBdICo9IHM7IHRlWyA0IF0gKj0gczsgdGVbIDggXSAqPSBzOyB0ZVsgMTIgXSAqPSBzO1xcclxcblxcdFxcdFxcdHRlWyAxIF0gKj0gczsgdGVbIDUgXSAqPSBzOyB0ZVsgOSBdICo9IHM7IHRlWyAxMyBdICo9IHM7XFxyXFxuXFx0XFx0XFx0dGVbIDIgXSAqPSBzOyB0ZVsgNiBdICo9IHM7IHRlWyAxMCBdICo9IHM7IHRlWyAxNCBdICo9IHM7XFxyXFxuXFx0XFx0XFx0dGVbIDMgXSAqPSBzOyB0ZVsgNyBdICo9IHM7IHRlWyAxMSBdICo9IHM7IHRlWyAxNSBdICo9IHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRhcHBseVRvQnVmZmVyQXR0cmlidXRlOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gYXBwbHlUb0J1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGF0dHJpYnV0ZS5jb3VudDsgaSA8IGw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0djEueCA9IGF0dHJpYnV0ZS5nZXRYKCBpICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0djEueSA9IGF0dHJpYnV0ZS5nZXRZKCBpICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0djEueiA9IGF0dHJpYnV0ZS5nZXRaKCBpICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0djEuYXBwbHlNYXRyaXg0KCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0YXR0cmlidXRlLnNldFhZWiggaSwgdjEueCwgdjEueSwgdjEueiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gYXR0cmlidXRlO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdGRldGVybWluYW50OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbjExID0gdGVbIDAgXSwgbjEyID0gdGVbIDQgXSwgbjEzID0gdGVbIDggXSwgbjE0ID0gdGVbIDEyIF07XFxyXFxuXFx0XFx0XFx0dmFyIG4yMSA9IHRlWyAxIF0sIG4yMiA9IHRlWyA1IF0sIG4yMyA9IHRlWyA5IF0sIG4yNCA9IHRlWyAxMyBdO1xcclxcblxcdFxcdFxcdHZhciBuMzEgPSB0ZVsgMiBdLCBuMzIgPSB0ZVsgNiBdLCBuMzMgPSB0ZVsgMTAgXSwgbjM0ID0gdGVbIDE0IF07XFxyXFxuXFx0XFx0XFx0dmFyIG40MSA9IHRlWyAzIF0sIG40MiA9IHRlWyA3IF0sIG40MyA9IHRlWyAxMSBdLCBuNDQgPSB0ZVsgMTUgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvL1RPRE86IG1ha2UgdGhpcyBtb3JlIGVmZmljaWVudFxcclxcblxcdFxcdFxcdC8vKCBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG0gKVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiAoXFxyXFxuXFx0XFx0XFx0XFx0bjQxICogKFxcclxcblxcdFxcdFxcdFxcdFxcdCsgbjE0ICogbjIzICogbjMyXFxyXFxuXFx0XFx0XFx0XFx0XFx0IC0gbjEzICogbjI0ICogbjMyXFxyXFxuXFx0XFx0XFx0XFx0XFx0IC0gbjE0ICogbjIyICogbjMzXFxyXFxuXFx0XFx0XFx0XFx0XFx0ICsgbjEyICogbjI0ICogbjMzXFxyXFxuXFx0XFx0XFx0XFx0XFx0ICsgbjEzICogbjIyICogbjM0XFxyXFxuXFx0XFx0XFx0XFx0XFx0IC0gbjEyICogbjIzICogbjM0XFxyXFxuXFx0XFx0XFx0XFx0KSArXFxyXFxuXFx0XFx0XFx0XFx0bjQyICogKFxcclxcblxcdFxcdFxcdFxcdFxcdCsgbjExICogbjIzICogbjM0XFxyXFxuXFx0XFx0XFx0XFx0XFx0IC0gbjExICogbjI0ICogbjMzXFxyXFxuXFx0XFx0XFx0XFx0XFx0ICsgbjE0ICogbjIxICogbjMzXFxyXFxuXFx0XFx0XFx0XFx0XFx0IC0gbjEzICogbjIxICogbjM0XFxyXFxuXFx0XFx0XFx0XFx0XFx0ICsgbjEzICogbjI0ICogbjMxXFxyXFxuXFx0XFx0XFx0XFx0XFx0IC0gbjE0ICogbjIzICogbjMxXFxyXFxuXFx0XFx0XFx0XFx0KSArXFxyXFxuXFx0XFx0XFx0XFx0bjQzICogKFxcclxcblxcdFxcdFxcdFxcdFxcdCsgbjExICogbjI0ICogbjMyXFxyXFxuXFx0XFx0XFx0XFx0XFx0IC0gbjExICogbjIyICogbjM0XFxyXFxuXFx0XFx0XFx0XFx0XFx0IC0gbjE0ICogbjIxICogbjMyXFxyXFxuXFx0XFx0XFx0XFx0XFx0ICsgbjEyICogbjIxICogbjM0XFxyXFxuXFx0XFx0XFx0XFx0XFx0ICsgbjE0ICogbjIyICogbjMxXFxyXFxuXFx0XFx0XFx0XFx0XFx0IC0gbjEyICogbjI0ICogbjMxXFxyXFxuXFx0XFx0XFx0XFx0KSArXFxyXFxuXFx0XFx0XFx0XFx0bjQ0ICogKFxcclxcblxcdFxcdFxcdFxcdFxcdC0gbjEzICogbjIyICogbjMxXFxyXFxuXFx0XFx0XFx0XFx0XFx0IC0gbjExICogbjIzICogbjMyXFxyXFxuXFx0XFx0XFx0XFx0XFx0ICsgbjExICogbjIyICogbjMzXFxyXFxuXFx0XFx0XFx0XFx0XFx0ICsgbjEzICogbjIxICogbjMyXFxyXFxuXFx0XFx0XFx0XFx0XFx0IC0gbjEyICogbjIxICogbjMzXFxyXFxuXFx0XFx0XFx0XFx0XFx0ICsgbjEyICogbjIzICogbjMxXFxyXFxuXFx0XFx0XFx0XFx0KVxcclxcblxcclxcblxcdFxcdFxcdCk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHR0cmFuc3Bvc2U6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xcclxcblxcdFxcdFxcdHZhciB0bXA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dG1wID0gdGVbIDEgXTsgdGVbIDEgXSA9IHRlWyA0IF07IHRlWyA0IF0gPSB0bXA7XFxyXFxuXFx0XFx0XFx0dG1wID0gdGVbIDIgXTsgdGVbIDIgXSA9IHRlWyA4IF07IHRlWyA4IF0gPSB0bXA7XFxyXFxuXFx0XFx0XFx0dG1wID0gdGVbIDYgXTsgdGVbIDYgXSA9IHRlWyA5IF07IHRlWyA5IF0gPSB0bXA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dG1wID0gdGVbIDMgXTsgdGVbIDMgXSA9IHRlWyAxMiBdOyB0ZVsgMTIgXSA9IHRtcDtcXHJcXG5cXHRcXHRcXHR0bXAgPSB0ZVsgNyBdOyB0ZVsgNyBdID0gdGVbIDEzIF07IHRlWyAxMyBdID0gdG1wO1xcclxcblxcdFxcdFxcdHRtcCA9IHRlWyAxMSBdOyB0ZVsgMTEgXSA9IHRlWyAxNCBdOyB0ZVsgMTQgXSA9IHRtcDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldFBvc2l0aW9uOiBmdW5jdGlvbiAoIHYgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcXHJcXG5cXHJcXG5cXHRcXHRcXHR0ZVsgMTIgXSA9IHYueDtcXHJcXG5cXHRcXHRcXHR0ZVsgMTMgXSA9IHYueTtcXHJcXG5cXHRcXHRcXHR0ZVsgMTQgXSA9IHYuejtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGdldEludmVyc2U6IGZ1bmN0aW9uICggbSwgdGhyb3dPbkRlZ2VuZXJhdGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtXFxyXFxuXFx0XFx0XFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cyxcXHJcXG5cXHRcXHRcXHRcXHRtZSA9IG0uZWxlbWVudHMsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bjExID0gbWVbIDAgXSwgbjIxID0gbWVbIDEgXSwgbjMxID0gbWVbIDIgXSwgbjQxID0gbWVbIDMgXSxcXHJcXG5cXHRcXHRcXHRcXHRuMTIgPSBtZVsgNCBdLCBuMjIgPSBtZVsgNSBdLCBuMzIgPSBtZVsgNiBdLCBuNDIgPSBtZVsgNyBdLFxcclxcblxcdFxcdFxcdFxcdG4xMyA9IG1lWyA4IF0sIG4yMyA9IG1lWyA5IF0sIG4zMyA9IG1lWyAxMCBdLCBuNDMgPSBtZVsgMTEgXSxcXHJcXG5cXHRcXHRcXHRcXHRuMTQgPSBtZVsgMTIgXSwgbjI0ID0gbWVbIDEzIF0sIG4zNCA9IG1lWyAxNCBdLCBuNDQgPSBtZVsgMTUgXSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0MTEgPSBuMjMgKiBuMzQgKiBuNDIgLSBuMjQgKiBuMzMgKiBuNDIgKyBuMjQgKiBuMzIgKiBuNDMgLSBuMjIgKiBuMzQgKiBuNDMgLSBuMjMgKiBuMzIgKiBuNDQgKyBuMjIgKiBuMzMgKiBuNDQsXFxyXFxuXFx0XFx0XFx0XFx0dDEyID0gbjE0ICogbjMzICogbjQyIC0gbjEzICogbjM0ICogbjQyIC0gbjE0ICogbjMyICogbjQzICsgbjEyICogbjM0ICogbjQzICsgbjEzICogbjMyICogbjQ0IC0gbjEyICogbjMzICogbjQ0LFxcclxcblxcdFxcdFxcdFxcdHQxMyA9IG4xMyAqIG4yNCAqIG40MiAtIG4xNCAqIG4yMyAqIG40MiArIG4xNCAqIG4yMiAqIG40MyAtIG4xMiAqIG4yNCAqIG40MyAtIG4xMyAqIG4yMiAqIG40NCArIG4xMiAqIG4yMyAqIG40NCxcXHJcXG5cXHRcXHRcXHRcXHR0MTQgPSBuMTQgKiBuMjMgKiBuMzIgLSBuMTMgKiBuMjQgKiBuMzIgLSBuMTQgKiBuMjIgKiBuMzMgKyBuMTIgKiBuMjQgKiBuMzMgKyBuMTMgKiBuMjIgKiBuMzQgLSBuMTIgKiBuMjMgKiBuMzQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGRldCA9IG4xMSAqIHQxMSArIG4yMSAqIHQxMiArIG4zMSAqIHQxMyArIG40MSAqIHQxNDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGRldCA9PT0gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgbXNnID0gXFxcIlRIUkVFLk1hdHJpeDQ6IC5nZXRJbnZlcnNlKCkgY2FuJ3QgaW52ZXJ0IG1hdHJpeCwgZGV0ZXJtaW5hbnQgaXMgMFxcXCI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB0aHJvd09uRGVnZW5lcmF0ZSA9PT0gdHJ1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCBtc2cgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuaWRlbnRpdHkoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGRldEludiA9IDEgLyBkZXQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGVbIDAgXSA9IHQxMSAqIGRldEludjtcXHJcXG5cXHRcXHRcXHR0ZVsgMSBdID0gKCBuMjQgKiBuMzMgKiBuNDEgLSBuMjMgKiBuMzQgKiBuNDEgLSBuMjQgKiBuMzEgKiBuNDMgKyBuMjEgKiBuMzQgKiBuNDMgKyBuMjMgKiBuMzEgKiBuNDQgLSBuMjEgKiBuMzMgKiBuNDQgKSAqIGRldEludjtcXHJcXG5cXHRcXHRcXHR0ZVsgMiBdID0gKCBuMjIgKiBuMzQgKiBuNDEgLSBuMjQgKiBuMzIgKiBuNDEgKyBuMjQgKiBuMzEgKiBuNDIgLSBuMjEgKiBuMzQgKiBuNDIgLSBuMjIgKiBuMzEgKiBuNDQgKyBuMjEgKiBuMzIgKiBuNDQgKSAqIGRldEludjtcXHJcXG5cXHRcXHRcXHR0ZVsgMyBdID0gKCBuMjMgKiBuMzIgKiBuNDEgLSBuMjIgKiBuMzMgKiBuNDEgLSBuMjMgKiBuMzEgKiBuNDIgKyBuMjEgKiBuMzMgKiBuNDIgKyBuMjIgKiBuMzEgKiBuNDMgLSBuMjEgKiBuMzIgKiBuNDMgKSAqIGRldEludjtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0ZVsgNCBdID0gdDEyICogZGV0SW52O1xcclxcblxcdFxcdFxcdHRlWyA1IF0gPSAoIG4xMyAqIG4zNCAqIG40MSAtIG4xNCAqIG4zMyAqIG40MSArIG4xNCAqIG4zMSAqIG40MyAtIG4xMSAqIG4zNCAqIG40MyAtIG4xMyAqIG4zMSAqIG40NCArIG4xMSAqIG4zMyAqIG40NCApICogZGV0SW52O1xcclxcblxcdFxcdFxcdHRlWyA2IF0gPSAoIG4xNCAqIG4zMiAqIG40MSAtIG4xMiAqIG4zNCAqIG40MSAtIG4xNCAqIG4zMSAqIG40MiArIG4xMSAqIG4zNCAqIG40MiArIG4xMiAqIG4zMSAqIG40NCAtIG4xMSAqIG4zMiAqIG40NCApICogZGV0SW52O1xcclxcblxcdFxcdFxcdHRlWyA3IF0gPSAoIG4xMiAqIG4zMyAqIG40MSAtIG4xMyAqIG4zMiAqIG40MSArIG4xMyAqIG4zMSAqIG40MiAtIG4xMSAqIG4zMyAqIG40MiAtIG4xMiAqIG4zMSAqIG40MyArIG4xMSAqIG4zMiAqIG40MyApICogZGV0SW52O1xcclxcblxcclxcblxcdFxcdFxcdHRlWyA4IF0gPSB0MTMgKiBkZXRJbnY7XFxyXFxuXFx0XFx0XFx0dGVbIDkgXSA9ICggbjE0ICogbjIzICogbjQxIC0gbjEzICogbjI0ICogbjQxIC0gbjE0ICogbjIxICogbjQzICsgbjExICogbjI0ICogbjQzICsgbjEzICogbjIxICogbjQ0IC0gbjExICogbjIzICogbjQ0ICkgKiBkZXRJbnY7XFxyXFxuXFx0XFx0XFx0dGVbIDEwIF0gPSAoIG4xMiAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMiAqIG40MSArIG4xNCAqIG4yMSAqIG40MiAtIG4xMSAqIG4yNCAqIG40MiAtIG4xMiAqIG4yMSAqIG40NCArIG4xMSAqIG4yMiAqIG40NCApICogZGV0SW52O1xcclxcblxcdFxcdFxcdHRlWyAxMSBdID0gKCBuMTMgKiBuMjIgKiBuNDEgLSBuMTIgKiBuMjMgKiBuNDEgLSBuMTMgKiBuMjEgKiBuNDIgKyBuMTEgKiBuMjMgKiBuNDIgKyBuMTIgKiBuMjEgKiBuNDMgLSBuMTEgKiBuMjIgKiBuNDMgKSAqIGRldEludjtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0ZVsgMTIgXSA9IHQxNCAqIGRldEludjtcXHJcXG5cXHRcXHRcXHR0ZVsgMTMgXSA9ICggbjEzICogbjI0ICogbjMxIC0gbjE0ICogbjIzICogbjMxICsgbjE0ICogbjIxICogbjMzIC0gbjExICogbjI0ICogbjMzIC0gbjEzICogbjIxICogbjM0ICsgbjExICogbjIzICogbjM0ICkgKiBkZXRJbnY7XFxyXFxuXFx0XFx0XFx0dGVbIDE0IF0gPSAoIG4xNCAqIG4yMiAqIG4zMSAtIG4xMiAqIG4yNCAqIG4zMSAtIG4xNCAqIG4yMSAqIG4zMiArIG4xMSAqIG4yNCAqIG4zMiArIG4xMiAqIG4yMSAqIG4zNCAtIG4xMSAqIG4yMiAqIG4zNCApICogZGV0SW52O1xcclxcblxcdFxcdFxcdHRlWyAxNSBdID0gKCBuMTIgKiBuMjMgKiBuMzEgLSBuMTMgKiBuMjIgKiBuMzEgKyBuMTMgKiBuMjEgKiBuMzIgLSBuMTEgKiBuMjMgKiBuMzIgLSBuMTIgKiBuMjEgKiBuMzMgKyBuMTEgKiBuMjIgKiBuMzMgKSAqIGRldEludjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNjYWxlOiBmdW5jdGlvbiAoIHYgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcXHJcXG5cXHRcXHRcXHR2YXIgeCA9IHYueCwgeSA9IHYueSwgeiA9IHYuejtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0ZVsgMCBdICo9IHg7IHRlWyA0IF0gKj0geTsgdGVbIDggXSAqPSB6O1xcclxcblxcdFxcdFxcdHRlWyAxIF0gKj0geDsgdGVbIDUgXSAqPSB5OyB0ZVsgOSBdICo9IHo7XFxyXFxuXFx0XFx0XFx0dGVbIDIgXSAqPSB4OyB0ZVsgNiBdICo9IHk7IHRlWyAxMCBdICo9IHo7XFxyXFxuXFx0XFx0XFx0dGVbIDMgXSAqPSB4OyB0ZVsgNyBdICo9IHk7IHRlWyAxMSBdICo9IHo7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRnZXRNYXhTY2FsZU9uQXhpczogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHNjYWxlWFNxID0gdGVbIDAgXSAqIHRlWyAwIF0gKyB0ZVsgMSBdICogdGVbIDEgXSArIHRlWyAyIF0gKiB0ZVsgMiBdO1xcclxcblxcdFxcdFxcdHZhciBzY2FsZVlTcSA9IHRlWyA0IF0gKiB0ZVsgNCBdICsgdGVbIDUgXSAqIHRlWyA1IF0gKyB0ZVsgNiBdICogdGVbIDYgXTtcXHJcXG5cXHRcXHRcXHR2YXIgc2NhbGVaU3EgPSB0ZVsgOCBdICogdGVbIDggXSArIHRlWyA5IF0gKiB0ZVsgOSBdICsgdGVbIDEwIF0gKiB0ZVsgMTAgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gTWF0aC5zcXJ0KCBNYXRoLm1heCggc2NhbGVYU3EsIHNjYWxlWVNxLCBzY2FsZVpTcSApICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRtYWtlVHJhbnNsYXRpb246IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnNldChcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQxLCAwLCAwLCB4LFxcclxcblxcdFxcdFxcdFxcdDAsIDEsIDAsIHksXFxyXFxuXFx0XFx0XFx0XFx0MCwgMCwgMSwgeixcXHJcXG5cXHRcXHRcXHRcXHQwLCAwLCAwLCAxXFxyXFxuXFxyXFxuXFx0XFx0XFx0KTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdG1ha2VSb3RhdGlvblg6IGZ1bmN0aW9uICggdGhldGEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuc2V0KFxcclxcblxcclxcblxcdFxcdFxcdFxcdDEsIDAsIDAsIDAsXFxyXFxuXFx0XFx0XFx0XFx0MCwgYywgLSBzLCAwLFxcclxcblxcdFxcdFxcdFxcdDAsIHMsIGMsIDAsXFxyXFxuXFx0XFx0XFx0XFx0MCwgMCwgMCwgMVxcclxcblxcclxcblxcdFxcdFxcdCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRtYWtlUm90YXRpb25ZOiBmdW5jdGlvbiAoIHRoZXRhICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnNldChcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQgYywgMCwgcywgMCxcXHJcXG5cXHRcXHRcXHRcXHQgMCwgMSwgMCwgMCxcXHJcXG5cXHRcXHRcXHRcXHQtIHMsIDAsIGMsIDAsXFxyXFxuXFx0XFx0XFx0XFx0IDAsIDAsIDAsIDFcXHJcXG5cXHJcXG5cXHRcXHRcXHQpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0bWFrZVJvdGF0aW9uWjogZnVuY3Rpb24gKCB0aGV0YSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5zZXQoXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YywgLSBzLCAwLCAwLFxcclxcblxcdFxcdFxcdFxcdHMsIGMsIDAsIDAsXFxyXFxuXFx0XFx0XFx0XFx0MCwgMCwgMSwgMCxcXHJcXG5cXHRcXHRcXHRcXHQwLCAwLCAwLCAxXFxyXFxuXFxyXFxuXFx0XFx0XFx0KTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdG1ha2VSb3RhdGlvbkF4aXM6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gQmFzZWQgb24gaHR0cDovL3d3dy5nYW1lZGV2Lm5ldC9yZWZlcmVuY2UvYXJ0aWNsZXMvYXJ0aWNsZTExOTkuYXNwXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGMgPSBNYXRoLmNvcyggYW5nbGUgKTtcXHJcXG5cXHRcXHRcXHR2YXIgcyA9IE1hdGguc2luKCBhbmdsZSApO1xcclxcblxcdFxcdFxcdHZhciB0ID0gMSAtIGM7XFxyXFxuXFx0XFx0XFx0dmFyIHggPSBheGlzLngsIHkgPSBheGlzLnksIHogPSBheGlzLno7XFxyXFxuXFx0XFx0XFx0dmFyIHR4ID0gdCAqIHgsIHR5ID0gdCAqIHk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5zZXQoXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dHggKiB4ICsgYywgdHggKiB5IC0gcyAqIHosIHR4ICogeiArIHMgKiB5LCAwLFxcclxcblxcdFxcdFxcdFxcdHR4ICogeSArIHMgKiB6LCB0eSAqIHkgKyBjLCB0eSAqIHogLSBzICogeCwgMCxcXHJcXG5cXHRcXHRcXHRcXHR0eCAqIHogLSBzICogeSwgdHkgKiB6ICsgcyAqIHgsIHQgKiB6ICogeiArIGMsIDAsXFxyXFxuXFx0XFx0XFx0XFx0MCwgMCwgMCwgMVxcclxcblxcclxcblxcdFxcdFxcdCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0IHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0bWFrZVNjYWxlOiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5zZXQoXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0eCwgMCwgMCwgMCxcXHJcXG5cXHRcXHRcXHRcXHQwLCB5LCAwLCAwLFxcclxcblxcdFxcdFxcdFxcdDAsIDAsIHosIDAsXFxyXFxuXFx0XFx0XFx0XFx0MCwgMCwgMCwgMVxcclxcblxcclxcblxcdFxcdFxcdCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRtYWtlU2hlYXI6IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnNldChcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQxLCB5LCB6LCAwLFxcclxcblxcdFxcdFxcdFxcdHgsIDEsIHosIDAsXFxyXFxuXFx0XFx0XFx0XFx0eCwgeSwgMSwgMCxcXHJcXG5cXHRcXHRcXHRcXHQwLCAwLCAwLCAxXFxyXFxuXFxyXFxuXFx0XFx0XFx0KTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNvbXBvc2U6IGZ1bmN0aW9uICggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcXHJcXG5cXHRcXHRcXHR0aGlzLnNjYWxlKCBzY2FsZSApO1xcclxcblxcdFxcdFxcdHRoaXMuc2V0UG9zaXRpb24oIHBvc2l0aW9uICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRkZWNvbXBvc2U6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHRcXHRcXHR2YXIgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgc3ggPSB2ZWN0b3Iuc2V0KCB0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdICkubGVuZ3RoKCk7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIHN5ID0gdmVjdG9yLnNldCggdGVbIDQgXSwgdGVbIDUgXSwgdGVbIDYgXSApLmxlbmd0aCgpO1xcclxcblxcdFxcdFxcdFxcdHZhciBzeiA9IHZlY3Rvci5zZXQoIHRlWyA4IF0sIHRlWyA5IF0sIHRlWyAxMCBdICkubGVuZ3RoKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gaWYgZGV0ZXJtaW5lIGlzIG5lZ2F0aXZlLCB3ZSBuZWVkIHRvIGludmVydCBvbmUgc2NhbGVcXHJcXG5cXHRcXHRcXHRcXHR2YXIgZGV0ID0gdGhpcy5kZXRlcm1pbmFudCgpO1xcclxcblxcdFxcdFxcdFxcdGlmICggZGV0IDwgMCApIHN4ID0gLSBzeDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRwb3NpdGlvbi54ID0gdGVbIDEyIF07XFxyXFxuXFx0XFx0XFx0XFx0cG9zaXRpb24ueSA9IHRlWyAxMyBdO1xcclxcblxcdFxcdFxcdFxcdHBvc2l0aW9uLnogPSB0ZVsgMTQgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBzY2FsZSB0aGUgcm90YXRpb24gcGFydFxcclxcblxcdFxcdFxcdFxcdG1hdHJpeC5jb3B5KCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGludlNYID0gMSAvIHN4O1xcclxcblxcdFxcdFxcdFxcdHZhciBpbnZTWSA9IDEgLyBzeTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgaW52U1ogPSAxIC8gc3o7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bWF0cml4LmVsZW1lbnRzWyAwIF0gKj0gaW52U1g7XFxyXFxuXFx0XFx0XFx0XFx0bWF0cml4LmVsZW1lbnRzWyAxIF0gKj0gaW52U1g7XFxyXFxuXFx0XFx0XFx0XFx0bWF0cml4LmVsZW1lbnRzWyAyIF0gKj0gaW52U1g7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bWF0cml4LmVsZW1lbnRzWyA0IF0gKj0gaW52U1k7XFxyXFxuXFx0XFx0XFx0XFx0bWF0cml4LmVsZW1lbnRzWyA1IF0gKj0gaW52U1k7XFxyXFxuXFx0XFx0XFx0XFx0bWF0cml4LmVsZW1lbnRzWyA2IF0gKj0gaW52U1k7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bWF0cml4LmVsZW1lbnRzWyA4IF0gKj0gaW52U1o7XFxyXFxuXFx0XFx0XFx0XFx0bWF0cml4LmVsZW1lbnRzWyA5IF0gKj0gaW52U1o7XFxyXFxuXFx0XFx0XFx0XFx0bWF0cml4LmVsZW1lbnRzWyAxMCBdICo9IGludlNaO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtYXRyaXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzY2FsZS54ID0gc3g7XFxyXFxuXFx0XFx0XFx0XFx0c2NhbGUueSA9IHN5O1xcclxcblxcdFxcdFxcdFxcdHNjYWxlLnogPSBzejtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0oKSxcXHJcXG5cXHJcXG5cXHRcXHRtYWtlUGVyc3BlY3RpdmU6IGZ1bmN0aW9uICggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBmYXIgPT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubWFrZVBlcnNwZWN0aXZlKCkgaGFzIGJlZW4gcmVkZWZpbmVkIGFuZCBoYXMgYSBuZXcgc2lnbmF0dXJlLiBQbGVhc2UgY2hlY2sgdGhlIGRvY3MuJyApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xcclxcblxcdFxcdFxcdHZhciB4ID0gMiAqIG5lYXIgLyAoIHJpZ2h0IC0gbGVmdCApO1xcclxcblxcdFxcdFxcdHZhciB5ID0gMiAqIG5lYXIgLyAoIHRvcCAtIGJvdHRvbSApO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBhID0gKCByaWdodCArIGxlZnQgKSAvICggcmlnaHQgLSBsZWZ0ICk7XFxyXFxuXFx0XFx0XFx0dmFyIGIgPSAoIHRvcCArIGJvdHRvbSApIC8gKCB0b3AgLSBib3R0b20gKTtcXHJcXG5cXHRcXHRcXHR2YXIgYyA9IC0gKCBmYXIgKyBuZWFyICkgLyAoIGZhciAtIG5lYXIgKTtcXHJcXG5cXHRcXHRcXHR2YXIgZCA9IC0gMiAqIGZhciAqIG5lYXIgLyAoIGZhciAtIG5lYXIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0ZVsgMCBdID0geDtcXHR0ZVsgNCBdID0gMDtcXHR0ZVsgOCBdID0gYTtcXHR0ZVsgMTIgXSA9IDA7XFxyXFxuXFx0XFx0XFx0dGVbIDEgXSA9IDA7XFx0dGVbIDUgXSA9IHk7XFx0dGVbIDkgXSA9IGI7XFx0dGVbIDEzIF0gPSAwO1xcclxcblxcdFxcdFxcdHRlWyAyIF0gPSAwO1xcdHRlWyA2IF0gPSAwO1xcdHRlWyAxMCBdID0gYztcXHR0ZVsgMTQgXSA9IGQ7XFxyXFxuXFx0XFx0XFx0dGVbIDMgXSA9IDA7XFx0dGVbIDcgXSA9IDA7XFx0dGVbIDExIF0gPSAtIDE7XFx0dGVbIDE1IF0gPSAwO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0bWFrZU9ydGhvZ3JhcGhpYzogZnVuY3Rpb24gKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xcclxcblxcdFxcdFxcdHZhciB3ID0gMS4wIC8gKCByaWdodCAtIGxlZnQgKTtcXHJcXG5cXHRcXHRcXHR2YXIgaCA9IDEuMCAvICggdG9wIC0gYm90dG9tICk7XFxyXFxuXFx0XFx0XFx0dmFyIHAgPSAxLjAgLyAoIGZhciAtIG5lYXIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgeCA9ICggcmlnaHQgKyBsZWZ0ICkgKiB3O1xcclxcblxcdFxcdFxcdHZhciB5ID0gKCB0b3AgKyBib3R0b20gKSAqIGg7XFxyXFxuXFx0XFx0XFx0dmFyIHogPSAoIGZhciArIG5lYXIgKSAqIHA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGVbIDAgXSA9IDIgKiB3O1xcdHRlWyA0IF0gPSAwO1xcdHRlWyA4IF0gPSAwO1xcdHRlWyAxMiBdID0gLSB4O1xcclxcblxcdFxcdFxcdHRlWyAxIF0gPSAwO1xcdHRlWyA1IF0gPSAyICogaDtcXHR0ZVsgOSBdID0gMDtcXHR0ZVsgMTMgXSA9IC0geTtcXHJcXG5cXHRcXHRcXHR0ZVsgMiBdID0gMDtcXHR0ZVsgNiBdID0gMDtcXHR0ZVsgMTAgXSA9IC0gMiAqIHA7XFx0dGVbIDE0IF0gPSAtIHo7XFxyXFxuXFx0XFx0XFx0dGVbIDMgXSA9IDA7XFx0dGVbIDcgXSA9IDA7XFx0dGVbIDExIF0gPSAwO1xcdHRlWyAxNSBdID0gMTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGVxdWFsczogZnVuY3Rpb24gKCBtYXRyaXggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcXHJcXG5cXHRcXHRcXHR2YXIgbWUgPSBtYXRyaXguZWxlbWVudHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgMTY7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB0ZVsgaSBdICE9PSBtZVsgaSBdICkgcmV0dXJuIGZhbHNlO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IDE2OyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudHNbIGkgXSA9IGFycmF5WyBpICsgb2Zmc2V0IF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XFxyXFxuXFx0XFx0XFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcXHJcXG5cXHJcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0IF0gPSB0ZVsgMCBdO1xcclxcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0ZVsgMSBdO1xcclxcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xcclxcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0ZVsgMyBdO1xcclxcblxcclxcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyA0IF0gPSB0ZVsgNCBdO1xcclxcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyA1IF0gPSB0ZVsgNSBdO1xcclxcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyA2IF0gPSB0ZVsgNiBdO1xcclxcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyA3IF0gPSB0ZVsgNyBdO1xcclxcblxcclxcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyA4IF0gPSB0ZVsgOCBdO1xcclxcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyA5IF0gPSB0ZVsgOSBdO1xcclxcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyAxMCBdID0gdGVbIDEwIF07XFxyXFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDExIF0gPSB0ZVsgMTEgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgMTIgXSA9IHRlWyAxMiBdO1xcclxcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyAxMyBdID0gdGVbIDEzIF07XFxyXFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDE0IF0gPSB0ZVsgMTQgXTtcXHJcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgMTUgXSA9IHRlWyAxNSBdO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBhcnJheTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXFxyXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXHJcXG5cXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcXHJcXG5cXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gUXVhdGVybmlvbiggeCwgeSwgeiwgdyApIHtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLl94ID0geCB8fCAwO1xcclxcblxcdFxcdHRoaXMuX3kgPSB5IHx8IDA7XFxyXFxuXFx0XFx0dGhpcy5feiA9IHogfHwgMDtcXHJcXG5cXHRcXHR0aGlzLl93ID0gKCB3ICE9PSB1bmRlZmluZWQgKSA/IHcgOiAxO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRPYmplY3QuYXNzaWduKCBRdWF0ZXJuaW9uLCB7XFxyXFxuXFxyXFxuXFx0XFx0c2xlcnA6IGZ1bmN0aW9uICggcWEsIHFiLCBxbSwgdCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gcW0uY29weSggcWEgKS5zbGVycCggcWIsIHQgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNsZXJwRmxhdDogZnVuY3Rpb24gKCBkc3QsIGRzdE9mZnNldCwgc3JjMCwgc3JjT2Zmc2V0MCwgc3JjMSwgc3JjT2Zmc2V0MSwgdCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBmdXp6LWZyZWUsIGFycmF5LWJhc2VkIFF1YXRlcm5pb24gU0xFUlAgb3BlcmF0aW9uXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHgwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDAgXSxcXHJcXG5cXHRcXHRcXHRcXHR5MCA9IHNyYzBbIHNyY09mZnNldDAgKyAxIF0sXFxyXFxuXFx0XFx0XFx0XFx0ejAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMiBdLFxcclxcblxcdFxcdFxcdFxcdHcwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDMgXSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR4MSA9IHNyYzFbIHNyY09mZnNldDEgKyAwIF0sXFxyXFxuXFx0XFx0XFx0XFx0eTEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMSBdLFxcclxcblxcdFxcdFxcdFxcdHoxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDIgXSxcXHJcXG5cXHRcXHRcXHRcXHR3MSA9IHNyYzFbIHNyY09mZnNldDEgKyAzIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB3MCAhPT0gdzEgfHwgeDAgIT09IHgxIHx8IHkwICE9PSB5MSB8fCB6MCAhPT0gejEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHMgPSAxIC0gdCxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRjb3MgPSB4MCAqIHgxICsgeTAgKiB5MSArIHowICogejEgKyB3MCAqIHcxLFxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGRpciA9ICggY29zID49IDAgPyAxIDogLSAxICksXFxyXFxuXFx0XFx0XFx0XFx0XFx0c3FyU2luID0gMSAtIGNvcyAqIGNvcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBTa2lwIHRoZSBTbGVycCBmb3IgdGlueSBzdGVwcyB0byBhdm9pZCBudW1lcmljIHByb2JsZW1zOlxcclxcblxcdFxcdFxcdFxcdGlmICggc3FyU2luID4gTnVtYmVyLkVQU0lMT04gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHNpbiA9IE1hdGguc3FydCggc3FyU2luICksXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0bGVuID0gTWF0aC5hdGFuMiggc2luLCBjb3MgKiBkaXIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRzID0gTWF0aC5zaW4oIHMgKiBsZW4gKSAvIHNpbjtcXHJcXG5cXHRcXHRcXHRcXHRcXHR0ID0gTWF0aC5zaW4oIHQgKiBsZW4gKSAvIHNpbjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHREaXIgPSB0ICogZGlyO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHgwID0geDAgKiBzICsgeDEgKiB0RGlyO1xcclxcblxcdFxcdFxcdFxcdHkwID0geTAgKiBzICsgeTEgKiB0RGlyO1xcclxcblxcdFxcdFxcdFxcdHowID0gejAgKiBzICsgejEgKiB0RGlyO1xcclxcblxcdFxcdFxcdFxcdHcwID0gdzAgKiBzICsgdzEgKiB0RGlyO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIE5vcm1hbGl6ZSBpbiBjYXNlIHdlIGp1c3QgZGlkIGEgbGVycDpcXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHMgPT09IDEgLSB0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBmID0gMSAvIE1hdGguc3FydCggeDAgKiB4MCArIHkwICogeTAgKyB6MCAqIHowICsgdzAgKiB3MCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHgwICo9IGY7XFxyXFxuXFx0XFx0XFx0XFx0XFx0eTAgKj0gZjtcXHJcXG5cXHRcXHRcXHRcXHRcXHR6MCAqPSBmO1xcclxcblxcdFxcdFxcdFxcdFxcdHcwICo9IGY7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRkc3RbIGRzdE9mZnNldCBdID0geDA7XFxyXFxuXFx0XFx0XFx0ZHN0WyBkc3RPZmZzZXQgKyAxIF0gPSB5MDtcXHJcXG5cXHRcXHRcXHRkc3RbIGRzdE9mZnNldCArIDIgXSA9IHowO1xcclxcblxcdFxcdFxcdGRzdFsgZHN0T2Zmc2V0ICsgMyBdID0gdzA7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggUXVhdGVybmlvbi5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHR4OiB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuX3g7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5feCA9IHZhbHVlO1xcclxcblxcdFxcdFxcdFxcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHk6IHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5feTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9LFxcclxcblxcclxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLl95ID0gdmFsdWU7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0ejoge1xcclxcblxcclxcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLl96O1xcclxcblxcclxcblxcdFxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuX3ogPSB2YWx1ZTtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHR3OiB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuX3c7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5fdyA9IHZhbHVlO1xcclxcblxcdFxcdFxcdFxcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIFF1YXRlcm5pb24ucHJvdG90eXBlLCB7XFxyXFxuXFxyXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5feCA9IHg7XFxyXFxuXFx0XFx0XFx0dGhpcy5feSA9IHk7XFxyXFxuXFx0XFx0XFx0dGhpcy5feiA9IHo7XFxyXFxuXFx0XFx0XFx0dGhpcy5fdyA9IHc7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fdyApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBxdWF0ZXJuaW9uICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuX3ggPSBxdWF0ZXJuaW9uLng7XFxyXFxuXFx0XFx0XFx0dGhpcy5feSA9IHF1YXRlcm5pb24ueTtcXHJcXG5cXHRcXHRcXHR0aGlzLl96ID0gcXVhdGVybmlvbi56O1xcclxcblxcdFxcdFxcdHRoaXMuX3cgPSBxdWF0ZXJuaW9uLnc7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRGcm9tRXVsZXI6IGZ1bmN0aW9uICggZXVsZXIsIHVwZGF0ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoICEgKCBldWxlciAmJiBldWxlci5pc0V1bGVyICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIG5vdyBleHBlY3RzIGFuIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgeCA9IGV1bGVyLl94LCB5ID0gZXVsZXIuX3ksIHogPSBldWxlci5feiwgb3JkZXIgPSBldWxlci5vcmRlcjtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5jb20vbWF0bGFiY2VudHJhbC9maWxlZXhjaGFuZ2UvXFxyXFxuXFx0XFx0XFx0Ly8gXFx0MjA2OTYtZnVuY3Rpb24tdG8tY29udmVydC1iZXR3ZWVuLWRjbS1ldWxlci1hbmdsZXMtcXVhdGVybmlvbnMtYW5kLWV1bGVyLXZlY3RvcnMvXFxyXFxuXFx0XFx0XFx0Ly9cXHRjb250ZW50L1NwaW5DYWxjLm1cXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgY29zID0gTWF0aC5jb3M7XFxyXFxuXFx0XFx0XFx0dmFyIHNpbiA9IE1hdGguc2luO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBjMSA9IGNvcyggeCAvIDIgKTtcXHJcXG5cXHRcXHRcXHR2YXIgYzIgPSBjb3MoIHkgLyAyICk7XFxyXFxuXFx0XFx0XFx0dmFyIGMzID0gY29zKCB6IC8gMiApO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBzMSA9IHNpbiggeCAvIDIgKTtcXHJcXG5cXHRcXHRcXHR2YXIgczIgPSBzaW4oIHkgLyAyICk7XFxyXFxuXFx0XFx0XFx0dmFyIHMzID0gc2luKCB6IC8gMiApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggb3JkZXIgPT09ICdYWVonICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xcclxcblxcdFxcdFxcdFxcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWFonICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xcclxcblxcdFxcdFxcdFxcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWFknICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xcclxcblxcdFxcdFxcdFxcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWVgnICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xcclxcblxcdFxcdFxcdFxcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWlgnICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xcclxcblxcdFxcdFxcdFxcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdYWlknICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xcclxcblxcdFxcdFxcdFxcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggdXBkYXRlICE9PSBmYWxzZSApIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0RnJvbUF4aXNBbmdsZTogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvYW5nbGVUb1F1YXRlcm5pb24vaW5kZXguaHRtXFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgaGFsZkFuZ2xlID0gYW5nbGUgLyAyLCBzID0gTWF0aC5zaW4oIGhhbGZBbmdsZSApO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuX3ggPSBheGlzLnggKiBzO1xcclxcblxcdFxcdFxcdHRoaXMuX3kgPSBheGlzLnkgKiBzO1xcclxcblxcdFxcdFxcdHRoaXMuX3ogPSBheGlzLnogKiBzO1xcclxcblxcdFxcdFxcdHRoaXMuX3cgPSBNYXRoLmNvcyggaGFsZkFuZ2xlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxcclxcblxcclxcblxcdFxcdFxcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHRlID0gbS5lbGVtZW50cyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdLFxcclxcblxcdFxcdFxcdFxcdG0yMSA9IHRlWyAxIF0sIG0yMiA9IHRlWyA1IF0sIG0yMyA9IHRlWyA5IF0sXFxyXFxuXFx0XFx0XFx0XFx0bTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF0sXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dHJhY2UgPSBtMTEgKyBtMjIgKyBtMzMsXFxyXFxuXFx0XFx0XFx0XFx0cztcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRyYWNlID4gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzID0gMC41IC8gTWF0aC5zcXJ0KCB0cmFjZSArIDEuMCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuX3cgPSAwLjI1IC8gcztcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLl94ID0gKCBtMzIgLSBtMjMgKSAqIHM7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5feSA9ICggbTEzIC0gbTMxICkgKiBzO1xcclxcblxcdFxcdFxcdFxcdHRoaXMuX3ogPSAoIG0yMSAtIG0xMiApICogcztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBtMTEgPiBtMjIgJiYgbTExID4gbTMzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0xMSAtIG0yMiAtIG0zMyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuX3cgPSAoIG0zMiAtIG0yMyApIC8gcztcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLl94ID0gMC4yNSAqIHM7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5feSA9ICggbTEyICsgbTIxICkgLyBzO1xcclxcblxcdFxcdFxcdFxcdHRoaXMuX3ogPSAoIG0xMyArIG0zMSApIC8gcztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBtMjIgPiBtMzMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTIyIC0gbTExIC0gbTMzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5fdyA9ICggbTEzIC0gbTMxICkgLyBzO1xcclxcblxcdFxcdFxcdFxcdHRoaXMuX3ggPSAoIG0xMiArIG0yMSApIC8gcztcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLl95ID0gMC4yNSAqIHM7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5feiA9ICggbTIzICsgbTMyICkgLyBzO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTMzIC0gbTExIC0gbTIyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5fdyA9ICggbTIxIC0gbTEyICkgLyBzO1xcclxcblxcdFxcdFxcdFxcdHRoaXMuX3ggPSAoIG0xMyArIG0zMSApIC8gcztcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLl95ID0gKCBtMjMgKyBtMzIgKSAvIHM7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5feiA9IDAuMjUgKiBzO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldEZyb21Vbml0VmVjdG9yczogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdC8vIGFzc3VtZXMgZGlyZWN0aW9uIHZlY3RvcnMgdkZyb20gYW5kIHZUbyBhcmUgbm9ybWFsaXplZFxcclxcblxcclxcblxcdFxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0XFx0dmFyIHI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIEVQUyA9IDAuMDAwMDAxO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBzZXRGcm9tVW5pdFZlY3RvcnMoIHZGcm9tLCB2VG8gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHIgPSB2RnJvbS5kb3QoIHZUbyApICsgMTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHIgPCBFUFMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0ciA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBNYXRoLmFicyggdkZyb20ueCApID4gTWF0aC5hYnMoIHZGcm9tLnogKSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2MS5zZXQoIC0gdkZyb20ueSwgdkZyb20ueCwgMCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0djEuc2V0KCAwLCAtIHZGcm9tLnosIHZGcm9tLnkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2MS5jcm9zc1ZlY3RvcnMoIHZGcm9tLCB2VG8gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5feCA9IHYxLng7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5feSA9IHYxLnk7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5feiA9IHYxLno7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5fdyA9IHI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR9KCksXFxyXFxuXFxyXFxuXFx0XFx0aW52ZXJzZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmNvbmp1Z2F0ZSgpLm5vcm1hbGl6ZSgpO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y29uanVnYXRlOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5feCAqPSAtIDE7XFxyXFxuXFx0XFx0XFx0dGhpcy5feSAqPSAtIDE7XFxyXFxuXFx0XFx0XFx0dGhpcy5feiAqPSAtIDE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5feCAqIHYuX3ggKyB0aGlzLl95ICogdi5feSArIHRoaXMuX3ogKiB2Ll96ICsgdGhpcy5fdyAqIHYuX3c7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGxlbmd0aDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93ICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbCA9IHRoaXMubGVuZ3RoKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBsID09PSAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuX3ggPSAwO1xcclxcblxcdFxcdFxcdFxcdHRoaXMuX3kgPSAwO1xcclxcblxcdFxcdFxcdFxcdHRoaXMuX3ogPSAwO1xcclxcblxcdFxcdFxcdFxcdHRoaXMuX3cgPSAxO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bCA9IDEgLyBsO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuX3ggPSB0aGlzLl94ICogbDtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLl95ID0gdGhpcy5feSAqIGw7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5feiA9IHRoaXMuX3ogKiBsO1xcclxcblxcdFxcdFxcdFxcdHRoaXMuX3cgPSB0aGlzLl93ICogbDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRtdWx0aXBseTogZnVuY3Rpb24gKCBxLCBwICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggcCAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlF1YXRlcm5pb246IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5UXVhdGVybmlvbnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCBxLCBwICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoIHRoaXMsIHEgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHByZW11bHRpcGx5OiBmdW5jdGlvbiAoIHEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggcSwgdGhpcyApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0bXVsdGlwbHlRdWF0ZXJuaW9uczogZnVuY3Rpb24gKCBhLCBiICkge1xcclxcblxcclxcblxcdFxcdFxcdC8vIGZyb20gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9jb2RlL2luZGV4Lmh0bVxcclxcblxcclxcblxcdFxcdFxcdHZhciBxYXggPSBhLl94LCBxYXkgPSBhLl95LCBxYXogPSBhLl96LCBxYXcgPSBhLl93O1xcclxcblxcdFxcdFxcdHZhciBxYnggPSBiLl94LCBxYnkgPSBiLl95LCBxYnogPSBiLl96LCBxYncgPSBiLl93O1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuX3ggPSBxYXggKiBxYncgKyBxYXcgKiBxYnggKyBxYXkgKiBxYnogLSBxYXogKiBxYnk7XFxyXFxuXFx0XFx0XFx0dGhpcy5feSA9IHFheSAqIHFidyArIHFhdyAqIHFieSArIHFheiAqIHFieCAtIHFheCAqIHFiejtcXHJcXG5cXHRcXHRcXHR0aGlzLl96ID0gcWF6ICogcWJ3ICsgcWF3ICogcWJ6ICsgcWF4ICogcWJ5IC0gcWF5ICogcWJ4O1xcclxcblxcdFxcdFxcdHRoaXMuX3cgPSBxYXcgKiBxYncgLSBxYXggKiBxYnggLSBxYXkgKiBxYnkgLSBxYXogKiBxYno7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzbGVycDogZnVuY3Rpb24gKCBxYiwgdCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHQgPT09IDAgKSByZXR1cm4gdGhpcztcXHJcXG5cXHRcXHRcXHRpZiAoIHQgPT09IDEgKSByZXR1cm4gdGhpcy5jb3B5KCBxYiApO1xcclxcblxcclxcblxcdFxcdFxcdHZhciB4ID0gdGhpcy5feCwgeSA9IHRoaXMuX3ksIHogPSB0aGlzLl96LCB3ID0gdGhpcy5fdztcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL3NsZXJwL1xcclxcblxcclxcblxcdFxcdFxcdHZhciBjb3NIYWxmVGhldGEgPSB3ICogcWIuX3cgKyB4ICogcWIuX3ggKyB5ICogcWIuX3kgKyB6ICogcWIuX3o7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBjb3NIYWxmVGhldGEgPCAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuX3cgPSAtIHFiLl93O1xcclxcblxcdFxcdFxcdFxcdHRoaXMuX3ggPSAtIHFiLl94O1xcclxcblxcdFxcdFxcdFxcdHRoaXMuX3kgPSAtIHFiLl95O1xcclxcblxcdFxcdFxcdFxcdHRoaXMuX3ogPSAtIHFiLl96O1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvc0hhbGZUaGV0YSA9IC0gY29zSGFsZlRoZXRhO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5jb3B5KCBxYiApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGNvc0hhbGZUaGV0YSA+PSAxLjAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5fdyA9IHc7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5feCA9IHg7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5feSA9IHk7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5feiA9IHo7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHZhciBzaW5IYWxmVGhldGEgPSBNYXRoLnNxcnQoIDEuMCAtIGNvc0hhbGZUaGV0YSAqIGNvc0hhbGZUaGV0YSApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggTWF0aC5hYnMoIHNpbkhhbGZUaGV0YSApIDwgMC4wMDEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5fdyA9IDAuNSAqICggdyArIHRoaXMuX3cgKTtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLl94ID0gMC41ICogKCB4ICsgdGhpcy5feCApO1xcclxcblxcdFxcdFxcdFxcdHRoaXMuX3kgPSAwLjUgKiAoIHkgKyB0aGlzLl95ICk7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5feiA9IDAuNSAqICggeiArIHRoaXMuX3ogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGhhbGZUaGV0YSA9IE1hdGguYXRhbjIoIHNpbkhhbGZUaGV0YSwgY29zSGFsZlRoZXRhICk7XFxyXFxuXFx0XFx0XFx0dmFyIHJhdGlvQSA9IE1hdGguc2luKCAoIDEgLSB0ICkgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YSxcXHJcXG5cXHRcXHRcXHRcXHRyYXRpb0IgPSBNYXRoLnNpbiggdCAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuX3cgPSAoIHcgKiByYXRpb0EgKyB0aGlzLl93ICogcmF0aW9CICk7XFxyXFxuXFx0XFx0XFx0dGhpcy5feCA9ICggeCAqIHJhdGlvQSArIHRoaXMuX3ggKiByYXRpb0IgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLl95ID0gKCB5ICogcmF0aW9BICsgdGhpcy5feSAqIHJhdGlvQiApO1xcclxcblxcdFxcdFxcdHRoaXMuX3ogPSAoIHogKiByYXRpb0EgKyB0aGlzLl96ICogcmF0aW9CICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRlcXVhbHM6IGZ1bmN0aW9uICggcXVhdGVybmlvbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gKCBxdWF0ZXJuaW9uLl94ID09PSB0aGlzLl94ICkgJiYgKCBxdWF0ZXJuaW9uLl95ID09PSB0aGlzLl95ICkgJiYgKCBxdWF0ZXJuaW9uLl96ID09PSB0aGlzLl96ICkgJiYgKCBxdWF0ZXJuaW9uLl93ID09PSB0aGlzLl93ICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLl94ID0gYXJyYXlbIG9mZnNldCBdO1xcclxcblxcdFxcdFxcdHRoaXMuX3kgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xcclxcblxcdFxcdFxcdHRoaXMuX3ogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xcclxcblxcdFxcdFxcdHRoaXMuX3cgPSBhcnJheVsgb2Zmc2V0ICsgMyBdO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XFxyXFxuXFx0XFx0XFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcXHJcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy5feTtcXHJcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5fejtcXHJcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fdztcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gYXJyYXk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRvbkNoYW5nZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdG9uQ2hhbmdlQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHt9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICogQGF1dGhvciBraWxlIC8gaHR0cDovL2tpbGUuc3RyYXZhZ2FuemEub3JnL1xcclxcblxcdCAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXFxyXFxuXFx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cXHJcXG5cXHQgKiBAYXV0aG9yIGVncmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xcclxcblxcdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIFZlY3RvcjMoIHgsIHksIHogKSB7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy54ID0geCB8fCAwO1xcclxcblxcdFxcdHRoaXMueSA9IHkgfHwgMDtcXHJcXG5cXHRcXHR0aGlzLnogPSB6IHx8IDA7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIFZlY3RvcjMucHJvdG90eXBlLCB7XFxyXFxuXFxyXFxuXFx0XFx0aXNWZWN0b3IzOiB0cnVlLFxcclxcblxcclxcblxcdFxcdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMueCA9IHg7XFxyXFxuXFx0XFx0XFx0dGhpcy55ID0geTtcXHJcXG5cXHRcXHRcXHR0aGlzLnogPSB6O1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggPSBzY2FsYXI7XFxyXFxuXFx0XFx0XFx0dGhpcy55ID0gc2NhbGFyO1xcclxcblxcdFxcdFxcdHRoaXMueiA9IHNjYWxhcjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldFg6IGZ1bmN0aW9uICggeCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggPSB4O1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0WTogZnVuY3Rpb24gKCB5ICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMueSA9IHk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRaOiBmdW5jdGlvbiAoIHogKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy56ID0gejtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0c3dpdGNoICggaW5kZXggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XFxyXFxuXFx0XFx0XFx0XFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XFxyXFxuXFx0XFx0XFx0XFx0Y2FzZSAyOiB0aGlzLnogPSB2YWx1ZTsgYnJlYWs7XFxyXFxuXFx0XFx0XFx0XFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRnZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0c3dpdGNoICggaW5kZXggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y2FzZSAwOiByZXR1cm4gdGhpcy54O1xcclxcblxcdFxcdFxcdFxcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcXHJcXG5cXHRcXHRcXHRcXHRjYXNlIDI6IHJldHVybiB0aGlzLno7XFxyXFxuXFx0XFx0XFx0XFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnksIHRoaXMueiApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCB2ICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMueCA9IHYueDtcXHJcXG5cXHRcXHRcXHR0aGlzLnkgPSB2Lnk7XFxyXFxuXFx0XFx0XFx0dGhpcy56ID0gdi56O1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0YWRkOiBmdW5jdGlvbiAoIHYsIHcgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHRoaXMueCArPSB2Lng7XFxyXFxuXFx0XFx0XFx0dGhpcy55ICs9IHYueTtcXHJcXG5cXHRcXHRcXHR0aGlzLnogKz0gdi56O1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy54ICs9IHM7XFxyXFxuXFx0XFx0XFx0dGhpcy55ICs9IHM7XFxyXFxuXFx0XFx0XFx0dGhpcy56ICs9IHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRhZGRWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy54ID0gYS54ICsgYi54O1xcclxcblxcdFxcdFxcdHRoaXMueSA9IGEueSArIGIueTtcXHJcXG5cXHRcXHRcXHR0aGlzLnogPSBhLnogKyBiLno7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRhZGRTY2FsZWRWZWN0b3I6IGZ1bmN0aW9uICggdiwgcyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggKz0gdi54ICogcztcXHJcXG5cXHRcXHRcXHR0aGlzLnkgKz0gdi55ICogcztcXHJcXG5cXHRcXHRcXHR0aGlzLnogKz0gdi56ICogcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHN1YjogZnVuY3Rpb24gKCB2LCB3ICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggLT0gdi54O1xcclxcblxcdFxcdFxcdHRoaXMueSAtPSB2Lnk7XFxyXFxuXFx0XFx0XFx0dGhpcy56IC09IHYuejtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHN1YlNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMueCAtPSBzO1xcclxcblxcdFxcdFxcdHRoaXMueSAtPSBzO1xcclxcblxcdFxcdFxcdHRoaXMueiAtPSBzO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMueCA9IGEueCAtIGIueDtcXHJcXG5cXHRcXHRcXHR0aGlzLnkgPSBhLnkgLSBiLnk7XFxyXFxuXFx0XFx0XFx0dGhpcy56ID0gYS56IC0gYi56O1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0bXVsdGlwbHk6IGZ1bmN0aW9uICggdiwgdyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5tdWx0aXBseVZlY3RvcnMoIHYsIHcgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy54ICo9IHYueDtcXHJcXG5cXHRcXHRcXHR0aGlzLnkgKj0gdi55O1xcclxcblxcdFxcdFxcdHRoaXMueiAqPSB2Lno7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy54ICo9IHNjYWxhcjtcXHJcXG5cXHRcXHRcXHR0aGlzLnkgKj0gc2NhbGFyO1xcclxcblxcdFxcdFxcdHRoaXMueiAqPSBzY2FsYXI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRtdWx0aXBseVZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggPSBhLnggKiBiLng7XFxyXFxuXFx0XFx0XFx0dGhpcy55ID0gYS55ICogYi55O1xcclxcblxcdFxcdFxcdHRoaXMueiA9IGEueiAqIGIuejtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGFwcGx5RXVsZXI6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGFwcGx5RXVsZXIoIGV1bGVyICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggISAoIGV1bGVyICYmIGV1bGVyLmlzRXVsZXIgKSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLmFwcGx5RXVsZXIoKSBub3cgZXhwZWN0cyBhbiBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLnNldEZyb21FdWxlciggZXVsZXIgKSApO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdGFwcGx5QXhpc0FuZ2xlOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBhcHBseUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0oKSxcXHJcXG5cXHJcXG5cXHRcXHRhcHBseU1hdHJpeDM6IGZ1bmN0aW9uICggbSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcXHJcXG5cXHRcXHRcXHR2YXIgZSA9IG0uZWxlbWVudHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDMgXSAqIHkgKyBlWyA2IF0gKiB6O1xcclxcblxcdFxcdFxcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgNyBdICogejtcXHJcXG5cXHRcXHRcXHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDggXSAqIHo7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcXHJcXG5cXHRcXHRcXHR2YXIgZSA9IG0uZWxlbWVudHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHcgPSAxIC8gKCBlWyAzIF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDExIF0gKiB6ICsgZVsgMTUgXSApO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMueCA9ICggZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gKiB6ICsgZVsgMTIgXSApICogdztcXHJcXG5cXHRcXHRcXHR0aGlzLnkgPSAoIGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICogeiArIGVbIDEzIF0gKSAqIHc7XFxyXFxuXFx0XFx0XFx0dGhpcy56ID0gKCBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6ICsgZVsgMTQgXSApICogdztcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGFwcGx5UXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xcclxcblxcdFxcdFxcdHZhciBxeCA9IHEueCwgcXkgPSBxLnksIHF6ID0gcS56LCBxdyA9IHEudztcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY3RvclxcclxcblxcclxcblxcdFxcdFxcdHZhciBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeTtcXHJcXG5cXHRcXHRcXHR2YXIgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XFxyXFxuXFx0XFx0XFx0dmFyIGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xcclxcblxcdFxcdFxcdHZhciBpdyA9IC0gcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xcclxcblxcclxcblxcdFxcdFxcdC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggPSBpeCAqIHF3ICsgaXcgKiAtIHF4ICsgaXkgKiAtIHF6IC0gaXogKiAtIHF5O1xcclxcblxcdFxcdFxcdHRoaXMueSA9IGl5ICogcXcgKyBpdyAqIC0gcXkgKyBpeiAqIC0gcXggLSBpeCAqIC0gcXo7XFxyXFxuXFx0XFx0XFx0dGhpcy56ID0gaXogKiBxdyArIGl3ICogLSBxeiArIGl4ICogLSBxeSAtIGl5ICogLSBxeDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHByb2plY3Q6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gcHJvamVjdCggY2FtZXJhICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdG1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgbWF0cml4LmdldEludmVyc2UoIGNhbWVyYS5tYXRyaXhXb3JsZCApICk7XFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0oKSxcXHJcXG5cXHJcXG5cXHRcXHR1bnByb2plY3Q6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gdW5wcm9qZWN0KCBjYW1lcmEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZCwgbWF0cml4LmdldEludmVyc2UoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICkgKTtcXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdHRyYW5zZm9ybURpcmVjdGlvbjogZnVuY3Rpb24gKCBtICkge1xcclxcblxcclxcblxcdFxcdFxcdC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0IGFmZmluZSBtYXRyaXhcXHJcXG5cXHRcXHRcXHQvLyB2ZWN0b3IgaW50ZXJwcmV0ZWQgYXMgYSBkaXJlY3Rpb25cXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcXHJcXG5cXHRcXHRcXHR2YXIgZSA9IG0uZWxlbWVudHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gKiB6O1xcclxcblxcdFxcdFxcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICogejtcXHJcXG5cXHRcXHRcXHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6O1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0ZGl2aWRlOiBmdW5jdGlvbiAoIHYgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy54IC89IHYueDtcXHJcXG5cXHRcXHRcXHR0aGlzLnkgLz0gdi55O1xcclxcblxcdFxcdFxcdHRoaXMueiAvPSB2Lno7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gc2NhbGFyICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRtaW46IGZ1bmN0aW9uICggdiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggPSBNYXRoLm1pbiggdGhpcy54LCB2LnggKTtcXHJcXG5cXHRcXHRcXHR0aGlzLnkgPSBNYXRoLm1pbiggdGhpcy55LCB2LnkgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLnogPSBNYXRoLm1pbiggdGhpcy56LCB2LnogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdG1heDogZnVuY3Rpb24gKCB2ICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMueCA9IE1hdGgubWF4KCB0aGlzLngsIHYueCApO1xcclxcblxcdFxcdFxcdHRoaXMueSA9IE1hdGgubWF4KCB0aGlzLnksIHYueSApO1xcclxcblxcdFxcdFxcdHRoaXMueiA9IE1hdGgubWF4KCB0aGlzLnosIHYueiApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gYXNzdW1lcyBtaW4gPCBtYXgsIGNvbXBvbmVudHdpc2VcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggPSBNYXRoLm1heCggbWluLngsIE1hdGgubWluKCBtYXgueCwgdGhpcy54ICkgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLnkgPSBNYXRoLm1heCggbWluLnksIE1hdGgubWluKCBtYXgueSwgdGhpcy55ICkgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLnogPSBNYXRoLm1heCggbWluLnosIE1hdGgubWluKCBtYXgueiwgdGhpcy56ICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNsYW1wU2NhbGFyOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG1pbiA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0XFx0dmFyIG1heCA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGNsYW1wU2NhbGFyKCBtaW5WYWwsIG1heFZhbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRtaW4uc2V0KCBtaW5WYWwsIG1pblZhbCwgbWluVmFsICk7XFxyXFxuXFx0XFx0XFx0XFx0bWF4LnNldCggbWF4VmFsLCBtYXhWYWwsIG1heFZhbCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmNsYW1wKCBtaW4sIG1heCApO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdGNsYW1wTGVuZ3RoOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggbGVuZ3RoIHx8IDEgKS5tdWx0aXBseVNjYWxhciggTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgbGVuZ3RoICkgKSApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcXHJcXG5cXHRcXHRcXHR0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLnogPSBNYXRoLmZsb29yKCB0aGlzLnogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNlaWw6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xcclxcblxcdFxcdFxcdHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XFxyXFxuXFx0XFx0XFx0dGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHJvdW5kOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XFxyXFxuXFx0XFx0XFx0dGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XFxyXFxuXFx0XFx0XFx0dGhpcy56ID0gTWF0aC5yb3VuZCggdGhpcy56ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRyb3VuZFRvWmVybzogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMueCA9ICggdGhpcy54IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnggKSA6IE1hdGguZmxvb3IoIHRoaXMueCApO1xcclxcblxcdFxcdFxcdHRoaXMueSA9ICggdGhpcy55IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnkgKSA6IE1hdGguZmxvb3IoIHRoaXMueSApO1xcclxcblxcdFxcdFxcdHRoaXMueiA9ICggdGhpcy56IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnogKSA6IE1hdGguZmxvb3IoIHRoaXMueiApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy54ID0gLSB0aGlzLng7XFxyXFxuXFx0XFx0XFx0dGhpcy55ID0gLSB0aGlzLnk7XFxyXFxuXFx0XFx0XFx0dGhpcy56ID0gLSB0aGlzLno7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56O1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Ly8gVE9ETyBsZW5ndGhTcXVhcmVkP1xcclxcblxcclxcblxcdFxcdGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMuejtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGxlbmd0aDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0bWFuaGF0dGFuTGVuZ3RoOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKSArIE1hdGguYWJzKCB0aGlzLnogKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSB8fCAxICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRMZW5ndGg6IGZ1bmN0aW9uICggbGVuZ3RoICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCBsZW5ndGggKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGxlcnA6IGZ1bmN0aW9uICggdiwgYWxwaGEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcXHJcXG5cXHRcXHRcXHR0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xcclxcblxcdFxcdFxcdHRoaXMueiArPSAoIHYueiAtIHRoaXMueiApICogYWxwaGE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRsZXJwVmVjdG9yczogZnVuY3Rpb24gKCB2MSwgdjIsIGFscGhhICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNyb3NzOiBmdW5jdGlvbiAoIHYsIHcgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmNyb3NzKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuY3Jvc3NWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuY3Jvc3NWZWN0b3JzKCB2LCB3ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmNyb3NzVmVjdG9ycyggdGhpcywgdiApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y3Jvc3NWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGF4ID0gYS54LCBheSA9IGEueSwgYXogPSBhLno7XFxyXFxuXFx0XFx0XFx0dmFyIGJ4ID0gYi54LCBieSA9IGIueSwgYnogPSBiLno7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy54ID0gYXkgKiBieiAtIGF6ICogYnk7XFxyXFxuXFx0XFx0XFx0dGhpcy55ID0gYXogKiBieCAtIGF4ICogYno7XFxyXFxuXFx0XFx0XFx0dGhpcy56ID0gYXggKiBieSAtIGF5ICogYng7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRwcm9qZWN0T25WZWN0b3I6IGZ1bmN0aW9uICggdmVjdG9yICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBzY2FsYXIgPSB2ZWN0b3IuZG90KCB0aGlzICkgLyB2ZWN0b3IubGVuZ3RoU3EoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5jb3B5KCB2ZWN0b3IgKS5tdWx0aXBseVNjYWxhciggc2NhbGFyICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRwcm9qZWN0T25QbGFuZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHByb2plY3RPblBsYW5lKCBwbGFuZU5vcm1hbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2MS5jb3B5KCB0aGlzICkucHJvamVjdE9uVmVjdG9yKCBwbGFuZU5vcm1hbCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnN1YiggdjEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0oKSxcXHJcXG5cXHJcXG5cXHRcXHRyZWZsZWN0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gcmVmbGVjdCBpbmNpZGVudCB2ZWN0b3Igb2ZmIHBsYW5lIG9ydGhvZ29uYWwgdG8gbm9ybWFsXFxyXFxuXFx0XFx0XFx0Ly8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gaGF2ZSB1bml0IGxlbmd0aFxcclxcblxcclxcblxcdFxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHJlZmxlY3QoIG5vcm1hbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5zdWIoIHYxLmNvcHkoIG5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCAyICogdGhpcy5kb3QoIG5vcm1hbCApICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0oKSxcXHJcXG5cXHJcXG5cXHRcXHRhbmdsZVRvOiBmdW5jdGlvbiAoIHYgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHRoZXRhID0gdGhpcy5kb3QoIHYgKSAvICggTWF0aC5zcXJ0KCB0aGlzLmxlbmd0aFNxKCkgKiB2Lmxlbmd0aFNxKCkgKSApO1xcclxcblxcclxcblxcdFxcdFxcdC8vIGNsYW1wLCB0byBoYW5kbGUgbnVtZXJpY2FsIHByb2JsZW1zXFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIE1hdGguYWNvcyggX01hdGguY2xhbXAoIHRoZXRhLCAtIDEsIDEgKSApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKCB2ICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0ZGlzdGFuY2VUb1NxdWFyZWQ6IGZ1bmN0aW9uICggdiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgZHggPSB0aGlzLnggLSB2LngsIGR5ID0gdGhpcy55IC0gdi55LCBkeiA9IHRoaXMueiAtIHYuejtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6O1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0bWFuaGF0dGFuRGlzdGFuY2VUbzogZnVuY3Rpb24gKCB2ICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBNYXRoLmFicyggdGhpcy54IC0gdi54ICkgKyBNYXRoLmFicyggdGhpcy55IC0gdi55ICkgKyBNYXRoLmFicyggdGhpcy56IC0gdi56ICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRGcm9tU3BoZXJpY2FsOiBmdW5jdGlvbiAoIHMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHNpblBoaVJhZGl1cyA9IE1hdGguc2luKCBzLnBoaSApICogcy5yYWRpdXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy54ID0gc2luUGhpUmFkaXVzICogTWF0aC5zaW4oIHMudGhldGEgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLnkgPSBNYXRoLmNvcyggcy5waGkgKSAqIHMucmFkaXVzO1xcclxcblxcdFxcdFxcdHRoaXMueiA9IHNpblBoaVJhZGl1cyAqIE1hdGguY29zKCBzLnRoZXRhICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRGcm9tQ3lsaW5kcmljYWw6IGZ1bmN0aW9uICggYyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggPSBjLnJhZGl1cyAqIE1hdGguc2luKCBjLnRoZXRhICk7XFxyXFxuXFx0XFx0XFx0dGhpcy55ID0gYy55O1xcclxcblxcdFxcdFxcdHRoaXMueiA9IGMucmFkaXVzICogTWF0aC5jb3MoIGMudGhldGEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldEZyb21NYXRyaXhQb3NpdGlvbjogZnVuY3Rpb24gKCBtICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBlID0gbS5lbGVtZW50cztcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggPSBlWyAxMiBdO1xcclxcblxcdFxcdFxcdHRoaXMueSA9IGVbIDEzIF07XFxyXFxuXFx0XFx0XFx0dGhpcy56ID0gZVsgMTQgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldEZyb21NYXRyaXhTY2FsZTogZnVuY3Rpb24gKCBtICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBzeCA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMCApLmxlbmd0aCgpO1xcclxcblxcdFxcdFxcdHZhciBzeSA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMSApLmxlbmd0aCgpO1xcclxcblxcdFxcdFxcdHZhciBzeiA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMiApLmxlbmd0aCgpO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMueCA9IHN4O1xcclxcblxcdFxcdFxcdHRoaXMueSA9IHN5O1xcclxcblxcdFxcdFxcdHRoaXMueiA9IHN6O1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0RnJvbU1hdHJpeENvbHVtbjogZnVuY3Rpb24gKCBtLCBpbmRleCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5mcm9tQXJyYXkoIG0uZWxlbWVudHMsIGluZGV4ICogNCApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0ZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSAmJiAoIHYueiA9PT0gdGhpcy56ICkgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcXHJcXG5cXHRcXHRcXHR0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xcclxcblxcdFxcdFxcdHRoaXMueiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcXHJcXG5cXHRcXHRcXHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLng7XFxyXFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcXHJcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy56O1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBhcnJheTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGZyb21CdWZmZXJBdHRyaWJ1dGU6IGZ1bmN0aW9uICggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggb2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogb2Zmc2V0IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSgpLicgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy54ID0gYXR0cmlidXRlLmdldFgoIGluZGV4ICk7XFxyXFxuXFx0XFx0XFx0dGhpcy55ID0gYXR0cmlidXRlLmdldFkoIGluZGV4ICk7XFxyXFxuXFx0XFx0XFx0dGhpcy56ID0gYXR0cmlidXRlLmdldFooIGluZGV4ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcclxcblxcdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxcclxcblxcdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cXHJcXG5cXHQgKiBAYXV0aG9yIHRzY2h3XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gTWF0cml4MygpIHtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmVsZW1lbnRzID0gW1xcclxcblxcclxcblxcdFxcdFxcdDEsIDAsIDAsXFxyXFxuXFx0XFx0XFx0MCwgMSwgMCxcXHJcXG5cXHRcXHRcXHQwLCAwLCAxXFxyXFxuXFxyXFxuXFx0XFx0XTtcXHJcXG5cXHJcXG5cXHRcXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAwICkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXgzOiB0aGUgY29uc3RydWN0b3Igbm8gbG9uZ2VyIHJlYWRzIGFyZ3VtZW50cy4gdXNlIC5zZXQoKSBpbnN0ZWFkLicgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIE1hdHJpeDMucHJvdG90eXBlLCB7XFxyXFxuXFxyXFxuXFx0XFx0aXNNYXRyaXgzOiB0cnVlLFxcclxcblxcclxcblxcdFxcdHNldDogZnVuY3Rpb24gKCBuMTEsIG4xMiwgbjEzLCBuMjEsIG4yMiwgbjIzLCBuMzEsIG4zMiwgbjMzICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGVbIDAgXSA9IG4xMTsgdGVbIDEgXSA9IG4yMTsgdGVbIDIgXSA9IG4zMTtcXHJcXG5cXHRcXHRcXHR0ZVsgMyBdID0gbjEyOyB0ZVsgNCBdID0gbjIyOyB0ZVsgNSBdID0gbjMyO1xcclxcblxcdFxcdFxcdHRlWyA2IF0gPSBuMTM7IHRlWyA3IF0gPSBuMjM7IHRlWyA4IF0gPSBuMzM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRpZGVudGl0eTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuc2V0KFxcclxcblxcclxcblxcdFxcdFxcdFxcdDEsIDAsIDAsXFxyXFxuXFx0XFx0XFx0XFx0MCwgMSwgMCxcXHJcXG5cXHRcXHRcXHRcXHQwLCAwLCAxXFxyXFxuXFxyXFxuXFx0XFx0XFx0KTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuZnJvbUFycmF5KCB0aGlzLmVsZW1lbnRzICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIG0gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcXHJcXG5cXHRcXHRcXHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xcclxcblxcclxcblxcdFxcdFxcdHRlWyAwIF0gPSBtZVsgMCBdOyB0ZVsgMSBdID0gbWVbIDEgXTsgdGVbIDIgXSA9IG1lWyAyIF07XFxyXFxuXFx0XFx0XFx0dGVbIDMgXSA9IG1lWyAzIF07IHRlWyA0IF0gPSBtZVsgNCBdOyB0ZVsgNSBdID0gbWVbIDUgXTtcXHJcXG5cXHRcXHRcXHR0ZVsgNiBdID0gbWVbIDYgXTsgdGVbIDcgXSA9IG1lWyA3IF07IHRlWyA4IF0gPSBtZVsgOCBdO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0RnJvbU1hdHJpeDQ6IGZ1bmN0aW9uICggbSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuc2V0KFxcclxcblxcclxcblxcdFxcdFxcdFxcdG1lWyAwIF0sIG1lWyA0IF0sIG1lWyA4IF0sXFxyXFxuXFx0XFx0XFx0XFx0bWVbIDEgXSwgbWVbIDUgXSwgbWVbIDkgXSxcXHJcXG5cXHRcXHRcXHRcXHRtZVsgMiBdLCBtZVsgNiBdLCBtZVsgMTAgXVxcclxcblxcclxcblxcdFxcdFxcdCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRhcHBseVRvQnVmZmVyQXR0cmlidXRlOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gYXBwbHlUb0J1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGF0dHJpYnV0ZS5jb3VudDsgaSA8IGw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0djEueCA9IGF0dHJpYnV0ZS5nZXRYKCBpICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0djEueSA9IGF0dHJpYnV0ZS5nZXRZKCBpICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0djEueiA9IGF0dHJpYnV0ZS5nZXRaKCBpICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0djEuYXBwbHlNYXRyaXgzKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0YXR0cmlidXRlLnNldFhZWiggaSwgdjEueCwgdjEueSwgdjEueiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gYXR0cmlidXRlO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdG11bHRpcGx5OiBmdW5jdGlvbiAoIG0gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggdGhpcywgbSApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0cHJlbXVsdGlwbHk6IGZ1bmN0aW9uICggbSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCBtLCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRtdWx0aXBseU1hdHJpY2VzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGFlID0gYS5lbGVtZW50cztcXHJcXG5cXHRcXHRcXHR2YXIgYmUgPSBiLmVsZW1lbnRzO1xcclxcblxcdFxcdFxcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGExMSA9IGFlWyAwIF0sIGExMiA9IGFlWyAzIF0sIGExMyA9IGFlWyA2IF07XFxyXFxuXFx0XFx0XFx0dmFyIGEyMSA9IGFlWyAxIF0sIGEyMiA9IGFlWyA0IF0sIGEyMyA9IGFlWyA3IF07XFxyXFxuXFx0XFx0XFx0dmFyIGEzMSA9IGFlWyAyIF0sIGEzMiA9IGFlWyA1IF0sIGEzMyA9IGFlWyA4IF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGIxMSA9IGJlWyAwIF0sIGIxMiA9IGJlWyAzIF0sIGIxMyA9IGJlWyA2IF07XFxyXFxuXFx0XFx0XFx0dmFyIGIyMSA9IGJlWyAxIF0sIGIyMiA9IGJlWyA0IF0sIGIyMyA9IGJlWyA3IF07XFxyXFxuXFx0XFx0XFx0dmFyIGIzMSA9IGJlWyAyIF0sIGIzMiA9IGJlWyA1IF0sIGIzMyA9IGJlWyA4IF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGVbIDAgXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMTtcXHJcXG5cXHRcXHRcXHR0ZVsgMyBdID0gYTExICogYjEyICsgYTEyICogYjIyICsgYTEzICogYjMyO1xcclxcblxcdFxcdFxcdHRlWyA2IF0gPSBhMTEgKiBiMTMgKyBhMTIgKiBiMjMgKyBhMTMgKiBiMzM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGVbIDEgXSA9IGEyMSAqIGIxMSArIGEyMiAqIGIyMSArIGEyMyAqIGIzMTtcXHJcXG5cXHRcXHRcXHR0ZVsgNCBdID0gYTIxICogYjEyICsgYTIyICogYjIyICsgYTIzICogYjMyO1xcclxcblxcdFxcdFxcdHRlWyA3IF0gPSBhMjEgKiBiMTMgKyBhMjIgKiBiMjMgKyBhMjMgKiBiMzM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGVbIDIgXSA9IGEzMSAqIGIxMSArIGEzMiAqIGIyMSArIGEzMyAqIGIzMTtcXHJcXG5cXHRcXHRcXHR0ZVsgNSBdID0gYTMxICogYjEyICsgYTMyICogYjIyICsgYTMzICogYjMyO1xcclxcblxcdFxcdFxcdHRlWyA4IF0gPSBhMzEgKiBiMTMgKyBhMzIgKiBiMjMgKyBhMzMgKiBiMzM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGVbIDAgXSAqPSBzOyB0ZVsgMyBdICo9IHM7IHRlWyA2IF0gKj0gcztcXHJcXG5cXHRcXHRcXHR0ZVsgMSBdICo9IHM7IHRlWyA0IF0gKj0gczsgdGVbIDcgXSAqPSBzO1xcclxcblxcdFxcdFxcdHRlWyAyIF0gKj0gczsgdGVbIDUgXSAqPSBzOyB0ZVsgOCBdICo9IHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRkZXRlcm1pbmFudDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGEgPSB0ZVsgMCBdLCBiID0gdGVbIDEgXSwgYyA9IHRlWyAyIF0sXFxyXFxuXFx0XFx0XFx0XFx0ZCA9IHRlWyAzIF0sIGUgPSB0ZVsgNCBdLCBmID0gdGVbIDUgXSxcXHJcXG5cXHRcXHRcXHRcXHRnID0gdGVbIDYgXSwgaCA9IHRlWyA3IF0sIGkgPSB0ZVsgOCBdO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBhICogZSAqIGkgLSBhICogZiAqIGggLSBiICogZCAqIGkgKyBiICogZiAqIGcgKyBjICogZCAqIGggLSBjICogZSAqIGc7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRnZXRJbnZlcnNlOiBmdW5jdGlvbiAoIG1hdHJpeCwgdGhyb3dPbkRlZ2VuZXJhdGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBtYXRyaXggJiYgbWF0cml4LmlzTWF0cml4NCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCBcXFwiVEhSRUUuTWF0cml4MzogLmdldEludmVyc2UoKSBubyBsb25nZXIgdGFrZXMgYSBNYXRyaXg0IGFyZ3VtZW50LlxcXCIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG1lID0gbWF0cml4LmVsZW1lbnRzLFxcclxcblxcdFxcdFxcdFxcdHRlID0gdGhpcy5lbGVtZW50cyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRuMTEgPSBtZVsgMCBdLCBuMjEgPSBtZVsgMSBdLCBuMzEgPSBtZVsgMiBdLFxcclxcblxcdFxcdFxcdFxcdG4xMiA9IG1lWyAzIF0sIG4yMiA9IG1lWyA0IF0sIG4zMiA9IG1lWyA1IF0sXFxyXFxuXFx0XFx0XFx0XFx0bjEzID0gbWVbIDYgXSwgbjIzID0gbWVbIDcgXSwgbjMzID0gbWVbIDggXSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0MTEgPSBuMzMgKiBuMjIgLSBuMzIgKiBuMjMsXFxyXFxuXFx0XFx0XFx0XFx0dDEyID0gbjMyICogbjEzIC0gbjMzICogbjEyLFxcclxcblxcdFxcdFxcdFxcdHQxMyA9IG4yMyAqIG4xMiAtIG4yMiAqIG4xMyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRkZXQgPSBuMTEgKiB0MTEgKyBuMjEgKiB0MTIgKyBuMzEgKiB0MTM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBkZXQgPT09IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIG1zZyA9IFxcXCJUSFJFRS5NYXRyaXgzOiAuZ2V0SW52ZXJzZSgpIGNhbid0IGludmVydCBtYXRyaXgsIGRldGVybWluYW50IGlzIDBcXFwiO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggdGhyb3dPbkRlZ2VuZXJhdGUgPT09IHRydWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggbXNnICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmlkZW50aXR5KCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHZhciBkZXRJbnYgPSAxIC8gZGV0O1xcclxcblxcclxcblxcdFxcdFxcdHRlWyAwIF0gPSB0MTEgKiBkZXRJbnY7XFxyXFxuXFx0XFx0XFx0dGVbIDEgXSA9ICggbjMxICogbjIzIC0gbjMzICogbjIxICkgKiBkZXRJbnY7XFxyXFxuXFx0XFx0XFx0dGVbIDIgXSA9ICggbjMyICogbjIxIC0gbjMxICogbjIyICkgKiBkZXRJbnY7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGVbIDMgXSA9IHQxMiAqIGRldEludjtcXHJcXG5cXHRcXHRcXHR0ZVsgNCBdID0gKCBuMzMgKiBuMTEgLSBuMzEgKiBuMTMgKSAqIGRldEludjtcXHJcXG5cXHRcXHRcXHR0ZVsgNSBdID0gKCBuMzEgKiBuMTIgLSBuMzIgKiBuMTEgKSAqIGRldEludjtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0ZVsgNiBdID0gdDEzICogZGV0SW52O1xcclxcblxcdFxcdFxcdHRlWyA3IF0gPSAoIG4yMSAqIG4xMyAtIG4yMyAqIG4xMSApICogZGV0SW52O1xcclxcblxcdFxcdFxcdHRlWyA4IF0gPSAoIG4yMiAqIG4xMSAtIG4yMSAqIG4xMiApICogZGV0SW52O1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0dHJhbnNwb3NlOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHRtcCwgbSA9IHRoaXMuZWxlbWVudHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dG1wID0gbVsgMSBdOyBtWyAxIF0gPSBtWyAzIF07IG1bIDMgXSA9IHRtcDtcXHJcXG5cXHRcXHRcXHR0bXAgPSBtWyAyIF07IG1bIDIgXSA9IG1bIDYgXTsgbVsgNiBdID0gdG1wO1xcclxcblxcdFxcdFxcdHRtcCA9IG1bIDUgXTsgbVsgNSBdID0gbVsgNyBdOyBtWyA3IF0gPSB0bXA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRnZXROb3JtYWxNYXRyaXg6IGZ1bmN0aW9uICggbWF0cml4NCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4NCggbWF0cml4NCApLmdldEludmVyc2UoIHRoaXMgKS50cmFuc3Bvc2UoKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHRyYW5zcG9zZUludG9BcnJheTogZnVuY3Rpb24gKCByICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBtID0gdGhpcy5lbGVtZW50cztcXHJcXG5cXHJcXG5cXHRcXHRcXHRyWyAwIF0gPSBtWyAwIF07XFxyXFxuXFx0XFx0XFx0clsgMSBdID0gbVsgMyBdO1xcclxcblxcdFxcdFxcdHJbIDIgXSA9IG1bIDYgXTtcXHJcXG5cXHRcXHRcXHRyWyAzIF0gPSBtWyAxIF07XFxyXFxuXFx0XFx0XFx0clsgNCBdID0gbVsgNCBdO1xcclxcblxcdFxcdFxcdHJbIDUgXSA9IG1bIDcgXTtcXHJcXG5cXHRcXHRcXHRyWyA2IF0gPSBtWyAyIF07XFxyXFxuXFx0XFx0XFx0clsgNyBdID0gbVsgNSBdO1xcclxcblxcdFxcdFxcdHJbIDggXSA9IG1bIDggXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldFV2VHJhbnNmb3JtOiBmdW5jdGlvbiAoIHR4LCB0eSwgc3gsIHN5LCByb3RhdGlvbiwgY3gsIGN5ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBjID0gTWF0aC5jb3MoIHJvdGF0aW9uICk7XFxyXFxuXFx0XFx0XFx0dmFyIHMgPSBNYXRoLnNpbiggcm90YXRpb24gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnNldChcXHJcXG5cXHRcXHRcXHRcXHRzeCAqIGMsIHN4ICogcywgLSBzeCAqICggYyAqIGN4ICsgcyAqIGN5ICkgKyBjeCArIHR4LFxcclxcblxcdFxcdFxcdFxcdC0gc3kgKiBzLCBzeSAqIGMsIC0gc3kgKiAoIC0gcyAqIGN4ICsgYyAqIGN5ICkgKyBjeSArIHR5LFxcclxcblxcdFxcdFxcdFxcdDAsIDAsIDFcXHJcXG5cXHRcXHRcXHQpO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2NhbGU6IGZ1bmN0aW9uICggc3gsIHN5ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGVbIDAgXSAqPSBzeDsgdGVbIDMgXSAqPSBzeDsgdGVbIDYgXSAqPSBzeDtcXHJcXG5cXHRcXHRcXHR0ZVsgMSBdICo9IHN5OyB0ZVsgNCBdICo9IHN5OyB0ZVsgNyBdICo9IHN5O1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0cm90YXRlOiBmdW5jdGlvbiAoIHRoZXRhICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBjID0gTWF0aC5jb3MoIHRoZXRhICk7XFxyXFxuXFx0XFx0XFx0dmFyIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBhMTEgPSB0ZVsgMCBdLCBhMTIgPSB0ZVsgMyBdLCBhMTMgPSB0ZVsgNiBdO1xcclxcblxcdFxcdFxcdHZhciBhMjEgPSB0ZVsgMSBdLCBhMjIgPSB0ZVsgNCBdLCBhMjMgPSB0ZVsgNyBdO1xcclxcblxcclxcblxcdFxcdFxcdHRlWyAwIF0gPSBjICogYTExICsgcyAqIGEyMTtcXHJcXG5cXHRcXHRcXHR0ZVsgMyBdID0gYyAqIGExMiArIHMgKiBhMjI7XFxyXFxuXFx0XFx0XFx0dGVbIDYgXSA9IGMgKiBhMTMgKyBzICogYTIzO1xcclxcblxcclxcblxcdFxcdFxcdHRlWyAxIF0gPSAtIHMgKiBhMTEgKyBjICogYTIxO1xcclxcblxcdFxcdFxcdHRlWyA0IF0gPSAtIHMgKiBhMTIgKyBjICogYTIyO1xcclxcblxcdFxcdFxcdHRlWyA3IF0gPSAtIHMgKiBhMTMgKyBjICogYTIzO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIHR4LCB0eSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xcclxcblxcclxcblxcdFxcdFxcdHRlWyAwIF0gKz0gdHggKiB0ZVsgMiBdOyB0ZVsgMyBdICs9IHR4ICogdGVbIDUgXTsgdGVbIDYgXSArPSB0eCAqIHRlWyA4IF07XFxyXFxuXFx0XFx0XFx0dGVbIDEgXSArPSB0eSAqIHRlWyAyIF07IHRlWyA0IF0gKz0gdHkgKiB0ZVsgNSBdOyB0ZVsgNyBdICs9IHR5ICogdGVbIDggXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGVxdWFsczogZnVuY3Rpb24gKCBtYXRyaXggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcXHJcXG5cXHRcXHRcXHR2YXIgbWUgPSBtYXRyaXguZWxlbWVudHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgOTsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHRlWyBpIF0gIT09IG1lWyBpIF0gKSByZXR1cm4gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0cnVlO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgOTsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnRzWyBpIF0gPSBhcnJheVsgaSArIG9mZnNldCBdO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xcclxcblxcdFxcdFxcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xcclxcblxcclxcblxcdFxcdFxcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCBdID0gdGVbIDAgXTtcXHJcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGVbIDEgXTtcXHJcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGVbIDIgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGVbIDMgXTtcXHJcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgNCBdID0gdGVbIDQgXTtcXHJcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgNSBdID0gdGVbIDUgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgNiBdID0gdGVbIDYgXTtcXHJcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgNyBdID0gdGVbIDcgXTtcXHJcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgOCBdID0gdGVbIDggXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gYXJyYXk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxyXFxuXFx0ICogQGF1dGhvciBzemltZWsgLyBodHRwczovL2dpdGh1Yi5jb20vc3ppbWVrL1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdHZhciB0ZXh0dXJlSWQgPSAwO1xcclxcblxcclxcblxcdGZ1bmN0aW9uIFRleHR1cmUoIGltYWdlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHksIGVuY29kaW5nICkge1xcclxcblxcclxcblxcdFxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogdGV4dHVyZUlkICsrIH0gKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm5hbWUgPSAnJztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmltYWdlID0gaW1hZ2UgIT09IHVuZGVmaW5lZCA/IGltYWdlIDogVGV4dHVyZS5ERUZBVUxUX0lNQUdFO1xcclxcblxcdFxcdHRoaXMubWlwbWFwcyA9IFtdO1xcclxcblxcclxcblxcdFxcdHRoaXMubWFwcGluZyA9IG1hcHBpbmcgIT09IHVuZGVmaW5lZCA/IG1hcHBpbmcgOiBUZXh0dXJlLkRFRkFVTFRfTUFQUElORztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLndyYXBTID0gd3JhcFMgIT09IHVuZGVmaW5lZCA/IHdyYXBTIDogQ2xhbXBUb0VkZ2VXcmFwcGluZztcXHJcXG5cXHRcXHR0aGlzLndyYXBUID0gd3JhcFQgIT09IHVuZGVmaW5lZCA/IHdyYXBUIDogQ2xhbXBUb0VkZ2VXcmFwcGluZztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWFnRmlsdGVyIDogTGluZWFyRmlsdGVyO1xcclxcblxcdFxcdHRoaXMubWluRmlsdGVyID0gbWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtaW5GaWx0ZXIgOiBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5hbmlzb3Ryb3B5ID0gYW5pc290cm9weSAhPT0gdW5kZWZpbmVkID8gYW5pc290cm9weSA6IDE7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5mb3JtYXQgPSBmb3JtYXQgIT09IHVuZGVmaW5lZCA/IGZvcm1hdCA6IFJHQkFGb3JtYXQ7XFxyXFxuXFx0XFx0dGhpcy50eXBlID0gdHlwZSAhPT0gdW5kZWZpbmVkID8gdHlwZSA6IFVuc2lnbmVkQnl0ZVR5cGU7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5vZmZzZXQgPSBuZXcgVmVjdG9yMiggMCwgMCApO1xcclxcblxcdFxcdHRoaXMucmVwZWF0ID0gbmV3IFZlY3RvcjIoIDEsIDEgKTtcXHJcXG5cXHRcXHR0aGlzLmNlbnRlciA9IG5ldyBWZWN0b3IyKCAwLCAwICk7XFxyXFxuXFx0XFx0dGhpcy5yb3RhdGlvbiA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gdHJ1ZTtcXHJcXG5cXHRcXHR0aGlzLm1hdHJpeCA9IG5ldyBNYXRyaXgzKCk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSB0cnVlO1xcclxcblxcdFxcdHRoaXMucHJlbXVsdGlwbHlBbHBoYSA9IGZhbHNlO1xcclxcblxcdFxcdHRoaXMuZmxpcFkgPSB0cnVlO1xcclxcblxcdFxcdHRoaXMudW5wYWNrQWxpZ25tZW50ID0gNDtcXHQvLyB2YWxpZCB2YWx1ZXM6IDEsIDIsIDQsIDggKHNlZSBodHRwOi8vd3d3Lmtocm9ub3Mub3JnL29wZW5nbGVzL3Nkay9kb2NzL21hbi94aHRtbC9nbFBpeGVsU3RvcmVpLnhtbClcXHJcXG5cXHJcXG5cXHRcXHQvLyBWYWx1ZXMgb2YgZW5jb2RpbmcgIT09IFRIUkVFLkxpbmVhckVuY29kaW5nIG9ubHkgc3VwcG9ydGVkIG9uIG1hcCwgZW52TWFwIGFuZCBlbWlzc2l2ZU1hcC5cXHJcXG5cXHRcXHQvL1xcclxcblxcdFxcdC8vIEFsc28gY2hhbmdpbmcgdGhlIGVuY29kaW5nIGFmdGVyIGFscmVhZHkgdXNlZCBieSBhIE1hdGVyaWFsIHdpbGwgbm90IGF1dG9tYXRpY2FsbHkgbWFrZSB0aGUgTWF0ZXJpYWxcXHJcXG5cXHRcXHQvLyB1cGRhdGUuICBZb3UgbmVlZCB0byBleHBsaWNpdGx5IGNhbGwgTWF0ZXJpYWwubmVlZHNVcGRhdGUgdG8gdHJpZ2dlciBpdCB0byByZWNvbXBpbGUuXFxyXFxuXFx0XFx0dGhpcy5lbmNvZGluZyA9IGVuY29kaW5nICE9PSB1bmRlZmluZWQgPyBlbmNvZGluZyA6IExpbmVhckVuY29kaW5nO1xcclxcblxcclxcblxcdFxcdHRoaXMudmVyc2lvbiA9IDA7XFxyXFxuXFx0XFx0dGhpcy5vblVwZGF0ZSA9IG51bGw7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdFRleHR1cmUuREVGQVVMVF9JTUFHRSA9IHVuZGVmaW5lZDtcXHJcXG5cXHRUZXh0dXJlLkRFRkFVTFRfTUFQUElORyA9IFVWTWFwcGluZztcXHJcXG5cXHJcXG5cXHRUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgKSwge1xcclxcblxcclxcblxcdFxcdGNvbnN0cnVjdG9yOiBUZXh0dXJlLFxcclxcblxcclxcblxcdFxcdGlzVGV4dHVyZTogdHJ1ZSxcXHJcXG5cXHJcXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuaW1hZ2UgPSBzb3VyY2UuaW1hZ2U7XFxyXFxuXFx0XFx0XFx0dGhpcy5taXBtYXBzID0gc291cmNlLm1pcG1hcHMuc2xpY2UoIDAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm1hcHBpbmcgPSBzb3VyY2UubWFwcGluZztcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLndyYXBTID0gc291cmNlLndyYXBTO1xcclxcblxcdFxcdFxcdHRoaXMud3JhcFQgPSBzb3VyY2Uud3JhcFQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5tYWdGaWx0ZXIgPSBzb3VyY2UubWFnRmlsdGVyO1xcclxcblxcdFxcdFxcdHRoaXMubWluRmlsdGVyID0gc291cmNlLm1pbkZpbHRlcjtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmFuaXNvdHJvcHkgPSBzb3VyY2UuYW5pc290cm9weTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmZvcm1hdCA9IHNvdXJjZS5mb3JtYXQ7XFxyXFxuXFx0XFx0XFx0dGhpcy50eXBlID0gc291cmNlLnR5cGU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5vZmZzZXQuY29weSggc291cmNlLm9mZnNldCApO1xcclxcblxcdFxcdFxcdHRoaXMucmVwZWF0LmNvcHkoIHNvdXJjZS5yZXBlYXQgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLmNlbnRlci5jb3B5KCBzb3VyY2UuY2VudGVyICk7XFxyXFxuXFx0XFx0XFx0dGhpcy5yb3RhdGlvbiA9IHNvdXJjZS5yb3RhdGlvbjtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBzb3VyY2UubWF0cml4QXV0b1VwZGF0ZTtcXHJcXG5cXHRcXHRcXHR0aGlzLm1hdHJpeC5jb3B5KCBzb3VyY2UubWF0cml4ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBzb3VyY2UuZ2VuZXJhdGVNaXBtYXBzO1xcclxcblxcdFxcdFxcdHRoaXMucHJlbXVsdGlwbHlBbHBoYSA9IHNvdXJjZS5wcmVtdWx0aXBseUFscGhhO1xcclxcblxcdFxcdFxcdHRoaXMuZmxpcFkgPSBzb3VyY2UuZmxpcFk7XFxyXFxuXFx0XFx0XFx0dGhpcy51bnBhY2tBbGlnbm1lbnQgPSBzb3VyY2UudW5wYWNrQWxpZ25tZW50O1xcclxcblxcdFxcdFxcdHRoaXMuZW5jb2RpbmcgPSBzb3VyY2UuZW5jb2Rpbmc7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHR0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgaXNSb290T2JqZWN0ID0gKCBtZXRhID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG1ldGEgPT09ICdzdHJpbmcnICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCAhIGlzUm9vdE9iamVjdCAmJiBtZXRhLnRleHR1cmVzWyB0aGlzLnV1aWQgXSAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiBtZXRhLnRleHR1cmVzWyB0aGlzLnV1aWQgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZnVuY3Rpb24gZ2V0RGF0YVVSTCggaW1hZ2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGNhbnZhcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGltYWdlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y2FudmFzID0gaW1hZ2U7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJywgJ2NhbnZhcycgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRjYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGltYWdlIGluc3RhbmNlb2YgSW1hZ2VEYXRhICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnRleHQucHV0SW1hZ2VEYXRhKCBpbWFnZSwgMCwgMCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29udGV4dC5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGNhbnZhcy53aWR0aCA+IDIwNDggfHwgY2FudmFzLmhlaWdodCA+IDIwNDggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoICdpbWFnZS9qcGVnJywgMC42ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gY2FudmFzLnRvRGF0YVVSTCggJ2ltYWdlL3BuZycgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHZhciBvdXRwdXQgPSB7XFxyXFxuXFx0XFx0XFx0XFx0bWV0YWRhdGE6IHtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2ZXJzaW9uOiA0LjUsXFxyXFxuXFx0XFx0XFx0XFx0XFx0dHlwZTogJ1RleHR1cmUnLFxcclxcblxcdFxcdFxcdFxcdFxcdGdlbmVyYXRvcjogJ1RleHR1cmUudG9KU09OJ1xcclxcblxcdFxcdFxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dXVpZDogdGhpcy51dWlkLFxcclxcblxcdFxcdFxcdFxcdG5hbWU6IHRoaXMubmFtZSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRtYXBwaW5nOiB0aGlzLm1hcHBpbmcsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmVwZWF0OiBbIHRoaXMucmVwZWF0LngsIHRoaXMucmVwZWF0LnkgXSxcXHJcXG5cXHRcXHRcXHRcXHRvZmZzZXQ6IFsgdGhpcy5vZmZzZXQueCwgdGhpcy5vZmZzZXQueSBdLFxcclxcblxcdFxcdFxcdFxcdGNlbnRlcjogWyB0aGlzLmNlbnRlci54LCB0aGlzLmNlbnRlci55IF0sXFxyXFxuXFx0XFx0XFx0XFx0cm90YXRpb246IHRoaXMucm90YXRpb24sXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0d3JhcDogWyB0aGlzLndyYXBTLCB0aGlzLndyYXBUIF0sXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bWluRmlsdGVyOiB0aGlzLm1pbkZpbHRlcixcXHJcXG5cXHRcXHRcXHRcXHRtYWdGaWx0ZXI6IHRoaXMubWFnRmlsdGVyLFxcclxcblxcdFxcdFxcdFxcdGFuaXNvdHJvcHk6IHRoaXMuYW5pc290cm9weSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmbGlwWTogdGhpcy5mbGlwWVxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmltYWdlICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gVE9ETzogTW92ZSB0byBUSFJFRS5JbWFnZVxcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBpbWFnZSA9IHRoaXMuaW1hZ2U7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBpbWFnZS51dWlkID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aW1hZ2UudXVpZCA9IF9NYXRoLmdlbmVyYXRlVVVJRCgpOyAvLyBVR0hcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCAhIGlzUm9vdE9iamVjdCAmJiBtZXRhLmltYWdlc1sgaW1hZ2UudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0bWV0YS5pbWFnZXNbIGltYWdlLnV1aWQgXSA9IHtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR1dWlkOiBpbWFnZS51dWlkLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHVybDogZ2V0RGF0YVVSTCggaW1hZ2UgKVxcclxcblxcdFxcdFxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdG91dHB1dC5pbWFnZSA9IGltYWdlLnV1aWQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggISBpc1Jvb3RPYmplY3QgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bWV0YS50ZXh0dXJlc1sgdGhpcy51dWlkIF0gPSBvdXRwdXQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBvdXRwdXQ7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHR0cmFuc2Zvcm1VdjogZnVuY3Rpb24gKCB1diApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMubWFwcGluZyAhPT0gVVZNYXBwaW5nICkgcmV0dXJuO1xcclxcblxcclxcblxcdFxcdFxcdHV2LmFwcGx5TWF0cml4MyggdGhpcy5tYXRyaXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHV2LnggPCAwIHx8IHV2LnggPiAxICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHN3aXRjaCAoIHRoaXMud3JhcFMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSBSZXBlYXRXcmFwcGluZzpcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR1di54ID0gdXYueCAtIE1hdGguZmxvb3IoIHV2LnggKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRjYXNlIENsYW1wVG9FZGdlV3JhcHBpbmc6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dXYueCA9IHV2LnggPCAwID8gMCA6IDE7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nOlxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggTWF0aC5hYnMoIE1hdGguZmxvb3IoIHV2LnggKSAlIDIgKSA9PT0gMSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR1di54ID0gTWF0aC5jZWlsKCB1di54ICkgLSB1di54O1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dXYueCA9IHV2LnggLSBNYXRoLmZsb29yKCB1di54ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB1di55IDwgMCB8fCB1di55ID4gMSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzd2l0Y2ggKCB0aGlzLndyYXBUICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNhc2UgUmVwZWF0V3JhcHBpbmc6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dXYueSA9IHV2LnkgLSBNYXRoLmZsb29yKCB1di55ICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSBDbGFtcFRvRWRnZVdyYXBwaW5nOlxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHV2LnkgPSB1di55IDwgMCA/IDAgOiAxO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNhc2UgTWlycm9yZWRSZXBlYXRXcmFwcGluZzpcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIE1hdGguYWJzKCBNYXRoLmZsb29yKCB1di55ICkgJSAyICkgPT09IDEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dXYueSA9IE1hdGguY2VpbCggdXYueSApIC0gdXYueTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHV2LnkgPSB1di55IC0gTWF0aC5mbG9vciggdXYueSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5mbGlwWSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR1di55ID0gMSAtIHV2Lnk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBUZXh0dXJlLnByb3RvdHlwZSwgXFxcIm5lZWRzVXBkYXRlXFxcIiwge1xcclxcblxcclxcblxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy52ZXJzaW9uICsrO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBzdXBlcmVnZ2JlcnQgLyBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9cXHJcXG5cXHQgKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xcclxcblxcdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXFxyXFxuXFx0ICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cXHJcXG5cXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBWZWN0b3I0KCB4LCB5LCB6LCB3ICkge1xcclxcblxcclxcblxcdFxcdHRoaXMueCA9IHggfHwgMDtcXHJcXG5cXHRcXHR0aGlzLnkgPSB5IHx8IDA7XFxyXFxuXFx0XFx0dGhpcy56ID0geiB8fCAwO1xcclxcblxcdFxcdHRoaXMudyA9ICggdyAhPT0gdW5kZWZpbmVkICkgPyB3IDogMTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0T2JqZWN0LmFzc2lnbiggVmVjdG9yNC5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHRpc1ZlY3RvcjQ6IHRydWUsXFxyXFxuXFxyXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy54ID0geDtcXHJcXG5cXHRcXHRcXHR0aGlzLnkgPSB5O1xcclxcblxcdFxcdFxcdHRoaXMueiA9IHo7XFxyXFxuXFx0XFx0XFx0dGhpcy53ID0gdztcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldFNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy54ID0gc2NhbGFyO1xcclxcblxcdFxcdFxcdHRoaXMueSA9IHNjYWxhcjtcXHJcXG5cXHRcXHRcXHR0aGlzLnogPSBzY2FsYXI7XFxyXFxuXFx0XFx0XFx0dGhpcy53ID0gc2NhbGFyO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0WDogZnVuY3Rpb24gKCB4ICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMueCA9IHg7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRZOiBmdW5jdGlvbiAoIHkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy55ID0geTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldFo6IGZ1bmN0aW9uICggeiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnogPSB6O1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0VzogZnVuY3Rpb24gKCB3ICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMudyA9IHc7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXgsIHZhbHVlICkge1xcclxcblxcclxcblxcdFxcdFxcdHN3aXRjaCAoIGluZGV4ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xcclxcblxcdFxcdFxcdFxcdGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xcclxcblxcdFxcdFxcdFxcdGNhc2UgMjogdGhpcy56ID0gdmFsdWU7IGJyZWFrO1xcclxcblxcdFxcdFxcdFxcdGNhc2UgMzogdGhpcy53ID0gdmFsdWU7IGJyZWFrO1xcclxcblxcdFxcdFxcdFxcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Z2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4ICkge1xcclxcblxcclxcblxcdFxcdFxcdHN3aXRjaCAoIGluZGV4ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcXHJcXG5cXHRcXHRcXHRcXHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XFxyXFxuXFx0XFx0XFx0XFx0Y2FzZSAyOiByZXR1cm4gdGhpcy56O1xcclxcblxcdFxcdFxcdFxcdGNhc2UgMzogcmV0dXJuIHRoaXMudztcXHJcXG5cXHRcXHRcXHRcXHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggdiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggPSB2Lng7XFxyXFxuXFx0XFx0XFx0dGhpcy55ID0gdi55O1xcclxcblxcdFxcdFxcdHRoaXMueiA9IHYuejtcXHJcXG5cXHRcXHRcXHR0aGlzLncgPSAoIHYudyAhPT0gdW5kZWZpbmVkICkgPyB2LncgOiAxO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0YWRkOiBmdW5jdGlvbiAoIHYsIHcgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yNDogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHRoaXMueCArPSB2Lng7XFxyXFxuXFx0XFx0XFx0dGhpcy55ICs9IHYueTtcXHJcXG5cXHRcXHRcXHR0aGlzLnogKz0gdi56O1xcclxcblxcdFxcdFxcdHRoaXMudyArPSB2Lnc7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRhZGRTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggKz0gcztcXHJcXG5cXHRcXHRcXHR0aGlzLnkgKz0gcztcXHJcXG5cXHRcXHRcXHR0aGlzLnogKz0gcztcXHJcXG5cXHRcXHRcXHR0aGlzLncgKz0gcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGFkZFZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggPSBhLnggKyBiLng7XFxyXFxuXFx0XFx0XFx0dGhpcy55ID0gYS55ICsgYi55O1xcclxcblxcdFxcdFxcdHRoaXMueiA9IGEueiArIGIuejtcXHJcXG5cXHRcXHRcXHR0aGlzLncgPSBhLncgKyBiLnc7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRhZGRTY2FsZWRWZWN0b3I6IGZ1bmN0aW9uICggdiwgcyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggKz0gdi54ICogcztcXHJcXG5cXHRcXHRcXHR0aGlzLnkgKz0gdi55ICogcztcXHJcXG5cXHRcXHRcXHR0aGlzLnogKz0gdi56ICogcztcXHJcXG5cXHRcXHRcXHR0aGlzLncgKz0gdi53ICogcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHN1YjogZnVuY3Rpb24gKCB2LCB3ICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjQ6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggLT0gdi54O1xcclxcblxcdFxcdFxcdHRoaXMueSAtPSB2Lnk7XFxyXFxuXFx0XFx0XFx0dGhpcy56IC09IHYuejtcXHJcXG5cXHRcXHRcXHR0aGlzLncgLT0gdi53O1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c3ViU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy54IC09IHM7XFxyXFxuXFx0XFx0XFx0dGhpcy55IC09IHM7XFxyXFxuXFx0XFx0XFx0dGhpcy56IC09IHM7XFxyXFxuXFx0XFx0XFx0dGhpcy53IC09IHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzdWJWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy54ID0gYS54IC0gYi54O1xcclxcblxcdFxcdFxcdHRoaXMueSA9IGEueSAtIGIueTtcXHJcXG5cXHRcXHRcXHR0aGlzLnogPSBhLnogLSBiLno7XFxyXFxuXFx0XFx0XFx0dGhpcy53ID0gYS53IC0gYi53O1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMueCAqPSBzY2FsYXI7XFxyXFxuXFx0XFx0XFx0dGhpcy55ICo9IHNjYWxhcjtcXHJcXG5cXHRcXHRcXHR0aGlzLnogKj0gc2NhbGFyO1xcclxcblxcdFxcdFxcdHRoaXMudyAqPSBzY2FsYXI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMueiwgdyA9IHRoaXMudztcXHJcXG5cXHRcXHRcXHR2YXIgZSA9IG0uZWxlbWVudHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gKiB6ICsgZVsgMTIgXSAqIHc7XFxyXFxuXFx0XFx0XFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gKiB6ICsgZVsgMTMgXSAqIHc7XFxyXFxuXFx0XFx0XFx0dGhpcy56ID0gZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF0gKiB3O1xcclxcblxcdFxcdFxcdHRoaXMudyA9IGVbIDMgXSAqIHggKyBlWyA3IF0gKiB5ICsgZVsgMTEgXSAqIHogKyBlWyAxNSBdICogdztcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGRpdmlkZVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBzY2FsYXIgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldEF4aXNBbmdsZUZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL3F1YXRlcm5pb25Ub0FuZ2xlL2luZGV4Lmh0bVxcclxcblxcclxcblxcdFxcdFxcdC8vIHEgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy53ID0gMiAqIE1hdGguYWNvcyggcS53ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHMgPSBNYXRoLnNxcnQoIDEgLSBxLncgKiBxLncgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHMgPCAwLjAwMDEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy54ID0gMTtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnkgPSAwO1xcclxcblxcdFxcdFxcdFxcdHRoaXMueiA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnggPSBxLnggLyBzO1xcclxcblxcdFxcdFxcdFxcdHRoaXMueSA9IHEueSAvIHM7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy56ID0gcS56IC8gcztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRBeGlzQW5nbGVGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9BbmdsZS9pbmRleC5odG1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxcclxcblxcclxcblxcdFxcdFxcdHZhciBhbmdsZSwgeCwgeSwgeixcXHRcXHQvLyB2YXJpYWJsZXMgZm9yIHJlc3VsdFxcclxcblxcdFxcdFxcdFxcdGVwc2lsb24gPSAwLjAxLFxcdFxcdC8vIG1hcmdpbiB0byBhbGxvdyBmb3Igcm91bmRpbmcgZXJyb3JzXFxyXFxuXFx0XFx0XFx0XFx0ZXBzaWxvbjIgPSAwLjEsXFx0XFx0Ly8gbWFyZ2luIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gMCBhbmQgMTgwIGRlZ3JlZXNcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0ZSA9IG0uZWxlbWVudHMsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXSxcXHJcXG5cXHRcXHRcXHRcXHRtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdLFxcclxcblxcdFxcdFxcdFxcdG0zMSA9IHRlWyAyIF0sIG0zMiA9IHRlWyA2IF0sIG0zMyA9IHRlWyAxMCBdO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggKCBNYXRoLmFicyggbTEyIC0gbTIxICkgPCBlcHNpbG9uICkgJiZcXHJcXG5cXHRcXHRcXHQgICAgICggTWF0aC5hYnMoIG0xMyAtIG0zMSApIDwgZXBzaWxvbiApICYmXFxyXFxuXFx0XFx0XFx0ICAgICAoIE1hdGguYWJzKCBtMjMgLSBtMzIgKSA8IGVwc2lsb24gKSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBzaW5ndWxhcml0eSBmb3VuZFxcclxcblxcdFxcdFxcdFxcdC8vIGZpcnN0IGNoZWNrIGZvciBpZGVudGl0eSBtYXRyaXggd2hpY2ggbXVzdCBoYXZlICsxIGZvciBhbGwgdGVybXNcXHJcXG5cXHRcXHRcXHRcXHQvLyBpbiBsZWFkaW5nIGRpYWdvbmFsIGFuZCB6ZXJvIGluIG90aGVyIHRlcm1zXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCAoIE1hdGguYWJzKCBtMTIgKyBtMjEgKSA8IGVwc2lsb24yICkgJiZcXHJcXG5cXHRcXHRcXHRcXHQgICAgICggTWF0aC5hYnMoIG0xMyArIG0zMSApIDwgZXBzaWxvbjIgKSAmJlxcclxcblxcdFxcdFxcdFxcdCAgICAgKCBNYXRoLmFicyggbTIzICsgbTMyICkgPCBlcHNpbG9uMiApICYmXFxyXFxuXFx0XFx0XFx0XFx0ICAgICAoIE1hdGguYWJzKCBtMTEgKyBtMjIgKyBtMzMgLSAzICkgPCBlcHNpbG9uMiApICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIHRoaXMgc2luZ3VsYXJpdHkgaXMgaWRlbnRpdHkgbWF0cml4IHNvIGFuZ2xlID0gMFxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2V0KCAxLCAwLCAwLCAwICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7IC8vIHplcm8gYW5nbGUsIGFyYml0cmFyeSBheGlzXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIG90aGVyd2lzZSB0aGlzIHNpbmd1bGFyaXR5IGlzIGFuZ2xlID0gMTgwXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YW5nbGUgPSBNYXRoLlBJO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciB4eCA9ICggbTExICsgMSApIC8gMjtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgeXkgPSAoIG0yMiArIDEgKSAvIDI7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIHp6ID0gKCBtMzMgKyAxICkgLyAyO1xcclxcblxcdFxcdFxcdFxcdHZhciB4eSA9ICggbTEyICsgbTIxICkgLyA0O1xcclxcblxcdFxcdFxcdFxcdHZhciB4eiA9ICggbTEzICsgbTMxICkgLyA0O1xcclxcblxcdFxcdFxcdFxcdHZhciB5eiA9ICggbTIzICsgbTMyICkgLyA0O1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggKCB4eCA+IHl5ICkgJiYgKCB4eCA+IHp6ICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gbTExIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHh4IDwgZXBzaWxvbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR4ID0gMDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR5ID0gMC43MDcxMDY3ODE7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0eiA9IDAuNzA3MTA2NzgxO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0eCA9IE1hdGguc3FydCggeHggKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR5ID0geHkgLyB4O1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHogPSB4eiAvIHg7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIHl5ID4genogKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gbTIyIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHl5IDwgZXBzaWxvbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR4ID0gMC43MDcxMDY3ODE7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0eSA9IDA7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0eiA9IDAuNzA3MTA2NzgxO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0eSA9IE1hdGguc3FydCggeXkgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR4ID0geHkgLyB5O1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHogPSB5eiAvIHk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gbTMzIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm0gc28gYmFzZSByZXN1bHQgb24gdGhpc1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggenogPCBlcHNpbG9uICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHggPSAwLjcwNzEwNjc4MTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR5ID0gMC43MDcxMDY3ODE7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0eiA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR6ID0gTWF0aC5zcXJ0KCB6eiApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHggPSB4eiAvIHo7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0eSA9IHl6IC8gejtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuc2V0KCB4LCB5LCB6LCBhbmdsZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzOyAvLyByZXR1cm4gMTgwIGRlZyByb3RhdGlvblxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBhcyB3ZSBoYXZlIHJlYWNoZWQgaGVyZSB0aGVyZSBhcmUgbm8gc2luZ3VsYXJpdGllcyBzbyB3ZSBjYW4gaGFuZGxlIG5vcm1hbGx5XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHMgPSBNYXRoLnNxcnQoICggbTMyIC0gbTIzICkgKiAoIG0zMiAtIG0yMyApICtcXHJcXG5cXHRcXHRcXHQgICAgICAgICAgICAgICAgICAgKCBtMTMgLSBtMzEgKSAqICggbTEzIC0gbTMxICkgK1xcclxcblxcdFxcdFxcdCAgICAgICAgICAgICAgICAgICAoIG0yMSAtIG0xMiApICogKCBtMjEgLSBtMTIgKSApOyAvLyB1c2VkIHRvIG5vcm1hbGl6ZVxcclxcblxcclxcblxcdFxcdFxcdGlmICggTWF0aC5hYnMoIHMgKSA8IDAuMDAxICkgcyA9IDE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gcHJldmVudCBkaXZpZGUgYnkgemVybywgc2hvdWxkIG5vdCBoYXBwZW4gaWYgbWF0cml4IGlzIG9ydGhvZ29uYWwgYW5kIHNob3VsZCBiZVxcclxcblxcdFxcdFxcdC8vIGNhdWdodCBieSBzaW5ndWxhcml0eSB0ZXN0IGFib3ZlLCBidXQgSSd2ZSBsZWZ0IGl0IGluIGp1c3QgaW4gY2FzZVxcclxcblxcclxcblxcdFxcdFxcdHRoaXMueCA9ICggbTMyIC0gbTIzICkgLyBzO1xcclxcblxcdFxcdFxcdHRoaXMueSA9ICggbTEzIC0gbTMxICkgLyBzO1xcclxcblxcdFxcdFxcdHRoaXMueiA9ICggbTIxIC0gbTEyICkgLyBzO1xcclxcblxcdFxcdFxcdHRoaXMudyA9IE1hdGguYWNvcyggKCBtMTEgKyBtMjIgKyBtMzMgLSAxICkgLyAyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRtaW46IGZ1bmN0aW9uICggdiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggPSBNYXRoLm1pbiggdGhpcy54LCB2LnggKTtcXHJcXG5cXHRcXHRcXHR0aGlzLnkgPSBNYXRoLm1pbiggdGhpcy55LCB2LnkgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLnogPSBNYXRoLm1pbiggdGhpcy56LCB2LnogKTtcXHJcXG5cXHRcXHRcXHR0aGlzLncgPSBNYXRoLm1pbiggdGhpcy53LCB2LncgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdG1heDogZnVuY3Rpb24gKCB2ICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMueCA9IE1hdGgubWF4KCB0aGlzLngsIHYueCApO1xcclxcblxcdFxcdFxcdHRoaXMueSA9IE1hdGgubWF4KCB0aGlzLnksIHYueSApO1xcclxcblxcdFxcdFxcdHRoaXMueiA9IE1hdGgubWF4KCB0aGlzLnosIHYueiApO1xcclxcblxcdFxcdFxcdHRoaXMudyA9IE1hdGgubWF4KCB0aGlzLncsIHYudyApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gYXNzdW1lcyBtaW4gPCBtYXgsIGNvbXBvbmVudHdpc2VcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggPSBNYXRoLm1heCggbWluLngsIE1hdGgubWluKCBtYXgueCwgdGhpcy54ICkgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLnkgPSBNYXRoLm1heCggbWluLnksIE1hdGgubWluKCBtYXgueSwgdGhpcy55ICkgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLnogPSBNYXRoLm1heCggbWluLnosIE1hdGgubWluKCBtYXgueiwgdGhpcy56ICkgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLncgPSBNYXRoLm1heCggbWluLncsIE1hdGgubWluKCBtYXgudywgdGhpcy53ICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNsYW1wU2NhbGFyOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG1pbiwgbWF4O1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBjbGFtcFNjYWxhciggbWluVmFsLCBtYXhWYWwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBtaW4gPT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRtaW4gPSBuZXcgVmVjdG9yNCgpO1xcclxcblxcdFxcdFxcdFxcdFxcdG1heCA9IG5ldyBWZWN0b3I0KCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdG1pbi5zZXQoIG1pblZhbCwgbWluVmFsLCBtaW5WYWwsIG1pblZhbCApO1xcclxcblxcdFxcdFxcdFxcdG1heC5zZXQoIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwsIG1heFZhbCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmNsYW1wKCBtaW4sIG1heCApO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdGNsYW1wTGVuZ3RoOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggbGVuZ3RoIHx8IDEgKS5tdWx0aXBseVNjYWxhciggTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgbGVuZ3RoICkgKSApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcXHJcXG5cXHRcXHRcXHR0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLnogPSBNYXRoLmZsb29yKCB0aGlzLnogKTtcXHJcXG5cXHRcXHRcXHR0aGlzLncgPSBNYXRoLmZsb29yKCB0aGlzLncgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNlaWw6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xcclxcblxcdFxcdFxcdHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XFxyXFxuXFx0XFx0XFx0dGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcXHJcXG5cXHRcXHRcXHR0aGlzLncgPSBNYXRoLmNlaWwoIHRoaXMudyApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggPSBNYXRoLnJvdW5kKCB0aGlzLnggKTtcXHJcXG5cXHRcXHRcXHR0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLnogPSBNYXRoLnJvdW5kKCB0aGlzLnogKTtcXHJcXG5cXHRcXHRcXHR0aGlzLncgPSBNYXRoLnJvdW5kKCB0aGlzLncgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XFxyXFxuXFx0XFx0XFx0dGhpcy55ID0gKCB0aGlzLnkgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueSApIDogTWF0aC5mbG9vciggdGhpcy55ICk7XFxyXFxuXFx0XFx0XFx0dGhpcy56ID0gKCB0aGlzLnogPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueiApIDogTWF0aC5mbG9vciggdGhpcy56ICk7XFxyXFxuXFx0XFx0XFx0dGhpcy53ID0gKCB0aGlzLncgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMudyApIDogTWF0aC5mbG9vciggdGhpcy53ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnggPSAtIHRoaXMueDtcXHJcXG5cXHRcXHRcXHR0aGlzLnkgPSAtIHRoaXMueTtcXHJcXG5cXHRcXHRcXHR0aGlzLnogPSAtIHRoaXMuejtcXHJcXG5cXHRcXHRcXHR0aGlzLncgPSAtIHRoaXMudztcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGRvdDogZnVuY3Rpb24gKCB2ICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2LnogKyB0aGlzLncgKiB2Lnc7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLnc7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLncgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdG1hbmhhdHRhbkxlbmd0aDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICkgKyBNYXRoLmFicyggdGhpcy56ICkgKyBNYXRoLmFicyggdGhpcy53ICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgfHwgMSApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0TGVuZ3RoOiBmdW5jdGlvbiAoIGxlbmd0aCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggbGVuZ3RoICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRsZXJwOiBmdW5jdGlvbiAoIHYsIGFscGhhICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XFxyXFxuXFx0XFx0XFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcXHJcXG5cXHRcXHRcXHR0aGlzLnogKz0gKCB2LnogLSB0aGlzLnogKSAqIGFscGhhO1xcclxcblxcdFxcdFxcdHRoaXMudyArPSAoIHYudyAtIHRoaXMudyApICogYWxwaGE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRsZXJwVmVjdG9yczogZnVuY3Rpb24gKCB2MSwgdjIsIGFscGhhICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGVxdWFsczogZnVuY3Rpb24gKCB2ICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgJiYgKCB2LnogPT09IHRoaXMueiApICYmICggdi53ID09PSB0aGlzLncgKSApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xcclxcblxcdFxcdFxcdHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XFxyXFxuXFx0XFx0XFx0dGhpcy56ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcXHJcXG5cXHRcXHRcXHR0aGlzLncgPSBhcnJheVsgb2Zmc2V0ICsgMyBdO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XFxyXFxuXFx0XFx0XFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xcclxcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XFxyXFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuejtcXHJcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy53O1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBhcnJheTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGZyb21CdWZmZXJBdHRyaWJ1dGU6IGZ1bmN0aW9uICggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggb2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yNDogb2Zmc2V0IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSgpLicgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy54ID0gYXR0cmlidXRlLmdldFgoIGluZGV4ICk7XFxyXFxuXFx0XFx0XFx0dGhpcy55ID0gYXR0cmlidXRlLmdldFkoIGluZGV4ICk7XFxyXFxuXFx0XFx0XFx0dGhpcy56ID0gYXR0cmlidXRlLmdldFooIGluZGV4ICk7XFxyXFxuXFx0XFx0XFx0dGhpcy53ID0gYXR0cmlidXRlLmdldFcoIGluZGV4ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIHN6aW1layAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zemltZWsvXFxyXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXHJcXG5cXHQgKiBAYXV0aG9yIE1hcml1cyBLaW50ZWwgLyBodHRwczovL2dpdGh1Yi5jb20va2ludGVsXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0LypcXHJcXG5cXHQgSW4gb3B0aW9ucywgd2UgY2FuIHNwZWNpZnk6XFxyXFxuXFx0ICogVGV4dHVyZSBwYXJhbWV0ZXJzIGZvciBhbiBhdXRvLWdlbmVyYXRlZCB0YXJnZXQgdGV4dHVyZVxcclxcblxcdCAqIGRlcHRoQnVmZmVyL3N0ZW5jaWxCdWZmZXI6IEJvb2xlYW5zIHRvIGluZGljYXRlIGlmIHdlIHNob3VsZCBnZW5lcmF0ZSB0aGVzZSBidWZmZXJzXFxyXFxuXFx0Ki9cXHJcXG5cXHRmdW5jdGlvbiBXZWJHTFJlbmRlclRhcmdldCggd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApIHtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLndpZHRoID0gd2lkdGg7XFxyXFxuXFx0XFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5zY2lzc29yID0gbmV3IFZlY3RvcjQoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcXHJcXG5cXHRcXHR0aGlzLnNjaXNzb3JUZXN0ID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy52aWV3cG9ydCA9IG5ldyBWZWN0b3I0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XFxyXFxuXFxyXFxuXFx0XFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCBvcHRpb25zLm1pbkZpbHRlciA9PT0gdW5kZWZpbmVkICkgb3B0aW9ucy5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50ZXh0dXJlID0gbmV3IFRleHR1cmUoIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvcHRpb25zLndyYXBTLCBvcHRpb25zLndyYXBULCBvcHRpb25zLm1hZ0ZpbHRlciwgb3B0aW9ucy5taW5GaWx0ZXIsIG9wdGlvbnMuZm9ybWF0LCBvcHRpb25zLnR5cGUsIG9wdGlvbnMuYW5pc290cm9weSwgb3B0aW9ucy5lbmNvZGluZyApO1xcclxcblxcclxcblxcdFxcdHRoaXMuZGVwdGhCdWZmZXIgPSBvcHRpb25zLmRlcHRoQnVmZmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlcHRoQnVmZmVyIDogdHJ1ZTtcXHJcXG5cXHRcXHR0aGlzLnN0ZW5jaWxCdWZmZXIgPSBvcHRpb25zLnN0ZW5jaWxCdWZmZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RlbmNpbEJ1ZmZlciA6IHRydWU7XFxyXFxuXFx0XFx0dGhpcy5kZXB0aFRleHR1cmUgPSBvcHRpb25zLmRlcHRoVGV4dHVyZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZXB0aFRleHR1cmUgOiBudWxsO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRXZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlICksIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zdHJ1Y3RvcjogV2ViR0xSZW5kZXJUYXJnZXQsXFxyXFxuXFxyXFxuXFx0XFx0aXNXZWJHTFJlbmRlclRhcmdldDogdHJ1ZSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRTaXplOiBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLndpZHRoICE9PSB3aWR0aCB8fCB0aGlzLmhlaWdodCAhPT0gaGVpZ2h0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMud2lkdGggPSB3aWR0aDtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmhlaWdodCA9IGhlaWdodDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmRpc3Bvc2UoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy52aWV3cG9ydC5zZXQoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLnNjaXNzb3Iuc2V0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMud2lkdGggPSBzb3VyY2Uud2lkdGg7XFxyXFxuXFx0XFx0XFx0dGhpcy5oZWlnaHQgPSBzb3VyY2UuaGVpZ2h0O1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMudmlld3BvcnQuY29weSggc291cmNlLnZpZXdwb3J0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy50ZXh0dXJlID0gc291cmNlLnRleHR1cmUuY2xvbmUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmRlcHRoQnVmZmVyID0gc291cmNlLmRlcHRoQnVmZmVyO1xcclxcblxcdFxcdFxcdHRoaXMuc3RlbmNpbEJ1ZmZlciA9IHNvdXJjZS5zdGVuY2lsQnVmZmVyO1xcclxcblxcdFxcdFxcdHRoaXMuZGVwdGhUZXh0dXJlID0gc291cmNlLmRlcHRoVGV4dHVyZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb21cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBXZWJHTFJlbmRlclRhcmdldEN1YmUoIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0V2ViR0xSZW5kZXJUYXJnZXQuY2FsbCggdGhpcywgd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApO1xcclxcblxcclxcblxcdFxcdHRoaXMuYWN0aXZlQ3ViZUZhY2UgPSAwOyAvLyBQWCAwLCBOWCAxLCBQWSAyLCBOWSAzLCBQWiA0LCBOWiA1XFxyXFxuXFx0XFx0dGhpcy5hY3RpdmVNaXBNYXBMZXZlbCA9IDA7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBXZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUgKTtcXHJcXG5cXHRXZWJHTFJlbmRlclRhcmdldEN1YmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gV2ViR0xSZW5kZXJUYXJnZXRDdWJlO1xcclxcblxcclxcblxcdFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZS5wcm90b3R5cGUuaXNXZWJHTFJlbmRlclRhcmdldEN1YmUgPSB0cnVlO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gRGF0YVRleHR1cmUoIGRhdGEsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgYW5pc290cm9weSwgZW5jb2RpbmcgKSB7XFxyXFxuXFxyXFxuXFx0XFx0VGV4dHVyZS5jYWxsKCB0aGlzLCBudWxsLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHksIGVuY29kaW5nICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5pbWFnZSA9IHsgZGF0YTogZGF0YSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xcclxcblxcclxcblxcdFxcdHRoaXMubWFnRmlsdGVyID0gbWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtYWdGaWx0ZXIgOiBOZWFyZXN0RmlsdGVyO1xcclxcblxcdFxcdHRoaXMubWluRmlsdGVyID0gbWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtaW5GaWx0ZXIgOiBOZWFyZXN0RmlsdGVyO1xcclxcblxcclxcblxcdFxcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XFxyXFxuXFx0XFx0dGhpcy5mbGlwWSA9IGZhbHNlO1xcclxcblxcdFxcdHRoaXMudW5wYWNrQWxpZ25tZW50ID0gMTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0RGF0YVRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVGV4dHVyZS5wcm90b3R5cGUgKTtcXHJcXG5cXHREYXRhVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEYXRhVGV4dHVyZTtcXHJcXG5cXHJcXG5cXHREYXRhVGV4dHVyZS5wcm90b3R5cGUuaXNEYXRhVGV4dHVyZSA9IHRydWU7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBDdWJlVGV4dHVyZSggaW1hZ2VzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHksIGVuY29kaW5nICkge1xcclxcblxcclxcblxcdFxcdGltYWdlcyA9IGltYWdlcyAhPT0gdW5kZWZpbmVkID8gaW1hZ2VzIDogW107XFxyXFxuXFx0XFx0bWFwcGluZyA9IG1hcHBpbmcgIT09IHVuZGVmaW5lZCA/IG1hcHBpbmcgOiBDdWJlUmVmbGVjdGlvbk1hcHBpbmc7XFxyXFxuXFxyXFxuXFx0XFx0VGV4dHVyZS5jYWxsKCB0aGlzLCBpbWFnZXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSwgZW5jb2RpbmcgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmZsaXBZID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdEN1YmVUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRleHR1cmUucHJvdG90eXBlICk7XFxyXFxuXFx0Q3ViZVRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ3ViZVRleHR1cmU7XFxyXFxuXFxyXFxuXFx0Q3ViZVRleHR1cmUucHJvdG90eXBlLmlzQ3ViZVRleHR1cmUgPSB0cnVlO1xcclxcblxcclxcblxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggQ3ViZVRleHR1cmUucHJvdG90eXBlLCAnaW1hZ2VzJywge1xcclxcblxcclxcblxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmltYWdlO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuaW1hZ2UgPSB2YWx1ZTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgdHNjaHdcXHJcXG5cXHQgKlxcclxcblxcdCAqIFVuaWZvcm1zIG9mIGEgcHJvZ3JhbS5cXHJcXG5cXHQgKiBUaG9zZSBmb3JtIGEgdHJlZSBzdHJ1Y3R1cmUgd2l0aCBhIHNwZWNpYWwgdG9wLWxldmVsIGNvbnRhaW5lciBmb3IgdGhlIHJvb3QsXFxyXFxuXFx0ICogd2hpY2ggeW91IGdldCBieSBjYWxsaW5nICduZXcgV2ViR0xVbmlmb3JtcyggZ2wsIHByb2dyYW0sIHJlbmRlcmVyICknLlxcclxcblxcdCAqXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBQcm9wZXJ0aWVzIG9mIGlubmVyIG5vZGVzIGluY2x1ZGluZyB0aGUgdG9wLWxldmVsIGNvbnRhaW5lcjpcXHJcXG5cXHQgKlxcclxcblxcdCAqIC5zZXEgLSBhcnJheSBvZiBuZXN0ZWQgdW5pZm9ybXNcXHJcXG5cXHQgKiAubWFwIC0gbmVzdGVkIHVuaWZvcm1zIGJ5IG5hbWVcXHJcXG5cXHQgKlxcclxcblxcdCAqXFxyXFxuXFx0ICogTWV0aG9kcyBvZiBhbGwgbm9kZXMgZXhjZXB0IHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyOlxcclxcblxcdCAqXFxyXFxuXFx0ICogLnNldFZhbHVlKCBnbCwgdmFsdWUsIFtyZW5kZXJlcl0gKVxcclxcblxcdCAqXFxyXFxuXFx0ICogXFx0XFx0dXBsb2FkcyBhIHVuaWZvcm0gdmFsdWUocylcXHJcXG5cXHQgKiAgXFx0dGhlICdyZW5kZXJlcicgcGFyYW1ldGVyIGlzIG5lZWRlZCBmb3Igc2FtcGxlciB1bmlmb3Jtc1xcclxcblxcdCAqXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBTdGF0aWMgbWV0aG9kcyBvZiB0aGUgdG9wLWxldmVsIGNvbnRhaW5lciAocmVuZGVyZXIgZmFjdG9yaXphdGlvbnMpOlxcclxcblxcdCAqXFxyXFxuXFx0ICogLnVwbG9hZCggZ2wsIHNlcSwgdmFsdWVzLCByZW5kZXJlciApXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBcXHRcXHRzZXRzIHVuaWZvcm1zIGluICdzZXEnIHRvICd2YWx1ZXNbaWRdLnZhbHVlJ1xcclxcblxcdCAqXFxyXFxuXFx0ICogLnNlcVdpdGhWYWx1ZSggc2VxLCB2YWx1ZXMgKSA6IGZpbHRlcmVkU2VxXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBcXHRcXHRmaWx0ZXJzICdzZXEnIGVudHJpZXMgd2l0aCBjb3JyZXNwb25kaW5nIGVudHJ5IGluIHZhbHVlc1xcclxcblxcdCAqXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBNZXRob2RzIG9mIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyIChyZW5kZXJlciBmYWN0b3JpemF0aW9ucyk6XFxyXFxuXFx0ICpcXHJcXG5cXHQgKiAuc2V0VmFsdWUoIGdsLCBuYW1lLCB2YWx1ZSApXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBcXHRcXHRzZXRzIHVuaWZvcm0gd2l0aCAgbmFtZSAnbmFtZScgdG8gJ3ZhbHVlJ1xcclxcblxcdCAqXFxyXFxuXFx0ICogLnNldCggZ2wsIG9iaiwgcHJvcCApXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBcXHRcXHRzZXRzIHVuaWZvcm0gZnJvbSBvYmplY3QgYW5kIHByb3BlcnR5IHdpdGggc2FtZSBuYW1lIHRoYW4gdW5pZm9ybVxcclxcblxcdCAqXFxyXFxuXFx0ICogLnNldE9wdGlvbmFsKCBnbCwgb2JqLCBwcm9wIClcXHJcXG5cXHQgKlxcclxcblxcdCAqIFxcdFxcdGxpa2UgLnNldCBmb3IgYW4gb3B0aW9uYWwgcHJvcGVydHkgb2YgdGhlIG9iamVjdFxcclxcblxcdCAqXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0dmFyIGVtcHR5VGV4dHVyZSA9IG5ldyBUZXh0dXJlKCk7XFxyXFxuXFx0dmFyIGVtcHR5Q3ViZVRleHR1cmUgPSBuZXcgQ3ViZVRleHR1cmUoKTtcXHJcXG5cXHJcXG5cXHQvLyAtLS0gQmFzZSBmb3IgaW5uZXIgbm9kZXMgKGluY2x1ZGluZyB0aGUgcm9vdCkgLS0tXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gVW5pZm9ybUNvbnRhaW5lcigpIHtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnNlcSA9IFtdO1xcclxcblxcdFxcdHRoaXMubWFwID0ge307XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8vIC0tLSBVdGlsaXRpZXMgLS0tXFxyXFxuXFxyXFxuXFx0Ly8gQXJyYXkgQ2FjaGVzIChwcm92aWRlIHR5cGVkIGFycmF5cyBmb3IgdGVtcG9yYXJ5IGJ5IHNpemUpXFxyXFxuXFxyXFxuXFx0dmFyIGFycmF5Q2FjaGVGMzIgPSBbXTtcXHJcXG5cXHR2YXIgYXJyYXlDYWNoZUkzMiA9IFtdO1xcclxcblxcclxcblxcdC8vIEZsb2F0MzJBcnJheSBjYWNoZXMgdXNlZCBmb3IgdXBsb2FkaW5nIE1hdHJpeCB1bmlmb3Jtc1xcclxcblxcclxcblxcdHZhciBtYXQ0YXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCAxNiApO1xcclxcblxcdHZhciBtYXQzYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCA5ICk7XFxyXFxuXFxyXFxuXFx0Ly8gRmxhdHRlbmluZyBmb3IgYXJyYXlzIG9mIHZlY3RvcnMgYW5kIG1hdHJpY2VzXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gZmxhdHRlbiggYXJyYXksIG5CbG9ja3MsIGJsb2NrU2l6ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgZmlyc3RFbGVtID0gYXJyYXlbIDAgXTtcXHJcXG5cXHJcXG5cXHRcXHRpZiAoIGZpcnN0RWxlbSA8PSAwIHx8IGZpcnN0RWxlbSA+IDAgKSByZXR1cm4gYXJyYXk7XFxyXFxuXFx0XFx0Ly8gdW5vcHRpbWl6ZWQ6ICEgaXNOYU4oIGZpcnN0RWxlbSApXFxyXFxuXFx0XFx0Ly8gc2VlIGh0dHA6Ly9qYWNrc29uZHVuc3Rhbi5jb20vYXJ0aWNsZXMvOTgzXFxyXFxuXFxyXFxuXFx0XFx0dmFyIG4gPSBuQmxvY2tzICogYmxvY2tTaXplLFxcclxcblxcdFxcdFxcdHIgPSBhcnJheUNhY2hlRjMyWyBuIF07XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCByID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0ciA9IG5ldyBGbG9hdDMyQXJyYXkoIG4gKTtcXHJcXG5cXHRcXHRcXHRhcnJheUNhY2hlRjMyWyBuIF0gPSByO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRpZiAoIG5CbG9ja3MgIT09IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zmlyc3RFbGVtLnRvQXJyYXkoIHIsIDAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDEsIG9mZnNldCA9IDA7IGkgIT09IG5CbG9ja3M7ICsrIGkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0b2Zmc2V0ICs9IGJsb2NrU2l6ZTtcXHJcXG5cXHRcXHRcXHRcXHRhcnJheVsgaSBdLnRvQXJyYXkoIHIsIG9mZnNldCApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHI7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8vIFRleHR1cmUgdW5pdCBhbGxvY2F0aW9uXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gYWxsb2NUZXhVbml0cyggcmVuZGVyZXIsIG4gKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHIgPSBhcnJheUNhY2hlSTMyWyBuIF07XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCByID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0ciA9IG5ldyBJbnQzMkFycmF5KCBuICk7XFxyXFxuXFx0XFx0XFx0YXJyYXlDYWNoZUkzMlsgbiBdID0gcjtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuOyArKyBpIClcXHJcXG5cXHRcXHRcXHRyWyBpIF0gPSByZW5kZXJlci5hbGxvY1RleHR1cmVVbml0KCk7XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHI7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8vIC0tLSBTZXR0ZXJzIC0tLVxcclxcblxcclxcblxcdC8vIE5vdGU6IERlZmluaW5nIHRoZXNlIG1ldGhvZHMgZXh0ZXJuYWxseSwgYmVjYXVzZSB0aGV5IGNvbWUgaW4gYSBidW5jaFxcclxcblxcdC8vIGFuZCB0aGlzIHdheSB0aGVpciBuYW1lcyBtaW5pZnkuXFxyXFxuXFxyXFxuXFx0Ly8gU2luZ2xlIHNjYWxhclxcclxcblxcclxcblxcdGZ1bmN0aW9uIHNldFZhbHVlMWYoIGdsLCB2ICkge1xcclxcblxcclxcblxcdFxcdGdsLnVuaWZvcm0xZiggdGhpcy5hZGRyLCB2ICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdGZ1bmN0aW9uIHNldFZhbHVlMWkoIGdsLCB2ICkge1xcclxcblxcclxcblxcdFxcdGdsLnVuaWZvcm0xaSggdGhpcy5hZGRyLCB2ICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8vIFNpbmdsZSBmbG9hdCB2ZWN0b3IgKGZyb20gZmxhdCBhcnJheSBvciBUSFJFRS5WZWN0b3JOKVxcclxcblxcclxcblxcdGZ1bmN0aW9uIHNldFZhbHVlMmZ2KCBnbCwgdiApIHtcXHJcXG5cXHJcXG5cXHRcXHRpZiAoIHYueCA9PT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdGdsLnVuaWZvcm0yZnYoIHRoaXMuYWRkciwgdiApO1xcclxcblxcclxcblxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Z2wudW5pZm9ybTJmKCB0aGlzLmFkZHIsIHYueCwgdi55ICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBzZXRWYWx1ZTNmdiggZ2wsIHYgKSB7XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCB2LnggIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRnbC51bmlmb3JtM2YoIHRoaXMuYWRkciwgdi54LCB2LnksIHYueiApO1xcclxcblxcclxcblxcdFxcdH0gZWxzZSBpZiAoIHYuciAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdGdsLnVuaWZvcm0zZiggdGhpcy5hZGRyLCB2LnIsIHYuZywgdi5iICk7XFxyXFxuXFxyXFxuXFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRnbC51bmlmb3JtM2Z2KCB0aGlzLmFkZHIsIHYgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdGZ1bmN0aW9uIHNldFZhbHVlNGZ2KCBnbCwgdiApIHtcXHJcXG5cXHJcXG5cXHRcXHRpZiAoIHYueCA9PT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdGdsLnVuaWZvcm00ZnYoIHRoaXMuYWRkciwgdiApO1xcclxcblxcclxcblxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0IGdsLnVuaWZvcm00ZiggdGhpcy5hZGRyLCB2LngsIHYueSwgdi56LCB2LncgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8vIFNpbmdsZSBtYXRyaXggKGZyb20gZmxhdCBhcnJheSBvciBNYXRyaXhOKVxcclxcblxcclxcblxcdGZ1bmN0aW9uIHNldFZhbHVlMmZtKCBnbCwgdiApIHtcXHJcXG5cXHJcXG5cXHRcXHRnbC51bmlmb3JtTWF0cml4MmZ2KCB0aGlzLmFkZHIsIGZhbHNlLCB2LmVsZW1lbnRzIHx8IHYgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gc2V0VmFsdWUzZm0oIGdsLCB2ICkge1xcclxcblxcclxcblxcdFxcdGlmICggdi5lbGVtZW50cyA9PT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdGdsLnVuaWZvcm1NYXRyaXgzZnYoIHRoaXMuYWRkciwgZmFsc2UsIHYgKTtcXHJcXG5cXHJcXG5cXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdG1hdDNhcnJheS5zZXQoIHYuZWxlbWVudHMgKTtcXHJcXG5cXHRcXHRcXHRnbC51bmlmb3JtTWF0cml4M2Z2KCB0aGlzLmFkZHIsIGZhbHNlLCBtYXQzYXJyYXkgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdGZ1bmN0aW9uIHNldFZhbHVlNGZtKCBnbCwgdiApIHtcXHJcXG5cXHJcXG5cXHRcXHRpZiAoIHYuZWxlbWVudHMgPT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRnbC51bmlmb3JtTWF0cml4NGZ2KCB0aGlzLmFkZHIsIGZhbHNlLCB2ICk7XFxyXFxuXFxyXFxuXFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRtYXQ0YXJyYXkuc2V0KCB2LmVsZW1lbnRzICk7XFxyXFxuXFx0XFx0XFx0Z2wudW5pZm9ybU1hdHJpeDRmdiggdGhpcy5hZGRyLCBmYWxzZSwgbWF0NGFycmF5ICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHQvLyBTaW5nbGUgdGV4dHVyZSAoMkQgLyBDdWJlKVxcclxcblxcclxcblxcdGZ1bmN0aW9uIHNldFZhbHVlVDEoIGdsLCB2LCByZW5kZXJlciApIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgdW5pdCA9IHJlbmRlcmVyLmFsbG9jVGV4dHVyZVVuaXQoKTtcXHJcXG5cXHRcXHRnbC51bmlmb3JtMWkoIHRoaXMuYWRkciwgdW5pdCApO1xcclxcblxcdFxcdHJlbmRlcmVyLnNldFRleHR1cmUyRCggdiB8fCBlbXB0eVRleHR1cmUsIHVuaXQgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gc2V0VmFsdWVUNiggZ2wsIHYsIHJlbmRlcmVyICkge1xcclxcblxcclxcblxcdFxcdHZhciB1bml0ID0gcmVuZGVyZXIuYWxsb2NUZXh0dXJlVW5pdCgpO1xcclxcblxcdFxcdGdsLnVuaWZvcm0xaSggdGhpcy5hZGRyLCB1bml0ICk7XFxyXFxuXFx0XFx0cmVuZGVyZXIuc2V0VGV4dHVyZUN1YmUoIHYgfHwgZW1wdHlDdWJlVGV4dHVyZSwgdW5pdCApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHQvLyBJbnRlZ2VyIC8gQm9vbGVhbiB2ZWN0b3JzIG9yIGFycmF5cyB0aGVyZW9mIChhbHdheXMgZmxhdCBhcnJheXMpXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gc2V0VmFsdWUyaXYoIGdsLCB2ICkge1xcclxcblxcclxcblxcdFxcdGdsLnVuaWZvcm0yaXYoIHRoaXMuYWRkciwgdiApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBzZXRWYWx1ZTNpdiggZ2wsIHYgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Z2wudW5pZm9ybTNpdiggdGhpcy5hZGRyLCB2ICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdGZ1bmN0aW9uIHNldFZhbHVlNGl2KCBnbCwgdiApIHtcXHJcXG5cXHJcXG5cXHRcXHRnbC51bmlmb3JtNGl2KCB0aGlzLmFkZHIsIHYgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0Ly8gSGVscGVyIHRvIHBpY2sgdGhlIHJpZ2h0IHNldHRlciBmb3IgdGhlIHNpbmd1bGFyIGNhc2VcXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBnZXRTaW5ndWxhclNldHRlciggdHlwZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRzd2l0Y2ggKCB0eXBlICkge1xcclxcblxcclxcblxcdFxcdFxcdGNhc2UgMHgxNDA2OiByZXR1cm4gc2V0VmFsdWUxZjsgLy8gRkxPQVRcXHJcXG5cXHRcXHRcXHRjYXNlIDB4OGI1MDogcmV0dXJuIHNldFZhbHVlMmZ2OyAvLyBfVkVDMlxcclxcblxcdFxcdFxcdGNhc2UgMHg4YjUxOiByZXR1cm4gc2V0VmFsdWUzZnY7IC8vIF9WRUMzXFxyXFxuXFx0XFx0XFx0Y2FzZSAweDhiNTI6IHJldHVybiBzZXRWYWx1ZTRmdjsgLy8gX1ZFQzRcXHJcXG5cXHJcXG5cXHRcXHRcXHRjYXNlIDB4OGI1YTogcmV0dXJuIHNldFZhbHVlMmZtOyAvLyBfTUFUMlxcclxcblxcdFxcdFxcdGNhc2UgMHg4YjViOiByZXR1cm4gc2V0VmFsdWUzZm07IC8vIF9NQVQzXFxyXFxuXFx0XFx0XFx0Y2FzZSAweDhiNWM6IHJldHVybiBzZXRWYWx1ZTRmbTsgLy8gX01BVDRcXHJcXG5cXHJcXG5cXHRcXHRcXHRjYXNlIDB4OGI1ZTogY2FzZSAweDhkNjY6IHJldHVybiBzZXRWYWx1ZVQxOyAvLyBTQU1QTEVSXzJELCBTQU1QTEVSX0VYVEVSTkFMX09FU1xcclxcblxcdFxcdFxcdGNhc2UgMHg4YjYwOiByZXR1cm4gc2V0VmFsdWVUNjsgLy8gU0FNUExFUl9DVUJFXFxyXFxuXFxyXFxuXFx0XFx0XFx0Y2FzZSAweDE0MDQ6IGNhc2UgMHg4YjU2OiByZXR1cm4gc2V0VmFsdWUxaTsgLy8gSU5ULCBCT09MXFxyXFxuXFx0XFx0XFx0Y2FzZSAweDhiNTM6IGNhc2UgMHg4YjU3OiByZXR1cm4gc2V0VmFsdWUyaXY7IC8vIF9WRUMyXFxyXFxuXFx0XFx0XFx0Y2FzZSAweDhiNTQ6IGNhc2UgMHg4YjU4OiByZXR1cm4gc2V0VmFsdWUzaXY7IC8vIF9WRUMzXFxyXFxuXFx0XFx0XFx0Y2FzZSAweDhiNTU6IGNhc2UgMHg4YjU5OiByZXR1cm4gc2V0VmFsdWU0aXY7IC8vIF9WRUM0XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHQvLyBBcnJheSBvZiBzY2FsYXJzXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gc2V0VmFsdWUxZnYoIGdsLCB2ICkge1xcclxcblxcclxcblxcdFxcdGdsLnVuaWZvcm0xZnYoIHRoaXMuYWRkciwgdiApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHRmdW5jdGlvbiBzZXRWYWx1ZTFpdiggZ2wsIHYgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Z2wudW5pZm9ybTFpdiggdGhpcy5hZGRyLCB2ICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8vIEFycmF5IG9mIHZlY3RvcnMgKGZsYXQgb3IgZnJvbSBUSFJFRSBjbGFzc2VzKVxcclxcblxcclxcblxcdGZ1bmN0aW9uIHNldFZhbHVlVjJhKCBnbCwgdiApIHtcXHJcXG5cXHJcXG5cXHRcXHRnbC51bmlmb3JtMmZ2KCB0aGlzLmFkZHIsIGZsYXR0ZW4oIHYsIHRoaXMuc2l6ZSwgMiApICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdGZ1bmN0aW9uIHNldFZhbHVlVjNhKCBnbCwgdiApIHtcXHJcXG5cXHJcXG5cXHRcXHRnbC51bmlmb3JtM2Z2KCB0aGlzLmFkZHIsIGZsYXR0ZW4oIHYsIHRoaXMuc2l6ZSwgMyApICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdGZ1bmN0aW9uIHNldFZhbHVlVjRhKCBnbCwgdiApIHtcXHJcXG5cXHJcXG5cXHRcXHRnbC51bmlmb3JtNGZ2KCB0aGlzLmFkZHIsIGZsYXR0ZW4oIHYsIHRoaXMuc2l6ZSwgNCApICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8vIEFycmF5IG9mIG1hdHJpY2VzIChmbGF0IG9yIGZyb20gVEhSRUUgY2xhc2VzKVxcclxcblxcclxcblxcdGZ1bmN0aW9uIHNldFZhbHVlTTJhKCBnbCwgdiApIHtcXHJcXG5cXHJcXG5cXHRcXHRnbC51bmlmb3JtTWF0cml4MmZ2KCB0aGlzLmFkZHIsIGZhbHNlLCBmbGF0dGVuKCB2LCB0aGlzLnNpemUsIDQgKSApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBzZXRWYWx1ZU0zYSggZ2wsIHYgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Z2wudW5pZm9ybU1hdHJpeDNmdiggdGhpcy5hZGRyLCBmYWxzZSwgZmxhdHRlbiggdiwgdGhpcy5zaXplLCA5ICkgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gc2V0VmFsdWVNNGEoIGdsLCB2ICkge1xcclxcblxcclxcblxcdFxcdGdsLnVuaWZvcm1NYXRyaXg0ZnYoIHRoaXMuYWRkciwgZmFsc2UsIGZsYXR0ZW4oIHYsIHRoaXMuc2l6ZSwgMTYgKSApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHQvLyBBcnJheSBvZiB0ZXh0dXJlcyAoMkQgLyBDdWJlKVxcclxcblxcclxcblxcdGZ1bmN0aW9uIHNldFZhbHVlVDFhKCBnbCwgdiwgcmVuZGVyZXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIG4gPSB2Lmxlbmd0aCxcXHJcXG5cXHRcXHRcXHR1bml0cyA9IGFsbG9jVGV4VW5pdHMoIHJlbmRlcmVyLCBuICk7XFxyXFxuXFxyXFxuXFx0XFx0Z2wudW5pZm9ybTFpdiggdGhpcy5hZGRyLCB1bml0cyApO1xcclxcblxcclxcblxcdFxcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbjsgKysgaSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZW5kZXJlci5zZXRUZXh0dXJlMkQoIHZbIGkgXSB8fCBlbXB0eVRleHR1cmUsIHVuaXRzWyBpIF0gKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdGZ1bmN0aW9uIHNldFZhbHVlVDZhKCBnbCwgdiwgcmVuZGVyZXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIG4gPSB2Lmxlbmd0aCxcXHJcXG5cXHRcXHRcXHR1bml0cyA9IGFsbG9jVGV4VW5pdHMoIHJlbmRlcmVyLCBuICk7XFxyXFxuXFxyXFxuXFx0XFx0Z2wudW5pZm9ybTFpdiggdGhpcy5hZGRyLCB1bml0cyApO1xcclxcblxcclxcblxcdFxcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbjsgKysgaSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZW5kZXJlci5zZXRUZXh0dXJlQ3ViZSggdlsgaSBdIHx8IGVtcHR5Q3ViZVRleHR1cmUsIHVuaXRzWyBpIF0gKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8vIEhlbHBlciB0byBwaWNrIHRoZSByaWdodCBzZXR0ZXIgZm9yIGEgcHVyZSAoYm90dG9tLWxldmVsKSBhcnJheVxcclxcblxcclxcblxcdGZ1bmN0aW9uIGdldFB1cmVBcnJheVNldHRlciggdHlwZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRzd2l0Y2ggKCB0eXBlICkge1xcclxcblxcclxcblxcdFxcdFxcdGNhc2UgMHgxNDA2OiByZXR1cm4gc2V0VmFsdWUxZnY7IC8vIEZMT0FUXFxyXFxuXFx0XFx0XFx0Y2FzZSAweDhiNTA6IHJldHVybiBzZXRWYWx1ZVYyYTsgLy8gX1ZFQzJcXHJcXG5cXHRcXHRcXHRjYXNlIDB4OGI1MTogcmV0dXJuIHNldFZhbHVlVjNhOyAvLyBfVkVDM1xcclxcblxcdFxcdFxcdGNhc2UgMHg4YjUyOiByZXR1cm4gc2V0VmFsdWVWNGE7IC8vIF9WRUM0XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y2FzZSAweDhiNWE6IHJldHVybiBzZXRWYWx1ZU0yYTsgLy8gX01BVDJcXHJcXG5cXHRcXHRcXHRjYXNlIDB4OGI1YjogcmV0dXJuIHNldFZhbHVlTTNhOyAvLyBfTUFUM1xcclxcblxcdFxcdFxcdGNhc2UgMHg4YjVjOiByZXR1cm4gc2V0VmFsdWVNNGE7IC8vIF9NQVQ0XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y2FzZSAweDhiNWU6IHJldHVybiBzZXRWYWx1ZVQxYTsgLy8gU0FNUExFUl8yRFxcclxcblxcdFxcdFxcdGNhc2UgMHg4YjYwOiByZXR1cm4gc2V0VmFsdWVUNmE7IC8vIFNBTVBMRVJfQ1VCRVxcclxcblxcclxcblxcdFxcdFxcdGNhc2UgMHgxNDA0OiBjYXNlIDB4OGI1NjogcmV0dXJuIHNldFZhbHVlMWl2OyAvLyBJTlQsIEJPT0xcXHJcXG5cXHRcXHRcXHRjYXNlIDB4OGI1MzogY2FzZSAweDhiNTc6IHJldHVybiBzZXRWYWx1ZTJpdjsgLy8gX1ZFQzJcXHJcXG5cXHRcXHRcXHRjYXNlIDB4OGI1NDogY2FzZSAweDhiNTg6IHJldHVybiBzZXRWYWx1ZTNpdjsgLy8gX1ZFQzNcXHJcXG5cXHRcXHRcXHRjYXNlIDB4OGI1NTogY2FzZSAweDhiNTk6IHJldHVybiBzZXRWYWx1ZTRpdjsgLy8gX1ZFQzRcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8vIC0tLSBVbmlmb3JtIENsYXNzZXMgLS0tXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gU2luZ2xlVW5pZm9ybSggaWQsIGFjdGl2ZUluZm8sIGFkZHIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5pZCA9IGlkO1xcclxcblxcdFxcdHRoaXMuYWRkciA9IGFkZHI7XFxyXFxuXFx0XFx0dGhpcy5zZXRWYWx1ZSA9IGdldFNpbmd1bGFyU2V0dGVyKCBhY3RpdmVJbmZvLnR5cGUgKTtcXHJcXG5cXHJcXG5cXHRcXHQvLyB0aGlzLnBhdGggPSBhY3RpdmVJbmZvLm5hbWU7IC8vIERFQlVHXFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdGZ1bmN0aW9uIFB1cmVBcnJheVVuaWZvcm0oIGlkLCBhY3RpdmVJbmZvLCBhZGRyICkge1xcclxcblxcclxcblxcdFxcdHRoaXMuaWQgPSBpZDtcXHJcXG5cXHRcXHR0aGlzLmFkZHIgPSBhZGRyO1xcclxcblxcdFxcdHRoaXMuc2l6ZSA9IGFjdGl2ZUluZm8uc2l6ZTtcXHJcXG5cXHRcXHR0aGlzLnNldFZhbHVlID0gZ2V0UHVyZUFycmF5U2V0dGVyKCBhY3RpdmVJbmZvLnR5cGUgKTtcXHJcXG5cXHJcXG5cXHRcXHQvLyB0aGlzLnBhdGggPSBhY3RpdmVJbmZvLm5hbWU7IC8vIERFQlVHXFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdGZ1bmN0aW9uIFN0cnVjdHVyZWRVbmlmb3JtKCBpZCApIHtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmlkID0gaWQ7XFxyXFxuXFxyXFxuXFx0XFx0VW5pZm9ybUNvbnRhaW5lci5jYWxsKCB0aGlzICk7IC8vIG1peC1pblxcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRTdHJ1Y3R1cmVkVW5pZm9ybS5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAoIGdsLCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHQvLyBOb3RlOiBEb24ndCBuZWVkIGFuIGV4dHJhICdyZW5kZXJlcicgcGFyYW1ldGVyLCBzaW5jZSBzYW1wbGVyc1xcclxcblxcdFxcdC8vIGFyZSBub3QgYWxsb3dlZCBpbiBzdHJ1Y3R1cmVkIHVuaWZvcm1zLlxcclxcblxcclxcblxcdFxcdHZhciBzZXEgPSB0aGlzLnNlcTtcXHJcXG5cXHJcXG5cXHRcXHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBzZXEubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB1ID0gc2VxWyBpIF07XFxyXFxuXFx0XFx0XFx0dS5zZXRWYWx1ZSggZ2wsIHZhbHVlWyB1LmlkIF0gKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHQvLyAtLS0gVG9wLWxldmVsIC0tLVxcclxcblxcclxcblxcdC8vIFBhcnNlciAtIGJ1aWxkcyB1cCB0aGUgcHJvcGVydHkgdHJlZSBmcm9tIHRoZSBwYXRoIHN0cmluZ3NcXHJcXG5cXHJcXG5cXHR2YXIgUmVQYXRoUGFydCA9IC8oW1xcXFx3XFxcXGRfXSspKFxcXFxdKT8oXFxcXFt8XFxcXC4pPy9nO1xcclxcblxcclxcblxcdC8vIGV4dHJhY3RzXFxyXFxuXFx0Ly8gXFx0LSB0aGUgaWRlbnRpZmllciAobWVtYmVyIG5hbWUgb3IgYXJyYXkgaW5kZXgpXFxyXFxuXFx0Ly8gIC0gZm9sbG93ZWQgYnkgYW4gb3B0aW9uYWwgcmlnaHQgYnJhY2tldCAoZm91bmQgd2hlbiBhcnJheSBpbmRleClcXHJcXG5cXHQvLyAgLSBmb2xsb3dlZCBieSBhbiBvcHRpb25hbCBsZWZ0IGJyYWNrZXQgb3IgZG90ICh0eXBlIG9mIHN1YnNjcmlwdClcXHJcXG5cXHQvL1xcclxcblxcdC8vIE5vdGU6IFRoZXNlIHBvcnRpb25zIGNhbiBiZSByZWFkIGluIGEgbm9uLW92ZXJsYXBwaW5nIGZhc2hpb24gYW5kXFxyXFxuXFx0Ly8gYWxsb3cgc3RyYWlnaHRmb3J3YXJkIHBhcnNpbmcgb2YgdGhlIGhpZXJhcmNoeSB0aGF0IFdlYkdMIGVuY29kZXNcXHJcXG5cXHQvLyBpbiB0aGUgdW5pZm9ybSBuYW1lcy5cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBhZGRVbmlmb3JtKCBjb250YWluZXIsIHVuaWZvcm1PYmplY3QgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Y29udGFpbmVyLnNlcS5wdXNoKCB1bmlmb3JtT2JqZWN0ICk7XFxyXFxuXFx0XFx0Y29udGFpbmVyLm1hcFsgdW5pZm9ybU9iamVjdC5pZCBdID0gdW5pZm9ybU9iamVjdDtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gcGFyc2VVbmlmb3JtKCBhY3RpdmVJbmZvLCBhZGRyLCBjb250YWluZXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHBhdGggPSBhY3RpdmVJbmZvLm5hbWUsXFxyXFxuXFx0XFx0XFx0cGF0aExlbmd0aCA9IHBhdGgubGVuZ3RoO1xcclxcblxcclxcblxcdFxcdC8vIHJlc2V0IFJlZ0V4cCBvYmplY3QsIGJlY2F1c2Ugb2YgdGhlIGVhcmx5IGV4aXQgb2YgYSBwcmV2aW91cyBydW5cXHJcXG5cXHRcXHRSZVBhdGhQYXJ0Lmxhc3RJbmRleCA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0Zm9yICggOyA7ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBtYXRjaCA9IFJlUGF0aFBhcnQuZXhlYyggcGF0aCApLFxcclxcblxcdFxcdFxcdFxcdG1hdGNoRW5kID0gUmVQYXRoUGFydC5sYXN0SW5kZXgsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWQgPSBtYXRjaFsgMSBdLFxcclxcblxcdFxcdFxcdFxcdGlkSXNJbmRleCA9IG1hdGNoWyAyIF0gPT09ICddJyxcXHJcXG5cXHRcXHRcXHRcXHRzdWJzY3JpcHQgPSBtYXRjaFsgMyBdO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggaWRJc0luZGV4ICkgaWQgPSBpZCB8IDA7IC8vIGNvbnZlcnQgdG8gaW50ZWdlclxcclxcblxcclxcblxcdFxcdFxcdGlmICggc3Vic2NyaXB0ID09PSB1bmRlZmluZWQgfHwgc3Vic2NyaXB0ID09PSAnWycgJiYgbWF0Y2hFbmQgKyAyID09PSBwYXRoTGVuZ3RoICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGJhcmUgbmFtZSBvciBcXFwicHVyZVxcXCIgYm90dG9tLWxldmVsIGFycmF5IFxcXCJbMF1cXFwiIHN1ZmZpeFxcclxcblxcclxcblxcdFxcdFxcdFxcdGFkZFVuaWZvcm0oIGNvbnRhaW5lciwgc3Vic2NyaXB0ID09PSB1bmRlZmluZWQgP1xcclxcblxcdFxcdFxcdFxcdFxcdG5ldyBTaW5nbGVVbmlmb3JtKCBpZCwgYWN0aXZlSW5mbywgYWRkciApIDpcXHJcXG5cXHRcXHRcXHRcXHRcXHRuZXcgUHVyZUFycmF5VW5pZm9ybSggaWQsIGFjdGl2ZUluZm8sIGFkZHIgKSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gc3RlcCBpbnRvIGlubmVyIG5vZGUgLyBjcmVhdGUgaXQgaW4gY2FzZSBpdCBkb2Vzbid0IGV4aXN0XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIG1hcCA9IGNvbnRhaW5lci5tYXAsIG5leHQgPSBtYXBbIGlkIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBuZXh0ID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0bmV4dCA9IG5ldyBTdHJ1Y3R1cmVkVW5pZm9ybSggaWQgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRhZGRVbmlmb3JtKCBjb250YWluZXIsIG5leHQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29udGFpbmVyID0gbmV4dDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHQvLyBSb290IENvbnRhaW5lclxcclxcblxcclxcblxcdGZ1bmN0aW9uIFdlYkdMVW5pZm9ybXMoIGdsLCBwcm9ncmFtLCByZW5kZXJlciApIHtcXHJcXG5cXHJcXG5cXHRcXHRVbmlmb3JtQ29udGFpbmVyLmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIG4gPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5BQ1RJVkVfVU5JRk9STVMgKTtcXHJcXG5cXHJcXG5cXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBuOyArKyBpICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBpbmZvID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybSggcHJvZ3JhbSwgaSApLFxcclxcblxcdFxcdFxcdFxcdHBhdGggPSBpbmZvLm5hbWUsXFxyXFxuXFx0XFx0XFx0XFx0YWRkciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgcGF0aCApO1xcclxcblxcclxcblxcdFxcdFxcdHBhcnNlVW5pZm9ybSggaW5mbywgYWRkciwgdGhpcyApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0V2ViR0xVbmlmb3Jtcy5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAoIGdsLCBuYW1lLCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgdSA9IHRoaXMubWFwWyBuYW1lIF07XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCB1ICE9PSB1bmRlZmluZWQgKSB1LnNldFZhbHVlKCBnbCwgdmFsdWUsIHRoaXMucmVuZGVyZXIgKTtcXHJcXG5cXHJcXG5cXHR9O1xcclxcblxcclxcblxcdFdlYkdMVW5pZm9ybXMucHJvdG90eXBlLnNldE9wdGlvbmFsID0gZnVuY3Rpb24gKCBnbCwgb2JqZWN0LCBuYW1lICkge1xcclxcblxcclxcblxcdFxcdHZhciB2ID0gb2JqZWN0WyBuYW1lIF07XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCB2ICE9PSB1bmRlZmluZWQgKSB0aGlzLnNldFZhbHVlKCBnbCwgbmFtZSwgdiApO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFxyXFxuXFx0Ly8gU3RhdGljIGludGVyZmFjZVxcclxcblxcclxcblxcdFdlYkdMVW5pZm9ybXMudXBsb2FkID0gZnVuY3Rpb24gKCBnbCwgc2VxLCB2YWx1ZXMsIHJlbmRlcmVyICkge1xcclxcblxcclxcblxcdFxcdGZvciAoIHZhciBpID0gMCwgbiA9IHNlcS5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHUgPSBzZXFbIGkgXSxcXHJcXG5cXHRcXHRcXHRcXHR2ID0gdmFsdWVzWyB1LmlkIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB2Lm5lZWRzVXBkYXRlICE9PSBmYWxzZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBub3RlOiBhbHdheXMgdXBkYXRpbmcgd2hlbiAubmVlZHNVcGRhdGUgaXMgdW5kZWZpbmVkXFxyXFxuXFx0XFx0XFx0XFx0dS5zZXRWYWx1ZSggZ2wsIHYudmFsdWUsIHJlbmRlcmVyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9O1xcclxcblxcclxcblxcdFdlYkdMVW5pZm9ybXMuc2VxV2l0aFZhbHVlID0gZnVuY3Rpb24gKCBzZXEsIHZhbHVlcyApIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgciA9IFtdO1xcclxcblxcclxcblxcdFxcdGZvciAoIHZhciBpID0gMCwgbiA9IHNlcS5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHUgPSBzZXFbIGkgXTtcXHJcXG5cXHRcXHRcXHRpZiAoIHUuaWQgaW4gdmFsdWVzICkgci5wdXNoKCB1ICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHJldHVybiByO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHR2YXIgQ29sb3JLZXl3b3JkcyA9IHsgJ2FsaWNlYmx1ZSc6IDB4RjBGOEZGLCAnYW50aXF1ZXdoaXRlJzogMHhGQUVCRDcsICdhcXVhJzogMHgwMEZGRkYsICdhcXVhbWFyaW5lJzogMHg3RkZGRDQsICdhenVyZSc6IDB4RjBGRkZGLFxcclxcblxcdFxcdCdiZWlnZSc6IDB4RjVGNURDLCAnYmlzcXVlJzogMHhGRkU0QzQsICdibGFjayc6IDB4MDAwMDAwLCAnYmxhbmNoZWRhbG1vbmQnOiAweEZGRUJDRCwgJ2JsdWUnOiAweDAwMDBGRiwgJ2JsdWV2aW9sZXQnOiAweDhBMkJFMixcXHJcXG5cXHRcXHQnYnJvd24nOiAweEE1MkEyQSwgJ2J1cmx5d29vZCc6IDB4REVCODg3LCAnY2FkZXRibHVlJzogMHg1RjlFQTAsICdjaGFydHJldXNlJzogMHg3RkZGMDAsICdjaG9jb2xhdGUnOiAweEQyNjkxRSwgJ2NvcmFsJzogMHhGRjdGNTAsXFxyXFxuXFx0XFx0J2Nvcm5mbG93ZXJibHVlJzogMHg2NDk1RUQsICdjb3Juc2lsayc6IDB4RkZGOERDLCAnY3JpbXNvbic6IDB4REMxNDNDLCAnY3lhbic6IDB4MDBGRkZGLCAnZGFya2JsdWUnOiAweDAwMDA4QiwgJ2RhcmtjeWFuJzogMHgwMDhCOEIsXFxyXFxuXFx0XFx0J2Rhcmtnb2xkZW5yb2QnOiAweEI4ODYwQiwgJ2RhcmtncmF5JzogMHhBOUE5QTksICdkYXJrZ3JlZW4nOiAweDAwNjQwMCwgJ2RhcmtncmV5JzogMHhBOUE5QTksICdkYXJra2hha2knOiAweEJEQjc2QiwgJ2RhcmttYWdlbnRhJzogMHg4QjAwOEIsXFxyXFxuXFx0XFx0J2RhcmtvbGl2ZWdyZWVuJzogMHg1NTZCMkYsICdkYXJrb3JhbmdlJzogMHhGRjhDMDAsICdkYXJrb3JjaGlkJzogMHg5OTMyQ0MsICdkYXJrcmVkJzogMHg4QjAwMDAsICdkYXJrc2FsbW9uJzogMHhFOTk2N0EsICdkYXJrc2VhZ3JlZW4nOiAweDhGQkM4RixcXHJcXG5cXHRcXHQnZGFya3NsYXRlYmx1ZSc6IDB4NDgzRDhCLCAnZGFya3NsYXRlZ3JheSc6IDB4MkY0RjRGLCAnZGFya3NsYXRlZ3JleSc6IDB4MkY0RjRGLCAnZGFya3R1cnF1b2lzZSc6IDB4MDBDRUQxLCAnZGFya3Zpb2xldCc6IDB4OTQwMEQzLFxcclxcblxcdFxcdCdkZWVwcGluayc6IDB4RkYxNDkzLCAnZGVlcHNreWJsdWUnOiAweDAwQkZGRiwgJ2RpbWdyYXknOiAweDY5Njk2OSwgJ2RpbWdyZXknOiAweDY5Njk2OSwgJ2RvZGdlcmJsdWUnOiAweDFFOTBGRiwgJ2ZpcmVicmljayc6IDB4QjIyMjIyLFxcclxcblxcdFxcdCdmbG9yYWx3aGl0ZSc6IDB4RkZGQUYwLCAnZm9yZXN0Z3JlZW4nOiAweDIyOEIyMiwgJ2Z1Y2hzaWEnOiAweEZGMDBGRiwgJ2dhaW5zYm9ybyc6IDB4RENEQ0RDLCAnZ2hvc3R3aGl0ZSc6IDB4RjhGOEZGLCAnZ29sZCc6IDB4RkZENzAwLFxcclxcblxcdFxcdCdnb2xkZW5yb2QnOiAweERBQTUyMCwgJ2dyYXknOiAweDgwODA4MCwgJ2dyZWVuJzogMHgwMDgwMDAsICdncmVlbnllbGxvdyc6IDB4QURGRjJGLCAnZ3JleSc6IDB4ODA4MDgwLCAnaG9uZXlkZXcnOiAweEYwRkZGMCwgJ2hvdHBpbmsnOiAweEZGNjlCNCxcXHJcXG5cXHRcXHQnaW5kaWFucmVkJzogMHhDRDVDNUMsICdpbmRpZ28nOiAweDRCMDA4MiwgJ2l2b3J5JzogMHhGRkZGRjAsICdraGFraSc6IDB4RjBFNjhDLCAnbGF2ZW5kZXInOiAweEU2RTZGQSwgJ2xhdmVuZGVyYmx1c2gnOiAweEZGRjBGNSwgJ2xhd25ncmVlbic6IDB4N0NGQzAwLFxcclxcblxcdFxcdCdsZW1vbmNoaWZmb24nOiAweEZGRkFDRCwgJ2xpZ2h0Ymx1ZSc6IDB4QUREOEU2LCAnbGlnaHRjb3JhbCc6IDB4RjA4MDgwLCAnbGlnaHRjeWFuJzogMHhFMEZGRkYsICdsaWdodGdvbGRlbnJvZHllbGxvdyc6IDB4RkFGQUQyLCAnbGlnaHRncmF5JzogMHhEM0QzRDMsXFxyXFxuXFx0XFx0J2xpZ2h0Z3JlZW4nOiAweDkwRUU5MCwgJ2xpZ2h0Z3JleSc6IDB4RDNEM0QzLCAnbGlnaHRwaW5rJzogMHhGRkI2QzEsICdsaWdodHNhbG1vbic6IDB4RkZBMDdBLCAnbGlnaHRzZWFncmVlbic6IDB4MjBCMkFBLCAnbGlnaHRza3libHVlJzogMHg4N0NFRkEsXFxyXFxuXFx0XFx0J2xpZ2h0c2xhdGVncmF5JzogMHg3Nzg4OTksICdsaWdodHNsYXRlZ3JleSc6IDB4Nzc4ODk5LCAnbGlnaHRzdGVlbGJsdWUnOiAweEIwQzRERSwgJ2xpZ2h0eWVsbG93JzogMHhGRkZGRTAsICdsaW1lJzogMHgwMEZGMDAsICdsaW1lZ3JlZW4nOiAweDMyQ0QzMixcXHJcXG5cXHRcXHQnbGluZW4nOiAweEZBRjBFNiwgJ21hZ2VudGEnOiAweEZGMDBGRiwgJ21hcm9vbic6IDB4ODAwMDAwLCAnbWVkaXVtYXF1YW1hcmluZSc6IDB4NjZDREFBLCAnbWVkaXVtYmx1ZSc6IDB4MDAwMENELCAnbWVkaXVtb3JjaGlkJzogMHhCQTU1RDMsXFxyXFxuXFx0XFx0J21lZGl1bXB1cnBsZSc6IDB4OTM3MERCLCAnbWVkaXVtc2VhZ3JlZW4nOiAweDNDQjM3MSwgJ21lZGl1bXNsYXRlYmx1ZSc6IDB4N0I2OEVFLCAnbWVkaXVtc3ByaW5nZ3JlZW4nOiAweDAwRkE5QSwgJ21lZGl1bXR1cnF1b2lzZSc6IDB4NDhEMUNDLFxcclxcblxcdFxcdCdtZWRpdW12aW9sZXRyZWQnOiAweEM3MTU4NSwgJ21pZG5pZ2h0Ymx1ZSc6IDB4MTkxOTcwLCAnbWludGNyZWFtJzogMHhGNUZGRkEsICdtaXN0eXJvc2UnOiAweEZGRTRFMSwgJ21vY2Nhc2luJzogMHhGRkU0QjUsICduYXZham93aGl0ZSc6IDB4RkZERUFELFxcclxcblxcdFxcdCduYXZ5JzogMHgwMDAwODAsICdvbGRsYWNlJzogMHhGREY1RTYsICdvbGl2ZSc6IDB4ODA4MDAwLCAnb2xpdmVkcmFiJzogMHg2QjhFMjMsICdvcmFuZ2UnOiAweEZGQTUwMCwgJ29yYW5nZXJlZCc6IDB4RkY0NTAwLCAnb3JjaGlkJzogMHhEQTcwRDYsXFxyXFxuXFx0XFx0J3BhbGVnb2xkZW5yb2QnOiAweEVFRThBQSwgJ3BhbGVncmVlbic6IDB4OThGQjk4LCAncGFsZXR1cnF1b2lzZSc6IDB4QUZFRUVFLCAncGFsZXZpb2xldHJlZCc6IDB4REI3MDkzLCAncGFwYXlhd2hpcCc6IDB4RkZFRkQ1LCAncGVhY2hwdWZmJzogMHhGRkRBQjksXFxyXFxuXFx0XFx0J3BlcnUnOiAweENEODUzRiwgJ3BpbmsnOiAweEZGQzBDQiwgJ3BsdW0nOiAweEREQTBERCwgJ3Bvd2RlcmJsdWUnOiAweEIwRTBFNiwgJ3B1cnBsZSc6IDB4ODAwMDgwLCAncmViZWNjYXB1cnBsZSc6IDB4NjYzMzk5LCAncmVkJzogMHhGRjAwMDAsICdyb3N5YnJvd24nOiAweEJDOEY4RixcXHJcXG5cXHRcXHQncm95YWxibHVlJzogMHg0MTY5RTEsICdzYWRkbGVicm93bic6IDB4OEI0NTEzLCAnc2FsbW9uJzogMHhGQTgwNzIsICdzYW5keWJyb3duJzogMHhGNEE0NjAsICdzZWFncmVlbic6IDB4MkU4QjU3LCAnc2Vhc2hlbGwnOiAweEZGRjVFRSxcXHJcXG5cXHRcXHQnc2llbm5hJzogMHhBMDUyMkQsICdzaWx2ZXInOiAweEMwQzBDMCwgJ3NreWJsdWUnOiAweDg3Q0VFQiwgJ3NsYXRlYmx1ZSc6IDB4NkE1QUNELCAnc2xhdGVncmF5JzogMHg3MDgwOTAsICdzbGF0ZWdyZXknOiAweDcwODA5MCwgJ3Nub3cnOiAweEZGRkFGQSxcXHJcXG5cXHRcXHQnc3ByaW5nZ3JlZW4nOiAweDAwRkY3RiwgJ3N0ZWVsYmx1ZSc6IDB4NDY4MkI0LCAndGFuJzogMHhEMkI0OEMsICd0ZWFsJzogMHgwMDgwODAsICd0aGlzdGxlJzogMHhEOEJGRDgsICd0b21hdG8nOiAweEZGNjM0NywgJ3R1cnF1b2lzZSc6IDB4NDBFMEQwLFxcclxcblxcdFxcdCd2aW9sZXQnOiAweEVFODJFRSwgJ3doZWF0JzogMHhGNURFQjMsICd3aGl0ZSc6IDB4RkZGRkZGLCAnd2hpdGVzbW9rZSc6IDB4RjVGNUY1LCAneWVsbG93JzogMHhGRkZGMDAsICd5ZWxsb3dncmVlbic6IDB4OUFDRDMyIH07XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gQ29sb3IoIHIsIGcsIGIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCBnID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdC8vIHIgaXMgVEhSRUUuQ29sb3IsIGhleCBvciBzdHJpbmdcXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5zZXQoIHIgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHRoaXMuc2V0UkdCKCByLCBnLCBiICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIENvbG9yLnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdGlzQ29sb3I6IHRydWUsXFxyXFxuXFxyXFxuXFx0XFx0cjogMSwgZzogMSwgYjogMSxcXHJcXG5cXHJcXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB2YWx1ZSAmJiB2YWx1ZS5pc0NvbG9yICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuY29weSggdmFsdWUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuc2V0SGV4KCB2YWx1ZSApO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5zZXRTdHlsZSggdmFsdWUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuciA9IHNjYWxhcjtcXHJcXG5cXHRcXHRcXHR0aGlzLmcgPSBzY2FsYXI7XFxyXFxuXFx0XFx0XFx0dGhpcy5iID0gc2NhbGFyO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0SGV4OiBmdW5jdGlvbiAoIGhleCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRoZXggPSBNYXRoLmZsb29yKCBoZXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnIgPSAoIGhleCA+PiAxNiAmIDI1NSApIC8gMjU1O1xcclxcblxcdFxcdFxcdHRoaXMuZyA9ICggaGV4ID4+IDggJiAyNTUgKSAvIDI1NTtcXHJcXG5cXHRcXHRcXHR0aGlzLmIgPSAoIGhleCAmIDI1NSApIC8gMjU1O1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0UkdCOiBmdW5jdGlvbiAoIHIsIGcsIGIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5yID0gcjtcXHJcXG5cXHRcXHRcXHR0aGlzLmcgPSBnO1xcclxcblxcdFxcdFxcdHRoaXMuYiA9IGI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRIU0w6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmdW5jdGlvbiBodWUycmdiKCBwLCBxLCB0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggdCA8IDAgKSB0ICs9IDE7XFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB0ID4gMSApIHQgLT0gMTtcXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHQgPCAxIC8gNiApIHJldHVybiBwICsgKCBxIC0gcCApICogNiAqIHQ7XFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB0IDwgMSAvIDIgKSByZXR1cm4gcTtcXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHQgPCAyIC8gMyApIHJldHVybiBwICsgKCBxIC0gcCApICogNiAqICggMiAvIDMgLSB0ICk7XFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBzZXRIU0woIGgsIHMsIGwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gaCxzLGwgcmFuZ2VzIGFyZSBpbiAwLjAgLSAxLjBcXHJcXG5cXHRcXHRcXHRcXHRoID0gX01hdGguZXVjbGlkZWFuTW9kdWxvKCBoLCAxICk7XFxyXFxuXFx0XFx0XFx0XFx0cyA9IF9NYXRoLmNsYW1wKCBzLCAwLCAxICk7XFxyXFxuXFx0XFx0XFx0XFx0bCA9IF9NYXRoLmNsYW1wKCBsLCAwLCAxICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBzID09PSAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMuciA9IHRoaXMuZyA9IHRoaXMuYiA9IGw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgcCA9IGwgPD0gMC41ID8gbCAqICggMSArIHMgKSA6IGwgKyBzIC0gKCBsICogcyApO1xcclxcblxcdFxcdFxcdFxcdFxcdHZhciBxID0gKCAyICogbCApIC0gcDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnIgPSBodWUycmdiKCBxLCBwLCBoICsgMSAvIDMgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmcgPSBodWUycmdiKCBxLCBwLCBoICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5iID0gaHVlMnJnYiggcSwgcCwgaCAtIDEgLyAzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdHNldFN0eWxlOiBmdW5jdGlvbiAoIHN0eWxlICkge1xcclxcblxcclxcblxcdFxcdFxcdGZ1bmN0aW9uIGhhbmRsZUFscGhhKCBzdHJpbmcgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBzdHJpbmcgPT09IHVuZGVmaW5lZCApIHJldHVybjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHBhcnNlRmxvYXQoIHN0cmluZyApIDwgMSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xvcjogQWxwaGEgY29tcG9uZW50IG9mICcgKyBzdHlsZSArICcgd2lsbCBiZSBpZ25vcmVkLicgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcclxcblxcdFxcdFxcdHZhciBtO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggbSA9IC9eKCg/OnJnYnxoc2wpYT8pXFxcXChcXFxccyooW15cXFxcKV0qKVxcXFwpLy5leGVjKCBzdHlsZSApICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIHJnYiAvIGhzbFxcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBjb2xvcjtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgbmFtZSA9IG1bIDEgXTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgY29tcG9uZW50cyA9IG1bIDIgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzd2l0Y2ggKCBuYW1lICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ3JnYic6XFxyXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAncmdiYSc6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBjb2xvciA9IC9eKFxcXFxkKylcXFxccyosXFxcXHMqKFxcXFxkKylcXFxccyosXFxcXHMqKFxcXFxkKylcXFxccyooLFxcXFxzKihbMC05XSpcXFxcLj9bMC05XSspXFxcXHMqKT8kLy5leGVjKCBjb21wb25lbnRzICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gcmdiKDI1NSwwLDApIHJnYmEoMjU1LDAsMCwwLjUpXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5yID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAxIF0sIDEwICkgKSAvIDI1NTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmcgPSBNYXRoLm1pbiggMjU1LCBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSApIC8gMjU1O1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuYiA9IE1hdGgubWluKCAyNTUsIHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApICkgLyAyNTU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aGFuZGxlQWxwaGEoIGNvbG9yWyA1IF0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBjb2xvciA9IC9eKFxcXFxkKylcXFxcJVxcXFxzKixcXFxccyooXFxcXGQrKVxcXFwlXFxcXHMqLFxcXFxzKihcXFxcZCspXFxcXCVcXFxccyooLFxcXFxzKihbMC05XSpcXFxcLj9bMC05XSspXFxcXHMqKT8kLy5leGVjKCBjb21wb25lbnRzICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gcmdiKDEwMCUsMCUsMCUpIHJnYmEoMTAwJSwwJSwwJSwwLjUpXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5yID0gTWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAxIF0sIDEwICkgKSAvIDEwMDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmcgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSApIC8gMTAwO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuYiA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApICkgLyAxMDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aGFuZGxlQWxwaGEoIGNvbG9yWyA1IF0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnaHNsJzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdoc2xhJzpcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGNvbG9yID0gL14oWzAtOV0qXFxcXC4/WzAtOV0rKVxcXFxzKixcXFxccyooXFxcXGQrKVxcXFwlXFxcXHMqLFxcXFxzKihcXFxcZCspXFxcXCVcXFxccyooLFxcXFxzKihbMC05XSpcXFxcLj9bMC05XSspXFxcXHMqKT8kLy5leGVjKCBjb21wb25lbnRzICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gaHNsKDEyMCw1MCUsNTAlKSBoc2xhKDEyMCw1MCUsNTAlLDAuNSlcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgaCA9IHBhcnNlRmxvYXQoIGNvbG9yWyAxIF0gKSAvIDM2MDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgcyA9IHBhcnNlSW50KCBjb2xvclsgMiBdLCAxMCApIC8gMTAwO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBsID0gcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgLyAxMDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aGFuZGxlQWxwaGEoIGNvbG9yWyA1IF0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5zZXRIU0woIGgsIHMsIGwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG0gPSAvXlxcXFwjKFtBLUZhLWYwLTldKykkLy5leGVjKCBzdHlsZSApICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGhleCBjb2xvclxcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBoZXggPSBtWyAxIF07XFxyXFxuXFx0XFx0XFx0XFx0dmFyIHNpemUgPSBoZXgubGVuZ3RoO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggc2l6ZSA9PT0gMyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyAjZmYwXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5yID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDAgKSArIGhleC5jaGFyQXQoIDAgKSwgMTYgKSAvIDI1NTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmcgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMSApICsgaGV4LmNoYXJBdCggMSApLCAxNiApIC8gMjU1O1xcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMuYiA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAyICkgKyBoZXguY2hhckF0KCAyICksIDE2ICkgLyAyNTU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggc2l6ZSA9PT0gNiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyAjZmYwMDAwXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5yID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDAgKSArIGhleC5jaGFyQXQoIDEgKSwgMTYgKSAvIDI1NTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmcgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMiApICsgaGV4LmNoYXJBdCggMyApLCAxNiApIC8gMjU1O1xcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMuYiA9IHBhcnNlSW50KCBoZXguY2hhckF0KCA0ICkgKyBoZXguY2hhckF0KCA1ICksIDE2ICkgLyAyNTU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHN0eWxlICYmIHN0eWxlLmxlbmd0aCA+IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gY29sb3Iga2V5d29yZHNcXHJcXG5cXHRcXHRcXHRcXHR2YXIgaGV4ID0gQ29sb3JLZXl3b3Jkc1sgc3R5bGUgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGhleCAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIHJlZFxcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2V0SGV4KCBoZXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIHVua25vd24gY29sb3JcXHJcXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xvcjogVW5rbm93biBjb2xvciAnICsgc3R5bGUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuciwgdGhpcy5nLCB0aGlzLmIgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggY29sb3IgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5yID0gY29sb3IucjtcXHJcXG5cXHRcXHRcXHR0aGlzLmcgPSBjb2xvci5nO1xcclxcblxcdFxcdFxcdHRoaXMuYiA9IGNvbG9yLmI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjb3B5R2FtbWFUb0xpbmVhcjogZnVuY3Rpb24gKCBjb2xvciwgZ2FtbWFGYWN0b3IgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBnYW1tYUZhY3RvciA9PT0gdW5kZWZpbmVkICkgZ2FtbWFGYWN0b3IgPSAyLjA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5yID0gTWF0aC5wb3coIGNvbG9yLnIsIGdhbW1hRmFjdG9yICk7XFxyXFxuXFx0XFx0XFx0dGhpcy5nID0gTWF0aC5wb3coIGNvbG9yLmcsIGdhbW1hRmFjdG9yICk7XFxyXFxuXFx0XFx0XFx0dGhpcy5iID0gTWF0aC5wb3coIGNvbG9yLmIsIGdhbW1hRmFjdG9yICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjb3B5TGluZWFyVG9HYW1tYTogZnVuY3Rpb24gKCBjb2xvciwgZ2FtbWFGYWN0b3IgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBnYW1tYUZhY3RvciA9PT0gdW5kZWZpbmVkICkgZ2FtbWFGYWN0b3IgPSAyLjA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHNhZmVJbnZlcnNlID0gKCBnYW1tYUZhY3RvciA+IDAgKSA/ICggMS4wIC8gZ2FtbWFGYWN0b3IgKSA6IDEuMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnIgPSBNYXRoLnBvdyggY29sb3Iuciwgc2FmZUludmVyc2UgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLmcgPSBNYXRoLnBvdyggY29sb3IuZywgc2FmZUludmVyc2UgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLmIgPSBNYXRoLnBvdyggY29sb3IuYiwgc2FmZUludmVyc2UgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNvbnZlcnRHYW1tYVRvTGluZWFyOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHIgPSB0aGlzLnIsIGcgPSB0aGlzLmcsIGIgPSB0aGlzLmI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5yID0gciAqIHI7XFxyXFxuXFx0XFx0XFx0dGhpcy5nID0gZyAqIGc7XFxyXFxuXFx0XFx0XFx0dGhpcy5iID0gYiAqIGI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjb252ZXJ0TGluZWFyVG9HYW1tYTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuciA9IE1hdGguc3FydCggdGhpcy5yICk7XFxyXFxuXFx0XFx0XFx0dGhpcy5nID0gTWF0aC5zcXJ0KCB0aGlzLmcgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLmIgPSBNYXRoLnNxcnQoIHRoaXMuYiApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Z2V0SGV4OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuICggdGhpcy5yICogMjU1ICkgPDwgMTYgXiAoIHRoaXMuZyAqIDI1NSApIDw8IDggXiAoIHRoaXMuYiAqIDI1NSApIDw8IDA7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRnZXRIZXhTdHJpbmc6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gKCAnMDAwMDAwJyArIHRoaXMuZ2V0SGV4KCkudG9TdHJpbmcoIDE2ICkgKS5zbGljZSggLSA2ICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRnZXRIU0w6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gaCxzLGwgcmFuZ2VzIGFyZSBpbiAwLjAgLSAxLjBcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgaHNsID0gb3B0aW9uYWxUYXJnZXQgfHwgeyBoOiAwLCBzOiAwLCBsOiAwIH07XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHIgPSB0aGlzLnIsIGcgPSB0aGlzLmcsIGIgPSB0aGlzLmI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG1heCA9IE1hdGgubWF4KCByLCBnLCBiICk7XFxyXFxuXFx0XFx0XFx0dmFyIG1pbiA9IE1hdGgubWluKCByLCBnLCBiICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGh1ZSwgc2F0dXJhdGlvbjtcXHJcXG5cXHRcXHRcXHR2YXIgbGlnaHRuZXNzID0gKCBtaW4gKyBtYXggKSAvIDIuMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIG1pbiA9PT0gbWF4ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGh1ZSA9IDA7XFxyXFxuXFx0XFx0XFx0XFx0c2F0dXJhdGlvbiA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgZGVsdGEgPSBtYXggLSBtaW47XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0c2F0dXJhdGlvbiA9IGxpZ2h0bmVzcyA8PSAwLjUgPyBkZWx0YSAvICggbWF4ICsgbWluICkgOiBkZWx0YSAvICggMiAtIG1heCAtIG1pbiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHN3aXRjaCAoIG1heCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRjYXNlIHI6IGh1ZSA9ICggZyAtIGIgKSAvIGRlbHRhICsgKCBnIDwgYiA/IDYgOiAwICk7IGJyZWFrO1xcclxcblxcdFxcdFxcdFxcdFxcdGNhc2UgZzogaHVlID0gKCBiIC0gciApIC8gZGVsdGEgKyAyOyBicmVhaztcXHJcXG5cXHRcXHRcXHRcXHRcXHRjYXNlIGI6IGh1ZSA9ICggciAtIGcgKSAvIGRlbHRhICsgNDsgYnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdGh1ZSAvPSA2O1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRoc2wuaCA9IGh1ZTtcXHJcXG5cXHRcXHRcXHRoc2wucyA9IHNhdHVyYXRpb247XFxyXFxuXFx0XFx0XFx0aHNsLmwgPSBsaWdodG5lc3M7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGhzbDtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGdldFN0eWxlOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuICdyZ2IoJyArICggKCB0aGlzLnIgKiAyNTUgKSB8IDAgKSArICcsJyArICggKCB0aGlzLmcgKiAyNTUgKSB8IDAgKSArICcsJyArICggKCB0aGlzLmIgKiAyNTUgKSB8IDAgKSArICcpJztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdG9mZnNldEhTTDogZnVuY3Rpb24gKCBoLCBzLCBsICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBoc2wgPSB0aGlzLmdldEhTTCgpO1xcclxcblxcclxcblxcdFxcdFxcdGhzbC5oICs9IGg7IGhzbC5zICs9IHM7IGhzbC5sICs9IGw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5zZXRIU0woIGhzbC5oLCBoc2wucywgaHNsLmwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGFkZDogZnVuY3Rpb24gKCBjb2xvciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnIgKz0gY29sb3IucjtcXHJcXG5cXHRcXHRcXHR0aGlzLmcgKz0gY29sb3IuZztcXHJcXG5cXHRcXHRcXHR0aGlzLmIgKz0gY29sb3IuYjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGFkZENvbG9yczogZnVuY3Rpb24gKCBjb2xvcjEsIGNvbG9yMiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnIgPSBjb2xvcjEuciArIGNvbG9yMi5yO1xcclxcblxcdFxcdFxcdHRoaXMuZyA9IGNvbG9yMS5nICsgY29sb3IyLmc7XFxyXFxuXFx0XFx0XFx0dGhpcy5iID0gY29sb3IxLmIgKyBjb2xvcjIuYjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuciArPSBzO1xcclxcblxcdFxcdFxcdHRoaXMuZyArPSBzO1xcclxcblxcdFxcdFxcdHRoaXMuYiArPSBzO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c3ViOiBmdW5jdGlvbiAoIGNvbG9yICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuciA9IE1hdGgubWF4KCAwLCB0aGlzLnIgLSBjb2xvci5yICk7XFxyXFxuXFx0XFx0XFx0dGhpcy5nID0gTWF0aC5tYXgoIDAsIHRoaXMuZyAtIGNvbG9yLmcgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLmIgPSBNYXRoLm1heCggMCwgdGhpcy5iIC0gY29sb3IuYiApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0bXVsdGlwbHk6IGZ1bmN0aW9uICggY29sb3IgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5yICo9IGNvbG9yLnI7XFxyXFxuXFx0XFx0XFx0dGhpcy5nICo9IGNvbG9yLmc7XFxyXFxuXFx0XFx0XFx0dGhpcy5iICo9IGNvbG9yLmI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuciAqPSBzO1xcclxcblxcdFxcdFxcdHRoaXMuZyAqPSBzO1xcclxcblxcdFxcdFxcdHRoaXMuYiAqPSBzO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0bGVycDogZnVuY3Rpb24gKCBjb2xvciwgYWxwaGEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5yICs9ICggY29sb3IuciAtIHRoaXMuciApICogYWxwaGE7XFxyXFxuXFx0XFx0XFx0dGhpcy5nICs9ICggY29sb3IuZyAtIHRoaXMuZyApICogYWxwaGE7XFxyXFxuXFx0XFx0XFx0dGhpcy5iICs9ICggY29sb3IuYiAtIHRoaXMuYiApICogYWxwaGE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRlcXVhbHM6IGZ1bmN0aW9uICggYyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gKCBjLnIgPT09IHRoaXMuciApICYmICggYy5nID09PSB0aGlzLmcgKSAmJiAoIGMuYiA9PT0gdGhpcy5iICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnIgPSBhcnJheVsgb2Zmc2V0IF07XFxyXFxuXFx0XFx0XFx0dGhpcy5nID0gYXJyYXlbIG9mZnNldCArIDEgXTtcXHJcXG5cXHRcXHRcXHR0aGlzLmIgPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XFxyXFxuXFx0XFx0XFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5yO1xcclxcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLmc7XFxyXFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuYjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gYXJyYXk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHR0b0pTT046IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5nZXRIZXgoKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIFVuaWZvcm1zIGxpYnJhcnkgZm9yIHNoYXJlZCB3ZWJnbCBzaGFkZXJzXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0dmFyIFVuaWZvcm1zTGliID0ge1xcclxcblxcclxcblxcdFxcdGNvbW1vbjoge1xcclxcblxcclxcblxcdFxcdFxcdGRpZmZ1c2U6IHsgdmFsdWU6IG5ldyBDb2xvciggMHhlZWVlZWUgKSB9LFxcclxcblxcdFxcdFxcdG9wYWNpdHk6IHsgdmFsdWU6IDEuMCB9LFxcclxcblxcclxcblxcdFxcdFxcdG1hcDogeyB2YWx1ZTogbnVsbCB9LFxcclxcblxcdFxcdFxcdHV2VHJhbnNmb3JtOiB7IHZhbHVlOiBuZXcgTWF0cml4MygpIH0sXFxyXFxuXFxyXFxuXFx0XFx0XFx0YWxwaGFNYXA6IHsgdmFsdWU6IG51bGwgfSxcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNwZWN1bGFybWFwOiB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0c3BlY3VsYXJNYXA6IHsgdmFsdWU6IG51bGwgfSxcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGVudm1hcDoge1xcclxcblxcclxcblxcdFxcdFxcdGVudk1hcDogeyB2YWx1ZTogbnVsbCB9LFxcclxcblxcdFxcdFxcdGZsaXBFbnZNYXA6IHsgdmFsdWU6IC0gMSB9LFxcclxcblxcdFxcdFxcdHJlZmxlY3Rpdml0eTogeyB2YWx1ZTogMS4wIH0sXFxyXFxuXFx0XFx0XFx0cmVmcmFjdGlvblJhdGlvOiB7IHZhbHVlOiAwLjk4IH1cXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGFvbWFwOiB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0YW9NYXA6IHsgdmFsdWU6IG51bGwgfSxcXHJcXG5cXHRcXHRcXHRhb01hcEludGVuc2l0eTogeyB2YWx1ZTogMSB9XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRsaWdodG1hcDoge1xcclxcblxcclxcblxcdFxcdFxcdGxpZ2h0TWFwOiB7IHZhbHVlOiBudWxsIH0sXFxyXFxuXFx0XFx0XFx0bGlnaHRNYXBJbnRlbnNpdHk6IHsgdmFsdWU6IDEgfVxcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0ZW1pc3NpdmVtYXA6IHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRlbWlzc2l2ZU1hcDogeyB2YWx1ZTogbnVsbCB9XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRidW1wbWFwOiB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0YnVtcE1hcDogeyB2YWx1ZTogbnVsbCB9LFxcclxcblxcdFxcdFxcdGJ1bXBTY2FsZTogeyB2YWx1ZTogMSB9XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRub3JtYWxtYXA6IHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRub3JtYWxNYXA6IHsgdmFsdWU6IG51bGwgfSxcXHJcXG5cXHRcXHRcXHRub3JtYWxTY2FsZTogeyB2YWx1ZTogbmV3IFZlY3RvcjIoIDEsIDEgKSB9XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRkaXNwbGFjZW1lbnRtYXA6IHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRkaXNwbGFjZW1lbnRNYXA6IHsgdmFsdWU6IG51bGwgfSxcXHJcXG5cXHRcXHRcXHRkaXNwbGFjZW1lbnRTY2FsZTogeyB2YWx1ZTogMSB9LFxcclxcblxcdFxcdFxcdGRpc3BsYWNlbWVudEJpYXM6IHsgdmFsdWU6IDAgfVxcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0cm91Z2huZXNzbWFwOiB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cm91Z2huZXNzTWFwOiB7IHZhbHVlOiBudWxsIH1cXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdG1ldGFsbmVzc21hcDoge1xcclxcblxcclxcblxcdFxcdFxcdG1ldGFsbmVzc01hcDogeyB2YWx1ZTogbnVsbCB9XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRncmFkaWVudG1hcDoge1xcclxcblxcclxcblxcdFxcdFxcdGdyYWRpZW50TWFwOiB7IHZhbHVlOiBudWxsIH1cXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGZvZzoge1xcclxcblxcclxcblxcdFxcdFxcdGZvZ0RlbnNpdHk6IHsgdmFsdWU6IDAuMDAwMjUgfSxcXHJcXG5cXHRcXHRcXHRmb2dOZWFyOiB7IHZhbHVlOiAxIH0sXFxyXFxuXFx0XFx0XFx0Zm9nRmFyOiB7IHZhbHVlOiAyMDAwIH0sXFxyXFxuXFx0XFx0XFx0Zm9nQ29sb3I6IHsgdmFsdWU6IG5ldyBDb2xvciggMHhmZmZmZmYgKSB9XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRsaWdodHM6IHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRhbWJpZW50TGlnaHRDb2xvcjogeyB2YWx1ZTogW10gfSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRkaXJlY3Rpb25hbExpZ2h0czogeyB2YWx1ZTogW10sIHByb3BlcnRpZXM6IHtcXHJcXG5cXHRcXHRcXHRcXHRkaXJlY3Rpb246IHt9LFxcclxcblxcdFxcdFxcdFxcdGNvbG9yOiB7fSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzaGFkb3c6IHt9LFxcclxcblxcdFxcdFxcdFxcdHNoYWRvd0JpYXM6IHt9LFxcclxcblxcdFxcdFxcdFxcdHNoYWRvd1JhZGl1czoge30sXFxyXFxuXFx0XFx0XFx0XFx0c2hhZG93TWFwU2l6ZToge31cXHJcXG5cXHRcXHRcXHR9IH0sXFxyXFxuXFxyXFxuXFx0XFx0XFx0ZGlyZWN0aW9uYWxTaGFkb3dNYXA6IHsgdmFsdWU6IFtdIH0sXFxyXFxuXFx0XFx0XFx0ZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXg6IHsgdmFsdWU6IFtdIH0sXFxyXFxuXFxyXFxuXFx0XFx0XFx0c3BvdExpZ2h0czogeyB2YWx1ZTogW10sIHByb3BlcnRpZXM6IHtcXHJcXG5cXHRcXHRcXHRcXHRjb2xvcjoge30sXFxyXFxuXFx0XFx0XFx0XFx0cG9zaXRpb246IHt9LFxcclxcblxcdFxcdFxcdFxcdGRpcmVjdGlvbjoge30sXFxyXFxuXFx0XFx0XFx0XFx0ZGlzdGFuY2U6IHt9LFxcclxcblxcdFxcdFxcdFxcdGNvbmVDb3M6IHt9LFxcclxcblxcdFxcdFxcdFxcdHBlbnVtYnJhQ29zOiB7fSxcXHJcXG5cXHRcXHRcXHRcXHRkZWNheToge30sXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0c2hhZG93OiB7fSxcXHJcXG5cXHRcXHRcXHRcXHRzaGFkb3dCaWFzOiB7fSxcXHJcXG5cXHRcXHRcXHRcXHRzaGFkb3dSYWRpdXM6IHt9LFxcclxcblxcdFxcdFxcdFxcdHNoYWRvd01hcFNpemU6IHt9XFxyXFxuXFx0XFx0XFx0fSB9LFxcclxcblxcclxcblxcdFxcdFxcdHNwb3RTaGFkb3dNYXA6IHsgdmFsdWU6IFtdIH0sXFxyXFxuXFx0XFx0XFx0c3BvdFNoYWRvd01hdHJpeDogeyB2YWx1ZTogW10gfSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRwb2ludExpZ2h0czogeyB2YWx1ZTogW10sIHByb3BlcnRpZXM6IHtcXHJcXG5cXHRcXHRcXHRcXHRjb2xvcjoge30sXFxyXFxuXFx0XFx0XFx0XFx0cG9zaXRpb246IHt9LFxcclxcblxcdFxcdFxcdFxcdGRlY2F5OiB7fSxcXHJcXG5cXHRcXHRcXHRcXHRkaXN0YW5jZToge30sXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0c2hhZG93OiB7fSxcXHJcXG5cXHRcXHRcXHRcXHRzaGFkb3dCaWFzOiB7fSxcXHJcXG5cXHRcXHRcXHRcXHRzaGFkb3dSYWRpdXM6IHt9LFxcclxcblxcdFxcdFxcdFxcdHNoYWRvd01hcFNpemU6IHt9LFxcclxcblxcdFxcdFxcdFxcdHNoYWRvd0NhbWVyYU5lYXI6IHt9LFxcclxcblxcdFxcdFxcdFxcdHNoYWRvd0NhbWVyYUZhcjoge31cXHJcXG5cXHRcXHRcXHR9IH0sXFxyXFxuXFxyXFxuXFx0XFx0XFx0cG9pbnRTaGFkb3dNYXA6IHsgdmFsdWU6IFtdIH0sXFxyXFxuXFx0XFx0XFx0cG9pbnRTaGFkb3dNYXRyaXg6IHsgdmFsdWU6IFtdIH0sXFxyXFxuXFxyXFxuXFx0XFx0XFx0aGVtaXNwaGVyZUxpZ2h0czogeyB2YWx1ZTogW10sIHByb3BlcnRpZXM6IHtcXHJcXG5cXHRcXHRcXHRcXHRkaXJlY3Rpb246IHt9LFxcclxcblxcdFxcdFxcdFxcdHNreUNvbG9yOiB7fSxcXHJcXG5cXHRcXHRcXHRcXHRncm91bmRDb2xvcjoge31cXHJcXG5cXHRcXHRcXHR9IH0sXFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gVE9ETyAoYWJlbG5hdGlvbik6IFJlY3RBcmVhTGlnaHQgQlJERiBkYXRhIG5lZWRzIHRvIGJlIG1vdmVkIGZyb20gZXhhbXBsZSB0byBtYWluIHNyY1xcclxcblxcdFxcdFxcdHJlY3RBcmVhTGlnaHRzOiB7IHZhbHVlOiBbXSwgcHJvcGVydGllczoge1xcclxcblxcdFxcdFxcdFxcdGNvbG9yOiB7fSxcXHJcXG5cXHRcXHRcXHRcXHRwb3NpdGlvbjoge30sXFxyXFxuXFx0XFx0XFx0XFx0d2lkdGg6IHt9LFxcclxcblxcdFxcdFxcdFxcdGhlaWdodDoge31cXHJcXG5cXHRcXHRcXHR9IH1cXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHBvaW50czoge1xcclxcblxcclxcblxcdFxcdFxcdGRpZmZ1c2U6IHsgdmFsdWU6IG5ldyBDb2xvciggMHhlZWVlZWUgKSB9LFxcclxcblxcdFxcdFxcdG9wYWNpdHk6IHsgdmFsdWU6IDEuMCB9LFxcclxcblxcdFxcdFxcdHNpemU6IHsgdmFsdWU6IDEuMCB9LFxcclxcblxcdFxcdFxcdHNjYWxlOiB7IHZhbHVlOiAxLjAgfSxcXHJcXG5cXHRcXHRcXHRtYXA6IHsgdmFsdWU6IG51bGwgfSxcXHJcXG5cXHRcXHRcXHR1dlRyYW5zZm9ybTogeyB2YWx1ZTogbmV3IE1hdHJpeDMoKSB9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogVW5pZm9ybSBVdGlsaXRpZXNcXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHR2YXIgVW5pZm9ybXNVdGlscyA9IHtcXHJcXG5cXHJcXG5cXHRcXHRtZXJnZTogZnVuY3Rpb24gKCB1bmlmb3JtcyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbWVyZ2VkID0ge307XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIHUgPSAwOyB1IDwgdW5pZm9ybXMubGVuZ3RoOyB1ICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciB0bXAgPSB0aGlzLmNsb25lKCB1bmlmb3Jtc1sgdSBdICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIHAgaW4gdG1wICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdG1lcmdlZFsgcCBdID0gdG1wWyBwIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gbWVyZ2VkO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICggdW5pZm9ybXNfc3JjICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB1bmlmb3Jtc19kc3QgPSB7fTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgdSBpbiB1bmlmb3Jtc19zcmMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXNfZHN0WyB1IF0gPSB7fTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgcCBpbiB1bmlmb3Jtc19zcmNbIHUgXSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgcGFyYW1ldGVyX3NyYyA9IHVuaWZvcm1zX3NyY1sgdSBdWyBwIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBwYXJhbWV0ZXJfc3JjICYmICggcGFyYW1ldGVyX3NyYy5pc0NvbG9yIHx8XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0cGFyYW1ldGVyX3NyYy5pc01hdHJpeDMgfHwgcGFyYW1ldGVyX3NyYy5pc01hdHJpeDQgfHxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRwYXJhbWV0ZXJfc3JjLmlzVmVjdG9yMiB8fCBwYXJhbWV0ZXJfc3JjLmlzVmVjdG9yMyB8fCBwYXJhbWV0ZXJfc3JjLmlzVmVjdG9yNCB8fFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHBhcmFtZXRlcl9zcmMuaXNUZXh0dXJlICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dW5pZm9ybXNfZHN0WyB1IF1bIHAgXSA9IHBhcmFtZXRlcl9zcmMuY2xvbmUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCBwYXJhbWV0ZXJfc3JjICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dW5pZm9ybXNfZHN0WyB1IF1bIHAgXSA9IHBhcmFtZXRlcl9zcmMuc2xpY2UoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zX2RzdFsgdSBdWyBwIF0gPSBwYXJhbWV0ZXJfc3JjO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB1bmlmb3Jtc19kc3Q7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0dmFyIGFscGhhbWFwX2ZyYWdtZW50ID0gXFxcIiNpZmRlZiBVU0VfQUxQSEFNQVBcXFxcblxcXFx0ZGlmZnVzZUNvbG9yLmEgKj0gdGV4dHVyZTJEKCBhbHBoYU1hcCwgdlV2ICkuZztcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgYWxwaGFtYXBfcGFyc19mcmFnbWVudCA9IFxcXCIjaWZkZWYgVVNFX0FMUEhBTUFQXFxcXG5cXFxcdHVuaWZvcm0gc2FtcGxlcjJEIGFscGhhTWFwO1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBhbHBoYXRlc3RfZnJhZ21lbnQgPSBcXFwiI2lmZGVmIEFMUEhBVEVTVFxcXFxuXFxcXHRpZiAoIGRpZmZ1c2VDb2xvci5hIDwgQUxQSEFURVNUICkgZGlzY2FyZDtcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgYW9tYXBfZnJhZ21lbnQgPSBcXFwiI2lmZGVmIFVTRV9BT01BUFxcXFxuXFxcXHRmbG9hdCBhbWJpZW50T2NjbHVzaW9uID0gKCB0ZXh0dXJlMkQoIGFvTWFwLCB2VXYyICkuciAtIDEuMCApICogYW9NYXBJbnRlbnNpdHkgKyAxLjA7XFxcXG5cXFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSAqPSBhbWJpZW50T2NjbHVzaW9uO1xcXFxuXFxcXHQjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFBIWVNJQ0FMIClcXFxcblxcXFx0XFxcXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZ2VvbWV0cnkudmlld0RpciApICk7XFxcXG5cXFxcdFxcXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciAqPSBjb21wdXRlU3BlY3VsYXJPY2NsdXNpb24oIGRvdE5WLCBhbWJpZW50T2NjbHVzaW9uLCBtYXRlcmlhbC5zcGVjdWxhclJvdWdobmVzcyApO1xcXFxuXFxcXHQjZW5kaWZcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgYW9tYXBfcGFyc19mcmFnbWVudCA9IFxcXCIjaWZkZWYgVVNFX0FPTUFQXFxcXG5cXFxcdHVuaWZvcm0gc2FtcGxlcjJEIGFvTWFwO1xcXFxuXFxcXHR1bmlmb3JtIGZsb2F0IGFvTWFwSW50ZW5zaXR5O1xcXFxuI2VuZGlmXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgYmVnaW5fdmVydGV4ID0gXFxcIlxcXFxudmVjMyB0cmFuc2Zvcm1lZCA9IHZlYzMoIHBvc2l0aW9uICk7XFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBiZWdpbm5vcm1hbF92ZXJ0ZXggPSBcXFwiXFxcXG52ZWMzIG9iamVjdE5vcm1hbCA9IHZlYzMoIG5vcm1hbCApO1xcXFxuXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgYnNkZnMgPSBcXFwiZmxvYXQgcHVuY3R1YWxMaWdodEludGVuc2l0eVRvSXJyYWRpYW5jZUZhY3RvciggY29uc3QgaW4gZmxvYXQgbGlnaHREaXN0YW5jZSwgY29uc3QgaW4gZmxvYXQgY3V0b2ZmRGlzdGFuY2UsIGNvbnN0IGluIGZsb2F0IGRlY2F5RXhwb25lbnQgKSB7XFxcXG5cXFxcdGlmKCBkZWNheUV4cG9uZW50ID4gMC4wICkge1xcXFxuI2lmIGRlZmluZWQgKCBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTIClcXFxcblxcXFx0XFxcXHRmbG9hdCBkaXN0YW5jZUZhbGxvZmYgPSAxLjAgLyBtYXgoIHBvdyggbGlnaHREaXN0YW5jZSwgZGVjYXlFeHBvbmVudCApLCAwLjAxICk7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgbWF4RGlzdGFuY2VDdXRvZmZGYWN0b3IgPSBwb3cyKCBzYXR1cmF0ZSggMS4wIC0gcG93NCggbGlnaHREaXN0YW5jZSAvIGN1dG9mZkRpc3RhbmNlICkgKSApO1xcXFxuXFxcXHRcXFxcdHJldHVybiBkaXN0YW5jZUZhbGxvZmYgKiBtYXhEaXN0YW5jZUN1dG9mZkZhY3RvcjtcXFxcbiNlbHNlXFxcXG5cXFxcdFxcXFx0cmV0dXJuIHBvdyggc2F0dXJhdGUoIC1saWdodERpc3RhbmNlIC8gY3V0b2ZmRGlzdGFuY2UgKyAxLjAgKSwgZGVjYXlFeHBvbmVudCApO1xcXFxuI2VuZGlmXFxcXG5cXFxcdH1cXFxcblxcXFx0cmV0dXJuIDEuMDtcXFxcbn1cXFxcbnZlYzMgQlJERl9EaWZmdXNlX0xhbWJlcnQoIGNvbnN0IGluIHZlYzMgZGlmZnVzZUNvbG9yICkge1xcXFxuXFxcXHRyZXR1cm4gUkVDSVBST0NBTF9QSSAqIGRpZmZ1c2VDb2xvcjtcXFxcbn1cXFxcbnZlYzMgRl9TY2hsaWNrKCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IGRvdExIICkge1xcXFxuXFxcXHRmbG9hdCBmcmVzbmVsID0gZXhwMiggKCAtNS41NTQ3MyAqIGRvdExIIC0gNi45ODMxNiApICogZG90TEggKTtcXFxcblxcXFx0cmV0dXJuICggMS4wIC0gc3BlY3VsYXJDb2xvciApICogZnJlc25lbCArIHNwZWN1bGFyQ29sb3I7XFxcXG59XFxcXG5mbG9hdCBHX0dHWF9TbWl0aCggY29uc3QgaW4gZmxvYXQgYWxwaGEsIGNvbnN0IGluIGZsb2F0IGRvdE5MLCBjb25zdCBpbiBmbG9hdCBkb3ROViApIHtcXFxcblxcXFx0ZmxvYXQgYTIgPSBwb3cyKCBhbHBoYSApO1xcXFxuXFxcXHRmbG9hdCBnbCA9IGRvdE5MICsgc3FydCggYTIgKyAoIDEuMCAtIGEyICkgKiBwb3cyKCBkb3ROTCApICk7XFxcXG5cXFxcdGZsb2F0IGd2ID0gZG90TlYgKyBzcXJ0KCBhMiArICggMS4wIC0gYTIgKSAqIHBvdzIoIGRvdE5WICkgKTtcXFxcblxcXFx0cmV0dXJuIDEuMCAvICggZ2wgKiBndiApO1xcXFxufVxcXFxuZmxvYXQgR19HR1hfU21pdGhDb3JyZWxhdGVkKCBjb25zdCBpbiBmbG9hdCBhbHBoYSwgY29uc3QgaW4gZmxvYXQgZG90TkwsIGNvbnN0IGluIGZsb2F0IGRvdE5WICkge1xcXFxuXFxcXHRmbG9hdCBhMiA9IHBvdzIoIGFscGhhICk7XFxcXG5cXFxcdGZsb2F0IGd2ID0gZG90TkwgKiBzcXJ0KCBhMiArICggMS4wIC0gYTIgKSAqIHBvdzIoIGRvdE5WICkgKTtcXFxcblxcXFx0ZmxvYXQgZ2wgPSBkb3ROViAqIHNxcnQoIGEyICsgKCAxLjAgLSBhMiApICogcG93MiggZG90TkwgKSApO1xcXFxuXFxcXHRyZXR1cm4gMC41IC8gbWF4KCBndiArIGdsLCBFUFNJTE9OICk7XFxcXG59XFxcXG5mbG9hdCBEX0dHWCggY29uc3QgaW4gZmxvYXQgYWxwaGEsIGNvbnN0IGluIGZsb2F0IGRvdE5IICkge1xcXFxuXFxcXHRmbG9hdCBhMiA9IHBvdzIoIGFscGhhICk7XFxcXG5cXFxcdGZsb2F0IGRlbm9tID0gcG93MiggZG90TkggKSAqICggYTIgLSAxLjAgKSArIDEuMDtcXFxcblxcXFx0cmV0dXJuIFJFQ0lQUk9DQUxfUEkgKiBhMiAvIHBvdzIoIGRlbm9tICk7XFxcXG59XFxcXG52ZWMzIEJSREZfU3BlY3VsYXJfR0dYKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGluY2lkZW50TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIHZlYzMgc3BlY3VsYXJDb2xvciwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xcXFxuXFxcXHRmbG9hdCBhbHBoYSA9IHBvdzIoIHJvdWdobmVzcyApO1xcXFxuXFxcXHR2ZWMzIGhhbGZEaXIgPSBub3JtYWxpemUoIGluY2lkZW50TGlnaHQuZGlyZWN0aW9uICsgZ2VvbWV0cnkudmlld0RpciApO1xcXFxuXFxcXHRmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgaW5jaWRlbnRMaWdodC5kaXJlY3Rpb24gKSApO1xcXFxuXFxcXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZ2VvbWV0cnkudmlld0RpciApICk7XFxcXG5cXFxcdGZsb2F0IGRvdE5IID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBoYWxmRGlyICkgKTtcXFxcblxcXFx0ZmxvYXQgZG90TEggPSBzYXR1cmF0ZSggZG90KCBpbmNpZGVudExpZ2h0LmRpcmVjdGlvbiwgaGFsZkRpciApICk7XFxcXG5cXFxcdHZlYzMgRiA9IEZfU2NobGljayggc3BlY3VsYXJDb2xvciwgZG90TEggKTtcXFxcblxcXFx0ZmxvYXQgRyA9IEdfR0dYX1NtaXRoQ29ycmVsYXRlZCggYWxwaGEsIGRvdE5MLCBkb3ROViApO1xcXFxuXFxcXHRmbG9hdCBEID0gRF9HR1goIGFscGhhLCBkb3ROSCApO1xcXFxuXFxcXHRyZXR1cm4gRiAqICggRyAqIEQgKTtcXFxcbn1cXFxcbnZlYzIgTFRDX1V2KCBjb25zdCBpbiB2ZWMzIE4sIGNvbnN0IGluIHZlYzMgViwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xcXFxuXFxcXHRjb25zdCBmbG9hdCBMVVRfU0laRSAgPSA2NC4wO1xcXFxuXFxcXHRjb25zdCBmbG9hdCBMVVRfU0NBTEUgPSAoIExVVF9TSVpFIC0gMS4wICkgLyBMVVRfU0laRTtcXFxcblxcXFx0Y29uc3QgZmxvYXQgTFVUX0JJQVMgID0gMC41IC8gTFVUX1NJWkU7XFxcXG5cXFxcdGZsb2F0IHRoZXRhID0gYWNvcyggZG90KCBOLCBWICkgKTtcXFxcblxcXFx0dmVjMiB1diA9IHZlYzIoXFxcXG5cXFxcdFxcXFx0c3FydCggc2F0dXJhdGUoIHJvdWdobmVzcyApICksXFxcXG5cXFxcdFxcXFx0c2F0dXJhdGUoIHRoZXRhIC8gKCAwLjUgKiBQSSApICkgKTtcXFxcblxcXFx0dXYgPSB1diAqIExVVF9TQ0FMRSArIExVVF9CSUFTO1xcXFxuXFxcXHRyZXR1cm4gdXY7XFxcXG59XFxcXG5mbG9hdCBMVENfQ2xpcHBlZFNwaGVyZUZvcm1GYWN0b3IoIGNvbnN0IGluIHZlYzMgZiApIHtcXFxcblxcXFx0ZmxvYXQgbCA9IGxlbmd0aCggZiApO1xcXFxuXFxcXHRyZXR1cm4gbWF4KCAoIGwgKiBsICsgZi56ICkgLyAoIGwgKyAxLjAgKSwgMC4wICk7XFxcXG59XFxcXG52ZWMzIExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggY29uc3QgaW4gdmVjMyB2MSwgY29uc3QgaW4gdmVjMyB2MiApIHtcXFxcblxcXFx0ZmxvYXQgeCA9IGRvdCggdjEsIHYyICk7XFxcXG5cXFxcdGZsb2F0IHkgPSBhYnMoIHggKTtcXFxcblxcXFx0ZmxvYXQgYSA9IDAuODYyNjcgKyAoMC40OTc4OCArIDAuMDE0MzYgKiB5ICkgKiB5O1xcXFxuXFxcXHRmbG9hdCBiID0gMy40NTA2OCArICg0LjE4ODE0ICsgeSkgKiB5O1xcXFxuXFxcXHRmbG9hdCB2ID0gYSAvIGI7XFxcXG5cXFxcdGZsb2F0IHRoZXRhX3NpbnRoZXRhID0gKHggPiAwLjApID8gdiA6IDAuNSAqIGludmVyc2VzcXJ0KCAxLjAgLSB4ICogeCApIC0gdjtcXFxcblxcXFx0cmV0dXJuIGNyb3NzKCB2MSwgdjIgKSAqIHRoZXRhX3NpbnRoZXRhO1xcXFxufVxcXFxudmVjMyBMVENfRXZhbHVhdGUoIGNvbnN0IGluIHZlYzMgTiwgY29uc3QgaW4gdmVjMyBWLCBjb25zdCBpbiB2ZWMzIFAsIGNvbnN0IGluIG1hdDMgbUludiwgY29uc3QgaW4gdmVjMyByZWN0Q29vcmRzWyA0IF0gKSB7XFxcXG5cXFxcdHZlYzMgdjEgPSByZWN0Q29vcmRzWyAxIF0gLSByZWN0Q29vcmRzWyAwIF07XFxcXG5cXFxcdHZlYzMgdjIgPSByZWN0Q29vcmRzWyAzIF0gLSByZWN0Q29vcmRzWyAwIF07XFxcXG5cXFxcdHZlYzMgbGlnaHROb3JtYWwgPSBjcm9zcyggdjEsIHYyICk7XFxcXG5cXFxcdGlmKCBkb3QoIGxpZ2h0Tm9ybWFsLCBQIC0gcmVjdENvb3Jkc1sgMCBdICkgPCAwLjAgKSByZXR1cm4gdmVjMyggMC4wICk7XFxcXG5cXFxcdHZlYzMgVDEsIFQyO1xcXFxuXFxcXHRUMSA9IG5vcm1hbGl6ZSggViAtIE4gKiBkb3QoIFYsIE4gKSApO1xcXFxuXFxcXHRUMiA9IC0gY3Jvc3MoIE4sIFQxICk7XFxcXG5cXFxcdG1hdDMgbWF0ID0gbUludiAqIHRyYW5zcG9zZU1hdDMoIG1hdDMoIFQxLCBUMiwgTiApICk7XFxcXG5cXFxcdHZlYzMgY29vcmRzWyA0IF07XFxcXG5cXFxcdGNvb3Jkc1sgMCBdID0gbWF0ICogKCByZWN0Q29vcmRzWyAwIF0gLSBQICk7XFxcXG5cXFxcdGNvb3Jkc1sgMSBdID0gbWF0ICogKCByZWN0Q29vcmRzWyAxIF0gLSBQICk7XFxcXG5cXFxcdGNvb3Jkc1sgMiBdID0gbWF0ICogKCByZWN0Q29vcmRzWyAyIF0gLSBQICk7XFxcXG5cXFxcdGNvb3Jkc1sgMyBdID0gbWF0ICogKCByZWN0Q29vcmRzWyAzIF0gLSBQICk7XFxcXG5cXFxcdGNvb3Jkc1sgMCBdID0gbm9ybWFsaXplKCBjb29yZHNbIDAgXSApO1xcXFxuXFxcXHRjb29yZHNbIDEgXSA9IG5vcm1hbGl6ZSggY29vcmRzWyAxIF0gKTtcXFxcblxcXFx0Y29vcmRzWyAyIF0gPSBub3JtYWxpemUoIGNvb3Jkc1sgMiBdICk7XFxcXG5cXFxcdGNvb3Jkc1sgMyBdID0gbm9ybWFsaXplKCBjb29yZHNbIDMgXSApO1xcXFxuXFxcXHR2ZWMzIHZlY3RvckZvcm1GYWN0b3IgPSB2ZWMzKCAwLjAgKTtcXFxcblxcXFx0dmVjdG9yRm9ybUZhY3RvciArPSBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvb3Jkc1sgMCBdLCBjb29yZHNbIDEgXSApO1xcXFxuXFxcXHR2ZWN0b3JGb3JtRmFjdG9yICs9IExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggY29vcmRzWyAxIF0sIGNvb3Jkc1sgMiBdICk7XFxcXG5cXFxcdHZlY3RvckZvcm1GYWN0b3IgKz0gTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yKCBjb29yZHNbIDIgXSwgY29vcmRzWyAzIF0gKTtcXFxcblxcXFx0dmVjdG9yRm9ybUZhY3RvciArPSBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvb3Jkc1sgMyBdLCBjb29yZHNbIDAgXSApO1xcXFxuXFxcXHR2ZWMzIHJlc3VsdCA9IHZlYzMoIExUQ19DbGlwcGVkU3BoZXJlRm9ybUZhY3RvciggdmVjdG9yRm9ybUZhY3RvciApICk7XFxcXG5cXFxcdHJldHVybiByZXN1bHQ7XFxcXG59XFxcXG52ZWMzIEJSREZfU3BlY3VsYXJfR0dYX0Vudmlyb25tZW50KCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXFxcblxcXFx0ZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIgKSApO1xcXFxuXFxcXHRjb25zdCB2ZWM0IGMwID0gdmVjNCggLSAxLCAtIDAuMDI3NSwgLSAwLjU3MiwgMC4wMjIgKTtcXFxcblxcXFx0Y29uc3QgdmVjNCBjMSA9IHZlYzQoIDEsIDAuMDQyNSwgMS4wNCwgLSAwLjA0ICk7XFxcXG5cXFxcdHZlYzQgciA9IHJvdWdobmVzcyAqIGMwICsgYzE7XFxcXG5cXFxcdGZsb2F0IGEwMDQgPSBtaW4oIHIueCAqIHIueCwgZXhwMiggLSA5LjI4ICogZG90TlYgKSApICogci54ICsgci55O1xcXFxuXFxcXHR2ZWMyIEFCID0gdmVjMiggLTEuMDQsIDEuMDQgKSAqIGEwMDQgKyByLnp3O1xcXFxuXFxcXHRyZXR1cm4gc3BlY3VsYXJDb2xvciAqIEFCLnggKyBBQi55O1xcXFxufVxcXFxuZmxvYXQgR19CbGlublBob25nX0ltcGxpY2l0KCApIHtcXFxcblxcXFx0cmV0dXJuIDAuMjU7XFxcXG59XFxcXG5mbG9hdCBEX0JsaW5uUGhvbmcoIGNvbnN0IGluIGZsb2F0IHNoaW5pbmVzcywgY29uc3QgaW4gZmxvYXQgZG90TkggKSB7XFxcXG5cXFxcdHJldHVybiBSRUNJUFJPQ0FMX1BJICogKCBzaGluaW5lc3MgKiAwLjUgKyAxLjAgKSAqIHBvdyggZG90TkgsIHNoaW5pbmVzcyApO1xcXFxufVxcXFxudmVjMyBCUkRGX1NwZWN1bGFyX0JsaW5uUGhvbmcoIGNvbnN0IGluIEluY2lkZW50TGlnaHQgaW5jaWRlbnRMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBzaGluaW5lc3MgKSB7XFxcXG5cXFxcdHZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggaW5jaWRlbnRMaWdodC5kaXJlY3Rpb24gKyBnZW9tZXRyeS52aWV3RGlyICk7XFxcXG5cXFxcdGZsb2F0IGRvdE5IID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBoYWxmRGlyICkgKTtcXFxcblxcXFx0ZmxvYXQgZG90TEggPSBzYXR1cmF0ZSggZG90KCBpbmNpZGVudExpZ2h0LmRpcmVjdGlvbiwgaGFsZkRpciApICk7XFxcXG5cXFxcdHZlYzMgRiA9IEZfU2NobGljayggc3BlY3VsYXJDb2xvciwgZG90TEggKTtcXFxcblxcXFx0ZmxvYXQgRyA9IEdfQmxpbm5QaG9uZ19JbXBsaWNpdCggKTtcXFxcblxcXFx0ZmxvYXQgRCA9IERfQmxpbm5QaG9uZyggc2hpbmluZXNzLCBkb3ROSCApO1xcXFxuXFxcXHRyZXR1cm4gRiAqICggRyAqIEQgKTtcXFxcbn1cXFxcbmZsb2F0IEdHWFJvdWdobmVzc1RvQmxpbm5FeHBvbmVudCggY29uc3QgaW4gZmxvYXQgZ2d4Um91Z2huZXNzICkge1xcXFxuXFxcXHRyZXR1cm4gKCAyLjAgLyBwb3cyKCBnZ3hSb3VnaG5lc3MgKyAwLjAwMDEgKSAtIDIuMCApO1xcXFxufVxcXFxuZmxvYXQgQmxpbm5FeHBvbmVudFRvR0dYUm91Z2huZXNzKCBjb25zdCBpbiBmbG9hdCBibGlubkV4cG9uZW50ICkge1xcXFxuXFxcXHRyZXR1cm4gc3FydCggMi4wIC8gKCBibGlubkV4cG9uZW50ICsgMi4wICkgKTtcXFxcbn1cXFxcblxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIGJ1bXBtYXBfcGFyc19mcmFnbWVudCA9IFxcXCIjaWZkZWYgVVNFX0JVTVBNQVBcXFxcblxcXFx0dW5pZm9ybSBzYW1wbGVyMkQgYnVtcE1hcDtcXFxcblxcXFx0dW5pZm9ybSBmbG9hdCBidW1wU2NhbGU7XFxcXG5cXFxcdHZlYzIgZEhkeHlfZndkKCkge1xcXFxuXFxcXHRcXFxcdHZlYzIgZFNUZHggPSBkRmR4KCB2VXYgKTtcXFxcblxcXFx0XFxcXHR2ZWMyIGRTVGR5ID0gZEZkeSggdlV2ICk7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgSGxsID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2VXYgKS54O1xcXFxuXFxcXHRcXFxcdGZsb2F0IGRCeCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICsgZFNUZHggKS54IC0gSGxsO1xcXFxuXFxcXHRcXFxcdGZsb2F0IGRCeSA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICsgZFNUZHkgKS54IC0gSGxsO1xcXFxuXFxcXHRcXFxcdHJldHVybiB2ZWMyKCBkQngsIGRCeSApO1xcXFxuXFxcXHR9XFxcXG5cXFxcdHZlYzMgcGVydHVyYk5vcm1hbEFyYiggdmVjMyBzdXJmX3BvcywgdmVjMyBzdXJmX25vcm0sIHZlYzIgZEhkeHkgKSB7XFxcXG5cXFxcdFxcXFx0dmVjMyB2U2lnbWFYID0gdmVjMyggZEZkeCggc3VyZl9wb3MueCApLCBkRmR4KCBzdXJmX3Bvcy55ICksIGRGZHgoIHN1cmZfcG9zLnogKSApO1xcXFxuXFxcXHRcXFxcdHZlYzMgdlNpZ21hWSA9IHZlYzMoIGRGZHkoIHN1cmZfcG9zLnggKSwgZEZkeSggc3VyZl9wb3MueSApLCBkRmR5KCBzdXJmX3Bvcy56ICkgKTtcXFxcblxcXFx0XFxcXHR2ZWMzIHZOID0gc3VyZl9ub3JtO1xcXFxuXFxcXHRcXFxcdHZlYzMgUjEgPSBjcm9zcyggdlNpZ21hWSwgdk4gKTtcXFxcblxcXFx0XFxcXHR2ZWMzIFIyID0gY3Jvc3MoIHZOLCB2U2lnbWFYICk7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgZkRldCA9IGRvdCggdlNpZ21hWCwgUjEgKTtcXFxcblxcXFx0XFxcXHR2ZWMzIHZHcmFkID0gc2lnbiggZkRldCApICogKCBkSGR4eS54ICogUjEgKyBkSGR4eS55ICogUjIgKTtcXFxcblxcXFx0XFxcXHRyZXR1cm4gbm9ybWFsaXplKCBhYnMoIGZEZXQgKSAqIHN1cmZfbm9ybSAtIHZHcmFkICk7XFxcXG5cXFxcdH1cXFxcbiNlbmRpZlxcXFxuXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgY2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50ID0gXFxcIiNpZiBOVU1fQ0xJUFBJTkdfUExBTkVTID4gMFxcXFxuXFxcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBVTklPTl9DTElQUElOR19QTEFORVM7ICsrIGkgKSB7XFxcXG5cXFxcdFxcXFx0dmVjNCBwbGFuZSA9IGNsaXBwaW5nUGxhbmVzWyBpIF07XFxcXG5cXFxcdFxcXFx0aWYgKCBkb3QoIHZWaWV3UG9zaXRpb24sIHBsYW5lLnh5eiApID4gcGxhbmUudyApIGRpc2NhcmQ7XFxcXG5cXFxcdH1cXFxcblxcXFx0XFxcXHRcXFxcblxcXFx0I2lmIFVOSU9OX0NMSVBQSU5HX1BMQU5FUyA8IE5VTV9DTElQUElOR19QTEFORVNcXFxcblxcXFx0XFxcXHRib29sIGNsaXBwZWQgPSB0cnVlO1xcXFxuXFxcXHRcXFxcdGZvciAoIGludCBpID0gVU5JT05fQ0xJUFBJTkdfUExBTkVTOyBpIDwgTlVNX0NMSVBQSU5HX1BMQU5FUzsgKysgaSApIHtcXFxcblxcXFx0XFxcXHRcXFxcdHZlYzQgcGxhbmUgPSBjbGlwcGluZ1BsYW5lc1sgaSBdO1xcXFxuXFxcXHRcXFxcdFxcXFx0Y2xpcHBlZCA9ICggZG90KCB2Vmlld1Bvc2l0aW9uLCBwbGFuZS54eXogKSA+IHBsYW5lLncgKSAmJiBjbGlwcGVkO1xcXFxuXFxcXHRcXFxcdH1cXFxcblxcXFx0XFxcXHRpZiAoIGNsaXBwZWQgKSBkaXNjYXJkO1xcXFxuXFxcXHRcXFxcblxcXFx0I2VuZGlmXFxcXG4jZW5kaWZcXFxcblxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50ID0gXFxcIiNpZiBOVU1fQ0xJUFBJTkdfUExBTkVTID4gMFxcXFxuXFxcXHQjaWYgISBkZWZpbmVkKCBQSFlTSUNBTCApICYmICEgZGVmaW5lZCggUEhPTkcgKVxcXFxuXFxcXHRcXFxcdHZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0dW5pZm9ybSB2ZWM0IGNsaXBwaW5nUGxhbmVzWyBOVU1fQ0xJUFBJTkdfUExBTkVTIF07XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleCA9IFxcXCIjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDAgJiYgISBkZWZpbmVkKCBQSFlTSUNBTCApICYmICEgZGVmaW5lZCggUEhPTkcgKVxcXFxuXFxcXHR2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgY2xpcHBpbmdfcGxhbmVzX3ZlcnRleCA9IFxcXCIjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDAgJiYgISBkZWZpbmVkKCBQSFlTSUNBTCApICYmICEgZGVmaW5lZCggUEhPTkcgKVxcXFxuXFxcXHR2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgY29sb3JfZnJhZ21lbnQgPSBcXFwiI2lmZGVmIFVTRV9DT0xPUlxcXFxuXFxcXHRkaWZmdXNlQ29sb3IucmdiICo9IHZDb2xvcjtcXFxcbiNlbmRpZlxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIGNvbG9yX3BhcnNfZnJhZ21lbnQgPSBcXFwiI2lmZGVmIFVTRV9DT0xPUlxcXFxuXFxcXHR2YXJ5aW5nIHZlYzMgdkNvbG9yO1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBjb2xvcl9wYXJzX3ZlcnRleCA9IFxcXCIjaWZkZWYgVVNFX0NPTE9SXFxcXG5cXFxcdHZhcnlpbmcgdmVjMyB2Q29sb3I7XFxcXG4jZW5kaWZcXFwiO1xcclxcblxcclxcblxcdHZhciBjb2xvcl92ZXJ0ZXggPSBcXFwiI2lmZGVmIFVTRV9DT0xPUlxcXFxuXFxcXHR2Q29sb3IueHl6ID0gY29sb3IueHl6O1xcXFxuI2VuZGlmXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgY29tbW9uID0gXFxcIiNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1OVxcXFxuI2RlZmluZSBQSTIgNi4yODMxODUzMDcxOFxcXFxuI2RlZmluZSBQSV9IQUxGIDEuNTcwNzk2MzI2Nzk0OVxcXFxuI2RlZmluZSBSRUNJUFJPQ0FMX1BJIDAuMzE4MzA5ODg2MThcXFxcbiNkZWZpbmUgUkVDSVBST0NBTF9QSTIgMC4xNTkxNTQ5NFxcXFxuI2RlZmluZSBMT0cyIDEuNDQyNjk1XFxcXG4jZGVmaW5lIEVQU0lMT04gMWUtNlxcXFxuI2RlZmluZSBzYXR1cmF0ZShhKSBjbGFtcCggYSwgMC4wLCAxLjAgKVxcXFxuI2RlZmluZSB3aGl0ZUNvbXBsaW1lbnQoYSkgKCAxLjAgLSBzYXR1cmF0ZSggYSApIClcXFxcbmZsb2F0IHBvdzIoIGNvbnN0IGluIGZsb2F0IHggKSB7IHJldHVybiB4Kng7IH1cXFxcbmZsb2F0IHBvdzMoIGNvbnN0IGluIGZsb2F0IHggKSB7IHJldHVybiB4KngqeDsgfVxcXFxuZmxvYXQgcG93NCggY29uc3QgaW4gZmxvYXQgeCApIHsgZmxvYXQgeDIgPSB4Kng7IHJldHVybiB4Mip4MjsgfVxcXFxuZmxvYXQgYXZlcmFnZSggY29uc3QgaW4gdmVjMyBjb2xvciApIHsgcmV0dXJuIGRvdCggY29sb3IsIHZlYzMoIDAuMzMzMyApICk7IH1cXFxcbmhpZ2hwIGZsb2F0IHJhbmQoIGNvbnN0IGluIHZlYzIgdXYgKSB7XFxcXG5cXFxcdGNvbnN0IGhpZ2hwIGZsb2F0IGEgPSAxMi45ODk4LCBiID0gNzguMjMzLCBjID0gNDM3NTguNTQ1MztcXFxcblxcXFx0aGlnaHAgZmxvYXQgZHQgPSBkb3QoIHV2Lnh5LCB2ZWMyKCBhLGIgKSApLCBzbiA9IG1vZCggZHQsIFBJICk7XFxcXG5cXFxcdHJldHVybiBmcmFjdChzaW4oc24pICogYyk7XFxcXG59XFxcXG5zdHJ1Y3QgSW5jaWRlbnRMaWdodCB7XFxcXG5cXFxcdHZlYzMgY29sb3I7XFxcXG5cXFxcdHZlYzMgZGlyZWN0aW9uO1xcXFxuXFxcXHRib29sIHZpc2libGU7XFxcXG59O1xcXFxuc3RydWN0IFJlZmxlY3RlZExpZ2h0IHtcXFxcblxcXFx0dmVjMyBkaXJlY3REaWZmdXNlO1xcXFxuXFxcXHR2ZWMzIGRpcmVjdFNwZWN1bGFyO1xcXFxuXFxcXHR2ZWMzIGluZGlyZWN0RGlmZnVzZTtcXFxcblxcXFx0dmVjMyBpbmRpcmVjdFNwZWN1bGFyO1xcXFxufTtcXFxcbnN0cnVjdCBHZW9tZXRyaWNDb250ZXh0IHtcXFxcblxcXFx0dmVjMyBwb3NpdGlvbjtcXFxcblxcXFx0dmVjMyBub3JtYWw7XFxcXG5cXFxcdHZlYzMgdmlld0RpcjtcXFxcbn07XFxcXG52ZWMzIHRyYW5zZm9ybURpcmVjdGlvbiggaW4gdmVjMyBkaXIsIGluIG1hdDQgbWF0cml4ICkge1xcXFxuXFxcXHRyZXR1cm4gbm9ybWFsaXplKCAoIG1hdHJpeCAqIHZlYzQoIGRpciwgMC4wICkgKS54eXogKTtcXFxcbn1cXFxcbnZlYzMgaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggaW4gdmVjMyBkaXIsIGluIG1hdDQgbWF0cml4ICkge1xcXFxuXFxcXHRyZXR1cm4gbm9ybWFsaXplKCAoIHZlYzQoIGRpciwgMC4wICkgKiBtYXRyaXggKS54eXogKTtcXFxcbn1cXFxcbnZlYzMgcHJvamVjdE9uUGxhbmUoaW4gdmVjMyBwb2ludCwgaW4gdmVjMyBwb2ludE9uUGxhbmUsIGluIHZlYzMgcGxhbmVOb3JtYWwgKSB7XFxcXG5cXFxcdGZsb2F0IGRpc3RhbmNlID0gZG90KCBwbGFuZU5vcm1hbCwgcG9pbnQgLSBwb2ludE9uUGxhbmUgKTtcXFxcblxcXFx0cmV0dXJuIC0gZGlzdGFuY2UgKiBwbGFuZU5vcm1hbCArIHBvaW50O1xcXFxufVxcXFxuZmxvYXQgc2lkZU9mUGxhbmUoIGluIHZlYzMgcG9pbnQsIGluIHZlYzMgcG9pbnRPblBsYW5lLCBpbiB2ZWMzIHBsYW5lTm9ybWFsICkge1xcXFxuXFxcXHRyZXR1cm4gc2lnbiggZG90KCBwb2ludCAtIHBvaW50T25QbGFuZSwgcGxhbmVOb3JtYWwgKSApO1xcXFxufVxcXFxudmVjMyBsaW5lUGxhbmVJbnRlcnNlY3QoIGluIHZlYzMgcG9pbnRPbkxpbmUsIGluIHZlYzMgbGluZURpcmVjdGlvbiwgaW4gdmVjMyBwb2ludE9uUGxhbmUsIGluIHZlYzMgcGxhbmVOb3JtYWwgKSB7XFxcXG5cXFxcdHJldHVybiBsaW5lRGlyZWN0aW9uICogKCBkb3QoIHBsYW5lTm9ybWFsLCBwb2ludE9uUGxhbmUgLSBwb2ludE9uTGluZSApIC8gZG90KCBwbGFuZU5vcm1hbCwgbGluZURpcmVjdGlvbiApICkgKyBwb2ludE9uTGluZTtcXFxcbn1cXFxcbm1hdDMgdHJhbnNwb3NlTWF0MyggY29uc3QgaW4gbWF0MyBtICkge1xcXFxuXFxcXHRtYXQzIHRtcDtcXFxcblxcXFx0dG1wWyAwIF0gPSB2ZWMzKCBtWyAwIF0ueCwgbVsgMSBdLngsIG1bIDIgXS54ICk7XFxcXG5cXFxcdHRtcFsgMSBdID0gdmVjMyggbVsgMCBdLnksIG1bIDEgXS55LCBtWyAyIF0ueSApO1xcXFxuXFxcXHR0bXBbIDIgXSA9IHZlYzMoIG1bIDAgXS56LCBtWyAxIF0ueiwgbVsgMiBdLnogKTtcXFxcblxcXFx0cmV0dXJuIHRtcDtcXFxcbn1cXFxcbmZsb2F0IGxpbmVhclRvUmVsYXRpdmVMdW1pbmFuY2UoIGNvbnN0IGluIHZlYzMgY29sb3IgKSB7XFxcXG5cXFxcdHZlYzMgd2VpZ2h0cyA9IHZlYzMoIDAuMjEyNiwgMC43MTUyLCAwLjA3MjIgKTtcXFxcblxcXFx0cmV0dXJuIGRvdCggd2VpZ2h0cywgY29sb3IucmdiICk7XFxcXG59XFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQgPSBcXFwiI2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVfVVZcXFxcbiNkZWZpbmUgY3ViZVVWX3RleHR1cmVTaXplICgxMDI0LjApXFxcXG5pbnQgZ2V0RmFjZUZyb21EaXJlY3Rpb24odmVjMyBkaXJlY3Rpb24pIHtcXFxcblxcXFx0dmVjMyBhYnNEaXJlY3Rpb24gPSBhYnMoZGlyZWN0aW9uKTtcXFxcblxcXFx0aW50IGZhY2UgPSAtMTtcXFxcblxcXFx0aWYoIGFic0RpcmVjdGlvbi54ID4gYWJzRGlyZWN0aW9uLnogKSB7XFxcXG5cXFxcdFxcXFx0aWYoYWJzRGlyZWN0aW9uLnggPiBhYnNEaXJlY3Rpb24ueSApXFxcXG5cXFxcdFxcXFx0XFxcXHRmYWNlID0gZGlyZWN0aW9uLnggPiAwLjAgPyAwIDogMztcXFxcblxcXFx0XFxcXHRlbHNlXFxcXG5cXFxcdFxcXFx0XFxcXHRmYWNlID0gZGlyZWN0aW9uLnkgPiAwLjAgPyAxIDogNDtcXFxcblxcXFx0fVxcXFxuXFxcXHRlbHNlIHtcXFxcblxcXFx0XFxcXHRpZihhYnNEaXJlY3Rpb24ueiA+IGFic0RpcmVjdGlvbi55IClcXFxcblxcXFx0XFxcXHRcXFxcdGZhY2UgPSBkaXJlY3Rpb24ueiA+IDAuMCA/IDIgOiA1O1xcXFxuXFxcXHRcXFxcdGVsc2VcXFxcblxcXFx0XFxcXHRcXFxcdGZhY2UgPSBkaXJlY3Rpb24ueSA+IDAuMCA/IDEgOiA0O1xcXFxuXFxcXHR9XFxcXG5cXFxcdHJldHVybiBmYWNlO1xcXFxufVxcXFxuI2RlZmluZSBjdWJlVVZfbWF4TG9kczEgIChsb2cyKGN1YmVVVl90ZXh0dXJlU2l6ZSowLjI1KSAtIDEuMClcXFxcbiNkZWZpbmUgY3ViZVVWX3JhbmdlQ2xhbXAgKGV4cDIoKDYuMCAtIDEuMCkgKiAyLjApKVxcXFxudmVjMiBNaXBMZXZlbEluZm8oIHZlYzMgdmVjLCBmbG9hdCByb3VnaG5lc3NMZXZlbCwgZmxvYXQgcm91Z2huZXNzICkge1xcXFxuXFxcXHRmbG9hdCBzY2FsZSA9IGV4cDIoY3ViZVVWX21heExvZHMxIC0gcm91Z2huZXNzTGV2ZWwpO1xcXFxuXFxcXHRmbG9hdCBkeFJvdWdobmVzcyA9IGRGZHgocm91Z2huZXNzKTtcXFxcblxcXFx0ZmxvYXQgZHlSb3VnaG5lc3MgPSBkRmR5KHJvdWdobmVzcyk7XFxcXG5cXFxcdHZlYzMgZHggPSBkRmR4KCB2ZWMgKiBzY2FsZSAqIGR4Um91Z2huZXNzICk7XFxcXG5cXFxcdHZlYzMgZHkgPSBkRmR5KCB2ZWMgKiBzY2FsZSAqIGR5Um91Z2huZXNzICk7XFxcXG5cXFxcdGZsb2F0IGQgPSBtYXgoIGRvdCggZHgsIGR4ICksIGRvdCggZHksIGR5ICkgKTtcXFxcblxcXFx0ZCA9IGNsYW1wKGQsIDEuMCwgY3ViZVVWX3JhbmdlQ2xhbXApO1xcXFxuXFxcXHRmbG9hdCBtaXBMZXZlbCA9IDAuNSAqIGxvZzIoZCk7XFxcXG5cXFxcdHJldHVybiB2ZWMyKGZsb29yKG1pcExldmVsKSwgZnJhY3QobWlwTGV2ZWwpKTtcXFxcbn1cXFxcbiNkZWZpbmUgY3ViZVVWX21heExvZHMyIChsb2cyKGN1YmVVVl90ZXh0dXJlU2l6ZSowLjI1KSAtIDIuMClcXFxcbiNkZWZpbmUgY3ViZVVWX3JjcFRleHR1cmVTaXplICgxLjAgLyBjdWJlVVZfdGV4dHVyZVNpemUpXFxcXG52ZWMyIGdldEN1YmVVVih2ZWMzIGRpcmVjdGlvbiwgZmxvYXQgcm91Z2huZXNzTGV2ZWwsIGZsb2F0IG1pcExldmVsKSB7XFxcXG5cXFxcdG1pcExldmVsID0gcm91Z2huZXNzTGV2ZWwgPiBjdWJlVVZfbWF4TG9kczIgLSAzLjAgPyAwLjAgOiBtaXBMZXZlbDtcXFxcblxcXFx0ZmxvYXQgYSA9IDE2LjAgKiBjdWJlVVZfcmNwVGV4dHVyZVNpemU7XFxcXG5cXFxcdHZlYzIgZXhwMl9wYWNrZWQgPSBleHAyKCB2ZWMyKCByb3VnaG5lc3NMZXZlbCwgbWlwTGV2ZWwgKSApO1xcXFxuXFxcXHR2ZWMyIHJjcF9leHAyX3BhY2tlZCA9IHZlYzIoIDEuMCApIC8gZXhwMl9wYWNrZWQ7XFxcXG5cXFxcdGZsb2F0IHBvd1NjYWxlID0gZXhwMl9wYWNrZWQueCAqIGV4cDJfcGFja2VkLnk7XFxcXG5cXFxcdGZsb2F0IHNjYWxlID0gcmNwX2V4cDJfcGFja2VkLnggKiByY3BfZXhwMl9wYWNrZWQueSAqIDAuMjU7XFxcXG5cXFxcdGZsb2F0IG1pcE9mZnNldCA9IDAuNzUqKDEuMCAtIHJjcF9leHAyX3BhY2tlZC55KSAqIHJjcF9leHAyX3BhY2tlZC54O1xcXFxuXFxcXHRib29sIGJSZXMgPSBtaXBMZXZlbCA9PSAwLjA7XFxcXG5cXFxcdHNjYWxlID0gIGJSZXMgJiYgKHNjYWxlIDwgYSkgPyBhIDogc2NhbGU7XFxcXG5cXFxcdHZlYzMgcjtcXFxcblxcXFx0dmVjMiBvZmZzZXQ7XFxcXG5cXFxcdGludCBmYWNlID0gZ2V0RmFjZUZyb21EaXJlY3Rpb24oZGlyZWN0aW9uKTtcXFxcblxcXFx0ZmxvYXQgcmNwUG93U2NhbGUgPSAxLjAgLyBwb3dTY2FsZTtcXFxcblxcXFx0aWYoIGZhY2UgPT0gMCkge1xcXFxuXFxcXHRcXFxcdHIgPSB2ZWMzKGRpcmVjdGlvbi54LCAtZGlyZWN0aW9uLnosIGRpcmVjdGlvbi55KTtcXFxcblxcXFx0XFxcXHRvZmZzZXQgPSB2ZWMyKDAuMCttaXBPZmZzZXQsMC43NSAqIHJjcFBvd1NjYWxlKTtcXFxcblxcXFx0XFxcXHRvZmZzZXQueSA9IGJSZXMgJiYgKG9mZnNldC55IDwgMi4wKmEpID8gYSA6IG9mZnNldC55O1xcXFxuXFxcXHR9XFxcXG5cXFxcdGVsc2UgaWYoIGZhY2UgPT0gMSkge1xcXFxuXFxcXHRcXFxcdHIgPSB2ZWMzKGRpcmVjdGlvbi55LCBkaXJlY3Rpb24ueCwgZGlyZWN0aW9uLnopO1xcXFxuXFxcXHRcXFxcdG9mZnNldCA9IHZlYzIoc2NhbGUrbWlwT2Zmc2V0LCAwLjc1ICogcmNwUG93U2NhbGUpO1xcXFxuXFxcXHRcXFxcdG9mZnNldC55ID0gYlJlcyAmJiAob2Zmc2V0LnkgPCAyLjAqYSkgPyBhIDogb2Zmc2V0Lnk7XFxcXG5cXFxcdH1cXFxcblxcXFx0ZWxzZSBpZiggZmFjZSA9PSAyKSB7XFxcXG5cXFxcdFxcXFx0ciA9IHZlYzMoZGlyZWN0aW9uLnosIGRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueSk7XFxcXG5cXFxcdFxcXFx0b2Zmc2V0ID0gdmVjMigyLjAqc2NhbGUrbWlwT2Zmc2V0LCAwLjc1ICogcmNwUG93U2NhbGUpO1xcXFxuXFxcXHRcXFxcdG9mZnNldC55ID0gYlJlcyAmJiAob2Zmc2V0LnkgPCAyLjAqYSkgPyBhIDogb2Zmc2V0Lnk7XFxcXG5cXFxcdH1cXFxcblxcXFx0ZWxzZSBpZiggZmFjZSA9PSAzKSB7XFxcXG5cXFxcdFxcXFx0ciA9IHZlYzMoZGlyZWN0aW9uLngsIGRpcmVjdGlvbi56LCBkaXJlY3Rpb24ueSk7XFxcXG5cXFxcdFxcXFx0b2Zmc2V0ID0gdmVjMigwLjArbWlwT2Zmc2V0LDAuNSAqIHJjcFBvd1NjYWxlKTtcXFxcblxcXFx0XFxcXHRvZmZzZXQueSA9IGJSZXMgJiYgKG9mZnNldC55IDwgMi4wKmEpID8gMC4wIDogb2Zmc2V0Lnk7XFxcXG5cXFxcdH1cXFxcblxcXFx0ZWxzZSBpZiggZmFjZSA9PSA0KSB7XFxcXG5cXFxcdFxcXFx0ciA9IHZlYzMoZGlyZWN0aW9uLnksIGRpcmVjdGlvbi54LCAtZGlyZWN0aW9uLnopO1xcXFxuXFxcXHRcXFxcdG9mZnNldCA9IHZlYzIoc2NhbGUrbWlwT2Zmc2V0LCAwLjUgKiByY3BQb3dTY2FsZSk7XFxcXG5cXFxcdFxcXFx0b2Zmc2V0LnkgPSBiUmVzICYmIChvZmZzZXQueSA8IDIuMCphKSA/IDAuMCA6IG9mZnNldC55O1xcXFxuXFxcXHR9XFxcXG5cXFxcdGVsc2Uge1xcXFxuXFxcXHRcXFxcdHIgPSB2ZWMzKGRpcmVjdGlvbi56LCAtZGlyZWN0aW9uLngsIGRpcmVjdGlvbi55KTtcXFxcblxcXFx0XFxcXHRvZmZzZXQgPSB2ZWMyKDIuMCpzY2FsZSttaXBPZmZzZXQsIDAuNSAqIHJjcFBvd1NjYWxlKTtcXFxcblxcXFx0XFxcXHRvZmZzZXQueSA9IGJSZXMgJiYgKG9mZnNldC55IDwgMi4wKmEpID8gMC4wIDogb2Zmc2V0Lnk7XFxcXG5cXFxcdH1cXFxcblxcXFx0ciA9IG5vcm1hbGl6ZShyKTtcXFxcblxcXFx0ZmxvYXQgdGV4ZWxPZmZzZXQgPSAwLjUgKiBjdWJlVVZfcmNwVGV4dHVyZVNpemU7XFxcXG5cXFxcdHZlYzIgcyA9ICggci55eiAvIGFicyggci54ICkgKyB2ZWMyKCAxLjAgKSApICogMC41O1xcXFxuXFxcXHR2ZWMyIGJhc2UgPSBvZmZzZXQgKyB2ZWMyKCB0ZXhlbE9mZnNldCApO1xcXFxuXFxcXHRyZXR1cm4gYmFzZSArIHMgKiAoIHNjYWxlIC0gMi4wICogdGV4ZWxPZmZzZXQgKTtcXFxcbn1cXFxcbiNkZWZpbmUgY3ViZVVWX21heExvZHMzIChsb2cyKGN1YmVVVl90ZXh0dXJlU2l6ZSowLjI1KSAtIDMuMClcXFxcbnZlYzQgdGV4dHVyZUN1YmVVVih2ZWMzIHJlZmxlY3RlZERpcmVjdGlvbiwgZmxvYXQgcm91Z2huZXNzICkge1xcXFxuXFxcXHRmbG9hdCByb3VnaG5lc3NWYWwgPSByb3VnaG5lc3MqIGN1YmVVVl9tYXhMb2RzMztcXFxcblxcXFx0ZmxvYXQgcjEgPSBmbG9vcihyb3VnaG5lc3NWYWwpO1xcXFxuXFxcXHRmbG9hdCByMiA9IHIxICsgMS4wO1xcXFxuXFxcXHRmbG9hdCB0ID0gZnJhY3Qocm91Z2huZXNzVmFsKTtcXFxcblxcXFx0dmVjMiBtaXBJbmZvID0gTWlwTGV2ZWxJbmZvKHJlZmxlY3RlZERpcmVjdGlvbiwgcjEsIHJvdWdobmVzcyk7XFxcXG5cXFxcdGZsb2F0IHMgPSBtaXBJbmZvLnk7XFxcXG5cXFxcdGZsb2F0IGxldmVsMCA9IG1pcEluZm8ueDtcXFxcblxcXFx0ZmxvYXQgbGV2ZWwxID0gbGV2ZWwwICsgMS4wO1xcXFxuXFxcXHRsZXZlbDEgPSBsZXZlbDEgPiA1LjAgPyA1LjAgOiBsZXZlbDE7XFxcXG5cXFxcdGxldmVsMCArPSBtaW4oIGZsb29yKCBzICsgMC41ICksIDUuMCApO1xcXFxuXFxcXHR2ZWMyIHV2XzEwID0gZ2V0Q3ViZVVWKHJlZmxlY3RlZERpcmVjdGlvbiwgcjEsIGxldmVsMCk7XFxcXG5cXFxcdHZlYzQgY29sb3IxMCA9IGVudk1hcFRleGVsVG9MaW5lYXIodGV4dHVyZTJEKGVudk1hcCwgdXZfMTApKTtcXFxcblxcXFx0dmVjMiB1dl8yMCA9IGdldEN1YmVVVihyZWZsZWN0ZWREaXJlY3Rpb24sIHIyLCBsZXZlbDApO1xcXFxuXFxcXHR2ZWM0IGNvbG9yMjAgPSBlbnZNYXBUZXhlbFRvTGluZWFyKHRleHR1cmUyRChlbnZNYXAsIHV2XzIwKSk7XFxcXG5cXFxcdHZlYzQgcmVzdWx0ID0gbWl4KGNvbG9yMTAsIGNvbG9yMjAsIHQpO1xcXFxuXFxcXHRyZXR1cm4gdmVjNChyZXN1bHQucmdiLCAxLjApO1xcXFxufVxcXFxuI2VuZGlmXFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBkZWZhdWx0bm9ybWFsX3ZlcnRleCA9IFxcXCJ2ZWMzIHRyYW5zZm9ybWVkTm9ybWFsID0gbm9ybWFsTWF0cml4ICogb2JqZWN0Tm9ybWFsO1xcXFxuI2lmZGVmIEZMSVBfU0lERURcXFxcblxcXFx0dHJhbnNmb3JtZWROb3JtYWwgPSAtIHRyYW5zZm9ybWVkTm9ybWFsO1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXggPSBcXFwiI2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVBcXFxcblxcXFx0dW5pZm9ybSBzYW1wbGVyMkQgZGlzcGxhY2VtZW50TWFwO1xcXFxuXFxcXHR1bmlmb3JtIGZsb2F0IGRpc3BsYWNlbWVudFNjYWxlO1xcXFxuXFxcXHR1bmlmb3JtIGZsb2F0IGRpc3BsYWNlbWVudEJpYXM7XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXggPSBcXFwiI2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVBcXFxcblxcXFx0dHJhbnNmb3JtZWQgKz0gbm9ybWFsaXplKCBvYmplY3ROb3JtYWwgKSAqICggdGV4dHVyZTJEKCBkaXNwbGFjZW1lbnRNYXAsIHV2ICkueCAqIGRpc3BsYWNlbWVudFNjYWxlICsgZGlzcGxhY2VtZW50QmlhcyApO1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBlbWlzc2l2ZW1hcF9mcmFnbWVudCA9IFxcXCIjaWZkZWYgVVNFX0VNSVNTSVZFTUFQXFxcXG5cXFxcdHZlYzQgZW1pc3NpdmVDb2xvciA9IHRleHR1cmUyRCggZW1pc3NpdmVNYXAsIHZVdiApO1xcXFxuXFxcXHRlbWlzc2l2ZUNvbG9yLnJnYiA9IGVtaXNzaXZlTWFwVGV4ZWxUb0xpbmVhciggZW1pc3NpdmVDb2xvciApLnJnYjtcXFxcblxcXFx0dG90YWxFbWlzc2l2ZVJhZGlhbmNlICo9IGVtaXNzaXZlQ29sb3IucmdiO1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50ID0gXFxcIiNpZmRlZiBVU0VfRU1JU1NJVkVNQVBcXFxcblxcXFx0dW5pZm9ybSBzYW1wbGVyMkQgZW1pc3NpdmVNYXA7XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIGVuY29kaW5nc19mcmFnbWVudCA9IFxcXCIgIGdsX0ZyYWdDb2xvciA9IGxpbmVhclRvT3V0cHV0VGV4ZWwoIGdsX0ZyYWdDb2xvciApO1xcXFxuXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgZW5jb2RpbmdzX3BhcnNfZnJhZ21lbnQgPSBcXFwiXFxcXG52ZWM0IExpbmVhclRvTGluZWFyKCBpbiB2ZWM0IHZhbHVlICkge1xcXFxuXFxcXHRyZXR1cm4gdmFsdWU7XFxcXG59XFxcXG52ZWM0IEdhbW1hVG9MaW5lYXIoIGluIHZlYzQgdmFsdWUsIGluIGZsb2F0IGdhbW1hRmFjdG9yICkge1xcXFxuXFxcXHRyZXR1cm4gdmVjNCggcG93KCB2YWx1ZS54eXosIHZlYzMoIGdhbW1hRmFjdG9yICkgKSwgdmFsdWUudyApO1xcXFxufVxcXFxudmVjNCBMaW5lYXJUb0dhbW1hKCBpbiB2ZWM0IHZhbHVlLCBpbiBmbG9hdCBnYW1tYUZhY3RvciApIHtcXFxcblxcXFx0cmV0dXJuIHZlYzQoIHBvdyggdmFsdWUueHl6LCB2ZWMzKCAxLjAgLyBnYW1tYUZhY3RvciApICksIHZhbHVlLncgKTtcXFxcbn1cXFxcbnZlYzQgc1JHQlRvTGluZWFyKCBpbiB2ZWM0IHZhbHVlICkge1xcXFxuXFxcXHRyZXR1cm4gdmVjNCggbWl4KCBwb3coIHZhbHVlLnJnYiAqIDAuOTQ3ODY3Mjk4NiArIHZlYzMoIDAuMDUyMTMyNzAxNCApLCB2ZWMzKCAyLjQgKSApLCB2YWx1ZS5yZ2IgKiAwLjA3NzM5OTM4MDgsIHZlYzMoIGxlc3NUaGFuRXF1YWwoIHZhbHVlLnJnYiwgdmVjMyggMC4wNDA0NSApICkgKSApLCB2YWx1ZS53ICk7XFxcXG59XFxcXG52ZWM0IExpbmVhclRvc1JHQiggaW4gdmVjNCB2YWx1ZSApIHtcXFxcblxcXFx0cmV0dXJuIHZlYzQoIG1peCggcG93KCB2YWx1ZS5yZ2IsIHZlYzMoIDAuNDE2NjYgKSApICogMS4wNTUgLSB2ZWMzKCAwLjA1NSApLCB2YWx1ZS5yZ2IgKiAxMi45MiwgdmVjMyggbGVzc1RoYW5FcXVhbCggdmFsdWUucmdiLCB2ZWMzKCAwLjAwMzEzMDggKSApICkgKSwgdmFsdWUudyApO1xcXFxufVxcXFxudmVjNCBSR0JFVG9MaW5lYXIoIGluIHZlYzQgdmFsdWUgKSB7XFxcXG5cXFxcdHJldHVybiB2ZWM0KCB2YWx1ZS5yZ2IgKiBleHAyKCB2YWx1ZS5hICogMjU1LjAgLSAxMjguMCApLCAxLjAgKTtcXFxcbn1cXFxcbnZlYzQgTGluZWFyVG9SR0JFKCBpbiB2ZWM0IHZhbHVlICkge1xcXFxuXFxcXHRmbG9hdCBtYXhDb21wb25lbnQgPSBtYXgoIG1heCggdmFsdWUuciwgdmFsdWUuZyApLCB2YWx1ZS5iICk7XFxcXG5cXFxcdGZsb2F0IGZFeHAgPSBjbGFtcCggY2VpbCggbG9nMiggbWF4Q29tcG9uZW50ICkgKSwgLTEyOC4wLCAxMjcuMCApO1xcXFxuXFxcXHRyZXR1cm4gdmVjNCggdmFsdWUucmdiIC8gZXhwMiggZkV4cCApLCAoIGZFeHAgKyAxMjguMCApIC8gMjU1LjAgKTtcXFxcbn1cXFxcbnZlYzQgUkdCTVRvTGluZWFyKCBpbiB2ZWM0IHZhbHVlLCBpbiBmbG9hdCBtYXhSYW5nZSApIHtcXFxcblxcXFx0cmV0dXJuIHZlYzQoIHZhbHVlLnh5eiAqIHZhbHVlLncgKiBtYXhSYW5nZSwgMS4wICk7XFxcXG59XFxcXG52ZWM0IExpbmVhclRvUkdCTSggaW4gdmVjNCB2YWx1ZSwgaW4gZmxvYXQgbWF4UmFuZ2UgKSB7XFxcXG5cXFxcdGZsb2F0IG1heFJHQiA9IG1heCggdmFsdWUueCwgbWF4KCB2YWx1ZS5nLCB2YWx1ZS5iICkgKTtcXFxcblxcXFx0ZmxvYXQgTSAgICAgID0gY2xhbXAoIG1heFJHQiAvIG1heFJhbmdlLCAwLjAsIDEuMCApO1xcXFxuXFxcXHRNICAgICAgICAgICAgPSBjZWlsKCBNICogMjU1LjAgKSAvIDI1NS4wO1xcXFxuXFxcXHRyZXR1cm4gdmVjNCggdmFsdWUucmdiIC8gKCBNICogbWF4UmFuZ2UgKSwgTSApO1xcXFxufVxcXFxudmVjNCBSR0JEVG9MaW5lYXIoIGluIHZlYzQgdmFsdWUsIGluIGZsb2F0IG1heFJhbmdlICkge1xcXFxuXFxcXHRyZXR1cm4gdmVjNCggdmFsdWUucmdiICogKCAoIG1heFJhbmdlIC8gMjU1LjAgKSAvIHZhbHVlLmEgKSwgMS4wICk7XFxcXG59XFxcXG52ZWM0IExpbmVhclRvUkdCRCggaW4gdmVjNCB2YWx1ZSwgaW4gZmxvYXQgbWF4UmFuZ2UgKSB7XFxcXG5cXFxcdGZsb2F0IG1heFJHQiA9IG1heCggdmFsdWUueCwgbWF4KCB2YWx1ZS5nLCB2YWx1ZS5iICkgKTtcXFxcblxcXFx0ZmxvYXQgRCAgICAgID0gbWF4KCBtYXhSYW5nZSAvIG1heFJHQiwgMS4wICk7XFxcXG5cXFxcdEQgICAgICAgICAgICA9IG1pbiggZmxvb3IoIEQgKSAvIDI1NS4wLCAxLjAgKTtcXFxcblxcXFx0cmV0dXJuIHZlYzQoIHZhbHVlLnJnYiAqICggRCAqICggMjU1LjAgLyBtYXhSYW5nZSApICksIEQgKTtcXFxcbn1cXFxcbmNvbnN0IG1hdDMgY0xvZ0x1dk0gPSBtYXQzKCAwLjIyMDksIDAuMzM5MCwgMC40MTg0LCAwLjExMzgsIDAuNjc4MCwgMC43MzE5LCAwLjAxMDIsIDAuMTEzMCwgMC4yOTY5ICk7XFxcXG52ZWM0IExpbmVhclRvTG9nTHV2KCBpbiB2ZWM0IHZhbHVlICkgIHtcXFxcblxcXFx0dmVjMyBYcF9ZX1hZWnAgPSB2YWx1ZS5yZ2IgKiBjTG9nTHV2TTtcXFxcblxcXFx0WHBfWV9YWVpwID0gbWF4KFhwX1lfWFlacCwgdmVjMygxZS02LCAxZS02LCAxZS02KSk7XFxcXG5cXFxcdHZlYzQgdlJlc3VsdDtcXFxcblxcXFx0dlJlc3VsdC54eSA9IFhwX1lfWFlacC54eSAvIFhwX1lfWFlacC56O1xcXFxuXFxcXHRmbG9hdCBMZSA9IDIuMCAqIGxvZzIoWHBfWV9YWVpwLnkpICsgMTI3LjA7XFxcXG5cXFxcdHZSZXN1bHQudyA9IGZyYWN0KExlKTtcXFxcblxcXFx0dlJlc3VsdC56ID0gKExlIC0gKGZsb29yKHZSZXN1bHQudyoyNTUuMCkpLzI1NS4wKS8yNTUuMDtcXFxcblxcXFx0cmV0dXJuIHZSZXN1bHQ7XFxcXG59XFxcXG5jb25zdCBtYXQzIGNMb2dMdXZJbnZlcnNlTSA9IG1hdDMoIDYuMDAxNCwgLTIuNzAwOCwgLTEuNzk5NiwgLTEuMzMyMCwgMy4xMDI5LCAtNS43NzIxLCAwLjMwMDgsIC0xLjA4ODIsIDUuNjI2OCApO1xcXFxudmVjNCBMb2dMdXZUb0xpbmVhciggaW4gdmVjNCB2YWx1ZSApIHtcXFxcblxcXFx0ZmxvYXQgTGUgPSB2YWx1ZS56ICogMjU1LjAgKyB2YWx1ZS53O1xcXFxuXFxcXHR2ZWMzIFhwX1lfWFlacDtcXFxcblxcXFx0WHBfWV9YWVpwLnkgPSBleHAyKChMZSAtIDEyNy4wKSAvIDIuMCk7XFxcXG5cXFxcdFhwX1lfWFlacC56ID0gWHBfWV9YWVpwLnkgLyB2YWx1ZS55O1xcXFxuXFxcXHRYcF9ZX1hZWnAueCA9IHZhbHVlLnggKiBYcF9ZX1hZWnAuejtcXFxcblxcXFx0dmVjMyB2UkdCID0gWHBfWV9YWVpwLnJnYiAqIGNMb2dMdXZJbnZlcnNlTTtcXFxcblxcXFx0cmV0dXJuIHZlYzQoIG1heCh2UkdCLCAwLjApLCAxLjAgKTtcXFxcbn1cXFxcblxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIGVudm1hcF9mcmFnbWVudCA9IFxcXCIjaWZkZWYgVVNFX0VOVk1BUFxcXFxuXFxcXHQjaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKVxcXFxuXFxcXHRcXFxcdHZlYzMgY2FtZXJhVG9WZXJ0ZXggPSBub3JtYWxpemUoIHZXb3JsZFBvc2l0aW9uIC0gY2FtZXJhUG9zaXRpb24gKTtcXFxcblxcXFx0XFxcXHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggbm9ybWFsLCB2aWV3TWF0cml4ICk7XFxcXG5cXFxcdFxcXFx0I2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT05cXFxcblxcXFx0XFxcXHRcXFxcdHZlYzMgcmVmbGVjdFZlYyA9IHJlZmxlY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCApO1xcXFxuXFxcXHRcXFxcdCNlbHNlXFxcXG5cXFxcdFxcXFx0XFxcXHR2ZWMzIHJlZmxlY3RWZWMgPSByZWZyYWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1xcXFxuXFxcXHRcXFxcdCNlbmRpZlxcXFxuXFxcXHQjZWxzZVxcXFxuXFxcXHRcXFxcdHZlYzMgcmVmbGVjdFZlYyA9IHZSZWZsZWN0O1xcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXFxcblxcXFx0XFxcXHR2ZWM0IGVudkNvbG9yID0gdGV4dHVyZUN1YmUoIGVudk1hcCwgdmVjMyggZmxpcEVudk1hcCAqIHJlZmxlY3RWZWMueCwgcmVmbGVjdFZlYy55eiApICk7XFxcXG5cXFxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX0VRVUlSRUMgKVxcXFxuXFxcXHRcXFxcdHZlYzIgc2FtcGxlVVY7XFxcXG5cXFxcdFxcXFx0cmVmbGVjdFZlYyA9IG5vcm1hbGl6ZSggcmVmbGVjdFZlYyApO1xcXFxuXFxcXHRcXFxcdHNhbXBsZVVWLnkgPSBhc2luKCBjbGFtcCggcmVmbGVjdFZlYy55LCAtIDEuMCwgMS4wICkgKSAqIFJFQ0lQUk9DQUxfUEkgKyAwLjU7XFxcXG5cXFxcdFxcXFx0c2FtcGxlVVYueCA9IGF0YW4oIHJlZmxlY3RWZWMueiwgcmVmbGVjdFZlYy54ICkgKiBSRUNJUFJPQ0FMX1BJMiArIDAuNTtcXFxcblxcXFx0XFxcXHR2ZWM0IGVudkNvbG9yID0gdGV4dHVyZTJEKCBlbnZNYXAsIHNhbXBsZVVWICk7XFxcXG5cXFxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX1NQSEVSRSApXFxcXG5cXFxcdFxcXFx0cmVmbGVjdFZlYyA9IG5vcm1hbGl6ZSggcmVmbGVjdFZlYyApO1xcXFxuXFxcXHRcXFxcdHZlYzMgcmVmbGVjdFZpZXcgPSBub3JtYWxpemUoICggdmlld01hdHJpeCAqIHZlYzQoIHJlZmxlY3RWZWMsIDAuMCApICkueHl6ICsgdmVjMyggMC4wLCAwLjAsIDEuMCApICk7XFxcXG5cXFxcdFxcXFx0dmVjNCBlbnZDb2xvciA9IHRleHR1cmUyRCggZW52TWFwLCByZWZsZWN0Vmlldy54eSAqIDAuNSArIDAuNSApO1xcXFxuXFxcXHQjZWxzZVxcXFxuXFxcXHRcXFxcdHZlYzQgZW52Q29sb3IgPSB2ZWM0KCAwLjAgKTtcXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdGVudkNvbG9yID0gZW52TWFwVGV4ZWxUb0xpbmVhciggZW52Q29sb3IgKTtcXFxcblxcXFx0I2lmZGVmIEVOVk1BUF9CTEVORElOR19NVUxUSVBMWVxcXFxuXFxcXHRcXFxcdG91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIG91dGdvaW5nTGlnaHQgKiBlbnZDb2xvci54eXosIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHkgKTtcXFxcblxcXFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX0JMRU5ESU5HX01JWCApXFxcXG5cXFxcdFxcXFx0b3V0Z29pbmdMaWdodCA9IG1peCggb3V0Z29pbmdMaWdodCwgZW52Q29sb3IueHl6LCBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5ICk7XFxcXG5cXFxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9CTEVORElOR19BREQgKVxcXFxuXFxcXHRcXFxcdG91dGdvaW5nTGlnaHQgKz0gZW52Q29sb3IueHl6ICogc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eTtcXFxcblxcXFx0I2VuZGlmXFxcXG4jZW5kaWZcXFxcblxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIGVudm1hcF9wYXJzX2ZyYWdtZW50ID0gXFxcIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgfHwgZGVmaW5lZCggUEhZU0lDQUwgKVxcXFxuXFxcXHR1bmlmb3JtIGZsb2F0IHJlZmxlY3Rpdml0eTtcXFxcblxcXFx0dW5pZm9ybSBmbG9hdCBlbnZNYXBJbnRlbnNpdHk7XFxcXG4jZW5kaWZcXFxcbiNpZmRlZiBVU0VfRU5WTUFQXFxcXG5cXFxcdCNpZiAhIGRlZmluZWQoIFBIWVNJQ0FMICkgJiYgKCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApIClcXFxcblxcXFx0XFxcXHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcXFxuXFxcXHRcXFxcdHVuaWZvcm0gc2FtcGxlckN1YmUgZW52TWFwO1xcXFxuXFxcXHQjZWxzZVxcXFxuXFxcXHRcXFxcdHVuaWZvcm0gc2FtcGxlcjJEIGVudk1hcDtcXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdHVuaWZvcm0gZmxvYXQgZmxpcEVudk1hcDtcXFxcblxcXFx0I2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HICkgfHwgZGVmaW5lZCggUEhZU0lDQUwgKVxcXFxuXFxcXHRcXFxcdHVuaWZvcm0gZmxvYXQgcmVmcmFjdGlvblJhdGlvO1xcXFxuXFxcXHQjZWxzZVxcXFxuXFxcXHRcXFxcdHZhcnlpbmcgdmVjMyB2UmVmbGVjdDtcXFxcblxcXFx0I2VuZGlmXFxcXG4jZW5kaWZcXFxcblxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIGVudm1hcF9wYXJzX3ZlcnRleCA9IFxcXCIjaWZkZWYgVVNFX0VOVk1BUFxcXFxuXFxcXHQjaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKVxcXFxuXFxcXHRcXFxcdHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXFxcblxcXFx0I2Vsc2VcXFxcblxcXFx0XFxcXHR2YXJ5aW5nIHZlYzMgdlJlZmxlY3Q7XFxcXG5cXFxcdFxcXFx0dW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uUmF0aW87XFxcXG5cXFxcdCNlbmRpZlxcXFxuI2VuZGlmXFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBlbnZtYXBfdmVydGV4ID0gXFxcIiNpZmRlZiBVU0VfRU5WTUFQXFxcXG5cXFxcdCNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApXFxcXG5cXFxcdFxcXFx0dldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcXFxcblxcXFx0I2Vsc2VcXFxcblxcXFx0XFxcXHR2ZWMzIGNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB3b3JsZFBvc2l0aW9uLnh5eiAtIGNhbWVyYVBvc2l0aW9uICk7XFxcXG5cXFxcdFxcXFx0dmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIHRyYW5zZm9ybWVkTm9ybWFsLCB2aWV3TWF0cml4ICk7XFxcXG5cXFxcdFxcXFx0I2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT05cXFxcblxcXFx0XFxcXHRcXFxcdHZSZWZsZWN0ID0gcmVmbGVjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsICk7XFxcXG5cXFxcdFxcXFx0I2Vsc2VcXFxcblxcXFx0XFxcXHRcXFxcdHZSZWZsZWN0ID0gcmVmcmFjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTtcXFxcblxcXFx0XFxcXHQjZW5kaWZcXFxcblxcXFx0I2VuZGlmXFxcXG4jZW5kaWZcXFxcblxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIGZvZ192ZXJ0ZXggPSBcXFwiXFxcXG4jaWZkZWYgVVNFX0ZPR1xcXFxuZm9nRGVwdGggPSAtbXZQb3NpdGlvbi56O1xcXFxuI2VuZGlmXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgZm9nX3BhcnNfdmVydGV4ID0gXFxcIiNpZmRlZiBVU0VfRk9HXFxcXG4gIHZhcnlpbmcgZmxvYXQgZm9nRGVwdGg7XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIGZvZ19mcmFnbWVudCA9IFxcXCIjaWZkZWYgVVNFX0ZPR1xcXFxuXFxcXHQjaWZkZWYgRk9HX0VYUDJcXFxcblxcXFx0XFxcXHRmbG9hdCBmb2dGYWN0b3IgPSB3aGl0ZUNvbXBsaW1lbnQoIGV4cDIoIC0gZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkgKiBmb2dEZXB0aCAqIGZvZ0RlcHRoICogTE9HMiApICk7XFxcXG5cXFxcdCNlbHNlXFxcXG5cXFxcdFxcXFx0ZmxvYXQgZm9nRmFjdG9yID0gc21vb3Roc3RlcCggZm9nTmVhciwgZm9nRmFyLCBmb2dEZXB0aCApO1xcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0Z2xfRnJhZ0NvbG9yLnJnYiA9IG1peCggZ2xfRnJhZ0NvbG9yLnJnYiwgZm9nQ29sb3IsIGZvZ0ZhY3RvciApO1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBmb2dfcGFyc19mcmFnbWVudCA9IFxcXCIjaWZkZWYgVVNFX0ZPR1xcXFxuXFxcXHR1bmlmb3JtIHZlYzMgZm9nQ29sb3I7XFxcXG5cXFxcdHZhcnlpbmcgZmxvYXQgZm9nRGVwdGg7XFxcXG5cXFxcdCNpZmRlZiBGT0dfRVhQMlxcXFxuXFxcXHRcXFxcdHVuaWZvcm0gZmxvYXQgZm9nRGVuc2l0eTtcXFxcblxcXFx0I2Vsc2VcXFxcblxcXFx0XFxcXHR1bmlmb3JtIGZsb2F0IGZvZ05lYXI7XFxcXG5cXFxcdFxcXFx0dW5pZm9ybSBmbG9hdCBmb2dGYXI7XFxcXG5cXFxcdCNlbmRpZlxcXFxuI2VuZGlmXFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBncmFkaWVudG1hcF9wYXJzX2ZyYWdtZW50ID0gXFxcIiNpZmRlZiBUT09OXFxcXG5cXFxcdHVuaWZvcm0gc2FtcGxlcjJEIGdyYWRpZW50TWFwO1xcXFxuXFxcXHR2ZWMzIGdldEdyYWRpZW50SXJyYWRpYW5jZSggdmVjMyBub3JtYWwsIHZlYzMgbGlnaHREaXJlY3Rpb24gKSB7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgZG90TkwgPSBkb3QoIG5vcm1hbCwgbGlnaHREaXJlY3Rpb24gKTtcXFxcblxcXFx0XFxcXHR2ZWMyIGNvb3JkID0gdmVjMiggZG90TkwgKiAwLjUgKyAwLjUsIDAuMCApO1xcXFxuXFxcXHRcXFxcdCNpZmRlZiBVU0VfR1JBRElFTlRNQVBcXFxcblxcXFx0XFxcXHRcXFxcdHJldHVybiB0ZXh0dXJlMkQoIGdyYWRpZW50TWFwLCBjb29yZCApLnJnYjtcXFxcblxcXFx0XFxcXHQjZWxzZVxcXFxuXFxcXHRcXFxcdFxcXFx0cmV0dXJuICggY29vcmQueCA8IDAuNyApID8gdmVjMyggMC43ICkgOiB2ZWMzKCAxLjAgKTtcXFxcblxcXFx0XFxcXHQjZW5kaWZcXFxcblxcXFx0fVxcXFxuI2VuZGlmXFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBsaWdodG1hcF9mcmFnbWVudCA9IFxcXCIjaWZkZWYgVVNFX0xJR0hUTUFQXFxcXG5cXFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBQSSAqIHRleHR1cmUyRCggbGlnaHRNYXAsIHZVdjIgKS54eXogKiBsaWdodE1hcEludGVuc2l0eTtcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgbGlnaHRtYXBfcGFyc19mcmFnbWVudCA9IFxcXCIjaWZkZWYgVVNFX0xJR0hUTUFQXFxcXG5cXFxcdHVuaWZvcm0gc2FtcGxlcjJEIGxpZ2h0TWFwO1xcXFxuXFxcXHR1bmlmb3JtIGZsb2F0IGxpZ2h0TWFwSW50ZW5zaXR5O1xcXFxuI2VuZGlmXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgbGlnaHRzX2xhbWJlcnRfdmVydGV4ID0gXFxcInZlYzMgZGlmZnVzZSA9IHZlYzMoIDEuMCApO1xcXFxuR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeTtcXFxcbmdlb21ldHJ5LnBvc2l0aW9uID0gbXZQb3NpdGlvbi54eXo7XFxcXG5nZW9tZXRyeS5ub3JtYWwgPSBub3JtYWxpemUoIHRyYW5zZm9ybWVkTm9ybWFsICk7XFxcXG5nZW9tZXRyeS52aWV3RGlyID0gbm9ybWFsaXplKCAtbXZQb3NpdGlvbi54eXogKTtcXFxcbkdlb21ldHJpY0NvbnRleHQgYmFja0dlb21ldHJ5O1xcXFxuYmFja0dlb21ldHJ5LnBvc2l0aW9uID0gZ2VvbWV0cnkucG9zaXRpb247XFxcXG5iYWNrR2VvbWV0cnkubm9ybWFsID0gLWdlb21ldHJ5Lm5vcm1hbDtcXFxcbmJhY2tHZW9tZXRyeS52aWV3RGlyID0gZ2VvbWV0cnkudmlld0RpcjtcXFxcbnZMaWdodEZyb250ID0gdmVjMyggMC4wICk7XFxcXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxcXG5cXFxcdHZMaWdodEJhY2sgPSB2ZWMzKCAwLjAgKTtcXFxcbiNlbmRpZlxcXFxuSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodDtcXFxcbmZsb2F0IGRvdE5MO1xcXFxudmVjMyBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxcXG4jaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXFxcblxcXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXFxcblxcXFx0XFxcXHRnZXRQb2ludERpcmVjdExpZ2h0SXJyYWRpYW5jZSggcG9pbnRMaWdodHNbIGkgXSwgZ2VvbWV0cnksIGRpcmVjdExpZ2h0ICk7XFxcXG5cXFxcdFxcXFx0ZG90TkwgPSBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICk7XFxcXG5cXFxcdFxcXFx0ZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlID0gUEkgKiBkaXJlY3RMaWdodC5jb2xvcjtcXFxcblxcXFx0XFxcXHR2TGlnaHRGcm9udCArPSBzYXR1cmF0ZSggZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXFxcblxcXFx0XFxcXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxcXG5cXFxcdFxcXFx0XFxcXHR2TGlnaHRCYWNrICs9IHNhdHVyYXRlKCAtZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXFxcblxcXFx0XFxcXHQjZW5kaWZcXFxcblxcXFx0fVxcXFxuI2VuZGlmXFxcXG4jaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcXFxuXFxcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxcXG5cXFxcdFxcXFx0Z2V0U3BvdERpcmVjdExpZ2h0SXJyYWRpYW5jZSggc3BvdExpZ2h0c1sgaSBdLCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcXFxcblxcXFx0XFxcXHRkb3ROTCA9IGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKTtcXFxcblxcXFx0XFxcXHRkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2UgPSBQSSAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcXFxuXFxcXHRcXFxcdHZMaWdodEZyb250ICs9IHNhdHVyYXRlKCBkb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcXFxuXFxcXHRcXFxcdCNpZmRlZiBET1VCTEVfU0lERURcXFxcblxcXFx0XFxcXHRcXFxcdHZMaWdodEJhY2sgKz0gc2F0dXJhdGUoIC1kb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcXFxuXFxcXHRcXFxcdCNlbmRpZlxcXFxuXFxcXHR9XFxcXG4jZW5kaWZcXFxcbiNpZiBOVU1fRElSX0xJR0hUUyA+IDBcXFxcblxcXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVFM7IGkgKysgKSB7XFxcXG5cXFxcdFxcXFx0Z2V0RGlyZWN0aW9uYWxEaXJlY3RMaWdodElycmFkaWFuY2UoIGRpcmVjdGlvbmFsTGlnaHRzWyBpIF0sIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xcXFxuXFxcXHRcXFxcdGRvdE5MID0gZG90KCBnZW9tZXRyeS5ub3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApO1xcXFxuXFxcXHRcXFxcdGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZSA9IFBJICogZGlyZWN0TGlnaHQuY29sb3I7XFxcXG5cXFxcdFxcXFx0dkxpZ2h0RnJvbnQgKz0gc2F0dXJhdGUoIGRvdE5MICkgKiBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxcXG5cXFxcdFxcXFx0I2lmZGVmIERPVUJMRV9TSURFRFxcXFxuXFxcXHRcXFxcdFxcXFx0dkxpZ2h0QmFjayArPSBzYXR1cmF0ZSggLWRvdE5MICkgKiBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxcXG5cXFxcdFxcXFx0I2VuZGlmXFxcXG5cXFxcdH1cXFxcbiNlbmRpZlxcXFxuI2lmIE5VTV9IRU1JX0xJR0hUUyA+IDBcXFxcblxcXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0hFTUlfTElHSFRTOyBpICsrICkge1xcXFxuXFxcXHRcXFxcdHZMaWdodEZyb250ICs9IGdldEhlbWlzcGhlcmVMaWdodElycmFkaWFuY2UoIGhlbWlzcGhlcmVMaWdodHNbIGkgXSwgZ2VvbWV0cnkgKTtcXFxcblxcXFx0XFxcXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxcXG5cXFxcdFxcXFx0XFxcXHR2TGlnaHRCYWNrICs9IGdldEhlbWlzcGhlcmVMaWdodElycmFkaWFuY2UoIGhlbWlzcGhlcmVMaWdodHNbIGkgXSwgYmFja0dlb21ldHJ5ICk7XFxcXG5cXFxcdFxcXFx0I2VuZGlmXFxcXG5cXFxcdH1cXFxcbiNlbmRpZlxcXFxuXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgbGlnaHRzX3BhcnMgPSBcXFwidW5pZm9ybSB2ZWMzIGFtYmllbnRMaWdodENvbG9yO1xcXFxudmVjMyBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiB2ZWMzIGFtYmllbnRMaWdodENvbG9yICkge1xcXFxuXFxcXHR2ZWMzIGlycmFkaWFuY2UgPSBhbWJpZW50TGlnaHRDb2xvcjtcXFxcblxcXFx0I2lmbmRlZiBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTXFxcXG5cXFxcdFxcXFx0aXJyYWRpYW5jZSAqPSBQSTtcXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdHJldHVybiBpcnJhZGlhbmNlO1xcXFxufVxcXFxuI2lmIE5VTV9ESVJfTElHSFRTID4gMFxcXFxuXFxcXHRzdHJ1Y3QgRGlyZWN0aW9uYWxMaWdodCB7XFxcXG5cXFxcdFxcXFx0dmVjMyBkaXJlY3Rpb247XFxcXG5cXFxcdFxcXFx0dmVjMyBjb2xvcjtcXFxcblxcXFx0XFxcXHRpbnQgc2hhZG93O1xcXFxuXFxcXHRcXFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgc2hhZG93UmFkaXVzO1xcXFxuXFxcXHRcXFxcdHZlYzIgc2hhZG93TWFwU2l6ZTtcXFxcblxcXFx0fTtcXFxcblxcXFx0dW5pZm9ybSBEaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHRzWyBOVU1fRElSX0xJR0hUUyBdO1xcXFxuXFxcXHR2b2lkIGdldERpcmVjdGlvbmFsRGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiBEaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIG91dCBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0ICkge1xcXFxuXFxcXHRcXFxcdGRpcmVjdExpZ2h0LmNvbG9yID0gZGlyZWN0aW9uYWxMaWdodC5jb2xvcjtcXFxcblxcXFx0XFxcXHRkaXJlY3RMaWdodC5kaXJlY3Rpb24gPSBkaXJlY3Rpb25hbExpZ2h0LmRpcmVjdGlvbjtcXFxcblxcXFx0XFxcXHRkaXJlY3RMaWdodC52aXNpYmxlID0gdHJ1ZTtcXFxcblxcXFx0fVxcXFxuI2VuZGlmXFxcXG4jaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXFxcblxcXFx0c3RydWN0IFBvaW50TGlnaHQge1xcXFxuXFxcXHRcXFxcdHZlYzMgcG9zaXRpb247XFxcXG5cXFxcdFxcXFx0dmVjMyBjb2xvcjtcXFxcblxcXFx0XFxcXHRmbG9hdCBkaXN0YW5jZTtcXFxcblxcXFx0XFxcXHRmbG9hdCBkZWNheTtcXFxcblxcXFx0XFxcXHRpbnQgc2hhZG93O1xcXFxuXFxcXHRcXFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgc2hhZG93UmFkaXVzO1xcXFxuXFxcXHRcXFxcdHZlYzIgc2hhZG93TWFwU2l6ZTtcXFxcblxcXFx0XFxcXHRmbG9hdCBzaGFkb3dDYW1lcmFOZWFyO1xcXFxuXFxcXHRcXFxcdGZsb2F0IHNoYWRvd0NhbWVyYUZhcjtcXFxcblxcXFx0fTtcXFxcblxcXFx0dW5pZm9ybSBQb2ludExpZ2h0IHBvaW50TGlnaHRzWyBOVU1fUE9JTlRfTElHSFRTIF07XFxcXG5cXFxcdHZvaWQgZ2V0UG9pbnREaXJlY3RMaWdodElycmFkaWFuY2UoIGNvbnN0IGluIFBvaW50TGlnaHQgcG9pbnRMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgb3V0IEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQgKSB7XFxcXG5cXFxcdFxcXFx0dmVjMyBsVmVjdG9yID0gcG9pbnRMaWdodC5wb3NpdGlvbiAtIGdlb21ldHJ5LnBvc2l0aW9uO1xcXFxuXFxcXHRcXFxcdGRpcmVjdExpZ2h0LmRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcXFxuXFxcXHRcXFxcdGZsb2F0IGxpZ2h0RGlzdGFuY2UgPSBsZW5ndGgoIGxWZWN0b3IgKTtcXFxcblxcXFx0XFxcXHRkaXJlY3RMaWdodC5jb2xvciA9IHBvaW50TGlnaHQuY29sb3I7XFxcXG5cXFxcdFxcXFx0ZGlyZWN0TGlnaHQuY29sb3IgKj0gcHVuY3R1YWxMaWdodEludGVuc2l0eVRvSXJyYWRpYW5jZUZhY3RvciggbGlnaHREaXN0YW5jZSwgcG9pbnRMaWdodC5kaXN0YW5jZSwgcG9pbnRMaWdodC5kZWNheSApO1xcXFxuXFxcXHRcXFxcdGRpcmVjdExpZ2h0LnZpc2libGUgPSAoIGRpcmVjdExpZ2h0LmNvbG9yICE9IHZlYzMoIDAuMCApICk7XFxcXG5cXFxcdH1cXFxcbiNlbmRpZlxcXFxuI2lmIE5VTV9TUE9UX0xJR0hUUyA+IDBcXFxcblxcXFx0c3RydWN0IFNwb3RMaWdodCB7XFxcXG5cXFxcdFxcXFx0dmVjMyBwb3NpdGlvbjtcXFxcblxcXFx0XFxcXHR2ZWMzIGRpcmVjdGlvbjtcXFxcblxcXFx0XFxcXHR2ZWMzIGNvbG9yO1xcXFxuXFxcXHRcXFxcdGZsb2F0IGRpc3RhbmNlO1xcXFxuXFxcXHRcXFxcdGZsb2F0IGRlY2F5O1xcXFxuXFxcXHRcXFxcdGZsb2F0IGNvbmVDb3M7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgcGVudW1icmFDb3M7XFxcXG5cXFxcdFxcXFx0aW50IHNoYWRvdztcXFxcblxcXFx0XFxcXHRmbG9hdCBzaGFkb3dCaWFzO1xcXFxuXFxcXHRcXFxcdGZsb2F0IHNoYWRvd1JhZGl1cztcXFxcblxcXFx0XFxcXHR2ZWMyIHNoYWRvd01hcFNpemU7XFxcXG5cXFxcdH07XFxcXG5cXFxcdHVuaWZvcm0gU3BvdExpZ2h0IHNwb3RMaWdodHNbIE5VTV9TUE9UX0xJR0hUUyBdO1xcXFxuXFxcXHR2b2lkIGdldFNwb3REaXJlY3RMaWdodElycmFkaWFuY2UoIGNvbnN0IGluIFNwb3RMaWdodCBzcG90TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIG91dCBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0ICApIHtcXFxcblxcXFx0XFxcXHR2ZWMzIGxWZWN0b3IgPSBzcG90TGlnaHQucG9zaXRpb24gLSBnZW9tZXRyeS5wb3NpdGlvbjtcXFxcblxcXFx0XFxcXHRkaXJlY3RMaWdodC5kaXJlY3Rpb24gPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXFxcblxcXFx0XFxcXHRmbG9hdCBsaWdodERpc3RhbmNlID0gbGVuZ3RoKCBsVmVjdG9yICk7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgYW5nbGVDb3MgPSBkb3QoIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiwgc3BvdExpZ2h0LmRpcmVjdGlvbiApO1xcXFxuXFxcXHRcXFxcdGlmICggYW5nbGVDb3MgPiBzcG90TGlnaHQuY29uZUNvcyApIHtcXFxcblxcXFx0XFxcXHRcXFxcdGZsb2F0IHNwb3RFZmZlY3QgPSBzbW9vdGhzdGVwKCBzcG90TGlnaHQuY29uZUNvcywgc3BvdExpZ2h0LnBlbnVtYnJhQ29zLCBhbmdsZUNvcyApO1xcXFxuXFxcXHRcXFxcdFxcXFx0ZGlyZWN0TGlnaHQuY29sb3IgPSBzcG90TGlnaHQuY29sb3I7XFxcXG5cXFxcdFxcXFx0XFxcXHRkaXJlY3RMaWdodC5jb2xvciAqPSBzcG90RWZmZWN0ICogcHVuY3R1YWxMaWdodEludGVuc2l0eVRvSXJyYWRpYW5jZUZhY3RvciggbGlnaHREaXN0YW5jZSwgc3BvdExpZ2h0LmRpc3RhbmNlLCBzcG90TGlnaHQuZGVjYXkgKTtcXFxcblxcXFx0XFxcXHRcXFxcdGRpcmVjdExpZ2h0LnZpc2libGUgPSB0cnVlO1xcXFxuXFxcXHRcXFxcdH0gZWxzZSB7XFxcXG5cXFxcdFxcXFx0XFxcXHRkaXJlY3RMaWdodC5jb2xvciA9IHZlYzMoIDAuMCApO1xcXFxuXFxcXHRcXFxcdFxcXFx0ZGlyZWN0TGlnaHQudmlzaWJsZSA9IGZhbHNlO1xcXFxuXFxcXHRcXFxcdH1cXFxcblxcXFx0fVxcXFxuI2VuZGlmXFxcXG4jaWYgTlVNX1JFQ1RfQVJFQV9MSUdIVFMgPiAwXFxcXG5cXFxcdHN0cnVjdCBSZWN0QXJlYUxpZ2h0IHtcXFxcblxcXFx0XFxcXHR2ZWMzIGNvbG9yO1xcXFxuXFxcXHRcXFxcdHZlYzMgcG9zaXRpb247XFxcXG5cXFxcdFxcXFx0dmVjMyBoYWxmV2lkdGg7XFxcXG5cXFxcdFxcXFx0dmVjMyBoYWxmSGVpZ2h0O1xcXFxuXFxcXHR9O1xcXFxuXFxcXHR1bmlmb3JtIHNhbXBsZXIyRCBsdGNNYXQ7XFxcXHR1bmlmb3JtIHNhbXBsZXIyRCBsdGNNYWc7XFxcXG5cXFxcdHVuaWZvcm0gUmVjdEFyZWFMaWdodCByZWN0QXJlYUxpZ2h0c1sgTlVNX1JFQ1RfQVJFQV9MSUdIVFMgXTtcXFxcbiNlbmRpZlxcXFxuI2lmIE5VTV9IRU1JX0xJR0hUUyA+IDBcXFxcblxcXFx0c3RydWN0IEhlbWlzcGhlcmVMaWdodCB7XFxcXG5cXFxcdFxcXFx0dmVjMyBkaXJlY3Rpb247XFxcXG5cXFxcdFxcXFx0dmVjMyBza3lDb2xvcjtcXFxcblxcXFx0XFxcXHR2ZWMzIGdyb3VuZENvbG9yO1xcXFxuXFxcXHR9O1xcXFxuXFxcXHR1bmlmb3JtIEhlbWlzcGhlcmVMaWdodCBoZW1pc3BoZXJlTGlnaHRzWyBOVU1fSEVNSV9MSUdIVFMgXTtcXFxcblxcXFx0dmVjMyBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiBIZW1pc3BoZXJlTGlnaHQgaGVtaUxpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5ICkge1xcXFxuXFxcXHRcXFxcdGZsb2F0IGRvdE5MID0gZG90KCBnZW9tZXRyeS5ub3JtYWwsIGhlbWlMaWdodC5kaXJlY3Rpb24gKTtcXFxcblxcXFx0XFxcXHRmbG9hdCBoZW1pRGlmZnVzZVdlaWdodCA9IDAuNSAqIGRvdE5MICsgMC41O1xcXFxuXFxcXHRcXFxcdHZlYzMgaXJyYWRpYW5jZSA9IG1peCggaGVtaUxpZ2h0Lmdyb3VuZENvbG9yLCBoZW1pTGlnaHQuc2t5Q29sb3IsIGhlbWlEaWZmdXNlV2VpZ2h0ICk7XFxcXG5cXFxcdFxcXFx0I2lmbmRlZiBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTXFxcXG5cXFxcdFxcXFx0XFxcXHRpcnJhZGlhbmNlICo9IFBJO1xcXFxuXFxcXHRcXFxcdCNlbmRpZlxcXFxuXFxcXHRcXFxcdHJldHVybiBpcnJhZGlhbmNlO1xcXFxuXFxcXHR9XFxcXG4jZW5kaWZcXFxcbiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgZGVmaW5lZCggUEhZU0lDQUwgKVxcXFxuXFxcXHR2ZWMzIGdldExpZ2h0UHJvYmVJbmRpcmVjdElycmFkaWFuY2UoIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIGludCBtYXhNSVBMZXZlbCApIHtcXFxcblxcXFx0XFxcXHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggZ2VvbWV0cnkubm9ybWFsLCB2aWV3TWF0cml4ICk7XFxcXG5cXFxcdFxcXFx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXFxcblxcXFx0XFxcXHRcXFxcdHZlYzMgcXVlcnlWZWMgPSB2ZWMzKCBmbGlwRW52TWFwICogd29ybGROb3JtYWwueCwgd29ybGROb3JtYWwueXogKTtcXFxcblxcXFx0XFxcXHRcXFxcdCNpZmRlZiBURVhUVVJFX0xPRF9FWFRcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlTG9kRVhUKCBlbnZNYXAsIHF1ZXJ5VmVjLCBmbG9hdCggbWF4TUlQTGV2ZWwgKSApO1xcXFxuXFxcXHRcXFxcdFxcXFx0I2Vsc2VcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIHF1ZXJ5VmVjLCBmbG9hdCggbWF4TUlQTGV2ZWwgKSApO1xcXFxuXFxcXHRcXFxcdFxcXFx0I2VuZGlmXFxcXG5cXFxcdFxcXFx0XFxcXHRlbnZNYXBDb2xvci5yZ2IgPSBlbnZNYXBUZXhlbFRvTGluZWFyKCBlbnZNYXBDb2xvciApLnJnYjtcXFxcblxcXFx0XFxcXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9DVUJFX1VWIClcXFxcblxcXFx0XFxcXHRcXFxcdHZlYzMgcXVlcnlWZWMgPSB2ZWMzKCBmbGlwRW52TWFwICogd29ybGROb3JtYWwueCwgd29ybGROb3JtYWwueXogKTtcXFxcblxcXFx0XFxcXHRcXFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZVVWKCBxdWVyeVZlYywgMS4wICk7XFxcXG5cXFxcdFxcXFx0I2Vsc2VcXFxcblxcXFx0XFxcXHRcXFxcdHZlYzQgZW52TWFwQ29sb3IgPSB2ZWM0KCAwLjAgKTtcXFxcblxcXFx0XFxcXHQjZW5kaWZcXFxcblxcXFx0XFxcXHRyZXR1cm4gUEkgKiBlbnZNYXBDb2xvci5yZ2IgKiBlbnZNYXBJbnRlbnNpdHk7XFxcXG5cXFxcdH1cXFxcblxcXFx0ZmxvYXQgZ2V0U3BlY3VsYXJNSVBMZXZlbCggY29uc3QgaW4gZmxvYXQgYmxpbm5TaGluaW5lc3NFeHBvbmVudCwgY29uc3QgaW4gaW50IG1heE1JUExldmVsICkge1xcXFxuXFxcXHRcXFxcdGZsb2F0IG1heE1JUExldmVsU2NhbGFyID0gZmxvYXQoIG1heE1JUExldmVsICk7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgZGVzaXJlZE1JUExldmVsID0gbWF4TUlQTGV2ZWxTY2FsYXIgKyAwLjc5MjQ4IC0gMC41ICogbG9nMiggcG93MiggYmxpbm5TaGluaW5lc3NFeHBvbmVudCApICsgMS4wICk7XFxcXG5cXFxcdFxcXFx0cmV0dXJuIGNsYW1wKCBkZXNpcmVkTUlQTGV2ZWwsIDAuMCwgbWF4TUlQTGV2ZWxTY2FsYXIgKTtcXFxcblxcXFx0fVxcXFxuXFxcXHR2ZWMzIGdldExpZ2h0UHJvYmVJbmRpcmVjdFJhZGlhbmNlKCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBmbG9hdCBibGlublNoaW5pbmVzc0V4cG9uZW50LCBjb25zdCBpbiBpbnQgbWF4TUlQTGV2ZWwgKSB7XFxcXG5cXFxcdFxcXFx0I2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT05cXFxcblxcXFx0XFxcXHRcXFxcdHZlYzMgcmVmbGVjdFZlYyA9IHJlZmxlY3QoIC1nZW9tZXRyeS52aWV3RGlyLCBnZW9tZXRyeS5ub3JtYWwgKTtcXFxcblxcXFx0XFxcXHQjZWxzZVxcXFxuXFxcXHRcXFxcdFxcXFx0dmVjMyByZWZsZWN0VmVjID0gcmVmcmFjdCggLWdlb21ldHJ5LnZpZXdEaXIsIGdlb21ldHJ5Lm5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XFxcXG5cXFxcdFxcXFx0I2VuZGlmXFxcXG5cXFxcdFxcXFx0cmVmbGVjdFZlYyA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIHJlZmxlY3RWZWMsIHZpZXdNYXRyaXggKTtcXFxcblxcXFx0XFxcXHRmbG9hdCBzcGVjdWxhck1JUExldmVsID0gZ2V0U3BlY3VsYXJNSVBMZXZlbCggYmxpbm5TaGluaW5lc3NFeHBvbmVudCwgbWF4TUlQTGV2ZWwgKTtcXFxcblxcXFx0XFxcXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcXFxuXFxcXHRcXFxcdFxcXFx0dmVjMyBxdWVyeVJlZmxlY3RWZWMgPSB2ZWMzKCBmbGlwRW52TWFwICogcmVmbGVjdFZlYy54LCByZWZsZWN0VmVjLnl6ICk7XFxcXG5cXFxcdFxcXFx0XFxcXHQjaWZkZWYgVEVYVFVSRV9MT0RfRVhUXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZUxvZEVYVCggZW52TWFwLCBxdWVyeVJlZmxlY3RWZWMsIHNwZWN1bGFyTUlQTGV2ZWwgKTtcXFxcblxcXFx0XFxcXHRcXFxcdCNlbHNlXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCBxdWVyeVJlZmxlY3RWZWMsIHNwZWN1bGFyTUlQTGV2ZWwgKTtcXFxcblxcXFx0XFxcXHRcXFxcdCNlbmRpZlxcXFxuXFxcXHRcXFxcdFxcXFx0ZW52TWFwQ29sb3IucmdiID0gZW52TWFwVGV4ZWxUb0xpbmVhciggZW52TWFwQ29sb3IgKS5yZ2I7XFxcXG5cXFxcdFxcXFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfQ1VCRV9VViApXFxcXG5cXFxcdFxcXFx0XFxcXHR2ZWMzIHF1ZXJ5UmVmbGVjdFZlYyA9IHZlYzMoIGZsaXBFbnZNYXAgKiByZWZsZWN0VmVjLngsIHJlZmxlY3RWZWMueXogKTtcXFxcblxcXFx0XFxcXHRcXFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZVVWKHF1ZXJ5UmVmbGVjdFZlYywgQmxpbm5FeHBvbmVudFRvR0dYUm91Z2huZXNzKGJsaW5uU2hpbmluZXNzRXhwb25lbnQpKTtcXFxcblxcXFx0XFxcXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9FUVVJUkVDIClcXFxcblxcXFx0XFxcXHRcXFxcdHZlYzIgc2FtcGxlVVY7XFxcXG5cXFxcdFxcXFx0XFxcXHRzYW1wbGVVVi55ID0gYXNpbiggY2xhbXAoIHJlZmxlY3RWZWMueSwgLSAxLjAsIDEuMCApICkgKiBSRUNJUFJPQ0FMX1BJICsgMC41O1xcXFxuXFxcXHRcXFxcdFxcXFx0c2FtcGxlVVYueCA9IGF0YW4oIHJlZmxlY3RWZWMueiwgcmVmbGVjdFZlYy54ICkgKiBSRUNJUFJPQ0FMX1BJMiArIDAuNTtcXFxcblxcXFx0XFxcXHRcXFxcdCNpZmRlZiBURVhUVVJFX0xPRF9FWFRcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmUyRExvZEVYVCggZW52TWFwLCBzYW1wbGVVViwgc3BlY3VsYXJNSVBMZXZlbCApO1xcXFxuXFxcXHRcXFxcdFxcXFx0I2Vsc2VcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmUyRCggZW52TWFwLCBzYW1wbGVVViwgc3BlY3VsYXJNSVBMZXZlbCApO1xcXFxuXFxcXHRcXFxcdFxcXFx0I2VuZGlmXFxcXG5cXFxcdFxcXFx0XFxcXHRlbnZNYXBDb2xvci5yZ2IgPSBlbnZNYXBUZXhlbFRvTGluZWFyKCBlbnZNYXBDb2xvciApLnJnYjtcXFxcblxcXFx0XFxcXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9TUEhFUkUgKVxcXFxuXFxcXHRcXFxcdFxcXFx0dmVjMyByZWZsZWN0VmlldyA9IG5vcm1hbGl6ZSggKCB2aWV3TWF0cml4ICogdmVjNCggcmVmbGVjdFZlYywgMC4wICkgKS54eXogKyB2ZWMzKCAwLjAsMC4wLDEuMCApICk7XFxcXG5cXFxcdFxcXFx0XFxcXHQjaWZkZWYgVEVYVFVSRV9MT0RfRVhUXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlMkRMb2RFWFQoIGVudk1hcCwgcmVmbGVjdFZpZXcueHkgKiAwLjUgKyAwLjUsIHNwZWN1bGFyTUlQTGV2ZWwgKTtcXFxcblxcXFx0XFxcXHRcXFxcdCNlbHNlXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlMkQoIGVudk1hcCwgcmVmbGVjdFZpZXcueHkgKiAwLjUgKyAwLjUsIHNwZWN1bGFyTUlQTGV2ZWwgKTtcXFxcblxcXFx0XFxcXHRcXFxcdCNlbmRpZlxcXFxuXFxcXHRcXFxcdFxcXFx0ZW52TWFwQ29sb3IucmdiID0gZW52TWFwVGV4ZWxUb0xpbmVhciggZW52TWFwQ29sb3IgKS5yZ2I7XFxcXG5cXFxcdFxcXFx0I2VuZGlmXFxcXG5cXFxcdFxcXFx0cmV0dXJuIGVudk1hcENvbG9yLnJnYiAqIGVudk1hcEludGVuc2l0eTtcXFxcblxcXFx0fVxcXFxuI2VuZGlmXFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBsaWdodHNfcGhvbmdfZnJhZ21lbnQgPSBcXFwiQmxpbm5QaG9uZ01hdGVyaWFsIG1hdGVyaWFsO1xcXFxubWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gZGlmZnVzZUNvbG9yLnJnYjtcXFxcbm1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgPSBzcGVjdWxhcjtcXFxcbm1hdGVyaWFsLnNwZWN1bGFyU2hpbmluZXNzID0gc2hpbmluZXNzO1xcXFxubWF0ZXJpYWwuc3BlY3VsYXJTdHJlbmd0aCA9IHNwZWN1bGFyU3RyZW5ndGg7XFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBsaWdodHNfcGhvbmdfcGFyc19mcmFnbWVudCA9IFxcXCJ2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXFxcbiNpZm5kZWYgRkxBVF9TSEFERURcXFxcblxcXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxcXG4jZW5kaWZcXFxcbnN0cnVjdCBCbGlublBob25nTWF0ZXJpYWwge1xcXFxuXFxcXHR2ZWMzXFxcXHRkaWZmdXNlQ29sb3I7XFxcXG5cXFxcdHZlYzNcXFxcdHNwZWN1bGFyQ29sb3I7XFxcXG5cXFxcdGZsb2F0XFxcXHRzcGVjdWxhclNoaW5pbmVzcztcXFxcblxcXFx0ZmxvYXRcXFxcdHNwZWN1bGFyU3RyZW5ndGg7XFxcXG59O1xcXFxudm9pZCBSRV9EaXJlY3RfQmxpbm5QaG9uZyggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gQmxpbm5QaG9uZ01hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXFxcblxcXFx0I2lmZGVmIFRPT05cXFxcblxcXFx0XFxcXHR2ZWMzIGlycmFkaWFuY2UgPSBnZXRHcmFkaWVudElycmFkaWFuY2UoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKiBkaXJlY3RMaWdodC5jb2xvcjtcXFxcblxcXFx0I2Vsc2VcXFxcblxcXFx0XFxcXHRmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKTtcXFxcblxcXFx0XFxcXHR2ZWMzIGlycmFkaWFuY2UgPSBkb3ROTCAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0I2lmbmRlZiBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTXFxcXG5cXFxcdFxcXFx0aXJyYWRpYW5jZSAqPSBQSTtcXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfRGlmZnVzZV9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXFxcblxcXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKz0gaXJyYWRpYW5jZSAqIEJSREZfU3BlY3VsYXJfQmxpbm5QaG9uZyggZGlyZWN0TGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhclNoaW5pbmVzcyApICogbWF0ZXJpYWwuc3BlY3VsYXJTdHJlbmd0aDtcXFxcbn1cXFxcbnZvaWQgUkVfSW5kaXJlY3REaWZmdXNlX0JsaW5uUGhvbmcoIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gQmxpbm5QaG9uZ01hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXFxcblxcXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0RpZmZ1c2VfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XFxcXG59XFxcXG4jZGVmaW5lIFJFX0RpcmVjdFxcXFx0XFxcXHRcXFxcdFxcXFx0UkVfRGlyZWN0X0JsaW5uUGhvbmdcXFxcbiNkZWZpbmUgUkVfSW5kaXJlY3REaWZmdXNlXFxcXHRcXFxcdFJFX0luZGlyZWN0RGlmZnVzZV9CbGlublBob25nXFxcXG4jZGVmaW5lIE1hdGVyaWFsX0xpZ2h0UHJvYmVMT0QoIG1hdGVyaWFsIClcXFxcdCgwKVxcXFxuXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgbGlnaHRzX3BoeXNpY2FsX2ZyYWdtZW50ID0gXFxcIlBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWw7XFxcXG5tYXRlcmlhbC5kaWZmdXNlQ29sb3IgPSBkaWZmdXNlQ29sb3IucmdiICogKCAxLjAgLSBtZXRhbG5lc3NGYWN0b3IgKTtcXFxcbm1hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzID0gY2xhbXAoIHJvdWdobmVzc0ZhY3RvciwgMC4wNCwgMS4wICk7XFxcXG4jaWZkZWYgU1RBTkRBUkRcXFxcblxcXFx0bWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IG1peCggdmVjMyggREVGQVVMVF9TUEVDVUxBUl9DT0VGRklDSUVOVCApLCBkaWZmdXNlQ29sb3IucmdiLCBtZXRhbG5lc3NGYWN0b3IgKTtcXFxcbiNlbHNlXFxcXG5cXFxcdG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgPSBtaXgoIHZlYzMoIE1BWElNVU1fU1BFQ1VMQVJfQ09FRkZJQ0lFTlQgKiBwb3cyKCByZWZsZWN0aXZpdHkgKSApLCBkaWZmdXNlQ29sb3IucmdiLCBtZXRhbG5lc3NGYWN0b3IgKTtcXFxcblxcXFx0bWF0ZXJpYWwuY2xlYXJDb2F0ID0gc2F0dXJhdGUoIGNsZWFyQ29hdCApO1xcXFx0bWF0ZXJpYWwuY2xlYXJDb2F0Um91Z2huZXNzID0gY2xhbXAoIGNsZWFyQ29hdFJvdWdobmVzcywgMC4wNCwgMS4wICk7XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIGxpZ2h0c19waHlzaWNhbF9wYXJzX2ZyYWdtZW50ID0gXFxcInN0cnVjdCBQaHlzaWNhbE1hdGVyaWFsIHtcXFxcblxcXFx0dmVjM1xcXFx0ZGlmZnVzZUNvbG9yO1xcXFxuXFxcXHRmbG9hdFxcXFx0c3BlY3VsYXJSb3VnaG5lc3M7XFxcXG5cXFxcdHZlYzNcXFxcdHNwZWN1bGFyQ29sb3I7XFxcXG5cXFxcdCNpZm5kZWYgU1RBTkRBUkRcXFxcblxcXFx0XFxcXHRmbG9hdCBjbGVhckNvYXQ7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgY2xlYXJDb2F0Um91Z2huZXNzO1xcXFxuXFxcXHQjZW5kaWZcXFxcbn07XFxcXG4jZGVmaW5lIE1BWElNVU1fU1BFQ1VMQVJfQ09FRkZJQ0lFTlQgMC4xNlxcXFxuI2RlZmluZSBERUZBVUxUX1NQRUNVTEFSX0NPRUZGSUNJRU5UIDAuMDRcXFxcbmZsb2F0IGNsZWFyQ29hdERIUkFwcHJveCggY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzLCBjb25zdCBpbiBmbG9hdCBkb3ROTCApIHtcXFxcblxcXFx0cmV0dXJuIERFRkFVTFRfU1BFQ1VMQVJfQ09FRkZJQ0lFTlQgKyAoIDEuMCAtIERFRkFVTFRfU1BFQ1VMQVJfQ09FRkZJQ0lFTlQgKSAqICggcG93KCAxLjAgLSBkb3ROTCwgNS4wICkgKiBwb3coIDEuMCAtIHJvdWdobmVzcywgMi4wICkgKTtcXFxcbn1cXFxcbiNpZiBOVU1fUkVDVF9BUkVBX0xJR0hUUyA+IDBcXFxcblxcXFx0dm9pZCBSRV9EaXJlY3RfUmVjdEFyZWFfUGh5c2ljYWwoIGNvbnN0IGluIFJlY3RBcmVhTGlnaHQgcmVjdEFyZWFMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxcXG5cXFxcdFxcXFx0dmVjMyBub3JtYWwgPSBnZW9tZXRyeS5ub3JtYWw7XFxcXG5cXFxcdFxcXFx0dmVjMyB2aWV3RGlyID0gZ2VvbWV0cnkudmlld0RpcjtcXFxcblxcXFx0XFxcXHR2ZWMzIHBvc2l0aW9uID0gZ2VvbWV0cnkucG9zaXRpb247XFxcXG5cXFxcdFxcXFx0dmVjMyBsaWdodFBvcyA9IHJlY3RBcmVhTGlnaHQucG9zaXRpb247XFxcXG5cXFxcdFxcXFx0dmVjMyBoYWxmV2lkdGggPSByZWN0QXJlYUxpZ2h0LmhhbGZXaWR0aDtcXFxcblxcXFx0XFxcXHR2ZWMzIGhhbGZIZWlnaHQgPSByZWN0QXJlYUxpZ2h0LmhhbGZIZWlnaHQ7XFxcXG5cXFxcdFxcXFx0dmVjMyBsaWdodENvbG9yID0gcmVjdEFyZWFMaWdodC5jb2xvcjtcXFxcblxcXFx0XFxcXHRmbG9hdCByb3VnaG5lc3MgPSBtYXRlcmlhbC5zcGVjdWxhclJvdWdobmVzcztcXFxcblxcXFx0XFxcXHR2ZWMzIHJlY3RDb29yZHNbIDQgXTtcXFxcblxcXFx0XFxcXHRyZWN0Q29vcmRzWyAwIF0gPSBsaWdodFBvcyAtIGhhbGZXaWR0aCAtIGhhbGZIZWlnaHQ7XFxcXHRcXFxcdHJlY3RDb29yZHNbIDEgXSA9IGxpZ2h0UG9zICsgaGFsZldpZHRoIC0gaGFsZkhlaWdodDtcXFxcblxcXFx0XFxcXHRyZWN0Q29vcmRzWyAyIF0gPSBsaWdodFBvcyArIGhhbGZXaWR0aCArIGhhbGZIZWlnaHQ7XFxcXG5cXFxcdFxcXFx0cmVjdENvb3Jkc1sgMyBdID0gbGlnaHRQb3MgLSBoYWxmV2lkdGggKyBoYWxmSGVpZ2h0O1xcXFxuXFxcXHRcXFxcdHZlYzIgdXYgPSBMVENfVXYoIG5vcm1hbCwgdmlld0Rpciwgcm91Z2huZXNzICk7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgbm9ybSA9IHRleHR1cmUyRCggbHRjTWFnLCB1diApLmE7XFxcXG5cXFxcdFxcXFx0dmVjNCB0ID0gdGV4dHVyZTJEKCBsdGNNYXQsIHV2ICk7XFxcXG5cXFxcdFxcXFx0bWF0MyBtSW52ID0gbWF0MyhcXFxcblxcXFx0XFxcXHRcXFxcdHZlYzMoICAgMSwgICAwLCB0LnkgKSxcXFxcblxcXFx0XFxcXHRcXFxcdHZlYzMoICAgMCwgdC56LCAgIDAgKSxcXFxcblxcXFx0XFxcXHRcXFxcdHZlYzMoIHQudywgICAwLCB0LnggKVxcXFxuXFxcXHRcXFxcdCk7XFxcXG5cXFxcdFxcXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKz0gbGlnaHRDb2xvciAqIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgKiBub3JtICogTFRDX0V2YWx1YXRlKCBub3JtYWwsIHZpZXdEaXIsIHBvc2l0aW9uLCBtSW52LCByZWN0Q29vcmRzICk7XFxcXG5cXFxcdFxcXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArPSBsaWdodENvbG9yICogbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICogTFRDX0V2YWx1YXRlKCBub3JtYWwsIHZpZXdEaXIsIHBvc2l0aW9uLCBtYXQzKCAxICksIHJlY3RDb29yZHMgKTtcXFxcblxcXFx0fVxcXFxuI2VuZGlmXFxcXG52b2lkIFJFX0RpcmVjdF9QaHlzaWNhbCggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxcXG5cXFxcdGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSApO1xcXFxuXFxcXHR2ZWMzIGlycmFkaWFuY2UgPSBkb3ROTCAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcXFxuXFxcXHQjaWZuZGVmIFBIWVNJQ0FMTFlfQ09SUkVDVF9MSUdIVFNcXFxcblxcXFx0XFxcXHRpcnJhZGlhbmNlICo9IFBJO1xcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0I2lmbmRlZiBTVEFOREFSRFxcXFxuXFxcXHRcXFxcdGZsb2F0IGNsZWFyQ29hdERIUiA9IG1hdGVyaWFsLmNsZWFyQ29hdCAqIGNsZWFyQ29hdERIUkFwcHJveCggbWF0ZXJpYWwuY2xlYXJDb2F0Um91Z2huZXNzLCBkb3ROTCApO1xcXFxuXFxcXHQjZWxzZVxcXFxuXFxcXHRcXFxcdGZsb2F0IGNsZWFyQ29hdERIUiA9IDAuMDtcXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICs9ICggMS4wIC0gY2xlYXJDb2F0REhSICkgKiBpcnJhZGlhbmNlICogQlJERl9TcGVjdWxhcl9HR1goIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MgKTtcXFxcblxcXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArPSAoIDEuMCAtIGNsZWFyQ29hdERIUiApICogaXJyYWRpYW5jZSAqIEJSREZfRGlmZnVzZV9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXFxcblxcXFx0I2lmbmRlZiBTVEFOREFSRFxcXFxuXFxcXHRcXFxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICs9IGlycmFkaWFuY2UgKiBtYXRlcmlhbC5jbGVhckNvYXQgKiBCUkRGX1NwZWN1bGFyX0dHWCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5LCB2ZWMzKCBERUZBVUxUX1NQRUNVTEFSX0NPRUZGSUNJRU5UICksIG1hdGVyaWFsLmNsZWFyQ29hdFJvdWdobmVzcyApO1xcXFxuXFxcXHQjZW5kaWZcXFxcbn1cXFxcbnZvaWQgUkVfSW5kaXJlY3REaWZmdXNlX1BoeXNpY2FsKCBjb25zdCBpbiB2ZWMzIGlycmFkaWFuY2UsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcXFxuXFxcXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfRGlmZnVzZV9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXFxcbn1cXFxcbnZvaWQgUkVfSW5kaXJlY3RTcGVjdWxhcl9QaHlzaWNhbCggY29uc3QgaW4gdmVjMyByYWRpYW5jZSwgY29uc3QgaW4gdmVjMyBjbGVhckNvYXRSYWRpYW5jZSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxcXG5cXFxcdCNpZm5kZWYgU1RBTkRBUkRcXFxcblxcXFx0XFxcXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZ2VvbWV0cnkudmlld0RpciApICk7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgZG90TkwgPSBkb3ROVjtcXFxcblxcXFx0XFxcXHRmbG9hdCBjbGVhckNvYXRESFIgPSBtYXRlcmlhbC5jbGVhckNvYXQgKiBjbGVhckNvYXRESFJBcHByb3goIG1hdGVyaWFsLmNsZWFyQ29hdFJvdWdobmVzcywgZG90TkwgKTtcXFxcblxcXFx0I2Vsc2VcXFxcblxcXFx0XFxcXHRmbG9hdCBjbGVhckNvYXRESFIgPSAwLjA7XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyICs9ICggMS4wIC0gY2xlYXJDb2F0REhSICkgKiByYWRpYW5jZSAqIEJSREZfU3BlY3VsYXJfR0dYX0Vudmlyb25tZW50KCBnZW9tZXRyeSwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MgKTtcXFxcblxcXFx0I2lmbmRlZiBTVEFOREFSRFxcXFxuXFxcXHRcXFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKz0gY2xlYXJDb2F0UmFkaWFuY2UgKiBtYXRlcmlhbC5jbGVhckNvYXQgKiBCUkRGX1NwZWN1bGFyX0dHWF9FbnZpcm9ubWVudCggZ2VvbWV0cnksIHZlYzMoIERFRkFVTFRfU1BFQ1VMQVJfQ09FRkZJQ0lFTlQgKSwgbWF0ZXJpYWwuY2xlYXJDb2F0Um91Z2huZXNzICk7XFxcXG5cXFxcdCNlbmRpZlxcXFxufVxcXFxuI2RlZmluZSBSRV9EaXJlY3RcXFxcdFxcXFx0XFxcXHRcXFxcdFJFX0RpcmVjdF9QaHlzaWNhbFxcXFxuI2RlZmluZSBSRV9EaXJlY3RfUmVjdEFyZWFcXFxcdFxcXFx0UkVfRGlyZWN0X1JlY3RBcmVhX1BoeXNpY2FsXFxcXG4jZGVmaW5lIFJFX0luZGlyZWN0RGlmZnVzZVxcXFx0XFxcXHRSRV9JbmRpcmVjdERpZmZ1c2VfUGh5c2ljYWxcXFxcbiNkZWZpbmUgUkVfSW5kaXJlY3RTcGVjdWxhclxcXFx0XFxcXHRSRV9JbmRpcmVjdFNwZWN1bGFyX1BoeXNpY2FsXFxcXG4jZGVmaW5lIE1hdGVyaWFsX0JsaW5uU2hpbmluZXNzRXhwb25lbnQoIG1hdGVyaWFsICkgICBHR1hSb3VnaG5lc3NUb0JsaW5uRXhwb25lbnQoIG1hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzIClcXFxcbiNkZWZpbmUgTWF0ZXJpYWxfQ2xlYXJDb2F0X0JsaW5uU2hpbmluZXNzRXhwb25lbnQoIG1hdGVyaWFsICkgICBHR1hSb3VnaG5lc3NUb0JsaW5uRXhwb25lbnQoIG1hdGVyaWFsLmNsZWFyQ29hdFJvdWdobmVzcyApXFxcXG5mbG9hdCBjb21wdXRlU3BlY3VsYXJPY2NsdXNpb24oIGNvbnN0IGluIGZsb2F0IGRvdE5WLCBjb25zdCBpbiBmbG9hdCBhbWJpZW50T2NjbHVzaW9uLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7XFxcXG5cXFxcdHJldHVybiBzYXR1cmF0ZSggcG93KCBkb3ROViArIGFtYmllbnRPY2NsdXNpb24sIGV4cDIoIC0gMTYuMCAqIHJvdWdobmVzcyAtIDEuMCApICkgLSAxLjAgKyBhbWJpZW50T2NjbHVzaW9uICk7XFxcXG59XFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBsaWdodHNfdGVtcGxhdGUgPSBcXFwiXFxcXG5HZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5O1xcXFxuZ2VvbWV0cnkucG9zaXRpb24gPSAtIHZWaWV3UG9zaXRpb247XFxcXG5nZW9tZXRyeS5ub3JtYWwgPSBub3JtYWw7XFxcXG5nZW9tZXRyeS52aWV3RGlyID0gbm9ybWFsaXplKCB2Vmlld1Bvc2l0aW9uICk7XFxcXG5JbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0O1xcXFxuI2lmICggTlVNX1BPSU5UX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3QgKVxcXFxuXFxcXHRQb2ludExpZ2h0IHBvaW50TGlnaHQ7XFxcXG5cXFxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XFxcXG5cXFxcdFxcXFx0cG9pbnRMaWdodCA9IHBvaW50TGlnaHRzWyBpIF07XFxcXG5cXFxcdFxcXFx0Z2V0UG9pbnREaXJlY3RMaWdodElycmFkaWFuY2UoIHBvaW50TGlnaHQsIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xcXFxuXFxcXHRcXFxcdCNpZmRlZiBVU0VfU0hBRE9XTUFQXFxcXG5cXFxcdFxcXFx0ZGlyZWN0TGlnaHQuY29sb3IgKj0gYWxsKCBidmVjMiggcG9pbnRMaWdodC5zaGFkb3csIGRpcmVjdExpZ2h0LnZpc2libGUgKSApID8gZ2V0UG9pbnRTaGFkb3coIHBvaW50U2hhZG93TWFwWyBpIF0sIHBvaW50TGlnaHQuc2hhZG93TWFwU2l6ZSwgcG9pbnRMaWdodC5zaGFkb3dCaWFzLCBwb2ludExpZ2h0LnNoYWRvd1JhZGl1cywgdlBvaW50U2hhZG93Q29vcmRbIGkgXSwgcG9pbnRMaWdodC5zaGFkb3dDYW1lcmFOZWFyLCBwb2ludExpZ2h0LnNoYWRvd0NhbWVyYUZhciApIDogMS4wO1xcXFxuXFxcXHRcXFxcdCNlbmRpZlxcXFxuXFxcXHRcXFxcdFJFX0RpcmVjdCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXFxcblxcXFx0fVxcXFxuI2VuZGlmXFxcXG4jaWYgKCBOVU1fU1BPVF9MSUdIVFMgPiAwICkgJiYgZGVmaW5lZCggUkVfRGlyZWN0IClcXFxcblxcXFx0U3BvdExpZ2h0IHNwb3RMaWdodDtcXFxcblxcXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRTOyBpICsrICkge1xcXFxuXFxcXHRcXFxcdHNwb3RMaWdodCA9IHNwb3RMaWdodHNbIGkgXTtcXFxcblxcXFx0XFxcXHRnZXRTcG90RGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBzcG90TGlnaHQsIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xcXFxuXFxcXHRcXFxcdCNpZmRlZiBVU0VfU0hBRE9XTUFQXFxcXG5cXFxcdFxcXFx0ZGlyZWN0TGlnaHQuY29sb3IgKj0gYWxsKCBidmVjMiggc3BvdExpZ2h0LnNoYWRvdywgZGlyZWN0TGlnaHQudmlzaWJsZSApICkgPyBnZXRTaGFkb3coIHNwb3RTaGFkb3dNYXBbIGkgXSwgc3BvdExpZ2h0LnNoYWRvd01hcFNpemUsIHNwb3RMaWdodC5zaGFkb3dCaWFzLCBzcG90TGlnaHQuc2hhZG93UmFkaXVzLCB2U3BvdFNoYWRvd0Nvb3JkWyBpIF0gKSA6IDEuMDtcXFxcblxcXFx0XFxcXHQjZW5kaWZcXFxcblxcXFx0XFxcXHRSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxcXG5cXFxcdH1cXFxcbiNlbmRpZlxcXFxuI2lmICggTlVNX0RJUl9MSUdIVFMgPiAwICkgJiYgZGVmaW5lZCggUkVfRGlyZWN0IClcXFxcblxcXFx0RGlyZWN0aW9uYWxMaWdodCBkaXJlY3Rpb25hbExpZ2h0O1xcXFxuXFxcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fRElSX0xJR0hUUzsgaSArKyApIHtcXFxcblxcXFx0XFxcXHRkaXJlY3Rpb25hbExpZ2h0ID0gZGlyZWN0aW9uYWxMaWdodHNbIGkgXTtcXFxcblxcXFx0XFxcXHRnZXREaXJlY3Rpb25hbERpcmVjdExpZ2h0SXJyYWRpYW5jZSggZGlyZWN0aW9uYWxMaWdodCwgZ2VvbWV0cnksIGRpcmVjdExpZ2h0ICk7XFxcXG5cXFxcdFxcXFx0I2lmZGVmIFVTRV9TSEFET1dNQVBcXFxcblxcXFx0XFxcXHRkaXJlY3RMaWdodC5jb2xvciAqPSBhbGwoIGJ2ZWMyKCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvdywgZGlyZWN0TGlnaHQudmlzaWJsZSApICkgPyBnZXRTaGFkb3coIGRpcmVjdGlvbmFsU2hhZG93TWFwWyBpIF0sIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93TWFwU2l6ZSwgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dCaWFzLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd1JhZGl1cywgdkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIGkgXSApIDogMS4wO1xcXFxuXFxcXHRcXFxcdCNlbmRpZlxcXFxuXFxcXHRcXFxcdFJFX0RpcmVjdCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXFxcblxcXFx0fVxcXFxuI2VuZGlmXFxcXG4jaWYgKCBOVU1fUkVDVF9BUkVBX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3RfUmVjdEFyZWEgKVxcXFxuXFxcXHRSZWN0QXJlYUxpZ2h0IHJlY3RBcmVhTGlnaHQ7XFxcXG5cXFxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9SRUNUX0FSRUFfTElHSFRTOyBpICsrICkge1xcXFxuXFxcXHRcXFxcdHJlY3RBcmVhTGlnaHQgPSByZWN0QXJlYUxpZ2h0c1sgaSBdO1xcXFxuXFxcXHRcXFxcdFJFX0RpcmVjdF9SZWN0QXJlYSggcmVjdEFyZWFMaWdodCwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcXFxuXFxcXHR9XFxcXG4jZW5kaWZcXFxcbiNpZiBkZWZpbmVkKCBSRV9JbmRpcmVjdERpZmZ1c2UgKVxcXFxuXFxcXHR2ZWMzIGlycmFkaWFuY2UgPSBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBhbWJpZW50TGlnaHRDb2xvciApO1xcXFxuXFxcXHQjaWZkZWYgVVNFX0xJR0hUTUFQXFxcXG5cXFxcdFxcXFx0dmVjMyBsaWdodE1hcElycmFkaWFuY2UgPSB0ZXh0dXJlMkQoIGxpZ2h0TWFwLCB2VXYyICkueHl6ICogbGlnaHRNYXBJbnRlbnNpdHk7XFxcXG5cXFxcdFxcXFx0I2lmbmRlZiBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTXFxcXG5cXFxcdFxcXFx0XFxcXHRsaWdodE1hcElycmFkaWFuY2UgKj0gUEk7XFxcXG5cXFxcdFxcXFx0I2VuZGlmXFxcXG5cXFxcdFxcXFx0aXJyYWRpYW5jZSArPSBsaWdodE1hcElycmFkaWFuY2U7XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHQjaWYgKCBOVU1fSEVNSV9MSUdIVFMgPiAwIClcXFxcblxcXFx0XFxcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fSEVNSV9MSUdIVFM7IGkgKysgKSB7XFxcXG5cXFxcdFxcXFx0XFxcXHRpcnJhZGlhbmNlICs9IGdldEhlbWlzcGhlcmVMaWdodElycmFkaWFuY2UoIGhlbWlzcGhlcmVMaWdodHNbIGkgXSwgZ2VvbWV0cnkgKTtcXFxcblxcXFx0XFxcXHR9XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHQjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFBIWVNJQ0FMICkgJiYgZGVmaW5lZCggRU5WTUFQX1RZUEVfQ1VCRV9VViApXFxcXG5cXFxcdFxcXFx0aXJyYWRpYW5jZSArPSBnZXRMaWdodFByb2JlSW5kaXJlY3RJcnJhZGlhbmNlKCBnZW9tZXRyeSwgOCApO1xcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0UkVfSW5kaXJlY3REaWZmdXNlKCBpcnJhZGlhbmNlLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxcXG4jZW5kaWZcXFxcbiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgZGVmaW5lZCggUkVfSW5kaXJlY3RTcGVjdWxhciApXFxcXG5cXFxcdHZlYzMgcmFkaWFuY2UgPSBnZXRMaWdodFByb2JlSW5kaXJlY3RSYWRpYW5jZSggZ2VvbWV0cnksIE1hdGVyaWFsX0JsaW5uU2hpbmluZXNzRXhwb25lbnQoIG1hdGVyaWFsICksIDggKTtcXFxcblxcXFx0I2lmbmRlZiBTVEFOREFSRFxcXFxuXFxcXHRcXFxcdHZlYzMgY2xlYXJDb2F0UmFkaWFuY2UgPSBnZXRMaWdodFByb2JlSW5kaXJlY3RSYWRpYW5jZSggZ2VvbWV0cnksIE1hdGVyaWFsX0NsZWFyQ29hdF9CbGlublNoaW5pbmVzc0V4cG9uZW50KCBtYXRlcmlhbCApLCA4ICk7XFxcXG5cXFxcdCNlbHNlXFxcXG5cXFxcdFxcXFx0dmVjMyBjbGVhckNvYXRSYWRpYW5jZSA9IHZlYzMoIDAuMCApO1xcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0UkVfSW5kaXJlY3RTcGVjdWxhciggcmFkaWFuY2UsIGNsZWFyQ29hdFJhZGlhbmNlLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIGxvZ2RlcHRoYnVmX2ZyYWdtZW50ID0gXFxcIiNpZiBkZWZpbmVkKCBVU0VfTE9HREVQVEhCVUYgKSAmJiBkZWZpbmVkKCBVU0VfTE9HREVQVEhCVUZfRVhUIClcXFxcblxcXFx0Z2xfRnJhZ0RlcHRoRVhUID0gbG9nMiggdkZyYWdEZXB0aCApICogbG9nRGVwdGhCdWZGQyAqIDAuNTtcXFxcbiNlbmRpZlxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQgPSBcXFwiI2lmZGVmIFVTRV9MT0dERVBUSEJVRlxcXFxuXFxcXHR1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XFxcXG5cXFxcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxcXG5cXFxcdFxcXFx0dmFyeWluZyBmbG9hdCB2RnJhZ0RlcHRoO1xcXFxuXFxcXHQjZW5kaWZcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgbG9nZGVwdGhidWZfcGFyc192ZXJ0ZXggPSBcXFwiI2lmZGVmIFVTRV9MT0dERVBUSEJVRlxcXFxuXFxcXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcXFxuXFxcXHRcXFxcdHZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdHVuaWZvcm0gZmxvYXQgbG9nRGVwdGhCdWZGQztcXFxcbiNlbmRpZlxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIGxvZ2RlcHRoYnVmX3ZlcnRleCA9IFxcXCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxcXG5cXFxcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxcXG5cXFxcdFxcXFx0dkZyYWdEZXB0aCA9IDEuMCArIGdsX1Bvc2l0aW9uLnc7XFxcXG5cXFxcdCNlbHNlXFxcXG5cXFxcdFxcXFx0Z2xfUG9zaXRpb24ueiA9IGxvZzIoIG1heCggRVBTSUxPTiwgZ2xfUG9zaXRpb24udyArIDEuMCApICkgKiBsb2dEZXB0aEJ1ZkZDIC0gMS4wO1xcXFxuXFxcXHRcXFxcdGdsX1Bvc2l0aW9uLnogKj0gZ2xfUG9zaXRpb24udztcXFxcblxcXFx0I2VuZGlmXFxcXG4jZW5kaWZcXFxcblxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIG1hcF9mcmFnbWVudCA9IFxcXCIjaWZkZWYgVVNFX01BUFxcXFxuXFxcXHR2ZWM0IHRleGVsQ29sb3IgPSB0ZXh0dXJlMkQoIG1hcCwgdlV2ICk7XFxcXG5cXFxcdHRleGVsQ29sb3IgPSBtYXBUZXhlbFRvTGluZWFyKCB0ZXhlbENvbG9yICk7XFxcXG5cXFxcdGRpZmZ1c2VDb2xvciAqPSB0ZXhlbENvbG9yO1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBtYXBfcGFyc19mcmFnbWVudCA9IFxcXCIjaWZkZWYgVVNFX01BUFxcXFxuXFxcXHR1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIG1hcF9wYXJ0aWNsZV9mcmFnbWVudCA9IFxcXCIjaWZkZWYgVVNFX01BUFxcXFxuXFxcXHR2ZWMyIHV2ID0gKCB1dlRyYW5zZm9ybSAqIHZlYzMoIGdsX1BvaW50Q29vcmQueCwgMS4wIC0gZ2xfUG9pbnRDb29yZC55LCAxICkgKS54eTtcXFxcblxcXFx0dmVjNCBtYXBUZXhlbCA9IHRleHR1cmUyRCggbWFwLCB1diApO1xcXFxuXFxcXHRkaWZmdXNlQ29sb3IgKj0gbWFwVGV4ZWxUb0xpbmVhciggbWFwVGV4ZWwgKTtcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgbWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQgPSBcXFwiI2lmZGVmIFVTRV9NQVBcXFxcblxcXFx0dW5pZm9ybSBtYXQzIHV2VHJhbnNmb3JtO1xcXFxuXFxcXHR1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIG1ldGFsbmVzc21hcF9mcmFnbWVudCA9IFxcXCJmbG9hdCBtZXRhbG5lc3NGYWN0b3IgPSBtZXRhbG5lc3M7XFxcXG4jaWZkZWYgVVNFX01FVEFMTkVTU01BUFxcXFxuXFxcXHR2ZWM0IHRleGVsTWV0YWxuZXNzID0gdGV4dHVyZTJEKCBtZXRhbG5lc3NNYXAsIHZVdiApO1xcXFxuXFxcXHRtZXRhbG5lc3NGYWN0b3IgKj0gdGV4ZWxNZXRhbG5lc3MuYjtcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgbWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQgPSBcXFwiI2lmZGVmIFVTRV9NRVRBTE5FU1NNQVBcXFxcblxcXFx0dW5pZm9ybSBzYW1wbGVyMkQgbWV0YWxuZXNzTWFwO1xcXFxuI2VuZGlmXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgbW9ycGhub3JtYWxfdmVydGV4ID0gXFxcIiNpZmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxcXG5cXFxcdG9iamVjdE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMCAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAwIF07XFxcXG5cXFxcdG9iamVjdE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMSAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAxIF07XFxcXG5cXFxcdG9iamVjdE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMiAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAyIF07XFxcXG5cXFxcdG9iamVjdE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMyAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAzIF07XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4ID0gXFxcIiNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXFxcXG5cXFxcdCNpZm5kZWYgVVNFX01PUlBITk9STUFMU1xcXFxuXFxcXHR1bmlmb3JtIGZsb2F0IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgOCBdO1xcXFxuXFxcXHQjZWxzZVxcXFxuXFxcXHR1bmlmb3JtIGZsb2F0IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNCBdO1xcXFxuXFxcXHQjZW5kaWZcXFxcbiNlbmRpZlxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIG1vcnBodGFyZ2V0X3ZlcnRleCA9IFxcXCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcXFxuXFxcXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0MCAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDAgXTtcXFxcblxcXFx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDEgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAxIF07XFxcXG5cXFxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQyIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMiBdO1xcXFxuXFxcXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0MyAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDMgXTtcXFxcblxcXFx0I2lmbmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxcXG5cXFxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ0IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNCBdO1xcXFxuXFxcXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0NSAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDUgXTtcXFxcblxcXFx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDYgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA2IF07XFxcXG5cXFxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ3IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNyBdO1xcXFxuXFxcXHQjZW5kaWZcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgbm9ybWFsX2ZyYWdtZW50ID0gXFxcIiNpZmRlZiBGTEFUX1NIQURFRFxcXFxuXFxcXHR2ZWMzIGZkeCA9IHZlYzMoIGRGZHgoIHZWaWV3UG9zaXRpb24ueCApLCBkRmR4KCB2Vmlld1Bvc2l0aW9uLnkgKSwgZEZkeCggdlZpZXdQb3NpdGlvbi56ICkgKTtcXFxcblxcXFx0dmVjMyBmZHkgPSB2ZWMzKCBkRmR5KCB2Vmlld1Bvc2l0aW9uLnggKSwgZEZkeSggdlZpZXdQb3NpdGlvbi55ICksIGRGZHkoIHZWaWV3UG9zaXRpb24ueiApICk7XFxcXG5cXFxcdHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCBjcm9zcyggZmR4LCBmZHkgKSApO1xcXFxuI2Vsc2VcXFxcblxcXFx0dmVjMyBub3JtYWwgPSBub3JtYWxpemUoIHZOb3JtYWwgKTtcXFxcblxcXFx0I2lmZGVmIERPVUJMRV9TSURFRFxcXFxuXFxcXHRcXFxcdG5vcm1hbCA9IG5vcm1hbCAqICggZmxvYXQoIGdsX0Zyb250RmFjaW5nICkgKiAyLjAgLSAxLjAgKTtcXFxcblxcXFx0I2VuZGlmXFxcXG4jZW5kaWZcXFxcbiNpZmRlZiBVU0VfTk9STUFMTUFQXFxcXG5cXFxcdG5vcm1hbCA9IHBlcnR1cmJOb3JtYWwyQXJiKCAtdlZpZXdQb3NpdGlvbiwgbm9ybWFsICk7XFxcXG4jZWxpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApXFxcXG5cXFxcdG5vcm1hbCA9IHBlcnR1cmJOb3JtYWxBcmIoIC12Vmlld1Bvc2l0aW9uLCBub3JtYWwsIGRIZHh5X2Z3ZCgpICk7XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50ID0gXFxcIiNpZmRlZiBVU0VfTk9STUFMTUFQXFxcXG5cXFxcdHVuaWZvcm0gc2FtcGxlcjJEIG5vcm1hbE1hcDtcXFxcblxcXFx0dW5pZm9ybSB2ZWMyIG5vcm1hbFNjYWxlO1xcXFxuXFxcXHR2ZWMzIHBlcnR1cmJOb3JtYWwyQXJiKCB2ZWMzIGV5ZV9wb3MsIHZlYzMgc3VyZl9ub3JtICkge1xcXFxuXFxcXHRcXFxcdHZlYzMgcTAgPSB2ZWMzKCBkRmR4KCBleWVfcG9zLnggKSwgZEZkeCggZXllX3Bvcy55ICksIGRGZHgoIGV5ZV9wb3MueiApICk7XFxcXG5cXFxcdFxcXFx0dmVjMyBxMSA9IHZlYzMoIGRGZHkoIGV5ZV9wb3MueCApLCBkRmR5KCBleWVfcG9zLnkgKSwgZEZkeSggZXllX3Bvcy56ICkgKTtcXFxcblxcXFx0XFxcXHR2ZWMyIHN0MCA9IGRGZHgoIHZVdi5zdCApO1xcXFxuXFxcXHRcXFxcdHZlYzIgc3QxID0gZEZkeSggdlV2LnN0ICk7XFxcXG5cXFxcdFxcXFx0dmVjMyBTID0gbm9ybWFsaXplKCBxMCAqIHN0MS50IC0gcTEgKiBzdDAudCApO1xcXFxuXFxcXHRcXFxcdHZlYzMgVCA9IG5vcm1hbGl6ZSggLXEwICogc3QxLnMgKyBxMSAqIHN0MC5zICk7XFxcXG5cXFxcdFxcXFx0dmVjMyBOID0gbm9ybWFsaXplKCBzdXJmX25vcm0gKTtcXFxcblxcXFx0XFxcXHR2ZWMzIG1hcE4gPSB0ZXh0dXJlMkQoIG5vcm1hbE1hcCwgdlV2ICkueHl6ICogMi4wIC0gMS4wO1xcXFxuXFxcXHRcXFxcdG1hcE4ueHkgPSBub3JtYWxTY2FsZSAqIG1hcE4ueHk7XFxcXG5cXFxcdFxcXFx0bWF0MyB0c24gPSBtYXQzKCBTLCBULCBOICk7XFxcXG5cXFxcdFxcXFx0cmV0dXJuIG5vcm1hbGl6ZSggdHNuICogbWFwTiApO1xcXFxuXFxcXHR9XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIHBhY2tpbmcgPSBcXFwidmVjMyBwYWNrTm9ybWFsVG9SR0IoIGNvbnN0IGluIHZlYzMgbm9ybWFsICkge1xcXFxuXFxcXHRyZXR1cm4gbm9ybWFsaXplKCBub3JtYWwgKSAqIDAuNSArIDAuNTtcXFxcbn1cXFxcbnZlYzMgdW5wYWNrUkdCVG9Ob3JtYWwoIGNvbnN0IGluIHZlYzMgcmdiICkge1xcXFxuXFxcXHRyZXR1cm4gMi4wICogcmdiLnh5eiAtIDEuMDtcXFxcbn1cXFxcbmNvbnN0IGZsb2F0IFBhY2tVcHNjYWxlID0gMjU2LiAvIDI1NS47Y29uc3QgZmxvYXQgVW5wYWNrRG93bnNjYWxlID0gMjU1LiAvIDI1Ni47XFxcXG5jb25zdCB2ZWMzIFBhY2tGYWN0b3JzID0gdmVjMyggMjU2LiAqIDI1Ni4gKiAyNTYuLCAyNTYuICogMjU2LiwgIDI1Ni4gKTtcXFxcbmNvbnN0IHZlYzQgVW5wYWNrRmFjdG9ycyA9IFVucGFja0Rvd25zY2FsZSAvIHZlYzQoIFBhY2tGYWN0b3JzLCAxLiApO1xcXFxuY29uc3QgZmxvYXQgU2hpZnRSaWdodDggPSAxLiAvIDI1Ni47XFxcXG52ZWM0IHBhY2tEZXB0aFRvUkdCQSggY29uc3QgaW4gZmxvYXQgdiApIHtcXFxcblxcXFx0dmVjNCByID0gdmVjNCggZnJhY3QoIHYgKiBQYWNrRmFjdG9ycyApLCB2ICk7XFxcXG5cXFxcdHIueXp3IC09IHIueHl6ICogU2hpZnRSaWdodDg7XFxcXHRyZXR1cm4gciAqIFBhY2tVcHNjYWxlO1xcXFxufVxcXFxuZmxvYXQgdW5wYWNrUkdCQVRvRGVwdGgoIGNvbnN0IGluIHZlYzQgdiApIHtcXFxcblxcXFx0cmV0dXJuIGRvdCggdiwgVW5wYWNrRmFjdG9ycyApO1xcXFxufVxcXFxuZmxvYXQgdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKCBjb25zdCBpbiBmbG9hdCB2aWV3WiwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkge1xcXFxuXFxcXHRyZXR1cm4gKCB2aWV3WiArIG5lYXIgKSAvICggbmVhciAtIGZhciApO1xcXFxufVxcXFxuZmxvYXQgb3J0aG9ncmFwaGljRGVwdGhUb1ZpZXdaKCBjb25zdCBpbiBmbG9hdCBsaW5lYXJDbGlwWiwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkge1xcXFxuXFxcXHRyZXR1cm4gbGluZWFyQ2xpcFogKiAoIG5lYXIgLSBmYXIgKSAtIG5lYXI7XFxcXG59XFxcXG5mbG9hdCB2aWV3WlRvUGVyc3BlY3RpdmVEZXB0aCggY29uc3QgaW4gZmxvYXQgdmlld1osIGNvbnN0IGluIGZsb2F0IG5lYXIsIGNvbnN0IGluIGZsb2F0IGZhciApIHtcXFxcblxcXFx0cmV0dXJuICgoIG5lYXIgKyB2aWV3WiApICogZmFyICkgLyAoKCBmYXIgLSBuZWFyICkgKiB2aWV3WiApO1xcXFxufVxcXFxuZmxvYXQgcGVyc3BlY3RpdmVEZXB0aFRvVmlld1ooIGNvbnN0IGluIGZsb2F0IGludkNsaXBaLCBjb25zdCBpbiBmbG9hdCBuZWFyLCBjb25zdCBpbiBmbG9hdCBmYXIgKSB7XFxcXG5cXFxcdHJldHVybiAoIG5lYXIgKiBmYXIgKSAvICggKCBmYXIgLSBuZWFyICkgKiBpbnZDbGlwWiAtIGZhciApO1xcXFxufVxcXFxuXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgcHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudCA9IFxcXCIjaWZkZWYgUFJFTVVMVElQTElFRF9BTFBIQVxcXFxuXFxcXHRnbF9GcmFnQ29sb3IucmdiICo9IGdsX0ZyYWdDb2xvci5hO1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBwcm9qZWN0X3ZlcnRleCA9IFxcXCJ2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7XFxcXG5nbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1xcXFxuXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgZGl0aGVyaW5nX2ZyYWdtZW50ID0gXFxcIiNpZiBkZWZpbmVkKCBESVRIRVJJTkcgKVxcXFxuICBnbF9GcmFnQ29sb3IucmdiID0gZGl0aGVyaW5nKCBnbF9GcmFnQ29sb3IucmdiICk7XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50ID0gXFxcIiNpZiBkZWZpbmVkKCBESVRIRVJJTkcgKVxcXFxuXFxcXHR2ZWMzIGRpdGhlcmluZyggdmVjMyBjb2xvciApIHtcXFxcblxcXFx0XFxcXHRmbG9hdCBncmlkX3Bvc2l0aW9uID0gcmFuZCggZ2xfRnJhZ0Nvb3JkLnh5ICk7XFxcXG5cXFxcdFxcXFx0dmVjMyBkaXRoZXJfc2hpZnRfUkdCID0gdmVjMyggMC4yNSAvIDI1NS4wLCAtMC4yNSAvIDI1NS4wLCAwLjI1IC8gMjU1LjAgKTtcXFxcblxcXFx0XFxcXHRkaXRoZXJfc2hpZnRfUkdCID0gbWl4KCAyLjAgKiBkaXRoZXJfc2hpZnRfUkdCLCAtMi4wICogZGl0aGVyX3NoaWZ0X1JHQiwgZ3JpZF9wb3NpdGlvbiApO1xcXFxuXFxcXHRcXFxcdHJldHVybiBjb2xvciArIGRpdGhlcl9zaGlmdF9SR0I7XFxcXG5cXFxcdH1cXFxcbiNlbmRpZlxcXFxuXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgcm91Z2huZXNzbWFwX2ZyYWdtZW50ID0gXFxcImZsb2F0IHJvdWdobmVzc0ZhY3RvciA9IHJvdWdobmVzcztcXFxcbiNpZmRlZiBVU0VfUk9VR0hORVNTTUFQXFxcXG5cXFxcdHZlYzQgdGV4ZWxSb3VnaG5lc3MgPSB0ZXh0dXJlMkQoIHJvdWdobmVzc01hcCwgdlV2ICk7XFxcXG5cXFxcdHJvdWdobmVzc0ZhY3RvciAqPSB0ZXhlbFJvdWdobmVzcy5nO1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciByb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudCA9IFxcXCIjaWZkZWYgVVNFX1JPVUdITkVTU01BUFxcXFxuXFxcXHR1bmlmb3JtIHNhbXBsZXIyRCByb3VnaG5lc3NNYXA7XFxcXG4jZW5kaWZcXFwiO1xcclxcblxcclxcblxcdHZhciBzaGFkb3dtYXBfcGFyc19mcmFnbWVudCA9IFxcXCIjaWZkZWYgVVNFX1NIQURPV01BUFxcXFxuXFxcXHQjaWYgTlVNX0RJUl9MSUdIVFMgPiAwXFxcXG5cXFxcdFxcXFx0dW5pZm9ybSBzYW1wbGVyMkQgZGlyZWN0aW9uYWxTaGFkb3dNYXBbIE5VTV9ESVJfTElHSFRTIF07XFxcXG5cXFxcdFxcXFx0dmFyeWluZyB2ZWM0IHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBOVU1fRElSX0xJR0hUUyBdO1xcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0I2lmIE5VTV9TUE9UX0xJR0hUUyA+IDBcXFxcblxcXFx0XFxcXHR1bmlmb3JtIHNhbXBsZXIyRCBzcG90U2hhZG93TWFwWyBOVU1fU1BPVF9MSUdIVFMgXTtcXFxcblxcXFx0XFxcXHR2YXJ5aW5nIHZlYzQgdlNwb3RTaGFkb3dDb29yZFsgTlVNX1NQT1RfTElHSFRTIF07XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHQjaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXFxcblxcXFx0XFxcXHR1bmlmb3JtIHNhbXBsZXIyRCBwb2ludFNoYWRvd01hcFsgTlVNX1BPSU5UX0xJR0hUUyBdO1xcXFxuXFxcXHRcXFxcdHZhcnlpbmcgdmVjNCB2UG9pbnRTaGFkb3dDb29yZFsgTlVNX1BPSU5UX0xJR0hUUyBdO1xcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0ZmxvYXQgdGV4dHVyZTJEQ29tcGFyZSggc2FtcGxlcjJEIGRlcHRocywgdmVjMiB1diwgZmxvYXQgY29tcGFyZSApIHtcXFxcblxcXFx0XFxcXHRyZXR1cm4gc3RlcCggY29tcGFyZSwgdW5wYWNrUkdCQVRvRGVwdGgoIHRleHR1cmUyRCggZGVwdGhzLCB1diApICkgKTtcXFxcblxcXFx0fVxcXFxuXFxcXHRmbG9hdCB0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzYW1wbGVyMkQgZGVwdGhzLCB2ZWMyIHNpemUsIHZlYzIgdXYsIGZsb2F0IGNvbXBhcmUgKSB7XFxcXG5cXFxcdFxcXFx0Y29uc3QgdmVjMiBvZmZzZXQgPSB2ZWMyKCAwLjAsIDEuMCApO1xcXFxuXFxcXHRcXFxcdHZlYzIgdGV4ZWxTaXplID0gdmVjMiggMS4wICkgLyBzaXplO1xcXFxuXFxcXHRcXFxcdHZlYzIgY2VudHJvaWRVViA9IGZsb29yKCB1diAqIHNpemUgKyAwLjUgKSAvIHNpemU7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgbGIgPSB0ZXh0dXJlMkRDb21wYXJlKCBkZXB0aHMsIGNlbnRyb2lkVVYgKyB0ZXhlbFNpemUgKiBvZmZzZXQueHgsIGNvbXBhcmUgKTtcXFxcblxcXFx0XFxcXHRmbG9hdCBsdCA9IHRleHR1cmUyRENvbXBhcmUoIGRlcHRocywgY2VudHJvaWRVViArIHRleGVsU2l6ZSAqIG9mZnNldC54eSwgY29tcGFyZSApO1xcXFxuXFxcXHRcXFxcdGZsb2F0IHJiID0gdGV4dHVyZTJEQ29tcGFyZSggZGVwdGhzLCBjZW50cm9pZFVWICsgdGV4ZWxTaXplICogb2Zmc2V0Lnl4LCBjb21wYXJlICk7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgcnQgPSB0ZXh0dXJlMkRDb21wYXJlKCBkZXB0aHMsIGNlbnRyb2lkVVYgKyB0ZXhlbFNpemUgKiBvZmZzZXQueXksIGNvbXBhcmUgKTtcXFxcblxcXFx0XFxcXHR2ZWMyIGYgPSBmcmFjdCggdXYgKiBzaXplICsgMC41ICk7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgYSA9IG1peCggbGIsIGx0LCBmLnkgKTtcXFxcblxcXFx0XFxcXHRmbG9hdCBiID0gbWl4KCByYiwgcnQsIGYueSApO1xcXFxuXFxcXHRcXFxcdGZsb2F0IGMgPSBtaXgoIGEsIGIsIGYueCApO1xcXFxuXFxcXHRcXFxcdHJldHVybiBjO1xcXFxuXFxcXHR9XFxcXG5cXFxcdGZsb2F0IGdldFNoYWRvdyggc2FtcGxlcjJEIHNoYWRvd01hcCwgdmVjMiBzaGFkb3dNYXBTaXplLCBmbG9hdCBzaGFkb3dCaWFzLCBmbG9hdCBzaGFkb3dSYWRpdXMsIHZlYzQgc2hhZG93Q29vcmQgKSB7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgc2hhZG93ID0gMS4wO1xcXFxuXFxcXHRcXFxcdHNoYWRvd0Nvb3JkLnh5eiAvPSBzaGFkb3dDb29yZC53O1xcXFxuXFxcXHRcXFxcdHNoYWRvd0Nvb3JkLnogKz0gc2hhZG93QmlhcztcXFxcblxcXFx0XFxcXHRidmVjNCBpbkZydXN0dW1WZWMgPSBidmVjNCAoIHNoYWRvd0Nvb3JkLnggPj0gMC4wLCBzaGFkb3dDb29yZC54IDw9IDEuMCwgc2hhZG93Q29vcmQueSA+PSAwLjAsIHNoYWRvd0Nvb3JkLnkgPD0gMS4wICk7XFxcXG5cXFxcdFxcXFx0Ym9vbCBpbkZydXN0dW0gPSBhbGwoIGluRnJ1c3R1bVZlYyApO1xcXFxuXFxcXHRcXFxcdGJ2ZWMyIGZydXN0dW1UZXN0VmVjID0gYnZlYzIoIGluRnJ1c3R1bSwgc2hhZG93Q29vcmQueiA8PSAxLjAgKTtcXFxcblxcXFx0XFxcXHRib29sIGZydXN0dW1UZXN0ID0gYWxsKCBmcnVzdHVtVGVzdFZlYyApO1xcXFxuXFxcXHRcXFxcdGlmICggZnJ1c3R1bVRlc3QgKSB7XFxcXG5cXFxcdFxcXFx0I2lmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRiApXFxcXG5cXFxcdFxcXFx0XFxcXHR2ZWMyIHRleGVsU2l6ZSA9IHZlYzIoIDEuMCApIC8gc2hhZG93TWFwU2l6ZTtcXFxcblxcXFx0XFxcXHRcXFxcdGZsb2F0IGR4MCA9IC0gdGV4ZWxTaXplLnggKiBzaGFkb3dSYWRpdXM7XFxcXG5cXFxcdFxcXFx0XFxcXHRmbG9hdCBkeTAgPSAtIHRleGVsU2l6ZS55ICogc2hhZG93UmFkaXVzO1xcXFxuXFxcXHRcXFxcdFxcXFx0ZmxvYXQgZHgxID0gKyB0ZXhlbFNpemUueCAqIHNoYWRvd1JhZGl1cztcXFxcblxcXFx0XFxcXHRcXFxcdGZsb2F0IGR5MSA9ICsgdGV4ZWxTaXplLnkgKiBzaGFkb3dSYWRpdXM7XFxcXG5cXFxcdFxcXFx0XFxcXHRzaGFkb3cgPSAoXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MCApLCBzaGFkb3dDb29yZC56ICkgK1xcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgK1xcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5LCBzaGFkb3dDb29yZC56ICkgK1xcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkxICksIHNoYWRvd0Nvb3JkLnogKSArXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MSApLCBzaGFkb3dDb29yZC56ICkgK1xcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSwgc2hhZG93Q29vcmQueiApXFxcXG5cXFxcdFxcXFx0XFxcXHQpICogKCAxLjAgLyA5LjAgKTtcXFxcblxcXFx0XFxcXHQjZWxpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCApXFxcXG5cXFxcdFxcXFx0XFxcXHR2ZWMyIHRleGVsU2l6ZSA9IHZlYzIoIDEuMCApIC8gc2hhZG93TWFwU2l6ZTtcXFxcblxcXFx0XFxcXHRcXFxcdGZsb2F0IGR4MCA9IC0gdGV4ZWxTaXplLnggKiBzaGFkb3dSYWRpdXM7XFxcXG5cXFxcdFxcXFx0XFxcXHRmbG9hdCBkeTAgPSAtIHRleGVsU2l6ZS55ICogc2hhZG93UmFkaXVzO1xcXFxuXFxcXHRcXFxcdFxcXFx0ZmxvYXQgZHgxID0gKyB0ZXhlbFNpemUueCAqIHNoYWRvd1JhZGl1cztcXFxcblxcXFx0XFxcXHRcXFxcdGZsb2F0IGR5MSA9ICsgdGV4ZWxTaXplLnkgKiBzaGFkb3dSYWRpdXM7XFxcXG5cXFxcdFxcXFx0XFxcXHRzaGFkb3cgPSAoXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHRleHR1cmUyRFNoYWRvd0xlcnAoIHNoYWRvd01hcCwgc2hhZG93TWFwU2l6ZSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MCApLCBzaGFkb3dDb29yZC56ICkgK1xcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHRleHR1cmUyRFNoYWRvd0xlcnAoIHNoYWRvd01hcCwgc2hhZG93TWFwU2l6ZSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgK1xcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5LCBzaGFkb3dDb29yZC56ICkgK1xcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkxICksIHNoYWRvd0Nvb3JkLnogKSArXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHRleHR1cmUyRFNoYWRvd0xlcnAoIHNoYWRvd01hcCwgc2hhZG93TWFwU2l6ZSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MSApLCBzaGFkb3dDb29yZC56ICkgK1xcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSwgc2hhZG93Q29vcmQueiApXFxcXG5cXFxcdFxcXFx0XFxcXHQpICogKCAxLjAgLyA5LjAgKTtcXFxcblxcXFx0XFxcXHQjZWxzZVxcXFxuXFxcXHRcXFxcdFxcXFx0c2hhZG93ID0gdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSwgc2hhZG93Q29vcmQueiApO1xcXFxuXFxcXHRcXFxcdCNlbmRpZlxcXFxuXFxcXHRcXFxcdH1cXFxcblxcXFx0XFxcXHRyZXR1cm4gc2hhZG93O1xcXFxuXFxcXHR9XFxcXG5cXFxcdHZlYzIgY3ViZVRvVVYoIHZlYzMgdiwgZmxvYXQgdGV4ZWxTaXplWSApIHtcXFxcblxcXFx0XFxcXHR2ZWMzIGFic1YgPSBhYnMoIHYgKTtcXFxcblxcXFx0XFxcXHRmbG9hdCBzY2FsZVRvQ3ViZSA9IDEuMCAvIG1heCggYWJzVi54LCBtYXgoIGFic1YueSwgYWJzVi56ICkgKTtcXFxcblxcXFx0XFxcXHRhYnNWICo9IHNjYWxlVG9DdWJlO1xcXFxuXFxcXHRcXFxcdHYgKj0gc2NhbGVUb0N1YmUgKiAoIDEuMCAtIDIuMCAqIHRleGVsU2l6ZVkgKTtcXFxcblxcXFx0XFxcXHR2ZWMyIHBsYW5hciA9IHYueHk7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgYWxtb3N0QVRleGVsID0gMS41ICogdGV4ZWxTaXplWTtcXFxcblxcXFx0XFxcXHRmbG9hdCBhbG1vc3RPbmUgPSAxLjAgLSBhbG1vc3RBVGV4ZWw7XFxcXG5cXFxcdFxcXFx0aWYgKCBhYnNWLnogPj0gYWxtb3N0T25lICkge1xcXFxuXFxcXHRcXFxcdFxcXFx0aWYgKCB2LnogPiAwLjAgKVxcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHRwbGFuYXIueCA9IDQuMCAtIHYueDtcXFxcblxcXFx0XFxcXHR9IGVsc2UgaWYgKCBhYnNWLnggPj0gYWxtb3N0T25lICkge1xcXFxuXFxcXHRcXFxcdFxcXFx0ZmxvYXQgc2lnblggPSBzaWduKCB2LnggKTtcXFxcblxcXFx0XFxcXHRcXFxcdHBsYW5hci54ID0gdi56ICogc2lnblggKyAyLjAgKiBzaWduWDtcXFxcblxcXFx0XFxcXHR9IGVsc2UgaWYgKCBhYnNWLnkgPj0gYWxtb3N0T25lICkge1xcXFxuXFxcXHRcXFxcdFxcXFx0ZmxvYXQgc2lnblkgPSBzaWduKCB2LnkgKTtcXFxcblxcXFx0XFxcXHRcXFxcdHBsYW5hci54ID0gdi54ICsgMi4wICogc2lnblkgKyAyLjA7XFxcXG5cXFxcdFxcXFx0XFxcXHRwbGFuYXIueSA9IHYueiAqIHNpZ25ZIC0gMi4wO1xcXFxuXFxcXHRcXFxcdH1cXFxcblxcXFx0XFxcXHRyZXR1cm4gdmVjMiggMC4xMjUsIDAuMjUgKSAqIHBsYW5hciArIHZlYzIoIDAuMzc1LCAwLjc1ICk7XFxcXG5cXFxcdH1cXFxcblxcXFx0ZmxvYXQgZ2V0UG9pbnRTaGFkb3coIHNhbXBsZXIyRCBzaGFkb3dNYXAsIHZlYzIgc2hhZG93TWFwU2l6ZSwgZmxvYXQgc2hhZG93QmlhcywgZmxvYXQgc2hhZG93UmFkaXVzLCB2ZWM0IHNoYWRvd0Nvb3JkLCBmbG9hdCBzaGFkb3dDYW1lcmFOZWFyLCBmbG9hdCBzaGFkb3dDYW1lcmFGYXIgKSB7XFxcXG5cXFxcdFxcXFx0dmVjMiB0ZXhlbFNpemUgPSB2ZWMyKCAxLjAgKSAvICggc2hhZG93TWFwU2l6ZSAqIHZlYzIoIDQuMCwgMi4wICkgKTtcXFxcblxcXFx0XFxcXHR2ZWMzIGxpZ2h0VG9Qb3NpdGlvbiA9IHNoYWRvd0Nvb3JkLnh5ejtcXFxcblxcXFx0XFxcXHRmbG9hdCBkcCA9ICggbGVuZ3RoKCBsaWdodFRvUG9zaXRpb24gKSAtIHNoYWRvd0NhbWVyYU5lYXIgKSAvICggc2hhZG93Q2FtZXJhRmFyIC0gc2hhZG93Q2FtZXJhTmVhciApO1xcXFx0XFxcXHRkcCArPSBzaGFkb3dCaWFzO1xcXFxuXFxcXHRcXFxcdHZlYzMgYmQzRCA9IG5vcm1hbGl6ZSggbGlnaHRUb1Bvc2l0aW9uICk7XFxcXG5cXFxcdFxcXFx0I2lmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRiApIHx8IGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRl9TT0ZUIClcXFxcblxcXFx0XFxcXHRcXFxcdHZlYzIgb2Zmc2V0ID0gdmVjMiggLSAxLCAxICkgKiBzaGFkb3dSYWRpdXMgKiB0ZXhlbFNpemUueTtcXFxcblxcXFx0XFxcXHRcXFxcdHJldHVybiAoXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHl5LCB0ZXhlbFNpemUueSApLCBkcCApICtcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eXksIHRleGVsU2l6ZS55ICksIGRwICkgK1xcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh5eCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueXl4LCB0ZXhlbFNpemUueSApLCBkcCApICtcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHh5LCB0ZXhlbFNpemUueSApLCBkcCApICtcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eHksIHRleGVsU2l6ZS55ICksIGRwICkgK1xcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh4eCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueXh4LCB0ZXhlbFNpemUueSApLCBkcCApXFxcXG5cXFxcdFxcXFx0XFxcXHQpICogKCAxLjAgLyA5LjAgKTtcXFxcblxcXFx0XFxcXHQjZWxzZVxcXFxuXFxcXHRcXFxcdFxcXFx0cmV0dXJuIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QsIHRleGVsU2l6ZS55ICksIGRwICk7XFxcXG5cXFxcdFxcXFx0I2VuZGlmXFxcXG5cXFxcdH1cXFxcbiNlbmRpZlxcXFxuXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgc2hhZG93bWFwX3BhcnNfdmVydGV4ID0gXFxcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxcXG5cXFxcdCNpZiBOVU1fRElSX0xJR0hUUyA+IDBcXFxcblxcXFx0XFxcXHR1bmlmb3JtIG1hdDQgZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXhbIE5VTV9ESVJfTElHSFRTIF07XFxcXG5cXFxcdFxcXFx0dmFyeWluZyB2ZWM0IHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBOVU1fRElSX0xJR0hUUyBdO1xcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0I2lmIE5VTV9TUE9UX0xJR0hUUyA+IDBcXFxcblxcXFx0XFxcXHR1bmlmb3JtIG1hdDQgc3BvdFNoYWRvd01hdHJpeFsgTlVNX1NQT1RfTElHSFRTIF07XFxcXG5cXFxcdFxcXFx0dmFyeWluZyB2ZWM0IHZTcG90U2hhZG93Q29vcmRbIE5VTV9TUE9UX0xJR0hUUyBdO1xcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0I2lmIE5VTV9QT0lOVF9MSUdIVFMgPiAwXFxcXG5cXFxcdFxcXFx0dW5pZm9ybSBtYXQ0IHBvaW50U2hhZG93TWF0cml4WyBOVU1fUE9JTlRfTElHSFRTIF07XFxcXG5cXFxcdFxcXFx0dmFyeWluZyB2ZWM0IHZQb2ludFNoYWRvd0Nvb3JkWyBOVU1fUE9JTlRfTElHSFRTIF07XFxcXG5cXFxcdCNlbmRpZlxcXFxuI2VuZGlmXFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBzaGFkb3dtYXBfdmVydGV4ID0gXFxcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxcXG5cXFxcdCNpZiBOVU1fRElSX0xJR0hUUyA+IDBcXFxcblxcXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVFM7IGkgKysgKSB7XFxcXG5cXFxcdFxcXFx0dkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIGkgXSA9IGRpcmVjdGlvbmFsU2hhZG93TWF0cml4WyBpIF0gKiB3b3JsZFBvc2l0aW9uO1xcXFxuXFxcXHR9XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHQjaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcXFxuXFxcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxcXG5cXFxcdFxcXFx0dlNwb3RTaGFkb3dDb29yZFsgaSBdID0gc3BvdFNoYWRvd01hdHJpeFsgaSBdICogd29ybGRQb3NpdGlvbjtcXFxcblxcXFx0fVxcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0I2lmIE5VTV9QT0lOVF9MSUdIVFMgPiAwXFxcXG5cXFxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XFxcXG5cXFxcdFxcXFx0dlBvaW50U2hhZG93Q29vcmRbIGkgXSA9IHBvaW50U2hhZG93TWF0cml4WyBpIF0gKiB3b3JsZFBvc2l0aW9uO1xcXFxuXFxcXHR9XFxcXG5cXFxcdCNlbmRpZlxcXFxuI2VuZGlmXFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQgPSBcXFwiZmxvYXQgZ2V0U2hhZG93TWFzaygpIHtcXFxcblxcXFx0ZmxvYXQgc2hhZG93ID0gMS4wO1xcXFxuXFxcXHQjaWZkZWYgVVNFX1NIQURPV01BUFxcXFxuXFxcXHQjaWYgTlVNX0RJUl9MSUdIVFMgPiAwXFxcXG5cXFxcdERpcmVjdGlvbmFsTGlnaHQgZGlyZWN0aW9uYWxMaWdodDtcXFxcblxcXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVFM7IGkgKysgKSB7XFxcXG5cXFxcdFxcXFx0ZGlyZWN0aW9uYWxMaWdodCA9IGRpcmVjdGlvbmFsTGlnaHRzWyBpIF07XFxcXG5cXFxcdFxcXFx0c2hhZG93ICo9IGJvb2woIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93ICkgPyBnZXRTaGFkb3coIGRpcmVjdGlvbmFsU2hhZG93TWFwWyBpIF0sIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93TWFwU2l6ZSwgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dCaWFzLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd1JhZGl1cywgdkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIGkgXSApIDogMS4wO1xcXFxuXFxcXHR9XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHQjaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcXFxuXFxcXHRTcG90TGlnaHQgc3BvdExpZ2h0O1xcXFxuXFxcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxcXG5cXFxcdFxcXFx0c3BvdExpZ2h0ID0gc3BvdExpZ2h0c1sgaSBdO1xcXFxuXFxcXHRcXFxcdHNoYWRvdyAqPSBib29sKCBzcG90TGlnaHQuc2hhZG93ICkgPyBnZXRTaGFkb3coIHNwb3RTaGFkb3dNYXBbIGkgXSwgc3BvdExpZ2h0LnNoYWRvd01hcFNpemUsIHNwb3RMaWdodC5zaGFkb3dCaWFzLCBzcG90TGlnaHQuc2hhZG93UmFkaXVzLCB2U3BvdFNoYWRvd0Nvb3JkWyBpIF0gKSA6IDEuMDtcXFxcblxcXFx0fVxcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0I2lmIE5VTV9QT0lOVF9MSUdIVFMgPiAwXFxcXG5cXFxcdFBvaW50TGlnaHQgcG9pbnRMaWdodDtcXFxcblxcXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXFxcblxcXFx0XFxcXHRwb2ludExpZ2h0ID0gcG9pbnRMaWdodHNbIGkgXTtcXFxcblxcXFx0XFxcXHRzaGFkb3cgKj0gYm9vbCggcG9pbnRMaWdodC5zaGFkb3cgKSA/IGdldFBvaW50U2hhZG93KCBwb2ludFNoYWRvd01hcFsgaSBdLCBwb2ludExpZ2h0LnNoYWRvd01hcFNpemUsIHBvaW50TGlnaHQuc2hhZG93QmlhcywgcG9pbnRMaWdodC5zaGFkb3dSYWRpdXMsIHZQb2ludFNoYWRvd0Nvb3JkWyBpIF0sIHBvaW50TGlnaHQuc2hhZG93Q2FtZXJhTmVhciwgcG9pbnRMaWdodC5zaGFkb3dDYW1lcmFGYXIgKSA6IDEuMDtcXFxcblxcXFx0fVxcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdHJldHVybiBzaGFkb3c7XFxcXG59XFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBza2luYmFzZV92ZXJ0ZXggPSBcXFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcXFxuXFxcXHRtYXQ0IGJvbmVNYXRYID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnggKTtcXFxcblxcXFx0bWF0NCBib25lTWF0WSA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC55ICk7XFxcXG5cXFxcdG1hdDQgYm9uZU1hdFogPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueiApO1xcXFxuXFxcXHRtYXQ0IGJvbmVNYXRXID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LncgKTtcXFxcbiNlbmRpZlxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIHNraW5uaW5nX3BhcnNfdmVydGV4ID0gXFxcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXFxcblxcXFx0dW5pZm9ybSBtYXQ0IGJpbmRNYXRyaXg7XFxcXG5cXFxcdHVuaWZvcm0gbWF0NCBiaW5kTWF0cml4SW52ZXJzZTtcXFxcblxcXFx0I2lmZGVmIEJPTkVfVEVYVFVSRVxcXFxuXFxcXHRcXFxcdHVuaWZvcm0gc2FtcGxlcjJEIGJvbmVUZXh0dXJlO1xcXFxuXFxcXHRcXFxcdHVuaWZvcm0gaW50IGJvbmVUZXh0dXJlU2l6ZTtcXFxcblxcXFx0XFxcXHRtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XFxcXG5cXFxcdFxcXFx0XFxcXHRmbG9hdCBqID0gaSAqIDQuMDtcXFxcblxcXFx0XFxcXHRcXFxcdGZsb2F0IHggPSBtb2QoIGosIGZsb2F0KCBib25lVGV4dHVyZVNpemUgKSApO1xcXFxuXFxcXHRcXFxcdFxcXFx0ZmxvYXQgeSA9IGZsb29yKCBqIC8gZmxvYXQoIGJvbmVUZXh0dXJlU2l6ZSApICk7XFxcXG5cXFxcdFxcXFx0XFxcXHRmbG9hdCBkeCA9IDEuMCAvIGZsb2F0KCBib25lVGV4dHVyZVNpemUgKTtcXFxcblxcXFx0XFxcXHRcXFxcdGZsb2F0IGR5ID0gMS4wIC8gZmxvYXQoIGJvbmVUZXh0dXJlU2l6ZSApO1xcXFxuXFxcXHRcXFxcdFxcXFx0eSA9IGR5ICogKCB5ICsgMC41ICk7XFxcXG5cXFxcdFxcXFx0XFxcXHR2ZWM0IHYxID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAwLjUgKSwgeSApICk7XFxcXG5cXFxcdFxcXFx0XFxcXHR2ZWM0IHYyID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAxLjUgKSwgeSApICk7XFxcXG5cXFxcdFxcXFx0XFxcXHR2ZWM0IHYzID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAyLjUgKSwgeSApICk7XFxcXG5cXFxcdFxcXFx0XFxcXHR2ZWM0IHY0ID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAzLjUgKSwgeSApICk7XFxcXG5cXFxcdFxcXFx0XFxcXHRtYXQ0IGJvbmUgPSBtYXQ0KCB2MSwgdjIsIHYzLCB2NCApO1xcXFxuXFxcXHRcXFxcdFxcXFx0cmV0dXJuIGJvbmU7XFxcXG5cXFxcdFxcXFx0fVxcXFxuXFxcXHQjZWxzZVxcXFxuXFxcXHRcXFxcdHVuaWZvcm0gbWF0NCBib25lTWF0cmljZXNbIE1BWF9CT05FUyBdO1xcXFxuXFxcXHRcXFxcdG1hdDQgZ2V0Qm9uZU1hdHJpeCggY29uc3QgaW4gZmxvYXQgaSApIHtcXFxcblxcXFx0XFxcXHRcXFxcdG1hdDQgYm9uZSA9IGJvbmVNYXRyaWNlc1sgaW50KGkpIF07XFxcXG5cXFxcdFxcXFx0XFxcXHRyZXR1cm4gYm9uZTtcXFxcblxcXFx0XFxcXHR9XFxcXG5cXFxcdCNlbmRpZlxcXFxuI2VuZGlmXFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBza2lubmluZ192ZXJ0ZXggPSBcXFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcXFxuXFxcXHR2ZWM0IHNraW5WZXJ0ZXggPSBiaW5kTWF0cml4ICogdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApO1xcXFxuXFxcXHR2ZWM0IHNraW5uZWQgPSB2ZWM0KCAwLjAgKTtcXFxcblxcXFx0c2tpbm5lZCArPSBib25lTWF0WCAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lng7XFxcXG5cXFxcdHNraW5uZWQgKz0gYm9uZU1hdFkgKiBza2luVmVydGV4ICogc2tpbldlaWdodC55O1xcXFxuXFxcXHRza2lubmVkICs9IGJvbmVNYXRaICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQuejtcXFxcblxcXFx0c2tpbm5lZCArPSBib25lTWF0VyAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnc7XFxcXG5cXFxcdHRyYW5zZm9ybWVkID0gKCBiaW5kTWF0cml4SW52ZXJzZSAqIHNraW5uZWQgKS54eXo7XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIHNraW5ub3JtYWxfdmVydGV4ID0gXFxcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXFxcblxcXFx0bWF0NCBza2luTWF0cml4ID0gbWF0NCggMC4wICk7XFxcXG5cXFxcdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC54ICogYm9uZU1hdFg7XFxcXG5cXFxcdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC55ICogYm9uZU1hdFk7XFxcXG5cXFxcdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC56ICogYm9uZU1hdFo7XFxcXG5cXFxcdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC53ICogYm9uZU1hdFc7XFxcXG5cXFxcdHNraW5NYXRyaXggID0gYmluZE1hdHJpeEludmVyc2UgKiBza2luTWF0cml4ICogYmluZE1hdHJpeDtcXFxcblxcXFx0b2JqZWN0Tm9ybWFsID0gdmVjNCggc2tpbk1hdHJpeCAqIHZlYzQoIG9iamVjdE5vcm1hbCwgMC4wICkgKS54eXo7XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIHNwZWN1bGFybWFwX2ZyYWdtZW50ID0gXFxcImZsb2F0IHNwZWN1bGFyU3RyZW5ndGg7XFxcXG4jaWZkZWYgVVNFX1NQRUNVTEFSTUFQXFxcXG5cXFxcdHZlYzQgdGV4ZWxTcGVjdWxhciA9IHRleHR1cmUyRCggc3BlY3VsYXJNYXAsIHZVdiApO1xcXFxuXFxcXHRzcGVjdWxhclN0cmVuZ3RoID0gdGV4ZWxTcGVjdWxhci5yO1xcXFxuI2Vsc2VcXFxcblxcXFx0c3BlY3VsYXJTdHJlbmd0aCA9IDEuMDtcXFxcbiNlbmRpZlxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQgPSBcXFwiI2lmZGVmIFVTRV9TUEVDVUxBUk1BUFxcXFxuXFxcXHR1bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhck1hcDtcXFxcbiNlbmRpZlxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIHRvbmVtYXBwaW5nX2ZyYWdtZW50ID0gXFxcIiNpZiBkZWZpbmVkKCBUT05FX01BUFBJTkcgKVxcXFxuICBnbF9GcmFnQ29sb3IucmdiID0gdG9uZU1hcHBpbmcoIGdsX0ZyYWdDb2xvci5yZ2IgKTtcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgdG9uZW1hcHBpbmdfcGFyc19mcmFnbWVudCA9IFxcXCIjaWZuZGVmIHNhdHVyYXRlXFxcXG5cXFxcdCNkZWZpbmUgc2F0dXJhdGUoYSkgY2xhbXAoIGEsIDAuMCwgMS4wIClcXFxcbiNlbmRpZlxcXFxudW5pZm9ybSBmbG9hdCB0b25lTWFwcGluZ0V4cG9zdXJlO1xcXFxudW5pZm9ybSBmbG9hdCB0b25lTWFwcGluZ1doaXRlUG9pbnQ7XFxcXG52ZWMzIExpbmVhclRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkge1xcXFxuXFxcXHRyZXR1cm4gdG9uZU1hcHBpbmdFeHBvc3VyZSAqIGNvbG9yO1xcXFxufVxcXFxudmVjMyBSZWluaGFyZFRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkge1xcXFxuXFxcXHRjb2xvciAqPSB0b25lTWFwcGluZ0V4cG9zdXJlO1xcXFxuXFxcXHRyZXR1cm4gc2F0dXJhdGUoIGNvbG9yIC8gKCB2ZWMzKCAxLjAgKSArIGNvbG9yICkgKTtcXFxcbn1cXFxcbiNkZWZpbmUgVW5jaGFydGVkMkhlbHBlciggeCApIG1heCggKCAoIHggKiAoIDAuMTUgKiB4ICsgMC4xMCAqIDAuNTAgKSArIDAuMjAgKiAwLjAyICkgLyAoIHggKiAoIDAuMTUgKiB4ICsgMC41MCApICsgMC4yMCAqIDAuMzAgKSApIC0gMC4wMiAvIDAuMzAsIHZlYzMoIDAuMCApIClcXFxcbnZlYzMgVW5jaGFydGVkMlRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkge1xcXFxuXFxcXHRjb2xvciAqPSB0b25lTWFwcGluZ0V4cG9zdXJlO1xcXFxuXFxcXHRyZXR1cm4gc2F0dXJhdGUoIFVuY2hhcnRlZDJIZWxwZXIoIGNvbG9yICkgLyBVbmNoYXJ0ZWQySGVscGVyKCB2ZWMzKCB0b25lTWFwcGluZ1doaXRlUG9pbnQgKSApICk7XFxcXG59XFxcXG52ZWMzIE9wdGltaXplZENpbmVvblRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkge1xcXFxuXFxcXHRjb2xvciAqPSB0b25lTWFwcGluZ0V4cG9zdXJlO1xcXFxuXFxcXHRjb2xvciA9IG1heCggdmVjMyggMC4wICksIGNvbG9yIC0gMC4wMDQgKTtcXFxcblxcXFx0cmV0dXJuIHBvdyggKCBjb2xvciAqICggNi4yICogY29sb3IgKyAwLjUgKSApIC8gKCBjb2xvciAqICggNi4yICogY29sb3IgKyAxLjcgKSArIDAuMDYgKSwgdmVjMyggMi4yICkgKTtcXFxcbn1cXFxcblxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIHV2X3BhcnNfZnJhZ21lbnQgPSBcXFwiI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfU1BFQ1VMQVJNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQUxQSEFNQVAgKSB8fCBkZWZpbmVkKCBVU0VfRU1JU1NJVkVNQVAgKSB8fCBkZWZpbmVkKCBVU0VfUk9VR0hORVNTTUFQICkgfHwgZGVmaW5lZCggVVNFX01FVEFMTkVTU01BUCApXFxcXG5cXFxcdHZhcnlpbmcgdmVjMiB2VXY7XFxcXG4jZW5kaWZcXFwiO1xcclxcblxcclxcblxcdHZhciB1dl9wYXJzX3ZlcnRleCA9IFxcXCIjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFVTRV9TUEVDVUxBUk1BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApIHx8IGRlZmluZWQoIFVTRV9FTUlTU0lWRU1BUCApIHx8IGRlZmluZWQoIFVTRV9ST1VHSE5FU1NNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTUVUQUxORVNTTUFQIClcXFxcblxcXFx0dmFyeWluZyB2ZWMyIHZVdjtcXFxcblxcXFx0dW5pZm9ybSBtYXQzIHV2VHJhbnNmb3JtO1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciB1dl92ZXJ0ZXggPSBcXFwiI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfU1BFQ1VMQVJNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQUxQSEFNQVAgKSB8fCBkZWZpbmVkKCBVU0VfRU1JU1NJVkVNQVAgKSB8fCBkZWZpbmVkKCBVU0VfUk9VR0hORVNTTUFQICkgfHwgZGVmaW5lZCggVVNFX01FVEFMTkVTU01BUCApXFxcXG5cXFxcdHZVdiA9ICggdXZUcmFuc2Zvcm0gKiB2ZWMzKCB1diwgMSApICkueHk7XFxcXG4jZW5kaWZcXFwiO1xcclxcblxcclxcblxcdHZhciB1djJfcGFyc19mcmFnbWVudCA9IFxcXCIjaWYgZGVmaW5lZCggVVNFX0xJR0hUTUFQICkgfHwgZGVmaW5lZCggVVNFX0FPTUFQIClcXFxcblxcXFx0dmFyeWluZyB2ZWMyIHZVdjI7XFxcXG4jZW5kaWZcXFwiO1xcclxcblxcclxcblxcdHZhciB1djJfcGFyc192ZXJ0ZXggPSBcXFwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXFxcXG5cXFxcdGF0dHJpYnV0ZSB2ZWMyIHV2MjtcXFxcblxcXFx0dmFyeWluZyB2ZWMyIHZVdjI7XFxcXG4jZW5kaWZcXFwiO1xcclxcblxcclxcblxcdHZhciB1djJfdmVydGV4ID0gXFxcIiNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU9NQVAgKVxcXFxuXFxcXHR2VXYyID0gdXYyO1xcXFxuI2VuZGlmXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgd29ybGRwb3NfdmVydGV4ID0gXFxcIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgfHwgZGVmaW5lZCggRElTVEFOQ0UgKSB8fCBkZWZpbmVkICggVVNFX1NIQURPV01BUCApXFxcXG5cXFxcdHZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApO1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBjdWJlX2ZyYWcgPSBcXFwidW5pZm9ybSBzYW1wbGVyQ3ViZSB0Q3ViZTtcXFxcbnVuaWZvcm0gZmxvYXQgdEZsaXA7XFxcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxcXG52YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxcXG52b2lkIG1haW4oKSB7XFxcXG5cXFxcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmVDdWJlKCB0Q3ViZSwgdmVjMyggdEZsaXAgKiB2V29ybGRQb3NpdGlvbi54LCB2V29ybGRQb3NpdGlvbi55eiApICk7XFxcXG5cXFxcdGdsX0ZyYWdDb2xvci5hICo9IG9wYWNpdHk7XFxcXG59XFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBjdWJlX3ZlcnQgPSBcXFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcXFxuI2luY2x1ZGUgPGNvbW1vbj5cXFxcbnZvaWQgbWFpbigpIHtcXFxcblxcXFx0dldvcmxkUG9zaXRpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1xcXFxuXFxcXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxcXG5cXFxcdGdsX1Bvc2l0aW9uLnogPSBnbF9Qb3NpdGlvbi53O1xcXFxufVxcXFxuXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgZGVwdGhfZnJhZyA9IFxcXCIjaWYgREVQVEhfUEFDS0lORyA9PSAzMjAwXFxcXG5cXFxcdHVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXFxcbiNlbmRpZlxcXFxuI2luY2x1ZGUgPGNvbW1vbj5cXFxcbiNpbmNsdWRlIDxwYWNraW5nPlxcXFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcXFxudm9pZCBtYWluKCkge1xcXFxuXFxcXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcXFxuXFxcXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIDEuMCApO1xcXFxuXFxcXHQjaWYgREVQVEhfUEFDS0lORyA9PSAzMjAwXFxcXG5cXFxcdFxcXFx0ZGlmZnVzZUNvbG9yLmEgPSBvcGFjaXR5O1xcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpZiBERVBUSF9QQUNLSU5HID09IDMyMDBcXFxcblxcXFx0XFxcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCB2ZWMzKCBnbF9GcmFnQ29vcmQueiApLCBvcGFjaXR5ICk7XFxcXG5cXFxcdCNlbGlmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMVxcXFxuXFxcXHRcXFxcdGdsX0ZyYWdDb2xvciA9IHBhY2tEZXB0aFRvUkdCQSggZ2xfRnJhZ0Nvb3JkLnogKTtcXFxcblxcXFx0I2VuZGlmXFxcXG59XFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBkZXB0aF92ZXJ0ID0gXFxcIiNpbmNsdWRlIDxjb21tb24+XFxcXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXFxcbnZvaWQgbWFpbigpIHtcXFxcblxcXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXFxcblxcXFx0I2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVBcXFxcblxcXFx0XFxcXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcXFxuXFxcXHRcXFxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxcXG5cXFxcdFxcXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxcXG59XFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBkaXN0YW5jZVJHQkFfZnJhZyA9IFxcXCIjZGVmaW5lIERJU1RBTkNFXFxcXG51bmlmb3JtIHZlYzMgcmVmZXJlbmNlUG9zaXRpb247XFxcXG51bmlmb3JtIGZsb2F0IG5lYXJEaXN0YW5jZTtcXFxcbnVuaWZvcm0gZmxvYXQgZmFyRGlzdGFuY2U7XFxcXG52YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxcXG4jaW5jbHVkZSA8Y29tbW9uPlxcXFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxcXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcXFxudm9pZCBtYWluICgpIHtcXFxcblxcXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXFxcblxcXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCAxLjAgKTtcXFxcblxcXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcXFxuXFxcXHRmbG9hdCBkaXN0ID0gbGVuZ3RoKCB2V29ybGRQb3NpdGlvbiAtIHJlZmVyZW5jZVBvc2l0aW9uICk7XFxcXG5cXFxcdGRpc3QgPSAoIGRpc3QgLSBuZWFyRGlzdGFuY2UgKSAvICggZmFyRGlzdGFuY2UgLSBuZWFyRGlzdGFuY2UgKTtcXFxcblxcXFx0ZGlzdCA9IHNhdHVyYXRlKCBkaXN0ICk7XFxcXG5cXFxcdGdsX0ZyYWdDb2xvciA9IHBhY2tEZXB0aFRvUkdCQSggZGlzdCApO1xcXFxufVxcXFxuXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgZGlzdGFuY2VSR0JBX3ZlcnQgPSBcXFwiI2RlZmluZSBESVNUQU5DRVxcXFxudmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcXFxuI2luY2x1ZGUgPGNvbW1vbj5cXFxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcXFxudm9pZCBtYWluKCkge1xcXFxuXFxcXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcXFxuXFxcXHQjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxcXFxuXFxcXHRcXFxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxcXG5cXFxcdFxcXFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXFxcblxcXFx0XFxcXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXFxcblxcXFx0dldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcXFxcbn1cXFxcblxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIGVxdWlyZWN0X2ZyYWcgPSBcXFwidW5pZm9ybSBzYW1wbGVyMkQgdEVxdWlyZWN0O1xcXFxudmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcXFxuI2luY2x1ZGUgPGNvbW1vbj5cXFxcbnZvaWQgbWFpbigpIHtcXFxcblxcXFx0dmVjMyBkaXJlY3Rpb24gPSBub3JtYWxpemUoIHZXb3JsZFBvc2l0aW9uICk7XFxcXG5cXFxcdHZlYzIgc2FtcGxlVVY7XFxcXG5cXFxcdHNhbXBsZVVWLnkgPSBhc2luKCBjbGFtcCggZGlyZWN0aW9uLnksIC0gMS4wLCAxLjAgKSApICogUkVDSVBST0NBTF9QSSArIDAuNTtcXFxcblxcXFx0c2FtcGxlVVYueCA9IGF0YW4oIGRpcmVjdGlvbi56LCBkaXJlY3Rpb24ueCApICogUkVDSVBST0NBTF9QSTIgKyAwLjU7XFxcXG5cXFxcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggdEVxdWlyZWN0LCBzYW1wbGVVViApO1xcXFxufVxcXFxuXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgZXF1aXJlY3RfdmVydCA9IFxcXCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxcXG4jaW5jbHVkZSA8Y29tbW9uPlxcXFxudm9pZCBtYWluKCkge1xcXFxuXFxcXHR2V29ybGRQb3NpdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbiggcG9zaXRpb24sIG1vZGVsTWF0cml4ICk7XFxcXG5cXFxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXFxcbn1cXFxcblxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIGxpbmVkYXNoZWRfZnJhZyA9IFxcXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcXFxcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXFxcbnVuaWZvcm0gZmxvYXQgZGFzaFNpemU7XFxcXG51bmlmb3JtIGZsb2F0IHRvdGFsU2l6ZTtcXFxcbnZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTtcXFxcbiNpbmNsdWRlIDxjb21tb24+XFxcXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcXFxudm9pZCBtYWluKCkge1xcXFxuXFxcXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcXFxuXFxcXHRpZiAoIG1vZCggdkxpbmVEaXN0YW5jZSwgdG90YWxTaXplICkgPiBkYXNoU2l6ZSApIHtcXFxcblxcXFx0XFxcXHRkaXNjYXJkO1xcXFxuXFxcXHR9XFxcXG5cXFxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1xcXFxuXFxcXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXFxcblxcXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxcXG5cXFxcdG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiO1xcXFxuXFxcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1xcXFxuXFxcXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcXFxufVxcXFxuXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgbGluZWRhc2hlZF92ZXJ0ID0gXFxcInVuaWZvcm0gZmxvYXQgc2NhbGU7XFxcXG5hdHRyaWJ1dGUgZmxvYXQgbGluZURpc3RhbmNlO1xcXFxudmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlO1xcXFxuI2luY2x1ZGUgPGNvbW1vbj5cXFxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcXFxudm9pZCBtYWluKCkge1xcXFxuXFxcXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcXFxuXFxcXHR2TGluZURpc3RhbmNlID0gc2NhbGUgKiBsaW5lRGlzdGFuY2U7XFxcXG5cXFxcdHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcXFxcblxcXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcXFxcblxcXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxmb2dfdmVydGV4PlxcXFxufVxcXFxuXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgbWVzaGJhc2ljX2ZyYWcgPSBcXFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxcXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxcXG5cXFxcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcXFxuI2VuZGlmXFxcXG4jaW5jbHVkZSA8Y29tbW9uPlxcXFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDx1djJfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxcXG52b2lkIG1haW4oKSB7XFxcXG5cXFxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxcXG5cXFxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcXFxuXFxcXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8c3BlY3VsYXJtYXBfZnJhZ21lbnQ+XFxcXG5cXFxcdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XFxcXG5cXFxcdCNpZmRlZiBVU0VfTElHSFRNQVBcXFxcblxcXFx0XFxcXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gdGV4dHVyZTJEKCBsaWdodE1hcCwgdlV2MiApLnh5eiAqIGxpZ2h0TWFwSW50ZW5zaXR5O1xcXFxuXFxcXHQjZWxzZVxcXFxuXFxcXHRcXFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSB2ZWMzKCAxLjAgKTtcXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdCNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD5cXFxcblxcXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICo9IGRpZmZ1c2VDb2xvci5yZ2I7XFxcXG5cXFxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZTtcXFxcblxcXFx0I2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD5cXFxcblxcXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcXFxcblxcXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXFxcbn1cXFxcblxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIG1lc2hiYXNpY192ZXJ0ID0gXFxcIiNpbmNsdWRlIDxjb21tb24+XFxcXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8dXYyX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcXFxudm9pZCBtYWluKCkge1xcXFxuXFxcXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8dXYyX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXFxcblxcXFx0I2lmZGVmIFVTRV9FTlZNQVBcXFxcblxcXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8ZW52bWFwX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxcXG59XFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBtZXNobGFtYmVydF9mcmFnID0gXFxcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcXFxudW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1xcXFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcXFxudmFyeWluZyB2ZWMzIHZMaWdodEZyb250O1xcXFxuI2lmZGVmIERPVUJMRV9TSURFRFxcXFxuXFxcXHR2YXJ5aW5nIHZlYzMgdkxpZ2h0QmFjaztcXFxcbiNlbmRpZlxcXFxuI2luY2x1ZGUgPGNvbW1vbj5cXFxcbiNpbmNsdWRlIDxwYWNraW5nPlxcXFxuI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDx1djJfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGJzZGZzPlxcXFxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzPlxcXFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPHNoYWRvd21hc2tfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxcXG52b2lkIG1haW4oKSB7XFxcXG5cXFxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxcXG5cXFxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcXFxuXFxcXHRSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCA9IFJlZmxlY3RlZExpZ2h0KCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSApO1xcXFxuXFxcXHR2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlO1xcXFxuXFxcXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8c3BlY3VsYXJtYXBfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9mcmFnbWVudD5cXFxcblxcXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlID0gZ2V0QW1iaWVudExpZ2h0SXJyYWRpYW5jZSggYW1iaWVudExpZ2h0Q29sb3IgKTtcXFxcblxcXFx0I2luY2x1ZGUgPGxpZ2h0bWFwX2ZyYWdtZW50PlxcXFxuXFxcXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKj0gQlJERl9EaWZmdXNlX0xhbWJlcnQoIGRpZmZ1c2VDb2xvci5yZ2IgKTtcXFxcblxcXFx0I2lmZGVmIERPVUJMRV9TSURFRFxcXFxuXFxcXHRcXFxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgPSAoIGdsX0Zyb250RmFjaW5nICkgPyB2TGlnaHRGcm9udCA6IHZMaWdodEJhY2s7XFxcXG5cXFxcdCNlbHNlXFxcXG5cXFxcdFxcXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSA9IHZMaWdodEZyb250O1xcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSAqPSBCUkRGX0RpZmZ1c2VfTGFtYmVydCggZGlmZnVzZUNvbG9yLnJnYiApICogZ2V0U2hhZG93TWFzaygpO1xcXFxuXFxcXHQjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+XFxcXG5cXFxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7XFxcXG5cXFxcdCNpbmNsdWRlIDxlbnZtYXBfZnJhZ21lbnQ+XFxcXG5cXFxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XFxcXG5cXFxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+XFxcXG59XFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBtZXNobGFtYmVydF92ZXJ0ID0gXFxcIiNkZWZpbmUgTEFNQkVSVFxcXFxudmFyeWluZyB2ZWMzIHZMaWdodEZyb250O1xcXFxuI2lmZGVmIERPVUJMRV9TSURFRFxcXFxuXFxcXHR2YXJ5aW5nIHZlYzMgdkxpZ2h0QmFjaztcXFxcbiNlbmRpZlxcXFxuI2luY2x1ZGUgPGNvbW1vbj5cXFxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDx1djJfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGJzZGZzPlxcXFxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzPlxcXFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcXFxudm9pZCBtYWluKCkge1xcXFxuXFxcXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8dXYyX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxlbnZtYXBfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8bGlnaHRzX2xhbWJlcnRfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxcXG59XFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBtZXNocGhvbmdfZnJhZyA9IFxcXCIjZGVmaW5lIFBIT05HXFxcXG51bmlmb3JtIHZlYzMgZGlmZnVzZTtcXFxcbnVuaWZvcm0gdmVjMyBlbWlzc2l2ZTtcXFxcbnVuaWZvcm0gdmVjMyBzcGVjdWxhcjtcXFxcbnVuaWZvcm0gZmxvYXQgc2hpbmluZXNzO1xcXFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcXFxuI2luY2x1ZGUgPGNvbW1vbj5cXFxcbiNpbmNsdWRlIDxwYWNraW5nPlxcXFxuI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDx1djJfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGdyYWRpZW50bWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8YnNkZnM+XFxcXG4jaW5jbHVkZSA8bGlnaHRzX3BhcnM+XFxcXG4jaW5jbHVkZSA8bGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXFxcbnZvaWQgbWFpbigpIHtcXFxcblxcXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXFxcblxcXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxcXG5cXFxcdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XFxcXG5cXFxcdHZlYzMgdG90YWxFbWlzc2l2ZVJhZGlhbmNlID0gZW1pc3NpdmU7XFxcXG5cXFxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxzcGVjdWxhcm1hcF9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8bGlnaHRzX3Bob25nX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8bGlnaHRzX3RlbXBsYXRlPlxcXFxuXFxcXHQjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+XFxcXG5cXFxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7XFxcXG5cXFxcdCNpbmNsdWRlIDxlbnZtYXBfZnJhZ21lbnQ+XFxcXG5cXFxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XFxcXG5cXFxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+XFxcXG59XFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBtZXNocGhvbmdfdmVydCA9IFxcXCIjZGVmaW5lIFBIT05HXFxcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXFxcbiNpZm5kZWYgRkxBVF9TSEFERURcXFxcblxcXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxcXG4jZW5kaWZcXFxcbiNpbmNsdWRlIDxjb21tb24+XFxcXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8dXYyX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxcXG52b2lkIG1haW4oKSB7XFxcXG5cXFxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDx1djJfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXFxcbiNpZm5kZWYgRkxBVF9TSEFERURcXFxcblxcXFx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcXFxcbiNlbmRpZlxcXFxuXFxcXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXFxcblxcXFx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XFxcXG5cXFxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxlbnZtYXBfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxcXG59XFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBtZXNocGh5c2ljYWxfZnJhZyA9IFxcXCIjZGVmaW5lIFBIWVNJQ0FMXFxcXG51bmlmb3JtIHZlYzMgZGlmZnVzZTtcXFxcbnVuaWZvcm0gdmVjMyBlbWlzc2l2ZTtcXFxcbnVuaWZvcm0gZmxvYXQgcm91Z2huZXNzO1xcXFxudW5pZm9ybSBmbG9hdCBtZXRhbG5lc3M7XFxcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxcXG4jaWZuZGVmIFNUQU5EQVJEXFxcXG5cXFxcdHVuaWZvcm0gZmxvYXQgY2xlYXJDb2F0O1xcXFxuXFxcXHR1bmlmb3JtIGZsb2F0IGNsZWFyQ29hdFJvdWdobmVzcztcXFxcbiNlbmRpZlxcXFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxcXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxcXG5cXFxcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcXFxuI2VuZGlmXFxcXG4jaW5jbHVkZSA8Y29tbW9uPlxcXFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxcXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPHV2Ml9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxsaWdodG1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8YnNkZnM+XFxcXG4jaW5jbHVkZSA8Y3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzPlxcXFxuI2luY2x1ZGUgPGxpZ2h0c19waHlzaWNhbF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxyb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcXFxudm9pZCBtYWluKCkge1xcXFxuXFxcXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcXFxuXFxcXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXFxcblxcXFx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcXFxcblxcXFx0dmVjMyB0b3RhbEVtaXNzaXZlUmFkaWFuY2UgPSBlbWlzc2l2ZTtcXFxcblxcXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPHJvdWdobmVzc21hcF9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPG1ldGFsbmVzc21hcF9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8bGlnaHRzX3BoeXNpY2FsX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8bGlnaHRzX3RlbXBsYXRlPlxcXFxuXFxcXHQjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+XFxcXG5cXFxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7XFxcXG5cXFxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XFxcXG5cXFxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+XFxcXG59XFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBtZXNocGh5c2ljYWxfdmVydCA9IFxcXCIjZGVmaW5lIFBIWVNJQ0FMXFxcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXFxcbiNpZm5kZWYgRkxBVF9TSEFERURcXFxcblxcXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxcXG4jZW5kaWZcXFxcbiNpbmNsdWRlIDxjb21tb24+XFxcXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8dXYyX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXFxcbnZvaWQgbWFpbigpIHtcXFxcblxcXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHV2Ml92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcXFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcXFxuXFxcXHR2Tm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1xcXFxuI2VuZGlmXFxcXG5cXFxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcXFxuXFxcXHR2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcXFxcblxcXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxmb2dfdmVydGV4PlxcXFxufVxcXFxuXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgbm9ybWFsX2ZyYWcgPSBcXFwiI2RlZmluZSBOT1JNQUxcXFxcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXFxcbiNpZiBkZWZpbmVkKCBGTEFUX1NIQURFRCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApXFxcXG5cXFxcdHZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcXFxuI2VuZGlmXFxcXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxcXG5cXFxcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcXFxuI2VuZGlmXFxcXG4jaW5jbHVkZSA8cGFja2luZz5cXFxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcXFxudm9pZCBtYWluKCkge1xcXFxuXFxcXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnQ+XFxcXG5cXFxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIHBhY2tOb3JtYWxUb1JHQiggbm9ybWFsICksIG9wYWNpdHkgKTtcXFxcbn1cXFxcblxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIG5vcm1hbF92ZXJ0ID0gXFxcIiNkZWZpbmUgTk9STUFMXFxcXG4jaWYgZGVmaW5lZCggRkxBVF9TSEFERUQgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKVxcXFxuXFxcXHR2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXFxcbiNlbmRpZlxcXFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcXFxuXFxcXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXFxcbiNlbmRpZlxcXFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXFxcbnZvaWQgbWFpbigpIHtcXFxcblxcXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxcXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxcXG5cXFxcdHZOb3JtYWwgPSBub3JtYWxpemUoIHRyYW5zZm9ybWVkTm9ybWFsICk7XFxcXG4jZW5kaWZcXFxcblxcXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXFxcbiNpZiBkZWZpbmVkKCBGTEFUX1NIQURFRCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApXFxcXG5cXFxcdHZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1xcXFxuI2VuZGlmXFxcXG59XFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBwb2ludHNfZnJhZyA9IFxcXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcXFxcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXFxcbiNpbmNsdWRlIDxjb21tb24+XFxcXG4jaW5jbHVkZSA8cGFja2luZz5cXFxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPG1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxcXG52b2lkIG1haW4oKSB7XFxcXG5cXFxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxcXG5cXFxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1xcXFxuXFxcXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXFxcblxcXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8bWFwX3BhcnRpY2xlX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxcXG5cXFxcdG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiO1xcXFxuXFxcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1xcXFxuXFxcXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcXFxufVxcXFxuXFxcIjtcXHJcXG5cXHJcXG5cXHR2YXIgcG9pbnRzX3ZlcnQgPSBcXFwidW5pZm9ybSBmbG9hdCBzaXplO1xcXFxudW5pZm9ybSBmbG9hdCBzY2FsZTtcXFxcbiNpbmNsdWRlIDxjb21tb24+XFxcXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxcXG52b2lkIG1haW4oKSB7XFxcXG5cXFxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXFxcblxcXFx0I2lmZGVmIFVTRV9TSVpFQVRURU5VQVRJT05cXFxcblxcXFx0XFxcXHRnbF9Qb2ludFNpemUgPSBzaXplICogKCBzY2FsZSAvIC0gbXZQb3NpdGlvbi56ICk7XFxcXG5cXFxcdCNlbHNlXFxcXG5cXFxcdFxcXFx0Z2xfUG9pbnRTaXplID0gc2l6ZTtcXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxcXG59XFxcXG5cXFwiO1xcclxcblxcclxcblxcdHZhciBzaGFkb3dfZnJhZyA9IFxcXCJ1bmlmb3JtIHZlYzMgY29sb3I7XFxcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxcXG4jaW5jbHVkZSA8Y29tbW9uPlxcXFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxcXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8YnNkZnM+XFxcXG4jaW5jbHVkZSA8bGlnaHRzX3BhcnM+XFxcXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8c2hhZG93bWFza19wYXJzX2ZyYWdtZW50PlxcXFxudm9pZCBtYWluKCkge1xcXFxuXFxcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBjb2xvciwgb3BhY2l0eSAqICggMS4wIC0gZ2V0U2hhZG93TWFzaygpICkgKTtcXFxcblxcXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXFxcbn1cXFxcblxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIHNoYWRvd192ZXJ0ID0gXFxcIiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PlxcXFxudm9pZCBtYWluKCkge1xcXFxuXFxcXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXFxcbn1cXFxcblxcXCI7XFxyXFxuXFxyXFxuXFx0dmFyIFNoYWRlckNodW5rID0ge1xcclxcblxcdFxcdGFscGhhbWFwX2ZyYWdtZW50OiBhbHBoYW1hcF9mcmFnbWVudCxcXHJcXG5cXHRcXHRhbHBoYW1hcF9wYXJzX2ZyYWdtZW50OiBhbHBoYW1hcF9wYXJzX2ZyYWdtZW50LFxcclxcblxcdFxcdGFscGhhdGVzdF9mcmFnbWVudDogYWxwaGF0ZXN0X2ZyYWdtZW50LFxcclxcblxcdFxcdGFvbWFwX2ZyYWdtZW50OiBhb21hcF9mcmFnbWVudCxcXHJcXG5cXHRcXHRhb21hcF9wYXJzX2ZyYWdtZW50OiBhb21hcF9wYXJzX2ZyYWdtZW50LFxcclxcblxcdFxcdGJlZ2luX3ZlcnRleDogYmVnaW5fdmVydGV4LFxcclxcblxcdFxcdGJlZ2lubm9ybWFsX3ZlcnRleDogYmVnaW5ub3JtYWxfdmVydGV4LFxcclxcblxcdFxcdGJzZGZzOiBic2RmcyxcXHJcXG5cXHRcXHRidW1wbWFwX3BhcnNfZnJhZ21lbnQ6IGJ1bXBtYXBfcGFyc19mcmFnbWVudCxcXHJcXG5cXHRcXHRjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ6IGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudCxcXHJcXG5cXHRcXHRjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudDogY2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQsXFxyXFxuXFx0XFx0Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4OiBjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXgsXFxyXFxuXFx0XFx0Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleDogY2xpcHBpbmdfcGxhbmVzX3ZlcnRleCxcXHJcXG5cXHRcXHRjb2xvcl9mcmFnbWVudDogY29sb3JfZnJhZ21lbnQsXFxyXFxuXFx0XFx0Y29sb3JfcGFyc19mcmFnbWVudDogY29sb3JfcGFyc19mcmFnbWVudCxcXHJcXG5cXHRcXHRjb2xvcl9wYXJzX3ZlcnRleDogY29sb3JfcGFyc192ZXJ0ZXgsXFxyXFxuXFx0XFx0Y29sb3JfdmVydGV4OiBjb2xvcl92ZXJ0ZXgsXFxyXFxuXFx0XFx0Y29tbW9uOiBjb21tb24sXFxyXFxuXFx0XFx0Y3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50OiBjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQsXFxyXFxuXFx0XFx0ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg6IGRlZmF1bHRub3JtYWxfdmVydGV4LFxcclxcblxcdFxcdGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleDogZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4LFxcclxcblxcdFxcdGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg6IGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXgsXFxyXFxuXFx0XFx0ZW1pc3NpdmVtYXBfZnJhZ21lbnQ6IGVtaXNzaXZlbWFwX2ZyYWdtZW50LFxcclxcblxcdFxcdGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQ6IGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQsXFxyXFxuXFx0XFx0ZW5jb2RpbmdzX2ZyYWdtZW50OiBlbmNvZGluZ3NfZnJhZ21lbnQsXFxyXFxuXFx0XFx0ZW5jb2RpbmdzX3BhcnNfZnJhZ21lbnQ6IGVuY29kaW5nc19wYXJzX2ZyYWdtZW50LFxcclxcblxcdFxcdGVudm1hcF9mcmFnbWVudDogZW52bWFwX2ZyYWdtZW50LFxcclxcblxcdFxcdGVudm1hcF9wYXJzX2ZyYWdtZW50OiBlbnZtYXBfcGFyc19mcmFnbWVudCxcXHJcXG5cXHRcXHRlbnZtYXBfcGFyc192ZXJ0ZXg6IGVudm1hcF9wYXJzX3ZlcnRleCxcXHJcXG5cXHRcXHRlbnZtYXBfdmVydGV4OiBlbnZtYXBfdmVydGV4LFxcclxcblxcdFxcdGZvZ192ZXJ0ZXg6IGZvZ192ZXJ0ZXgsXFxyXFxuXFx0XFx0Zm9nX3BhcnNfdmVydGV4OiBmb2dfcGFyc192ZXJ0ZXgsXFxyXFxuXFx0XFx0Zm9nX2ZyYWdtZW50OiBmb2dfZnJhZ21lbnQsXFxyXFxuXFx0XFx0Zm9nX3BhcnNfZnJhZ21lbnQ6IGZvZ19wYXJzX2ZyYWdtZW50LFxcclxcblxcdFxcdGdyYWRpZW50bWFwX3BhcnNfZnJhZ21lbnQ6IGdyYWRpZW50bWFwX3BhcnNfZnJhZ21lbnQsXFxyXFxuXFx0XFx0bGlnaHRtYXBfZnJhZ21lbnQ6IGxpZ2h0bWFwX2ZyYWdtZW50LFxcclxcblxcdFxcdGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ6IGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQsXFxyXFxuXFx0XFx0bGlnaHRzX2xhbWJlcnRfdmVydGV4OiBsaWdodHNfbGFtYmVydF92ZXJ0ZXgsXFxyXFxuXFx0XFx0bGlnaHRzX3BhcnM6IGxpZ2h0c19wYXJzLFxcclxcblxcdFxcdGxpZ2h0c19waG9uZ19mcmFnbWVudDogbGlnaHRzX3Bob25nX2ZyYWdtZW50LFxcclxcblxcdFxcdGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50OiBsaWdodHNfcGhvbmdfcGFyc19mcmFnbWVudCxcXHJcXG5cXHRcXHRsaWdodHNfcGh5c2ljYWxfZnJhZ21lbnQ6IGxpZ2h0c19waHlzaWNhbF9mcmFnbWVudCxcXHJcXG5cXHRcXHRsaWdodHNfcGh5c2ljYWxfcGFyc19mcmFnbWVudDogbGlnaHRzX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQsXFxyXFxuXFx0XFx0bGlnaHRzX3RlbXBsYXRlOiBsaWdodHNfdGVtcGxhdGUsXFxyXFxuXFx0XFx0bG9nZGVwdGhidWZfZnJhZ21lbnQ6IGxvZ2RlcHRoYnVmX2ZyYWdtZW50LFxcclxcblxcdFxcdGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ6IGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQsXFxyXFxuXFx0XFx0bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg6IGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4LFxcclxcblxcdFxcdGxvZ2RlcHRoYnVmX3ZlcnRleDogbG9nZGVwdGhidWZfdmVydGV4LFxcclxcblxcdFxcdG1hcF9mcmFnbWVudDogbWFwX2ZyYWdtZW50LFxcclxcblxcdFxcdG1hcF9wYXJzX2ZyYWdtZW50OiBtYXBfcGFyc19mcmFnbWVudCxcXHJcXG5cXHRcXHRtYXBfcGFydGljbGVfZnJhZ21lbnQ6IG1hcF9wYXJ0aWNsZV9mcmFnbWVudCxcXHJcXG5cXHRcXHRtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudDogbWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQsXFxyXFxuXFx0XFx0bWV0YWxuZXNzbWFwX2ZyYWdtZW50OiBtZXRhbG5lc3NtYXBfZnJhZ21lbnQsXFxyXFxuXFx0XFx0bWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQ6IG1ldGFsbmVzc21hcF9wYXJzX2ZyYWdtZW50LFxcclxcblxcdFxcdG1vcnBobm9ybWFsX3ZlcnRleDogbW9ycGhub3JtYWxfdmVydGV4LFxcclxcblxcdFxcdG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4OiBtb3JwaHRhcmdldF9wYXJzX3ZlcnRleCxcXHJcXG5cXHRcXHRtb3JwaHRhcmdldF92ZXJ0ZXg6IG1vcnBodGFyZ2V0X3ZlcnRleCxcXHJcXG5cXHRcXHRub3JtYWxfZnJhZ21lbnQ6IG5vcm1hbF9mcmFnbWVudCxcXHJcXG5cXHRcXHRub3JtYWxtYXBfcGFyc19mcmFnbWVudDogbm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQsXFxyXFxuXFx0XFx0cGFja2luZzogcGFja2luZyxcXHJcXG5cXHRcXHRwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50OiBwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50LFxcclxcblxcdFxcdHByb2plY3RfdmVydGV4OiBwcm9qZWN0X3ZlcnRleCxcXHJcXG5cXHRcXHRkaXRoZXJpbmdfZnJhZ21lbnQ6IGRpdGhlcmluZ19mcmFnbWVudCxcXHJcXG5cXHRcXHRkaXRoZXJpbmdfcGFyc19mcmFnbWVudDogZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQsXFxyXFxuXFx0XFx0cm91Z2huZXNzbWFwX2ZyYWdtZW50OiByb3VnaG5lc3NtYXBfZnJhZ21lbnQsXFxyXFxuXFx0XFx0cm91Z2huZXNzbWFwX3BhcnNfZnJhZ21lbnQ6IHJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50LFxcclxcblxcdFxcdHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50OiBzaGFkb3dtYXBfcGFyc19mcmFnbWVudCxcXHJcXG5cXHRcXHRzaGFkb3dtYXBfcGFyc192ZXJ0ZXg6IHNoYWRvd21hcF9wYXJzX3ZlcnRleCxcXHJcXG5cXHRcXHRzaGFkb3dtYXBfdmVydGV4OiBzaGFkb3dtYXBfdmVydGV4LFxcclxcblxcdFxcdHNoYWRvd21hc2tfcGFyc19mcmFnbWVudDogc2hhZG93bWFza19wYXJzX2ZyYWdtZW50LFxcclxcblxcdFxcdHNraW5iYXNlX3ZlcnRleDogc2tpbmJhc2VfdmVydGV4LFxcclxcblxcdFxcdHNraW5uaW5nX3BhcnNfdmVydGV4OiBza2lubmluZ19wYXJzX3ZlcnRleCxcXHJcXG5cXHRcXHRza2lubmluZ192ZXJ0ZXg6IHNraW5uaW5nX3ZlcnRleCxcXHJcXG5cXHRcXHRza2lubm9ybWFsX3ZlcnRleDogc2tpbm5vcm1hbF92ZXJ0ZXgsXFxyXFxuXFx0XFx0c3BlY3VsYXJtYXBfZnJhZ21lbnQ6IHNwZWN1bGFybWFwX2ZyYWdtZW50LFxcclxcblxcdFxcdHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ6IHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQsXFxyXFxuXFx0XFx0dG9uZW1hcHBpbmdfZnJhZ21lbnQ6IHRvbmVtYXBwaW5nX2ZyYWdtZW50LFxcclxcblxcdFxcdHRvbmVtYXBwaW5nX3BhcnNfZnJhZ21lbnQ6IHRvbmVtYXBwaW5nX3BhcnNfZnJhZ21lbnQsXFxyXFxuXFx0XFx0dXZfcGFyc19mcmFnbWVudDogdXZfcGFyc19mcmFnbWVudCxcXHJcXG5cXHRcXHR1dl9wYXJzX3ZlcnRleDogdXZfcGFyc192ZXJ0ZXgsXFxyXFxuXFx0XFx0dXZfdmVydGV4OiB1dl92ZXJ0ZXgsXFxyXFxuXFx0XFx0dXYyX3BhcnNfZnJhZ21lbnQ6IHV2Ml9wYXJzX2ZyYWdtZW50LFxcclxcblxcdFxcdHV2Ml9wYXJzX3ZlcnRleDogdXYyX3BhcnNfdmVydGV4LFxcclxcblxcdFxcdHV2Ml92ZXJ0ZXg6IHV2Ml92ZXJ0ZXgsXFxyXFxuXFx0XFx0d29ybGRwb3NfdmVydGV4OiB3b3JsZHBvc192ZXJ0ZXgsXFxyXFxuXFxyXFxuXFx0XFx0Y3ViZV9mcmFnOiBjdWJlX2ZyYWcsXFxyXFxuXFx0XFx0Y3ViZV92ZXJ0OiBjdWJlX3ZlcnQsXFxyXFxuXFx0XFx0ZGVwdGhfZnJhZzogZGVwdGhfZnJhZyxcXHJcXG5cXHRcXHRkZXB0aF92ZXJ0OiBkZXB0aF92ZXJ0LFxcclxcblxcdFxcdGRpc3RhbmNlUkdCQV9mcmFnOiBkaXN0YW5jZVJHQkFfZnJhZyxcXHJcXG5cXHRcXHRkaXN0YW5jZVJHQkFfdmVydDogZGlzdGFuY2VSR0JBX3ZlcnQsXFxyXFxuXFx0XFx0ZXF1aXJlY3RfZnJhZzogZXF1aXJlY3RfZnJhZyxcXHJcXG5cXHRcXHRlcXVpcmVjdF92ZXJ0OiBlcXVpcmVjdF92ZXJ0LFxcclxcblxcdFxcdGxpbmVkYXNoZWRfZnJhZzogbGluZWRhc2hlZF9mcmFnLFxcclxcblxcdFxcdGxpbmVkYXNoZWRfdmVydDogbGluZWRhc2hlZF92ZXJ0LFxcclxcblxcdFxcdG1lc2hiYXNpY19mcmFnOiBtZXNoYmFzaWNfZnJhZyxcXHJcXG5cXHRcXHRtZXNoYmFzaWNfdmVydDogbWVzaGJhc2ljX3ZlcnQsXFxyXFxuXFx0XFx0bWVzaGxhbWJlcnRfZnJhZzogbWVzaGxhbWJlcnRfZnJhZyxcXHJcXG5cXHRcXHRtZXNobGFtYmVydF92ZXJ0OiBtZXNobGFtYmVydF92ZXJ0LFxcclxcblxcdFxcdG1lc2hwaG9uZ19mcmFnOiBtZXNocGhvbmdfZnJhZyxcXHJcXG5cXHRcXHRtZXNocGhvbmdfdmVydDogbWVzaHBob25nX3ZlcnQsXFxyXFxuXFx0XFx0bWVzaHBoeXNpY2FsX2ZyYWc6IG1lc2hwaHlzaWNhbF9mcmFnLFxcclxcblxcdFxcdG1lc2hwaHlzaWNhbF92ZXJ0OiBtZXNocGh5c2ljYWxfdmVydCxcXHJcXG5cXHRcXHRub3JtYWxfZnJhZzogbm9ybWFsX2ZyYWcsXFxyXFxuXFx0XFx0bm9ybWFsX3ZlcnQ6IG5vcm1hbF92ZXJ0LFxcclxcblxcdFxcdHBvaW50c19mcmFnOiBwb2ludHNfZnJhZyxcXHJcXG5cXHRcXHRwb2ludHNfdmVydDogcG9pbnRzX3ZlcnQsXFxyXFxuXFx0XFx0c2hhZG93X2ZyYWc6IHNoYWRvd19mcmFnLFxcclxcblxcdFxcdHNoYWRvd192ZXJ0OiBzaGFkb3dfdmVydFxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0dmFyIFNoYWRlckxpYiA9IHtcXHJcXG5cXHJcXG5cXHRcXHRiYXNpYzoge1xcclxcblxcclxcblxcdFxcdFxcdHVuaWZvcm1zOiBVbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXFxyXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuY29tbW9uLFxcclxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLnNwZWN1bGFybWFwLFxcclxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmVudm1hcCxcXHJcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5hb21hcCxcXHJcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5saWdodG1hcCxcXHJcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5mb2dcXHJcXG5cXHRcXHRcXHRdICksXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNoYmFzaWNfdmVydCxcXHJcXG5cXHRcXHRcXHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaGJhc2ljX2ZyYWdcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGxhbWJlcnQ6IHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR1bmlmb3JtczogVW5pZm9ybXNVdGlscy5tZXJnZSggW1xcclxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmNvbW1vbixcXHJcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5zcGVjdWxhcm1hcCxcXHJcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5lbnZtYXAsXFxyXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuYW9tYXAsXFxyXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIubGlnaHRtYXAsXFxyXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuZW1pc3NpdmVtYXAsXFxyXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuZm9nLFxcclxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmxpZ2h0cyxcXHJcXG5cXHRcXHRcXHRcXHR7XFxyXFxuXFx0XFx0XFx0XFx0XFx0ZW1pc3NpdmU6IHsgdmFsdWU6IG5ldyBDb2xvciggMHgwMDAwMDAgKSB9XFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcdFxcdFxcdF0gKSxcXHJcXG5cXHJcXG5cXHRcXHRcXHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hsYW1iZXJ0X3ZlcnQsXFxyXFxuXFx0XFx0XFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hsYW1iZXJ0X2ZyYWdcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHBob25nOiB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dW5pZm9ybXM6IFVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcXHJcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5jb21tb24sXFxyXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuc3BlY3VsYXJtYXAsXFxyXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuZW52bWFwLFxcclxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmFvbWFwLFxcclxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmxpZ2h0bWFwLFxcclxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmVtaXNzaXZlbWFwLFxcclxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmJ1bXBtYXAsXFxyXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIubm9ybWFsbWFwLFxcclxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmRpc3BsYWNlbWVudG1hcCxcXHJcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5ncmFkaWVudG1hcCxcXHJcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5mb2csXFxyXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIubGlnaHRzLFxcclxcblxcdFxcdFxcdFxcdHtcXHJcXG5cXHRcXHRcXHRcXHRcXHRlbWlzc2l2ZTogeyB2YWx1ZTogbmV3IENvbG9yKCAweDAwMDAwMCApIH0sXFxyXFxuXFx0XFx0XFx0XFx0XFx0c3BlY3VsYXI6IHsgdmFsdWU6IG5ldyBDb2xvciggMHgxMTExMTEgKSB9LFxcclxcblxcdFxcdFxcdFxcdFxcdHNoaW5pbmVzczogeyB2YWx1ZTogMzAgfVxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHRcXHRcXHRdICksXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNocGhvbmdfdmVydCxcXHJcXG5cXHRcXHRcXHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBob25nX2ZyYWdcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHN0YW5kYXJkOiB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dW5pZm9ybXM6IFVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcXHJcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5jb21tb24sXFxyXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuZW52bWFwLFxcclxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmFvbWFwLFxcclxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmxpZ2h0bWFwLFxcclxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmVtaXNzaXZlbWFwLFxcclxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmJ1bXBtYXAsXFxyXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIubm9ybWFsbWFwLFxcclxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmRpc3BsYWNlbWVudG1hcCxcXHJcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5yb3VnaG5lc3NtYXAsXFxyXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIubWV0YWxuZXNzbWFwLFxcclxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmZvZyxcXHJcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5saWdodHMsXFxyXFxuXFx0XFx0XFx0XFx0e1xcclxcblxcdFxcdFxcdFxcdFxcdGVtaXNzaXZlOiB7IHZhbHVlOiBuZXcgQ29sb3IoIDB4MDAwMDAwICkgfSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRyb3VnaG5lc3M6IHsgdmFsdWU6IDAuNSB9LFxcclxcblxcdFxcdFxcdFxcdFxcdG1ldGFsbmVzczogeyB2YWx1ZTogMC41IH0sXFxyXFxuXFx0XFx0XFx0XFx0XFx0ZW52TWFwSW50ZW5zaXR5OiB7IHZhbHVlOiAxIH0gLy8gdGVtcG9yYXJ5XFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcdFxcdFxcdF0gKSxcXHJcXG5cXHJcXG5cXHRcXHRcXHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaHlzaWNhbF92ZXJ0LFxcclxcblxcdFxcdFxcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNocGh5c2ljYWxfZnJhZ1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0cG9pbnRzOiB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dW5pZm9ybXM6IFVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcXHJcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5wb2ludHMsXFxyXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuZm9nXFxyXFxuXFx0XFx0XFx0XSApLFxcclxcblxcclxcblxcdFxcdFxcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsucG9pbnRzX3ZlcnQsXFxyXFxuXFx0XFx0XFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLnBvaW50c19mcmFnXFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRkYXNoZWQ6IHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR1bmlmb3JtczogVW5pZm9ybXNVdGlscy5tZXJnZSggW1xcclxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmNvbW1vbixcXHJcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5mb2csXFxyXFxuXFx0XFx0XFx0XFx0e1xcclxcblxcdFxcdFxcdFxcdFxcdHNjYWxlOiB7IHZhbHVlOiAxIH0sXFxyXFxuXFx0XFx0XFx0XFx0XFx0ZGFzaFNpemU6IHsgdmFsdWU6IDEgfSxcXHJcXG5cXHRcXHRcXHRcXHRcXHR0b3RhbFNpemU6IHsgdmFsdWU6IDIgfVxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHRcXHRcXHRdICksXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5saW5lZGFzaGVkX3ZlcnQsXFxyXFxuXFx0XFx0XFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmxpbmVkYXNoZWRfZnJhZ1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0ZGVwdGg6IHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR1bmlmb3JtczogVW5pZm9ybXNVdGlscy5tZXJnZSggW1xcclxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmNvbW1vbixcXHJcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXBcXHJcXG5cXHRcXHRcXHRdICksXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5kZXB0aF92ZXJ0LFxcclxcblxcdFxcdFxcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5kZXB0aF9mcmFnXFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRub3JtYWw6IHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR1bmlmb3JtczogVW5pZm9ybXNVdGlscy5tZXJnZSggW1xcclxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmNvbW1vbixcXHJcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5idW1wbWFwLFxcclxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLm5vcm1hbG1hcCxcXHJcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXAsXFxyXFxuXFx0XFx0XFx0XFx0e1xcclxcblxcdFxcdFxcdFxcdFxcdG9wYWNpdHk6IHsgdmFsdWU6IDEuMCB9XFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcdFxcdFxcdF0gKSxcXHJcXG5cXHJcXG5cXHRcXHRcXHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm5vcm1hbF92ZXJ0LFxcclxcblxcdFxcdFxcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5ub3JtYWxfZnJhZ1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcclxcblxcdFxcdC8vXFx0Q3ViZSBtYXAgc2hhZGVyXFxyXFxuXFx0XFx0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cXHJcXG5cXHJcXG5cXHRcXHRjdWJlOiB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dW5pZm9ybXM6IHtcXHJcXG5cXHRcXHRcXHRcXHR0Q3ViZTogeyB2YWx1ZTogbnVsbCB9LFxcclxcblxcdFxcdFxcdFxcdHRGbGlwOiB7IHZhbHVlOiAtIDEgfSxcXHJcXG5cXHRcXHRcXHRcXHRvcGFjaXR5OiB7IHZhbHVlOiAxLjAgfVxcclxcblxcdFxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5jdWJlX3ZlcnQsXFxyXFxuXFx0XFx0XFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmN1YmVfZnJhZ1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0ZXF1aXJlY3Q6IHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR1bmlmb3Jtczoge1xcclxcblxcdFxcdFxcdFxcdHRFcXVpcmVjdDogeyB2YWx1ZTogbnVsbCB9LFxcclxcblxcdFxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5lcXVpcmVjdF92ZXJ0LFxcclxcblxcdFxcdFxcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5lcXVpcmVjdF9mcmFnXFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRkaXN0YW5jZVJHQkE6IHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR1bmlmb3JtczogVW5pZm9ybXNVdGlscy5tZXJnZSggW1xcclxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmNvbW1vbixcXHJcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXAsXFxyXFxuXFx0XFx0XFx0XFx0e1xcclxcblxcdFxcdFxcdFxcdFxcdHJlZmVyZW5jZVBvc2l0aW9uOiB7IHZhbHVlOiBuZXcgVmVjdG9yMygpIH0sXFxyXFxuXFx0XFx0XFx0XFx0XFx0bmVhckRpc3RhbmNlOiB7IHZhbHVlOiAxIH0sXFxyXFxuXFx0XFx0XFx0XFx0XFx0ZmFyRGlzdGFuY2U6IHsgdmFsdWU6IDEwMDAgfVxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHRcXHRcXHRdICksXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5kaXN0YW5jZVJHQkFfdmVydCxcXHJcXG5cXHRcXHRcXHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsuZGlzdGFuY2VSR0JBX2ZyYWdcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNoYWRvdzoge1xcclxcblxcclxcblxcdFxcdFxcdHVuaWZvcm1zOiBVbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXFxyXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIubGlnaHRzLFxcclxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmZvZyxcXHJcXG5cXHRcXHRcXHRcXHR7XFxyXFxuXFx0XFx0XFx0XFx0XFx0Y29sb3I6IHsgdmFsdWU6IG5ldyBDb2xvciggMHgwMDAwMCApIH0sXFxyXFxuXFx0XFx0XFx0XFx0XFx0b3BhY2l0eTogeyB2YWx1ZTogMS4wIH1cXHJcXG5cXHRcXHRcXHRcXHR9LFxcclxcblxcdFxcdFxcdF0gKSxcXHJcXG5cXHJcXG5cXHRcXHRcXHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLnNoYWRvd192ZXJ0LFxcclxcblxcdFxcdFxcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5zaGFkb3dfZnJhZ1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9O1xcclxcblxcclxcblxcdFNoYWRlckxpYi5waHlzaWNhbCA9IHtcXHJcXG5cXHJcXG5cXHRcXHR1bmlmb3JtczogVW5pZm9ybXNVdGlscy5tZXJnZSggW1xcclxcblxcdFxcdFxcdFNoYWRlckxpYi5zdGFuZGFyZC51bmlmb3JtcyxcXHJcXG5cXHRcXHRcXHR7XFxyXFxuXFx0XFx0XFx0XFx0Y2xlYXJDb2F0OiB7IHZhbHVlOiAwIH0sXFxyXFxuXFx0XFx0XFx0XFx0Y2xlYXJDb2F0Um91Z2huZXNzOiB7IHZhbHVlOiAwIH1cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFx0XFx0XSApLFxcclxcblxcclxcblxcdFxcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBoeXNpY2FsX3ZlcnQsXFxyXFxuXFx0XFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaHlzaWNhbF9mcmFnXFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gQm94MiggbWluLCBtYXggKSB7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5taW4gPSAoIG1pbiAhPT0gdW5kZWZpbmVkICkgPyBtaW4gOiBuZXcgVmVjdG9yMiggKyBJbmZpbml0eSwgKyBJbmZpbml0eSApO1xcclxcblxcdFxcdHRoaXMubWF4ID0gKCBtYXggIT09IHVuZGVmaW5lZCApID8gbWF4IDogbmV3IFZlY3RvcjIoIC0gSW5maW5pdHksIC0gSW5maW5pdHkgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0T2JqZWN0LmFzc2lnbiggQm94Mi5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5taW4uY29weSggbWluICk7XFxyXFxuXFx0XFx0XFx0dGhpcy5tYXguY29weSggbWF4ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoIHBvaW50cyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm1ha2VFbXB0eSgpO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5leHBhbmRCeVBvaW50KCBwb2ludHNbIGkgXSApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldEZyb21DZW50ZXJBbmRTaXplOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjIoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gc2V0RnJvbUNlbnRlckFuZFNpemUoIGNlbnRlciwgc2l6ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgaGFsZlNpemUgPSB2MS5jb3B5KCBzaXplICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xcclxcblxcdFxcdFxcdFxcdHRoaXMubWluLmNvcHkoIGNlbnRlciApLnN1YiggaGFsZlNpemUgKTtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLm1heC5jb3B5KCBjZW50ZXIgKS5hZGQoIGhhbGZTaXplICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR9KCksXFxyXFxuXFxyXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIGJveCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm1pbi5jb3B5KCBib3gubWluICk7XFxyXFxuXFx0XFx0XFx0dGhpcy5tYXguY29weSggYm94Lm1heCApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0bWFrZUVtcHR5OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5taW4ueCA9IHRoaXMubWluLnkgPSArIEluZmluaXR5O1xcclxcblxcdFxcdFxcdHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gLSBJbmZpbml0eTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyB0aGlzIGlzIGEgbW9yZSByb2J1c3QgY2hlY2sgZm9yIGVtcHR5IHRoYW4gKCB2b2x1bWUgPD0gMCApIGJlY2F1c2Ugdm9sdW1lIGNhbiBnZXQgcG9zaXRpdmUgd2l0aCB0d28gbmVnYXRpdmUgYXhlc1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiAoIHRoaXMubWF4LnggPCB0aGlzLm1pbi54ICkgfHwgKCB0aGlzLm1heC55IDwgdGhpcy5taW4ueSApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMigpO1xcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IHJlc3VsdC5zZXQoIDAsIDAgKSA6IHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLm1pbiwgdGhpcy5tYXggKS5tdWx0aXBseVNjYWxhciggMC41ICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRnZXRTaXplOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMigpO1xcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IHJlc3VsdC5zZXQoIDAsIDAgKSA6IHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLm1heCwgdGhpcy5taW4gKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGV4cGFuZEJ5UG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5taW4ubWluKCBwb2ludCApO1xcclxcblxcdFxcdFxcdHRoaXMubWF4Lm1heCggcG9pbnQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGV4cGFuZEJ5VmVjdG9yOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm1pbi5zdWIoIHZlY3RvciApO1xcclxcblxcdFxcdFxcdHRoaXMubWF4LmFkZCggdmVjdG9yICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRleHBhbmRCeVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5taW4uYWRkU2NhbGFyKCAtIHNjYWxhciApO1xcclxcblxcdFxcdFxcdHRoaXMubWF4LmFkZFNjYWxhciggc2NhbGFyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBwb2ludC54IDwgdGhpcy5taW4ueCB8fCBwb2ludC54ID4gdGhpcy5tYXgueCB8fFxcclxcblxcdFxcdFxcdFxcdHBvaW50LnkgPCB0aGlzLm1pbi55IHx8IHBvaW50LnkgPiB0aGlzLm1heC55ID8gZmFsc2UgOiB0cnVlO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y29udGFpbnNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLm1pbi54IDw9IGJveC5taW4ueCAmJiBib3gubWF4LnggPD0gdGhpcy5tYXgueCAmJlxcclxcblxcdFxcdFxcdFxcdHRoaXMubWluLnkgPD0gYm94Lm1pbi55ICYmIGJveC5tYXgueSA8PSB0aGlzLm1heC55O1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Z2V0UGFyYW1ldGVyOiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBUaGlzIGNhbiBwb3RlbnRpYWxseSBoYXZlIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIGJveFxcclxcblxcdFxcdFxcdC8vIGhhcyBhIHNpemUgZGltZW5zaW9uIG9mIDAuXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IyKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHJlc3VsdC5zZXQoXFxyXFxuXFx0XFx0XFx0XFx0KCBwb2ludC54IC0gdGhpcy5taW4ueCApIC8gKCB0aGlzLm1heC54IC0gdGhpcy5taW4ueCApLFxcclxcblxcdFxcdFxcdFxcdCggcG9pbnQueSAtIHRoaXMubWluLnkgKSAvICggdGhpcy5tYXgueSAtIHRoaXMubWluLnkgKVxcclxcblxcdFxcdFxcdCk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRpbnRlcnNlY3RzQm94OiBmdW5jdGlvbiAoIGJveCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyB1c2luZyA0IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9uc1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBib3gubWF4LnggPCB0aGlzLm1pbi54IHx8IGJveC5taW4ueCA+IHRoaXMubWF4LnggfHxcXHJcXG5cXHRcXHRcXHRcXHRib3gubWF4LnkgPCB0aGlzLm1pbi55IHx8IGJveC5taW4ueSA+IHRoaXMubWF4LnkgPyBmYWxzZSA6IHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjbGFtcFBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjIoKTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0LmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjIoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gZGlzdGFuY2VUb1BvaW50KCBwb2ludCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgY2xhbXBlZFBvaW50ID0gdjEuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGNsYW1wZWRQb2ludC5zdWIoIHBvaW50ICkubGVuZ3RoKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR9KCksXFxyXFxuXFxyXFxuXFx0XFx0aW50ZXJzZWN0OiBmdW5jdGlvbiAoIGJveCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm1pbi5tYXgoIGJveC5taW4gKTtcXHJcXG5cXHRcXHRcXHR0aGlzLm1heC5taW4oIGJveC5tYXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHVuaW9uOiBmdW5jdGlvbiAoIGJveCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm1pbi5taW4oIGJveC5taW4gKTtcXHJcXG5cXHRcXHRcXHR0aGlzLm1heC5tYXgoIGJveC5tYXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBvZmZzZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5taW4uYWRkKCBvZmZzZXQgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLm1heC5hZGQoIG9mZnNldCApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0ZXF1YWxzOiBmdW5jdGlvbiAoIGJveCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gYm94Lm1pbi5lcXVhbHMoIHRoaXMubWluICkgJiYgYm94Lm1heC5lcXVhbHMoIHRoaXMubWF4ICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xcclxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gV2ViR0xGbGFyZVJlbmRlcmVyKCByZW5kZXJlciwgZ2wsIHN0YXRlLCB0ZXh0dXJlcywgY2FwYWJpbGl0aWVzICkge1xcclxcblxcclxcblxcdFxcdHZhciB2ZXJ0ZXhCdWZmZXIsIGVsZW1lbnRCdWZmZXI7XFxyXFxuXFx0XFx0dmFyIHNoYWRlciwgcHJvZ3JhbSwgYXR0cmlidXRlcywgdW5pZm9ybXM7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHRlbXBUZXh0dXJlLCBvY2NsdXNpb25UZXh0dXJlO1xcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIGluaXQoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggW1xcclxcblxcdFxcdFxcdFxcdC0gMSwgLSAxLCAwLCAwLFxcclxcblxcdFxcdFxcdFxcdCAgMSwgLSAxLCAxLCAwLFxcclxcblxcdFxcdFxcdFxcdCAgMSwgMSwgMSwgMSxcXHJcXG5cXHRcXHRcXHRcXHQtIDEsIDEsIDAsIDFcXHJcXG5cXHRcXHRcXHRdICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGZhY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbXFxyXFxuXFx0XFx0XFx0XFx0MCwgMSwgMixcXHJcXG5cXHRcXHRcXHRcXHQwLCAyLCAzXFxyXFxuXFx0XFx0XFx0XSApO1xcclxcblxcclxcblxcdFxcdFxcdC8vIGJ1ZmZlcnNcXHJcXG5cXHJcXG5cXHRcXHRcXHR2ZXJ0ZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcXHJcXG5cXHRcXHRcXHRlbGVtZW50QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Z2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIgKTtcXHJcXG5cXHRcXHRcXHRnbC5idWZmZXJEYXRhKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRpY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xcclxcblxcclxcblxcdFxcdFxcdGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XFxyXFxuXFx0XFx0XFx0Z2wuYnVmZmVyRGF0YSggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGZhY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xcclxcblxcclxcblxcdFxcdFxcdC8vIHRleHR1cmVzXFxyXFxuXFxyXFxuXFx0XFx0XFx0dGVtcFRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XFxyXFxuXFx0XFx0XFx0b2NjbHVzaW9uVGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgdGVtcFRleHR1cmUgKTtcXHJcXG5cXHRcXHRcXHRnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0IsIDE2LCAxNiwgMCwgZ2wuUkdCLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsICk7XFxyXFxuXFx0XFx0XFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UgKTtcXHJcXG5cXHRcXHRcXHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSApO1xcclxcblxcdFxcdFxcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xcclxcblxcdFxcdFxcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xcclxcblxcclxcblxcdFxcdFxcdHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBvY2NsdXNpb25UZXh0dXJlICk7XFxyXFxuXFx0XFx0XFx0Z2wudGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgMTYsIDE2LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsICk7XFxyXFxuXFx0XFx0XFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UgKTtcXHJcXG5cXHRcXHRcXHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSApO1xcclxcblxcdFxcdFxcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xcclxcblxcdFxcdFxcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xcclxcblxcclxcblxcdFxcdFxcdHNoYWRlciA9IHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2ZXJ0ZXhTaGFkZXI6IFtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQndW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlOycsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0J3VuaWZvcm0gdmVjMyBzY3JlZW5Qb3NpdGlvbjsnLFxcclxcblxcdFxcdFxcdFxcdFxcdCd1bmlmb3JtIHZlYzIgc2NhbGU7JyxcXHJcXG5cXHRcXHRcXHRcXHRcXHQndW5pZm9ybSBmbG9hdCByb3RhdGlvbjsnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdCd1bmlmb3JtIHNhbXBsZXIyRCBvY2NsdXNpb25NYXA7JyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQnYXR0cmlidXRlIHZlYzIgcG9zaXRpb247JyxcXHJcXG5cXHRcXHRcXHRcXHRcXHQnYXR0cmlidXRlIHZlYzIgdXY7JyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQndmFyeWluZyB2ZWMyIHZVVjsnLFxcclxcblxcdFxcdFxcdFxcdFxcdCd2YXJ5aW5nIGZsb2F0IHZWaXNpYmlsaXR5OycsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0J3ZvaWQgbWFpbigpIHsnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdCdcXHR2VVYgPSB1djsnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdCdcXHR2ZWMyIHBvcyA9IHBvc2l0aW9uOycsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0J1xcdGlmICggcmVuZGVyVHlwZSA9PSAyICkgeycsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0J1xcdFxcdHZlYzQgdmlzaWJpbGl0eSA9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuMSApICk7JyxcXHJcXG5cXHRcXHRcXHRcXHRcXHQnXFx0XFx0dmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjEgKSApOycsXFxyXFxuXFx0XFx0XFx0XFx0XFx0J1xcdFxcdHZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC4xICkgKTsnLFxcclxcblxcdFxcdFxcdFxcdFxcdCdcXHRcXHR2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuNSApICk7JyxcXHJcXG5cXHRcXHRcXHRcXHRcXHQnXFx0XFx0dmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjkgKSApOycsXFxyXFxuXFx0XFx0XFx0XFx0XFx0J1xcdFxcdHZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC45ICkgKTsnLFxcclxcblxcdFxcdFxcdFxcdFxcdCdcXHRcXHR2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuOSApICk7JyxcXHJcXG5cXHRcXHRcXHRcXHRcXHQnXFx0XFx0dmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjUgKSApOycsXFxyXFxuXFx0XFx0XFx0XFx0XFx0J1xcdFxcdHZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC41ICkgKTsnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdCdcXHRcXHR2VmlzaWJpbGl0eSA9ICAgICAgICB2aXNpYmlsaXR5LnIgLyA5LjA7JyxcXHJcXG5cXHRcXHRcXHRcXHRcXHQnXFx0XFx0dlZpc2liaWxpdHkgKj0gMS4wIC0gdmlzaWJpbGl0eS5nIC8gOS4wOycsXFxyXFxuXFx0XFx0XFx0XFx0XFx0J1xcdFxcdHZWaXNpYmlsaXR5ICo9ICAgICAgIHZpc2liaWxpdHkuYiAvIDkuMDsnLFxcclxcblxcdFxcdFxcdFxcdFxcdCdcXHRcXHR2VmlzaWJpbGl0eSAqPSAxLjAgLSB2aXNpYmlsaXR5LmEgLyA5LjA7JyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQnXFx0XFx0cG9zLnggPSBjb3MoIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueTsnLFxcclxcblxcdFxcdFxcdFxcdFxcdCdcXHRcXHRwb3MueSA9IHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBwb3NpdGlvbi55OycsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0J1xcdH0nLFxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdCdcXHRnbF9Qb3NpdGlvbiA9IHZlYzQoICggcG9zICogc2NhbGUgKyBzY3JlZW5Qb3NpdGlvbi54eSApLnh5LCBzY3JlZW5Qb3NpdGlvbi56LCAxLjAgKTsnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdCd9J1xcclxcblxcclxcblxcdFxcdFxcdFxcdF0uam9pbiggJ1xcXFxuJyApLFxcclxcblxcclxcblxcdFxcdFxcdFxcdGZyYWdtZW50U2hhZGVyOiBbXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0J3VuaWZvcm0gbG93cCBpbnQgcmVuZGVyVHlwZTsnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdCd1bmlmb3JtIHNhbXBsZXIyRCBtYXA7JyxcXHJcXG5cXHRcXHRcXHRcXHRcXHQndW5pZm9ybSBmbG9hdCBvcGFjaXR5OycsXFxyXFxuXFx0XFx0XFx0XFx0XFx0J3VuaWZvcm0gdmVjMyBjb2xvcjsnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdCd2YXJ5aW5nIHZlYzIgdlVWOycsXFxyXFxuXFx0XFx0XFx0XFx0XFx0J3ZhcnlpbmcgZmxvYXQgdlZpc2liaWxpdHk7JyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQndm9pZCBtYWluKCkgeycsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gcGluayBzcXVhcmVcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQnXFx0aWYgKCByZW5kZXJUeXBlID09IDAgKSB7JyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQnXFx0XFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggMS4wLCAwLjAsIDEuMCwgMC4wICk7JyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyByZXN0b3JlXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0J1xcdH0gZWxzZSBpZiAoIHJlbmRlclR5cGUgPT0gMSApIHsnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdCdcXHRcXHRnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7JyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBmbGFyZVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdCdcXHR9IGVsc2UgeycsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0J1xcdFxcdHZlYzQgdGV4dHVyZSA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTsnLFxcclxcblxcdFxcdFxcdFxcdFxcdCdcXHRcXHR0ZXh0dXJlLmEgKj0gb3BhY2l0eSAqIHZWaXNpYmlsaXR5OycsXFxyXFxuXFx0XFx0XFx0XFx0XFx0J1xcdFxcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmU7JyxcXHJcXG5cXHRcXHRcXHRcXHRcXHQnXFx0XFx0Z2xfRnJhZ0NvbG9yLnJnYiAqPSBjb2xvcjsnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdCdcXHR9JyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQnfSdcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRdLmpvaW4oICdcXFxcbicgKVxcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0XFx0cHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0oIHNoYWRlciApO1xcclxcblxcclxcblxcdFxcdFxcdGF0dHJpYnV0ZXMgPSB7XFxyXFxuXFx0XFx0XFx0XFx0dmVydGV4OiBnbC5nZXRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgJ3Bvc2l0aW9uJyApLFxcclxcblxcdFxcdFxcdFxcdHV2OiBnbC5nZXRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgJ3V2JyApXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR1bmlmb3JtcyA9IHtcXHJcXG5cXHRcXHRcXHRcXHRyZW5kZXJUeXBlOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdyZW5kZXJUeXBlJyApLFxcclxcblxcdFxcdFxcdFxcdG1hcDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnbWFwJyApLFxcclxcblxcdFxcdFxcdFxcdG9jY2x1c2lvbk1hcDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnb2NjbHVzaW9uTWFwJyApLFxcclxcblxcdFxcdFxcdFxcdG9wYWNpdHk6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ29wYWNpdHknICksXFxyXFxuXFx0XFx0XFx0XFx0Y29sb3I6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2NvbG9yJyApLFxcclxcblxcdFxcdFxcdFxcdHNjYWxlOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdzY2FsZScgKSxcXHJcXG5cXHRcXHRcXHRcXHRyb3RhdGlvbjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAncm90YXRpb24nICksXFxyXFxuXFx0XFx0XFx0XFx0c2NyZWVuUG9zaXRpb246IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3NjcmVlblBvc2l0aW9uJyApXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0LypcXHJcXG5cXHRcXHQgKiBSZW5kZXIgbGVucyBmbGFyZXNcXHJcXG5cXHRcXHQgKiBNZXRob2Q6IHJlbmRlcnMgMTZ4MTYgMHhmZjAwZmYtY29sb3JlZCBwb2ludHMgc2NhdHRlcmVkIG92ZXIgdGhlIGxpZ2h0IHNvdXJjZSBhcmVhLFxcclxcblxcdFxcdCAqICAgICAgICAgcmVhZHMgdGhlc2UgYmFjayBhbmQgY2FsY3VsYXRlcyBvY2NsdXNpb24uXFxyXFxuXFx0XFx0ICovXFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIGZsYXJlcywgc2NlbmUsIGNhbWVyYSwgdmlld3BvcnQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBmbGFyZXMubGVuZ3RoID09PSAwICkgcmV0dXJuO1xcclxcblxcclxcblxcdFxcdFxcdHZhciB0ZW1wUG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBpbnZBc3BlY3QgPSB2aWV3cG9ydC53IC8gdmlld3BvcnQueixcXHJcXG5cXHRcXHRcXHRcXHRoYWxmVmlld3BvcnRXaWR0aCA9IHZpZXdwb3J0LnogKiAwLjUsXFxyXFxuXFx0XFx0XFx0XFx0aGFsZlZpZXdwb3J0SGVpZ2h0ID0gdmlld3BvcnQudyAqIDAuNTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgc2l6ZSA9IDE2IC8gdmlld3BvcnQudyxcXHJcXG5cXHRcXHRcXHRcXHRzY2FsZSA9IG5ldyBWZWN0b3IyKCBzaXplICogaW52QXNwZWN0LCBzaXplICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHNjcmVlblBvc2l0aW9uID0gbmV3IFZlY3RvcjMoIDEsIDEsIDAgKSxcXHJcXG5cXHRcXHRcXHRcXHRzY3JlZW5Qb3NpdGlvblBpeGVscyA9IG5ldyBWZWN0b3IyKCAxLCAxICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHZhbGlkQXJlYSA9IG5ldyBCb3gyKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFsaWRBcmVhLm1pbi5zZXQoIHZpZXdwb3J0LngsIHZpZXdwb3J0LnkgKTtcXHJcXG5cXHRcXHRcXHR2YWxpZEFyZWEubWF4LnNldCggdmlld3BvcnQueCArICggdmlld3BvcnQueiAtIDE2ICksIHZpZXdwb3J0LnkgKyAoIHZpZXdwb3J0LncgLSAxNiApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aW5pdCgpO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRzdGF0ZS51c2VQcm9ncmFtKCBwcm9ncmFtICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0c3RhdGUuaW5pdEF0dHJpYnV0ZXMoKTtcXHJcXG5cXHRcXHRcXHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudmVydGV4ICk7XFxyXFxuXFx0XFx0XFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnV2ICk7XFxyXFxuXFx0XFx0XFx0c3RhdGUuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBsb29wIHRocm91Z2ggYWxsIGxlbnMgZmxhcmVzIHRvIHVwZGF0ZSB0aGVpciBvY2NsdXNpb24gYW5kIHBvc2l0aW9uc1xcclxcblxcdFxcdFxcdC8vIHNldHVwIGdsIGFuZCBjb21tb24gdXNlZCBhdHRyaWJzL3VuaWZvcm1zXFxyXFxuXFxyXFxuXFx0XFx0XFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5vY2NsdXNpb25NYXAsIDAgKTtcXHJcXG5cXHRcXHRcXHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLm1hcCwgMSApO1xcclxcblxcclxcblxcdFxcdFxcdGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XFxyXFxuXFx0XFx0XFx0Z2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy52ZXJ0ZXgsIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDAgKTtcXHJcXG5cXHRcXHRcXHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2LCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCA4ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Z2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVsZW1lbnRCdWZmZXIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRzdGF0ZS5kaXNhYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcXHJcXG5cXHRcXHRcXHRzdGF0ZS5idWZmZXJzLmRlcHRoLnNldE1hc2soIGZhbHNlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmxhcmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0c2l6ZSA9IDE2IC8gdmlld3BvcnQudztcXHJcXG5cXHRcXHRcXHRcXHRzY2FsZS5zZXQoIHNpemUgKiBpbnZBc3BlY3QsIHNpemUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBjYWxjIG9iamVjdCBzY3JlZW4gcG9zaXRpb25cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgZmxhcmUgPSBmbGFyZXNbIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0ZW1wUG9zaXRpb24uc2V0KCBmbGFyZS5tYXRyaXhXb3JsZC5lbGVtZW50c1sgMTIgXSwgZmxhcmUubWF0cml4V29ybGQuZWxlbWVudHNbIDEzIF0sIGZsYXJlLm1hdHJpeFdvcmxkLmVsZW1lbnRzWyAxNCBdICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGVtcFBvc2l0aW9uLmFwcGx5TWF0cml4NCggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xcclxcblxcdFxcdFxcdFxcdHRlbXBQb3NpdGlvbi5hcHBseU1hdHJpeDQoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gc2V0dXAgYXJyYXlzIGZvciBnbCBwcm9ncmFtc1xcclxcblxcclxcblxcdFxcdFxcdFxcdHNjcmVlblBvc2l0aW9uLmNvcHkoIHRlbXBQb3NpdGlvbiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGNvb3JkaW5hdGUgb2YgdGhlIGxvd2VyIGxlZnQgY29ybmVyIG9mIHRoZSBwaXhlbHMgdG8gY29weVxcclxcblxcclxcblxcdFxcdFxcdFxcdHNjcmVlblBvc2l0aW9uUGl4ZWxzLnggPSB2aWV3cG9ydC54ICsgKCBzY3JlZW5Qb3NpdGlvbi54ICogaGFsZlZpZXdwb3J0V2lkdGggKSArIGhhbGZWaWV3cG9ydFdpZHRoIC0gODtcXHJcXG5cXHRcXHRcXHRcXHRzY3JlZW5Qb3NpdGlvblBpeGVscy55ID0gdmlld3BvcnQueSArICggc2NyZWVuUG9zaXRpb24ueSAqIGhhbGZWaWV3cG9ydEhlaWdodCApICsgaGFsZlZpZXdwb3J0SGVpZ2h0IC0gODtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBzY3JlZW4gY3VsbFxcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggdmFsaWRBcmVhLmNvbnRhaW5zUG9pbnQoIHNjcmVlblBvc2l0aW9uUGl4ZWxzICkgPT09IHRydWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gc2F2ZSBjdXJyZW50IFJHQiB0byB0ZW1wIHRleHR1cmVcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMCApO1xcclxcblxcdFxcdFxcdFxcdFxcdHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBudWxsICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTEgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgdGVtcFRleHR1cmUgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRnbC5jb3B5VGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCLCBzY3JlZW5Qb3NpdGlvblBpeGVscy54LCBzY3JlZW5Qb3NpdGlvblBpeGVscy55LCAxNiwgMTYsIDAgKTtcXHJcXG5cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyByZW5kZXIgcGluayBxdWFkXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5yZW5kZXJUeXBlLCAwICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy5zY2FsZSwgc2NhbGUueCwgc2NhbGUueSApO1xcclxcblxcdFxcdFxcdFxcdFxcdGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuc2NyZWVuUG9zaXRpb24sIHNjcmVlblBvc2l0aW9uLngsIHNjcmVlblBvc2l0aW9uLnksIHNjcmVlblBvc2l0aW9uLnogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZS5kaXNhYmxlKCBnbC5CTEVORCApO1xcclxcblxcdFxcdFxcdFxcdFxcdHN0YXRlLmVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xcclxcblxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIGNvcHkgcmVzdWx0IHRvIG9jY2x1c2lvbk1hcFxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUwICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG9jY2x1c2lvblRleHR1cmUgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRnbC5jb3B5VGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgc2NyZWVuUG9zaXRpb25QaXhlbHMueCwgc2NyZWVuUG9zaXRpb25QaXhlbHMueSwgMTYsIDE2LCAwICk7XFxyXFxuXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gcmVzdG9yZSBncmFwaGljc1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMucmVuZGVyVHlwZSwgMSApO1xcclxcblxcdFxcdFxcdFxcdFxcdHN0YXRlLmRpc2FibGUoIGdsLkRFUFRIX1RFU1QgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMSApO1xcclxcblxcdFxcdFxcdFxcdFxcdHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCB0ZW1wVGV4dHVyZSApO1xcclxcblxcdFxcdFxcdFxcdFxcdGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xcclxcblxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIHVwZGF0ZSBvYmplY3QgcG9zaXRpb25zXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0ZmxhcmUucG9zaXRpb25TY3JlZW4uY29weSggc2NyZWVuUG9zaXRpb24gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGZsYXJlLmN1c3RvbVVwZGF0ZUNhbGxiYWNrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGZsYXJlLmN1c3RvbVVwZGF0ZUNhbGxiYWNrKCBmbGFyZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmxhcmUudXBkYXRlTGVuc0ZsYXJlcygpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyByZW5kZXIgZmxhcmVzXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5yZW5kZXJUeXBlLCAyICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUuZW5hYmxlKCBnbC5CTEVORCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBqID0gMCwgamwgPSBmbGFyZS5sZW5zRmxhcmVzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBzcHJpdGUgPSBmbGFyZS5sZW5zRmxhcmVzWyBqIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBzcHJpdGUub3BhY2l0eSA+IDAuMDAxICYmIHNwcml0ZS5zY2FsZSA+IDAuMDAxICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNjcmVlblBvc2l0aW9uLnggPSBzcHJpdGUueDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzY3JlZW5Qb3NpdGlvbi55ID0gc3ByaXRlLnk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2NyZWVuUG9zaXRpb24ueiA9IHNwcml0ZS56O1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNpemUgPSBzcHJpdGUuc2l6ZSAqIHNwcml0ZS5zY2FsZSAvIHZpZXdwb3J0Lnc7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2NhbGUueCA9IHNpemUgKiBpbnZBc3BlY3Q7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2NhbGUueSA9IHNpemU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5zY3JlZW5Qb3NpdGlvbiwgc2NyZWVuUG9zaXRpb24ueCwgc2NyZWVuUG9zaXRpb24ueSwgc2NyZWVuUG9zaXRpb24ueiApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLnVuaWZvcm0yZiggdW5pZm9ybXMuc2NhbGUsIHNjYWxlLngsIHNjYWxlLnkgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLnJvdGF0aW9uLCBzcHJpdGUucm90YXRpb24gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLm9wYWNpdHksIHNwcml0ZS5vcGFjaXR5ICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5jb2xvciwgc3ByaXRlLmNvbG9yLnIsIHNwcml0ZS5jb2xvci5nLCBzcHJpdGUuY29sb3IuYiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHN0YXRlLnNldEJsZW5kaW5nKCBzcHJpdGUuYmxlbmRpbmcsIHNwcml0ZS5ibGVuZEVxdWF0aW9uLCBzcHJpdGUuYmxlbmRTcmMsIHNwcml0ZS5ibGVuZERzdCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRleHR1cmVzLnNldFRleHR1cmUyRCggc3ByaXRlLnRleHR1cmUsIDEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC5kcmF3RWxlbWVudHMoIGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gcmVzdG9yZSBnbFxcclxcblxcclxcblxcdFxcdFxcdHN0YXRlLmVuYWJsZSggZ2wuQ1VMTF9GQUNFICk7XFxyXFxuXFx0XFx0XFx0c3RhdGUuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XFxyXFxuXFx0XFx0XFx0c3RhdGUuYnVmZmVycy5kZXB0aC5zZXRNYXNrKCB0cnVlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0c3RhdGUucmVzZXQoKTtcXHJcXG5cXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0oIHNoYWRlciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgZnJhZ21lbnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLkZSQUdNRU5UX1NIQURFUiApO1xcclxcblxcdFxcdFxcdHZhciB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLlZFUlRFWF9TSEFERVIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcHJlZml4ID0gJ3ByZWNpc2lvbiAnICsgY2FwYWJpbGl0aWVzLnByZWNpc2lvbiArICcgZmxvYXQ7XFxcXG4nO1xcclxcblxcclxcblxcdFxcdFxcdGdsLnNoYWRlclNvdXJjZSggZnJhZ21lbnRTaGFkZXIsIHByZWZpeCArIHNoYWRlci5mcmFnbWVudFNoYWRlciApO1xcclxcblxcdFxcdFxcdGdsLnNoYWRlclNvdXJjZSggdmVydGV4U2hhZGVyLCBwcmVmaXggKyBzaGFkZXIudmVydGV4U2hhZGVyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Z2wuY29tcGlsZVNoYWRlciggZnJhZ21lbnRTaGFkZXIgKTtcXHJcXG5cXHRcXHRcXHRnbC5jb21waWxlU2hhZGVyKCB2ZXJ0ZXhTaGFkZXIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGZyYWdtZW50U2hhZGVyICk7XFxyXFxuXFx0XFx0XFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRnbC5saW5rUHJvZ3JhbSggcHJvZ3JhbSApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBwcm9ncmFtO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBDYW52YXNUZXh0dXJlKCBjYW52YXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApIHtcXHJcXG5cXHJcXG5cXHRcXHRUZXh0dXJlLmNhbGwoIHRoaXMsIGNhbnZhcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdENhbnZhc1RleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVGV4dHVyZS5wcm90b3R5cGUgKTtcXHJcXG5cXHRDYW52YXNUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbnZhc1RleHR1cmU7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cXHJcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIFdlYkdMU3ByaXRlUmVuZGVyZXIoIHJlbmRlcmVyLCBnbCwgc3RhdGUsIHRleHR1cmVzLCBjYXBhYmlsaXRpZXMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHZlcnRleEJ1ZmZlciwgZWxlbWVudEJ1ZmZlcjtcXHJcXG5cXHRcXHR2YXIgcHJvZ3JhbSwgYXR0cmlidXRlcywgdW5pZm9ybXM7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHRleHR1cmU7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gZGVjb21wb3NlIG1hdHJpeFdvcmxkXFxyXFxuXFxyXFxuXFx0XFx0dmFyIHNwcml0ZVBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHRcXHR2YXIgc3ByaXRlUm90YXRpb24gPSBuZXcgUXVhdGVybmlvbigpO1xcclxcblxcdFxcdHZhciBzcHJpdGVTY2FsZSA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gaW5pdCgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXFxyXFxuXFx0XFx0XFx0XFx0LSAwLjUsIC0gMC41LCAwLCAwLFxcclxcblxcdFxcdFxcdFxcdCAgMC41LCAtIDAuNSwgMSwgMCxcXHJcXG5cXHRcXHRcXHRcXHQgIDAuNSwgMC41LCAxLCAxLFxcclxcblxcdFxcdFxcdFxcdC0gMC41LCAwLjUsIDAsIDFcXHJcXG5cXHRcXHRcXHRdICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGZhY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbXFxyXFxuXFx0XFx0XFx0XFx0MCwgMSwgMixcXHJcXG5cXHRcXHRcXHRcXHQwLCAyLCAzXFxyXFxuXFx0XFx0XFx0XSApO1xcclxcblxcclxcblxcdFxcdFxcdHZlcnRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xcclxcblxcdFxcdFxcdGVsZW1lbnRCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xcclxcblxcdFxcdFxcdGdsLmJ1ZmZlckRhdGEoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGljZXMsIGdsLlNUQVRJQ19EUkFXICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Z2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVsZW1lbnRCdWZmZXIgKTtcXHJcXG5cXHRcXHRcXHRnbC5idWZmZXJEYXRhKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZmFjZXMsIGdsLlNUQVRJQ19EUkFXICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0oKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRhdHRyaWJ1dGVzID0ge1xcclxcblxcdFxcdFxcdFxcdHBvc2l0aW9uOiBnbC5nZXRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgJ3Bvc2l0aW9uJyApLFxcclxcblxcdFxcdFxcdFxcdHV2OiBnbC5nZXRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgJ3V2JyApXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR1bmlmb3JtcyA9IHtcXHJcXG5cXHRcXHRcXHRcXHR1dk9mZnNldDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAndXZPZmZzZXQnICksXFxyXFxuXFx0XFx0XFx0XFx0dXZTY2FsZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAndXZTY2FsZScgKSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyb3RhdGlvbjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAncm90YXRpb24nICksXFxyXFxuXFx0XFx0XFx0XFx0c2NhbGU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3NjYWxlJyApLFxcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbG9yOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdjb2xvcicgKSxcXHJcXG5cXHRcXHRcXHRcXHRtYXA6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ21hcCcgKSxcXHJcXG5cXHRcXHRcXHRcXHRvcGFjaXR5OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdvcGFjaXR5JyApLFxcclxcblxcclxcblxcdFxcdFxcdFxcdG1vZGVsVmlld01hdHJpeDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnbW9kZWxWaWV3TWF0cml4JyApLFxcclxcblxcdFxcdFxcdFxcdHByb2plY3Rpb25NYXRyaXg6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3Byb2plY3Rpb25NYXRyaXgnICksXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9nVHlwZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nVHlwZScgKSxcXHJcXG5cXHRcXHRcXHRcXHRmb2dEZW5zaXR5OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dEZW5zaXR5JyApLFxcclxcblxcdFxcdFxcdFxcdGZvZ05lYXI6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ05lYXInICksXFxyXFxuXFx0XFx0XFx0XFx0Zm9nRmFyOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dGYXInICksXFxyXFxuXFx0XFx0XFx0XFx0Zm9nQ29sb3I6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ0NvbG9yJyApLFxcclxcblxcdFxcdFxcdFxcdGZvZ0RlcHRoOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dEZXB0aCcgKSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRhbHBoYVRlc3Q6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2FscGhhVGVzdCcgKVxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLCAnY2FudmFzJyApO1xcclxcblxcdFxcdFxcdGNhbnZhcy53aWR0aCA9IDg7XFxyXFxuXFx0XFx0XFx0Y2FudmFzLmhlaWdodCA9IDg7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xcclxcblxcdFxcdFxcdGNvbnRleHQuZmlsbFN0eWxlID0gJ3doaXRlJztcXHJcXG5cXHRcXHRcXHRjb250ZXh0LmZpbGxSZWN0KCAwLCAwLCA4LCA4ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGV4dHVyZSA9IG5ldyBDYW52YXNUZXh0dXJlKCBjYW52YXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNwcml0ZXMsIHNjZW5lLCBjYW1lcmEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBzcHJpdGVzLmxlbmd0aCA9PT0gMCApIHJldHVybjtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBzZXR1cCBnbFxcclxcblxcclxcblxcdFxcdFxcdGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGluaXQoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0c3RhdGUudXNlUHJvZ3JhbSggcHJvZ3JhbSApO1xcclxcblxcclxcblxcdFxcdFxcdHN0YXRlLmluaXRBdHRyaWJ1dGVzKCk7XFxyXFxuXFx0XFx0XFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICk7XFxyXFxuXFx0XFx0XFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnV2ICk7XFxyXFxuXFx0XFx0XFx0c3RhdGUuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRzdGF0ZS5kaXNhYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcXHJcXG5cXHRcXHRcXHRzdGF0ZS5lbmFibGUoIGdsLkJMRU5EICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Z2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIgKTtcXHJcXG5cXHRcXHRcXHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnBvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCAwICk7XFxyXFxuXFx0XFx0XFx0Z2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy51diwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgOCApO1xcclxcblxcclxcblxcdFxcdFxcdGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Z2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCwgZmFsc2UsIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTAgKTtcXHJcXG5cXHRcXHRcXHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLm1hcCwgMCApO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBvbGRGb2dUeXBlID0gMDtcXHJcXG5cXHRcXHRcXHR2YXIgc2NlbmVGb2dUeXBlID0gMDtcXHJcXG5cXHRcXHRcXHR2YXIgZm9nID0gc2NlbmUuZm9nO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggZm9nICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuZm9nQ29sb3IsIGZvZy5jb2xvci5yLCBmb2cuY29sb3IuZywgZm9nLmNvbG9yLmIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGZvZy5pc0ZvZyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLmZvZ05lYXIsIGZvZy5uZWFyICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dGYXIsIGZvZy5mYXIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIDEgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRvbGRGb2dUeXBlID0gMTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRzY2VuZUZvZ1R5cGUgPSAxO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIGZvZy5pc0ZvZ0V4cDIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dEZW5zaXR5LCBmb2cuZGVuc2l0eSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgMiApO1xcclxcblxcdFxcdFxcdFxcdFxcdG9sZEZvZ1R5cGUgPSAyO1xcclxcblxcdFxcdFxcdFxcdFxcdHNjZW5lRm9nVHlwZSA9IDI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5mb2dUeXBlLCAwICk7XFxyXFxuXFx0XFx0XFx0XFx0b2xkRm9nVHlwZSA9IDA7XFxyXFxuXFx0XFx0XFx0XFx0c2NlbmVGb2dUeXBlID0gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gdXBkYXRlIHBvc2l0aW9ucyBhbmQgc29ydFxcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHNwcml0ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgc3ByaXRlID0gc3ByaXRlc1sgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHNwcml0ZS5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgc3ByaXRlLm1hdHJpeFdvcmxkICk7XFxyXFxuXFx0XFx0XFx0XFx0c3ByaXRlLnogPSAtIHNwcml0ZS5tb2RlbFZpZXdNYXRyaXguZWxlbWVudHNbIDE0IF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHNwcml0ZXMuc29ydCggcGFpbnRlclNvcnRTdGFibGUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyByZW5kZXIgYWxsIHNwcml0ZXNcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgc2NhbGUgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzcHJpdGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHNwcml0ZSA9IHNwcml0ZXNbIGkgXTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgbWF0ZXJpYWwgPSBzcHJpdGUubWF0ZXJpYWw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBtYXRlcmlhbC52aXNpYmxlID09PSBmYWxzZSApIGNvbnRpbnVlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHNwcml0ZS5vbkJlZm9yZVJlbmRlciggcmVuZGVyZXIsIHNjZW5lLCBjYW1lcmEsIHVuZGVmaW5lZCwgbWF0ZXJpYWwsIHVuZGVmaW5lZCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMuYWxwaGFUZXN0LCBtYXRlcmlhbC5hbHBoYVRlc3QgKTtcXHJcXG5cXHRcXHRcXHRcXHRnbC51bmlmb3JtTWF0cml4NGZ2KCB1bmlmb3Jtcy5tb2RlbFZpZXdNYXRyaXgsIGZhbHNlLCBzcHJpdGUubW9kZWxWaWV3TWF0cml4LmVsZW1lbnRzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0c3ByaXRlLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggc3ByaXRlUG9zaXRpb24sIHNwcml0ZVJvdGF0aW9uLCBzcHJpdGVTY2FsZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHNjYWxlWyAwIF0gPSBzcHJpdGVTY2FsZS54O1xcclxcblxcdFxcdFxcdFxcdHNjYWxlWyAxIF0gPSBzcHJpdGVTY2FsZS55O1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBmb2dUeXBlID0gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHNjZW5lLmZvZyAmJiBtYXRlcmlhbC5mb2cgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Zm9nVHlwZSA9IHNjZW5lRm9nVHlwZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBvbGRGb2dUeXBlICE9PSBmb2dUeXBlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgZm9nVHlwZSApO1xcclxcblxcdFxcdFxcdFxcdFxcdG9sZEZvZ1R5cGUgPSBmb2dUeXBlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIG1hdGVyaWFsLm1hcCAhPT0gbnVsbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2T2Zmc2V0LCBtYXRlcmlhbC5tYXAub2Zmc2V0LngsIG1hdGVyaWFsLm1hcC5vZmZzZXQueSApO1xcclxcblxcdFxcdFxcdFxcdFxcdGdsLnVuaWZvcm0yZiggdW5pZm9ybXMudXZTY2FsZSwgbWF0ZXJpYWwubWFwLnJlcGVhdC54LCBtYXRlcmlhbC5tYXAucmVwZWF0LnkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGdsLnVuaWZvcm0yZiggdW5pZm9ybXMudXZPZmZzZXQsIDAsIDAgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2U2NhbGUsIDEsIDEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5vcGFjaXR5LCBtYXRlcmlhbC5vcGFjaXR5ICk7XFxyXFxuXFx0XFx0XFx0XFx0Z2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5jb2xvciwgbWF0ZXJpYWwuY29sb3IuciwgbWF0ZXJpYWwuY29sb3IuZywgbWF0ZXJpYWwuY29sb3IuYiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMucm90YXRpb24sIG1hdGVyaWFsLnJvdGF0aW9uICk7XFxyXFxuXFx0XFx0XFx0XFx0Z2wudW5pZm9ybTJmdiggdW5pZm9ybXMuc2NhbGUsIHNjYWxlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0c3RhdGUuc2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nLCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uLCBtYXRlcmlhbC5ibGVuZFNyYywgbWF0ZXJpYWwuYmxlbmREc3QsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb25BbHBoYSwgbWF0ZXJpYWwuYmxlbmRTcmNBbHBoYSwgbWF0ZXJpYWwuYmxlbmREc3RBbHBoYSwgbWF0ZXJpYWwucHJlbXVsdGlwbGllZEFscGhhICk7XFxyXFxuXFx0XFx0XFx0XFx0c3RhdGUuYnVmZmVycy5kZXB0aC5zZXRUZXN0KCBtYXRlcmlhbC5kZXB0aFRlc3QgKTtcXHJcXG5cXHRcXHRcXHRcXHRzdGF0ZS5idWZmZXJzLmRlcHRoLnNldE1hc2soIG1hdGVyaWFsLmRlcHRoV3JpdGUgKTtcXHJcXG5cXHRcXHRcXHRcXHRzdGF0ZS5idWZmZXJzLmNvbG9yLnNldE1hc2soIG1hdGVyaWFsLmNvbG9yV3JpdGUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlcy5zZXRUZXh0dXJlMkQoIG1hdGVyaWFsLm1hcCB8fCB0ZXh0dXJlLCAwICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Z2wuZHJhd0VsZW1lbnRzKCBnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0c3ByaXRlLm9uQWZ0ZXJSZW5kZXIoIHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhLCB1bmRlZmluZWQsIG1hdGVyaWFsLCB1bmRlZmluZWQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gcmVzdG9yZSBnbFxcclxcblxcclxcblxcdFxcdFxcdHN0YXRlLmVuYWJsZSggZ2wuQ1VMTF9GQUNFICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0c3RhdGUucmVzZXQoKTtcXHJcXG5cXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0oKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHZlcnRleFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuVkVSVEVYX1NIQURFUiApO1xcclxcblxcdFxcdFxcdHZhciBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuRlJBR01FTlRfU0hBREVSICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Z2wuc2hhZGVyU291cmNlKCB2ZXJ0ZXhTaGFkZXIsIFtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQncHJlY2lzaW9uICcgKyBjYXBhYmlsaXRpZXMucHJlY2lzaW9uICsgJyBmbG9hdDsnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdCcjZGVmaW5lIFNIQURFUl9OQU1FICcgKyAnU3ByaXRlTWF0ZXJpYWwnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdCd1bmlmb3JtIG1hdDQgbW9kZWxWaWV3TWF0cml4OycsXFxyXFxuXFx0XFx0XFx0XFx0J3VuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4OycsXFxyXFxuXFx0XFx0XFx0XFx0J3VuaWZvcm0gZmxvYXQgcm90YXRpb247JyxcXHJcXG5cXHRcXHRcXHRcXHQndW5pZm9ybSB2ZWMyIHNjYWxlOycsXFxyXFxuXFx0XFx0XFx0XFx0J3VuaWZvcm0gdmVjMiB1dk9mZnNldDsnLFxcclxcblxcdFxcdFxcdFxcdCd1bmlmb3JtIHZlYzIgdXZTY2FsZTsnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdCdhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjsnLFxcclxcblxcdFxcdFxcdFxcdCdhdHRyaWJ1dGUgdmVjMiB1djsnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdCd2YXJ5aW5nIHZlYzIgdlVWOycsXFxyXFxuXFx0XFx0XFx0XFx0J3ZhcnlpbmcgZmxvYXQgZm9nRGVwdGg7JyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQndm9pZCBtYWluKCkgeycsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0J1xcdHZVViA9IHV2T2Zmc2V0ICsgdXYgKiB1dlNjYWxlOycsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0J1xcdHZlYzIgYWxpZ25lZFBvc2l0aW9uID0gcG9zaXRpb24gKiBzY2FsZTsnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdCdcXHR2ZWMyIHJvdGF0ZWRQb3NpdGlvbjsnLFxcclxcblxcdFxcdFxcdFxcdCdcXHRyb3RhdGVkUG9zaXRpb24ueCA9IGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7JyxcXHJcXG5cXHRcXHRcXHRcXHQnXFx0cm90YXRlZFBvc2l0aW9uLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55OycsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0J1xcdHZlYzQgbXZQb3NpdGlvbjsnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdCdcXHRtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggMC4wLCAwLjAsIDAuMCwgMS4wICk7JyxcXHJcXG5cXHRcXHRcXHRcXHQnXFx0bXZQb3NpdGlvbi54eSArPSByb3RhdGVkUG9zaXRpb247JyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQnXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjsnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdCdcXHRmb2dEZXB0aCA9IC0gbXZQb3NpdGlvbi56OycsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0J30nXFxyXFxuXFxyXFxuXFx0XFx0XFx0XS5qb2luKCAnXFxcXG4nICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRnbC5zaGFkZXJTb3VyY2UoIGZyYWdtZW50U2hhZGVyLCBbXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0J3ByZWNpc2lvbiAnICsgY2FwYWJpbGl0aWVzLnByZWNpc2lvbiArICcgZmxvYXQ7JyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQnI2RlZmluZSBTSEFERVJfTkFNRSAnICsgJ1Nwcml0ZU1hdGVyaWFsJyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQndW5pZm9ybSB2ZWMzIGNvbG9yOycsXFxyXFxuXFx0XFx0XFx0XFx0J3VuaWZvcm0gc2FtcGxlcjJEIG1hcDsnLFxcclxcblxcdFxcdFxcdFxcdCd1bmlmb3JtIGZsb2F0IG9wYWNpdHk7JyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQndW5pZm9ybSBpbnQgZm9nVHlwZTsnLFxcclxcblxcdFxcdFxcdFxcdCd1bmlmb3JtIHZlYzMgZm9nQ29sb3I7JyxcXHJcXG5cXHRcXHRcXHRcXHQndW5pZm9ybSBmbG9hdCBmb2dEZW5zaXR5OycsXFxyXFxuXFx0XFx0XFx0XFx0J3VuaWZvcm0gZmxvYXQgZm9nTmVhcjsnLFxcclxcblxcdFxcdFxcdFxcdCd1bmlmb3JtIGZsb2F0IGZvZ0ZhcjsnLFxcclxcblxcdFxcdFxcdFxcdCd1bmlmb3JtIGZsb2F0IGFscGhhVGVzdDsnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdCd2YXJ5aW5nIHZlYzIgdlVWOycsXFxyXFxuXFx0XFx0XFx0XFx0J3ZhcnlpbmcgZmxvYXQgZm9nRGVwdGg7JyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQndm9pZCBtYWluKCkgeycsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0J1xcdHZlYzQgdGV4dHVyZSA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTsnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdCdcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBjb2xvciAqIHRleHR1cmUueHl6LCB0ZXh0dXJlLmEgKiBvcGFjaXR5ICk7JyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQnXFx0aWYgKCBnbF9GcmFnQ29sb3IuYSA8IGFscGhhVGVzdCApIGRpc2NhcmQ7JyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQnXFx0aWYgKCBmb2dUeXBlID4gMCApIHsnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdCdcXHRcXHRmbG9hdCBmb2dGYWN0b3IgPSAwLjA7JyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQnXFx0XFx0aWYgKCBmb2dUeXBlID09IDEgKSB7JyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQnXFx0XFx0XFx0Zm9nRmFjdG9yID0gc21vb3Roc3RlcCggZm9nTmVhciwgZm9nRmFyLCBmb2dEZXB0aCApOycsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0J1xcdFxcdH0gZWxzZSB7JyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQnXFx0XFx0XFx0Y29uc3QgZmxvYXQgTE9HMiA9IDEuNDQyNjk1OycsXFxyXFxuXFx0XFx0XFx0XFx0J1xcdFxcdFxcdGZvZ0ZhY3RvciA9IGV4cDIoIC0gZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkgKiBmb2dEZXB0aCAqIGZvZ0RlcHRoICogTE9HMiApOycsXFxyXFxuXFx0XFx0XFx0XFx0J1xcdFxcdFxcdGZvZ0ZhY3RvciA9IDEuMCAtIGNsYW1wKCBmb2dGYWN0b3IsIDAuMCwgMS4wICk7JyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQnXFx0XFx0fScsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0J1xcdFxcdGdsX0ZyYWdDb2xvci5yZ2IgPSBtaXgoIGdsX0ZyYWdDb2xvci5yZ2IsIGZvZ0NvbG9yLCBmb2dGYWN0b3IgKTsnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdCdcXHR9JyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQnfSdcXHJcXG5cXHJcXG5cXHRcXHRcXHRdLmpvaW4oICdcXFxcbicgKSApO1xcclxcblxcclxcblxcdFxcdFxcdGdsLmNvbXBpbGVTaGFkZXIoIHZlcnRleFNoYWRlciApO1xcclxcblxcdFxcdFxcdGdsLmNvbXBpbGVTaGFkZXIoIGZyYWdtZW50U2hhZGVyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIgKTtcXHJcXG5cXHRcXHRcXHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGZyYWdtZW50U2hhZGVyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Z2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gcHJvZ3JhbTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gcGFpbnRlclNvcnRTdGFibGUoIGEsIGIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBhLnJlbmRlck9yZGVyICE9PSBiLnJlbmRlck9yZGVyICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiBhLnJlbmRlck9yZGVyIC0gYi5yZW5kZXJPcmRlcjtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBhLnogIT09IGIueiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gYi56IC0gYS56O1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGIuaWQgLSBhLmlkO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHR2YXIgbWF0ZXJpYWxJZCA9IDA7XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gTWF0ZXJpYWwoKSB7XFxyXFxuXFxyXFxuXFx0XFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBtYXRlcmlhbElkICsrIH0gKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm5hbWUgPSAnJztcXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnTWF0ZXJpYWwnO1xcclxcblxcclxcblxcdFxcdHRoaXMuZm9nID0gdHJ1ZTtcXHJcXG5cXHRcXHR0aGlzLmxpZ2h0cyA9IHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5ibGVuZGluZyA9IE5vcm1hbEJsZW5kaW5nO1xcclxcblxcdFxcdHRoaXMuc2lkZSA9IEZyb250U2lkZTtcXHJcXG5cXHRcXHR0aGlzLmZsYXRTaGFkaW5nID0gZmFsc2U7XFxyXFxuXFx0XFx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBOb0NvbG9yczsgLy8gVEhSRUUuTm9Db2xvcnMsIFRIUkVFLlZlcnRleENvbG9ycywgVEhSRUUuRmFjZUNvbG9yc1xcclxcblxcclxcblxcdFxcdHRoaXMub3BhY2l0eSA9IDE7XFxyXFxuXFx0XFx0dGhpcy50cmFuc3BhcmVudCA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdHRoaXMuYmxlbmRTcmMgPSBTcmNBbHBoYUZhY3RvcjtcXHJcXG5cXHRcXHR0aGlzLmJsZW5kRHN0ID0gT25lTWludXNTcmNBbHBoYUZhY3RvcjtcXHJcXG5cXHRcXHR0aGlzLmJsZW5kRXF1YXRpb24gPSBBZGRFcXVhdGlvbjtcXHJcXG5cXHRcXHR0aGlzLmJsZW5kU3JjQWxwaGEgPSBudWxsO1xcclxcblxcdFxcdHRoaXMuYmxlbmREc3RBbHBoYSA9IG51bGw7XFxyXFxuXFx0XFx0dGhpcy5ibGVuZEVxdWF0aW9uQWxwaGEgPSBudWxsO1xcclxcblxcclxcblxcdFxcdHRoaXMuZGVwdGhGdW5jID0gTGVzc0VxdWFsRGVwdGg7XFxyXFxuXFx0XFx0dGhpcy5kZXB0aFRlc3QgPSB0cnVlO1xcclxcblxcdFxcdHRoaXMuZGVwdGhXcml0ZSA9IHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5jbGlwcGluZ1BsYW5lcyA9IG51bGw7XFxyXFxuXFx0XFx0dGhpcy5jbGlwSW50ZXJzZWN0aW9uID0gZmFsc2U7XFxyXFxuXFx0XFx0dGhpcy5jbGlwU2hhZG93cyA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdHRoaXMuY29sb3JXcml0ZSA9IHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5wcmVjaXNpb24gPSBudWxsOyAvLyBvdmVycmlkZSB0aGUgcmVuZGVyZXIncyBkZWZhdWx0IHByZWNpc2lvbiBmb3IgdGhpcyBtYXRlcmlhbFxcclxcblxcclxcblxcdFxcdHRoaXMucG9seWdvbk9mZnNldCA9IGZhbHNlO1xcclxcblxcdFxcdHRoaXMucG9seWdvbk9mZnNldEZhY3RvciA9IDA7XFxyXFxuXFx0XFx0dGhpcy5wb2x5Z29uT2Zmc2V0VW5pdHMgPSAwO1xcclxcblxcclxcblxcdFxcdHRoaXMuZGl0aGVyaW5nID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5hbHBoYVRlc3QgPSAwO1xcclxcblxcdFxcdHRoaXMucHJlbXVsdGlwbGllZEFscGhhID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5vdmVyZHJhdyA9IDA7IC8vIE92ZXJkcmF3biBwaXhlbHMgKHR5cGljYWxseSBiZXR3ZWVuIDAgYW5kIDEpIGZvciBmaXhpbmcgYW50aWFsaWFzaW5nIGdhcHMgaW4gQ2FudmFzUmVuZGVyZXJcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnZpc2libGUgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdHRoaXMudXNlckRhdGEgPSB7fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0TWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSApLCB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc3RydWN0b3I6IE1hdGVyaWFsLFxcclxcblxcclxcblxcdFxcdGlzTWF0ZXJpYWw6IHRydWUsXFxyXFxuXFxyXFxuXFx0XFx0b25CZWZvcmVDb21waWxlOiBmdW5jdGlvbiAoKSB7fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRWYWx1ZXM6IGZ1bmN0aW9uICggdmFsdWVzICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdmFsdWVzID09PSB1bmRlZmluZWQgKSByZXR1cm47XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGtleSBpbiB2YWx1ZXMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIG5ld1ZhbHVlID0gdmFsdWVzWyBrZXkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIG5ld1ZhbHVlID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCBcXFwiVEhSRUUuTWF0ZXJpYWw6ICdcXFwiICsga2V5ICsgXFxcIicgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZC5cXFwiICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0Y29udGludWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGZvciBiYWNrd2FyZCBjb21wYXRhYmlsaXR5IGlmIHNoYWRpbmcgaXMgc2V0IGluIHRoZSBjb25zdHJ1Y3RvclxcclxcblxcdFxcdFxcdFxcdGlmICgga2V5ID09PSAnc2hhZGluZycgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuJyArIHRoaXMudHlwZSArICc6IC5zaGFkaW5nIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB0aGUgYm9vbGVhbiAuZmxhdFNoYWRpbmcgaW5zdGVhZC4nICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5mbGF0U2hhZGluZyA9ICggbmV3VmFsdWUgPT09IEZsYXRTaGFkaW5nICkgPyB0cnVlIDogZmFsc2U7XFxyXFxuXFx0XFx0XFx0XFx0XFx0Y29udGludWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBjdXJyZW50VmFsdWUgPSB0aGlzWyBrZXkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGN1cnJlbnRWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggXFxcIlRIUkVFLlxcXCIgKyB0aGlzLnR5cGUgKyBcXFwiOiAnXFxcIiArIGtleSArIFxcXCInIGlzIG5vdCBhIHByb3BlcnR5IG9mIHRoaXMgbWF0ZXJpYWwuXFxcIiApO1xcclxcblxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGN1cnJlbnRWYWx1ZSAmJiBjdXJyZW50VmFsdWUuaXNDb2xvciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRjdXJyZW50VmFsdWUuc2V0KCBuZXdWYWx1ZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoICggY3VycmVudFZhbHVlICYmIGN1cnJlbnRWYWx1ZS5pc1ZlY3RvcjMgKSAmJiAoIG5ld1ZhbHVlICYmIG5ld1ZhbHVlLmlzVmVjdG9yMyApICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGN1cnJlbnRWYWx1ZS5jb3B5KCBuZXdWYWx1ZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIGtleSA9PT0gJ292ZXJkcmF3JyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBlbnN1cmUgb3ZlcmRyYXcgaXMgYmFja3dhcmRzLWNvbXBhdGlibGUgd2l0aCBsZWdhY3kgYm9vbGVhbiB0eXBlXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpc1sga2V5IF0gPSBOdW1iZXIoIG5ld1ZhbHVlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzWyBrZXkgXSA9IG5ld1ZhbHVlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHR0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgaXNSb290ID0gKCBtZXRhID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG1ldGEgPT09ICdzdHJpbmcnICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBpc1Jvb3QgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bWV0YSA9IHtcXHJcXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlczoge30sXFxyXFxuXFx0XFx0XFx0XFx0XFx0aW1hZ2VzOiB7fVxcclxcblxcdFxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHZhciBkYXRhID0ge1xcclxcblxcdFxcdFxcdFxcdG1ldGFkYXRhOiB7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmVyc2lvbjogNC41LFxcclxcblxcdFxcdFxcdFxcdFxcdHR5cGU6ICdNYXRlcmlhbCcsXFxyXFxuXFx0XFx0XFx0XFx0XFx0Z2VuZXJhdG9yOiAnTWF0ZXJpYWwudG9KU09OJ1xcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdFxcdC8vIHN0YW5kYXJkIE1hdGVyaWFsIHNlcmlhbGl6YXRpb25cXHJcXG5cXHRcXHRcXHRkYXRhLnV1aWQgPSB0aGlzLnV1aWQ7XFxyXFxuXFx0XFx0XFx0ZGF0YS50eXBlID0gdGhpcy50eXBlO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMuY29sb3IgJiYgdGhpcy5jb2xvci5pc0NvbG9yICkgZGF0YS5jb2xvciA9IHRoaXMuY29sb3IuZ2V0SGV4KCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLnJvdWdobmVzcyAhPT0gdW5kZWZpbmVkICkgZGF0YS5yb3VnaG5lc3MgPSB0aGlzLnJvdWdobmVzcztcXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMubWV0YWxuZXNzICE9PSB1bmRlZmluZWQgKSBkYXRhLm1ldGFsbmVzcyA9IHRoaXMubWV0YWxuZXNzO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5lbWlzc2l2ZSAmJiB0aGlzLmVtaXNzaXZlLmlzQ29sb3IgKSBkYXRhLmVtaXNzaXZlID0gdGhpcy5lbWlzc2l2ZS5nZXRIZXgoKTtcXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgIT09IDEgKSBkYXRhLmVtaXNzaXZlSW50ZW5zaXR5ID0gdGhpcy5lbWlzc2l2ZUludGVuc2l0eTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMuc3BlY3VsYXIgJiYgdGhpcy5zcGVjdWxhci5pc0NvbG9yICkgZGF0YS5zcGVjdWxhciA9IHRoaXMuc3BlY3VsYXIuZ2V0SGV4KCk7XFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLnNoaW5pbmVzcyAhPT0gdW5kZWZpbmVkICkgZGF0YS5zaGluaW5lc3MgPSB0aGlzLnNoaW5pbmVzcztcXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMuY2xlYXJDb2F0ICE9PSB1bmRlZmluZWQgKSBkYXRhLmNsZWFyQ29hdCA9IHRoaXMuY2xlYXJDb2F0O1xcclxcblxcdFxcdFxcdGlmICggdGhpcy5jbGVhckNvYXRSb3VnaG5lc3MgIT09IHVuZGVmaW5lZCApIGRhdGEuY2xlYXJDb2F0Um91Z2huZXNzID0gdGhpcy5jbGVhckNvYXRSb3VnaG5lc3M7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLm1hcCAmJiB0aGlzLm1hcC5pc1RleHR1cmUgKSBkYXRhLm1hcCA9IHRoaXMubWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmFscGhhTWFwICYmIHRoaXMuYWxwaGFNYXAuaXNUZXh0dXJlICkgZGF0YS5hbHBoYU1hcCA9IHRoaXMuYWxwaGFNYXAudG9KU09OKCBtZXRhICkudXVpZDtcXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMubGlnaHRNYXAgJiYgdGhpcy5saWdodE1hcC5pc1RleHR1cmUgKSBkYXRhLmxpZ2h0TWFwID0gdGhpcy5saWdodE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xcclxcblxcdFxcdFxcdGlmICggdGhpcy5idW1wTWFwICYmIHRoaXMuYnVtcE1hcC5pc1RleHR1cmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZGF0YS5idW1wTWFwID0gdGhpcy5idW1wTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XFxyXFxuXFx0XFx0XFx0XFx0ZGF0YS5idW1wU2NhbGUgPSB0aGlzLmJ1bXBTY2FsZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLm5vcm1hbE1hcCAmJiB0aGlzLm5vcm1hbE1hcC5pc1RleHR1cmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZGF0YS5ub3JtYWxNYXAgPSB0aGlzLm5vcm1hbE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xcclxcblxcdFxcdFxcdFxcdGRhdGEubm9ybWFsU2NhbGUgPSB0aGlzLm5vcm1hbFNjYWxlLnRvQXJyYXkoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmRpc3BsYWNlbWVudE1hcCAmJiB0aGlzLmRpc3BsYWNlbWVudE1hcC5pc1RleHR1cmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZGF0YS5kaXNwbGFjZW1lbnRNYXAgPSB0aGlzLmRpc3BsYWNlbWVudE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xcclxcblxcdFxcdFxcdFxcdGRhdGEuZGlzcGxhY2VtZW50U2NhbGUgPSB0aGlzLmRpc3BsYWNlbWVudFNjYWxlO1xcclxcblxcdFxcdFxcdFxcdGRhdGEuZGlzcGxhY2VtZW50QmlhcyA9IHRoaXMuZGlzcGxhY2VtZW50QmlhcztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLnJvdWdobmVzc01hcCAmJiB0aGlzLnJvdWdobmVzc01hcC5pc1RleHR1cmUgKSBkYXRhLnJvdWdobmVzc01hcCA9IHRoaXMucm91Z2huZXNzTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLm1ldGFsbmVzc01hcCAmJiB0aGlzLm1ldGFsbmVzc01hcC5pc1RleHR1cmUgKSBkYXRhLm1ldGFsbmVzc01hcCA9IHRoaXMubWV0YWxuZXNzTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmVtaXNzaXZlTWFwICYmIHRoaXMuZW1pc3NpdmVNYXAuaXNUZXh0dXJlICkgZGF0YS5lbWlzc2l2ZU1hcCA9IHRoaXMuZW1pc3NpdmVNYXAudG9KU09OKCBtZXRhICkudXVpZDtcXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMuc3BlY3VsYXJNYXAgJiYgdGhpcy5zcGVjdWxhck1hcC5pc1RleHR1cmUgKSBkYXRhLnNwZWN1bGFyTWFwID0gdGhpcy5zcGVjdWxhck1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5lbnZNYXAgJiYgdGhpcy5lbnZNYXAuaXNUZXh0dXJlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGRhdGEuZW52TWFwID0gdGhpcy5lbnZNYXAudG9KU09OKCBtZXRhICkudXVpZDtcXHJcXG5cXHRcXHRcXHRcXHRkYXRhLnJlZmxlY3Rpdml0eSA9IHRoaXMucmVmbGVjdGl2aXR5OyAvLyBTY2FsZSBiZWhpbmQgZW52TWFwXFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5ncmFkaWVudE1hcCAmJiB0aGlzLmdyYWRpZW50TWFwLmlzVGV4dHVyZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRkYXRhLmdyYWRpZW50TWFwID0gdGhpcy5ncmFkaWVudE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMuc2l6ZSAhPT0gdW5kZWZpbmVkICkgZGF0YS5zaXplID0gdGhpcy5zaXplO1xcclxcblxcdFxcdFxcdGlmICggdGhpcy5zaXplQXR0ZW51YXRpb24gIT09IHVuZGVmaW5lZCApIGRhdGEuc2l6ZUF0dGVudWF0aW9uID0gdGhpcy5zaXplQXR0ZW51YXRpb247XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmJsZW5kaW5nICE9PSBOb3JtYWxCbGVuZGluZyApIGRhdGEuYmxlbmRpbmcgPSB0aGlzLmJsZW5kaW5nO1xcclxcblxcdFxcdFxcdGlmICggdGhpcy5mbGF0U2hhZGluZyA9PT0gdHJ1ZSApIGRhdGEuZmxhdFNoYWRpbmcgPSB0aGlzLmZsYXRTaGFkaW5nO1xcclxcblxcdFxcdFxcdGlmICggdGhpcy5zaWRlICE9PSBGcm9udFNpZGUgKSBkYXRhLnNpZGUgPSB0aGlzLnNpZGU7XFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLnZlcnRleENvbG9ycyAhPT0gTm9Db2xvcnMgKSBkYXRhLnZlcnRleENvbG9ycyA9IHRoaXMudmVydGV4Q29sb3JzO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5vcGFjaXR5IDwgMSApIGRhdGEub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMudHJhbnNwYXJlbnQgPT09IHRydWUgKSBkYXRhLnRyYW5zcGFyZW50ID0gdGhpcy50cmFuc3BhcmVudDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRkYXRhLmRlcHRoRnVuYyA9IHRoaXMuZGVwdGhGdW5jO1xcclxcblxcdFxcdFxcdGRhdGEuZGVwdGhUZXN0ID0gdGhpcy5kZXB0aFRlc3Q7XFxyXFxuXFx0XFx0XFx0ZGF0YS5kZXB0aFdyaXRlID0gdGhpcy5kZXB0aFdyaXRlO1xcclxcblxcclxcblxcdFxcdFxcdC8vIHJvdGF0aW9uIChTcHJpdGVNYXRlcmlhbClcXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMucm90YXRpb24gIT09IDAgKSBkYXRhLnJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMubGluZXdpZHRoICE9PSAxICkgZGF0YS5saW5ld2lkdGggPSB0aGlzLmxpbmV3aWR0aDtcXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMuZGFzaFNpemUgIT09IHVuZGVmaW5lZCApIGRhdGEuZGFzaFNpemUgPSB0aGlzLmRhc2hTaXplO1xcclxcblxcdFxcdFxcdGlmICggdGhpcy5nYXBTaXplICE9PSB1bmRlZmluZWQgKSBkYXRhLmdhcFNpemUgPSB0aGlzLmdhcFNpemU7XFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLnNjYWxlICE9PSB1bmRlZmluZWQgKSBkYXRhLnNjYWxlID0gdGhpcy5zY2FsZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMuZGl0aGVyaW5nID09PSB0cnVlICkgZGF0YS5kaXRoZXJpbmcgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5hbHBoYVRlc3QgPiAwICkgZGF0YS5hbHBoYVRlc3QgPSB0aGlzLmFscGhhVGVzdDtcXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMucHJlbXVsdGlwbGllZEFscGhhID09PSB0cnVlICkgZGF0YS5wcmVtdWx0aXBsaWVkQWxwaGEgPSB0aGlzLnByZW11bHRpcGxpZWRBbHBoYTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMud2lyZWZyYW1lID09PSB0cnVlICkgZGF0YS53aXJlZnJhbWUgPSB0aGlzLndpcmVmcmFtZTtcXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID4gMSApIGRhdGEud2lyZWZyYW1lTGluZXdpZHRoID0gdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg7XFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLndpcmVmcmFtZUxpbmVjYXAgIT09ICdyb3VuZCcgKSBkYXRhLndpcmVmcmFtZUxpbmVjYXAgPSB0aGlzLndpcmVmcmFtZUxpbmVjYXA7XFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLndpcmVmcmFtZUxpbmVqb2luICE9PSAncm91bmQnICkgZGF0YS53aXJlZnJhbWVMaW5lam9pbiA9IHRoaXMud2lyZWZyYW1lTGluZWpvaW47XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLm1vcnBoVGFyZ2V0cyA9PT0gdHJ1ZSApIGRhdGEubW9ycGhUYXJnZXRzID0gdHJ1ZTtcXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMuc2tpbm5pbmcgPT09IHRydWUgKSBkYXRhLnNraW5uaW5nID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMudmlzaWJsZSA9PT0gZmFsc2UgKSBkYXRhLnZpc2libGUgPSBmYWxzZTtcXHJcXG5cXHRcXHRcXHRpZiAoIEpTT04uc3RyaW5naWZ5KCB0aGlzLnVzZXJEYXRhICkgIT09ICd7fScgKSBkYXRhLnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBUT0RPOiBDb3BpZWQgZnJvbSBPYmplY3QzRC50b0pTT05cXHJcXG5cXHJcXG5cXHRcXHRcXHRmdW5jdGlvbiBleHRyYWN0RnJvbUNhY2hlKCBjYWNoZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgdmFsdWVzID0gW107XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGtleSBpbiBjYWNoZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgZGF0YSA9IGNhY2hlWyBrZXkgXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRkZWxldGUgZGF0YS5tZXRhZGF0YTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2YWx1ZXMucHVzaCggZGF0YSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdmFsdWVzO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGlzUm9vdCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgdGV4dHVyZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLnRleHR1cmVzICk7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGltYWdlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuaW1hZ2VzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB0ZXh0dXJlcy5sZW5ndGggPiAwICkgZGF0YS50ZXh0dXJlcyA9IHRleHR1cmVzO1xcclxcblxcdFxcdFxcdFxcdGlmICggaW1hZ2VzLmxlbmd0aCA+IDAgKSBkYXRhLmltYWdlcyA9IGltYWdlcztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGRhdGE7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuZm9nID0gc291cmNlLmZvZztcXHJcXG5cXHRcXHRcXHR0aGlzLmxpZ2h0cyA9IHNvdXJjZS5saWdodHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5ibGVuZGluZyA9IHNvdXJjZS5ibGVuZGluZztcXHJcXG5cXHRcXHRcXHR0aGlzLnNpZGUgPSBzb3VyY2Uuc2lkZTtcXHJcXG5cXHRcXHRcXHR0aGlzLmZsYXRTaGFkaW5nID0gc291cmNlLmZsYXRTaGFkaW5nO1xcclxcblxcdFxcdFxcdHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm9wYWNpdHkgPSBzb3VyY2Uub3BhY2l0eTtcXHJcXG5cXHRcXHRcXHR0aGlzLnRyYW5zcGFyZW50ID0gc291cmNlLnRyYW5zcGFyZW50O1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuYmxlbmRTcmMgPSBzb3VyY2UuYmxlbmRTcmM7XFxyXFxuXFx0XFx0XFx0dGhpcy5ibGVuZERzdCA9IHNvdXJjZS5ibGVuZERzdDtcXHJcXG5cXHRcXHRcXHR0aGlzLmJsZW5kRXF1YXRpb24gPSBzb3VyY2UuYmxlbmRFcXVhdGlvbjtcXHJcXG5cXHRcXHRcXHR0aGlzLmJsZW5kU3JjQWxwaGEgPSBzb3VyY2UuYmxlbmRTcmNBbHBoYTtcXHJcXG5cXHRcXHRcXHR0aGlzLmJsZW5kRHN0QWxwaGEgPSBzb3VyY2UuYmxlbmREc3RBbHBoYTtcXHJcXG5cXHRcXHRcXHR0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSA9IHNvdXJjZS5ibGVuZEVxdWF0aW9uQWxwaGE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5kZXB0aEZ1bmMgPSBzb3VyY2UuZGVwdGhGdW5jO1xcclxcblxcdFxcdFxcdHRoaXMuZGVwdGhUZXN0ID0gc291cmNlLmRlcHRoVGVzdDtcXHJcXG5cXHRcXHRcXHR0aGlzLmRlcHRoV3JpdGUgPSBzb3VyY2UuZGVwdGhXcml0ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmNvbG9yV3JpdGUgPSBzb3VyY2UuY29sb3JXcml0ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnByZWNpc2lvbiA9IHNvdXJjZS5wcmVjaXNpb247XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5wb2x5Z29uT2Zmc2V0ID0gc291cmNlLnBvbHlnb25PZmZzZXQ7XFxyXFxuXFx0XFx0XFx0dGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gc291cmNlLnBvbHlnb25PZmZzZXRGYWN0b3I7XFxyXFxuXFx0XFx0XFx0dGhpcy5wb2x5Z29uT2Zmc2V0VW5pdHMgPSBzb3VyY2UucG9seWdvbk9mZnNldFVuaXRzO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuZGl0aGVyaW5nID0gc291cmNlLmRpdGhlcmluZztcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmFscGhhVGVzdCA9IHNvdXJjZS5hbHBoYVRlc3Q7XFxyXFxuXFx0XFx0XFx0dGhpcy5wcmVtdWx0aXBsaWVkQWxwaGEgPSBzb3VyY2UucHJlbXVsdGlwbGllZEFscGhhO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMub3ZlcmRyYXcgPSBzb3VyY2Uub3ZlcmRyYXc7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy52aXNpYmxlID0gc291cmNlLnZpc2libGU7XFxyXFxuXFx0XFx0XFx0dGhpcy51c2VyRGF0YSA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCBzb3VyY2UudXNlckRhdGEgKSApO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuY2xpcFNoYWRvd3MgPSBzb3VyY2UuY2xpcFNoYWRvd3M7XFxyXFxuXFx0XFx0XFx0dGhpcy5jbGlwSW50ZXJzZWN0aW9uID0gc291cmNlLmNsaXBJbnRlcnNlY3Rpb247XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHNyY1BsYW5lcyA9IHNvdXJjZS5jbGlwcGluZ1BsYW5lcyxcXHJcXG5cXHRcXHRcXHRcXHRkc3RQbGFuZXMgPSBudWxsO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggc3JjUGxhbmVzICE9PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBuID0gc3JjUGxhbmVzLmxlbmd0aDtcXHJcXG5cXHRcXHRcXHRcXHRkc3RQbGFuZXMgPSBuZXcgQXJyYXkoIG4gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG47ICsrIGkgKVxcclxcblxcdFxcdFxcdFxcdFxcdGRzdFBsYW5lc1sgaSBdID0gc3JjUGxhbmVzWyBpIF0uY2xvbmUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5jbGlwcGluZ1BsYW5lcyA9IGRzdFBsYW5lcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXHJcXG5cXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cHM6Ly9jbGFyYS5pb1xcclxcblxcdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxcclxcblxcdCAqXFxyXFxuXFx0ICogcGFyYW1ldGVycyA9IHtcXHJcXG5cXHQgKlxcclxcblxcdCAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxcclxcblxcdCAqXFxyXFxuXFx0ICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXHJcXG5cXHQgKlxcclxcblxcdCAqICBhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXHJcXG5cXHQgKlxcclxcblxcdCAqICBkaXNwbGFjZW1lbnRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxyXFxuXFx0ICogIGRpc3BsYWNlbWVudFNjYWxlOiA8ZmxvYXQ+LFxcclxcblxcdCAqICBkaXNwbGFjZW1lbnRCaWFzOiA8ZmxvYXQ+LFxcclxcblxcdCAqXFxyXFxuXFx0ICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxcclxcblxcdCAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD5cXHJcXG5cXHQgKiB9XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gTWVzaERlcHRoTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0TWF0ZXJpYWwuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdNZXNoRGVwdGhNYXRlcmlhbCc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5kZXB0aFBhY2tpbmcgPSBCYXNpY0RlcHRoUGFja2luZztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7XFxyXFxuXFx0XFx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm1hcCA9IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xcclxcblxcdFxcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xcclxcblxcdFxcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcXHJcXG5cXHRcXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5mb2cgPSBmYWxzZTtcXHJcXG5cXHRcXHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdE1lc2hEZXB0aE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hdGVyaWFsLnByb3RvdHlwZSApO1xcclxcblxcdE1lc2hEZXB0aE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1lc2hEZXB0aE1hdGVyaWFsO1xcclxcblxcclxcblxcdE1lc2hEZXB0aE1hdGVyaWFsLnByb3RvdHlwZS5pc01lc2hEZXB0aE1hdGVyaWFsID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRNZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xcclxcblxcclxcblxcdFxcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcclxcblxcclxcblxcdFxcdHRoaXMuZGVwdGhQYWNraW5nID0gc291cmNlLmRlcHRoUGFja2luZztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xcclxcblxcdFxcdHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XFxyXFxuXFx0XFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcXHJcXG5cXHRcXHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50QmlhcztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XFxyXFxuXFx0XFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xcclxcblxcclxcblxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBwYXJhbWV0ZXJzID0ge1xcclxcblxcdCAqXFxyXFxuXFx0ICogIHJlZmVyZW5jZVBvc2l0aW9uOiA8ZmxvYXQ+LFxcclxcblxcdCAqICBuZWFyRGlzdGFuY2U6IDxmbG9hdD4sXFxyXFxuXFx0ICogIGZhckRpc3RhbmNlOiA8ZmxvYXQ+LFxcclxcblxcdCAqXFxyXFxuXFx0ICogIHNraW5uaW5nOiA8Ym9vbD4sXFxyXFxuXFx0ICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxcclxcblxcdCAqXFxyXFxuXFx0ICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXHJcXG5cXHQgKlxcclxcblxcdCAqICBhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXHJcXG5cXHQgKlxcclxcblxcdCAqICBkaXNwbGFjZW1lbnRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxyXFxuXFx0ICogIGRpc3BsYWNlbWVudFNjYWxlOiA8ZmxvYXQ+LFxcclxcblxcdCAqICBkaXNwbGFjZW1lbnRCaWFzOiA8ZmxvYXQ+XFxyXFxuXFx0ICpcXHJcXG5cXHQgKiB9XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gTWVzaERpc3RhbmNlTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0TWF0ZXJpYWwuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdNZXNoRGlzdGFuY2VNYXRlcmlhbCc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5yZWZlcmVuY2VQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0dGhpcy5uZWFyRGlzdGFuY2UgPSAxO1xcclxcblxcdFxcdHRoaXMuZmFyRGlzdGFuY2UgPSAxMDAwO1xcclxcblxcclxcblxcdFxcdHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcXHJcXG5cXHRcXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdHRoaXMubWFwID0gbnVsbDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmFscGhhTWFwID0gbnVsbDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XFxyXFxuXFx0XFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XFxyXFxuXFx0XFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmZvZyA9IGZhbHNlO1xcclxcblxcdFxcdHRoaXMubGlnaHRzID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0TWVzaERpc3RhbmNlTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XFxyXFxuXFx0TWVzaERpc3RhbmNlTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWVzaERpc3RhbmNlTWF0ZXJpYWw7XFxyXFxuXFxyXFxuXFx0TWVzaERpc3RhbmNlTWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaERpc3RhbmNlTWF0ZXJpYWwgPSB0cnVlO1xcclxcblxcclxcblxcdE1lc2hEaXN0YW5jZU1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5yZWZlcmVuY2VQb3NpdGlvbi5jb3B5KCBzb3VyY2UucmVmZXJlbmNlUG9zaXRpb24gKTtcXHJcXG5cXHRcXHR0aGlzLm5lYXJEaXN0YW5jZSA9IHNvdXJjZS5uZWFyRGlzdGFuY2U7XFxyXFxuXFx0XFx0dGhpcy5mYXJEaXN0YW5jZSA9IHNvdXJjZS5mYXJEaXN0YW5jZTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xcclxcblxcdFxcdHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XFxyXFxuXFx0XFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcXHJcXG5cXHRcXHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50QmlhcztcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHR9O1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cXHJcXG5cXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBCb3gzKCBtaW4sIG1heCApIHtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm1pbiA9ICggbWluICE9PSB1bmRlZmluZWQgKSA/IG1pbiA6IG5ldyBWZWN0b3IzKCArIEluZmluaXR5LCArIEluZmluaXR5LCArIEluZmluaXR5ICk7XFxyXFxuXFx0XFx0dGhpcy5tYXggPSAoIG1heCAhPT0gdW5kZWZpbmVkICkgPyBtYXggOiBuZXcgVmVjdG9yMyggLSBJbmZpbml0eSwgLSBJbmZpbml0eSwgLSBJbmZpbml0eSApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRPYmplY3QuYXNzaWduKCBCb3gzLnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdGlzQm94MzogdHJ1ZSxcXHJcXG5cXHJcXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5taW4uY29weSggbWluICk7XFxyXFxuXFx0XFx0XFx0dGhpcy5tYXguY29weSggbWF4ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRGcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG1pblggPSArIEluZmluaXR5O1xcclxcblxcdFxcdFxcdHZhciBtaW5ZID0gKyBJbmZpbml0eTtcXHJcXG5cXHRcXHRcXHR2YXIgbWluWiA9ICsgSW5maW5pdHk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG1heFggPSAtIEluZmluaXR5O1xcclxcblxcdFxcdFxcdHZhciBtYXhZID0gLSBJbmZpbml0eTtcXHJcXG5cXHRcXHRcXHR2YXIgbWF4WiA9IC0gSW5maW5pdHk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArPSAzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciB4ID0gYXJyYXlbIGkgXTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgeSA9IGFycmF5WyBpICsgMSBdO1xcclxcblxcdFxcdFxcdFxcdHZhciB6ID0gYXJyYXlbIGkgKyAyIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB4IDwgbWluWCApIG1pblggPSB4O1xcclxcblxcdFxcdFxcdFxcdGlmICggeSA8IG1pblkgKSBtaW5ZID0geTtcXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHogPCBtaW5aICkgbWluWiA9IHo7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB4ID4gbWF4WCApIG1heFggPSB4O1xcclxcblxcdFxcdFxcdFxcdGlmICggeSA+IG1heFkgKSBtYXhZID0geTtcXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHogPiBtYXhaICkgbWF4WiA9IHo7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHRoaXMubWluLnNldCggbWluWCwgbWluWSwgbWluWiApO1xcclxcblxcdFxcdFxcdHRoaXMubWF4LnNldCggbWF4WCwgbWF4WSwgbWF4WiApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG1pblggPSArIEluZmluaXR5O1xcclxcblxcdFxcdFxcdHZhciBtaW5ZID0gKyBJbmZpbml0eTtcXHJcXG5cXHRcXHRcXHR2YXIgbWluWiA9ICsgSW5maW5pdHk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG1heFggPSAtIEluZmluaXR5O1xcclxcblxcdFxcdFxcdHZhciBtYXhZID0gLSBJbmZpbml0eTtcXHJcXG5cXHRcXHRcXHR2YXIgbWF4WiA9IC0gSW5maW5pdHk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYXR0cmlidXRlLmNvdW50OyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgeCA9IGF0dHJpYnV0ZS5nZXRYKCBpICk7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIHkgPSBhdHRyaWJ1dGUuZ2V0WSggaSApO1xcclxcblxcdFxcdFxcdFxcdHZhciB6ID0gYXR0cmlidXRlLmdldFooIGkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHggPCBtaW5YICkgbWluWCA9IHg7XFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB5IDwgbWluWSApIG1pblkgPSB5O1xcclxcblxcdFxcdFxcdFxcdGlmICggeiA8IG1pblogKSBtaW5aID0gejtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHggPiBtYXhYICkgbWF4WCA9IHg7XFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB5ID4gbWF4WSApIG1heFkgPSB5O1xcclxcblxcdFxcdFxcdFxcdGlmICggeiA+IG1heFogKSBtYXhaID0gejtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5taW4uc2V0KCBtaW5YLCBtaW5ZLCBtaW5aICk7XFxyXFxuXFx0XFx0XFx0dGhpcy5tYXguc2V0KCBtYXhYLCBtYXhZLCBtYXhaICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoIHBvaW50cyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm1ha2VFbXB0eSgpO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5leHBhbmRCeVBvaW50KCBwb2ludHNbIGkgXSApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldEZyb21DZW50ZXJBbmRTaXplOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gc2V0RnJvbUNlbnRlckFuZFNpemUoIGNlbnRlciwgc2l6ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgaGFsZlNpemUgPSB2MS5jb3B5KCBzaXplICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMubWluLmNvcHkoIGNlbnRlciApLnN1YiggaGFsZlNpemUgKTtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLm1heC5jb3B5KCBjZW50ZXIgKS5hZGQoIGhhbGZTaXplICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR9KCksXFxyXFxuXFxyXFxuXFx0XFx0c2V0RnJvbU9iamVjdDogZnVuY3Rpb24gKCBvYmplY3QgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5tYWtlRW1wdHkoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5leHBhbmRCeU9iamVjdCggb2JqZWN0ICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggYm94ICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMubWluLmNvcHkoIGJveC5taW4gKTtcXHJcXG5cXHRcXHRcXHR0aGlzLm1heC5jb3B5KCBib3gubWF4ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRtYWtlRW1wdHk6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm1pbi54ID0gdGhpcy5taW4ueSA9IHRoaXMubWluLnogPSArIEluZmluaXR5O1xcclxcblxcdFxcdFxcdHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gdGhpcy5tYXgueiA9IC0gSW5maW5pdHk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gdGhpcyBpcyBhIG1vcmUgcm9idXN0IGNoZWNrIGZvciBlbXB0eSB0aGFuICggdm9sdW1lIDw9IDAgKSBiZWNhdXNlIHZvbHVtZSBjYW4gZ2V0IHBvc2l0aXZlIHdpdGggdHdvIG5lZ2F0aXZlIGF4ZXNcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gKCB0aGlzLm1heC54IDwgdGhpcy5taW4ueCApIHx8ICggdGhpcy5tYXgueSA8IHRoaXMubWluLnkgKSB8fCAoIHRoaXMubWF4LnogPCB0aGlzLm1pbi56ICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gcmVzdWx0LnNldCggMCwgMCwgMCApIDogcmVzdWx0LmFkZFZlY3RvcnMoIHRoaXMubWluLCB0aGlzLm1heCApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGdldFNpemU6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gcmVzdWx0LnNldCggMCwgMCwgMCApIDogcmVzdWx0LnN1YlZlY3RvcnMoIHRoaXMubWF4LCB0aGlzLm1pbiApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0ZXhwYW5kQnlQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm1pbi5taW4oIHBvaW50ICk7XFxyXFxuXFx0XFx0XFx0dGhpcy5tYXgubWF4KCBwb2ludCApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0ZXhwYW5kQnlWZWN0b3I6IGZ1bmN0aW9uICggdmVjdG9yICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMubWluLnN1YiggdmVjdG9yICk7XFxyXFxuXFx0XFx0XFx0dGhpcy5tYXguYWRkKCB2ZWN0b3IgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGV4cGFuZEJ5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm1pbi5hZGRTY2FsYXIoIC0gc2NhbGFyICk7XFxyXFxuXFx0XFx0XFx0dGhpcy5tYXguYWRkU2NhbGFyKCBzY2FsYXIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGV4cGFuZEJ5T2JqZWN0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gQ29tcHV0ZXMgdGhlIHdvcmxkLWF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggb2YgYW4gb2JqZWN0IChpbmNsdWRpbmcgaXRzIGNoaWxkcmVuKSxcXHJcXG5cXHRcXHRcXHQvLyBhY2NvdW50aW5nIGZvciBib3RoIHRoZSBvYmplY3QncywgYW5kIGNoaWxkcmVuJ3MsIHdvcmxkIHRyYW5zZm9ybXNcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgc2NvcGUsIGksIGw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmdW5jdGlvbiB0cmF2ZXJzZSggbm9kZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgZ2VvbWV0cnkgPSBub2RlLmdlb21ldHJ5O1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggaSA9IDAsIGwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHYxLmNvcHkoIHZlcnRpY2VzWyBpIF0gKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2MS5hcHBseU1hdHJpeDQoIG5vZGUubWF0cml4V29ybGQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzY29wZS5leHBhbmRCeVBvaW50KCB2MSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBhdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggaSA9IDAsIGwgPSBhdHRyaWJ1dGUuY291bnQ7IGkgPCBsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHYxLmZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaSApLmFwcGx5TWF0cml4NCggbm9kZS5tYXRyaXhXb3JsZCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHNjb3BlLmV4cGFuZEJ5UG9pbnQoIHYxICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gZXhwYW5kQnlPYmplY3QoIG9iamVjdCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzY29wZSA9IHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0b2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0b2JqZWN0LnRyYXZlcnNlKCB0cmF2ZXJzZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHBvaW50LnggPCB0aGlzLm1pbi54IHx8IHBvaW50LnggPiB0aGlzLm1heC54IHx8XFxyXFxuXFx0XFx0XFx0XFx0cG9pbnQueSA8IHRoaXMubWluLnkgfHwgcG9pbnQueSA+IHRoaXMubWF4LnkgfHxcXHJcXG5cXHRcXHRcXHRcXHRwb2ludC56IDwgdGhpcy5taW4ueiB8fCBwb2ludC56ID4gdGhpcy5tYXgueiA/IGZhbHNlIDogdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNvbnRhaW5zQm94OiBmdW5jdGlvbiAoIGJveCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5taW4ueCA8PSBib3gubWluLnggJiYgYm94Lm1heC54IDw9IHRoaXMubWF4LnggJiZcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLm1pbi55IDw9IGJveC5taW4ueSAmJiBib3gubWF4LnkgPD0gdGhpcy5tYXgueSAmJlxcclxcblxcdFxcdFxcdFxcdHRoaXMubWluLnogPD0gYm94Lm1pbi56ICYmIGJveC5tYXgueiA8PSB0aGlzLm1heC56O1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Z2V0UGFyYW1ldGVyOiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBUaGlzIGNhbiBwb3RlbnRpYWxseSBoYXZlIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIGJveFxcclxcblxcdFxcdFxcdC8vIGhhcyBhIHNpemUgZGltZW5zaW9uIG9mIDAuXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHJlc3VsdC5zZXQoXFxyXFxuXFx0XFx0XFx0XFx0KCBwb2ludC54IC0gdGhpcy5taW4ueCApIC8gKCB0aGlzLm1heC54IC0gdGhpcy5taW4ueCApLFxcclxcblxcdFxcdFxcdFxcdCggcG9pbnQueSAtIHRoaXMubWluLnkgKSAvICggdGhpcy5tYXgueSAtIHRoaXMubWluLnkgKSxcXHJcXG5cXHRcXHRcXHRcXHQoIHBvaW50LnogLSB0aGlzLm1pbi56ICkgLyAoIHRoaXMubWF4LnogLSB0aGlzLm1pbi56IClcXHJcXG5cXHRcXHRcXHQpO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0aW50ZXJzZWN0c0JveDogZnVuY3Rpb24gKCBib3ggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gdXNpbmcgNiBzcGxpdHRpbmcgcGxhbmVzIHRvIHJ1bGUgb3V0IGludGVyc2VjdGlvbnMuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGJveC5tYXgueCA8IHRoaXMubWluLnggfHwgYm94Lm1pbi54ID4gdGhpcy5tYXgueCB8fFxcclxcblxcdFxcdFxcdFxcdGJveC5tYXgueSA8IHRoaXMubWluLnkgfHwgYm94Lm1pbi55ID4gdGhpcy5tYXgueSB8fFxcclxcblxcdFxcdFxcdFxcdGJveC5tYXgueiA8IHRoaXMubWluLnogfHwgYm94Lm1pbi56ID4gdGhpcy5tYXgueiA/IGZhbHNlIDogdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGludGVyc2VjdHNTcGhlcmU6ICggZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBjbG9zZXN0UG9pbnQgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gRmluZCB0aGUgcG9pbnQgb24gdGhlIEFBQkIgY2xvc2VzdCB0byB0aGUgc3BoZXJlIGNlbnRlci5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmNsYW1wUG9pbnQoIHNwaGVyZS5jZW50ZXIsIGNsb3Nlc3RQb2ludCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIElmIHRoYXQgcG9pbnQgaXMgaW5zaWRlIHRoZSBzcGhlcmUsIHRoZSBBQUJCIGFuZCBzcGhlcmUgaW50ZXJzZWN0LlxcclxcblxcdFxcdFxcdFxcdHJldHVybiBjbG9zZXN0UG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoIHNwaGVyZS5jZW50ZXIgKSA8PSAoIHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR9ICkoKSxcXHJcXG5cXHJcXG5cXHRcXHRpbnRlcnNlY3RzUGxhbmU6IGZ1bmN0aW9uICggcGxhbmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gV2UgY29tcHV0ZSB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBkb3QgcHJvZHVjdCB2YWx1ZXMuIElmIHRob3NlIHZhbHVlc1xcclxcblxcdFxcdFxcdC8vIGFyZSBvbiB0aGUgc2FtZSBzaWRlIChiYWNrIG9yIGZyb250KSBvZiB0aGUgcGxhbmUsIHRoZW4gdGhlcmUgaXMgbm8gaW50ZXJzZWN0aW9uLlxcclxcblxcclxcblxcdFxcdFxcdHZhciBtaW4sIG1heDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHBsYW5lLm5vcm1hbC54ID4gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRtaW4gPSBwbGFuZS5ub3JtYWwueCAqIHRoaXMubWluLng7XFxyXFxuXFx0XFx0XFx0XFx0bWF4ID0gcGxhbmUubm9ybWFsLnggKiB0aGlzLm1heC54O1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bWluID0gcGxhbmUubm9ybWFsLnggKiB0aGlzLm1heC54O1xcclxcblxcdFxcdFxcdFxcdG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5taW4ueDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBwbGFuZS5ub3JtYWwueSA+IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bWluICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5taW4ueTtcXHJcXG5cXHRcXHRcXHRcXHRtYXggKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1heC55O1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bWluICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5tYXgueTtcXHJcXG5cXHRcXHRcXHRcXHRtYXggKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1pbi55O1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHBsYW5lLm5vcm1hbC56ID4gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRtaW4gKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1pbi56O1xcclxcblxcdFxcdFxcdFxcdG1heCArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWF4Lno7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRtaW4gKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1heC56O1xcclxcblxcdFxcdFxcdFxcdG1heCArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWluLno7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiAoIG1pbiA8PSBwbGFuZS5jb25zdGFudCAmJiBtYXggPj0gcGxhbmUuY29uc3RhbnQgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNsYW1wUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdFxcdHJldHVybiByZXN1bHQuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBkaXN0YW5jZVRvUG9pbnQoIHBvaW50ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBjbGFtcGVkUG9pbnQgPSB2MS5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gY2xhbXBlZFBvaW50LnN1YiggcG9pbnQgKS5sZW5ndGgoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0oKSxcXHJcXG5cXHJcXG5cXHRcXHRnZXRCb3VuZGluZ1NwaGVyZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGdldEJvdW5kaW5nU3BoZXJlKCBvcHRpb25hbFRhcmdldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFNwaGVyZSgpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuZ2V0Q2VudGVyKCByZXN1bHQuY2VudGVyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmVzdWx0LnJhZGl1cyA9IHRoaXMuZ2V0U2l6ZSggdjEgKS5sZW5ndGgoKSAqIDAuNTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0O1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdGludGVyc2VjdDogZnVuY3Rpb24gKCBib3ggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5taW4ubWF4KCBib3gubWluICk7XFxyXFxuXFx0XFx0XFx0dGhpcy5tYXgubWluKCBib3gubWF4ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gZW5zdXJlIHRoYXQgaWYgdGhlcmUgaXMgbm8gb3ZlcmxhcCwgdGhlIHJlc3VsdCBpcyBmdWxseSBlbXB0eSwgbm90IHNsaWdodGx5IGVtcHR5IHdpdGggbm9uLWluZi8raW5mIHZhbHVlcyB0aGF0IHdpbGwgY2F1c2Ugc3Vic2VxdWVuY2UgaW50ZXJzZWN0cyB0byBlcnJvbmVvdXNseSByZXR1cm4gdmFsaWQgdmFsdWVzLlxcclxcblxcdFxcdFxcdGlmICggdGhpcy5pc0VtcHR5KCkgKSB0aGlzLm1ha2VFbXB0eSgpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0dW5pb246IGZ1bmN0aW9uICggYm94ICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMubWluLm1pbiggYm94Lm1pbiApO1xcclxcblxcdFxcdFxcdHRoaXMubWF4Lm1heCggYm94Lm1heCApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHBvaW50cyA9IFtcXHJcXG5cXHRcXHRcXHRcXHRuZXcgVmVjdG9yMygpLFxcclxcblxcdFxcdFxcdFxcdG5ldyBWZWN0b3IzKCksXFxyXFxuXFx0XFx0XFx0XFx0bmV3IFZlY3RvcjMoKSxcXHJcXG5cXHRcXHRcXHRcXHRuZXcgVmVjdG9yMygpLFxcclxcblxcdFxcdFxcdFxcdG5ldyBWZWN0b3IzKCksXFxyXFxuXFx0XFx0XFx0XFx0bmV3IFZlY3RvcjMoKSxcXHJcXG5cXHRcXHRcXHRcXHRuZXcgVmVjdG9yMygpLFxcclxcblxcdFxcdFxcdFxcdG5ldyBWZWN0b3IzKClcXHJcXG5cXHRcXHRcXHRdO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBhcHBseU1hdHJpeDQoIG1hdHJpeCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyB0cmFuc2Zvcm0gb2YgZW1wdHkgYm94IGlzIGFuIGVtcHR5IGJveC5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHRoaXMuaXNFbXB0eSgpICkgcmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gTk9URTogSSBhbSB1c2luZyBhIGJpbmFyeSBwYXR0ZXJuIHRvIHNwZWNpZnkgYWxsIDJeMyBjb21iaW5hdGlvbnMgYmVsb3dcXHJcXG5cXHRcXHRcXHRcXHRwb2ludHNbIDAgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWluLnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMDBcXHJcXG5cXHRcXHRcXHRcXHRwb2ludHNbIDEgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWluLnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMDFcXHJcXG5cXHRcXHRcXHRcXHRwb2ludHNbIDIgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWF4LnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMTBcXHJcXG5cXHRcXHRcXHRcXHRwb2ludHNbIDMgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWF4LnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMTFcXHJcXG5cXHRcXHRcXHRcXHRwb2ludHNbIDQgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWluLnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMDBcXHJcXG5cXHRcXHRcXHRcXHRwb2ludHNbIDUgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWluLnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMDFcXHJcXG5cXHRcXHRcXHRcXHRwb2ludHNbIDYgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWF4LnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMTBcXHJcXG5cXHRcXHRcXHRcXHRwb2ludHNbIDcgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWF4LnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xcdC8vIDExMVxcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuc2V0RnJvbVBvaW50cyggcG9pbnRzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR9KCksXFxyXFxuXFxyXFxuXFx0XFx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm1pbi5hZGQoIG9mZnNldCApO1xcclxcblxcdFxcdFxcdHRoaXMubWF4LmFkZCggb2Zmc2V0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRlcXVhbHM6IGZ1bmN0aW9uICggYm94ICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBib3gubWluLmVxdWFscyggdGhpcy5taW4gKSAmJiBib3gubWF4LmVxdWFscyggdGhpcy5tYXggKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIFNwaGVyZSggY2VudGVyLCByYWRpdXMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5jZW50ZXIgPSAoIGNlbnRlciAhPT0gdW5kZWZpbmVkICkgPyBjZW50ZXIgOiBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdHRoaXMucmFkaXVzID0gKCByYWRpdXMgIT09IHVuZGVmaW5lZCApID8gcmFkaXVzIDogMDtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0T2JqZWN0LmFzc2lnbiggU3BoZXJlLnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdHNldDogZnVuY3Rpb24gKCBjZW50ZXIsIHJhZGl1cyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmNlbnRlci5jb3B5KCBjZW50ZXIgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgYm94ID0gbmV3IEJveDMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gc2V0RnJvbVBvaW50cyggcG9pbnRzLCBvcHRpb25hbENlbnRlciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgY2VudGVyID0gdGhpcy5jZW50ZXI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBvcHRpb25hbENlbnRlciAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNlbnRlci5jb3B5KCBvcHRpb25hbENlbnRlciApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ym94LnNldEZyb21Qb2ludHMoIHBvaW50cyApLmdldENlbnRlciggY2VudGVyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBtYXhSYWRpdXNTcSA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRtYXhSYWRpdXNTcSA9IE1hdGgubWF4KCBtYXhSYWRpdXNTcSwgY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludHNbIGkgXSApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMucmFkaXVzID0gTWF0aC5zcXJ0KCBtYXhSYWRpdXNTcSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5jZW50ZXIuY29weSggc3BoZXJlLmNlbnRlciApO1xcclxcblxcdFxcdFxcdHRoaXMucmFkaXVzID0gc3BoZXJlLnJhZGl1cztcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGVtcHR5OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuICggdGhpcy5yYWRpdXMgPD0gMCApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gKCBwb2ludC5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5jZW50ZXIgKSA8PSAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiAoIHBvaW50LmRpc3RhbmNlVG8oIHRoaXMuY2VudGVyICkgLSB0aGlzLnJhZGl1cyApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0aW50ZXJzZWN0c1NwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHJhZGl1c1N1bSA9IHRoaXMucmFkaXVzICsgc3BoZXJlLnJhZGl1cztcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gc3BoZXJlLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5jZW50ZXIgKSA8PSAoIHJhZGl1c1N1bSAqIHJhZGl1c1N1bSApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0aW50ZXJzZWN0c0JveDogZnVuY3Rpb24gKCBib3ggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGJveC5pbnRlcnNlY3RzU3BoZXJlKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRpbnRlcnNlY3RzUGxhbmU6IGZ1bmN0aW9uICggcGxhbmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIE1hdGguYWJzKCBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMuY2VudGVyICkgKSA8PSB0aGlzLnJhZGl1cztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNsYW1wUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBkZWx0YUxlbmd0aFNxID0gdGhpcy5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmVzdWx0LmNvcHkoIHBvaW50ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBkZWx0YUxlbmd0aFNxID4gKCB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmVzdWx0LnN1YiggdGhpcy5jZW50ZXIgKS5ub3JtYWxpemUoKTtcXHJcXG5cXHRcXHRcXHRcXHRyZXN1bHQubXVsdGlwbHlTY2FsYXIoIHRoaXMucmFkaXVzICkuYWRkKCB0aGlzLmNlbnRlciApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0O1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Z2V0Qm91bmRpbmdCb3g6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGJveCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBCb3gzKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ym94LnNldCggdGhpcy5jZW50ZXIsIHRoaXMuY2VudGVyICk7XFxyXFxuXFx0XFx0XFx0Ym94LmV4cGFuZEJ5U2NhbGFyKCB0aGlzLnJhZGl1cyApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBib3g7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbWF0cml4ICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuY2VudGVyLmFwcGx5TWF0cml4NCggbWF0cml4ICk7XFxyXFxuXFx0XFx0XFx0dGhpcy5yYWRpdXMgPSB0aGlzLnJhZGl1cyAqIG1hdHJpeC5nZXRNYXhTY2FsZU9uQXhpcygpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmNlbnRlci5hZGQoIG9mZnNldCApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0ZXF1YWxzOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gc3BoZXJlLmNlbnRlci5lcXVhbHMoIHRoaXMuY2VudGVyICkgJiYgKCBzcGhlcmUucmFkaXVzID09PSB0aGlzLnJhZGl1cyApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIFBsYW5lKCBub3JtYWwsIGNvbnN0YW50ICkge1xcclxcblxcclxcblxcdFxcdC8vIG5vcm1hbCBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm5vcm1hbCA9ICggbm9ybWFsICE9PSB1bmRlZmluZWQgKSA/IG5vcm1hbCA6IG5ldyBWZWN0b3IzKCAxLCAwLCAwICk7XFxyXFxuXFx0XFx0dGhpcy5jb25zdGFudCA9ICggY29uc3RhbnQgIT09IHVuZGVmaW5lZCApID8gY29uc3RhbnQgOiAwO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRPYmplY3QuYXNzaWduKCBQbGFuZS5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uICggbm9ybWFsLCBjb25zdGFudCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLmNvbnN0YW50ID0gY29uc3RhbnQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRDb21wb25lbnRzOiBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5ub3JtYWwuc2V0KCB4LCB5LCB6ICk7XFxyXFxuXFx0XFx0XFx0dGhpcy5jb25zdGFudCA9IHc7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludDogZnVuY3Rpb24gKCBub3JtYWwsIHBvaW50ICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMubm9ybWFsLmNvcHkoIG5vcm1hbCApO1xcclxcblxcdFxcdFxcdHRoaXMuY29uc3RhbnQgPSAtIHBvaW50LmRvdCggdGhpcy5ub3JtYWwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldEZyb21Db3BsYW5hclBvaW50czogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0XFx0dmFyIHYyID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gc2V0RnJvbUNvcGxhbmFyUG9pbnRzKCBhLCBiLCBjICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBub3JtYWwgPSB2MS5zdWJWZWN0b3JzKCBjLCBiICkuY3Jvc3MoIHYyLnN1YlZlY3RvcnMoIGEsIGIgKSApLm5vcm1hbGl6ZSgpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIFE6IHNob3VsZCBhbiBlcnJvciBiZSB0aHJvd24gaWYgbm9ybWFsIGlzIHplcm8gKGUuZy4gZGVnZW5lcmF0ZSBwbGFuZSk/XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5zZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludCggbm9ybWFsLCBhICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR9KCksXFxyXFxuXFxyXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHBsYW5lICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMubm9ybWFsLmNvcHkoIHBsYW5lLm5vcm1hbCApO1xcclxcblxcdFxcdFxcdHRoaXMuY29uc3RhbnQgPSBwbGFuZS5jb25zdGFudDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdC8vIE5vdGU6IHdpbGwgbGVhZCB0byBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBwbGFuZSBpcyBpbnZhbGlkLlxcclxcblxcclxcblxcdFxcdFxcdHZhciBpbnZlcnNlTm9ybWFsTGVuZ3RoID0gMS4wIC8gdGhpcy5ub3JtYWwubGVuZ3RoKCk7XFxyXFxuXFx0XFx0XFx0dGhpcy5ub3JtYWwubXVsdGlwbHlTY2FsYXIoIGludmVyc2VOb3JtYWxMZW5ndGggKTtcXHJcXG5cXHRcXHRcXHR0aGlzLmNvbnN0YW50ICo9IGludmVyc2VOb3JtYWxMZW5ndGg7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmNvbnN0YW50ICo9IC0gMTtcXHJcXG5cXHRcXHRcXHR0aGlzLm5vcm1hbC5uZWdhdGUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5ub3JtYWwuZG90KCBwb2ludCApICsgdGhpcy5jb25zdGFudDtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGRpc3RhbmNlVG9TcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmRpc3RhbmNlVG9Qb2ludCggc3BoZXJlLmNlbnRlciApIC0gc3BoZXJlLnJhZGl1cztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHByb2plY3RQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLm5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCAtIHRoaXMuZGlzdGFuY2VUb1BvaW50KCBwb2ludCApICkuYWRkKCBwb2ludCApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0aW50ZXJzZWN0TGluZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdExpbmUoIGxpbmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBkaXJlY3Rpb24gPSBsaW5lLmRlbHRhKCB2MSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBkZW5vbWluYXRvciA9IHRoaXMubm9ybWFsLmRvdCggZGlyZWN0aW9uICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBkZW5vbWluYXRvciA9PT0gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBsaW5lIGlzIGNvcGxhbmFyLCByZXR1cm4gb3JpZ2luXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0aGlzLmRpc3RhbmNlVG9Qb2ludCggbGluZS5zdGFydCApID09PSAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiByZXN1bHQuY29weSggbGluZS5zdGFydCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBVbnN1cmUgaWYgdGhpcyBpcyB0aGUgY29ycmVjdCBtZXRob2QgdG8gaGFuZGxlIHRoaXMgY2FzZS5cXHJcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdW5kZWZpbmVkO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgdCA9IC0gKCBsaW5lLnN0YXJ0LmRvdCggdGhpcy5ub3JtYWwgKSArIHRoaXMuY29uc3RhbnQgKSAvIGRlbm9taW5hdG9yO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggdCA8IDAgfHwgdCA+IDEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHVuZGVmaW5lZDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBkaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggbGluZS5zdGFydCApO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdGludGVyc2VjdHNMaW5lOiBmdW5jdGlvbiAoIGxpbmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gTm90ZTogdGhpcyB0ZXN0cyBpZiBhIGxpbmUgaW50ZXJzZWN0cyB0aGUgcGxhbmUsIG5vdCB3aGV0aGVyIGl0IChvciBpdHMgZW5kLXBvaW50cykgYXJlIGNvcGxhbmFyIHdpdGggaXQuXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHN0YXJ0U2lnbiA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLnN0YXJ0ICk7XFxyXFxuXFx0XFx0XFx0dmFyIGVuZFNpZ24gPSB0aGlzLmRpc3RhbmNlVG9Qb2ludCggbGluZS5lbmQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gKCBzdGFydFNpZ24gPCAwICYmIGVuZFNpZ24gPiAwICkgfHwgKCBlbmRTaWduIDwgMCAmJiBzdGFydFNpZ24gPiAwICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRpbnRlcnNlY3RzQm94OiBmdW5jdGlvbiAoIGJveCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gYm94LmludGVyc2VjdHNQbGFuZSggdGhpcyApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0aW50ZXJzZWN0c1NwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHNwaGVyZS5pbnRlcnNlY3RzUGxhbmUoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNvcGxhbmFyUG9pbnQ6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLm5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCAtIHRoaXMuY29uc3RhbnQgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0XFx0dmFyIG0xID0gbmV3IE1hdHJpeDMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gYXBwbHlNYXRyaXg0KCBtYXRyaXgsIG9wdGlvbmFsTm9ybWFsTWF0cml4ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBub3JtYWxNYXRyaXggPSBvcHRpb25hbE5vcm1hbE1hdHJpeCB8fCBtMS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciByZWZlcmVuY2VQb2ludCA9IHRoaXMuY29wbGFuYXJQb2ludCggdjEgKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBub3JtYWwgPSB0aGlzLm5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuY29uc3RhbnQgPSAtIHJlZmVyZW5jZVBvaW50LmRvdCggbm9ybWFsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR9KCksXFxyXFxuXFxyXFxuXFx0XFx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmNvbnN0YW50IC09IG9mZnNldC5kb3QoIHRoaXMubm9ybWFsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRlcXVhbHM6IGZ1bmN0aW9uICggcGxhbmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHBsYW5lLm5vcm1hbC5lcXVhbHMoIHRoaXMubm9ybWFsICkgJiYgKCBwbGFuZS5jb25zdGFudCA9PT0gdGhpcy5jb25zdGFudCApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcclxcblxcdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBGcnVzdHVtKCBwMCwgcDEsIHAyLCBwMywgcDQsIHA1ICkge1xcclxcblxcclxcblxcdFxcdHRoaXMucGxhbmVzID0gW1xcclxcblxcclxcblxcdFxcdFxcdCggcDAgIT09IHVuZGVmaW5lZCApID8gcDAgOiBuZXcgUGxhbmUoKSxcXHJcXG5cXHRcXHRcXHQoIHAxICE9PSB1bmRlZmluZWQgKSA/IHAxIDogbmV3IFBsYW5lKCksXFxyXFxuXFx0XFx0XFx0KCBwMiAhPT0gdW5kZWZpbmVkICkgPyBwMiA6IG5ldyBQbGFuZSgpLFxcclxcblxcdFxcdFxcdCggcDMgIT09IHVuZGVmaW5lZCApID8gcDMgOiBuZXcgUGxhbmUoKSxcXHJcXG5cXHRcXHRcXHQoIHA0ICE9PSB1bmRlZmluZWQgKSA/IHA0IDogbmV3IFBsYW5lKCksXFxyXFxuXFx0XFx0XFx0KCBwNSAhPT0gdW5kZWZpbmVkICkgPyBwNSA6IG5ldyBQbGFuZSgpXFxyXFxuXFxyXFxuXFx0XFx0XTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0T2JqZWN0LmFzc2lnbiggRnJ1c3R1bS5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uICggcDAsIHAxLCBwMiwgcDMsIHA0LCBwNSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cGxhbmVzWyAwIF0uY29weSggcDAgKTtcXHJcXG5cXHRcXHRcXHRwbGFuZXNbIDEgXS5jb3B5KCBwMSApO1xcclxcblxcdFxcdFxcdHBsYW5lc1sgMiBdLmNvcHkoIHAyICk7XFxyXFxuXFx0XFx0XFx0cGxhbmVzWyAzIF0uY29weSggcDMgKTtcXHJcXG5cXHRcXHRcXHRwbGFuZXNbIDQgXS5jb3B5KCBwNCApO1xcclxcblxcdFxcdFxcdHBsYW5lc1sgNSBdLmNvcHkoIHA1ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggZnJ1c3R1bSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRwbGFuZXNbIGkgXS5jb3B5KCBmcnVzdHVtLnBsYW5lc1sgaSBdICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0RnJvbU1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcXHJcXG5cXHRcXHRcXHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xcclxcblxcdFxcdFxcdHZhciBtZTAgPSBtZVsgMCBdLCBtZTEgPSBtZVsgMSBdLCBtZTIgPSBtZVsgMiBdLCBtZTMgPSBtZVsgMyBdO1xcclxcblxcdFxcdFxcdHZhciBtZTQgPSBtZVsgNCBdLCBtZTUgPSBtZVsgNSBdLCBtZTYgPSBtZVsgNiBdLCBtZTcgPSBtZVsgNyBdO1xcclxcblxcdFxcdFxcdHZhciBtZTggPSBtZVsgOCBdLCBtZTkgPSBtZVsgOSBdLCBtZTEwID0gbWVbIDEwIF0sIG1lMTEgPSBtZVsgMTEgXTtcXHJcXG5cXHRcXHRcXHR2YXIgbWUxMiA9IG1lWyAxMiBdLCBtZTEzID0gbWVbIDEzIF0sIG1lMTQgPSBtZVsgMTQgXSwgbWUxNSA9IG1lWyAxNSBdO1xcclxcblxcclxcblxcdFxcdFxcdHBsYW5lc1sgMCBdLnNldENvbXBvbmVudHMoIG1lMyAtIG1lMCwgbWU3IC0gbWU0LCBtZTExIC0gbWU4LCBtZTE1IC0gbWUxMiApLm5vcm1hbGl6ZSgpO1xcclxcblxcdFxcdFxcdHBsYW5lc1sgMSBdLnNldENvbXBvbmVudHMoIG1lMyArIG1lMCwgbWU3ICsgbWU0LCBtZTExICsgbWU4LCBtZTE1ICsgbWUxMiApLm5vcm1hbGl6ZSgpO1xcclxcblxcdFxcdFxcdHBsYW5lc1sgMiBdLnNldENvbXBvbmVudHMoIG1lMyArIG1lMSwgbWU3ICsgbWU1LCBtZTExICsgbWU5LCBtZTE1ICsgbWUxMyApLm5vcm1hbGl6ZSgpO1xcclxcblxcdFxcdFxcdHBsYW5lc1sgMyBdLnNldENvbXBvbmVudHMoIG1lMyAtIG1lMSwgbWU3IC0gbWU1LCBtZTExIC0gbWU5LCBtZTE1IC0gbWUxMyApLm5vcm1hbGl6ZSgpO1xcclxcblxcdFxcdFxcdHBsYW5lc1sgNCBdLnNldENvbXBvbmVudHMoIG1lMyAtIG1lMiwgbWU3IC0gbWU2LCBtZTExIC0gbWUxMCwgbWUxNSAtIG1lMTQgKS5ub3JtYWxpemUoKTtcXHJcXG5cXHRcXHRcXHRwbGFuZXNbIDUgXS5zZXRDb21wb25lbnRzKCBtZTMgKyBtZTIsIG1lNyArIG1lNiwgbWUxMSArIG1lMTAsIG1lMTUgKyBtZTE0ICkubm9ybWFsaXplKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRpbnRlcnNlY3RzT2JqZWN0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHNwaGVyZSA9IG5ldyBTcGhlcmUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0c09iamVjdCggb2JqZWN0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsIClcXHJcXG5cXHRcXHRcXHRcXHRcXHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKVxcclxcblxcdFxcdFxcdFxcdFxcdC5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdGludGVyc2VjdHNTcHJpdGU6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgc3BoZXJlID0gbmV3IFNwaGVyZSgpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RzU3ByaXRlKCBzcHJpdGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0c3BoZXJlLmNlbnRlci5zZXQoIDAsIDAsIDAgKTtcXHJcXG5cXHRcXHRcXHRcXHRzcGhlcmUucmFkaXVzID0gMC43MDcxMDY3ODExODY1NDc2O1xcclxcblxcdFxcdFxcdFxcdHNwaGVyZS5hcHBseU1hdHJpeDQoIHNwcml0ZS5tYXRyaXhXb3JsZCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdGludGVyc2VjdHNTcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcXHJcXG5cXHRcXHRcXHR2YXIgY2VudGVyID0gc3BoZXJlLmNlbnRlcjtcXHJcXG5cXHRcXHRcXHR2YXIgbmVnUmFkaXVzID0gLSBzcGhlcmUucmFkaXVzO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGRpc3RhbmNlID0gcGxhbmVzWyBpIF0uZGlzdGFuY2VUb1BvaW50KCBjZW50ZXIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGRpc3RhbmNlIDwgbmVnUmFkaXVzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0cnVlO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0aW50ZXJzZWN0c0JveDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBwMSA9IG5ldyBWZWN0b3IzKCksXFxyXFxuXFx0XFx0XFx0XFx0cDIgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RzQm94KCBib3ggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHBsYW5lID0gcGxhbmVzWyBpIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cDEueCA9IHBsYW5lLm5vcm1hbC54ID4gMCA/IGJveC5taW4ueCA6IGJveC5tYXgueDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRwMi54ID0gcGxhbmUubm9ybWFsLnggPiAwID8gYm94Lm1heC54IDogYm94Lm1pbi54O1xcclxcblxcdFxcdFxcdFxcdFxcdHAxLnkgPSBwbGFuZS5ub3JtYWwueSA+IDAgPyBib3gubWluLnkgOiBib3gubWF4Lnk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0cDIueSA9IHBsYW5lLm5vcm1hbC55ID4gMCA/IGJveC5tYXgueSA6IGJveC5taW4ueTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRwMS56ID0gcGxhbmUubm9ybWFsLnogPiAwID8gYm94Lm1pbi56IDogYm94Lm1heC56O1xcclxcblxcdFxcdFxcdFxcdFxcdHAyLnogPSBwbGFuZS5ub3JtYWwueiA+IDAgPyBib3gubWF4LnogOiBib3gubWluLno7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGQxID0gcGxhbmUuZGlzdGFuY2VUb1BvaW50KCBwMSApO1xcclxcblxcdFxcdFxcdFxcdFxcdHZhciBkMiA9IHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggcDIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBpZiBib3RoIG91dHNpZGUgcGxhbmUsIG5vIGludGVyc2VjdGlvblxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggZDEgPCAwICYmIGQyIDwgMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0oKSxcXHJcXG5cXHJcXG5cXHRcXHRjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggcGxhbmVzWyBpIF0uZGlzdGFuY2VUb1BvaW50KCBwb2ludCApIDwgMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBXZWJHTFNoYWRvd01hcCggX3JlbmRlcmVyLCBfb2JqZWN0cywgbWF4VGV4dHVyZVNpemUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIF9mcnVzdHVtID0gbmV3IEZydXN0dW0oKSxcXHJcXG5cXHRcXHRcXHRfcHJvalNjcmVlbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCksXFxyXFxuXFxyXFxuXFx0XFx0XFx0X3NoYWRvd01hcFNpemUgPSBuZXcgVmVjdG9yMigpLFxcclxcblxcdFxcdFxcdF9tYXhTaGFkb3dNYXBTaXplID0gbmV3IFZlY3RvcjIoIG1heFRleHR1cmVTaXplLCBtYXhUZXh0dXJlU2l6ZSApLFxcclxcblxcclxcblxcdFxcdFxcdF9sb29rVGFyZ2V0ID0gbmV3IFZlY3RvcjMoKSxcXHJcXG5cXHRcXHRcXHRfbGlnaHRQb3NpdGlvbldvcmxkID0gbmV3IFZlY3RvcjMoKSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRfTW9ycGhpbmdGbGFnID0gMSxcXHJcXG5cXHRcXHRcXHRfU2tpbm5pbmdGbGFnID0gMixcXHJcXG5cXHJcXG5cXHRcXHRcXHRfTnVtYmVyT2ZNYXRlcmlhbFZhcmlhbnRzID0gKCBfTW9ycGhpbmdGbGFnIHwgX1NraW5uaW5nRmxhZyApICsgMSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRfZGVwdGhNYXRlcmlhbHMgPSBuZXcgQXJyYXkoIF9OdW1iZXJPZk1hdGVyaWFsVmFyaWFudHMgKSxcXHJcXG5cXHRcXHRcXHRfZGlzdGFuY2VNYXRlcmlhbHMgPSBuZXcgQXJyYXkoIF9OdW1iZXJPZk1hdGVyaWFsVmFyaWFudHMgKSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRfbWF0ZXJpYWxDYWNoZSA9IHt9O1xcclxcblxcclxcblxcdFxcdHZhciBjdWJlRGlyZWN0aW9ucyA9IFtcXHJcXG5cXHRcXHRcXHRuZXcgVmVjdG9yMyggMSwgMCwgMCApLCBuZXcgVmVjdG9yMyggLSAxLCAwLCAwICksIG5ldyBWZWN0b3IzKCAwLCAwLCAxICksXFxyXFxuXFx0XFx0XFx0bmV3IFZlY3RvcjMoIDAsIDAsIC0gMSApLCBuZXcgVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVmVjdG9yMyggMCwgLSAxLCAwIClcXHJcXG5cXHRcXHRdO1xcclxcblxcclxcblxcdFxcdHZhciBjdWJlVXBzID0gW1xcclxcblxcdFxcdFxcdG5ldyBWZWN0b3IzKCAwLCAxLCAwICksIG5ldyBWZWN0b3IzKCAwLCAxLCAwICksIG5ldyBWZWN0b3IzKCAwLCAxLCAwICksXFxyXFxuXFx0XFx0XFx0bmV3IFZlY3RvcjMoIDAsIDEsIDAgKSwgbmV3IFZlY3RvcjMoIDAsIDAsIDEgKSxcXHRuZXcgVmVjdG9yMyggMCwgMCwgLSAxIClcXHJcXG5cXHRcXHRdO1xcclxcblxcclxcblxcdFxcdHZhciBjdWJlMkRWaWV3UG9ydHMgPSBbXFxyXFxuXFx0XFx0XFx0bmV3IFZlY3RvcjQoKSwgbmV3IFZlY3RvcjQoKSwgbmV3IFZlY3RvcjQoKSxcXHJcXG5cXHRcXHRcXHRuZXcgVmVjdG9yNCgpLCBuZXcgVmVjdG9yNCgpLCBuZXcgVmVjdG9yNCgpXFxyXFxuXFx0XFx0XTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBpbml0XFxyXFxuXFxyXFxuXFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBfTnVtYmVyT2ZNYXRlcmlhbFZhcmlhbnRzOyArKyBpICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB1c2VNb3JwaGluZyA9ICggaSAmIF9Nb3JwaGluZ0ZsYWcgKSAhPT0gMDtcXHJcXG5cXHRcXHRcXHR2YXIgdXNlU2tpbm5pbmcgPSAoIGkgJiBfU2tpbm5pbmdGbGFnICkgIT09IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGRlcHRoTWF0ZXJpYWwgPSBuZXcgTWVzaERlcHRoTWF0ZXJpYWwoIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRkZXB0aFBhY2tpbmc6IFJHQkFEZXB0aFBhY2tpbmcsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bW9ycGhUYXJnZXRzOiB1c2VNb3JwaGluZyxcXHJcXG5cXHRcXHRcXHRcXHRza2lubmluZzogdXNlU2tpbm5pbmdcXHJcXG5cXHJcXG5cXHRcXHRcXHR9ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0X2RlcHRoTWF0ZXJpYWxzWyBpIF0gPSBkZXB0aE1hdGVyaWFsO1xcclxcblxcclxcblxcdFxcdFxcdC8vXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGRpc3RhbmNlTWF0ZXJpYWwgPSBuZXcgTWVzaERpc3RhbmNlTWF0ZXJpYWwoIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRtb3JwaFRhcmdldHM6IHVzZU1vcnBoaW5nLFxcclxcblxcdFxcdFxcdFxcdHNraW5uaW5nOiB1c2VTa2lubmluZ1xcclxcblxcclxcblxcdFxcdFxcdH0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRfZGlzdGFuY2VNYXRlcmlhbHNbIGkgXSA9IGRpc3RhbmNlTWF0ZXJpYWw7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdC8vXFxyXFxuXFxyXFxuXFx0XFx0dmFyIHNjb3BlID0gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmVuYWJsZWQgPSBmYWxzZTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmF1dG9VcGRhdGUgPSB0cnVlO1xcclxcblxcdFxcdHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSBQQ0ZTaGFkb3dNYXA7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5yZW5kZXJSZXZlcnNlU2lkZWQgPSB0cnVlO1xcclxcblxcdFxcdHRoaXMucmVuZGVyU2luZ2xlU2lkZWQgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBsaWdodHMsIHNjZW5lLCBjYW1lcmEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcXHJcXG5cXHRcXHRcXHRpZiAoIHNjb3BlLmF1dG9VcGRhdGUgPT09IGZhbHNlICYmIHNjb3BlLm5lZWRzVXBkYXRlID09PSBmYWxzZSApIHJldHVybjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGxpZ2h0cy5sZW5ndGggPT09IDAgKSByZXR1cm47XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gVE9ETyBDbGVhbiB1cCAobmVlZGVkIGluIGNhc2Ugb2YgY29udGV4dGxvc3QpXFxyXFxuXFx0XFx0XFx0dmFyIF9nbCA9IF9yZW5kZXJlci5jb250ZXh0O1xcclxcblxcdFxcdFxcdHZhciBfc3RhdGUgPSBfcmVuZGVyZXIuc3RhdGU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gU2V0IEdMIHN0YXRlIGZvciBkZXB0aCBtYXAuXFxyXFxuXFx0XFx0XFx0X3N0YXRlLmRpc2FibGUoIF9nbC5CTEVORCApO1xcclxcblxcdFxcdFxcdF9zdGF0ZS5idWZmZXJzLmNvbG9yLnNldENsZWFyKCAxLCAxLCAxLCAxICk7XFxyXFxuXFx0XFx0XFx0X3N0YXRlLmJ1ZmZlcnMuZGVwdGguc2V0VGVzdCggdHJ1ZSApO1xcclxcblxcdFxcdFxcdF9zdGF0ZS5zZXRTY2lzc29yVGVzdCggZmFsc2UgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyByZW5kZXIgZGVwdGggbWFwXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGZhY2VDb3VudDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbGlnaHRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBsaWdodCA9IGxpZ2h0c1sgaSBdO1xcclxcblxcdFxcdFxcdFxcdHZhciBzaGFkb3cgPSBsaWdodC5zaGFkb3c7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGlzUG9pbnRMaWdodCA9IGxpZ2h0ICYmIGxpZ2h0LmlzUG9pbnRMaWdodDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHNoYWRvdyA9PT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMU2hhZG93TWFwOicsIGxpZ2h0LCAnaGFzIG5vIHNoYWRvdy4nICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0Y29udGludWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBzaGFkb3dDYW1lcmEgPSBzaGFkb3cuY2FtZXJhO1xcclxcblxcclxcblxcdFxcdFxcdFxcdF9zaGFkb3dNYXBTaXplLmNvcHkoIHNoYWRvdy5tYXBTaXplICk7XFxyXFxuXFx0XFx0XFx0XFx0X3NoYWRvd01hcFNpemUubWluKCBfbWF4U2hhZG93TWFwU2l6ZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggaXNQb2ludExpZ2h0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciB2cFdpZHRoID0gX3NoYWRvd01hcFNpemUueDtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdnBIZWlnaHQgPSBfc2hhZG93TWFwU2l6ZS55O1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIFRoZXNlIHZpZXdwb3J0cyBtYXAgYSBjdWJlLW1hcCBvbnRvIGEgMkQgdGV4dHVyZSB3aXRoIHRoZVxcclxcblxcdFxcdFxcdFxcdFxcdC8vIGZvbGxvd2luZyBvcmllbnRhdGlvbjpcXHJcXG5cXHRcXHRcXHRcXHRcXHQvL1xcclxcblxcdFxcdFxcdFxcdFxcdC8vICB4elhaXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gICB5IFlcXHJcXG5cXHRcXHRcXHRcXHRcXHQvL1xcclxcblxcdFxcdFxcdFxcdFxcdC8vIFggLSBQb3NpdGl2ZSB4IGRpcmVjdGlvblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIHggLSBOZWdhdGl2ZSB4IGRpcmVjdGlvblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIFkgLSBQb3NpdGl2ZSB5IGRpcmVjdGlvblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIHkgLSBOZWdhdGl2ZSB5IGRpcmVjdGlvblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIFogLSBQb3NpdGl2ZSB6IGRpcmVjdGlvblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIHogLSBOZWdhdGl2ZSB6IGRpcmVjdGlvblxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIHBvc2l0aXZlIFhcXHJcXG5cXHRcXHRcXHRcXHRcXHRjdWJlMkRWaWV3UG9ydHNbIDAgXS5zZXQoIHZwV2lkdGggKiAyLCB2cEhlaWdodCwgdnBXaWR0aCwgdnBIZWlnaHQgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBuZWdhdGl2ZSBYXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y3ViZTJEVmlld1BvcnRzWyAxIF0uc2V0KCAwLCB2cEhlaWdodCwgdnBXaWR0aCwgdnBIZWlnaHQgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBwb3NpdGl2ZSBaXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y3ViZTJEVmlld1BvcnRzWyAyIF0uc2V0KCB2cFdpZHRoICogMywgdnBIZWlnaHQsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gbmVnYXRpdmUgWlxcclxcblxcdFxcdFxcdFxcdFxcdGN1YmUyRFZpZXdQb3J0c1sgMyBdLnNldCggdnBXaWR0aCwgdnBIZWlnaHQsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gcG9zaXRpdmUgWVxcclxcblxcdFxcdFxcdFxcdFxcdGN1YmUyRFZpZXdQb3J0c1sgNCBdLnNldCggdnBXaWR0aCAqIDMsIDAsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gbmVnYXRpdmUgWVxcclxcblxcdFxcdFxcdFxcdFxcdGN1YmUyRFZpZXdQb3J0c1sgNSBdLnNldCggdnBXaWR0aCwgMCwgdnBXaWR0aCwgdnBIZWlnaHQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRfc2hhZG93TWFwU2l6ZS54ICo9IDQuMDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRfc2hhZG93TWFwU2l6ZS55ICo9IDIuMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBzaGFkb3cubWFwID09PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBwYXJzID0geyBtaW5GaWx0ZXI6IE5lYXJlc3RGaWx0ZXIsIG1hZ0ZpbHRlcjogTmVhcmVzdEZpbHRlciwgZm9ybWF0OiBSR0JBRm9ybWF0IH07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0c2hhZG93Lm1hcCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldCggX3NoYWRvd01hcFNpemUueCwgX3NoYWRvd01hcFNpemUueSwgcGFycyApO1xcclxcblxcdFxcdFxcdFxcdFxcdHNoYWRvdy5tYXAudGV4dHVyZS5uYW1lID0gbGlnaHQubmFtZSArIFxcXCIuc2hhZG93TWFwXFxcIjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRzaGFkb3dDYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHNoYWRvdy5pc1Nwb3RMaWdodFNoYWRvdyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRzaGFkb3cudXBkYXRlKCBsaWdodCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgc2hhZG93TWFwID0gc2hhZG93Lm1hcDtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgc2hhZG93TWF0cml4ID0gc2hhZG93Lm1hdHJpeDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRfbGlnaHRQb3NpdGlvbldvcmxkLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcXHJcXG5cXHRcXHRcXHRcXHRzaGFkb3dDYW1lcmEucG9zaXRpb24uY29weSggX2xpZ2h0UG9zaXRpb25Xb3JsZCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggaXNQb2ludExpZ2h0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGZhY2VDb3VudCA9IDY7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gZm9yIHBvaW50IGxpZ2h0cyB3ZSBzZXQgdGhlIHNoYWRvdyBtYXRyaXggdG8gYmUgYSB0cmFuc2xhdGlvbi1vbmx5IG1hdHJpeFxcclxcblxcdFxcdFxcdFxcdFxcdC8vIGVxdWFsIHRvIGludmVyc2Ugb2YgdGhlIGxpZ2h0J3MgcG9zaXRpb25cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRzaGFkb3dNYXRyaXgubWFrZVRyYW5zbGF0aW9uKCAtIF9saWdodFBvc2l0aW9uV29ybGQueCwgLSBfbGlnaHRQb3NpdGlvbldvcmxkLnksIC0gX2xpZ2h0UG9zaXRpb25Xb3JsZC56ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmYWNlQ291bnQgPSAxO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdF9sb29rVGFyZ2V0LnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0c2hhZG93Q2FtZXJhLmxvb2tBdCggX2xvb2tUYXJnZXQgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRzaGFkb3dDYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBjb21wdXRlIHNoYWRvdyBtYXRyaXhcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRzaGFkb3dNYXRyaXguc2V0KFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdDAuNSwgMC4wLCAwLjAsIDAuNSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQwLjAsIDAuNSwgMC4wLCAwLjUsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0MC4wLCAwLjAsIDAuNSwgMC41LFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdDAuMCwgMC4wLCAwLjAsIDEuMFxcclxcblxcdFxcdFxcdFxcdFxcdCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0c2hhZG93TWF0cml4Lm11bHRpcGx5KCBzaGFkb3dDYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xcclxcblxcdFxcdFxcdFxcdFxcdHNoYWRvd01hdHJpeC5tdWx0aXBseSggc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRfcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBzaGFkb3dNYXAgKTtcXHJcXG5cXHRcXHRcXHRcXHRfcmVuZGVyZXIuY2xlYXIoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyByZW5kZXIgc2hhZG93IG1hcCBmb3IgZWFjaCBjdWJlIGZhY2UgKGlmIG9tbmktZGlyZWN0aW9uYWwpIG9yXFxyXFxuXFx0XFx0XFx0XFx0Ly8gcnVuIGEgc2luZ2xlIHBhc3MgaWYgbm90XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGZhY2UgPSAwOyBmYWNlIDwgZmFjZUNvdW50OyBmYWNlICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggaXNQb2ludExpZ2h0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdF9sb29rVGFyZ2V0LmNvcHkoIHNoYWRvd0NhbWVyYS5wb3NpdGlvbiApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdF9sb29rVGFyZ2V0LmFkZCggY3ViZURpcmVjdGlvbnNbIGZhY2UgXSApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHNoYWRvd0NhbWVyYS51cC5jb3B5KCBjdWJlVXBzWyBmYWNlIF0gKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRzaGFkb3dDYW1lcmEubG9va0F0KCBfbG9va1RhcmdldCApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHNoYWRvd0NhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciB2cERpbWVuc2lvbnMgPSBjdWJlMkRWaWV3UG9ydHNbIGZhY2UgXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRfc3RhdGUudmlld3BvcnQoIHZwRGltZW5zaW9ucyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyB1cGRhdGUgY2FtZXJhIG1hdHJpY2VzIGFuZCBmcnVzdHVtXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0X3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggc2hhZG93Q2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRfZnJ1c3R1bS5zZXRGcm9tTWF0cml4KCBfcHJvalNjcmVlbk1hdHJpeCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIHNldCBvYmplY3QgbWF0cmljZXMgJiBmcnVzdHVtIGN1bGxpbmdcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRyZW5kZXJPYmplY3QoIHNjZW5lLCBjYW1lcmEsIHNoYWRvd0NhbWVyYSwgaXNQb2ludExpZ2h0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRzY29wZS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gZ2V0RGVwdGhNYXRlcmlhbCggb2JqZWN0LCBtYXRlcmlhbCwgaXNQb2ludExpZ2h0LCBsaWdodFBvc2l0aW9uV29ybGQsIHNoYWRvd0NhbWVyYU5lYXIsIHNoYWRvd0NhbWVyYUZhciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHJlc3VsdCA9IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG1hdGVyaWFsVmFyaWFudHMgPSBfZGVwdGhNYXRlcmlhbHM7XFxyXFxuXFx0XFx0XFx0dmFyIGN1c3RvbU1hdGVyaWFsID0gb2JqZWN0LmN1c3RvbURlcHRoTWF0ZXJpYWw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBpc1BvaW50TGlnaHQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bWF0ZXJpYWxWYXJpYW50cyA9IF9kaXN0YW5jZU1hdGVyaWFscztcXHJcXG5cXHRcXHRcXHRcXHRjdXN0b21NYXRlcmlhbCA9IG9iamVjdC5jdXN0b21EaXN0YW5jZU1hdGVyaWFsO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoICEgY3VzdG9tTWF0ZXJpYWwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHVzZU1vcnBoaW5nID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5tb3JwaFRhcmdldHMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHVzZU1vcnBoaW5nID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzICYmIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiAmJiBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24ubGVuZ3RoID4gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0dlb21ldHJ5ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHVzZU1vcnBoaW5nID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzICYmIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGggPiAwO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBvYmplY3QuaXNTa2lubmVkTWVzaCAmJiBtYXRlcmlhbC5za2lubmluZyA9PT0gZmFsc2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xTaGFkb3dNYXA6IFRIUkVFLlNraW5uZWRNZXNoIHdpdGggbWF0ZXJpYWwuc2tpbm5pbmcgc2V0IHRvIGZhbHNlOicsIG9iamVjdCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgdXNlU2tpbm5pbmcgPSBvYmplY3QuaXNTa2lubmVkTWVzaCAmJiBtYXRlcmlhbC5za2lubmluZztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgdmFyaWFudEluZGV4ID0gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHVzZU1vcnBoaW5nICkgdmFyaWFudEluZGV4IHw9IF9Nb3JwaGluZ0ZsYWc7XFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB1c2VTa2lubmluZyApIHZhcmlhbnRJbmRleCB8PSBfU2tpbm5pbmdGbGFnO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJlc3VsdCA9IG1hdGVyaWFsVmFyaWFudHNbIHZhcmlhbnRJbmRleCBdO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmVzdWx0ID0gY3VzdG9tTWF0ZXJpYWw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggX3JlbmRlcmVyLmxvY2FsQ2xpcHBpbmdFbmFibGVkICYmXFxyXFxuXFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWwuY2xpcFNoYWRvd3MgPT09IHRydWUgJiZcXHJcXG5cXHRcXHRcXHRcXHRcXHRtYXRlcmlhbC5jbGlwcGluZ1BsYW5lcy5sZW5ndGggIT09IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gaW4gdGhpcyBjYXNlIHdlIG5lZWQgYSB1bmlxdWUgbWF0ZXJpYWwgaW5zdGFuY2UgcmVmbGVjdGluZyB0aGVcXHJcXG5cXHRcXHRcXHRcXHQvLyBhcHByb3ByaWF0ZSBzdGF0ZVxcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBrZXlBID0gcmVzdWx0LnV1aWQsIGtleUIgPSBtYXRlcmlhbC51dWlkO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBtYXRlcmlhbHNGb3JWYXJpYW50ID0gX21hdGVyaWFsQ2FjaGVbIGtleUEgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIG1hdGVyaWFsc0ZvclZhcmlhbnQgPT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRtYXRlcmlhbHNGb3JWYXJpYW50ID0ge307XFxyXFxuXFx0XFx0XFx0XFx0XFx0X21hdGVyaWFsQ2FjaGVbIGtleUEgXSA9IG1hdGVyaWFsc0ZvclZhcmlhbnQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBjYWNoZWRNYXRlcmlhbCA9IG1hdGVyaWFsc0ZvclZhcmlhbnRbIGtleUIgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGNhY2hlZE1hdGVyaWFsID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y2FjaGVkTWF0ZXJpYWwgPSByZXN1bHQuY2xvbmUoKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRtYXRlcmlhbHNGb3JWYXJpYW50WyBrZXlCIF0gPSBjYWNoZWRNYXRlcmlhbDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmVzdWx0ID0gY2FjaGVkTWF0ZXJpYWw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJlc3VsdC52aXNpYmxlID0gbWF0ZXJpYWwudmlzaWJsZTtcXHJcXG5cXHRcXHRcXHRyZXN1bHQud2lyZWZyYW1lID0gbWF0ZXJpYWwud2lyZWZyYW1lO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBzaWRlID0gbWF0ZXJpYWwuc2lkZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHNjb3BlLnJlbmRlclNpbmdsZVNpZGVkICYmIHNpZGUgPT0gRG91YmxlU2lkZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzaWRlID0gRnJvbnRTaWRlO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHNjb3BlLnJlbmRlclJldmVyc2VTaWRlZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHNpZGUgPT09IEZyb250U2lkZSApIHNpZGUgPSBCYWNrU2lkZTtcXHJcXG5cXHRcXHRcXHRcXHRlbHNlIGlmICggc2lkZSA9PT0gQmFja1NpZGUgKSBzaWRlID0gRnJvbnRTaWRlO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXN1bHQuc2lkZSA9IHNpZGU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmVzdWx0LmNsaXBTaGFkb3dzID0gbWF0ZXJpYWwuY2xpcFNoYWRvd3M7XFxyXFxuXFx0XFx0XFx0cmVzdWx0LmNsaXBwaW5nUGxhbmVzID0gbWF0ZXJpYWwuY2xpcHBpbmdQbGFuZXM7XFxyXFxuXFx0XFx0XFx0cmVzdWx0LmNsaXBJbnRlcnNlY3Rpb24gPSBtYXRlcmlhbC5jbGlwSW50ZXJzZWN0aW9uO1xcclxcblxcclxcblxcdFxcdFxcdHJlc3VsdC53aXJlZnJhbWVMaW5ld2lkdGggPSBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGg7XFxyXFxuXFx0XFx0XFx0cmVzdWx0LmxpbmV3aWR0aCA9IG1hdGVyaWFsLmxpbmV3aWR0aDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGlzUG9pbnRMaWdodCAmJiByZXN1bHQuaXNNZXNoRGlzdGFuY2VNYXRlcmlhbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXN1bHQucmVmZXJlbmNlUG9zaXRpb24uY29weSggbGlnaHRQb3NpdGlvbldvcmxkICk7XFxyXFxuXFx0XFx0XFx0XFx0cmVzdWx0Lm5lYXJEaXN0YW5jZSA9IHNoYWRvd0NhbWVyYU5lYXI7XFxyXFxuXFx0XFx0XFx0XFx0cmVzdWx0LmZhckRpc3RhbmNlID0gc2hhZG93Q2FtZXJhRmFyO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0O1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiByZW5kZXJPYmplY3QoIG9iamVjdCwgY2FtZXJhLCBzaGFkb3dDYW1lcmEsIGlzUG9pbnRMaWdodCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIG9iamVjdC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdmlzaWJsZSA9IG9iamVjdC5sYXllcnMudGVzdCggY2FtZXJhLmxheWVycyApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdmlzaWJsZSAmJiAoIG9iamVjdC5pc01lc2ggfHwgb2JqZWN0LmlzTGluZSB8fCBvYmplY3QuaXNQb2ludHMgKSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIG9iamVjdC5jYXN0U2hhZG93ICYmICggISBvYmplY3QuZnJ1c3R1bUN1bGxlZCB8fCBfZnJ1c3R1bS5pbnRlcnNlY3RzT2JqZWN0KCBvYmplY3QgKSApICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdG9iamVjdC5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGdlb21ldHJ5ID0gX29iamVjdHMudXBkYXRlKCBvYmplY3QgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBBcnJheS5pc0FycmF5KCBtYXRlcmlhbCApICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGsgPSAwLCBrbCA9IGdyb3Vwcy5sZW5ndGg7IGsgPCBrbDsgayArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgZ3JvdXAgPSBncm91cHNbIGsgXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsWyBncm91cC5tYXRlcmlhbEluZGV4IF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBncm91cE1hdGVyaWFsICYmIGdyb3VwTWF0ZXJpYWwudmlzaWJsZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgZGVwdGhNYXRlcmlhbCA9IGdldERlcHRoTWF0ZXJpYWwoIG9iamVjdCwgZ3JvdXBNYXRlcmlhbCwgaXNQb2ludExpZ2h0LCBfbGlnaHRQb3NpdGlvbldvcmxkLCBzaGFkb3dDYW1lcmEubmVhciwgc2hhZG93Q2FtZXJhLmZhciApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdF9yZW5kZXJlci5yZW5kZXJCdWZmZXJEaXJlY3QoIHNoYWRvd0NhbWVyYSwgbnVsbCwgZ2VvbWV0cnksIGRlcHRoTWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLnZpc2libGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGRlcHRoTWF0ZXJpYWwgPSBnZXREZXB0aE1hdGVyaWFsKCBvYmplY3QsIG1hdGVyaWFsLCBpc1BvaW50TGlnaHQsIF9saWdodFBvc2l0aW9uV29ybGQsIHNoYWRvd0NhbWVyYS5uZWFyLCBzaGFkb3dDYW1lcmEuZmFyICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0X3JlbmRlcmVyLnJlbmRlckJ1ZmZlckRpcmVjdCggc2hhZG93Q2FtZXJhLCBudWxsLCBnZW9tZXRyeSwgZGVwdGhNYXRlcmlhbCwgb2JqZWN0LCBudWxsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmVuZGVyT2JqZWN0KCBjaGlsZHJlblsgaSBdLCBjYW1lcmEsIHNoYWRvd0NhbWVyYSwgaXNQb2ludExpZ2h0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBXZWJHTEF0dHJpYnV0ZXMoIGdsICkge1xcclxcblxcclxcblxcdFxcdHZhciBidWZmZXJzID0ge307XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gY3JlYXRlQnVmZmVyKCBhdHRyaWJ1dGUsIGJ1ZmZlclR5cGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGFycmF5ID0gYXR0cmlidXRlLmFycmF5O1xcclxcblxcdFxcdFxcdHZhciB1c2FnZSA9IGF0dHJpYnV0ZS5keW5hbWljID8gZ2wuRFlOQU1JQ19EUkFXIDogZ2wuU1RBVElDX0RSQVc7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xcclxcblxcclxcblxcdFxcdFxcdGdsLmJpbmRCdWZmZXIoIGJ1ZmZlclR5cGUsIGJ1ZmZlciApO1xcclxcblxcdFxcdFxcdGdsLmJ1ZmZlckRhdGEoIGJ1ZmZlclR5cGUsIGFycmF5LCB1c2FnZSApO1xcclxcblxcclxcblxcdFxcdFxcdGF0dHJpYnV0ZS5vblVwbG9hZENhbGxiYWNrKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHR5cGUgPSBnbC5GTE9BVDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGFycmF5IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHR5cGUgPSBnbC5GTE9BVDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTEF0dHJpYnV0ZXM6IFVuc3VwcG9ydGVkIGRhdGEgYnVmZmVyIGZvcm1hdDogRmxvYXQ2NEFycmF5LicgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHR5cGUgPSBnbC5VTlNJR05FRF9TSE9SVDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIEludDE2QXJyYXkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dHlwZSA9IGdsLlNIT1JUO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGFycmF5IGluc3RhbmNlb2YgVWludDMyQXJyYXkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dHlwZSA9IGdsLlVOU0lHTkVEX0lOVDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIEludDMyQXJyYXkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dHlwZSA9IGdsLklOVDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIEludDhBcnJheSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0eXBlID0gZ2wuQllURTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB7XFxyXFxuXFx0XFx0XFx0XFx0YnVmZmVyOiBidWZmZXIsXFxyXFxuXFx0XFx0XFx0XFx0dHlwZTogdHlwZSxcXHJcXG5cXHRcXHRcXHRcXHRieXRlc1BlckVsZW1lbnQ6IGFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxcclxcblxcdFxcdFxcdFxcdHZlcnNpb246IGF0dHJpYnV0ZS52ZXJzaW9uXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gdXBkYXRlQnVmZmVyKCBidWZmZXIsIGF0dHJpYnV0ZSwgYnVmZmVyVHlwZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XFxyXFxuXFx0XFx0XFx0dmFyIHVwZGF0ZVJhbmdlID0gYXR0cmlidXRlLnVwZGF0ZVJhbmdlO1xcclxcblxcclxcblxcdFxcdFxcdGdsLmJpbmRCdWZmZXIoIGJ1ZmZlclR5cGUsIGJ1ZmZlciApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggYXR0cmlidXRlLmR5bmFtaWMgPT09IGZhbHNlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGdsLmJ1ZmZlckRhdGEoIGJ1ZmZlclR5cGUsIGFycmF5LCBnbC5TVEFUSUNfRFJBVyApO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIHVwZGF0ZVJhbmdlLmNvdW50ID09PSAtIDEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gTm90IHVzaW5nIHVwZGF0ZSByYW5nZXNcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRnbC5idWZmZXJTdWJEYXRhKCBidWZmZXJUeXBlLCAwLCBhcnJheSApO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIHVwZGF0ZVJhbmdlLmNvdW50ID09PSAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTE9iamVjdHMudXBkYXRlQnVmZmVyOiBkeW5hbWljIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSBtYXJrZWQgYXMgbmVlZHNVcGRhdGUgYnV0IHVwZGF0ZVJhbmdlLmNvdW50IGlzIDAsIGVuc3VyZSB5b3UgYXJlIHVzaW5nIHNldCBtZXRob2RzIG9yIHVwZGF0aW5nIG1hbnVhbGx5LicgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGdsLmJ1ZmZlclN1YkRhdGEoIGJ1ZmZlclR5cGUsIHVwZGF0ZVJhbmdlLm9mZnNldCAqIGFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxcclxcblxcdFxcdFxcdFxcdFxcdGFycmF5LnN1YmFycmF5KCB1cGRhdGVSYW5nZS5vZmZzZXQsIHVwZGF0ZVJhbmdlLm9mZnNldCArIHVwZGF0ZVJhbmdlLmNvdW50ICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR1cGRhdGVSYW5nZS5jb3VudCA9IC0gMTsgLy8gcmVzZXQgcmFuZ2VcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdC8vXFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gZ2V0KCBhdHRyaWJ1dGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZS5kYXRhO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBidWZmZXJzWyBhdHRyaWJ1dGUudXVpZCBdO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiByZW1vdmUoIGF0dHJpYnV0ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkgYXR0cmlidXRlID0gYXR0cmlidXRlLmRhdGE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGRhdGEgPSBidWZmZXJzWyBhdHRyaWJ1dGUudXVpZCBdO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggZGF0YSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRnbC5kZWxldGVCdWZmZXIoIGRhdGEuYnVmZmVyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZGVsZXRlIGJ1ZmZlcnNbIGF0dHJpYnV0ZS51dWlkIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiB1cGRhdGUoIGF0dHJpYnV0ZSwgYnVmZmVyVHlwZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkgYXR0cmlidXRlID0gYXR0cmlidXRlLmRhdGE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGRhdGEgPSBidWZmZXJzWyBhdHRyaWJ1dGUudXVpZCBdO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGJ1ZmZlcnNbIGF0dHJpYnV0ZS51dWlkIF0gPSBjcmVhdGVCdWZmZXIoIGF0dHJpYnV0ZSwgYnVmZmVyVHlwZSApO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGRhdGEudmVyc2lvbiA8IGF0dHJpYnV0ZS52ZXJzaW9uICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHVwZGF0ZUJ1ZmZlciggZGF0YS5idWZmZXIsIGF0dHJpYnV0ZSwgYnVmZmVyVHlwZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGRhdGEudmVyc2lvbiA9IGF0dHJpYnV0ZS52ZXJzaW9uO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRnZXQ6IGdldCxcXHJcXG5cXHRcXHRcXHRyZW1vdmU6IHJlbW92ZSxcXHJcXG5cXHRcXHRcXHR1cGRhdGU6IHVwZGF0ZVxcclxcblxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XFxyXFxuXFx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIEV1bGVyKCB4LCB5LCB6LCBvcmRlciApIHtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLl94ID0geCB8fCAwO1xcclxcblxcdFxcdHRoaXMuX3kgPSB5IHx8IDA7XFxyXFxuXFx0XFx0dGhpcy5feiA9IHogfHwgMDtcXHJcXG5cXHRcXHR0aGlzLl9vcmRlciA9IG9yZGVyIHx8IEV1bGVyLkRlZmF1bHRPcmRlcjtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0RXVsZXIuUm90YXRpb25PcmRlcnMgPSBbICdYWVonLCAnWVpYJywgJ1pYWScsICdYWlknLCAnWVhaJywgJ1pZWCcgXTtcXHJcXG5cXHJcXG5cXHRFdWxlci5EZWZhdWx0T3JkZXIgPSAnWFlaJztcXHJcXG5cXHJcXG5cXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggRXVsZXIucHJvdG90eXBlLCB7XFxyXFxuXFxyXFxuXFx0XFx0eDoge1xcclxcblxcclxcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLl94O1xcclxcblxcclxcblxcdFxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuX3ggPSB2YWx1ZTtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHR5OiB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuX3k7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5feSA9IHZhbHVlO1xcclxcblxcdFxcdFxcdFxcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHo6IHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5fejtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9LFxcclxcblxcclxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLl96ID0gdmFsdWU7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0b3JkZXI6IHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5fb3JkZXI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5fb3JkZXIgPSB2YWx1ZTtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHRPYmplY3QuYXNzaWduKCBFdWxlci5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHRpc0V1bGVyOiB0cnVlLFxcclxcblxcclxcblxcdFxcdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCBvcmRlciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLl94ID0geDtcXHJcXG5cXHRcXHRcXHR0aGlzLl95ID0geTtcXHJcXG5cXHRcXHRcXHR0aGlzLl96ID0gejtcXHJcXG5cXHRcXHRcXHR0aGlzLl9vcmRlciA9IG9yZGVyIHx8IHRoaXMuX29yZGVyO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX29yZGVyICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIGV1bGVyICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuX3ggPSBldWxlci5feDtcXHJcXG5cXHRcXHRcXHR0aGlzLl95ID0gZXVsZXIuX3k7XFxyXFxuXFx0XFx0XFx0dGhpcy5feiA9IGV1bGVyLl96O1xcclxcblxcdFxcdFxcdHRoaXMuX29yZGVyID0gZXVsZXIuX29yZGVyO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0RnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0sIG9yZGVyLCB1cGRhdGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGNsYW1wID0gX01hdGguY2xhbXA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdGUgPSBtLmVsZW1lbnRzO1xcclxcblxcdFxcdFxcdHZhciBtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdO1xcclxcblxcdFxcdFxcdHZhciBtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdO1xcclxcblxcdFxcdFxcdHZhciBtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRvcmRlciA9IG9yZGVyIHx8IHRoaXMuX29yZGVyO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggb3JkZXIgPT09ICdYWVonICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuX3kgPSBNYXRoLmFzaW4oIGNsYW1wKCBtMTMsIC0gMSwgMSApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBNYXRoLmFicyggbTEzICkgPCAwLjk5OTk5ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTMzICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMTEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0yMiApO1xcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3ogPSAwO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1lYWicgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5feCA9IE1hdGguYXNpbiggLSBjbGFtcCggbTIzLCAtIDEsIDEgKSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggTWF0aC5hYnMoIG0yMyApIDwgMC45OTk5OSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMjIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTExICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5feiA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWlhZJyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLl94ID0gTWF0aC5hc2luKCBjbGFtcCggbTMyLCAtIDEsIDEgKSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggTWF0aC5hYnMoIG0zMiApIDwgMC45OTk5OSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0zMyApO1xcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTIyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl95ID0gMDtcXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMTEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWVgnICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuX3kgPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0zMSwgLSAxLCAxICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIE1hdGguYWJzKCBtMzEgKSA8IDAuOTk5OTkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTMzICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl94ID0gMDtcXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0yMiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1laWCcgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5feiA9IE1hdGguYXNpbiggY2xhbXAoIG0yMSwgLSAxLCAxICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIE1hdGguYWJzKCBtMjEgKSA8IDAuOTk5OTkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMjIgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0xMSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5feCA9IDA7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTMzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWFpZJyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLl96ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMTIsIC0gMSwgMSApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBNYXRoLmFicyggbTEyICkgPCAwLjk5OTk5ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0yMiApO1xcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0xMSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMzMgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl95ID0gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5FdWxlcjogLnNldEZyb21Sb3RhdGlvbk1hdHJpeCgpIGdpdmVuIHVuc3VwcG9ydGVkIG9yZGVyOiAnICsgb3JkZXIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5fb3JkZXIgPSBvcmRlcjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHVwZGF0ZSAhPT0gZmFsc2UgKSB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldEZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHNldEZyb21RdWF0ZXJuaW9uKCBxLCBvcmRlciwgdXBkYXRlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdG1hdHJpeC5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiggcSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbWF0cml4LCBvcmRlciwgdXBkYXRlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR9KCksXFxyXFxuXFxyXFxuXFx0XFx0c2V0RnJvbVZlY3RvcjM6IGZ1bmN0aW9uICggdiwgb3JkZXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuc2V0KCB2LngsIHYueSwgdi56LCBvcmRlciB8fCB0aGlzLl9vcmRlciApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0cmVvcmRlcjogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdC8vIFdBUk5JTkc6IHRoaXMgZGlzY2FyZHMgcmV2b2x1dGlvbiBpbmZvcm1hdGlvbiAtYmhvdXN0b25cXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcSA9IG5ldyBRdWF0ZXJuaW9uKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHJlb3JkZXIoIG5ld09yZGVyICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHEuc2V0RnJvbUV1bGVyKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuc2V0RnJvbVF1YXRlcm5pb24oIHEsIG5ld09yZGVyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR9KCksXFxyXFxuXFxyXFxuXFx0XFx0ZXF1YWxzOiBmdW5jdGlvbiAoIGV1bGVyICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiAoIGV1bGVyLl94ID09PSB0aGlzLl94ICkgJiYgKCBldWxlci5feSA9PT0gdGhpcy5feSApICYmICggZXVsZXIuX3ogPT09IHRoaXMuX3ogKSAmJiAoIGV1bGVyLl9vcmRlciA9PT0gdGhpcy5fb3JkZXIgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLl94ID0gYXJyYXlbIDAgXTtcXHJcXG5cXHRcXHRcXHR0aGlzLl95ID0gYXJyYXlbIDEgXTtcXHJcXG5cXHRcXHRcXHR0aGlzLl96ID0gYXJyYXlbIDIgXTtcXHJcXG5cXHRcXHRcXHRpZiAoIGFycmF5WyAzIF0gIT09IHVuZGVmaW5lZCApIHRoaXMuX29yZGVyID0gYXJyYXlbIDMgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xcclxcblxcdFxcdFxcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xcclxcblxcclxcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMuX3g7XFxyXFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuX3k7XFxyXFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuX3o7XFxyXFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMuX29yZGVyO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBhcnJheTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHRvVmVjdG9yMzogZnVuY3Rpb24gKCBvcHRpb25hbFJlc3VsdCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIG9wdGlvbmFsUmVzdWx0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiBvcHRpb25hbFJlc3VsdC5zZXQoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3ogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiBuZXcgVmVjdG9yMyggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdG9uQ2hhbmdlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0b25DaGFuZ2VDYWxsYmFjazogZnVuY3Rpb24gKCkge31cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBMYXllcnMoKSB7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5tYXNrID0gMSB8IDA7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIExheWVycy5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uICggY2hhbm5lbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm1hc2sgPSAxIDw8IGNoYW5uZWwgfCAwO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0ZW5hYmxlOiBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5tYXNrIHw9IDEgPDwgY2hhbm5lbCB8IDA7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHR0b2dnbGU6IGZ1bmN0aW9uICggY2hhbm5lbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm1hc2sgXj0gMSA8PCBjaGFubmVsIHwgMDtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGRpc2FibGU6IGZ1bmN0aW9uICggY2hhbm5lbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm1hc2sgJj0gfiAoIDEgPDwgY2hhbm5lbCB8IDAgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHRlc3Q6IGZ1bmN0aW9uICggbGF5ZXJzICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiAoIHRoaXMubWFzayAmIGxheWVycy5tYXNrICkgIT09IDA7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXFxyXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXHJcXG5cXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcXHJcXG5cXHQgKiBAYXV0aG9yIGVsZXBoYW50YXR3b3JrIC8gd3d3LmVsZXBoYW50YXR3b3JrLmNoXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0dmFyIG9iamVjdDNESWQgPSAwO1xcclxcblxcclxcblxcdGZ1bmN0aW9uIE9iamVjdDNEKCkge1xcclxcblxcclxcblxcdFxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogb2JqZWN0M0RJZCArKyB9ICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy51dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5uYW1lID0gJyc7XFxyXFxuXFx0XFx0dGhpcy50eXBlID0gJ09iamVjdDNEJztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnBhcmVudCA9IG51bGw7XFxyXFxuXFx0XFx0dGhpcy5jaGlsZHJlbiA9IFtdO1xcclxcblxcclxcblxcdFxcdHRoaXMudXAgPSBPYmplY3QzRC5EZWZhdWx0VXAuY2xvbmUoKTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgcG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdHZhciByb3RhdGlvbiA9IG5ldyBFdWxlcigpO1xcclxcblxcdFxcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcXHJcXG5cXHRcXHR2YXIgc2NhbGUgPSBuZXcgVmVjdG9yMyggMSwgMSwgMSApO1xcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIG9uUm90YXRpb25DaGFuZ2UoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIHJvdGF0aW9uLCBmYWxzZSApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBvblF1YXRlcm5pb25DaGFuZ2UoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cm90YXRpb24uc2V0RnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24sIHVuZGVmaW5lZCwgZmFsc2UgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0cm90YXRpb24ub25DaGFuZ2UoIG9uUm90YXRpb25DaGFuZ2UgKTtcXHJcXG5cXHRcXHRxdWF0ZXJuaW9uLm9uQ2hhbmdlKCBvblF1YXRlcm5pb25DaGFuZ2UgKTtcXHJcXG5cXHJcXG5cXHRcXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xcclxcblxcdFxcdFxcdHBvc2l0aW9uOiB7XFxyXFxuXFx0XFx0XFx0XFx0ZW51bWVyYWJsZTogdHJ1ZSxcXHJcXG5cXHRcXHRcXHRcXHR2YWx1ZTogcG9zaXRpb25cXHJcXG5cXHRcXHRcXHR9LFxcclxcblxcdFxcdFxcdHJvdGF0aW9uOiB7XFxyXFxuXFx0XFx0XFx0XFx0ZW51bWVyYWJsZTogdHJ1ZSxcXHJcXG5cXHRcXHRcXHRcXHR2YWx1ZTogcm90YXRpb25cXHJcXG5cXHRcXHRcXHR9LFxcclxcblxcdFxcdFxcdHF1YXRlcm5pb246IHtcXHJcXG5cXHRcXHRcXHRcXHRlbnVtZXJhYmxlOiB0cnVlLFxcclxcblxcdFxcdFxcdFxcdHZhbHVlOiBxdWF0ZXJuaW9uXFxyXFxuXFx0XFx0XFx0fSxcXHJcXG5cXHRcXHRcXHRzY2FsZToge1xcclxcblxcdFxcdFxcdFxcdGVudW1lcmFibGU6IHRydWUsXFxyXFxuXFx0XFx0XFx0XFx0dmFsdWU6IHNjYWxlXFxyXFxuXFx0XFx0XFx0fSxcXHJcXG5cXHRcXHRcXHRtb2RlbFZpZXdNYXRyaXg6IHtcXHJcXG5cXHRcXHRcXHRcXHR2YWx1ZTogbmV3IE1hdHJpeDQoKVxcclxcblxcdFxcdFxcdH0sXFxyXFxuXFx0XFx0XFx0bm9ybWFsTWF0cml4OiB7XFxyXFxuXFx0XFx0XFx0XFx0dmFsdWU6IG5ldyBNYXRyaXgzKClcXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFx0XFx0fSApO1xcclxcblxcclxcblxcdFxcdHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcXHJcXG5cXHRcXHR0aGlzLm1hdHJpeFdvcmxkID0gbmV3IE1hdHJpeDQoKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBPYmplY3QzRC5EZWZhdWx0TWF0cml4QXV0b1VwZGF0ZTtcXHJcXG5cXHRcXHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBmYWxzZTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmxheWVycyA9IG5ldyBMYXllcnMoKTtcXHJcXG5cXHRcXHR0aGlzLnZpc2libGUgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdHRoaXMuY2FzdFNoYWRvdyA9IGZhbHNlO1xcclxcblxcdFxcdHRoaXMucmVjZWl2ZVNoYWRvdyA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHRydWU7XFxyXFxuXFx0XFx0dGhpcy5yZW5kZXJPcmRlciA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy51c2VyRGF0YSA9IHt9O1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRPYmplY3QzRC5EZWZhdWx0VXAgPSBuZXcgVmVjdG9yMyggMCwgMSwgMCApO1xcclxcblxcdE9iamVjdDNELkRlZmF1bHRNYXRyaXhBdXRvVXBkYXRlID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRPYmplY3QzRC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlICksIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zdHJ1Y3RvcjogT2JqZWN0M0QsXFxyXFxuXFxyXFxuXFx0XFx0aXNPYmplY3QzRDogdHJ1ZSxcXHJcXG5cXHJcXG5cXHRcXHRvbkJlZm9yZVJlbmRlcjogZnVuY3Rpb24gKCkge30sXFxyXFxuXFx0XFx0b25BZnRlclJlbmRlcjogZnVuY3Rpb24gKCkge30sXFxyXFxuXFxyXFxuXFx0XFx0YXBwbHlNYXRyaXg6IGZ1bmN0aW9uICggbWF0cml4ICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMubWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeCwgdGhpcy5tYXRyaXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm1hdHJpeC5kZWNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0YXBwbHlRdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5xdWF0ZXJuaW9uLnByZW11bHRpcGx5KCBxICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRSb3RhdGlvbkZyb21BeGlzQW5nbGU6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldFJvdGF0aW9uRnJvbUV1bGVyOiBmdW5jdGlvbiAoIGV1bGVyICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIGV1bGVyLCB0cnVlICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRSb3RhdGlvbkZyb21NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxcclxcblxcclxcblxcdFxcdFxcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG0gKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBhc3N1bWVzIHEgaXMgbm9ybWFsaXplZFxcclxcblxcclxcblxcdFxcdFxcdHRoaXMucXVhdGVybmlvbi5jb3B5KCBxICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRyb3RhdGVPbkF4aXM6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gb2JqZWN0IHNwYWNlXFxyXFxuXFx0XFx0XFx0Ly8gYXhpcyBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcTEgPSBuZXcgUXVhdGVybmlvbigpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiByb3RhdGVPbkF4aXMoIGF4aXMsIGFuZ2xlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHExLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5xdWF0ZXJuaW9uLm11bHRpcGx5KCBxMSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdHJvdGF0ZU9uV29ybGRBeGlzOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gcm90YXRlIG9iamVjdCBvbiBheGlzIGluIHdvcmxkIHNwYWNlXFxyXFxuXFx0XFx0XFx0Ly8gYXhpcyBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcXHJcXG5cXHRcXHRcXHQvLyBtZXRob2QgYXNzdW1lcyBubyByb3RhdGVkIHBhcmVudFxcclxcblxcclxcblxcdFxcdFxcdHZhciBxMSA9IG5ldyBRdWF0ZXJuaW9uKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZU9uV29ybGRBeGlzKCBheGlzLCBhbmdsZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRxMS5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMucXVhdGVybmlvbi5wcmVtdWx0aXBseSggcTEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0oKSxcXHJcXG5cXHJcXG5cXHRcXHRyb3RhdGVYOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoIDEsIDAsIDAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWCggYW5nbGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0oKSxcXHJcXG5cXHJcXG5cXHRcXHRyb3RhdGVZOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoIDAsIDEsIDAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWSggYW5nbGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0oKSxcXHJcXG5cXHJcXG5cXHRcXHRyb3RhdGVaOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoIDAsIDAsIDEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWiggYW5nbGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0oKSxcXHJcXG5cXHJcXG5cXHRcXHR0cmFuc2xhdGVPbkF4aXM6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyB0cmFuc2xhdGUgb2JqZWN0IGJ5IGRpc3RhbmNlIGFsb25nIGF4aXMgaW4gb2JqZWN0IHNwYWNlXFxyXFxuXFx0XFx0XFx0Ly8gYXhpcyBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiB0cmFuc2xhdGVPbkF4aXMoIGF4aXMsIGRpc3RhbmNlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHYxLmNvcHkoIGF4aXMgKS5hcHBseVF1YXRlcm5pb24oIHRoaXMucXVhdGVybmlvbiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMucG9zaXRpb24uYWRkKCB2MS5tdWx0aXBseVNjYWxhciggZGlzdGFuY2UgKSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdHRyYW5zbGF0ZVg6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMyggMSwgMCwgMCApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiB0cmFuc2xhdGVYKCBkaXN0YW5jZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIHYxLCBkaXN0YW5jZSApO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdHRyYW5zbGF0ZVk6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMyggMCwgMSwgMCApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiB0cmFuc2xhdGVZKCBkaXN0YW5jZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIHYxLCBkaXN0YW5jZSApO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdHRyYW5zbGF0ZVo6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMyggMCwgMCwgMSApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiB0cmFuc2xhdGVaKCBkaXN0YW5jZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIHYxLCBkaXN0YW5jZSApO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdGxvY2FsVG9Xb3JsZDogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHdvcmxkVG9Mb2NhbDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHdvcmxkVG9Mb2NhbCggdmVjdG9yICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtMS5nZXRJbnZlcnNlKCB0aGlzLm1hdHJpeFdvcmxkICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0oKSxcXHJcXG5cXHJcXG5cXHRcXHRsb29rQXQ6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IG9iamVjdHMgd2l0aCByb3RhdGVkIGFuZC9vciB0cmFuc2xhdGVkIHBhcmVudChzKVxcclxcblxcclxcblxcdFxcdFxcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XFxyXFxuXFx0XFx0XFx0dmFyIHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGxvb2tBdCggeCwgeSwgeiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHguaXNWZWN0b3IzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZlY3Rvci5jb3B5KCB4ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2ZWN0b3Iuc2V0KCB4LCB5LCB6ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggdGhpcy5pc0NhbWVyYSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRtMS5sb29rQXQoIHRoaXMucG9zaXRpb24sIHZlY3RvciwgdGhpcy51cCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0bTEubG9va0F0KCB2ZWN0b3IsIHRoaXMucG9zaXRpb24sIHRoaXMudXAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbTEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0oKSxcXHJcXG5cXHJcXG5cXHRcXHRhZGQ6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmFkZCggYXJndW1lbnRzWyBpIF0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggb2JqZWN0ID09PSB0aGlzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoIFxcXCJUSFJFRS5PYmplY3QzRC5hZGQ6IG9iamVjdCBjYW4ndCBiZSBhZGRlZCBhcyBhIGNoaWxkIG9mIGl0c2VsZi5cXFwiLCBvYmplY3QgKTtcXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCAoIG9iamVjdCAmJiBvYmplY3QuaXNPYmplY3QzRCApICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggb2JqZWN0LnBhcmVudCAhPT0gbnVsbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRvYmplY3QucGFyZW50LnJlbW92ZSggb2JqZWN0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdG9iamVjdC5wYXJlbnQgPSB0aGlzO1xcclxcblxcdFxcdFxcdFxcdG9iamVjdC5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdhZGRlZCcgfSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuY2hpbGRyZW4ucHVzaCggb2JqZWN0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCBcXFwiVEhSRUUuT2JqZWN0M0QuYWRkOiBvYmplY3Qgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLk9iamVjdDNELlxcXCIsIG9iamVjdCApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHJlbW92ZTogZnVuY3Rpb24gKCBvYmplY3QgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMucmVtb3ZlKCBhcmd1bWVudHNbIGkgXSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKCBvYmplY3QgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGluZGV4ICE9PSAtIDEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0b2JqZWN0LnBhcmVudCA9IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0b2JqZWN0LmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ3JlbW92ZWQnIH0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmNoaWxkcmVuLnNwbGljZSggaW5kZXgsIDEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRnZXRPYmplY3RCeUlkOiBmdW5jdGlvbiAoIGlkICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmdldE9iamVjdEJ5UHJvcGVydHkoICdpZCcsIGlkICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRnZXRPYmplY3RCeU5hbWU6IGZ1bmN0aW9uICggbmFtZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCAnbmFtZScsIG5hbWUgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGdldE9iamVjdEJ5UHJvcGVydHk6IGZ1bmN0aW9uICggbmFtZSwgdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzWyBuYW1lIF0gPT09IHZhbHVlICkgcmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bIGkgXTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgb2JqZWN0ID0gY2hpbGQuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBvYmplY3Q7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdW5kZWZpbmVkO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Z2V0V29ybGRQb3NpdGlvbjogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHJlc3VsdC5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGdldFdvcmxkUXVhdGVybmlvbjogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0XFx0dmFyIHNjYWxlID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gZ2V0V29ybGRRdWF0ZXJuaW9uKCBvcHRpb25hbFRhcmdldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFF1YXRlcm5pb24oKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHBvc2l0aW9uLCByZXN1bHQsIHNjYWxlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0oKSxcXHJcXG5cXHJcXG5cXHRcXHRnZXRXb3JsZFJvdGF0aW9uOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBnZXRXb3JsZFJvdGF0aW9uKCBvcHRpb25hbFRhcmdldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IEV1bGVyKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5nZXRXb3JsZFF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0LnNldEZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLCB0aGlzLnJvdGF0aW9uLm9yZGVyLCBmYWxzZSApO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdGdldFdvcmxkU2NhbGU6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdFxcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gZ2V0V29ybGRTY2FsZSggb3B0aW9uYWxUYXJnZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgcmVzdWx0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0oKSxcXHJcXG5cXHJcXG5cXHRcXHRnZXRXb3JsZERpcmVjdGlvbjogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gZ2V0V29ybGREaXJlY3Rpb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuZ2V0V29ybGRRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIDEgKS5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0oKSxcXHJcXG5cXHJcXG5cXHRcXHRyYXljYXN0OiBmdW5jdGlvbiAoKSB7fSxcXHJcXG5cXHJcXG5cXHRcXHR0cmF2ZXJzZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjYWxsYmFjayggdGhpcyApO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjaGlsZHJlblsgaSBdLnRyYXZlcnNlKCBjYWxsYmFjayApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHRyYXZlcnNlVmlzaWJsZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y2FsbGJhY2soIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y2hpbGRyZW5bIGkgXS50cmF2ZXJzZVZpc2libGUoIGNhbGxiYWNrICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0dHJhdmVyc2VBbmNlc3RvcnM6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xcclxcblxcclxcblxcdFxcdFxcdGlmICggcGFyZW50ICE9PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNhbGxiYWNrKCBwYXJlbnQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRwYXJlbnQudHJhdmVyc2VBbmNlc3RvcnMoIGNhbGxiYWNrICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0dXBkYXRlTWF0cml4OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5tYXRyaXguY29tcG9zZSggdGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCB0aGlzLnNjYWxlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHVwZGF0ZU1hdHJpeFdvcmxkOiBmdW5jdGlvbiAoIGZvcmNlICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5tYXRyaXhBdXRvVXBkYXRlICkgdGhpcy51cGRhdGVNYXRyaXgoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSB8fCBmb3JjZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHRoaXMucGFyZW50ID09PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMubWF0cml4V29ybGQuY29weSggdGhpcy5tYXRyaXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyggdGhpcy5wYXJlbnQubWF0cml4V29ybGQsIHRoaXMubWF0cml4ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvcmNlID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gdXBkYXRlIGNoaWxkcmVuXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNoaWxkcmVuWyBpIF0udXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0dG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gbWV0YSBpcyBhIHN0cmluZyB3aGVuIGNhbGxlZCBmcm9tIEpTT04uc3RyaW5naWZ5XFxyXFxuXFx0XFx0XFx0dmFyIGlzUm9vdE9iamVjdCA9ICggbWV0YSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBtZXRhID09PSAnc3RyaW5nJyApO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBvdXRwdXQgPSB7fTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBtZXRhIGlzIGEgaGFzaCB1c2VkIHRvIGNvbGxlY3QgZ2VvbWV0cmllcywgbWF0ZXJpYWxzLlxcclxcblxcdFxcdFxcdC8vIG5vdCBwcm92aWRpbmcgaXQgaW1wbGllcyB0aGF0IHRoaXMgaXMgdGhlIHJvb3Qgb2JqZWN0XFxyXFxuXFx0XFx0XFx0Ly8gYmVpbmcgc2VyaWFsaXplZC5cXHJcXG5cXHRcXHRcXHRpZiAoIGlzUm9vdE9iamVjdCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBpbml0aWFsaXplIG1ldGEgb2JqXFxyXFxuXFx0XFx0XFx0XFx0bWV0YSA9IHtcXHJcXG5cXHRcXHRcXHRcXHRcXHRnZW9tZXRyaWVzOiB7fSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRtYXRlcmlhbHM6IHt9LFxcclxcblxcdFxcdFxcdFxcdFxcdHRleHR1cmVzOiB7fSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRpbWFnZXM6IHt9LFxcclxcblxcdFxcdFxcdFxcdFxcdHNoYXBlczoge31cXHJcXG5cXHRcXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdFxcdFxcdG91dHB1dC5tZXRhZGF0YSA9IHtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2ZXJzaW9uOiA0LjUsXFxyXFxuXFx0XFx0XFx0XFx0XFx0dHlwZTogJ09iamVjdCcsXFxyXFxuXFx0XFx0XFx0XFx0XFx0Z2VuZXJhdG9yOiAnT2JqZWN0M0QudG9KU09OJ1xcclxcblxcdFxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdC8vIHN0YW5kYXJkIE9iamVjdDNEIHNlcmlhbGl6YXRpb25cXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgb2JqZWN0ID0ge307XFxyXFxuXFxyXFxuXFx0XFx0XFx0b2JqZWN0LnV1aWQgPSB0aGlzLnV1aWQ7XFxyXFxuXFx0XFx0XFx0b2JqZWN0LnR5cGUgPSB0aGlzLnR5cGU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLm5hbWUgIT09ICcnICkgb2JqZWN0Lm5hbWUgPSB0aGlzLm5hbWU7XFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmNhc3RTaGFkb3cgPT09IHRydWUgKSBvYmplY3QuY2FzdFNoYWRvdyA9IHRydWU7XFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLnJlY2VpdmVTaGFkb3cgPT09IHRydWUgKSBvYmplY3QucmVjZWl2ZVNoYWRvdyA9IHRydWU7XFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLnZpc2libGUgPT09IGZhbHNlICkgb2JqZWN0LnZpc2libGUgPSBmYWxzZTtcXHJcXG5cXHRcXHRcXHRpZiAoIEpTT04uc3RyaW5naWZ5KCB0aGlzLnVzZXJEYXRhICkgIT09ICd7fScgKSBvYmplY3QudXNlckRhdGEgPSB0aGlzLnVzZXJEYXRhO1xcclxcblxcclxcblxcdFxcdFxcdG9iamVjdC5tYXRyaXggPSB0aGlzLm1hdHJpeC50b0FycmF5KCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly9cXHJcXG5cXHJcXG5cXHRcXHRcXHRmdW5jdGlvbiBzZXJpYWxpemUoIGxpYnJhcnksIGVsZW1lbnQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBsaWJyYXJ5WyBlbGVtZW50LnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGxpYnJhcnlbIGVsZW1lbnQudXVpZCBdID0gZWxlbWVudC50b0pTT04oIG1ldGEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGVsZW1lbnQudXVpZDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmdlb21ldHJ5ICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0b2JqZWN0Lmdlb21ldHJ5ID0gc2VyaWFsaXplKCBtZXRhLmdlb21ldHJpZXMsIHRoaXMuZ2VvbWV0cnkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgcGFyYW1ldGVycyA9IHRoaXMuZ2VvbWV0cnkucGFyYW1ldGVycztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCAmJiBwYXJhbWV0ZXJzLnNoYXBlcyAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBzaGFwZXMgPSBwYXJhbWV0ZXJzLnNoYXBlcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIEFycmF5LmlzQXJyYXkoIHNoYXBlcyApICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBzaGFwZSA9IHNoYXBlc1sgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNlcmlhbGl6ZSggbWV0YS5zaGFwZXMsIHNoYXBlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0c2VyaWFsaXplKCBtZXRhLnNoYXBlcywgc2hhcGVzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLm1hdGVyaWFsICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBBcnJheS5pc0FycmF5KCB0aGlzLm1hdGVyaWFsICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHV1aWRzID0gW107XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5tYXRlcmlhbC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHV1aWRzLnB1c2goIHNlcmlhbGl6ZSggbWV0YS5tYXRlcmlhbHMsIHRoaXMubWF0ZXJpYWxbIGkgXSApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdG9iamVjdC5tYXRlcmlhbCA9IHV1aWRzO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0b2JqZWN0Lm1hdGVyaWFsID0gc2VyaWFsaXplKCBtZXRhLm1hdGVyaWFscywgdGhpcy5tYXRlcmlhbCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly9cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRvYmplY3QuY2hpbGRyZW4gPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRvYmplY3QuY2hpbGRyZW4ucHVzaCggdGhpcy5jaGlsZHJlblsgaSBdLnRvSlNPTiggbWV0YSApLm9iamVjdCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBpc1Jvb3RPYmplY3QgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGdlb21ldHJpZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLmdlb21ldHJpZXMgKTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgbWF0ZXJpYWxzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5tYXRlcmlhbHMgKTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgdGV4dHVyZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLnRleHR1cmVzICk7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGltYWdlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuaW1hZ2VzICk7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIHNoYXBlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuc2hhcGVzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBnZW9tZXRyaWVzLmxlbmd0aCA+IDAgKSBvdXRwdXQuZ2VvbWV0cmllcyA9IGdlb21ldHJpZXM7XFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBtYXRlcmlhbHMubGVuZ3RoID4gMCApIG91dHB1dC5tYXRlcmlhbHMgPSBtYXRlcmlhbHM7XFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB0ZXh0dXJlcy5sZW5ndGggPiAwICkgb3V0cHV0LnRleHR1cmVzID0gdGV4dHVyZXM7XFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBpbWFnZXMubGVuZ3RoID4gMCApIG91dHB1dC5pbWFnZXMgPSBpbWFnZXM7XFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBzaGFwZXMubGVuZ3RoID4gMCApIG91dHB1dC5zaGFwZXMgPSBzaGFwZXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdG91dHB1dC5vYmplY3QgPSBvYmplY3Q7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIG91dHB1dDtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBleHRyYWN0IGRhdGEgZnJvbSB0aGUgY2FjaGUgaGFzaFxcclxcblxcdFxcdFxcdC8vIHJlbW92ZSBtZXRhZGF0YSBvbiBlYWNoIGl0ZW1cXHJcXG5cXHRcXHRcXHQvLyBhbmQgcmV0dXJuIGFzIGFycmF5XFxyXFxuXFx0XFx0XFx0ZnVuY3Rpb24gZXh0cmFjdEZyb21DYWNoZSggY2FjaGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHZhbHVlcyA9IFtdO1xcclxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBrZXkgaW4gY2FjaGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGRhdGEgPSBjYWNoZVsga2V5IF07XFxyXFxuXFx0XFx0XFx0XFx0XFx0ZGVsZXRlIGRhdGEubWV0YWRhdGE7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFsdWVzLnB1c2goIGRhdGEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHZhbHVlcztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCByZWN1cnNpdmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcywgcmVjdXJzaXZlICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggcmVjdXJzaXZlID09PSB1bmRlZmluZWQgKSByZWN1cnNpdmUgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMudXAuY29weSggc291cmNlLnVwICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5wb3NpdGlvbi5jb3B5KCBzb3VyY2UucG9zaXRpb24gKTtcXHJcXG5cXHRcXHRcXHR0aGlzLnF1YXRlcm5pb24uY29weSggc291cmNlLnF1YXRlcm5pb24gKTtcXHJcXG5cXHRcXHRcXHR0aGlzLnNjYWxlLmNvcHkoIHNvdXJjZS5zY2FsZSApO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMubWF0cml4LmNvcHkoIHNvdXJjZS5tYXRyaXggKTtcXHJcXG5cXHRcXHRcXHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHNvdXJjZS5tYXRyaXhXb3JsZCApO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhBdXRvVXBkYXRlO1xcclxcblxcdFxcdFxcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMubGF5ZXJzLm1hc2sgPSBzb3VyY2UubGF5ZXJzLm1hc2s7XFxyXFxuXFx0XFx0XFx0dGhpcy52aXNpYmxlID0gc291cmNlLnZpc2libGU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5jYXN0U2hhZG93ID0gc291cmNlLmNhc3RTaGFkb3c7XFxyXFxuXFx0XFx0XFx0dGhpcy5yZWNlaXZlU2hhZG93ID0gc291cmNlLnJlY2VpdmVTaGFkb3c7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5mcnVzdHVtQ3VsbGVkID0gc291cmNlLmZydXN0dW1DdWxsZWQ7XFxyXFxuXFx0XFx0XFx0dGhpcy5yZW5kZXJPcmRlciA9IHNvdXJjZS5yZW5kZXJPcmRlcjtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnVzZXJEYXRhID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIHNvdXJjZS51c2VyRGF0YSApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCByZWN1cnNpdmUgPT09IHRydWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgc291cmNlLmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgY2hpbGQgPSBzb3VyY2UuY2hpbGRyZW5bIGkgXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmFkZCggY2hpbGQuY2xvbmUoKSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXFxyXFxuXFx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XFxyXFxuXFx0Ki9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBDYW1lcmEoKSB7XFxyXFxuXFxyXFxuXFx0XFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdDYW1lcmEnO1xcclxcblxcclxcblxcdFxcdHRoaXMubWF0cml4V29ybGRJbnZlcnNlID0gbmV3IE1hdHJpeDQoKTtcXHJcXG5cXHRcXHR0aGlzLnByb2plY3Rpb25NYXRyaXggPSBuZXcgTWF0cml4NCgpO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICksIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zdHJ1Y3RvcjogQ2FtZXJhLFxcclxcblxcclxcblxcdFxcdGlzQ2FtZXJhOiB0cnVlLFxcclxcblxcclxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlLCByZWN1cnNpdmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0T2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlLCByZWN1cnNpdmUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZS5jb3B5KCBzb3VyY2UubWF0cml4V29ybGRJbnZlcnNlICk7XFxyXFxuXFx0XFx0XFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIHNvdXJjZS5wcm9qZWN0aW9uTWF0cml4ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRnZXRXb3JsZERpcmVjdGlvbjogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gZ2V0V29ybGREaXJlY3Rpb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuZ2V0V29ybGRRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIC0gMSApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdHVwZGF0ZU1hdHJpeFdvcmxkOiBmdW5jdGlvbiAoIGZvcmNlICkge1xcclxcblxcclxcblxcdFxcdFxcdE9iamVjdDNELnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKCB0aGlzLCBmb3JjZSApO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMubWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXHJcXG5cXHQgKiBAYXV0aG9yIGFyb3NlIC8gaHR0cDovL2dpdGh1Yi5jb20vYXJvc2VcXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBPcnRob2dyYXBoaWNDYW1lcmEoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkge1xcclxcblxcclxcblxcdFxcdENhbWVyYS5jYWxsKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50eXBlID0gJ09ydGhvZ3JhcGhpY0NhbWVyYSc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy56b29tID0gMTtcXHJcXG5cXHRcXHR0aGlzLnZpZXcgPSBudWxsO1xcclxcblxcclxcblxcdFxcdHRoaXMubGVmdCA9IGxlZnQ7XFxyXFxuXFx0XFx0dGhpcy5yaWdodCA9IHJpZ2h0O1xcclxcblxcdFxcdHRoaXMudG9wID0gdG9wO1xcclxcblxcdFxcdHRoaXMuYm90dG9tID0gYm90dG9tO1xcclxcblxcclxcblxcdFxcdHRoaXMubmVhciA9ICggbmVhciAhPT0gdW5kZWZpbmVkICkgPyBuZWFyIDogMC4xO1xcclxcblxcdFxcdHRoaXMuZmFyID0gKCBmYXIgIT09IHVuZGVmaW5lZCApID8gZmFyIDogMjAwMDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0T3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIENhbWVyYS5wcm90b3R5cGUgKSwge1xcclxcblxcclxcblxcdFxcdGNvbnN0cnVjdG9yOiBPcnRob2dyYXBoaWNDYW1lcmEsXFxyXFxuXFxyXFxuXFx0XFx0aXNPcnRob2dyYXBoaWNDYW1lcmE6IHRydWUsXFxyXFxuXFxyXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRDYW1lcmEucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlLCByZWN1cnNpdmUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmxlZnQgPSBzb3VyY2UubGVmdDtcXHJcXG5cXHRcXHRcXHR0aGlzLnJpZ2h0ID0gc291cmNlLnJpZ2h0O1xcclxcblxcdFxcdFxcdHRoaXMudG9wID0gc291cmNlLnRvcDtcXHJcXG5cXHRcXHRcXHR0aGlzLmJvdHRvbSA9IHNvdXJjZS5ib3R0b207XFxyXFxuXFx0XFx0XFx0dGhpcy5uZWFyID0gc291cmNlLm5lYXI7XFxyXFxuXFx0XFx0XFx0dGhpcy5mYXIgPSBzb3VyY2UuZmFyO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuem9vbSA9IHNvdXJjZS56b29tO1xcclxcblxcdFxcdFxcdHRoaXMudmlldyA9IHNvdXJjZS52aWV3ID09PSBudWxsID8gbnVsbCA6IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UudmlldyApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0Vmlld09mZnNldDogZnVuY3Rpb24gKCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLnZpZXcgPT09IG51bGwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy52aWV3ID0ge1xcclxcblxcdFxcdFxcdFxcdFxcdGVuYWJsZWQ6IHRydWUsXFxyXFxuXFx0XFx0XFx0XFx0XFx0ZnVsbFdpZHRoOiAxLFxcclxcblxcdFxcdFxcdFxcdFxcdGZ1bGxIZWlnaHQ6IDEsXFxyXFxuXFx0XFx0XFx0XFx0XFx0b2Zmc2V0WDogMCxcXHJcXG5cXHRcXHRcXHRcXHRcXHRvZmZzZXRZOiAwLFxcclxcblxcdFxcdFxcdFxcdFxcdHdpZHRoOiAxLFxcclxcblxcdFxcdFxcdFxcdFxcdGhlaWdodDogMVxcclxcblxcdFxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHRoaXMudmlldy5lbmFibGVkID0gdHJ1ZTtcXHJcXG5cXHRcXHRcXHR0aGlzLnZpZXcuZnVsbFdpZHRoID0gZnVsbFdpZHRoO1xcclxcblxcdFxcdFxcdHRoaXMudmlldy5mdWxsSGVpZ2h0ID0gZnVsbEhlaWdodDtcXHJcXG5cXHRcXHRcXHR0aGlzLnZpZXcub2Zmc2V0WCA9IHg7XFxyXFxuXFx0XFx0XFx0dGhpcy52aWV3Lm9mZnNldFkgPSB5O1xcclxcblxcdFxcdFxcdHRoaXMudmlldy53aWR0aCA9IHdpZHRoO1xcclxcblxcdFxcdFxcdHRoaXMudmlldy5oZWlnaHQgPSBoZWlnaHQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjbGVhclZpZXdPZmZzZXQ6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMudmlldyAhPT0gbnVsbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnZpZXcuZW5hYmxlZCA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHVwZGF0ZVByb2plY3Rpb25NYXRyaXg6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgZHggPSAoIHRoaXMucmlnaHQgLSB0aGlzLmxlZnQgKSAvICggMiAqIHRoaXMuem9vbSApO1xcclxcblxcdFxcdFxcdHZhciBkeSA9ICggdGhpcy50b3AgLSB0aGlzLmJvdHRvbSApIC8gKCAyICogdGhpcy56b29tICk7XFxyXFxuXFx0XFx0XFx0dmFyIGN4ID0gKCB0aGlzLnJpZ2h0ICsgdGhpcy5sZWZ0ICkgLyAyO1xcclxcblxcdFxcdFxcdHZhciBjeSA9ICggdGhpcy50b3AgKyB0aGlzLmJvdHRvbSApIC8gMjtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbGVmdCA9IGN4IC0gZHg7XFxyXFxuXFx0XFx0XFx0dmFyIHJpZ2h0ID0gY3ggKyBkeDtcXHJcXG5cXHRcXHRcXHR2YXIgdG9wID0gY3kgKyBkeTtcXHJcXG5cXHRcXHRcXHR2YXIgYm90dG9tID0gY3kgLSBkeTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMudmlldyAhPT0gbnVsbCAmJiB0aGlzLnZpZXcuZW5hYmxlZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgem9vbVcgPSB0aGlzLnpvb20gLyAoIHRoaXMudmlldy53aWR0aCAvIHRoaXMudmlldy5mdWxsV2lkdGggKTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgem9vbUggPSB0aGlzLnpvb20gLyAoIHRoaXMudmlldy5oZWlnaHQgLyB0aGlzLnZpZXcuZnVsbEhlaWdodCApO1xcclxcblxcdFxcdFxcdFxcdHZhciBzY2FsZVcgPSAoIHRoaXMucmlnaHQgLSB0aGlzLmxlZnQgKSAvIHRoaXMudmlldy53aWR0aDtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgc2NhbGVIID0gKCB0aGlzLnRvcCAtIHRoaXMuYm90dG9tICkgLyB0aGlzLnZpZXcuaGVpZ2h0O1xcclxcblxcclxcblxcdFxcdFxcdFxcdGxlZnQgKz0gc2NhbGVXICogKCB0aGlzLnZpZXcub2Zmc2V0WCAvIHpvb21XICk7XFxyXFxuXFx0XFx0XFx0XFx0cmlnaHQgPSBsZWZ0ICsgc2NhbGVXICogKCB0aGlzLnZpZXcud2lkdGggLyB6b29tVyApO1xcclxcblxcdFxcdFxcdFxcdHRvcCAtPSBzY2FsZUggKiAoIHRoaXMudmlldy5vZmZzZXRZIC8gem9vbUggKTtcXHJcXG5cXHRcXHRcXHRcXHRib3R0b20gPSB0b3AgLSBzY2FsZUggKiAoIHRoaXMudmlldy5oZWlnaHQgLyB6b29tSCApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZU9ydGhvZ3JhcGhpYyggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCB0aGlzLm5lYXIsIHRoaXMuZmFyICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHR0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgZGF0YSA9IE9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xcclxcblxcclxcblxcdFxcdFxcdGRhdGEub2JqZWN0Lnpvb20gPSB0aGlzLnpvb207XFxyXFxuXFx0XFx0XFx0ZGF0YS5vYmplY3QubGVmdCA9IHRoaXMubGVmdDtcXHJcXG5cXHRcXHRcXHRkYXRhLm9iamVjdC5yaWdodCA9IHRoaXMucmlnaHQ7XFxyXFxuXFx0XFx0XFx0ZGF0YS5vYmplY3QudG9wID0gdGhpcy50b3A7XFxyXFxuXFx0XFx0XFx0ZGF0YS5vYmplY3QuYm90dG9tID0gdGhpcy5ib3R0b207XFxyXFxuXFx0XFx0XFx0ZGF0YS5vYmplY3QubmVhciA9IHRoaXMubmVhcjtcXHJcXG5cXHRcXHRcXHRkYXRhLm9iamVjdC5mYXIgPSB0aGlzLmZhcjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMudmlldyAhPT0gbnVsbCApIGRhdGEub2JqZWN0LnZpZXcgPSBPYmplY3QuYXNzaWduKCB7fSwgdGhpcy52aWV3ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGRhdGE7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gRmFjZTMoIGEsIGIsIGMsIG5vcm1hbCwgY29sb3IsIG1hdGVyaWFsSW5kZXggKSB7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5hID0gYTtcXHJcXG5cXHRcXHR0aGlzLmIgPSBiO1xcclxcblxcdFxcdHRoaXMuYyA9IGM7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5ub3JtYWwgPSAoIG5vcm1hbCAmJiBub3JtYWwuaXNWZWN0b3IzICkgPyBub3JtYWwgOiBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdHRoaXMudmVydGV4Tm9ybWFscyA9IEFycmF5LmlzQXJyYXkoIG5vcm1hbCApID8gbm9ybWFsIDogW107XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5jb2xvciA9ICggY29sb3IgJiYgY29sb3IuaXNDb2xvciApID8gY29sb3IgOiBuZXcgQ29sb3IoKTtcXHJcXG5cXHRcXHR0aGlzLnZlcnRleENvbG9ycyA9IEFycmF5LmlzQXJyYXkoIGNvbG9yICkgPyBjb2xvciA6IFtdO1xcclxcblxcclxcblxcdFxcdHRoaXMubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXggIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsSW5kZXggOiAwO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRPYmplY3QuYXNzaWduKCBGYWNlMy5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuYSA9IHNvdXJjZS5hO1xcclxcblxcdFxcdFxcdHRoaXMuYiA9IHNvdXJjZS5iO1xcclxcblxcdFxcdFxcdHRoaXMuYyA9IHNvdXJjZS5jO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMubm9ybWFsLmNvcHkoIHNvdXJjZS5ub3JtYWwgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMubWF0ZXJpYWxJbmRleCA9IHNvdXJjZS5tYXRlcmlhbEluZGV4O1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSBzb3VyY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnZlcnRleE5vcm1hbHNbIGkgXSA9IHNvdXJjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0uY2xvbmUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy52ZXJ0ZXhDb2xvcnNbIGkgXSA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnNbIGkgXS5jbG9uZSgpO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICogQGF1dGhvciBraWxlIC8gaHR0cDovL2tpbGUuc3RyYXZhZ2FuemEub3JnL1xcclxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxyXFxuXFx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cXHJcXG5cXHQgKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXFxyXFxuXFx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdHZhciBnZW9tZXRyeUlkID0gMDsgLy8gR2VvbWV0cnkgdXNlcyBldmVuIG51bWJlcnMgYXMgSWRcXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBHZW9tZXRyeSgpIHtcXHJcXG5cXHJcXG5cXHRcXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IGdlb21ldHJ5SWQgKz0gMiB9ICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy51dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5uYW1lID0gJyc7XFxyXFxuXFx0XFx0dGhpcy50eXBlID0gJ0dlb21ldHJ5JztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnZlcnRpY2VzID0gW107XFxyXFxuXFx0XFx0dGhpcy5jb2xvcnMgPSBbXTtcXHJcXG5cXHRcXHR0aGlzLmZhY2VzID0gW107XFxyXFxuXFx0XFx0dGhpcy5mYWNlVmVydGV4VXZzID0gW1tdXTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IFtdO1xcclxcblxcdFxcdHRoaXMubW9ycGhOb3JtYWxzID0gW107XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5za2luV2VpZ2h0cyA9IFtdO1xcclxcblxcdFxcdHRoaXMuc2tpbkluZGljZXMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmxpbmVEaXN0YW5jZXMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcXHJcXG5cXHRcXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcXHJcXG5cXHJcXG5cXHRcXHQvLyB1cGRhdGUgZmxhZ3NcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmVsZW1lbnRzTmVlZFVwZGF0ZSA9IGZhbHNlO1xcclxcblxcdFxcdHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XFxyXFxuXFx0XFx0dGhpcy51dnNOZWVkVXBkYXRlID0gZmFsc2U7XFxyXFxuXFx0XFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xcclxcblxcdFxcdHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xcclxcblxcdFxcdHRoaXMubGluZURpc3RhbmNlc05lZWRVcGRhdGUgPSBmYWxzZTtcXHJcXG5cXHRcXHR0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0R2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSApLCB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc3RydWN0b3I6IEdlb21ldHJ5LFxcclxcblxcclxcblxcdFxcdGlzR2VvbWV0cnk6IHRydWUsXFxyXFxuXFxyXFxuXFx0XFx0YXBwbHlNYXRyaXg6IGZ1bmN0aW9uICggbWF0cml4ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBub3JtYWxNYXRyaXggPSBuZXcgTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHZlcnRleCA9IHRoaXMudmVydGljZXNbIGkgXTtcXHJcXG5cXHRcXHRcXHRcXHR2ZXJ0ZXguYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGZhY2UgPSB0aGlzLmZhY2VzWyBpIF07XFxyXFxuXFx0XFx0XFx0XFx0ZmFjZS5ub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGZhY2UudmVydGV4Tm9ybWFsc1sgaiBdLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcXHJcXG5cXHRcXHRcXHR0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHJvdGF0ZVg6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHgtYXhpc1xcclxcblxcclxcblxcdFxcdFxcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVgoIGFuZ2xlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdG0xLm1ha2VSb3RhdGlvblgoIGFuZ2xlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0oKSxcXHJcXG5cXHJcXG5cXHRcXHRyb3RhdGVZOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB5LWF4aXNcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbTEgPSBuZXcgTWF0cml4NCgpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiByb3RhdGVZKCBhbmdsZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRtMS5tYWtlUm90YXRpb25ZKCBhbmdsZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR9KCksXFxyXFxuXFxyXFxuXFx0XFx0cm90YXRlWjogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgei1heGlzXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWiggYW5nbGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bTEubWFrZVJvdGF0aW9uWiggYW5nbGUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdC8vIHRyYW5zbGF0ZSBnZW9tZXRyeVxcclxcblxcclxcblxcdFxcdFxcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZSggeCwgeSwgeiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRtMS5tYWtlVHJhbnNsYXRpb24oIHgsIHksIHogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdHNjYWxlOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gc2NhbGUgZ2VvbWV0cnlcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbTEgPSBuZXcgTWF0cml4NCgpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBzY2FsZSggeCwgeSwgeiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRtMS5tYWtlU2NhbGUoIHgsIHksIHogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdGxvb2tBdDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBvYmogPSBuZXcgT2JqZWN0M0QoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gbG9va0F0KCB2ZWN0b3IgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0b2JqLmxvb2tBdCggdmVjdG9yICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0b2JqLnVwZGF0ZU1hdHJpeCgpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuYXBwbHlNYXRyaXgoIG9iai5tYXRyaXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0oKSxcXHJcXG5cXHJcXG5cXHRcXHRmcm9tQnVmZmVyR2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHNjb3BlID0gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgaW5kaWNlcyA9IGdlb21ldHJ5LmluZGV4ICE9PSBudWxsID8gZ2VvbWV0cnkuaW5kZXguYXJyYXkgOiB1bmRlZmluZWQ7XFxyXFxuXFx0XFx0XFx0dmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xcclxcblxcdFxcdFxcdHZhciBub3JtYWxzID0gYXR0cmlidXRlcy5ub3JtYWwgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5IDogdW5kZWZpbmVkO1xcclxcblxcdFxcdFxcdHZhciBjb2xvcnMgPSBhdHRyaWJ1dGVzLmNvbG9yICE9PSB1bmRlZmluZWQgPyBhdHRyaWJ1dGVzLmNvbG9yLmFycmF5IDogdW5kZWZpbmVkO1xcclxcblxcdFxcdFxcdHZhciB1dnMgPSBhdHRyaWJ1dGVzLnV2ICE9PSB1bmRlZmluZWQgPyBhdHRyaWJ1dGVzLnV2LmFycmF5IDogdW5kZWZpbmVkO1xcclxcblxcdFxcdFxcdHZhciB1dnMyID0gYXR0cmlidXRlcy51djIgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMudXYyLmFycmF5IDogdW5kZWZpbmVkO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdXZzMiAhPT0gdW5kZWZpbmVkICkgdGhpcy5mYWNlVmVydGV4VXZzWyAxIF0gPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdGVtcE5vcm1hbHMgPSBbXTtcXHJcXG5cXHRcXHRcXHR2YXIgdGVtcFVWcyA9IFtdO1xcclxcblxcdFxcdFxcdHZhciB0ZW1wVVZzMiA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaiA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoOyBpICs9IDMsIGogKz0gMiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzY29wZS52ZXJ0aWNlcy5wdXNoKCBuZXcgVmVjdG9yMyggcG9zaXRpb25zWyBpIF0sIHBvc2l0aW9uc1sgaSArIDEgXSwgcG9zaXRpb25zWyBpICsgMiBdICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIG5vcm1hbHMgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0ZW1wTm9ybWFscy5wdXNoKCBuZXcgVmVjdG9yMyggbm9ybWFsc1sgaSBdLCBub3JtYWxzWyBpICsgMSBdLCBub3JtYWxzWyBpICsgMiBdICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBjb2xvcnMgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRzY29wZS5jb2xvcnMucHVzaCggbmV3IENvbG9yKCBjb2xvcnNbIGkgXSwgY29sb3JzWyBpICsgMSBdLCBjb2xvcnNbIGkgKyAyIF0gKSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHV2cyAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHRlbXBVVnMucHVzaCggbmV3IFZlY3RvcjIoIHV2c1sgaiBdLCB1dnNbIGogKyAxIF0gKSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHV2czIgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0ZW1wVVZzMi5wdXNoKCBuZXcgVmVjdG9yMiggdXZzMlsgaiBdLCB1dnMyWyBqICsgMSBdICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGZ1bmN0aW9uIGFkZEZhY2UoIGEsIGIsIGMsIG1hdGVyaWFsSW5kZXggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHZlcnRleE5vcm1hbHMgPSBub3JtYWxzICE9PSB1bmRlZmluZWQgPyBbIHRlbXBOb3JtYWxzWyBhIF0uY2xvbmUoKSwgdGVtcE5vcm1hbHNbIGIgXS5jbG9uZSgpLCB0ZW1wTm9ybWFsc1sgYyBdLmNsb25lKCkgXSA6IFtdO1xcclxcblxcdFxcdFxcdFxcdHZhciB2ZXJ0ZXhDb2xvcnMgPSBjb2xvcnMgIT09IHVuZGVmaW5lZCA/IFsgc2NvcGUuY29sb3JzWyBhIF0uY2xvbmUoKSwgc2NvcGUuY29sb3JzWyBiIF0uY2xvbmUoKSwgc2NvcGUuY29sb3JzWyBjIF0uY2xvbmUoKSBdIDogW107XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGZhY2UgPSBuZXcgRmFjZTMoIGEsIGIsIGMsIHZlcnRleE5vcm1hbHMsIHZlcnRleENvbG9ycywgbWF0ZXJpYWxJbmRleCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHNjb3BlLmZhY2VzLnB1c2goIGZhY2UgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHV2cyAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHRlbXBVVnNbIGEgXS5jbG9uZSgpLCB0ZW1wVVZzWyBiIF0uY2xvbmUoKSwgdGVtcFVWc1sgYyBdLmNsb25lKCkgXSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHV2czIgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRzY29wZS5mYWNlVmVydGV4VXZzWyAxIF0ucHVzaCggWyB0ZW1wVVZzMlsgYSBdLmNsb25lKCksIHRlbXBVVnMyWyBiIF0uY2xvbmUoKSwgdGVtcFVWczJbIGMgXS5jbG9uZSgpIF0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHZhciBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBncm91cHMubGVuZ3RoID4gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBzdGFydCA9IGdyb3VwLnN0YXJ0O1xcclxcblxcdFxcdFxcdFxcdFxcdHZhciBjb3VudCA9IGdyb3VwLmNvdW50O1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBqID0gc3RhcnQsIGpsID0gc3RhcnQgKyBjb3VudDsgaiA8IGpsOyBqICs9IDMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBpbmRpY2VzICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YWRkRmFjZSggaW5kaWNlc1sgaiBdLCBpbmRpY2VzWyBqICsgMSBdLCBpbmRpY2VzWyBqICsgMiBdLCBncm91cC5tYXRlcmlhbEluZGV4ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRhZGRGYWNlKCBqLCBqICsgMSwgaiArIDIsIGdyb3VwLm1hdGVyaWFsSW5kZXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggaW5kaWNlcyAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpICs9IDMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0YWRkRmFjZSggaW5kaWNlc1sgaSBdLCBpbmRpY2VzWyBpICsgMSBdLCBpbmRpY2VzWyBpICsgMiBdICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aCAvIDM7IGkgKz0gMyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRhZGRGYWNlKCBpLCBpICsgMSwgaSArIDIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5ib3VuZGluZ0JveCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94LmNsb25lKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y2VudGVyOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgb2Zmc2V0ID0gdGhpcy5ib3VuZGluZ0JveC5nZXRDZW50ZXIoKS5uZWdhdGUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnRyYW5zbGF0ZSggb2Zmc2V0LngsIG9mZnNldC55LCBvZmZzZXQueiApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBvZmZzZXQ7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBjZW50ZXIgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcXHJcXG5cXHRcXHRcXHR2YXIgcmFkaXVzID0gdGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHMgPSByYWRpdXMgPT09IDAgPyAxIDogMS4wIC8gcmFkaXVzO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xcclxcblxcdFxcdFxcdG1hdHJpeC5zZXQoXFxyXFxuXFx0XFx0XFx0XFx0cywgMCwgMCwgLSBzICogY2VudGVyLngsXFxyXFxuXFx0XFx0XFx0XFx0MCwgcywgMCwgLSBzICogY2VudGVyLnksXFxyXFxuXFx0XFx0XFx0XFx0MCwgMCwgcywgLSBzICogY2VudGVyLnosXFxyXFxuXFx0XFx0XFx0XFx0MCwgMCwgMCwgMVxcclxcblxcdFxcdFxcdCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5hcHBseU1hdHJpeCggbWF0cml4ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjb21wdXRlRmFjZU5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgY2IgPSBuZXcgVmVjdG9yMygpLCBhYiA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHZBID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5hIF07XFxyXFxuXFx0XFx0XFx0XFx0dmFyIHZCID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5iIF07XFxyXFxuXFx0XFx0XFx0XFx0dmFyIHZDID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5jIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y2Iuc3ViVmVjdG9ycyggdkMsIHZCICk7XFxyXFxuXFx0XFx0XFx0XFx0YWIuc3ViVmVjdG9ycyggdkEsIHZCICk7XFxyXFxuXFx0XFx0XFx0XFx0Y2IuY3Jvc3MoIGFiICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y2Iubm9ybWFsaXplKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZmFjZS5ub3JtYWwuY29weSggY2IgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjb21wdXRlVmVydGV4Tm9ybWFsczogZnVuY3Rpb24gKCBhcmVhV2VpZ2h0ZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBhcmVhV2VpZ2h0ZWQgPT09IHVuZGVmaW5lZCApIGFyZWFXZWlnaHRlZCA9IHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHYsIHZsLCBmLCBmbCwgZmFjZSwgdmVydGljZXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmVydGljZXMgPSBuZXcgQXJyYXkoIHRoaXMudmVydGljZXMubGVuZ3RoICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdiA9IDAsIHZsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2ZXJ0aWNlc1sgdiBdID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBhcmVhV2VpZ2h0ZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gdmVydGV4IG5vcm1hbHMgd2VpZ2h0ZWQgYnkgdHJpYW5nbGUgYXJlYXNcXHJcXG5cXHRcXHRcXHRcXHQvLyBodHRwOi8vd3d3LmlxdWlsZXpsZXMub3JnL3d3dy9hcnRpY2xlcy9ub3JtYWxzL25vcm1hbHMuaHRtXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHZBLCB2QiwgdkM7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGNiID0gbmV3IFZlY3RvcjMoKSwgYWIgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2QSA9IHRoaXMudmVydGljZXNbIGZhY2UuYSBdO1xcclxcblxcdFxcdFxcdFxcdFxcdHZCID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5iIF07XFxyXFxuXFx0XFx0XFx0XFx0XFx0dkMgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmMgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRjYi5zdWJWZWN0b3JzKCB2QywgdkIgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRhYi5zdWJWZWN0b3JzKCB2QSwgdkIgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRjYi5jcm9zcyggYWIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0aWNlc1sgZmFjZS5hIF0uYWRkKCBjYiApO1xcclxcblxcdFxcdFxcdFxcdFxcdHZlcnRpY2VzWyBmYWNlLmIgXS5hZGQoIGNiICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmVydGljZXNbIGZhY2UuYyBdLmFkZCggY2IgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0aWNlc1sgZmFjZS5hIF0uYWRkKCBmYWNlLm5vcm1hbCApO1xcclxcblxcdFxcdFxcdFxcdFxcdHZlcnRpY2VzWyBmYWNlLmIgXS5hZGQoIGZhY2Uubm9ybWFsICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmVydGljZXNbIGZhY2UuYyBdLmFkZCggZmFjZS5ub3JtYWwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHYgPSAwLCB2bCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmVydGljZXNbIHYgXS5ub3JtYWxpemUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciB2ZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggdmVydGV4Tm9ybWFscy5sZW5ndGggPT09IDMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmVydGV4Tm9ybWFsc1sgMCBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmEgXSApO1xcclxcblxcdFxcdFxcdFxcdFxcdHZlcnRleE5vcm1hbHNbIDEgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5iIF0gKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0ZXhOb3JtYWxzWyAyIF0uY29weSggdmVydGljZXNbIGZhY2UuYyBdICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0ZXhOb3JtYWxzWyAwIF0gPSB2ZXJ0aWNlc1sgZmFjZS5hIF0uY2xvbmUoKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0ZXhOb3JtYWxzWyAxIF0gPSB2ZXJ0aWNlc1sgZmFjZS5iIF0uY2xvbmUoKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0ZXhOb3JtYWxzWyAyIF0gPSB2ZXJ0aWNlc1sgZmFjZS5jIF0uY2xvbmUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5mYWNlcy5sZW5ndGggPiAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNvbXB1dGVGbGF0VmVydGV4Tm9ybWFsczogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBmLCBmbCwgZmFjZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgdmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHZlcnRleE5vcm1hbHMubGVuZ3RoID09PSAzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZlcnRleE5vcm1hbHNbIDAgXS5jb3B5KCBmYWNlLm5vcm1hbCApO1xcclxcblxcdFxcdFxcdFxcdFxcdHZlcnRleE5vcm1hbHNbIDEgXS5jb3B5KCBmYWNlLm5vcm1hbCApO1xcclxcblxcdFxcdFxcdFxcdFxcdHZlcnRleE5vcm1hbHNbIDIgXS5jb3B5KCBmYWNlLm5vcm1hbCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmVydGV4Tm9ybWFsc1sgMCBdID0gZmFjZS5ub3JtYWwuY2xvbmUoKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0ZXhOb3JtYWxzWyAxIF0gPSBmYWNlLm5vcm1hbC5jbG9uZSgpO1xcclxcblxcdFxcdFxcdFxcdFxcdHZlcnRleE5vcm1hbHNbIDIgXSA9IGZhY2Uubm9ybWFsLmNsb25lKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMuZmFjZXMubGVuZ3RoID4gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjb21wdXRlTW9ycGhOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGksIGlsLCBmLCBmbCwgZmFjZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBzYXZlIG9yaWdpbmFsIG5vcm1hbHNcXHJcXG5cXHRcXHRcXHQvLyAtIGNyZWF0ZSB0ZW1wIHZhcmlhYmxlcyBvbiBmaXJzdCBhY2Nlc3NcXHJcXG5cXHRcXHRcXHQvLyAgIG90aGVyd2lzZSBqdXN0IGNvcHkgKGZvciBmYXN0ZXIgcmVwZWF0ZWQgY2FsbHMpXFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggISBmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGZhY2UuX19vcmlnaW5hbEZhY2VOb3JtYWwgPSBmYWNlLm5vcm1hbC5jbG9uZSgpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0ZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbC5jb3B5KCBmYWNlLm5vcm1hbCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoICEgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFscyApIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCBpID0gMCwgaWwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAhIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzWyBpIF0gPSBmYWNlLnZlcnRleE5vcm1hbHNbIGkgXS5jbG9uZSgpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFsc1sgaSBdLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgaSBdICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gdXNlIHRlbXAgZ2VvbWV0cnkgdG8gY29tcHV0ZSBmYWNlIGFuZCB2ZXJ0ZXggbm9ybWFscyBmb3IgZWFjaCBtb3JwaFxcclxcblxcclxcblxcdFxcdFxcdHZhciB0bXBHZW8gPSBuZXcgR2VvbWV0cnkoKTtcXHJcXG5cXHRcXHRcXHR0bXBHZW8uZmFjZXMgPSB0aGlzLmZhY2VzO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGNyZWF0ZSBvbiBmaXJzdCBhY2Nlc3NcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoICEgdGhpcy5tb3JwaE5vcm1hbHNbIGkgXSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLm1vcnBoTm9ybWFsc1sgaSBdID0ge307XFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5tb3JwaE5vcm1hbHNbIGkgXS5mYWNlTm9ybWFscyA9IFtdO1xcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMubW9ycGhOb3JtYWxzWyBpIF0udmVydGV4Tm9ybWFscyA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBkc3ROb3JtYWxzRmFjZSA9IHRoaXMubW9ycGhOb3JtYWxzWyBpIF0uZmFjZU5vcm1hbHM7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGRzdE5vcm1hbHNWZXJ0ZXggPSB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLnZlcnRleE5vcm1hbHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGZhY2VOb3JtYWwsIHZlcnRleE5vcm1hbHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRmYWNlTm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2ZXJ0ZXhOb3JtYWxzID0geyBhOiBuZXcgVmVjdG9yMygpLCBiOiBuZXcgVmVjdG9yMygpLCBjOiBuZXcgVmVjdG9yMygpIH07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZHN0Tm9ybWFsc0ZhY2UucHVzaCggZmFjZU5vcm1hbCApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGRzdE5vcm1hbHNWZXJ0ZXgucHVzaCggdmVydGV4Tm9ybWFscyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIG1vcnBoTm9ybWFscyA9IHRoaXMubW9ycGhOb3JtYWxzWyBpIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gc2V0IHZlcnRpY2VzIHRvIG1vcnBoIHRhcmdldFxcclxcblxcclxcblxcdFxcdFxcdFxcdHRtcEdlby52ZXJ0aWNlcyA9IHRoaXMubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gY29tcHV0ZSBtb3JwaCBub3JtYWxzXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dG1wR2VvLmNvbXB1dGVGYWNlTm9ybWFscygpO1xcclxcblxcdFxcdFxcdFxcdHRtcEdlby5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIHN0b3JlIG1vcnBoIG5vcm1hbHNcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgZmFjZU5vcm1hbCwgdmVydGV4Tm9ybWFscztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0ZmFjZU5vcm1hbCA9IG1vcnBoTm9ybWFscy5mYWNlTm9ybWFsc1sgZiBdO1xcclxcblxcdFxcdFxcdFxcdFxcdHZlcnRleE5vcm1hbHMgPSBtb3JwaE5vcm1hbHMudmVydGV4Tm9ybWFsc1sgZiBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGZhY2VOb3JtYWwuY29weSggZmFjZS5ub3JtYWwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0ZXhOb3JtYWxzLmEuY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyAwIF0gKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0ZXhOb3JtYWxzLmIuY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyAxIF0gKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0ZXhOb3JtYWxzLmMuY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyAyIF0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdC8vIHJlc3RvcmUgb3JpZ2luYWwgbm9ybWFsc1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmYWNlLm5vcm1hbCA9IGZhY2UuX19vcmlnaW5hbEZhY2VOb3JtYWw7XFxyXFxuXFx0XFx0XFx0XFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzID0gZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFscztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjb21wdXRlTGluZURpc3RhbmNlczogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBkID0gMDtcXHJcXG5cXHRcXHRcXHR2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGkgPiAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGQgKz0gdmVydGljZXNbIGkgXS5kaXN0YW5jZVRvKCB2ZXJ0aWNlc1sgaSAtIDEgXSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmxpbmVEaXN0YW5jZXNbIGkgXSA9IGQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y29tcHV0ZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ID09PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgQm94MygpO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmJvdW5kaW5nQm94LnNldEZyb21Qb2ludHMoIHRoaXMudmVydGljZXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNvbXB1dGVCb3VuZGluZ1NwaGVyZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSgpO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmJvdW5kaW5nU3BoZXJlLnNldEZyb21Qb2ludHMoIHRoaXMudmVydGljZXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdG1lcmdlOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRyaXgsIG1hdGVyaWFsSW5kZXhPZmZzZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCAhICggZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNHZW9tZXRyeSApICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5HZW9tZXRyeS5tZXJnZSgpOiBnZW9tZXRyeSBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuR2VvbWV0cnkuJywgZ2VvbWV0cnkgKTtcXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHZhciBub3JtYWxNYXRyaXgsXFxyXFxuXFx0XFx0XFx0XFx0dmVydGV4T2Zmc2V0ID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgsXFxyXFxuXFx0XFx0XFx0XFx0dmVydGljZXMxID0gdGhpcy52ZXJ0aWNlcyxcXHJcXG5cXHRcXHRcXHRcXHR2ZXJ0aWNlczIgPSBnZW9tZXRyeS52ZXJ0aWNlcyxcXHJcXG5cXHRcXHRcXHRcXHRmYWNlczEgPSB0aGlzLmZhY2VzLFxcclxcblxcdFxcdFxcdFxcdGZhY2VzMiA9IGdlb21ldHJ5LmZhY2VzLFxcclxcblxcdFxcdFxcdFxcdHV2czEgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXSxcXHJcXG5cXHRcXHRcXHRcXHR1dnMyID0gZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgMCBdLFxcclxcblxcdFxcdFxcdFxcdGNvbG9yczEgPSB0aGlzLmNvbG9ycyxcXHJcXG5cXHRcXHRcXHRcXHRjb2xvcnMyID0gZ2VvbWV0cnkuY29sb3JzO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWxJbmRleE9mZnNldCA9PT0gdW5kZWZpbmVkICkgbWF0ZXJpYWxJbmRleE9mZnNldCA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBtYXRyaXggIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRub3JtYWxNYXRyaXggPSBuZXcgTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdC8vIHZlcnRpY2VzXFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzMi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgdmVydGV4ID0gdmVydGljZXMyWyBpIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHZlcnRleENvcHkgPSB2ZXJ0ZXguY2xvbmUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIG1hdHJpeCAhPT0gdW5kZWZpbmVkICkgdmVydGV4Q29weS5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZlcnRpY2VzMS5wdXNoKCB2ZXJ0ZXhDb3B5ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdC8vIGNvbG9yc1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSBjb2xvcnMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbG9yczEucHVzaCggY29sb3JzMlsgaSBdLmNsb25lKCkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gZmFjZXNcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCBpID0gMCwgaWwgPSBmYWNlczIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGZhY2UgPSBmYWNlczJbIGkgXSwgZmFjZUNvcHksIG5vcm1hbCwgY29sb3IsXFxyXFxuXFx0XFx0XFx0XFx0XFx0ZmFjZVZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHMsXFxyXFxuXFx0XFx0XFx0XFx0XFx0ZmFjZVZlcnRleENvbG9ycyA9IGZhY2UudmVydGV4Q29sb3JzO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZhY2VDb3B5ID0gbmV3IEZhY2UzKCBmYWNlLmEgKyB2ZXJ0ZXhPZmZzZXQsIGZhY2UuYiArIHZlcnRleE9mZnNldCwgZmFjZS5jICsgdmVydGV4T2Zmc2V0ICk7XFxyXFxuXFx0XFx0XFx0XFx0ZmFjZUNvcHkubm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBub3JtYWxNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmYWNlQ29weS5ub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2VWZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdG5vcm1hbCA9IGZhY2VWZXJ0ZXhOb3JtYWxzWyBqIF0uY2xvbmUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG5vcm1hbE1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmYWNlQ29weS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmYWNlQ29weS5jb2xvci5jb3B5KCBmYWNlLmNvbG9yICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2VWZXJ0ZXhDb2xvcnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y29sb3IgPSBmYWNlVmVydGV4Q29sb3JzWyBqIF07XFxyXFxuXFx0XFx0XFx0XFx0XFx0ZmFjZUNvcHkudmVydGV4Q29sb3JzLnB1c2goIGNvbG9yLmNsb25lKCkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZmFjZUNvcHkubWF0ZXJpYWxJbmRleCA9IGZhY2UubWF0ZXJpYWxJbmRleCArIG1hdGVyaWFsSW5kZXhPZmZzZXQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZmFjZXMxLnB1c2goIGZhY2VDb3B5ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdC8vIHV2c1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIGkgPSAwLCBpbCA9IHV2czIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHV2ID0gdXZzMlsgaSBdLCB1dkNvcHkgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHV2ID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y29udGludWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBqID0gMCwgamwgPSB1di5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR1dkNvcHkucHVzaCggdXZbIGogXS5jbG9uZSgpICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHV2czEucHVzaCggdXZDb3B5ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0bWVyZ2VNZXNoOiBmdW5jdGlvbiAoIG1lc2ggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCAhICggbWVzaCAmJiBtZXNoLmlzTWVzaCApICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5HZW9tZXRyeS5tZXJnZU1lc2goKTogbWVzaCBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuTWVzaC4nLCBtZXNoICk7XFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRtZXNoLm1hdHJpeEF1dG9VcGRhdGUgJiYgbWVzaC51cGRhdGVNYXRyaXgoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm1lcmdlKCBtZXNoLmdlb21ldHJ5LCBtZXNoLm1hdHJpeCApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0LypcXHJcXG5cXHRcXHQgKiBDaGVja3MgZm9yIGR1cGxpY2F0ZSB2ZXJ0aWNlcyB3aXRoIGhhc2htYXAuXFxyXFxuXFx0XFx0ICogRHVwbGljYXRlZCB2ZXJ0aWNlcyBhcmUgcmVtb3ZlZFxcclxcblxcdFxcdCAqIGFuZCBmYWNlcycgdmVydGljZXMgYXJlIHVwZGF0ZWQuXFxyXFxuXFx0XFx0ICovXFxyXFxuXFxyXFxuXFx0XFx0bWVyZ2VWZXJ0aWNlczogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB2ZXJ0aWNlc01hcCA9IHt9OyAvLyBIYXNobWFwIGZvciBsb29raW5nIHVwIHZlcnRpY2VzIGJ5IHBvc2l0aW9uIGNvb3JkaW5hdGVzIChhbmQgbWFraW5nIHN1cmUgdGhleSBhcmUgdW5pcXVlKVxcclxcblxcdFxcdFxcdHZhciB1bmlxdWUgPSBbXSwgY2hhbmdlcyA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdHZhciB2LCBrZXk7XFxyXFxuXFx0XFx0XFx0dmFyIHByZWNpc2lvblBvaW50cyA9IDQ7IC8vIG51bWJlciBvZiBkZWNpbWFsIHBvaW50cywgZS5nLiA0IGZvciBlcHNpbG9uIG9mIDAuMDAwMVxcclxcblxcdFxcdFxcdHZhciBwcmVjaXNpb24gPSBNYXRoLnBvdyggMTAsIHByZWNpc2lvblBvaW50cyApO1xcclxcblxcdFxcdFxcdHZhciBpLCBpbCwgZmFjZTtcXHJcXG5cXHRcXHRcXHR2YXIgaW5kaWNlcywgaiwgamw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xcclxcblxcdFxcdFxcdFxcdGtleSA9IE1hdGgucm91bmQoIHYueCAqIHByZWNpc2lvbiApICsgJ18nICsgTWF0aC5yb3VuZCggdi55ICogcHJlY2lzaW9uICkgKyAnXycgKyBNYXRoLnJvdW5kKCB2LnogKiBwcmVjaXNpb24gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHZlcnRpY2VzTWFwWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZlcnRpY2VzTWFwWyBrZXkgXSA9IGk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dW5pcXVlLnB1c2goIHRoaXMudmVydGljZXNbIGkgXSApO1xcclxcblxcdFxcdFxcdFxcdFxcdGNoYW5nZXNbIGkgXSA9IHVuaXF1ZS5sZW5ndGggLSAxO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly9jb25zb2xlLmxvZygnRHVwbGljYXRlIHZlcnRleCBmb3VuZC4gJywgaSwgJyBjb3VsZCBiZSB1c2luZyAnLCB2ZXJ0aWNlc01hcFtrZXldKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRjaGFuZ2VzWyBpIF0gPSBjaGFuZ2VzWyB2ZXJ0aWNlc01hcFsga2V5IF0gXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcclxcblxcdFxcdFxcdC8vIGlmIGZhY2VzIGFyZSBjb21wbGV0ZWx5IGRlZ2VuZXJhdGUgYWZ0ZXIgbWVyZ2luZyB2ZXJ0aWNlcywgd2VcXHJcXG5cXHRcXHRcXHQvLyBoYXZlIHRvIHJlbW92ZSB0aGVtIGZyb20gdGhlIGdlb21ldHJ5LlxcclxcblxcdFxcdFxcdHZhciBmYWNlSW5kaWNlc1RvUmVtb3ZlID0gW107XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmYWNlID0gdGhpcy5mYWNlc1sgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZhY2UuYSA9IGNoYW5nZXNbIGZhY2UuYSBdO1xcclxcblxcdFxcdFxcdFxcdGZhY2UuYiA9IGNoYW5nZXNbIGZhY2UuYiBdO1xcclxcblxcdFxcdFxcdFxcdGZhY2UuYyA9IGNoYW5nZXNbIGZhY2UuYyBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGluZGljZXMgPSBbIGZhY2UuYSwgZmFjZS5iLCBmYWNlLmMgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBpZiBhbnkgZHVwbGljYXRlIHZlcnRpY2VzIGFyZSBmb3VuZCBpbiBhIEZhY2UzXFxyXFxuXFx0XFx0XFx0XFx0Ly8gd2UgaGF2ZSB0byByZW1vdmUgdGhlIGZhY2UgYXMgbm90aGluZyBjYW4gYmUgc2F2ZWRcXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgbiA9IDA7IG4gPCAzOyBuICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggaW5kaWNlc1sgbiBdID09PSBpbmRpY2VzWyAoIG4gKyAxICkgJSAzIF0gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmFjZUluZGljZXNUb1JlbW92ZS5wdXNoKCBpICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggaSA9IGZhY2VJbmRpY2VzVG9SZW1vdmUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC0tICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBpZHggPSBmYWNlSW5kaWNlc1RvUmVtb3ZlWyBpIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5mYWNlcy5zcGxpY2UoIGlkeCwgMSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIGogPSAwLCBqbCA9IHRoaXMuZmFjZVZlcnRleFV2cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIGogXS5zcGxpY2UoIGlkeCwgMSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gVXNlIHVuaXF1ZSBzZXQgb2YgdmVydGljZXNcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgZGlmZiA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gdW5pcXVlLmxlbmd0aDtcXHJcXG5cXHRcXHRcXHR0aGlzLnZlcnRpY2VzID0gdW5pcXVlO1xcclxcblxcdFxcdFxcdHJldHVybiBkaWZmO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0RnJvbVBvaW50czogZnVuY3Rpb24gKCBwb2ludHMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy52ZXJ0aWNlcyA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBwb2ludCA9IHBvaW50c1sgaSBdO1xcclxcblxcdFxcdFxcdFxcdHRoaXMudmVydGljZXMucHVzaCggbmV3IFZlY3RvcjMoIHBvaW50LngsIHBvaW50LnksIHBvaW50LnogfHwgMCApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c29ydEZhY2VzQnlNYXRlcmlhbEluZGV4OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGZhY2VzID0gdGhpcy5mYWNlcztcXHJcXG5cXHRcXHRcXHR2YXIgbGVuZ3RoID0gZmFjZXMubGVuZ3RoO1xcclxcblxcclxcblxcdFxcdFxcdC8vIHRhZyBmYWNlc1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmYWNlc1sgaSBdLl9pZCA9IGk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdC8vIHNvcnQgZmFjZXNcXHJcXG5cXHJcXG5cXHRcXHRcXHRmdW5jdGlvbiBtYXRlcmlhbEluZGV4U29ydCggYSwgYiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gYS5tYXRlcmlhbEluZGV4IC0gYi5tYXRlcmlhbEluZGV4O1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRmYWNlcy5zb3J0KCBtYXRlcmlhbEluZGV4U29ydCApO1xcclxcblxcclxcblxcdFxcdFxcdC8vIHNvcnQgdXZzXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHV2czEgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXTtcXHJcXG5cXHRcXHRcXHR2YXIgdXZzMiA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMSBdO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBuZXdVdnMxLCBuZXdVdnMyO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdXZzMSAmJiB1dnMxLmxlbmd0aCA9PT0gbGVuZ3RoICkgbmV3VXZzMSA9IFtdO1xcclxcblxcdFxcdFxcdGlmICggdXZzMiAmJiB1dnMyLmxlbmd0aCA9PT0gbGVuZ3RoICkgbmV3VXZzMiA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgaWQgPSBmYWNlc1sgaSBdLl9pZDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIG5ld1V2czEgKSBuZXdVdnMxLnB1c2goIHV2czFbIGlkIF0gKTtcXHJcXG5cXHRcXHRcXHRcXHRpZiAoIG5ld1V2czIgKSBuZXdVdnMyLnB1c2goIHV2czJbIGlkIF0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBuZXdVdnMxICkgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0gPSBuZXdVdnMxO1xcclxcblxcdFxcdFxcdGlmICggbmV3VXZzMiApIHRoaXMuZmFjZVZlcnRleFV2c1sgMSBdID0gbmV3VXZzMjtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHRvSlNPTjogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBkYXRhID0ge1xcclxcblxcdFxcdFxcdFxcdG1ldGFkYXRhOiB7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmVyc2lvbjogNC41LFxcclxcblxcdFxcdFxcdFxcdFxcdHR5cGU6ICdHZW9tZXRyeScsXFxyXFxuXFx0XFx0XFx0XFx0XFx0Z2VuZXJhdG9yOiAnR2VvbWV0cnkudG9KU09OJ1xcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdFxcdC8vIHN0YW5kYXJkIEdlb21ldHJ5IHNlcmlhbGl6YXRpb25cXHJcXG5cXHJcXG5cXHRcXHRcXHRkYXRhLnV1aWQgPSB0aGlzLnV1aWQ7XFxyXFxuXFx0XFx0XFx0ZGF0YS50eXBlID0gdGhpcy50eXBlO1xcclxcblxcdFxcdFxcdGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMucGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBrZXkgaW4gcGFyYW1ldGVycyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHBhcmFtZXRlcnNbIGtleSBdICE9PSB1bmRlZmluZWQgKSBkYXRhWyBrZXkgXSA9IHBhcmFtZXRlcnNbIGtleSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZGF0YTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHZlcnRpY2VzID0gW107XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHZlcnRleCA9IHRoaXMudmVydGljZXNbIGkgXTtcXHJcXG5cXHRcXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHZhciBmYWNlcyA9IFtdO1xcclxcblxcdFxcdFxcdHZhciBub3JtYWxzID0gW107XFxyXFxuXFx0XFx0XFx0dmFyIG5vcm1hbHNIYXNoID0ge307XFxyXFxuXFx0XFx0XFx0dmFyIGNvbG9ycyA9IFtdO1xcclxcblxcdFxcdFxcdHZhciBjb2xvcnNIYXNoID0ge307XFxyXFxuXFx0XFx0XFx0dmFyIHV2cyA9IFtdO1xcclxcblxcdFxcdFxcdHZhciB1dnNIYXNoID0ge307XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5mYWNlcy5sZW5ndGg7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGZhY2UgPSB0aGlzLmZhY2VzWyBpIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGhhc01hdGVyaWFsID0gdHJ1ZTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgaGFzRmFjZVV2ID0gZmFsc2U7IC8vIGRlcHJlY2F0ZWRcXHJcXG5cXHRcXHRcXHRcXHR2YXIgaGFzRmFjZVZlcnRleFV2ID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF1bIGkgXSAhPT0gdW5kZWZpbmVkO1xcclxcblxcdFxcdFxcdFxcdHZhciBoYXNGYWNlTm9ybWFsID0gZmFjZS5ub3JtYWwubGVuZ3RoKCkgPiAwO1xcclxcblxcdFxcdFxcdFxcdHZhciBoYXNGYWNlVmVydGV4Tm9ybWFsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA+IDA7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGhhc0ZhY2VDb2xvciA9IGZhY2UuY29sb3IuciAhPT0gMSB8fCBmYWNlLmNvbG9yLmcgIT09IDEgfHwgZmFjZS5jb2xvci5iICE9PSAxO1xcclxcblxcdFxcdFxcdFxcdHZhciBoYXNGYWNlVmVydGV4Q29sb3IgPSBmYWNlLnZlcnRleENvbG9ycy5sZW5ndGggPiAwO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBmYWNlVHlwZSA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAwLCAwICk7IC8vIGlzUXVhZFxcclxcblxcdFxcdFxcdFxcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgMSwgaGFzTWF0ZXJpYWwgKTtcXHJcXG5cXHRcXHRcXHRcXHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDIsIGhhc0ZhY2VVdiApO1xcclxcblxcdFxcdFxcdFxcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgMywgaGFzRmFjZVZlcnRleFV2ICk7XFxyXFxuXFx0XFx0XFx0XFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA0LCBoYXNGYWNlTm9ybWFsICk7XFxyXFxuXFx0XFx0XFx0XFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA1LCBoYXNGYWNlVmVydGV4Tm9ybWFsICk7XFxyXFxuXFx0XFx0XFx0XFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA2LCBoYXNGYWNlQ29sb3IgKTtcXHJcXG5cXHRcXHRcXHRcXHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDcsIGhhc0ZhY2VWZXJ0ZXhDb2xvciApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZhY2VzLnB1c2goIGZhY2VUeXBlICk7XFxyXFxuXFx0XFx0XFx0XFx0ZmFjZXMucHVzaCggZmFjZS5hLCBmYWNlLmIsIGZhY2UuYyApO1xcclxcblxcdFxcdFxcdFxcdGZhY2VzLnB1c2goIGZhY2UubWF0ZXJpYWxJbmRleCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggaGFzRmFjZVZlcnRleFV2ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBmYWNlVmVydGV4VXZzID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF1bIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmYWNlcy5wdXNoKFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGdldFV2SW5kZXgoIGZhY2VWZXJ0ZXhVdnNbIDAgXSApLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGdldFV2SW5kZXgoIGZhY2VWZXJ0ZXhVdnNbIDEgXSApLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGdldFV2SW5kZXgoIGZhY2VWZXJ0ZXhVdnNbIDIgXSApXFxyXFxuXFx0XFx0XFx0XFx0XFx0KTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBoYXNGYWNlTm9ybWFsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGZhY2VzLnB1c2goIGdldE5vcm1hbEluZGV4KCBmYWNlLm5vcm1hbCApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggaGFzRmFjZVZlcnRleE5vcm1hbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmYWNlcy5wdXNoKFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGdldE5vcm1hbEluZGV4KCB2ZXJ0ZXhOb3JtYWxzWyAwIF0gKSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRnZXROb3JtYWxJbmRleCggdmVydGV4Tm9ybWFsc1sgMSBdICksXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2V0Tm9ybWFsSW5kZXgoIHZlcnRleE5vcm1hbHNbIDIgXSApXFxyXFxuXFx0XFx0XFx0XFx0XFx0KTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBoYXNGYWNlQ29sb3IgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0ZmFjZXMucHVzaCggZ2V0Q29sb3JJbmRleCggZmFjZS5jb2xvciApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggaGFzRmFjZVZlcnRleENvbG9yICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciB2ZXJ0ZXhDb2xvcnMgPSBmYWNlLnZlcnRleENvbG9ycztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmYWNlcy5wdXNoKFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGdldENvbG9ySW5kZXgoIHZlcnRleENvbG9yc1sgMCBdICksXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2V0Q29sb3JJbmRleCggdmVydGV4Q29sb3JzWyAxIF0gKSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRnZXRDb2xvckluZGV4KCB2ZXJ0ZXhDb2xvcnNbIDIgXSApXFxyXFxuXFx0XFx0XFx0XFx0XFx0KTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGZ1bmN0aW9uIHNldEJpdCggdmFsdWUsIHBvc2l0aW9uLCBlbmFibGVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiBlbmFibGVkID8gdmFsdWUgfCAoIDEgPDwgcG9zaXRpb24gKSA6IHZhbHVlICYgKCB+ICggMSA8PCBwb3NpdGlvbiApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGZ1bmN0aW9uIGdldE5vcm1hbEluZGV4KCBub3JtYWwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGhhc2ggPSBub3JtYWwueC50b1N0cmluZygpICsgbm9ybWFsLnkudG9TdHJpbmcoKSArIG5vcm1hbC56LnRvU3RyaW5nKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBub3JtYWxzSGFzaFsgaGFzaCBdICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIG5vcm1hbHNIYXNoWyBoYXNoIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdG5vcm1hbHNIYXNoWyBoYXNoIF0gPSBub3JtYWxzLmxlbmd0aCAvIDM7XFxyXFxuXFx0XFx0XFx0XFx0bm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIG5vcm1hbHNIYXNoWyBoYXNoIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGZ1bmN0aW9uIGdldENvbG9ySW5kZXgoIGNvbG9yICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBoYXNoID0gY29sb3Iuci50b1N0cmluZygpICsgY29sb3IuZy50b1N0cmluZygpICsgY29sb3IuYi50b1N0cmluZygpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggY29sb3JzSGFzaFsgaGFzaCBdICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGNvbG9yc0hhc2hbIGhhc2ggXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29sb3JzSGFzaFsgaGFzaCBdID0gY29sb3JzLmxlbmd0aDtcXHJcXG5cXHRcXHRcXHRcXHRjb2xvcnMucHVzaCggY29sb3IuZ2V0SGV4KCkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gY29sb3JzSGFzaFsgaGFzaCBdO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRmdW5jdGlvbiBnZXRVdkluZGV4KCB1diApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgaGFzaCA9IHV2LngudG9TdHJpbmcoKSArIHV2LnkudG9TdHJpbmcoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHV2c0hhc2hbIGhhc2ggXSAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB1dnNIYXNoWyBoYXNoIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHV2c0hhc2hbIGhhc2ggXSA9IHV2cy5sZW5ndGggLyAyO1xcclxcblxcdFxcdFxcdFxcdHV2cy5wdXNoKCB1di54LCB1di55ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHV2c0hhc2hbIGhhc2ggXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZGF0YS5kYXRhID0ge307XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZGF0YS5kYXRhLnZlcnRpY2VzID0gdmVydGljZXM7XFxyXFxuXFx0XFx0XFx0ZGF0YS5kYXRhLm5vcm1hbHMgPSBub3JtYWxzO1xcclxcblxcdFxcdFxcdGlmICggY29sb3JzLmxlbmd0aCA+IDAgKSBkYXRhLmRhdGEuY29sb3JzID0gY29sb3JzO1xcclxcblxcdFxcdFxcdGlmICggdXZzLmxlbmd0aCA+IDAgKSBkYXRhLmRhdGEudXZzID0gWyB1dnMgXTsgLy8gdGVtcG9yYWwgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxcclxcblxcdFxcdFxcdGRhdGEuZGF0YS5mYWNlcyA9IGZhY2VzO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBkYXRhO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvKlxcclxcblxcdFxcdFxcdCAvLyBIYW5kbGUgcHJpbWl0aXZlc1xcclxcblxcclxcblxcdFxcdFxcdCB2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcXHJcXG5cXHJcXG5cXHRcXHRcXHQgaWYgKCBwYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0IHZhciB2YWx1ZXMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQgZm9yICggdmFyIGtleSBpbiBwYXJhbWV0ZXJzICkge1xcclxcblxcclxcblxcdFxcdFxcdCB2YWx1ZXMucHVzaCggcGFyYW1ldGVyc1sga2V5IF0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQgfVxcclxcblxcclxcblxcdFxcdFxcdCB2YXIgZ2VvbWV0cnkgPSBPYmplY3QuY3JlYXRlKCB0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSApO1xcclxcblxcdFxcdFxcdCB0aGlzLmNvbnN0cnVjdG9yLmFwcGx5KCBnZW9tZXRyeSwgdmFsdWVzICk7XFxyXFxuXFx0XFx0XFx0IHJldHVybiBnZW9tZXRyeTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQgfVxcclxcblxcclxcblxcdFxcdFxcdCByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XFxyXFxuXFx0XFx0XFx0ICovXFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyBHZW9tZXRyeSgpLmNvcHkoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBpLCBpbCwgaiwgamwsIGssIGtsO1xcclxcblxcclxcblxcdFxcdFxcdC8vIHJlc2V0XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy52ZXJ0aWNlcyA9IFtdO1xcclxcblxcdFxcdFxcdHRoaXMuY29sb3JzID0gW107XFxyXFxuXFx0XFx0XFx0dGhpcy5mYWNlcyA9IFtdO1xcclxcblxcdFxcdFxcdHRoaXMuZmFjZVZlcnRleFV2cyA9IFtbXV07XFxyXFxuXFx0XFx0XFx0dGhpcy5tb3JwaFRhcmdldHMgPSBbXTtcXHJcXG5cXHRcXHRcXHR0aGlzLm1vcnBoTm9ybWFscyA9IFtdO1xcclxcblxcdFxcdFxcdHRoaXMuc2tpbldlaWdodHMgPSBbXTtcXHJcXG5cXHRcXHRcXHR0aGlzLnNraW5JbmRpY2VzID0gW107XFxyXFxuXFx0XFx0XFx0dGhpcy5saW5lRGlzdGFuY2VzID0gW107XFxyXFxuXFx0XFx0XFx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XFxyXFxuXFx0XFx0XFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gbmFtZVxcclxcblxcclxcblxcdFxcdFxcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xcclxcblxcclxcblxcdFxcdFxcdC8vIHZlcnRpY2VzXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHZlcnRpY2VzID0gc291cmNlLnZlcnRpY2VzO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIGkgPSAwLCBpbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMudmVydGljZXMucHVzaCggdmVydGljZXNbIGkgXS5jbG9uZSgpICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdC8vIGNvbG9yc1xcclxcblxcclxcblxcdFxcdFxcdHZhciBjb2xvcnMgPSBzb3VyY2UuY29sb3JzO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIGkgPSAwLCBpbCA9IGNvbG9ycy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmNvbG9ycy5wdXNoKCBjb2xvcnNbIGkgXS5jbG9uZSgpICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdC8vIGZhY2VzXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGZhY2VzID0gc291cmNlLmZhY2VzO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIGkgPSAwLCBpbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuZmFjZXMucHVzaCggZmFjZXNbIGkgXS5jbG9uZSgpICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdC8vIGZhY2UgdmVydGV4IHV2c1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIGkgPSAwLCBpbCA9IHNvdXJjZS5mYWNlVmVydGV4VXZzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBmYWNlVmVydGV4VXZzID0gc291cmNlLmZhY2VWZXJ0ZXhVdnNbIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHRoaXMuZmFjZVZlcnRleFV2c1sgaSBdID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5mYWNlVmVydGV4VXZzWyBpIF0gPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggaiA9IDAsIGpsID0gZmFjZVZlcnRleFV2cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdXZzID0gZmFjZVZlcnRleFV2c1sgaiBdLCB1dnNDb3B5ID0gW107XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggayA9IDAsIGtsID0gdXZzLmxlbmd0aDsgayA8IGtsOyBrICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciB1diA9IHV2c1sgayBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHV2c0NvcHkucHVzaCggdXYuY2xvbmUoKSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIGkgXS5wdXNoKCB1dnNDb3B5ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBtb3JwaCB0YXJnZXRzXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggaSA9IDAsIGlsID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBtb3JwaFRhcmdldCA9IHt9O1xcclxcblxcdFxcdFxcdFxcdG1vcnBoVGFyZ2V0Lm5hbWUgPSBtb3JwaFRhcmdldHNbIGkgXS5uYW1lO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIHZlcnRpY2VzXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBtb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcyAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdG1vcnBoVGFyZ2V0LnZlcnRpY2VzID0gW107XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggaiA9IDAsIGpsID0gbW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0bW9ycGhUYXJnZXQudmVydGljZXMucHVzaCggbW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXNbIGogXS5jbG9uZSgpICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBub3JtYWxzXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBtb3JwaFRhcmdldHNbIGkgXS5ub3JtYWxzICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0bW9ycGhUYXJnZXQubm9ybWFscyA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGZvciAoIGogPSAwLCBqbCA9IG1vcnBoVGFyZ2V0c1sgaSBdLm5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0bW9ycGhUYXJnZXQubm9ybWFscy5wdXNoKCBtb3JwaFRhcmdldHNbIGkgXS5ub3JtYWxzWyBqIF0uY2xvbmUoKSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5tb3JwaFRhcmdldHMucHVzaCggbW9ycGhUYXJnZXQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gbW9ycGggbm9ybWFsc1xcclxcblxcclxcblxcdFxcdFxcdHZhciBtb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIGkgPSAwLCBpbCA9IG1vcnBoTm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgbW9ycGhOb3JtYWwgPSB7fTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyB2ZXJ0ZXggbm9ybWFsc1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggbW9ycGhOb3JtYWxzWyBpIF0udmVydGV4Tm9ybWFscyAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdG1vcnBoTm9ybWFsLnZlcnRleE5vcm1hbHMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCBqID0gMCwgamwgPSBtb3JwaE5vcm1hbHNbIGkgXS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBzcmNWZXJ0ZXhOb3JtYWwgPSBtb3JwaE5vcm1hbHNbIGkgXS52ZXJ0ZXhOb3JtYWxzWyBqIF07XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGRlc3RWZXJ0ZXhOb3JtYWwgPSB7fTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRkZXN0VmVydGV4Tm9ybWFsLmEgPSBzcmNWZXJ0ZXhOb3JtYWwuYS5jbG9uZSgpO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGRlc3RWZXJ0ZXhOb3JtYWwuYiA9IHNyY1ZlcnRleE5vcm1hbC5iLmNsb25lKCk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGVzdFZlcnRleE5vcm1hbC5jID0gc3JjVmVydGV4Tm9ybWFsLmMuY2xvbmUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRtb3JwaE5vcm1hbC52ZXJ0ZXhOb3JtYWxzLnB1c2goIGRlc3RWZXJ0ZXhOb3JtYWwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGZhY2Ugbm9ybWFsc1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggbW9ycGhOb3JtYWxzWyBpIF0uZmFjZU5vcm1hbHMgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRtb3JwaE5vcm1hbC5mYWNlTm9ybWFscyA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGZvciAoIGogPSAwLCBqbCA9IG1vcnBoTm9ybWFsc1sgaSBdLmZhY2VOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdG1vcnBoTm9ybWFsLmZhY2VOb3JtYWxzLnB1c2goIG1vcnBoTm9ybWFsc1sgaSBdLmZhY2VOb3JtYWxzWyBqIF0uY2xvbmUoKSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5tb3JwaE5vcm1hbHMucHVzaCggbW9ycGhOb3JtYWwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gc2tpbiB3ZWlnaHRzXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHNraW5XZWlnaHRzID0gc291cmNlLnNraW5XZWlnaHRzO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIGkgPSAwLCBpbCA9IHNraW5XZWlnaHRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuc2tpbldlaWdodHMucHVzaCggc2tpbldlaWdodHNbIGkgXS5jbG9uZSgpICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdC8vIHNraW4gaW5kaWNlc1xcclxcblxcclxcblxcdFxcdFxcdHZhciBza2luSW5kaWNlcyA9IHNvdXJjZS5za2luSW5kaWNlcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCBpID0gMCwgaWwgPSBza2luSW5kaWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnNraW5JbmRpY2VzLnB1c2goIHNraW5JbmRpY2VzWyBpIF0uY2xvbmUoKSApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBsaW5lIGRpc3RhbmNlc1xcclxcblxcclxcblxcdFxcdFxcdHZhciBsaW5lRGlzdGFuY2VzID0gc291cmNlLmxpbmVEaXN0YW5jZXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggaSA9IDAsIGlsID0gbGluZURpc3RhbmNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmxpbmVEaXN0YW5jZXMucHVzaCggbGluZURpc3RhbmNlc1sgaSBdICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdC8vIGJvdW5kaW5nIGJveFxcclxcblxcclxcblxcdFxcdFxcdHZhciBib3VuZGluZ0JveCA9IHNvdXJjZS5ib3VuZGluZ0JveDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGJvdW5kaW5nQm94ICE9PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuYm91bmRpbmdCb3ggPSBib3VuZGluZ0JveC5jbG9uZSgpO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBib3VuZGluZyBzcGhlcmVcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgYm91bmRpbmdTcGhlcmUgPSBzb3VyY2UuYm91bmRpbmdTcGhlcmU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gdXBkYXRlIGZsYWdzXFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50c05lZWRVcGRhdGUgPSBzb3VyY2UuZWxlbWVudHNOZWVkVXBkYXRlO1xcclxcblxcdFxcdFxcdHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gc291cmNlLnZlcnRpY2VzTmVlZFVwZGF0ZTtcXHJcXG5cXHRcXHRcXHR0aGlzLnV2c05lZWRVcGRhdGUgPSBzb3VyY2UudXZzTmVlZFVwZGF0ZTtcXHJcXG5cXHRcXHRcXHR0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gc291cmNlLm5vcm1hbHNOZWVkVXBkYXRlO1xcclxcblxcdFxcdFxcdHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IHNvdXJjZS5jb2xvcnNOZWVkVXBkYXRlO1xcclxcblxcdFxcdFxcdHRoaXMubGluZURpc3RhbmNlc05lZWRVcGRhdGUgPSBzb3VyY2UubGluZURpc3RhbmNlc05lZWRVcGRhdGU7XFxyXFxuXFx0XFx0XFx0dGhpcy5ncm91cHNOZWVkVXBkYXRlID0gc291cmNlLmdyb3Vwc05lZWRVcGRhdGU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xcclxcblxcclxcblxcdFxcdGlmICggQXJyYXkuaXNBcnJheSggYXJyYXkgKSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlOiBhcnJheSBzaG91bGQgYmUgYSBUeXBlZCBBcnJheS4nICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHRoaXMudXVpZCA9IF9NYXRoLmdlbmVyYXRlVVVJRCgpO1xcclxcblxcdFxcdHRoaXMubmFtZSA9ICcnO1xcclxcblxcclxcblxcdFxcdHRoaXMuYXJyYXkgPSBhcnJheTtcXHJcXG5cXHRcXHR0aGlzLml0ZW1TaXplID0gaXRlbVNpemU7XFxyXFxuXFx0XFx0dGhpcy5jb3VudCA9IGFycmF5ICE9PSB1bmRlZmluZWQgPyBhcnJheS5sZW5ndGggLyBpdGVtU2l6ZSA6IDA7XFxyXFxuXFx0XFx0dGhpcy5ub3JtYWxpemVkID0gbm9ybWFsaXplZCA9PT0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmR5bmFtaWMgPSBmYWxzZTtcXHJcXG5cXHRcXHR0aGlzLnVwZGF0ZVJhbmdlID0geyBvZmZzZXQ6IDAsIGNvdW50OiAtIDEgfTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm9uVXBsb2FkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnZlcnNpb24gPSAwO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUsICduZWVkc1VwZGF0ZScsIHtcXHJcXG5cXHJcXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudmVyc2lvbiArKztcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHRpc0J1ZmZlckF0dHJpYnV0ZTogdHJ1ZSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRBcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIEFycmF5LmlzQXJyYXkoIGFycmF5ICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogYXJyYXkgc2hvdWxkIGJlIGEgVHlwZWQgQXJyYXkuJyApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmNvdW50ID0gYXJyYXkgIT09IHVuZGVmaW5lZCA/IGFycmF5Lmxlbmd0aCAvIHRoaXMuaXRlbVNpemUgOiAwO1xcclxcblxcdFxcdFxcdHRoaXMuYXJyYXkgPSBhcnJheTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldER5bmFtaWM6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5keW5hbWljID0gdmFsdWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmFycmF5ID0gbmV3IHNvdXJjZS5hcnJheS5jb25zdHJ1Y3Rvciggc291cmNlLmFycmF5ICk7XFxyXFxuXFx0XFx0XFx0dGhpcy5pdGVtU2l6ZSA9IHNvdXJjZS5pdGVtU2l6ZTtcXHJcXG5cXHRcXHRcXHR0aGlzLmNvdW50ID0gc291cmNlLmNvdW50O1xcclxcblxcdFxcdFxcdHRoaXMubm9ybWFsaXplZCA9IHNvdXJjZS5ub3JtYWxpemVkO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuZHluYW1pYyA9IHNvdXJjZS5keW5hbWljO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y29weUF0OiBmdW5jdGlvbiAoIGluZGV4MSwgYXR0cmlidXRlLCBpbmRleDIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aW5kZXgxICo9IHRoaXMuaXRlbVNpemU7XFxyXFxuXFx0XFx0XFx0aW5kZXgyICo9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLml0ZW1TaXplOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmFycmF5WyBpbmRleDEgKyBpIF0gPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4MiArIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjb3B5QXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5hcnJheS5zZXQoIGFycmF5ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjb3B5Q29sb3JzQXJyYXk6IGZ1bmN0aW9uICggY29sb3JzICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY29sb3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGNvbG9yID0gY29sb3JzWyBpIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5Q29sb3JzQXJyYXkoKTogY29sb3IgaXMgdW5kZWZpbmVkJywgaSApO1xcclxcblxcdFxcdFxcdFxcdFxcdGNvbG9yID0gbmV3IENvbG9yKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKysgXSA9IGNvbG9yLnI7XFxyXFxuXFx0XFx0XFx0XFx0YXJyYXlbIG9mZnNldCArKyBdID0gY29sb3IuZztcXHJcXG5cXHRcXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBjb2xvci5iO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNvcHlJbmRpY2VzQXJyYXk6IGZ1bmN0aW9uICggaW5kaWNlcyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgYXJyYXkgPSB0aGlzLmFycmF5LCBvZmZzZXQgPSAwO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgaW5kZXggPSBpbmRpY2VzWyBpIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YXJyYXlbIG9mZnNldCArKyBdID0gaW5kZXguYTtcXHJcXG5cXHRcXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBpbmRleC5iO1xcclxcblxcdFxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKysgXSA9IGluZGV4LmM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y29weVZlY3RvcjJzQXJyYXk6IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgYXJyYXkgPSB0aGlzLmFycmF5LCBvZmZzZXQgPSAwO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHZlY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgdmVjdG9yID0gdmVjdG9yc1sgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggdmVjdG9yID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3Iyc0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBpICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmVjdG9yID0gbmV3IFZlY3RvcjIoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLng7XFxyXFxuXFx0XFx0XFx0XFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLnk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y29weVZlY3RvcjNzQXJyYXk6IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgYXJyYXkgPSB0aGlzLmFycmF5LCBvZmZzZXQgPSAwO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHZlY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgdmVjdG9yID0gdmVjdG9yc1sgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggdmVjdG9yID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBpICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLng7XFxyXFxuXFx0XFx0XFx0XFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLnk7XFxyXFxuXFx0XFx0XFx0XFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLno7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y29weVZlY3RvcjRzQXJyYXk6IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgYXJyYXkgPSB0aGlzLmFycmF5LCBvZmZzZXQgPSAwO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHZlY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgdmVjdG9yID0gdmVjdG9yc1sgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggdmVjdG9yID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3I0c0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBpICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmVjdG9yID0gbmV3IFZlY3RvcjQoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLng7XFxyXFxuXFx0XFx0XFx0XFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLnk7XFxyXFxuXFx0XFx0XFx0XFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLno7XFxyXFxuXFx0XFx0XFx0XFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLnc7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlLCBvZmZzZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5hcnJheS5zZXQoIHZhbHVlLCBvZmZzZXQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGdldFg6IGZ1bmN0aW9uICggaW5kZXggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSBdO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0WDogZnVuY3Rpb24gKCBpbmRleCwgeCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgXSA9IHg7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRnZXRZOiBmdW5jdGlvbiAoIGluZGV4ICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAxIF07XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRZOiBmdW5jdGlvbiAoIGluZGV4LCB5ICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXSA9IHk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRnZXRaOiBmdW5jdGlvbiAoIGluZGV4ICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAyIF07XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRaOiBmdW5jdGlvbiAoIGluZGV4LCB6ICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDIgXSA9IHo7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRnZXRXOiBmdW5jdGlvbiAoIGluZGV4ICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAzIF07XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRXOiBmdW5jdGlvbiAoIGluZGV4LCB3ICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDMgXSA9IHc7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRYWTogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcXHJcXG5cXHRcXHRcXHR0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRYWVo6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHksIHogKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XFxyXFxuXFx0XFx0XFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xcclxcblxcdFxcdFxcdHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldFhZWlc6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHksIHosIHcgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XFxyXFxuXFx0XFx0XFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xcclxcblxcdFxcdFxcdHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcXHJcXG5cXHRcXHRcXHR0aGlzLmFycmF5WyBpbmRleCArIDMgXSA9IHc7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRvblVwbG9hZDogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm9uVXBsb2FkQ2FsbGJhY2sgPSBjYWxsYmFjaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLmFycmF5LCB0aGlzLml0ZW1TaXplICkuY29weSggdGhpcyApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0Ly9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBJbnQ4QnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0QnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIG5ldyBJbnQ4QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdEludDhCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSApO1xcclxcblxcdEludDhCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW50OEJ1ZmZlckF0dHJpYnV0ZTtcXHJcXG5cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBVaW50OEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xcclxcblxcclxcblxcdFxcdEJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBuZXcgVWludDhBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0VWludDhCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSApO1xcclxcblxcdFVpbnQ4QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFVpbnQ4QnVmZmVyQXR0cmlidXRlO1xcclxcblxcclxcblxcclxcblxcdGZ1bmN0aW9uIFVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xcclxcblxcclxcblxcdFxcdEJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBuZXcgVWludDhDbGFtcGVkQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdFVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XFxyXFxuXFx0VWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZTtcXHJcXG5cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBJbnQxNkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xcclxcblxcclxcblxcdFxcdEJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBuZXcgSW50MTZBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0SW50MTZCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSApO1xcclxcblxcdEludDE2QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEludDE2QnVmZmVyQXR0cmlidXRlO1xcclxcblxcclxcblxcclxcblxcdGZ1bmN0aW9uIFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xcclxcblxcclxcblxcdFxcdEJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBuZXcgVWludDE2QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XFxyXFxuXFx0VWludDE2QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZTtcXHJcXG5cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBJbnQzMkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xcclxcblxcclxcblxcdFxcdEJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBuZXcgSW50MzJBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0SW50MzJCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSApO1xcclxcblxcdEludDMyQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEludDMyQnVmZmVyQXR0cmlidXRlO1xcclxcblxcclxcblxcclxcblxcdGZ1bmN0aW9uIFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xcclxcblxcclxcblxcdFxcdEJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBuZXcgVWludDMyQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XFxyXFxuXFx0VWludDMyQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZTtcXHJcXG5cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0QnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIG5ldyBGbG9hdDMyQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSApO1xcclxcblxcdEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZTtcXHJcXG5cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBGbG9hdDY0QnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0QnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIG5ldyBGbG9hdDY0QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdEZsb2F0NjRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSApO1xcclxcblxcdEZsb2F0NjRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRmxvYXQ2NEJ1ZmZlckF0dHJpYnV0ZTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIERpcmVjdEdlb21ldHJ5KCkge1xcclxcblxcclxcblxcdFxcdHRoaXMuaW5kaWNlcyA9IFtdO1xcclxcblxcdFxcdHRoaXMudmVydGljZXMgPSBbXTtcXHJcXG5cXHRcXHR0aGlzLm5vcm1hbHMgPSBbXTtcXHJcXG5cXHRcXHR0aGlzLmNvbG9ycyA9IFtdO1xcclxcblxcdFxcdHRoaXMudXZzID0gW107XFxyXFxuXFx0XFx0dGhpcy51dnMyID0gW107XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5ncm91cHMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHt9O1xcclxcblxcclxcblxcdFxcdHRoaXMuc2tpbldlaWdodHMgPSBbXTtcXHJcXG5cXHRcXHR0aGlzLnNraW5JbmRpY2VzID0gW107XFxyXFxuXFxyXFxuXFx0XFx0Ly8gdGhpcy5saW5lRGlzdGFuY2VzID0gW107XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XFxyXFxuXFx0XFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gdXBkYXRlIGZsYWdzXFxyXFxuXFxyXFxuXFx0XFx0dGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcXHJcXG5cXHRcXHR0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XFxyXFxuXFx0XFx0dGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XFxyXFxuXFx0XFx0dGhpcy51dnNOZWVkVXBkYXRlID0gZmFsc2U7XFxyXFxuXFx0XFx0dGhpcy5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIERpcmVjdEdlb21ldHJ5LnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdGNvbXB1dGVHcm91cHM6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGdyb3VwO1xcclxcblxcdFxcdFxcdHZhciBncm91cHMgPSBbXTtcXHJcXG5cXHRcXHRcXHR2YXIgbWF0ZXJpYWxJbmRleCA9IHVuZGVmaW5lZDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgZmFjZXMgPSBnZW9tZXRyeS5mYWNlcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBmYWNlcy5sZW5ndGg7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIG1hdGVyaWFsc1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggZmFjZS5tYXRlcmlhbEluZGV4ICE9PSBtYXRlcmlhbEluZGV4ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsSW5kZXggPSBmYWNlLm1hdGVyaWFsSW5kZXg7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBncm91cCAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGdyb3VwLmNvdW50ID0gKCBpICogMyApIC0gZ3JvdXAuc3RhcnQ7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z3JvdXBzLnB1c2goIGdyb3VwICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGdyb3VwID0ge1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHN0YXJ0OiBpICogMyxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXRlcmlhbEluZGV4OiBtYXRlcmlhbEluZGV4XFxyXFxuXFx0XFx0XFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggZ3JvdXAgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRncm91cC5jb3VudCA9ICggaSAqIDMgKSAtIGdyb3VwLnN0YXJ0O1xcclxcblxcdFxcdFxcdFxcdGdyb3Vwcy5wdXNoKCBncm91cCApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmdyb3VwcyA9IGdyb3VwcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGZyb21HZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgZmFjZXMgPSBnZW9tZXRyeS5mYWNlcztcXHJcXG5cXHRcXHRcXHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcXHJcXG5cXHRcXHRcXHR2YXIgZmFjZVZlcnRleFV2cyA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGhhc0ZhY2VWZXJ0ZXhVdiA9IGZhY2VWZXJ0ZXhVdnNbIDAgXSAmJiBmYWNlVmVydGV4VXZzWyAwIF0ubGVuZ3RoID4gMDtcXHJcXG5cXHRcXHRcXHR2YXIgaGFzRmFjZVZlcnRleFV2MiA9IGZhY2VWZXJ0ZXhVdnNbIDEgXSAmJiBmYWNlVmVydGV4VXZzWyAxIF0ubGVuZ3RoID4gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBtb3JwaHNcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzO1xcclxcblxcdFxcdFxcdHZhciBtb3JwaFRhcmdldHNMZW5ndGggPSBtb3JwaFRhcmdldHMubGVuZ3RoO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBtb3JwaFRhcmdldHNQb3NpdGlvbjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIG1vcnBoVGFyZ2V0c0xlbmd0aCA+IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bW9ycGhUYXJnZXRzUG9zaXRpb24gPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBtb3JwaFRhcmdldHNMZW5ndGg7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0bW9ycGhUYXJnZXRzUG9zaXRpb25bIGkgXSA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLm1vcnBoVGFyZ2V0cy5wb3NpdGlvbiA9IG1vcnBoVGFyZ2V0c1Bvc2l0aW9uO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbW9ycGhOb3JtYWxzID0gZ2VvbWV0cnkubW9ycGhOb3JtYWxzO1xcclxcblxcdFxcdFxcdHZhciBtb3JwaE5vcm1hbHNMZW5ndGggPSBtb3JwaE5vcm1hbHMubGVuZ3RoO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBtb3JwaFRhcmdldHNOb3JtYWw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBtb3JwaE5vcm1hbHNMZW5ndGggPiAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdG1vcnBoVGFyZ2V0c05vcm1hbCA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IG1vcnBoTm9ybWFsc0xlbmd0aDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRtb3JwaFRhcmdldHNOb3JtYWxbIGkgXSA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLm1vcnBoVGFyZ2V0cy5ub3JtYWwgPSBtb3JwaFRhcmdldHNOb3JtYWw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdC8vIHNraW5zXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHNraW5JbmRpY2VzID0gZ2VvbWV0cnkuc2tpbkluZGljZXM7XFxyXFxuXFx0XFx0XFx0dmFyIHNraW5XZWlnaHRzID0gZ2VvbWV0cnkuc2tpbldlaWdodHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGhhc1NraW5JbmRpY2VzID0gc2tpbkluZGljZXMubGVuZ3RoID09PSB2ZXJ0aWNlcy5sZW5ndGg7XFxyXFxuXFx0XFx0XFx0dmFyIGhhc1NraW5XZWlnaHRzID0gc2tpbldlaWdodHMubGVuZ3RoID09PSB2ZXJ0aWNlcy5sZW5ndGg7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly9cXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBmYWNlcy5sZW5ndGg7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMudmVydGljZXMucHVzaCggdmVydGljZXNbIGZhY2UuYSBdLCB2ZXJ0aWNlc1sgZmFjZS5iIF0sIHZlcnRpY2VzWyBmYWNlLmMgXSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciB2ZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggdmVydGV4Tm9ybWFscy5sZW5ndGggPT09IDMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5ub3JtYWxzLnB1c2goIHZlcnRleE5vcm1hbHNbIDAgXSwgdmVydGV4Tm9ybWFsc1sgMSBdLCB2ZXJ0ZXhOb3JtYWxzWyAyIF0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBub3JtYWwgPSBmYWNlLm5vcm1hbDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLm5vcm1hbHMucHVzaCggbm9ybWFsLCBub3JtYWwsIG5vcm1hbCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgdmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB2ZXJ0ZXhDb2xvcnMubGVuZ3RoID09PSAzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMuY29sb3JzLnB1c2goIHZlcnRleENvbG9yc1sgMCBdLCB2ZXJ0ZXhDb2xvcnNbIDEgXSwgdmVydGV4Q29sb3JzWyAyIF0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBjb2xvciA9IGZhY2UuY29sb3I7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5jb2xvcnMucHVzaCggY29sb3IsIGNvbG9yLCBjb2xvciApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiA9PT0gdHJ1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdmVydGV4VXZzID0gZmFjZVZlcnRleFV2c1sgMCBdWyBpIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB2ZXJ0ZXhVdnMgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnV2cy5wdXNoKCB2ZXJ0ZXhVdnNbIDAgXSwgdmVydGV4VXZzWyAxIF0sIHZlcnRleFV2c1sgMiBdICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5EaXJlY3RHZW9tZXRyeS5mcm9tR2VvbWV0cnkoKTogVW5kZWZpbmVkIHZlcnRleFV2ICcsIGkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnV2cy5wdXNoKCBuZXcgVmVjdG9yMigpLCBuZXcgVmVjdG9yMigpLCBuZXcgVmVjdG9yMigpICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGhhc0ZhY2VWZXJ0ZXhVdjIgPT09IHRydWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHZlcnRleFV2cyA9IGZhY2VWZXJ0ZXhVdnNbIDEgXVsgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggdmVydGV4VXZzICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy51dnMyLnB1c2goIHZlcnRleFV2c1sgMCBdLCB2ZXJ0ZXhVdnNbIDEgXSwgdmVydGV4VXZzWyAyIF0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkRpcmVjdEdlb21ldHJ5LmZyb21HZW9tZXRyeSgpOiBVbmRlZmluZWQgdmVydGV4VXYyICcsIGkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnV2czIucHVzaCggbmV3IFZlY3RvcjIoKSwgbmV3IFZlY3RvcjIoKSwgbmV3IFZlY3RvcjIoKSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gbW9ycGhzXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGogPSAwOyBqIDwgbW9ycGhUYXJnZXRzTGVuZ3RoOyBqICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBtb3JwaFRhcmdldCA9IG1vcnBoVGFyZ2V0c1sgaiBdLnZlcnRpY2VzO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdG1vcnBoVGFyZ2V0c1Bvc2l0aW9uWyBqIF0ucHVzaCggbW9ycGhUYXJnZXRbIGZhY2UuYSBdLCBtb3JwaFRhcmdldFsgZmFjZS5iIF0sIG1vcnBoVGFyZ2V0WyBmYWNlLmMgXSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaiA9IDA7IGogPCBtb3JwaE5vcm1hbHNMZW5ndGg7IGogKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIG1vcnBoTm9ybWFsID0gbW9ycGhOb3JtYWxzWyBqIF0udmVydGV4Tm9ybWFsc1sgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdG1vcnBoVGFyZ2V0c05vcm1hbFsgaiBdLnB1c2goIG1vcnBoTm9ybWFsLmEsIG1vcnBoTm9ybWFsLmIsIG1vcnBoTm9ybWFsLmMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gc2tpbnNcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGhhc1NraW5JbmRpY2VzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2tpbkluZGljZXMucHVzaCggc2tpbkluZGljZXNbIGZhY2UuYSBdLCBza2luSW5kaWNlc1sgZmFjZS5iIF0sIHNraW5JbmRpY2VzWyBmYWNlLmMgXSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGhhc1NraW5XZWlnaHRzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2tpbldlaWdodHMucHVzaCggc2tpbldlaWdodHNbIGZhY2UuYSBdLCBza2luV2VpZ2h0c1sgZmFjZS5iIF0sIHNraW5XZWlnaHRzWyBmYWNlLmMgXSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5jb21wdXRlR3JvdXBzKCBnZW9tZXRyeSApO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlO1xcclxcblxcdFxcdFxcdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZTtcXHJcXG5cXHRcXHRcXHR0aGlzLmNvbG9yc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlO1xcclxcblxcdFxcdFxcdHRoaXMudXZzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnV2c05lZWRVcGRhdGU7XFxyXFxuXFx0XFx0XFx0dGhpcy5ncm91cHNOZWVkVXBkYXRlID0gZ2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gYXJyYXlNYXgoIGFycmF5ICkge1xcclxcblxcclxcblxcdFxcdGlmICggYXJyYXkubGVuZ3RoID09PSAwICkgcmV0dXJuIC0gSW5maW5pdHk7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIG1heCA9IGFycmF5WyAwIF07XFxyXFxuXFxyXFxuXFx0XFx0Zm9yICggdmFyIGkgPSAxLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgKysgaSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGFycmF5WyBpIF0gPiBtYXggKSBtYXggPSBhcnJheVsgaSBdO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gbWF4O1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0dmFyIGJ1ZmZlckdlb21ldHJ5SWQgPSAxOyAvLyBCdWZmZXJHZW9tZXRyeSB1c2VzIG9kZCBudW1iZXJzIGFzIElkXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gQnVmZmVyR2VvbWV0cnkoKSB7XFxyXFxuXFxyXFxuXFx0XFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBidWZmZXJHZW9tZXRyeUlkICs9IDIgfSApO1xcclxcblxcclxcblxcdFxcdHRoaXMudXVpZCA9IF9NYXRoLmdlbmVyYXRlVVVJRCgpO1xcclxcblxcclxcblxcdFxcdHRoaXMubmFtZSA9ICcnO1xcclxcblxcdFxcdHRoaXMudHlwZSA9ICdCdWZmZXJHZW9tZXRyeSc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5pbmRleCA9IG51bGw7XFxyXFxuXFx0XFx0dGhpcy5hdHRyaWJ1dGVzID0ge307XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5tb3JwaEF0dHJpYnV0ZXMgPSB7fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmdyb3VwcyA9IFtdO1xcclxcblxcclxcblxcdFxcdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xcclxcblxcdFxcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xcclxcblxcclxcblxcdFxcdHRoaXMuZHJhd1JhbmdlID0geyBzdGFydDogMCwgY291bnQ6IEluZmluaXR5IH07XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgKSwge1xcclxcblxcclxcblxcdFxcdGNvbnN0cnVjdG9yOiBCdWZmZXJHZW9tZXRyeSxcXHJcXG5cXHJcXG5cXHRcXHRpc0J1ZmZlckdlb21ldHJ5OiB0cnVlLFxcclxcblxcclxcblxcdFxcdGdldEluZGV4OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuaW5kZXg7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRJbmRleDogZnVuY3Rpb24gKCBpbmRleCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIEFycmF5LmlzQXJyYXkoIGluZGV4ICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5pbmRleCA9IG5ldyAoIGFycmF5TWF4KCBpbmRleCApID4gNjU1MzUgPyBVaW50MzJCdWZmZXJBdHRyaWJ1dGUgOiBVaW50MTZCdWZmZXJBdHRyaWJ1dGUgKSggaW5kZXgsIDEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuaW5kZXggPSBpbmRleDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRhZGRBdHRyaWJ1dGU6IGZ1bmN0aW9uICggbmFtZSwgYXR0cmlidXRlICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggISAoIGF0dHJpYnV0ZSAmJiBhdHRyaWJ1dGUuaXNCdWZmZXJBdHRyaWJ1dGUgKSAmJiAhICggYXR0cmlidXRlICYmIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGRBdHRyaWJ1dGUoKSBub3cgZXhwZWN0cyAoIG5hbWUsIGF0dHJpYnV0ZSApLicgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggbmFtZSwgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggYXJndW1lbnRzWyAxIF0sIGFyZ3VtZW50c1sgMiBdICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggbmFtZSA9PT0gJ2luZGV4JyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5hZGRBdHRyaWJ1dGU6IFVzZSAuc2V0SW5kZXgoKSBmb3IgaW5kZXggYXR0cmlidXRlLicgKTtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnNldEluZGV4KCBhdHRyaWJ1dGUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdID0gYXR0cmlidXRlO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Z2V0QXR0cmlidXRlOiBmdW5jdGlvbiAoIG5hbWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0cmVtb3ZlQXR0cmlidXRlOiBmdW5jdGlvbiAoIG5hbWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZGVsZXRlIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0YWRkR3JvdXA6IGZ1bmN0aW9uICggc3RhcnQsIGNvdW50LCBtYXRlcmlhbEluZGV4ICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuZ3JvdXBzLnB1c2goIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzdGFydDogc3RhcnQsXFxyXFxuXFx0XFx0XFx0XFx0Y291bnQ6IGNvdW50LFxcclxcblxcdFxcdFxcdFxcdG1hdGVyaWFsSW5kZXg6IG1hdGVyaWFsSW5kZXggIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsSW5kZXggOiAwXFxyXFxuXFxyXFxuXFx0XFx0XFx0fSApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y2xlYXJHcm91cHM6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmdyb3VwcyA9IFtdO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0RHJhd1JhbmdlOiBmdW5jdGlvbiAoIHN0YXJ0LCBjb3VudCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmRyYXdSYW5nZS5zdGFydCA9IHN0YXJ0O1xcclxcblxcdFxcdFxcdHRoaXMuZHJhd1JhbmdlLmNvdW50ID0gY291bnQ7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRhcHBseU1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHBvc2l0aW9uID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggcG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRtYXRyaXguYXBwbHlUb0J1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24gKTtcXHJcXG5cXHRcXHRcXHRcXHRwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHZhciBub3JtYWwgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggbm9ybWFsICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBNYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRub3JtYWxNYXRyaXguYXBwbHlUb0J1ZmZlckF0dHJpYnV0ZSggbm9ybWFsICk7XFxyXFxuXFx0XFx0XFx0XFx0bm9ybWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHJvdGF0ZVg6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHgtYXhpc1xcclxcblxcclxcblxcdFxcdFxcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVgoIGFuZ2xlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdG0xLm1ha2VSb3RhdGlvblgoIGFuZ2xlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0oKSxcXHJcXG5cXHJcXG5cXHRcXHRyb3RhdGVZOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB5LWF4aXNcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbTEgPSBuZXcgTWF0cml4NCgpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiByb3RhdGVZKCBhbmdsZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRtMS5tYWtlUm90YXRpb25ZKCBhbmdsZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR9KCksXFxyXFxuXFxyXFxuXFx0XFx0cm90YXRlWjogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgei1heGlzXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWiggYW5nbGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bTEubWFrZVJvdGF0aW9uWiggYW5nbGUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdC8vIHRyYW5zbGF0ZSBnZW9tZXRyeVxcclxcblxcclxcblxcdFxcdFxcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZSggeCwgeSwgeiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRtMS5tYWtlVHJhbnNsYXRpb24oIHgsIHksIHogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdHNjYWxlOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gc2NhbGUgZ2VvbWV0cnlcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbTEgPSBuZXcgTWF0cml4NCgpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBzY2FsZSggeCwgeSwgeiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRtMS5tYWtlU2NhbGUoIHgsIHksIHogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdGxvb2tBdDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBvYmogPSBuZXcgT2JqZWN0M0QoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gbG9va0F0KCB2ZWN0b3IgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0b2JqLmxvb2tBdCggdmVjdG9yICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0b2JqLnVwZGF0ZU1hdHJpeCgpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuYXBwbHlNYXRyaXgoIG9iai5tYXRyaXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0oKSxcXHJcXG5cXHJcXG5cXHRcXHRjZW50ZXI6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBvZmZzZXQgPSB0aGlzLmJvdW5kaW5nQm94LmdldENlbnRlcigpLm5lZ2F0ZSgpO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMudHJhbnNsYXRlKCBvZmZzZXQueCwgb2Zmc2V0LnksIG9mZnNldC56ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIG9mZnNldDtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldEZyb21PYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xcclxcblxcclxcblxcdFxcdFxcdC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuc2V0RnJvbU9iamVjdCgpLiBDb252ZXJ0aW5nJywgb2JqZWN0LCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xcclxcblxcclxcblxcdFxcdFxcdGlmICggb2JqZWN0LmlzUG9pbnRzIHx8IG9iamVjdC5pc0xpbmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKiAzLCAzICk7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGNvbG9ycyA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBnZW9tZXRyeS5jb2xvcnMubGVuZ3RoICogMywgMyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbnMuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5LnZlcnRpY2VzICkgKTtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ2NvbG9yJywgY29sb3JzLmNvcHlDb2xvcnNBcnJheSggZ2VvbWV0cnkuY29sb3JzICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMgJiYgZ2VvbWV0cnkubGluZURpc3RhbmNlcy5sZW5ndGggPT09IGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgbGluZURpc3RhbmNlcyA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzLmxlbmd0aCwgMSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAnbGluZURpc3RhbmNlJywgbGluZURpc3RhbmNlcy5jb3B5QXJyYXkoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMgKSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMuYm91bmRpbmdCb3ggPSBnZW9tZXRyeS5ib3VuZGluZ0JveC5jbG9uZSgpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBvYmplY3QuaXNNZXNoICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNHZW9tZXRyeSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmZyb21HZW9tZXRyeSggZ2VvbWV0cnkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0RnJvbVBvaW50czogZnVuY3Rpb24gKCBwb2ludHMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHBvc2l0aW9uID0gW107XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHBvaW50ID0gcG9pbnRzWyBpIF07XFxyXFxuXFx0XFx0XFx0XFx0cG9zaXRpb24ucHVzaCggcG9pbnQueCwgcG9pbnQueSwgcG9pbnQueiB8fCAwICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIDMgKSApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0dXBkYXRlRnJvbU9iamVjdDogZnVuY3Rpb24gKCBvYmplY3QgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xcclxcblxcclxcblxcdFxcdFxcdGlmICggb2JqZWN0LmlzTWVzaCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgZGlyZWN0ID0gZ2VvbWV0cnkuX19kaXJlY3RHZW9tZXRyeTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGdlb21ldHJ5LmVsZW1lbnRzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRkaXJlY3QgPSB1bmRlZmluZWQ7XFxyXFxuXFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkuZWxlbWVudHNOZWVkVXBkYXRlID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggZGlyZWN0ID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZnJvbUdlb21ldHJ5KCBnZW9tZXRyeSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRkaXJlY3QudmVydGljZXNOZWVkVXBkYXRlID0gZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlO1xcclxcblxcdFxcdFxcdFxcdGRpcmVjdC5ub3JtYWxzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlO1xcclxcblxcdFxcdFxcdFxcdGRpcmVjdC5jb2xvcnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZTtcXHJcXG5cXHRcXHRcXHRcXHRkaXJlY3QudXZzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnV2c05lZWRVcGRhdGU7XFxyXFxuXFx0XFx0XFx0XFx0ZGlyZWN0Lmdyb3Vwc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xcclxcblxcdFxcdFxcdFxcdGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XFxyXFxuXFx0XFx0XFx0XFx0Z2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xcclxcblxcdFxcdFxcdFxcdGdlb21ldHJ5LnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcXHJcXG5cXHRcXHRcXHRcXHRnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Z2VvbWV0cnkgPSBkaXJlY3Q7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHZhciBhdHRyaWJ1dGU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPT09IHRydWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0YXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcyApO1xcclxcblxcdFxcdFxcdFxcdFxcdGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlID09PSB0cnVlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRhdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5Lm5vcm1hbHMgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPT09IHRydWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLmNvbG9yO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0YXR0cmlidXRlLmNvcHlDb2xvcnNBcnJheSggZ2VvbWV0cnkuY29sb3JzICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Z2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGdlb21ldHJ5LnV2c05lZWRVcGRhdGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLnV2O1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0YXR0cmlidXRlLmNvcHlWZWN0b3Iyc0FycmF5KCBnZW9tZXRyeS51dnMgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRnZW9tZXRyeS51dnNOZWVkVXBkYXRlID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggZ2VvbWV0cnkubGluZURpc3RhbmNlc05lZWRVcGRhdGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLmxpbmVEaXN0YW5jZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGF0dHJpYnV0ZS5jb3B5QXJyYXkoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRnZW9tZXRyeS5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Z2VvbWV0cnkuY29tcHV0ZUdyb3Vwcyggb2JqZWN0Lmdlb21ldHJ5ICk7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5ncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Z2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZSA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGZyb21HZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRnZW9tZXRyeS5fX2RpcmVjdEdlb21ldHJ5ID0gbmV3IERpcmVjdEdlb21ldHJ5KCkuZnJvbUdlb21ldHJ5KCBnZW9tZXRyeSApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmZyb21EaXJlY3RHZW9tZXRyeSggZ2VvbWV0cnkuX19kaXJlY3RHZW9tZXRyeSApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0ZnJvbURpcmVjdEdlb21ldHJ5OiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKiAzICk7XFxyXFxuXFx0XFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcyApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5ub3JtYWxzLmxlbmd0aCA+IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS5ub3JtYWxzLmxlbmd0aCAqIDMgKTtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKS5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkubm9ybWFscyApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggZ2VvbWV0cnkuY29sb3JzLmxlbmd0aCA+IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LmNvbG9ycy5sZW5ndGggKiAzICk7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApLmNvcHlDb2xvcnNBcnJheSggZ2VvbWV0cnkuY29sb3JzICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBnZW9tZXRyeS51dnMubGVuZ3RoID4gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgdXZzID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudXZzLmxlbmd0aCAqIDIgKTtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkuY29weVZlY3RvcjJzQXJyYXkoIGdlb21ldHJ5LnV2cyApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggZ2VvbWV0cnkudXZzMi5sZW5ndGggPiAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciB1dnMyID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudXZzMi5sZW5ndGggKiAyICk7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1djInLCBuZXcgQnVmZmVyQXR0cmlidXRlKCB1dnMyLCAyICkuY29weVZlY3RvcjJzQXJyYXkoIGdlb21ldHJ5LnV2czIgKSApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGdlb21ldHJ5LmluZGljZXMubGVuZ3RoID4gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgVHlwZUFycmF5ID0gYXJyYXlNYXgoIGdlb21ldHJ5LmluZGljZXMgKSA+IDY1NTM1ID8gVWludDMyQXJyYXkgOiBVaW50MTZBcnJheTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgaW5kaWNlcyA9IG5ldyBUeXBlQXJyYXkoIGdlb21ldHJ5LmluZGljZXMubGVuZ3RoICogMyApO1xcclxcblxcdFxcdFxcdFxcdHRoaXMuc2V0SW5kZXgoIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGluZGljZXMsIDEgKS5jb3B5SW5kaWNlc0FycmF5KCBnZW9tZXRyeS5pbmRpY2VzICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gZ3JvdXBzXFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5ncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gbW9ycGhzXFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIG5hbWUgaW4gZ2VvbWV0cnkubW9ycGhUYXJnZXRzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBhcnJheSA9IFtdO1xcclxcblxcdFxcdFxcdFxcdHZhciBtb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIG5hbWUgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBtb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgbW9ycGhUYXJnZXQgPSBtb3JwaFRhcmdldHNbIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgYXR0cmlidXRlID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG1vcnBoVGFyZ2V0Lmxlbmd0aCAqIDMsIDMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRhcnJheS5wdXNoKCBhdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoIG1vcnBoVGFyZ2V0ICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5tb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXSA9IGFycmF5O1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBza2lubmluZ1xcclxcblxcclxcblxcdFxcdFxcdGlmICggZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoID4gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgc2tpbkluZGljZXMgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoICogNCwgNCApO1xcclxcblxcdFxcdFxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAnc2tpbkluZGV4Jywgc2tpbkluZGljZXMuY29weVZlY3RvcjRzQXJyYXkoIGdlb21ldHJ5LnNraW5JbmRpY2VzICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggPiAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBza2luV2VpZ2h0cyA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBnZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggKiA0LCA0ICk7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdza2luV2VpZ2h0Jywgc2tpbldlaWdodHMuY29weVZlY3RvcjRzQXJyYXkoIGdlb21ldHJ5LnNraW5XZWlnaHRzICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly9cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuYm91bmRpbmdCb3ggPSBnZW9tZXRyeS5ib3VuZGluZ0JveC5jbG9uZSgpO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNvbXB1dGVCb3VuZGluZ0JveDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmJvdW5kaW5nQm94ID0gbmV3IEJveDMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHBvc2l0aW9uID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggcG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmJvdW5kaW5nQm94LnNldEZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmJvdW5kaW5nQm94Lm1ha2VFbXB0eSgpO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi54ICkgfHwgaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnkgKSB8fCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueiApICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3g6IENvbXB1dGVkIG1pbi9tYXggaGF2ZSBOYU4gdmFsdWVzLiBUaGUgXFxcInBvc2l0aW9uXFxcIiBhdHRyaWJ1dGUgaXMgbGlrZWx5IHRvIGhhdmUgTmFOIHZhbHVlcy4nLCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y29tcHV0ZUJvdW5kaW5nU3BoZXJlOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGJveCA9IG5ldyBCb3gzKCk7XFxyXFxuXFx0XFx0XFx0dmFyIHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBTcGhlcmUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHBvc2l0aW9uID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggcG9zaXRpb24gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGNlbnRlciA9IHRoaXMuYm91bmRpbmdTcGhlcmUuY2VudGVyO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGJveC5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiApO1xcclxcblxcdFxcdFxcdFxcdFxcdGJveC5nZXRDZW50ZXIoIGNlbnRlciApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIGhvcGluZyB0byBmaW5kIGEgYm91bmRpbmdTcGhlcmUgd2l0aCBhIHJhZGl1cyBzbWFsbGVyIHRoYW4gdGhlXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gYm91bmRpbmdTcGhlcmUgb2YgdGhlIGJvdW5kaW5nQm94OiBzcXJ0KDMpIHNtYWxsZXIgaW4gdGhlIGJlc3QgY2FzZVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBtYXhSYWRpdXNTcSA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvc2l0aW9uLmNvdW50OyBpIDwgaWw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmVjdG9yLnggPSBwb3NpdGlvbi5nZXRYKCBpICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmVjdG9yLnkgPSBwb3NpdGlvbi5nZXRZKCBpICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmVjdG9yLnogPSBwb3NpdGlvbi5nZXRaKCBpICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0bWF4UmFkaXVzU3EgPSBNYXRoLm1heCggbWF4UmFkaXVzU3EsIGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggdmVjdG9yICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgPSBNYXRoLnNxcnQoIG1heFJhZGl1c1NxICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBpc05hTiggdGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgKSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk6IENvbXB1dGVkIHJhZGl1cyBpcyBOYU4uIFRoZSBcXFwicG9zaXRpb25cXFwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdGNvbXB1dGVGYWNlTm9ybWFsczogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjb21wdXRlVmVydGV4Tm9ybWFsczogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XFxyXFxuXFx0XFx0XFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XFxyXFxuXFx0XFx0XFx0dmFyIGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggYXR0cmlidXRlcy5wb3NpdGlvbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGF0dHJpYnV0ZXMubm9ybWFsID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBwb3NpdGlvbnMubGVuZ3RoICksIDMgKSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gcmVzZXQgZXhpc3Rpbmcgbm9ybWFscyB0byB6ZXJvXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGFycmF5ID0gYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGFycmF5WyBpIF0gPSAwO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIG5vcm1hbHMgPSBhdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgdkEsIHZCLCB2QztcXHJcXG5cXHRcXHRcXHRcXHR2YXIgcEEgPSBuZXcgVmVjdG9yMygpLCBwQiA9IG5ldyBWZWN0b3IzKCksIHBDID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgY2IgPSBuZXcgVmVjdG9yMygpLCBhYiA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gaW5kZXhlZCBlbGVtZW50c1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggaW5kZXggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGluZGljZXMgPSBpbmRleC5hcnJheTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGdyb3Vwcy5sZW5ndGggPT09IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5hZGRHcm91cCggMCwgaW5kaWNlcy5sZW5ndGggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGdyb3Vwcy5sZW5ndGg7IGogPCBqbDsgKysgaiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgZ3JvdXAgPSBncm91cHNbIGogXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgc3RhcnQgPSBncm91cC5zdGFydDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgY291bnQgPSBncm91cC5jb3VudDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IHN0YXJ0LCBpbCA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbDsgaSArPSAzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZBID0gaW5kaWNlc1sgaSArIDAgXSAqIDM7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dkIgPSBpbmRpY2VzWyBpICsgMSBdICogMztcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2QyA9IGluZGljZXNbIGkgKyAyIF0gKiAzO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHBBLmZyb21BcnJheSggcG9zaXRpb25zLCB2QSApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHBCLmZyb21BcnJheSggcG9zaXRpb25zLCB2QiApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHBDLmZyb21BcnJheSggcG9zaXRpb25zLCB2QyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNiLnN1YlZlY3RvcnMoIHBDLCBwQiApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGFiLnN1YlZlY3RvcnMoIHBBLCBwQiApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNiLmNyb3NzKCBhYiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIHZBIF0gKz0gY2IueDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxzWyB2QSArIDEgXSArPSBjYi55O1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIHZBICsgMiBdICs9IGNiLno7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgdkIgXSArPSBjYi54O1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIHZCICsgMSBdICs9IGNiLnk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgdkIgKyAyIF0gKz0gY2IuejtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxzWyB2QyBdICs9IGNiLng7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgdkMgKyAxIF0gKz0gY2IueTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxzWyB2QyArIDIgXSArPSBjYi56O1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBub24taW5kZXhlZCBlbGVtZW50cyAodW5jb25uZWN0ZWQgdHJpYW5nbGUgc291cClcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0cEEuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRwQi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSArIDMgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRwQy5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSArIDYgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYi5zdWJWZWN0b3JzKCBwQywgcEIgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRhYi5zdWJWZWN0b3JzKCBwQSwgcEIgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYi5jcm9zcyggYWIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxzWyBpIF0gPSBjYi54O1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIGkgKyAxIF0gPSBjYi55O1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIGkgKyAyIF0gPSBjYi56O1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIGkgKyAzIF0gPSBjYi54O1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIGkgKyA0IF0gPSBjYi55O1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIGkgKyA1IF0gPSBjYi56O1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIGkgKyA2IF0gPSBjYi54O1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIGkgKyA3IF0gPSBjYi55O1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIGkgKyA4IF0gPSBjYi56O1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5ub3JtYWxpemVOb3JtYWxzKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YXR0cmlidXRlcy5ub3JtYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdG1lcmdlOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBvZmZzZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCAhICggZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5tZXJnZSgpOiBnZW9tZXRyeSBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkuJywgZ2VvbWV0cnkgKTtcXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBrZXkgaW4gYXR0cmlidXRlcyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGdlb21ldHJ5LmF0dHJpYnV0ZXNbIGtleSBdID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgYXR0cmlidXRlMSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xcclxcblxcdFxcdFxcdFxcdHZhciBhdHRyaWJ1dGVBcnJheTEgPSBhdHRyaWJ1dGUxLmFycmF5O1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBhdHRyaWJ1dGUyID0gZ2VvbWV0cnkuYXR0cmlidXRlc1sga2V5IF07XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGF0dHJpYnV0ZUFycmF5MiA9IGF0dHJpYnV0ZTIuYXJyYXk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGF0dHJpYnV0ZVNpemUgPSBhdHRyaWJ1dGUyLml0ZW1TaXplO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaiA9IGF0dHJpYnV0ZVNpemUgKiBvZmZzZXQ7IGkgPCBhdHRyaWJ1dGVBcnJheTIubGVuZ3RoOyBpICsrLCBqICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGF0dHJpYnV0ZUFycmF5MVsgaiBdID0gYXR0cmlidXRlQXJyYXkyWyBpIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdG5vcm1hbGl6ZU5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gbm9ybWFsaXplTm9ybWFscygpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgbm9ybWFscyA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG5vcm1hbHMuY291bnQ7IGkgPCBpbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2ZWN0b3IueCA9IG5vcm1hbHMuZ2V0WCggaSApO1xcclxcblxcdFxcdFxcdFxcdFxcdHZlY3Rvci55ID0gbm9ybWFscy5nZXRZKCBpICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmVjdG9yLnogPSBub3JtYWxzLmdldFooIGkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2ZWN0b3Iubm9ybWFsaXplKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0bm9ybWFscy5zZXRYWVooIGksIHZlY3Rvci54LCB2ZWN0b3IueSwgdmVjdG9yLnogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR9KCksXFxyXFxuXFxyXFxuXFx0XFx0dG9Ob25JbmRleGVkOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmluZGV4ID09PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LnRvTm9uSW5kZXhlZCgpOiBHZW9tZXRyeSBpcyBhbHJlYWR5IG5vbi1pbmRleGVkLicgKTtcXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGdlb21ldHJ5MiA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBpbmRpY2VzID0gdGhpcy5pbmRleC5hcnJheTtcXHJcXG5cXHRcXHRcXHR2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGFycmF5ID0gYXR0cmlidXRlLmFycmF5O1xcclxcblxcdFxcdFxcdFxcdHZhciBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgYXJyYXkyID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKCBpbmRpY2VzLmxlbmd0aCAqIGl0ZW1TaXplICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGluZGV4ID0gMCwgaW5kZXgyID0gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aW5kZXggPSBpbmRpY2VzWyBpIF0gKiBpdGVtU2l6ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaiA9IDA7IGogPCBpdGVtU2l6ZTsgaiArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRhcnJheTJbIGluZGV4MiArKyBdID0gYXJyYXlbIGluZGV4ICsrIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRnZW9tZXRyeTIuYWRkQXR0cmlidXRlKCBuYW1lLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBhcnJheTIsIGl0ZW1TaXplICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGdlb21ldHJ5MjtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHRvSlNPTjogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBkYXRhID0ge1xcclxcblxcdFxcdFxcdFxcdG1ldGFkYXRhOiB7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmVyc2lvbjogNC41LFxcclxcblxcdFxcdFxcdFxcdFxcdHR5cGU6ICdCdWZmZXJHZW9tZXRyeScsXFxyXFxuXFx0XFx0XFx0XFx0XFx0Z2VuZXJhdG9yOiAnQnVmZmVyR2VvbWV0cnkudG9KU09OJ1xcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdFxcdC8vIHN0YW5kYXJkIEJ1ZmZlckdlb21ldHJ5IHNlcmlhbGl6YXRpb25cXHJcXG5cXHJcXG5cXHRcXHRcXHRkYXRhLnV1aWQgPSB0aGlzLnV1aWQ7XFxyXFxuXFx0XFx0XFx0ZGF0YS50eXBlID0gdGhpcy50eXBlO1xcclxcblxcdFxcdFxcdGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMucGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBrZXkgaW4gcGFyYW1ldGVycyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHBhcmFtZXRlcnNbIGtleSBdICE9PSB1bmRlZmluZWQgKSBkYXRhWyBrZXkgXSA9IHBhcmFtZXRlcnNbIGtleSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZGF0YTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZGF0YS5kYXRhID0geyBhdHRyaWJ1dGVzOiB7fSB9O1xcclxcblxcclxcblxcdFxcdFxcdHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgYXJyYXkgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggaW5kZXguYXJyYXkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRkYXRhLmRhdGEuaW5kZXggPSB7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dHlwZTogaW5kZXguYXJyYXkuY29uc3RydWN0b3IubmFtZSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRhcnJheTogYXJyYXlcXHJcXG5cXHRcXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIga2V5IGluIGF0dHJpYnV0ZXMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBhcnJheSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhdHRyaWJ1dGUuYXJyYXkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRkYXRhLmRhdGEuYXR0cmlidXRlc1sga2V5IF0gPSB7XFxyXFxuXFx0XFx0XFx0XFx0XFx0aXRlbVNpemU6IGF0dHJpYnV0ZS5pdGVtU2l6ZSxcXHJcXG5cXHRcXHRcXHRcXHRcXHR0eXBlOiBhdHRyaWJ1dGUuYXJyYXkuY29uc3RydWN0b3IubmFtZSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRhcnJheTogYXJyYXksXFxyXFxuXFx0XFx0XFx0XFx0XFx0bm9ybWFsaXplZDogYXR0cmlidXRlLm5vcm1hbGl6ZWRcXHJcXG5cXHRcXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBncm91cHMubGVuZ3RoID4gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRkYXRhLmRhdGEuZ3JvdXBzID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIGdyb3VwcyApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHZhciBib3VuZGluZ1NwaGVyZSA9IHRoaXMuYm91bmRpbmdTcGhlcmU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRkYXRhLmRhdGEuYm91bmRpbmdTcGhlcmUgPSB7XFxyXFxuXFx0XFx0XFx0XFx0XFx0Y2VudGVyOiBib3VuZGluZ1NwaGVyZS5jZW50ZXIudG9BcnJheSgpLFxcclxcblxcdFxcdFxcdFxcdFxcdHJhZGl1czogYm91bmRpbmdTcGhlcmUucmFkaXVzXFxyXFxuXFx0XFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGRhdGE7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdC8qXFxyXFxuXFx0XFx0XFx0IC8vIEhhbmRsZSBwcmltaXRpdmVzXFxyXFxuXFxyXFxuXFx0XFx0XFx0IHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xcclxcblxcclxcblxcdFxcdFxcdCBpZiAoIHBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHQgdmFyIHZhbHVlcyA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdCBmb3IgKCB2YXIga2V5IGluIHBhcmFtZXRlcnMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0IHZhbHVlcy5wdXNoKCBwYXJhbWV0ZXJzWyBrZXkgXSApO1xcclxcblxcclxcblxcdFxcdFxcdCB9XFxyXFxuXFxyXFxuXFx0XFx0XFx0IHZhciBnZW9tZXRyeSA9IE9iamVjdC5jcmVhdGUoIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlICk7XFxyXFxuXFx0XFx0XFx0IHRoaXMuY29uc3RydWN0b3IuYXBwbHkoIGdlb21ldHJ5LCB2YWx1ZXMgKTtcXHJcXG5cXHRcXHRcXHQgcmV0dXJuIGdlb21ldHJ5O1xcclxcblxcclxcblxcdFxcdFxcdCB9XFxyXFxuXFxyXFxuXFx0XFx0XFx0IHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcXHJcXG5cXHRcXHRcXHQgKi9cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gbmV3IEJ1ZmZlckdlb21ldHJ5KCkuY29weSggdGhpcyApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG5hbWUsIGksIGw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gcmVzZXRcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmluZGV4ID0gbnVsbDtcXHJcXG5cXHRcXHRcXHR0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcXHJcXG5cXHRcXHRcXHR0aGlzLm1vcnBoQXR0cmlidXRlcyA9IHt9O1xcclxcblxcdFxcdFxcdHRoaXMuZ3JvdXBzID0gW107XFxyXFxuXFx0XFx0XFx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XFxyXFxuXFx0XFx0XFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gbmFtZVxcclxcblxcclxcblxcdFxcdFxcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xcclxcblxcclxcblxcdFxcdFxcdC8vIGluZGV4XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGluZGV4ID0gc291cmNlLmluZGV4O1xcclxcblxcclxcblxcdFxcdFxcdGlmICggaW5kZXggIT09IG51bGwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5zZXRJbmRleCggaW5kZXguY2xvbmUoKSApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBhdHRyaWJ1dGVzXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGF0dHJpYnV0ZXMgPSBzb3VyY2UuYXR0cmlidXRlcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIG5hbWUgXTtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggbmFtZSwgYXR0cmlidXRlLmNsb25lKCkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gbW9ycGggYXR0cmlidXRlc1xcclxcblxcclxcblxcdFxcdFxcdHZhciBtb3JwaEF0dHJpYnV0ZXMgPSBzb3VyY2UubW9ycGhBdHRyaWJ1dGVzO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIG5hbWUgaW4gbW9ycGhBdHRyaWJ1dGVzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBhcnJheSA9IFtdO1xcclxcblxcdFxcdFxcdFxcdHZhciBtb3JwaEF0dHJpYnV0ZSA9IG1vcnBoQXR0cmlidXRlc1sgbmFtZSBdOyAvLyBtb3JwaEF0dHJpYnV0ZTogYXJyYXkgb2YgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZXNcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCBpID0gMCwgbCA9IG1vcnBoQXR0cmlidXRlLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0YXJyYXkucHVzaCggbW9ycGhBdHRyaWJ1dGVbIGkgXS5jbG9uZSgpICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMubW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF0gPSBhcnJheTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gZ3JvdXBzXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGdyb3VwcyA9IHNvdXJjZS5ncm91cHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggaSA9IDAsIGwgPSBncm91cHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgZ3JvdXAgPSBncm91cHNbIGkgXTtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmFkZEdyb3VwKCBncm91cC5zdGFydCwgZ3JvdXAuY291bnQsIGdyb3VwLm1hdGVyaWFsSW5kZXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gYm91bmRpbmcgYm94XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGJvdW5kaW5nQm94ID0gc291cmNlLmJvdW5kaW5nQm94O1xcclxcblxcclxcblxcdFxcdFxcdGlmICggYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5ib3VuZGluZ0JveCA9IGJvdW5kaW5nQm94LmNsb25lKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdC8vIGJvdW5kaW5nIHNwaGVyZVxcclxcblxcclxcblxcdFxcdFxcdHZhciBib3VuZGluZ1NwaGVyZSA9IHNvdXJjZS5ib3VuZGluZ1NwaGVyZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBkcmF3IHJhbmdlXFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5kcmF3UmFuZ2Uuc3RhcnQgPSBzb3VyY2UuZHJhd1JhbmdlLnN0YXJ0O1xcclxcblxcdFxcdFxcdHRoaXMuZHJhd1JhbmdlLmNvdW50ID0gc291cmNlLmRyYXdSYW5nZS5jb3VudDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHQvLyBCb3hHZW9tZXRyeVxcclxcblxcclxcblxcdGZ1bmN0aW9uIEJveEdlb21ldHJ5KCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIGRlcHRoU2VnbWVudHMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdCb3hHZW9tZXRyeSc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcclxcblxcdFxcdFxcdHdpZHRoOiB3aWR0aCxcXHJcXG5cXHRcXHRcXHRoZWlnaHQ6IGhlaWdodCxcXHJcXG5cXHRcXHRcXHRkZXB0aDogZGVwdGgsXFxyXFxuXFx0XFx0XFx0d2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcXHJcXG5cXHRcXHRcXHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXFxyXFxuXFx0XFx0XFx0ZGVwdGhTZWdtZW50czogZGVwdGhTZWdtZW50c1xcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBCb3hCdWZmZXJHZW9tZXRyeSggd2lkdGgsIGhlaWdodCwgZGVwdGgsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBkZXB0aFNlZ21lbnRzICkgKTtcXHJcXG5cXHRcXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0Qm94R2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XFxyXFxuXFx0Qm94R2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQm94R2VvbWV0cnk7XFxyXFxuXFxyXFxuXFx0Ly8gQm94QnVmZmVyR2VvbWV0cnlcXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBCb3hCdWZmZXJHZW9tZXRyeSggd2lkdGgsIGhlaWdodCwgZGVwdGgsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBkZXB0aFNlZ21lbnRzICkge1xcclxcblxcclxcblxcdFxcdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnQm94QnVmZmVyR2VvbWV0cnknO1xcclxcblxcclxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXHJcXG5cXHRcXHRcXHR3aWR0aDogd2lkdGgsXFxyXFxuXFx0XFx0XFx0aGVpZ2h0OiBoZWlnaHQsXFxyXFxuXFx0XFx0XFx0ZGVwdGg6IGRlcHRoLFxcclxcblxcdFxcdFxcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXFxyXFxuXFx0XFx0XFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxcclxcblxcdFxcdFxcdGRlcHRoU2VnbWVudHM6IGRlcHRoU2VnbWVudHNcXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdFxcdHZhciBzY29wZSA9IHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0d2lkdGggPSB3aWR0aCB8fCAxO1xcclxcblxcdFxcdGhlaWdodCA9IGhlaWdodCB8fCAxO1xcclxcblxcdFxcdGRlcHRoID0gZGVwdGggfHwgMTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBzZWdtZW50c1xcclxcblxcclxcblxcdFxcdHdpZHRoU2VnbWVudHMgPSBNYXRoLmZsb29yKCB3aWR0aFNlZ21lbnRzICkgfHwgMTtcXHJcXG5cXHRcXHRoZWlnaHRTZWdtZW50cyA9IE1hdGguZmxvb3IoIGhlaWdodFNlZ21lbnRzICkgfHwgMTtcXHJcXG5cXHRcXHRkZXB0aFNlZ21lbnRzID0gTWF0aC5mbG9vciggZGVwdGhTZWdtZW50cyApIHx8IDE7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gYnVmZmVyc1xcclxcblxcclxcblxcdFxcdHZhciBpbmRpY2VzID0gW107XFxyXFxuXFx0XFx0dmFyIHZlcnRpY2VzID0gW107XFxyXFxuXFx0XFx0dmFyIG5vcm1hbHMgPSBbXTtcXHJcXG5cXHRcXHR2YXIgdXZzID0gW107XFxyXFxuXFxyXFxuXFx0XFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xcclxcblxcclxcblxcdFxcdHZhciBudW1iZXJPZlZlcnRpY2VzID0gMDtcXHJcXG5cXHRcXHR2YXIgZ3JvdXBTdGFydCA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gYnVpbGQgZWFjaCBzaWRlIG9mIHRoZSBib3ggZ2VvbWV0cnlcXHJcXG5cXHJcXG5cXHRcXHRidWlsZFBsYW5lKCAneicsICd5JywgJ3gnLCAtIDEsIC0gMSwgZGVwdGgsIGhlaWdodCwgd2lkdGgsIGRlcHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCAwICk7IC8vIHB4XFxyXFxuXFx0XFx0YnVpbGRQbGFuZSggJ3onLCAneScsICd4JywgMSwgLSAxLCBkZXB0aCwgaGVpZ2h0LCAtIHdpZHRoLCBkZXB0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgMSApOyAvLyBueFxcclxcblxcdFxcdGJ1aWxkUGxhbmUoICd4JywgJ3onLCAneScsIDEsIDEsIHdpZHRoLCBkZXB0aCwgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBkZXB0aFNlZ21lbnRzLCAyICk7IC8vIHB5XFxyXFxuXFx0XFx0YnVpbGRQbGFuZSggJ3gnLCAneicsICd5JywgMSwgLSAxLCB3aWR0aCwgZGVwdGgsIC0gaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBkZXB0aFNlZ21lbnRzLCAzICk7IC8vIG55XFxyXFxuXFx0XFx0YnVpbGRQbGFuZSggJ3gnLCAneScsICd6JywgMSwgLSAxLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIDQgKTsgLy8gcHpcXHJcXG5cXHRcXHRidWlsZFBsYW5lKCAneCcsICd5JywgJ3onLCAtIDEsIC0gMSwgd2lkdGgsIGhlaWdodCwgLSBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIDUgKTsgLy8gbnpcXHJcXG5cXHJcXG5cXHRcXHQvLyBidWlsZCBnZW9tZXRyeVxcclxcblxcclxcblxcdFxcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcXHJcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcXHJcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcXHJcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gYnVpbGRQbGFuZSggdSwgdiwgdywgdWRpciwgdmRpciwgd2lkdGgsIGhlaWdodCwgZGVwdGgsIGdyaWRYLCBncmlkWSwgbWF0ZXJpYWxJbmRleCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgc2VnbWVudFdpZHRoID0gd2lkdGggLyBncmlkWDtcXHJcXG5cXHRcXHRcXHR2YXIgc2VnbWVudEhlaWdodCA9IGhlaWdodCAvIGdyaWRZO1xcclxcblxcclxcblxcdFxcdFxcdHZhciB3aWR0aEhhbGYgPSB3aWR0aCAvIDI7XFxyXFxuXFx0XFx0XFx0dmFyIGhlaWdodEhhbGYgPSBoZWlnaHQgLyAyO1xcclxcblxcdFxcdFxcdHZhciBkZXB0aEhhbGYgPSBkZXB0aCAvIDI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGdyaWRYMSA9IGdyaWRYICsgMTtcXHJcXG5cXHRcXHRcXHR2YXIgZ3JpZFkxID0gZ3JpZFkgKyAxO1xcclxcblxcclxcblxcdFxcdFxcdHZhciB2ZXJ0ZXhDb3VudGVyID0gMDtcXHJcXG5cXHRcXHRcXHR2YXIgZ3JvdXBDb3VudCA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGl4LCBpeTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggaXkgPSAwOyBpeSA8IGdyaWRZMTsgaXkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHkgPSBpeSAqIHNlZ21lbnRIZWlnaHQgLSBoZWlnaHRIYWxmO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIGl4ID0gMDsgaXggPCBncmlkWDE7IGl4ICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciB4ID0gaXggKiBzZWdtZW50V2lkdGggLSB3aWR0aEhhbGY7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gc2V0IHZhbHVlcyB0byBjb3JyZWN0IHZlY3RvciBjb21wb25lbnRcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2ZWN0b3JbIHUgXSA9IHggKiB1ZGlyO1xcclxcblxcdFxcdFxcdFxcdFxcdHZlY3RvclsgdiBdID0geSAqIHZkaXI7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmVjdG9yWyB3IF0gPSBkZXB0aEhhbGY7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gbm93IGFwcGx5IHZlY3RvciB0byB2ZXJ0ZXggYnVmZmVyXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmVydGljZXMucHVzaCggdmVjdG9yLngsIHZlY3Rvci55LCB2ZWN0b3IueiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIHNldCB2YWx1ZXMgdG8gY29ycmVjdCB2ZWN0b3IgY29tcG9uZW50XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmVjdG9yWyB1IF0gPSAwO1xcclxcblxcdFxcdFxcdFxcdFxcdHZlY3RvclsgdiBdID0gMDtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2ZWN0b3JbIHcgXSA9IGRlcHRoID4gMCA/IDEgOiAtIDE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gbm93IGFwcGx5IHZlY3RvciB0byBub3JtYWwgYnVmZmVyXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0bm9ybWFscy5wdXNoKCB2ZWN0b3IueCwgdmVjdG9yLnksIHZlY3Rvci56ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdXZzXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dXZzLnB1c2goIGl4IC8gZ3JpZFggKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR1dnMucHVzaCggMSAtICggaXkgLyBncmlkWSApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gY291bnRlcnNcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0ZXhDb3VudGVyICs9IDE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBpbmRpY2VzXFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gMS4geW91IG5lZWQgdGhyZWUgaW5kaWNlcyB0byBkcmF3IGEgc2luZ2xlIGZhY2VcXHJcXG5cXHRcXHRcXHQvLyAyLiBhIHNpbmdsZSBzZWdtZW50IGNvbnNpc3RzIG9mIHR3byBmYWNlc1xcclxcblxcdFxcdFxcdC8vIDMuIHNvIHdlIG5lZWQgdG8gZ2VuZXJhdGUgc2l4ICgyKjMpIGluZGljZXMgcGVyIHNlZ21lbnRcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCBpeSA9IDA7IGl5IDwgZ3JpZFk7IGl5ICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIGl4ID0gMDsgaXggPCBncmlkWDsgaXggKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGEgPSBudW1iZXJPZlZlcnRpY2VzICsgaXggKyBncmlkWDEgKiBpeTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgYiA9IG51bWJlck9mVmVydGljZXMgKyBpeCArIGdyaWRYMSAqICggaXkgKyAxICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGMgPSBudW1iZXJPZlZlcnRpY2VzICsgKCBpeCArIDEgKSArIGdyaWRYMSAqICggaXkgKyAxICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGQgPSBudW1iZXJPZlZlcnRpY2VzICsgKCBpeCArIDEgKSArIGdyaWRYMSAqIGl5O1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIGZhY2VzXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0aW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gaW5jcmVhc2UgY291bnRlclxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGdyb3VwQ291bnQgKz0gNjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdC8vIGFkZCBhIGdyb3VwIHRvIHRoZSBnZW9tZXRyeS4gdGhpcyB3aWxsIGVuc3VyZSBtdWx0aSBtYXRlcmlhbCBzdXBwb3J0XFxyXFxuXFxyXFxuXFx0XFx0XFx0c2NvcGUuYWRkR3JvdXAoIGdyb3VwU3RhcnQsIGdyb3VwQ291bnQsIG1hdGVyaWFsSW5kZXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBjYWxjdWxhdGUgbmV3IHN0YXJ0IHZhbHVlIGZvciBncm91cHNcXHJcXG5cXHJcXG5cXHRcXHRcXHRncm91cFN0YXJ0ICs9IGdyb3VwQ291bnQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gdXBkYXRlIHRvdGFsIG51bWJlciBvZiB2ZXJ0aWNlc1xcclxcblxcclxcblxcdFxcdFxcdG51bWJlck9mVmVydGljZXMgKz0gdmVydGV4Q291bnRlcjtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdEJveEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xcclxcblxcdEJveEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJveEJ1ZmZlckdlb21ldHJ5O1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHQvLyBQbGFuZUdlb21ldHJ5XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gUGxhbmVHZW9tZXRyeSggd2lkdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdQbGFuZUdlb21ldHJ5JztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxyXFxuXFx0XFx0XFx0d2lkdGg6IHdpZHRoLFxcclxcblxcdFxcdFxcdGhlaWdodDogaGVpZ2h0LFxcclxcblxcdFxcdFxcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXFxyXFxuXFx0XFx0XFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IFBsYW5lQnVmZmVyR2VvbWV0cnkoIHdpZHRoLCBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzICkgKTtcXHJcXG5cXHRcXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0UGxhbmVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcXHJcXG5cXHRQbGFuZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBsYW5lR2VvbWV0cnk7XFxyXFxuXFxyXFxuXFx0Ly8gUGxhbmVCdWZmZXJHZW9tZXRyeVxcclxcblxcclxcblxcdGZ1bmN0aW9uIFBsYW5lQnVmZmVyR2VvbWV0cnkoIHdpZHRoLCBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzICkge1xcclxcblxcclxcblxcdFxcdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnUGxhbmVCdWZmZXJHZW9tZXRyeSc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcclxcblxcdFxcdFxcdHdpZHRoOiB3aWR0aCxcXHJcXG5cXHRcXHRcXHRoZWlnaHQ6IGhlaWdodCxcXHJcXG5cXHRcXHRcXHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxcclxcblxcdFxcdFxcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50c1xcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0d2lkdGggPSB3aWR0aCB8fCAxO1xcclxcblxcdFxcdGhlaWdodCA9IGhlaWdodCB8fCAxO1xcclxcblxcclxcblxcdFxcdHZhciB3aWR0aF9oYWxmID0gd2lkdGggLyAyO1xcclxcblxcdFxcdHZhciBoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDI7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGdyaWRYID0gTWF0aC5mbG9vciggd2lkdGhTZWdtZW50cyApIHx8IDE7XFxyXFxuXFx0XFx0dmFyIGdyaWRZID0gTWF0aC5mbG9vciggaGVpZ2h0U2VnbWVudHMgKSB8fCAxO1xcclxcblxcclxcblxcdFxcdHZhciBncmlkWDEgPSBncmlkWCArIDE7XFxyXFxuXFx0XFx0dmFyIGdyaWRZMSA9IGdyaWRZICsgMTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgc2VnbWVudF93aWR0aCA9IHdpZHRoIC8gZ3JpZFg7XFxyXFxuXFx0XFx0dmFyIHNlZ21lbnRfaGVpZ2h0ID0gaGVpZ2h0IC8gZ3JpZFk7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGl4LCBpeTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBidWZmZXJzXFxyXFxuXFxyXFxuXFx0XFx0dmFyIGluZGljZXMgPSBbXTtcXHJcXG5cXHRcXHR2YXIgdmVydGljZXMgPSBbXTtcXHJcXG5cXHRcXHR2YXIgbm9ybWFscyA9IFtdO1xcclxcblxcdFxcdHZhciB1dnMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXFxyXFxuXFxyXFxuXFx0XFx0Zm9yICggaXkgPSAwOyBpeSA8IGdyaWRZMTsgaXkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHkgPSBpeSAqIHNlZ21lbnRfaGVpZ2h0IC0gaGVpZ2h0X2hhbGY7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggaXggPSAwOyBpeCA8IGdyaWRYMTsgaXggKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHggPSBpeCAqIHNlZ21lbnRfd2lkdGggLSB3aWR0aF9oYWxmO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIHgsIC0geSwgMCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdG5vcm1hbHMucHVzaCggMCwgMCwgMSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHV2cy5wdXNoKCBpeCAvIGdyaWRYICk7XFxyXFxuXFx0XFx0XFx0XFx0dXZzLnB1c2goIDEgLSAoIGl5IC8gZ3JpZFkgKSApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0Ly8gaW5kaWNlc1xcclxcblxcclxcblxcdFxcdGZvciAoIGl5ID0gMDsgaXkgPCBncmlkWTsgaXkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggaXggPSAwOyBpeCA8IGdyaWRYOyBpeCArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgYSA9IGl4ICsgZ3JpZFgxICogaXk7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGIgPSBpeCArIGdyaWRYMSAqICggaXkgKyAxICk7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGMgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogKCBpeSArIDEgKTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgZCA9ICggaXggKyAxICkgKyBncmlkWDEgKiBpeTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBmYWNlc1xcclxcblxcclxcblxcdFxcdFxcdFxcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xcclxcblxcdFxcdFxcdFxcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0Ly8gYnVpbGQgZ2VvbWV0cnlcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XFxyXFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XFxyXFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XFxyXFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRQbGFuZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xcclxcblxcdFBsYW5lQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGxhbmVCdWZmZXJHZW9tZXRyeTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBwYXJhbWV0ZXJzID0ge1xcclxcblxcdCAqICBjb2xvcjogPGhleD4sXFxyXFxuXFx0ICogIG9wYWNpdHk6IDxmbG9hdD4sXFxyXFxuXFx0ICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXHJcXG5cXHQgKlxcclxcblxcdCAqICBsaWdodE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXHJcXG5cXHQgKiAgbGlnaHRNYXBJbnRlbnNpdHk6IDxmbG9hdD5cXHJcXG5cXHQgKlxcclxcblxcdCAqICBhb01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXHJcXG5cXHQgKiAgYW9NYXBJbnRlbnNpdHk6IDxmbG9hdD5cXHJcXG5cXHQgKlxcclxcblxcdCAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXHJcXG5cXHQgKlxcclxcblxcdCAqICBhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXHJcXG5cXHQgKlxcclxcblxcdCAqICBlbnZNYXA6IG5ldyBUSFJFRS5UZXh0dXJlQ3ViZSggW3Bvc3gsIG5lZ3gsIHBvc3ksIG5lZ3ksIHBvc3osIG5lZ3pdICksXFxyXFxuXFx0ICogIGNvbWJpbmU6IFRIUkVFLk11bHRpcGx5LFxcclxcblxcdCAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXFxyXFxuXFx0ICogIHJlZnJhY3Rpb25SYXRpbzogPGZsb2F0PixcXHJcXG5cXHQgKlxcclxcblxcdCAqICBkZXB0aFRlc3Q6IDxib29sPixcXHJcXG5cXHQgKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxcclxcblxcdCAqXFxyXFxuXFx0ICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxcclxcblxcdCAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiAgc2tpbm5pbmc6IDxib29sPixcXHJcXG5cXHQgKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD5cXHJcXG5cXHQgKiB9XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gTWVzaEJhc2ljTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0TWF0ZXJpYWwuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdNZXNoQmFzaWNNYXRlcmlhbCc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTsgLy8gZW1pc3NpdmVcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm1hcCA9IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5saWdodE1hcCA9IG51bGw7XFxyXFxuXFx0XFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmFvTWFwID0gbnVsbDtcXHJcXG5cXHRcXHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gMS4wO1xcclxcblxcclxcblxcdFxcdHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xcclxcblxcclxcblxcdFxcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xcclxcblxcclxcblxcdFxcdHRoaXMuZW52TWFwID0gbnVsbDtcXHJcXG5cXHRcXHR0aGlzLmNvbWJpbmUgPSBNdWx0aXBseU9wZXJhdGlvbjtcXHJcXG5cXHRcXHR0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XFxyXFxuXFx0XFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xcclxcblxcclxcblxcdFxcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XFxyXFxuXFx0XFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xcclxcblxcdFxcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XFxyXFxuXFx0XFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xcclxcblxcdFxcdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5saWdodHMgPSBmYWxzZTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRNZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXRlcmlhbC5wcm90b3R5cGUgKTtcXHJcXG5cXHRNZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNZXNoQmFzaWNNYXRlcmlhbDtcXHJcXG5cXHJcXG5cXHRNZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuaXNNZXNoQmFzaWNNYXRlcmlhbCA9IHRydWU7XFxyXFxuXFxyXFxuXFx0TWVzaEJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xcclxcblxcclxcblxcdFxcdHRoaXMubWFwID0gc291cmNlLm1hcDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmxpZ2h0TWFwID0gc291cmNlLmxpZ2h0TWFwO1xcclxcblxcdFxcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSBzb3VyY2UubGlnaHRNYXBJbnRlbnNpdHk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcXHJcXG5cXHRcXHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xcclxcblxcclxcblxcdFxcdHRoaXMuc3BlY3VsYXJNYXAgPSBzb3VyY2Uuc3BlY3VsYXJNYXA7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XFxyXFxuXFx0XFx0dGhpcy5jb21iaW5lID0gc291cmNlLmNvbWJpbmU7XFxyXFxuXFx0XFx0dGhpcy5yZWZsZWN0aXZpdHkgPSBzb3VyY2UucmVmbGVjdGl2aXR5O1xcclxcblxcdFxcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gc291cmNlLnJlZnJhY3Rpb25SYXRpbztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XFxyXFxuXFx0XFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xcclxcblxcdFxcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xcclxcblxcdFxcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcXHJcXG5cXHRcXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcclxcblxcdCAqXFxyXFxuXFx0ICogcGFyYW1ldGVycyA9IHtcXHJcXG5cXHQgKiAgZGVmaW5lczogeyBcXFwibGFiZWxcXFwiIDogXFxcInZhbHVlXFxcIiB9LFxcclxcblxcdCAqICB1bmlmb3JtczogeyBcXFwicGFyYW1ldGVyMVxcXCI6IHsgdmFsdWU6IDEuMCB9LCBcXFwicGFyYW1ldGVyMlxcXCI6IHsgdmFsdWUyOiAyIH0gfSxcXHJcXG5cXHQgKlxcclxcblxcdCAqICBmcmFnbWVudFNoYWRlcjogPHN0cmluZz4sXFxyXFxuXFx0ICogIHZlcnRleFNoYWRlcjogPHN0cmluZz4sXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXFxyXFxuXFx0ICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcXHJcXG5cXHQgKlxcclxcblxcdCAqICBsaWdodHM6IDxib29sPixcXHJcXG5cXHQgKlxcclxcblxcdCAqICBza2lubmluZzogPGJvb2w+LFxcclxcblxcdCAqICBtb3JwaFRhcmdldHM6IDxib29sPixcXHJcXG5cXHQgKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD5cXHJcXG5cXHQgKiB9XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gU2hhZGVyTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0TWF0ZXJpYWwuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdTaGFkZXJNYXRlcmlhbCc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5kZWZpbmVzID0ge307XFxyXFxuXFx0XFx0dGhpcy51bmlmb3JtcyA9IHt9O1xcclxcblxcclxcblxcdFxcdHRoaXMudmVydGV4U2hhZGVyID0gJ3ZvaWQgbWFpbigpIHtcXFxcblxcXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcXFxufSc7XFxyXFxuXFx0XFx0dGhpcy5mcmFnbWVudFNoYWRlciA9ICd2b2lkIG1haW4oKSB7XFxcXG5cXFxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIDEuMCwgMC4wLCAwLjAsIDEuMCApO1xcXFxufSc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5saW5ld2lkdGggPSAxO1xcclxcblxcclxcblxcdFxcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XFxyXFxuXFx0XFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xcclxcblxcclxcblxcdFxcdHRoaXMuZm9nID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2NlbmUgZm9nXFxyXFxuXFx0XFx0dGhpcy5saWdodHMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBzY2VuZSBsaWdodHNcXHJcXG5cXHRcXHR0aGlzLmNsaXBwaW5nID0gZmFsc2U7IC8vIHNldCB0byB1c2UgdXNlci1kZWZpbmVkIGNsaXBwaW5nIHBsYW5lc1xcclxcblxcclxcblxcdFxcdHRoaXMuc2tpbm5pbmcgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBza2lubmluZyBhdHRyaWJ1dGUgc3RyZWFtc1xcclxcblxcdFxcdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7IC8vIHNldCB0byB1c2UgbW9ycGggdGFyZ2V0c1xcclxcblxcdFxcdHRoaXMubW9ycGhOb3JtYWxzID0gZmFsc2U7IC8vIHNldCB0byB1c2UgbW9ycGggbm9ybWFsc1xcclxcblxcclxcblxcdFxcdHRoaXMuZXh0ZW5zaW9ucyA9IHtcXHJcXG5cXHRcXHRcXHRkZXJpdmF0aXZlczogZmFsc2UsIC8vIHNldCB0byB1c2UgZGVyaXZhdGl2ZXNcXHJcXG5cXHRcXHRcXHRmcmFnRGVwdGg6IGZhbHNlLCAvLyBzZXQgdG8gdXNlIGZyYWdtZW50IGRlcHRoIHZhbHVlc1xcclxcblxcdFxcdFxcdGRyYXdCdWZmZXJzOiBmYWxzZSwgLy8gc2V0IHRvIHVzZSBkcmF3IGJ1ZmZlcnNcXHJcXG5cXHRcXHRcXHRzaGFkZXJUZXh0dXJlTE9EOiBmYWxzZSAvLyBzZXQgdG8gdXNlIHNoYWRlciB0ZXh0dXJlIExPRFxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0Ly8gV2hlbiByZW5kZXJlZCBnZW9tZXRyeSBkb2Vzbid0IGluY2x1ZGUgdGhlc2UgYXR0cmlidXRlcyBidXQgdGhlIG1hdGVyaWFsIGRvZXMsXFxyXFxuXFx0XFx0Ly8gdXNlIHRoZXNlIGRlZmF1bHQgdmFsdWVzIGluIFdlYkdMLiBUaGlzIGF2b2lkcyBlcnJvcnMgd2hlbiBidWZmZXIgZGF0YSBpcyBtaXNzaW5nLlxcclxcblxcdFxcdHRoaXMuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyA9IHtcXHJcXG5cXHRcXHRcXHQnY29sb3InOiBbIDEsIDEsIDEgXSxcXHJcXG5cXHRcXHRcXHQndXYnOiBbIDAsIDAgXSxcXHJcXG5cXHRcXHRcXHQndXYyJzogWyAwLCAwIF1cXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdFxcdHRoaXMuaW5kZXgwQXR0cmlidXRlTmFtZSA9IHVuZGVmaW5lZDtcXHJcXG5cXHJcXG5cXHRcXHRpZiAoIHBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHBhcmFtZXRlcnMuYXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5TaGFkZXJNYXRlcmlhbDogYXR0cmlidXRlcyBzaG91bGQgbm93IGJlIGRlZmluZWQgaW4gVEhSRUUuQnVmZmVyR2VvbWV0cnkgaW5zdGVhZC4nICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXRlcmlhbC5wcm90b3R5cGUgKTtcXHJcXG5cXHRTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTaGFkZXJNYXRlcmlhbDtcXHJcXG5cXHJcXG5cXHRTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuaXNTaGFkZXJNYXRlcmlhbCA9IHRydWU7XFxyXFxuXFxyXFxuXFx0U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmZyYWdtZW50U2hhZGVyID0gc291cmNlLmZyYWdtZW50U2hhZGVyO1xcclxcblxcdFxcdHRoaXMudmVydGV4U2hhZGVyID0gc291cmNlLnZlcnRleFNoYWRlcjtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnVuaWZvcm1zID0gVW5pZm9ybXNVdGlscy5jbG9uZSggc291cmNlLnVuaWZvcm1zICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5kZWZpbmVzID0gc291cmNlLmRlZmluZXM7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xcclxcblxcdFxcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmxpZ2h0cyA9IHNvdXJjZS5saWdodHM7XFxyXFxuXFx0XFx0dGhpcy5jbGlwcGluZyA9IHNvdXJjZS5jbGlwcGluZztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xcclxcblxcclxcblxcdFxcdHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcXHJcXG5cXHRcXHR0aGlzLm1vcnBoTm9ybWFscyA9IHNvdXJjZS5tb3JwaE5vcm1hbHM7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5leHRlbnNpb25zID0gc291cmNlLmV4dGVuc2lvbnM7XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHRTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCBtZXRhICkge1xcclxcblxcclxcblxcdFxcdHZhciBkYXRhID0gTWF0ZXJpYWwucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XFxyXFxuXFxyXFxuXFx0XFx0ZGF0YS51bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7XFxyXFxuXFx0XFx0ZGF0YS52ZXJ0ZXhTaGFkZXIgPSB0aGlzLnZlcnRleFNoYWRlcjtcXHJcXG5cXHRcXHRkYXRhLmZyYWdtZW50U2hhZGVyID0gdGhpcy5mcmFnbWVudFNoYWRlcjtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gZGF0YTtcXHJcXG5cXHJcXG5cXHR9O1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBSYXkoIG9yaWdpbiwgZGlyZWN0aW9uICkge1xcclxcblxcclxcblxcdFxcdHRoaXMub3JpZ2luID0gKCBvcmlnaW4gIT09IHVuZGVmaW5lZCApID8gb3JpZ2luIDogbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHRcXHR0aGlzLmRpcmVjdGlvbiA9ICggZGlyZWN0aW9uICE9PSB1bmRlZmluZWQgKSA/IGRpcmVjdGlvbiA6IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIFJheS5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uICggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5vcmlnaW4uY29weSggb3JpZ2luICk7XFxyXFxuXFx0XFx0XFx0dGhpcy5kaXJlY3Rpb24uY29weSggZGlyZWN0aW9uICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggcmF5ICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMub3JpZ2luLmNvcHkoIHJheS5vcmlnaW4gKTtcXHJcXG5cXHRcXHRcXHR0aGlzLmRpcmVjdGlvbi5jb3B5KCByYXkuZGlyZWN0aW9uICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRhdDogZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMub3JpZ2luICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRsb29rQXQ6IGZ1bmN0aW9uICggdiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmRpcmVjdGlvbi5jb3B5KCB2ICkuc3ViKCB0aGlzLm9yaWdpbiApLm5vcm1hbGl6ZSgpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0cmVjYXN0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gcmVjYXN0KCB0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMub3JpZ2luLmNvcHkoIHRoaXMuYXQoIHQsIHYxICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0oKSxcXHJcXG5cXHJcXG5cXHRcXHRjbG9zZXN0UG9pbnRUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHRcXHRcXHRyZXN1bHQuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMub3JpZ2luICk7XFxyXFxuXFx0XFx0XFx0dmFyIGRpcmVjdGlvbkRpc3RhbmNlID0gcmVzdWx0LmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGRpcmVjdGlvbkRpc3RhbmNlIDwgMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMub3JpZ2luICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiByZXN1bHQuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggZGlyZWN0aW9uRGlzdGFuY2UgKS5hZGQoIHRoaXMub3JpZ2luICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVNxVG9Qb2ludCggcG9pbnQgKSApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0ZGlzdGFuY2VTcVRvUG9pbnQ6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBkaXN0YW5jZVNxVG9Qb2ludCggcG9pbnQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGRpcmVjdGlvbkRpc3RhbmNlID0gdjEuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMub3JpZ2luICkuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIHBvaW50IGJlaGluZCB0aGUgcmF5XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBkaXJlY3Rpb25EaXN0YW5jZSA8IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMub3JpZ2luLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2MS5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCBkaXJlY3Rpb25EaXN0YW5jZSApLmFkZCggdGhpcy5vcmlnaW4gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdjEuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR9KCksXFxyXFxuXFxyXFxuXFx0XFx0ZGlzdGFuY2VTcVRvU2VnbWVudDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBzZWdDZW50ZXIgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdFxcdHZhciBzZWdEaXIgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdFxcdHZhciBkaWZmID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gZGlzdGFuY2VTcVRvU2VnbWVudCggdjAsIHYxLCBvcHRpb25hbFBvaW50T25SYXksIG9wdGlvbmFsUG9pbnRPblNlZ21lbnQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gZnJvbSBodHRwOi8vd3d3Lmdlb21ldHJpY3Rvb2xzLmNvbS9HVEVuZ2luZS9JbmNsdWRlL01hdGhlbWF0aWNzL0d0ZURpc3RSYXlTZWdtZW50LmhcXHJcXG5cXHRcXHRcXHRcXHQvLyBJdCByZXR1cm5zIHRoZSBtaW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgcmF5IGFuZCB0aGUgc2VnbWVudFxcclxcblxcdFxcdFxcdFxcdC8vIGRlZmluZWQgYnkgdjAgYW5kIHYxXFxyXFxuXFx0XFx0XFx0XFx0Ly8gSXQgY2FuIGFsc28gc2V0IHR3byBvcHRpb25hbCB0YXJnZXRzIDpcXHJcXG5cXHRcXHRcXHRcXHQvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSByYXlcXHJcXG5cXHRcXHRcXHRcXHQvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBzZWdtZW50XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0c2VnQ2VudGVyLmNvcHkoIHYwICkuYWRkKCB2MSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcXHJcXG5cXHRcXHRcXHRcXHRzZWdEaXIuY29weSggdjEgKS5zdWIoIHYwICkubm9ybWFsaXplKCk7XFxyXFxuXFx0XFx0XFx0XFx0ZGlmZi5jb3B5KCB0aGlzLm9yaWdpbiApLnN1Yiggc2VnQ2VudGVyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHNlZ0V4dGVudCA9IHYwLmRpc3RhbmNlVG8oIHYxICkgKiAwLjU7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGEwMSA9IC0gdGhpcy5kaXJlY3Rpb24uZG90KCBzZWdEaXIgKTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgYjAgPSBkaWZmLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgYjEgPSAtIGRpZmYuZG90KCBzZWdEaXIgKTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgYyA9IGRpZmYubGVuZ3RoU3EoKTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgZGV0ID0gTWF0aC5hYnMoIDEgLSBhMDEgKiBhMDEgKTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgczAsIHMxLCBzcXJEaXN0LCBleHREZXQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBkZXQgPiAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIFRoZSByYXkgYW5kIHNlZ21lbnQgYXJlIG5vdCBwYXJhbGxlbC5cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRzMCA9IGEwMSAqIGIxIC0gYjA7XFxyXFxuXFx0XFx0XFx0XFx0XFx0czEgPSBhMDEgKiBiMCAtIGIxO1xcclxcblxcdFxcdFxcdFxcdFxcdGV4dERldCA9IHNlZ0V4dGVudCAqIGRldDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHMwID49IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBzMSA+PSAtIGV4dERldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHMxIDw9IGV4dERldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyByZWdpb24gMFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIE1pbmltdW0gYXQgaW50ZXJpb3IgcG9pbnRzIG9mIHJheSBhbmQgc2VnbWVudC5cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgaW52RGV0ID0gMSAvIGRldDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzMCAqPSBpbnZEZXQ7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0czEgKj0gaW52RGV0O1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHNxckRpc3QgPSBzMCAqICggczAgKyBhMDEgKiBzMSArIDIgKiBiMCApICsgczEgKiAoIGEwMSAqIHMwICsgczEgKyAyICogYjEgKSArIGM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyByZWdpb24gMVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHMxID0gc2VnRXh0ZW50O1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzMSArIGIwICkgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHJlZ2lvbiA1XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0czEgPSAtIHNlZ0V4dGVudDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogczEgKyBiMCApICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHMxIDw9IC0gZXh0RGV0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHJlZ2lvbiA0XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0czAgPSBNYXRoLm1heCggMCwgLSAoIC0gYTAxICogc2VnRXh0ZW50ICsgYjAgKSApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHMxID0gKCBzMCA+IDAgKSA/IC0gc2VnRXh0ZW50IDogTWF0aC5taW4oIE1hdGgubWF4KCAtIHNlZ0V4dGVudCwgLSBiMSApLCBzZWdFeHRlbnQgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIHMxIDw9IGV4dERldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyByZWdpb24gM1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHMwID0gMDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzMSA9IE1hdGgubWluKCBNYXRoLm1heCggLSBzZWdFeHRlbnQsIC0gYjEgKSwgc2VnRXh0ZW50ICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c3FyRGlzdCA9IHMxICogKCBzMSArIDIgKiBiMSApICsgYztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHJlZ2lvbiAyXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHNlZ0V4dGVudCArIGIwICkgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzMSA9ICggczAgPiAwICkgPyBzZWdFeHRlbnQgOiBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIFJheSBhbmQgc2VnbWVudCBhcmUgcGFyYWxsZWwuXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0czEgPSAoIGEwMSA+IDAgKSA/IC0gc2VnRXh0ZW50IDogc2VnRXh0ZW50O1xcclxcblxcdFxcdFxcdFxcdFxcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzMSArIGIwICkgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIG9wdGlvbmFsUG9pbnRPblJheSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRvcHRpb25hbFBvaW50T25SYXkuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggczAgKS5hZGQoIHRoaXMub3JpZ2luICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggb3B0aW9uYWxQb2ludE9uU2VnbWVudCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRvcHRpb25hbFBvaW50T25TZWdtZW50LmNvcHkoIHNlZ0RpciApLm11bHRpcGx5U2NhbGFyKCBzMSApLmFkZCggc2VnQ2VudGVyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiBzcXJEaXN0O1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdGludGVyc2VjdFNwaGVyZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdFNwaGVyZSggc3BoZXJlLCBvcHRpb25hbFRhcmdldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2MS5zdWJWZWN0b3JzKCBzcGhlcmUuY2VudGVyLCB0aGlzLm9yaWdpbiApO1xcclxcblxcdFxcdFxcdFxcdHZhciB0Y2EgPSB2MS5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGQyID0gdjEuZG90KCB2MSApIC0gdGNhICogdGNhO1xcclxcblxcdFxcdFxcdFxcdHZhciByYWRpdXMyID0gc3BoZXJlLnJhZGl1cyAqIHNwaGVyZS5yYWRpdXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBkMiA+IHJhZGl1czIgKSByZXR1cm4gbnVsbDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgdGhjID0gTWF0aC5zcXJ0KCByYWRpdXMyIC0gZDIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyB0MCA9IGZpcnN0IGludGVyc2VjdCBwb2ludCAtIGVudHJhbmNlIG9uIGZyb250IG9mIHNwaGVyZVxcclxcblxcdFxcdFxcdFxcdHZhciB0MCA9IHRjYSAtIHRoYztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyB0MSA9IHNlY29uZCBpbnRlcnNlY3QgcG9pbnQgLSBleGl0IHBvaW50IG9uIGJhY2sgb2Ygc3BoZXJlXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHQxID0gdGNhICsgdGhjO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIHRlc3QgdG8gc2VlIGlmIGJvdGggdDAgYW5kIHQxIGFyZSBiZWhpbmQgdGhlIHJheSAtIGlmIHNvLCByZXR1cm4gbnVsbFxcclxcblxcdFxcdFxcdFxcdGlmICggdDAgPCAwICYmIHQxIDwgMCApIHJldHVybiBudWxsO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIHRlc3QgdG8gc2VlIGlmIHQwIGlzIGJlaGluZCB0aGUgcmF5OlxcclxcblxcdFxcdFxcdFxcdC8vIGlmIGl0IGlzLCB0aGUgcmF5IGlzIGluc2lkZSB0aGUgc3BoZXJlLCBzbyByZXR1cm4gdGhlIHNlY29uZCBleGl0IHBvaW50IHNjYWxlZCBieSB0MSxcXHJcXG5cXHRcXHRcXHRcXHQvLyBpbiBvcmRlciB0byBhbHdheXMgcmV0dXJuIGFuIGludGVyc2VjdCBwb2ludCB0aGF0IGlzIGluIGZyb250IG9mIHRoZSByYXkuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB0MCA8IDAgKSByZXR1cm4gdGhpcy5hdCggdDEsIG9wdGlvbmFsVGFyZ2V0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gZWxzZSB0MCBpcyBpbiBmcm9udCBvZiB0aGUgcmF5LCBzbyByZXR1cm4gdGhlIGZpcnN0IGNvbGxpc2lvbiBwb2ludCBzY2FsZWQgYnkgdDBcXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5hdCggdDAsIG9wdGlvbmFsVGFyZ2V0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR9KCksXFxyXFxuXFxyXFxuXFx0XFx0aW50ZXJzZWN0c1NwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KCBzcGhlcmUuY2VudGVyICkgPD0gc3BoZXJlLnJhZGl1cztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGRpc3RhbmNlVG9QbGFuZTogZnVuY3Rpb24gKCBwbGFuZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgZGVub21pbmF0b3IgPSBwbGFuZS5ub3JtYWwuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggZGVub21pbmF0b3IgPT09IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gbGluZSBpcyBjb3BsYW5hciwgcmV0dXJuIG9yaWdpblxcclxcblxcdFxcdFxcdFxcdGlmICggcGxhbmUuZGlzdGFuY2VUb1BvaW50KCB0aGlzLm9yaWdpbiApID09PSAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHJldHVybiAwO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBOdWxsIGlzIHByZWZlcmFibGUgdG8gdW5kZWZpbmVkIHNpbmNlIHVuZGVmaW5lZCBtZWFucy4uLi4gaXQgaXMgdW5kZWZpbmVkXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHZhciB0ID0gLSAoIHRoaXMub3JpZ2luLmRvdCggcGxhbmUubm9ybWFsICkgKyBwbGFuZS5jb25zdGFudCApIC8gZGVub21pbmF0b3I7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gUmV0dXJuIGlmIHRoZSByYXkgbmV2ZXIgaW50ZXJzZWN0cyB0aGUgcGxhbmVcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdCA+PSAwID8gdCA6IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRpbnRlcnNlY3RQbGFuZTogZnVuY3Rpb24gKCBwbGFuZSwgb3B0aW9uYWxUYXJnZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHQgPSB0aGlzLmRpc3RhbmNlVG9QbGFuZSggcGxhbmUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHQgPT09IG51bGwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmF0KCB0LCBvcHRpb25hbFRhcmdldCApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0aW50ZXJzZWN0c1BsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xcclxcblxcclxcblxcdFxcdFxcdC8vIGNoZWNrIGlmIHRoZSByYXkgbGllcyBvbiB0aGUgcGxhbmUgZmlyc3RcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgZGlzdFRvUG9pbnQgPSBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMub3JpZ2luICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBkaXN0VG9Qb2ludCA9PT0gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGRlbm9taW5hdG9yID0gcGxhbmUubm9ybWFsLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGRlbm9taW5hdG9yICogZGlzdFRvUG9pbnQgPCAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyByYXkgb3JpZ2luIGlzIGJlaGluZCB0aGUgcGxhbmUgKGFuZCBpcyBwb2ludGluZyBiZWhpbmQgaXQpXFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0aW50ZXJzZWN0Qm94OiBmdW5jdGlvbiAoIGJveCwgb3B0aW9uYWxUYXJnZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHRtaW4sIHRtYXgsIHR5bWluLCB0eW1heCwgdHptaW4sIHR6bWF4O1xcclxcblxcclxcblxcdFxcdFxcdHZhciBpbnZkaXJ4ID0gMSAvIHRoaXMuZGlyZWN0aW9uLngsXFxyXFxuXFx0XFx0XFx0XFx0aW52ZGlyeSA9IDEgLyB0aGlzLmRpcmVjdGlvbi55LFxcclxcblxcdFxcdFxcdFxcdGludmRpcnogPSAxIC8gdGhpcy5kaXJlY3Rpb24uejtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgb3JpZ2luID0gdGhpcy5vcmlnaW47XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBpbnZkaXJ4ID49IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dG1pbiA9ICggYm94Lm1pbi54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XFxyXFxuXFx0XFx0XFx0XFx0dG1heCA9ICggYm94Lm1heC54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0bWluID0gKCBib3gubWF4LnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcXHJcXG5cXHRcXHRcXHRcXHR0bWF4ID0gKCBib3gubWluLnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBpbnZkaXJ5ID49IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dHltaW4gPSAoIGJveC5taW4ueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xcclxcblxcdFxcdFxcdFxcdHR5bWF4ID0gKCBib3gubWF4LnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHR5bWluID0gKCBib3gubWF4LnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcXHJcXG5cXHRcXHRcXHRcXHR0eW1heCA9ICggYm94Lm1pbi55IC0gb3JpZ2luLnkgKSAqIGludmRpcnk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggKCB0bWluID4gdHltYXggKSB8fCAoIHR5bWluID4gdG1heCApICkgcmV0dXJuIG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gVGhlc2UgbGluZXMgYWxzbyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdG1pbiBvciB0bWF4IGlzIE5hTlxcclxcblxcdFxcdFxcdC8vIChyZXN1bHQgb2YgMCAqIEluZmluaXR5KS4geCAhPT0geCByZXR1cm5zIHRydWUgaWYgeCBpcyBOYU5cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHR5bWluID4gdG1pbiB8fCB0bWluICE9PSB0bWluICkgdG1pbiA9IHR5bWluO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdHltYXggPCB0bWF4IHx8IHRtYXggIT09IHRtYXggKSB0bWF4ID0gdHltYXg7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBpbnZkaXJ6ID49IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dHptaW4gPSAoIGJveC5taW4ueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xcclxcblxcdFxcdFxcdFxcdHR6bWF4ID0gKCBib3gubWF4LnogLSBvcmlnaW4ueiApICogaW52ZGlyejtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHR6bWluID0gKCBib3gubWF4LnogLSBvcmlnaW4ueiApICogaW52ZGlyejtcXHJcXG5cXHRcXHRcXHRcXHR0em1heCA9ICggYm94Lm1pbi56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggKCB0bWluID4gdHptYXggKSB8fCAoIHR6bWluID4gdG1heCApICkgcmV0dXJuIG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0em1pbiA+IHRtaW4gfHwgdG1pbiAhPT0gdG1pbiApIHRtaW4gPSB0em1pbjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHR6bWF4IDwgdG1heCB8fCB0bWF4ICE9PSB0bWF4ICkgdG1heCA9IHR6bWF4O1xcclxcblxcclxcblxcdFxcdFxcdC8vcmV0dXJuIHBvaW50IGNsb3Nlc3QgdG8gdGhlIHJheSAocG9zaXRpdmUgc2lkZSlcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRtYXggPCAwICkgcmV0dXJuIG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuYXQoIHRtaW4gPj0gMCA/IHRtaW4gOiB0bWF4LCBvcHRpb25hbFRhcmdldCApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0aW50ZXJzZWN0c0JveDogKCBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHYgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RzQm94KCBib3ggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0Qm94KCBib3gsIHYgKSAhPT0gbnVsbDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0gKSgpLFxcclxcblxcclxcblxcdFxcdGludGVyc2VjdFRyaWFuZ2xlOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gQ29tcHV0ZSB0aGUgb2Zmc2V0IG9yaWdpbiwgZWRnZXMsIGFuZCBub3JtYWwuXFxyXFxuXFx0XFx0XFx0dmFyIGRpZmYgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdFxcdHZhciBlZGdlMSA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0XFx0dmFyIGVkZ2UyID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHRcXHRcXHR2YXIgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0VHJpYW5nbGUoIGEsIGIsIGMsIGJhY2tmYWNlQ3VsbGluZywgb3B0aW9uYWxUYXJnZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gZnJvbSBodHRwOi8vd3d3Lmdlb21ldHJpY3Rvb2xzLmNvbS9HVEVuZ2luZS9JbmNsdWRlL01hdGhlbWF0aWNzL0d0ZUludHJSYXkzVHJpYW5nbGUzLmhcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRlZGdlMS5zdWJWZWN0b3JzKCBiLCBhICk7XFxyXFxuXFx0XFx0XFx0XFx0ZWRnZTIuc3ViVmVjdG9ycyggYywgYSApO1xcclxcblxcdFxcdFxcdFxcdG5vcm1hbC5jcm9zc1ZlY3RvcnMoIGVkZ2UxLCBlZGdlMiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIFNvbHZlIFEgKyB0KkQgPSBiMSpFMSArIGIyKkUyIChRID0ga0RpZmYsIEQgPSByYXkgZGlyZWN0aW9uLFxcclxcblxcdFxcdFxcdFxcdC8vIEUxID0ga0VkZ2UxLCBFMiA9IGtFZGdlMiwgTiA9IENyb3NzKEUxLEUyKSkgYnlcXHJcXG5cXHRcXHRcXHRcXHQvLyAgIHxEb3QoRCxOKXwqYjEgPSBzaWduKERvdChELE4pKSpEb3QoRCxDcm9zcyhRLEUyKSlcXHJcXG5cXHRcXHRcXHRcXHQvLyAgIHxEb3QoRCxOKXwqYjIgPSBzaWduKERvdChELE4pKSpEb3QoRCxDcm9zcyhFMSxRKSlcXHJcXG5cXHRcXHRcXHRcXHQvLyAgIHxEb3QoRCxOKXwqdCA9IC1zaWduKERvdChELE4pKSpEb3QoUSxOKVxcclxcblxcdFxcdFxcdFxcdHZhciBEZE4gPSB0aGlzLmRpcmVjdGlvbi5kb3QoIG5vcm1hbCApO1xcclxcblxcdFxcdFxcdFxcdHZhciBzaWduO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggRGROID4gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGJhY2tmYWNlQ3VsbGluZyApIHJldHVybiBudWxsO1xcclxcblxcdFxcdFxcdFxcdFxcdHNpZ24gPSAxO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIERkTiA8IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0c2lnbiA9IC0gMTtcXHJcXG5cXHRcXHRcXHRcXHRcXHREZE4gPSAtIERkTjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBudWxsO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRkaWZmLnN1YlZlY3RvcnMoIHRoaXMub3JpZ2luLCBhICk7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIERkUXhFMiA9IHNpZ24gKiB0aGlzLmRpcmVjdGlvbi5kb3QoIGVkZ2UyLmNyb3NzVmVjdG9ycyggZGlmZiwgZWRnZTIgKSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGIxIDwgMCwgbm8gaW50ZXJzZWN0aW9uXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBEZFF4RTIgPCAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBudWxsO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgRGRFMXhRID0gc2lnbiAqIHRoaXMuZGlyZWN0aW9uLmRvdCggZWRnZTEuY3Jvc3MoIGRpZmYgKSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGIyIDwgMCwgbm8gaW50ZXJzZWN0aW9uXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBEZEUxeFEgPCAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBudWxsO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBiMStiMiA+IDEsIG5vIGludGVyc2VjdGlvblxcclxcblxcdFxcdFxcdFxcdGlmICggRGRReEUyICsgRGRFMXhRID4gRGROICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBudWxsO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBMaW5lIGludGVyc2VjdHMgdHJpYW5nbGUsIGNoZWNrIGlmIHJheSBkb2VzLlxcclxcblxcdFxcdFxcdFxcdHZhciBRZE4gPSAtIHNpZ24gKiBkaWZmLmRvdCggbm9ybWFsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gdCA8IDAsIG5vIGludGVyc2VjdGlvblxcclxcblxcdFxcdFxcdFxcdGlmICggUWROIDwgMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gbnVsbDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gUmF5IGludGVyc2VjdHMgdHJpYW5nbGUuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuYXQoIFFkTiAvIERkTiwgb3B0aW9uYWxUYXJnZXQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0oKSxcXHJcXG5cXHJcXG5cXHRcXHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbWF0cml4NCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm9yaWdpbi5hcHBseU1hdHJpeDQoIG1hdHJpeDQgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24oIG1hdHJpeDQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGVxdWFsczogZnVuY3Rpb24gKCByYXkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHJheS5vcmlnaW4uZXF1YWxzKCB0aGlzLm9yaWdpbiApICYmIHJheS5kaXJlY3Rpb24uZXF1YWxzKCB0aGlzLmRpcmVjdGlvbiApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIExpbmUzKCBzdGFydCwgZW5kICkge1xcclxcblxcclxcblxcdFxcdHRoaXMuc3RhcnQgPSAoIHN0YXJ0ICE9PSB1bmRlZmluZWQgKSA/IHN0YXJ0IDogbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHRcXHR0aGlzLmVuZCA9ICggZW5kICE9PSB1bmRlZmluZWQgKSA/IGVuZCA6IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIExpbmUzLnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdHNldDogZnVuY3Rpb24gKCBzdGFydCwgZW5kICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuc3RhcnQuY29weSggc3RhcnQgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLmVuZC5jb3B5KCBlbmQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBsaW5lICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuc3RhcnQuY29weSggbGluZS5zdGFydCApO1xcclxcblxcdFxcdFxcdHRoaXMuZW5kLmNvcHkoIGxpbmUuZW5kICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGRlbHRhOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdFxcdHJldHVybiByZXN1bHQuc3ViVmVjdG9ycyggdGhpcy5lbmQsIHRoaXMuc3RhcnQgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGRpc3RhbmNlU3E6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5zdGFydC5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5lbmQgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGRpc3RhbmNlOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2VUbyggdGhpcy5lbmQgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGF0OiBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmRlbHRhKCByZXN1bHQgKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy5zdGFydCApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y2xvc2VzdFBvaW50VG9Qb2ludFBhcmFtZXRlcjogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBzdGFydFAgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdFxcdHZhciBzdGFydEVuZCA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGNsb3Nlc3RQb2ludFRvUG9pbnRQYXJhbWV0ZXIoIHBvaW50LCBjbGFtcFRvTGluZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzdGFydFAuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMuc3RhcnQgKTtcXHJcXG5cXHRcXHRcXHRcXHRzdGFydEVuZC5zdWJWZWN0b3JzKCB0aGlzLmVuZCwgdGhpcy5zdGFydCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBzdGFydEVuZDIgPSBzdGFydEVuZC5kb3QoIHN0YXJ0RW5kICk7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIHN0YXJ0RW5kX3N0YXJ0UCA9IHN0YXJ0RW5kLmRvdCggc3RhcnRQICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHQgPSBzdGFydEVuZF9zdGFydFAgLyBzdGFydEVuZDI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBjbGFtcFRvTGluZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0ID0gX01hdGguY2xhbXAoIHQsIDAsIDEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR9KCksXFxyXFxuXFxyXFxuXFx0XFx0Y2xvc2VzdFBvaW50VG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCwgY2xhbXBUb0xpbmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB0ID0gdGhpcy5jbG9zZXN0UG9pbnRUb1BvaW50UGFyYW1ldGVyKCBwb2ludCwgY2xhbXBUb0xpbmUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5kZWx0YSggcmVzdWx0ICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMuc3RhcnQgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5zdGFydC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xcclxcblxcdFxcdFxcdHRoaXMuZW5kLmFwcGx5TWF0cml4NCggbWF0cml4ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRlcXVhbHM6IGZ1bmN0aW9uICggbGluZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gbGluZS5zdGFydC5lcXVhbHMoIHRoaXMuc3RhcnQgKSAmJiBsaW5lLmVuZC5lcXVhbHMoIHRoaXMuZW5kICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBUcmlhbmdsZSggYSwgYiwgYyApIHtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmEgPSAoIGEgIT09IHVuZGVmaW5lZCApID8gYSA6IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0dGhpcy5iID0gKCBiICE9PSB1bmRlZmluZWQgKSA/IGIgOiBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdHRoaXMuYyA9ICggYyAhPT0gdW5kZWZpbmVkICkgPyBjIDogbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0T2JqZWN0LmFzc2lnbiggVHJpYW5nbGUsIHtcXHJcXG5cXHJcXG5cXHRcXHRub3JtYWw6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdjAgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBub3JtYWwoIGEsIGIsIGMsIG9wdGlvbmFsVGFyZ2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJlc3VsdC5zdWJWZWN0b3JzKCBjLCBiICk7XFxyXFxuXFx0XFx0XFx0XFx0djAuc3ViVmVjdG9ycyggYSwgYiApO1xcclxcblxcdFxcdFxcdFxcdHJlc3VsdC5jcm9zcyggdjAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgcmVzdWx0TGVuZ3RoU3EgPSByZXN1bHQubGVuZ3RoU3EoKTtcXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHJlc3VsdExlbmd0aFNxID4gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0Lm11bHRpcGx5U2NhbGFyKCAxIC8gTWF0aC5zcXJ0KCByZXN1bHRMZW5ndGhTcSApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiByZXN1bHQuc2V0KCAwLCAwLCAwICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR9KCksXFxyXFxuXFxyXFxuXFx0XFx0Ly8gc3RhdGljL2luc3RhbmNlIG1ldGhvZCB0byBjYWxjdWxhdGUgYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXNcXHJcXG5cXHRcXHQvLyBiYXNlZCBvbjogaHR0cDovL3d3dy5ibGFja3Bhd24uY29tL3RleHRzL3BvaW50aW5wb2x5L2RlZmF1bHQuaHRtbFxcclxcblxcdFxcdGJhcnljb29yZEZyb21Qb2ludDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB2MCA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHRcXHRcXHR2YXIgdjIgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBiYXJ5Y29vcmRGcm9tUG9pbnQoIHBvaW50LCBhLCBiLCBjLCBvcHRpb25hbFRhcmdldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2MC5zdWJWZWN0b3JzKCBjLCBhICk7XFxyXFxuXFx0XFx0XFx0XFx0djEuc3ViVmVjdG9ycyggYiwgYSApO1xcclxcblxcdFxcdFxcdFxcdHYyLnN1YlZlY3RvcnMoIHBvaW50LCBhICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGRvdDAwID0gdjAuZG90KCB2MCApO1xcclxcblxcdFxcdFxcdFxcdHZhciBkb3QwMSA9IHYwLmRvdCggdjEgKTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgZG90MDIgPSB2MC5kb3QoIHYyICk7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGRvdDExID0gdjEuZG90KCB2MSApO1xcclxcblxcdFxcdFxcdFxcdHZhciBkb3QxMiA9IHYxLmRvdCggdjIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgZGVub20gPSAoIGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gY29sbGluZWFyIG9yIHNpbmd1bGFyIHRyaWFuZ2xlXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBkZW5vbSA9PT0gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBhcmJpdHJhcnkgbG9jYXRpb24gb3V0c2lkZSBvZiB0cmlhbmdsZT9cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBub3Qgc3VyZSBpZiB0aGlzIGlzIHRoZSBiZXN0IGlkZWEsIG1heWJlIHNob3VsZCBiZSByZXR1cm5pbmcgdW5kZWZpbmVkXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdC5zZXQoIC0gMiwgLSAxLCAtIDEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGludkRlbm9tID0gMSAvIGRlbm9tO1xcclxcblxcdFxcdFxcdFxcdHZhciB1ID0gKCBkb3QxMSAqIGRvdDAyIC0gZG90MDEgKiBkb3QxMiApICogaW52RGVub207XFxyXFxuXFx0XFx0XFx0XFx0dmFyIHYgPSAoIGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyICkgKiBpbnZEZW5vbTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBiYXJ5Y2VudHJpYyBjb29yZGluYXRlcyBtdXN0IGFsd2F5cyBzdW0gdG8gMVxcclxcblxcdFxcdFxcdFxcdHJldHVybiByZXN1bHQuc2V0KCAxIC0gdSAtIHYsIHYsIHUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0oKSxcXHJcXG5cXHJcXG5cXHRcXHRjb250YWluc1BvaW50OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gY29udGFpbnNQb2ludCggcG9pbnQsIGEsIGIsIGMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHJlc3VsdCA9IFRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCggcG9pbnQsIGEsIGIsIGMsIHYxICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuICggcmVzdWx0LnggPj0gMCApICYmICggcmVzdWx0LnkgPj0gMCApICYmICggKCByZXN1bHQueCArIHJlc3VsdC55ICkgPD0gMSApO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpXFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIFRyaWFuZ2xlLnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdHNldDogZnVuY3Rpb24gKCBhLCBiLCBjICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuYS5jb3B5KCBhICk7XFxyXFxuXFx0XFx0XFx0dGhpcy5iLmNvcHkoIGIgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLmMuY29weSggYyApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0RnJvbVBvaW50c0FuZEluZGljZXM6IGZ1bmN0aW9uICggcG9pbnRzLCBpMCwgaTEsIGkyICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuYS5jb3B5KCBwb2ludHNbIGkwIF0gKTtcXHJcXG5cXHRcXHRcXHR0aGlzLmIuY29weSggcG9pbnRzWyBpMSBdICk7XFxyXFxuXFx0XFx0XFx0dGhpcy5jLmNvcHkoIHBvaW50c1sgaTIgXSApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHRyaWFuZ2xlICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuYS5jb3B5KCB0cmlhbmdsZS5hICk7XFxyXFxuXFx0XFx0XFx0dGhpcy5iLmNvcHkoIHRyaWFuZ2xlLmIgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLmMuY29weSggdHJpYW5nbGUuYyApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0YXJlYTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB2MCA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gYXJlYSgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2MC5zdWJWZWN0b3JzKCB0aGlzLmMsIHRoaXMuYiApO1xcclxcblxcdFxcdFxcdFxcdHYxLnN1YlZlY3RvcnMoIHRoaXMuYSwgdGhpcy5iICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHYwLmNyb3NzKCB2MSApLmxlbmd0aCgpICogMC41O1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdG1pZHBvaW50OiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdFxcdHJldHVybiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5hLCB0aGlzLmIgKS5hZGQoIHRoaXMuYyApLm11bHRpcGx5U2NhbGFyKCAxIC8gMyApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0bm9ybWFsOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBUcmlhbmdsZS5ub3JtYWwoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIG9wdGlvbmFsVGFyZ2V0ICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRwbGFuZTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFBsYW5lKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHJlc3VsdC5zZXRGcm9tQ29wbGFuYXJQb2ludHMoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGJhcnljb29yZEZyb21Qb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIFRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCggcG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIG9wdGlvbmFsVGFyZ2V0ICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBUcmlhbmdsZS5jb250YWluc1BvaW50KCBwb2ludCwgdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y2xvc2VzdFBvaW50VG9Qb2ludDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBwbGFuZSA9IG5ldyBQbGFuZSgpO1xcclxcblxcdFxcdFxcdHZhciBlZGdlTGlzdCA9IFsgbmV3IExpbmUzKCksIG5ldyBMaW5lMygpLCBuZXcgTGluZTMoKSBdO1xcclxcblxcdFxcdFxcdHZhciBwcm9qZWN0ZWRQb2ludCA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0XFx0dmFyIGNsb3Nlc3RQb2ludCA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGNsb3Nlc3RQb2ludFRvUG9pbnQoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgbWluRGlzdGFuY2UgPSBJbmZpbml0eTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBwcm9qZWN0IHRoZSBwb2ludCBvbnRvIHRoZSBwbGFuZSBvZiB0aGUgdHJpYW5nbGVcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRwbGFuZS5zZXRGcm9tQ29wbGFuYXJQb2ludHMoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgKTtcXHJcXG5cXHRcXHRcXHRcXHRwbGFuZS5wcm9qZWN0UG9pbnQoIHBvaW50LCBwcm9qZWN0ZWRQb2ludCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGNoZWNrIGlmIHRoZSBwcm9qZWN0aW9uIGxpZXMgd2l0aGluIHRoZSB0cmlhbmdsZVxcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggdGhpcy5jb250YWluc1BvaW50KCBwcm9qZWN0ZWRQb2ludCApID09PSB0cnVlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIGlmIHNvLCB0aGlzIGlzIHRoZSBjbG9zZXN0IHBvaW50XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmVzdWx0LmNvcHkoIHByb2plY3RlZFBvaW50ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBpZiBub3QsIHRoZSBwb2ludCBmYWxscyBvdXRzaWRlIHRoZSB0cmlhbmdsZS4gdGhlIHJlc3VsdCBpcyB0aGUgY2xvc2VzdCBwb2ludCB0byB0aGUgdHJpYW5nbGUncyBlZGdlcyBvciB2ZXJ0aWNlc1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGVkZ2VMaXN0WyAwIF0uc2V0KCB0aGlzLmEsIHRoaXMuYiApO1xcclxcblxcdFxcdFxcdFxcdFxcdGVkZ2VMaXN0WyAxIF0uc2V0KCB0aGlzLmIsIHRoaXMuYyApO1xcclxcblxcdFxcdFxcdFxcdFxcdGVkZ2VMaXN0WyAyIF0uc2V0KCB0aGlzLmMsIHRoaXMuYSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IGVkZ2VMaXN0Lmxlbmd0aDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRlZGdlTGlzdFsgaSBdLmNsb3Nlc3RQb2ludFRvUG9pbnQoIHByb2plY3RlZFBvaW50LCB0cnVlLCBjbG9zZXN0UG9pbnQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgZGlzdGFuY2UgPSBwcm9qZWN0ZWRQb2ludC5kaXN0YW5jZVRvU3F1YXJlZCggY2xvc2VzdFBvaW50ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBkaXN0YW5jZSA8IG1pbkRpc3RhbmNlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzdWx0LmNvcHkoIGNsb3Nlc3RQb2ludCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiByZXN1bHQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR9KCksXFxyXFxuXFxyXFxuXFx0XFx0ZXF1YWxzOiBmdW5jdGlvbiAoIHRyaWFuZ2xlICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0cmlhbmdsZS5hLmVxdWFscyggdGhpcy5hICkgJiYgdHJpYW5nbGUuYi5lcXVhbHMoIHRoaXMuYiApICYmIHRyaWFuZ2xlLmMuZXF1YWxzKCB0aGlzLmMgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXHJcXG5cXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xcclxcblxcdCAqIEBhdXRob3Igam9ub2JyMSAvIGh0dHA6Ly9qb25vYnIxLmNvbS9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdNZXNoJztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCA/IGdlb21ldHJ5IDogbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XFxyXFxuXFx0XFx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbCA6IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmIH0gKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmRyYXdNb2RlID0gVHJpYW5nbGVzRHJhd01vZGU7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy51cGRhdGVNb3JwaFRhcmdldHMoKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0TWVzaC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xcclxcblxcclxcblxcdFxcdGNvbnN0cnVjdG9yOiBNZXNoLFxcclxcblxcclxcblxcdFxcdGlzTWVzaDogdHJ1ZSxcXHJcXG5cXHJcXG5cXHRcXHRzZXREcmF3TW9kZTogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmRyYXdNb2RlID0gdmFsdWU7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRPYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmRyYXdNb2RlID0gc291cmNlLmRyYXdNb2RlO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggc291cmNlLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gc291cmNlLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5zbGljZSgpO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHNvdXJjZS5tb3JwaFRhcmdldERpY3Rpb25hcnkgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UubW9ycGhUYXJnZXREaWN0aW9uYXJ5ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0dXBkYXRlTW9ycGhUYXJnZXRzOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcXHJcXG5cXHRcXHRcXHR2YXIgbSwgbWwsIG5hbWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBtb3JwaEF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXM7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyggbW9ycGhBdHRyaWJ1dGVzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBrZXlzLmxlbmd0aCA+IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzWyBrZXlzWyAwIF0gXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG1vcnBoQXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBbXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IHt9O1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIG0gPSAwLCBtbCA9IG1vcnBoQXR0cmlidXRlLmxlbmd0aDsgbSA8IG1sOyBtICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG5hbWUgPSBtb3JwaEF0dHJpYnV0ZVsgbSBdLm5hbWUgfHwgU3RyaW5nKCBtICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMucHVzaCggMCApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5WyBuYW1lIF0gPSBtO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIG1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICYmIG1vcnBoVGFyZ2V0cy5sZW5ndGggPiAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gW107XFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnkgPSB7fTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCBtID0gMCwgbWwgPSBtb3JwaFRhcmdldHMubGVuZ3RoOyBtIDwgbWw7IG0gKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0bmFtZSA9IG1vcnBoVGFyZ2V0c1sgbSBdLm5hbWUgfHwgU3RyaW5nKCBtICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMucHVzaCggMCApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5WyBuYW1lIF0gPSBtO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0cmF5Y2FzdDogKCBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGludmVyc2VNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xcclxcblxcdFxcdFxcdHZhciByYXkgPSBuZXcgUmF5KCk7XFxyXFxuXFx0XFx0XFx0dmFyIHNwaGVyZSA9IG5ldyBTcGhlcmUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdkEgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdFxcdHZhciB2QiA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0XFx0dmFyIHZDID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdGVtcEEgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdFxcdHZhciB0ZW1wQiA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0XFx0dmFyIHRlbXBDID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdXZBID0gbmV3IFZlY3RvcjIoKTtcXHJcXG5cXHRcXHRcXHR2YXIgdXZCID0gbmV3IFZlY3RvcjIoKTtcXHJcXG5cXHRcXHRcXHR2YXIgdXZDID0gbmV3IFZlY3RvcjIoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgYmFyeWNvb3JkID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgaW50ZXJzZWN0aW9uUG9pbnQgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdFxcdHZhciBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmdW5jdGlvbiB1dkludGVyc2VjdGlvbiggcG9pbnQsIHAxLCBwMiwgcDMsIHV2MSwgdXYyLCB1djMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0VHJpYW5nbGUuYmFyeWNvb3JkRnJvbVBvaW50KCBwb2ludCwgcDEsIHAyLCBwMywgYmFyeWNvb3JkICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dXYxLm11bHRpcGx5U2NhbGFyKCBiYXJ5Y29vcmQueCApO1xcclxcblxcdFxcdFxcdFxcdHV2Mi5tdWx0aXBseVNjYWxhciggYmFyeWNvb3JkLnkgKTtcXHJcXG5cXHRcXHRcXHRcXHR1djMubXVsdGlwbHlTY2FsYXIoIGJhcnljb29yZC56ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dXYxLmFkZCggdXYyICkuYWRkKCB1djMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdXYxLmNsb25lKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGZ1bmN0aW9uIGNoZWNrSW50ZXJzZWN0aW9uKCBvYmplY3QsIG1hdGVyaWFsLCByYXljYXN0ZXIsIHJheSwgcEEsIHBCLCBwQywgcG9pbnQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGludGVyc2VjdDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIG1hdGVyaWFsLnNpZGUgPT09IEJhY2tTaWRlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGludGVyc2VjdCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZSggcEMsIHBCLCBwQSwgdHJ1ZSwgcG9pbnQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGludGVyc2VjdCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZSggcEEsIHBCLCBwQywgbWF0ZXJpYWwuc2lkZSAhPT0gRG91YmxlU2lkZSwgcG9pbnQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBpbnRlcnNlY3QgPT09IG51bGwgKSByZXR1cm4gbnVsbDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmNvcHkoIHBvaW50ICk7XFxyXFxuXFx0XFx0XFx0XFx0aW50ZXJzZWN0aW9uUG9pbnRXb3JsZC5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyc2VjdGlvblBvaW50V29ybGQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgcmV0dXJuIG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHtcXHJcXG5cXHRcXHRcXHRcXHRcXHRkaXN0YW5jZTogZGlzdGFuY2UsXFxyXFxuXFx0XFx0XFx0XFx0XFx0cG9pbnQ6IGludGVyc2VjdGlvblBvaW50V29ybGQuY2xvbmUoKSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRvYmplY3Q6IG9iamVjdFxcclxcblxcdFxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGZ1bmN0aW9uIGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24oIG9iamVjdCwgcmF5Y2FzdGVyLCByYXksIHBvc2l0aW9uLCB1diwgYSwgYiwgYyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2QS5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgYSApO1xcclxcblxcdFxcdFxcdFxcdHZCLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBiICk7XFxyXFxuXFx0XFx0XFx0XFx0dkMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgaW50ZXJzZWN0aW9uID0gY2hlY2tJbnRlcnNlY3Rpb24oIG9iamVjdCwgb2JqZWN0Lm1hdGVyaWFsLCByYXljYXN0ZXIsIHJheSwgdkEsIHZCLCB2QywgaW50ZXJzZWN0aW9uUG9pbnQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGludGVyc2VjdGlvbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHV2ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHV2QS5mcm9tQnVmZmVyQXR0cmlidXRlKCB1diwgYSApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHV2Qi5mcm9tQnVmZmVyQXR0cmlidXRlKCB1diwgYiApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHV2Qy5mcm9tQnVmZmVyQXR0cmlidXRlKCB1diwgYyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGludGVyc2VjdGlvbi51diA9IHV2SW50ZXJzZWN0aW9uKCBpbnRlcnNlY3Rpb25Qb2ludCwgdkEsIHZCLCB2QywgdXZBLCB1dkIsIHV2QyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpbnRlcnNlY3Rpb24uZmFjZSA9IG5ldyBGYWNlMyggYSwgYiwgYywgVHJpYW5nbGUubm9ybWFsKCB2QSwgdkIsIHZDICkgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gYTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGludGVyc2VjdGlvbjtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xcclxcblxcdFxcdFxcdFxcdHZhciBtYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIG1hdGVyaWFsID09PSB1bmRlZmluZWQgKSByZXR1cm47XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gQ2hlY2tpbmcgYm91bmRpbmdTcGhlcmUgZGlzdGFuY2UgdG8gcmF5XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHNwaGVyZS5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApO1xcclxcblxcdFxcdFxcdFxcdHNwaGVyZS5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCByYXljYXN0ZXIucmF5LmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApID09PSBmYWxzZSApIHJldHVybjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvL1xcclxcblxcclxcblxcdFxcdFxcdFxcdGludmVyc2VNYXRyaXguZ2V0SW52ZXJzZSggbWF0cml4V29ybGQgKTtcXHJcXG5cXHRcXHRcXHRcXHRyYXkuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggaW52ZXJzZU1hdHJpeCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIENoZWNrIGJvdW5kaW5nQm94IGJlZm9yZSBjb250aW51aW5nXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHJheS5pbnRlcnNlY3RzQm94KCBnZW9tZXRyeS5ib3VuZGluZ0JveCApID09PSBmYWxzZSApIHJldHVybjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGludGVyc2VjdGlvbjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGEsIGIsIGM7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdXYgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnV2O1xcclxcblxcdFxcdFxcdFxcdFxcdHZhciBpLCBsO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggaW5kZXggIT09IG51bGwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gaW5kZXhlZCBidWZmZXIgZ2VvbWV0cnlcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCBpID0gMCwgbCA9IGluZGV4LmNvdW50OyBpIDwgbDsgaSArPSAzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGEgPSBpbmRleC5nZXRYKCBpICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YiA9IGluZGV4LmdldFgoIGkgKyAxICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YyA9IGluZGV4LmdldFgoIGkgKyAyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aW50ZXJzZWN0aW9uID0gY2hlY2tCdWZmZXJHZW9tZXRyeUludGVyc2VjdGlvbiggdGhpcywgcmF5Y2FzdGVyLCByYXksIHBvc2l0aW9uLCB1diwgYSwgYiwgYyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggaW50ZXJzZWN0aW9uICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSBNYXRoLmZsb29yKCBpIC8gMyApOyAvLyB0cmlhbmdsZSBudW1iZXIgaW4gaW5kaWNlcyBidWZmZXIgc2VtYW50aWNzXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3Rpb24gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gbm9uLWluZGV4ZWQgYnVmZmVyIGdlb21ldHJ5XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggaSA9IDAsIGwgPSBwb3NpdGlvbi5jb3VudDsgaSA8IGw7IGkgKz0gMyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRhID0gaTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRiID0gaSArIDE7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YyA9IGkgKyAyO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGludGVyc2VjdGlvbiA9IGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24oIHRoaXMsIHJheWNhc3RlciwgcmF5LCBwb3NpdGlvbiwgdXYsIGEsIGIsIGMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGludGVyc2VjdGlvbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpbnRlcnNlY3Rpb24uaW5kZXggPSBhOyAvLyB0cmlhbmdsZSBudW1iZXIgaW4gcG9zaXRpb25zIGJ1ZmZlciBzZW1hbnRpY3NcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpbnRlcnNlY3RzLnB1c2goIGludGVyc2VjdGlvbiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIGdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGZ2QSwgZnZCLCBmdkM7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGlzTXVsdGlNYXRlcmlhbCA9IEFycmF5LmlzQXJyYXkoIG1hdGVyaWFsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHV2cztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgZmFjZVZlcnRleFV2cyA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIDAgXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGZhY2VWZXJ0ZXhVdnMubGVuZ3RoID4gMCApIHV2cyA9IGZhY2VWZXJ0ZXhVdnM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGYgPSAwLCBmbCA9IGZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBmYWNlID0gZmFjZXNbIGYgXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgZmFjZU1hdGVyaWFsID0gaXNNdWx0aU1hdGVyaWFsID8gbWF0ZXJpYWxbIGZhY2UubWF0ZXJpYWxJbmRleCBdIDogbWF0ZXJpYWw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBmYWNlTWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGZ2QSA9IHZlcnRpY2VzWyBmYWNlLmEgXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRmdkIgPSB2ZXJ0aWNlc1sgZmFjZS5iIF07XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZnZDID0gdmVydGljZXNbIGZhY2UuYyBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggZmFjZU1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9PT0gdHJ1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBtb3JwaEluZmx1ZW5jZXMgPSB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2QS5zZXQoIDAsIDAsIDAgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2Qi5zZXQoIDAsIDAsIDAgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2Qy5zZXQoIDAsIDAsIDAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgdCA9IDAsIHRsID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgdCA8IHRsOyB0ICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBpbmZsdWVuY2UgPSBtb3JwaEluZmx1ZW5jZXNbIHQgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGluZmx1ZW5jZSA9PT0gMCApIGNvbnRpbnVlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciB0YXJnZXRzID0gbW9ycGhUYXJnZXRzWyB0IF0udmVydGljZXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dkEuYWRkU2NhbGVkVmVjdG9yKCB0ZW1wQS5zdWJWZWN0b3JzKCB0YXJnZXRzWyBmYWNlLmEgXSwgZnZBICksIGluZmx1ZW5jZSApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHZCLmFkZFNjYWxlZFZlY3RvciggdGVtcEIuc3ViVmVjdG9ycyggdGFyZ2V0c1sgZmFjZS5iIF0sIGZ2QiApLCBpbmZsdWVuY2UgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR2Qy5hZGRTY2FsZWRWZWN0b3IoIHRlbXBDLnN1YlZlY3RvcnMoIHRhcmdldHNbIGZhY2UuYyBdLCBmdkMgKSwgaW5mbHVlbmNlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZBLmFkZCggZnZBICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dkIuYWRkKCBmdkIgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2Qy5hZGQoIGZ2QyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZ2QSA9IHZBO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZ2QiA9IHZCO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZ2QyA9IHZDO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpbnRlcnNlY3Rpb24gPSBjaGVja0ludGVyc2VjdGlvbiggdGhpcywgZmFjZU1hdGVyaWFsLCByYXljYXN0ZXIsIHJheSwgZnZBLCBmdkIsIGZ2QywgaW50ZXJzZWN0aW9uUG9pbnQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGludGVyc2VjdGlvbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHV2cyAmJiB1dnNbIGYgXSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgdXZzX2YgPSB1dnNbIGYgXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR1dkEuY29weSggdXZzX2ZbIDAgXSApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHV2Qi5jb3B5KCB1dnNfZlsgMSBdICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dXZDLmNvcHkoIHV2c19mWyAyIF0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpbnRlcnNlY3Rpb24udXYgPSB1dkludGVyc2VjdGlvbiggaW50ZXJzZWN0aW9uUG9pbnQsIGZ2QSwgZnZCLCBmdkMsIHV2QSwgdXZCLCB1dkMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aW50ZXJzZWN0aW9uLmZhY2UgPSBmYWNlO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSBmO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0aW9uICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR9KCkgKSxcXHJcXG5cXHJcXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApLmNvcHkoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gV2ViR0xCYWNrZ3JvdW5kKCByZW5kZXJlciwgc3RhdGUsIGdlb21ldHJpZXMsIHByZW11bHRpcGxpZWRBbHBoYSApIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgY2xlYXJDb2xvciA9IG5ldyBDb2xvciggMHgwMDAwMDAgKTtcXHJcXG5cXHRcXHR2YXIgY2xlYXJBbHBoYSA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHBsYW5lQ2FtZXJhLCBwbGFuZU1lc2g7XFxyXFxuXFx0XFx0dmFyIGJveE1lc2g7XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gcmVuZGVyKCByZW5kZXJMaXN0LCBzY2VuZSwgY2FtZXJhLCBmb3JjZUNsZWFyICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBiYWNrZ3JvdW5kID0gc2NlbmUuYmFja2dyb3VuZDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGJhY2tncm91bmQgPT09IG51bGwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0c2V0Q2xlYXIoIGNsZWFyQ29sb3IsIGNsZWFyQWxwaGEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBiYWNrZ3JvdW5kICYmIGJhY2tncm91bmQuaXNDb2xvciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzZXRDbGVhciggYmFja2dyb3VuZCwgMSApO1xcclxcblxcdFxcdFxcdFxcdGZvcmNlQ2xlYXIgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHJlbmRlcmVyLmF1dG9DbGVhciB8fCBmb3JjZUNsZWFyICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJlbmRlcmVyLmNsZWFyKCByZW5kZXJlci5hdXRvQ2xlYXJDb2xvciwgcmVuZGVyZXIuYXV0b0NsZWFyRGVwdGgsIHJlbmRlcmVyLmF1dG9DbGVhclN0ZW5jaWwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBiYWNrZ3JvdW5kICYmIGJhY2tncm91bmQuaXNDdWJlVGV4dHVyZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGJveE1lc2ggPT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRib3hNZXNoID0gbmV3IE1lc2goXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0bmV3IEJveEJ1ZmZlckdlb21ldHJ5KCAxLCAxLCAxICksXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0bmV3IFNoYWRlck1hdGVyaWFsKCB7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dW5pZm9ybXM6IFNoYWRlckxpYi5jdWJlLnVuaWZvcm1zLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZlcnRleFNoYWRlcjogU2hhZGVyTGliLmN1YmUudmVydGV4U2hhZGVyLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJMaWIuY3ViZS5mcmFnbWVudFNoYWRlcixcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzaWRlOiBCYWNrU2lkZSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkZXB0aFRlc3Q6IHRydWUsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGVwdGhXcml0ZTogZmFsc2UsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9nOiBmYWxzZVxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH0gKVxcclxcblxcdFxcdFxcdFxcdFxcdCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ym94TWVzaC5nZW9tZXRyeS5yZW1vdmVBdHRyaWJ1dGUoICdub3JtYWwnICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0Ym94TWVzaC5nZW9tZXRyeS5yZW1vdmVBdHRyaWJ1dGUoICd1dicgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRib3hNZXNoLm9uQmVmb3JlUmVuZGVyID0gZnVuY3Rpb24gKCByZW5kZXJlciwgc2NlbmUsIGNhbWVyYSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLm1hdHJpeFdvcmxkLmNvcHlQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRnZW9tZXRyaWVzLnVwZGF0ZSggYm94TWVzaC5nZW9tZXRyeSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRib3hNZXNoLm1hdGVyaWFsLnVuaWZvcm1zLnRDdWJlLnZhbHVlID0gYmFja2dyb3VuZDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZW5kZXJMaXN0LnB1c2goIGJveE1lc2gsIGJveE1lc2guZ2VvbWV0cnksIGJveE1lc2gubWF0ZXJpYWwsIDAsIG51bGwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBiYWNrZ3JvdW5kICYmIGJhY2tncm91bmQuaXNUZXh0dXJlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggcGxhbmVDYW1lcmEgPT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRwbGFuZUNhbWVyYSA9IG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoIC0gMSwgMSwgMSwgLSAxLCAwLCAxICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cGxhbmVNZXNoID0gbmV3IE1lc2goXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0bmV3IFBsYW5lQnVmZmVyR2VvbWV0cnkoIDIsIDIgKSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoIHsgZGVwdGhUZXN0OiBmYWxzZSwgZGVwdGhXcml0ZTogZmFsc2UsIGZvZzogZmFsc2UgfSApXFxyXFxuXFx0XFx0XFx0XFx0XFx0KTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRnZW9tZXRyaWVzLnVwZGF0ZSggcGxhbmVNZXNoLmdlb21ldHJ5ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHBsYW5lTWVzaC5tYXRlcmlhbC5tYXAgPSBiYWNrZ3JvdW5kO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIFRPRE8gUHVzaCB0aGlzIHRvIHJlbmRlckxpc3RcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZW5kZXJlci5yZW5kZXJCdWZmZXJEaXJlY3QoIHBsYW5lQ2FtZXJhLCBudWxsLCBwbGFuZU1lc2guZ2VvbWV0cnksIHBsYW5lTWVzaC5tYXRlcmlhbCwgcGxhbmVNZXNoLCBudWxsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBzZXRDbGVhciggY29sb3IsIGFscGhhICkge1xcclxcblxcclxcblxcdFxcdFxcdHN0YXRlLmJ1ZmZlcnMuY29sb3Iuc2V0Q2xlYXIoIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIsIGFscGhhLCBwcmVtdWx0aXBsaWVkQWxwaGEgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRnZXRDbGVhckNvbG9yOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGNsZWFyQ29sb3I7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSxcXHJcXG5cXHRcXHRcXHRzZXRDbGVhckNvbG9yOiBmdW5jdGlvbiAoIGNvbG9yLCBhbHBoYSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjbGVhckNvbG9yLnNldCggY29sb3IgKTtcXHJcXG5cXHRcXHRcXHRcXHRjbGVhckFscGhhID0gYWxwaGEgIT09IHVuZGVmaW5lZCA/IGFscGhhIDogMTtcXHJcXG5cXHRcXHRcXHRcXHRzZXRDbGVhciggY2xlYXJDb2xvciwgY2xlYXJBbHBoYSApO1xcclxcblxcclxcblxcdFxcdFxcdH0sXFxyXFxuXFx0XFx0XFx0Z2V0Q2xlYXJBbHBoYTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiBjbGVhckFscGhhO1xcclxcblxcclxcblxcdFxcdFxcdH0sXFxyXFxuXFx0XFx0XFx0c2V0Q2xlYXJBbHBoYTogZnVuY3Rpb24gKCBhbHBoYSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjbGVhckFscGhhID0gYWxwaGE7XFxyXFxuXFx0XFx0XFx0XFx0c2V0Q2xlYXIoIGNsZWFyQ29sb3IsIGNsZWFyQWxwaGEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9LFxcclxcblxcdFxcdFxcdHJlbmRlcjogcmVuZGVyXFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBwYWludGVyU29ydFN0YWJsZSggYSwgYiApIHtcXHJcXG5cXHJcXG5cXHRcXHRpZiAoIGEucmVuZGVyT3JkZXIgIT09IGIucmVuZGVyT3JkZXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGEucmVuZGVyT3JkZXIgLSBiLnJlbmRlck9yZGVyO1xcclxcblxcclxcblxcdFxcdH0gZWxzZSBpZiAoIGEucHJvZ3JhbSAmJiBiLnByb2dyYW0gJiYgYS5wcm9ncmFtICE9PSBiLnByb2dyYW0gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGEucHJvZ3JhbS5pZCAtIGIucHJvZ3JhbS5pZDtcXHJcXG5cXHJcXG5cXHRcXHR9IGVsc2UgaWYgKCBhLm1hdGVyaWFsLmlkICE9PSBiLm1hdGVyaWFsLmlkICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBhLm1hdGVyaWFsLmlkIC0gYi5tYXRlcmlhbC5pZDtcXHJcXG5cXHJcXG5cXHRcXHR9IGVsc2UgaWYgKCBhLnogIT09IGIueiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gYS56IC0gYi56O1xcclxcblxcclxcblxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGEuaWQgLSBiLmlkO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gcmV2ZXJzZVBhaW50ZXJTb3J0U3RhYmxlKCBhLCBiICkge1xcclxcblxcclxcblxcdFxcdGlmICggYS5yZW5kZXJPcmRlciAhPT0gYi5yZW5kZXJPcmRlciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gYS5yZW5kZXJPcmRlciAtIGIucmVuZGVyT3JkZXI7XFxyXFxuXFxyXFxuXFx0XFx0fSBpZiAoIGEueiAhPT0gYi56ICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBiLnogLSBhLno7XFxyXFxuXFxyXFxuXFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gYS5pZCAtIGIuaWQ7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBXZWJHTFJlbmRlckxpc3QoKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHJlbmRlckl0ZW1zID0gW107XFxyXFxuXFx0XFx0dmFyIHJlbmRlckl0ZW1zSW5kZXggPSAwO1xcclxcblxcclxcblxcdFxcdHZhciBvcGFxdWUgPSBbXTtcXHJcXG5cXHRcXHR2YXIgdHJhbnNwYXJlbnQgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBpbml0KCkge1xcclxcblxcclxcblxcdFxcdFxcdHJlbmRlckl0ZW1zSW5kZXggPSAwO1xcclxcblxcclxcblxcdFxcdFxcdG9wYXF1ZS5sZW5ndGggPSAwO1xcclxcblxcdFxcdFxcdHRyYW5zcGFyZW50Lmxlbmd0aCA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIHB1c2goIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCB6LCBncm91cCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcmVuZGVySXRlbSA9IHJlbmRlckl0ZW1zWyByZW5kZXJJdGVtc0luZGV4IF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCByZW5kZXJJdGVtID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmVuZGVySXRlbSA9IHtcXHJcXG5cXHRcXHRcXHRcXHRcXHRpZDogb2JqZWN0LmlkLFxcclxcblxcdFxcdFxcdFxcdFxcdG9iamVjdDogb2JqZWN0LFxcclxcblxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5OiBnZW9tZXRyeSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRtYXRlcmlhbDogbWF0ZXJpYWwsXFxyXFxuXFx0XFx0XFx0XFx0XFx0cHJvZ3JhbTogbWF0ZXJpYWwucHJvZ3JhbSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRyZW5kZXJPcmRlcjogb2JqZWN0LnJlbmRlck9yZGVyLFxcclxcblxcdFxcdFxcdFxcdFxcdHo6IHosXFxyXFxuXFx0XFx0XFx0XFx0XFx0Z3JvdXA6IGdyb3VwXFxyXFxuXFx0XFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZW5kZXJJdGVtc1sgcmVuZGVySXRlbXNJbmRleCBdID0gcmVuZGVySXRlbTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJlbmRlckl0ZW0uaWQgPSBvYmplY3QuaWQ7XFxyXFxuXFx0XFx0XFx0XFx0cmVuZGVySXRlbS5vYmplY3QgPSBvYmplY3Q7XFxyXFxuXFx0XFx0XFx0XFx0cmVuZGVySXRlbS5nZW9tZXRyeSA9IGdlb21ldHJ5O1xcclxcblxcdFxcdFxcdFxcdHJlbmRlckl0ZW0ubWF0ZXJpYWwgPSBtYXRlcmlhbDtcXHJcXG5cXHRcXHRcXHRcXHRyZW5kZXJJdGVtLnByb2dyYW0gPSBtYXRlcmlhbC5wcm9ncmFtO1xcclxcblxcdFxcdFxcdFxcdHJlbmRlckl0ZW0ucmVuZGVyT3JkZXIgPSBvYmplY3QucmVuZGVyT3JkZXI7XFxyXFxuXFx0XFx0XFx0XFx0cmVuZGVySXRlbS56ID0gejtcXHJcXG5cXHRcXHRcXHRcXHRyZW5kZXJJdGVtLmdyb3VwID0gZ3JvdXA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdCggbWF0ZXJpYWwudHJhbnNwYXJlbnQgPT09IHRydWUgPyB0cmFuc3BhcmVudCA6IG9wYXF1ZSApLnB1c2goIHJlbmRlckl0ZW0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZW5kZXJJdGVtc0luZGV4ICsrO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBzb3J0KCkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggb3BhcXVlLmxlbmd0aCA+IDEgKSBvcGFxdWUuc29ydCggcGFpbnRlclNvcnRTdGFibGUgKTtcXHJcXG5cXHRcXHRcXHRpZiAoIHRyYW5zcGFyZW50Lmxlbmd0aCA+IDEgKSB0cmFuc3BhcmVudC5zb3J0KCByZXZlcnNlUGFpbnRlclNvcnRTdGFibGUgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHtcXHJcXG5cXHRcXHRcXHRvcGFxdWU6IG9wYXF1ZSxcXHJcXG5cXHRcXHRcXHR0cmFuc3BhcmVudDogdHJhbnNwYXJlbnQsXFxyXFxuXFxyXFxuXFx0XFx0XFx0aW5pdDogaW5pdCxcXHJcXG5cXHRcXHRcXHRwdXNoOiBwdXNoLFxcclxcblxcclxcblxcdFxcdFxcdHNvcnQ6IHNvcnRcXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBXZWJHTFJlbmRlckxpc3RzKCkge1xcclxcblxcclxcblxcdFxcdHZhciBsaXN0cyA9IHt9O1xcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIGdldCggc2NlbmUsIGNhbWVyYSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgaGFzaCA9IHNjZW5lLmlkICsgJywnICsgY2FtZXJhLmlkO1xcclxcblxcdFxcdFxcdHZhciBsaXN0ID0gbGlzdHNbIGhhc2ggXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGxpc3QgPT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBjb25zb2xlLmxvZyggJ1RIUkVFLldlYkdMUmVuZGVyTGlzdHM6JywgaGFzaCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGxpc3QgPSBuZXcgV2ViR0xSZW5kZXJMaXN0KCk7XFxyXFxuXFx0XFx0XFx0XFx0bGlzdHNbIGhhc2ggXSA9IGxpc3Q7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBsaXN0O1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBkaXNwb3NlKCkge1xcclxcblxcclxcblxcdFxcdFxcdGxpc3RzID0ge307XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHJldHVybiB7XFxyXFxuXFx0XFx0XFx0Z2V0OiBnZXQsXFxyXFxuXFx0XFx0XFx0ZGlzcG9zZTogZGlzcG9zZVxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gYWJzTnVtZXJpY2FsU29ydCggYSwgYiApIHtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gTWF0aC5hYnMoIGJbIDEgXSApIC0gTWF0aC5hYnMoIGFbIDEgXSApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBXZWJHTE1vcnBodGFyZ2V0cyggZ2wgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGluZmx1ZW5jZXNMaXN0ID0ge307XFxyXFxuXFx0XFx0dmFyIG1vcnBoSW5mbHVlbmNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIDggKTtcXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiB1cGRhdGUoIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBwcm9ncmFtICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBvYmplY3RJbmZsdWVuY2VzID0gb2JqZWN0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbGVuZ3RoID0gb2JqZWN0SW5mbHVlbmNlcy5sZW5ndGg7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGluZmx1ZW5jZXMgPSBpbmZsdWVuY2VzTGlzdFsgZ2VvbWV0cnkuaWQgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGluZmx1ZW5jZXMgPT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBpbml0aWFsaXNlIGxpc3RcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpbmZsdWVuY2VzID0gW107XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGluZmx1ZW5jZXNbIGkgXSA9IFsgaSwgMCBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpbmZsdWVuY2VzTGlzdFsgZ2VvbWV0cnkuaWQgXSA9IGluZmx1ZW5jZXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHZhciBtb3JwaFRhcmdldHMgPSBtYXRlcmlhbC5tb3JwaFRhcmdldHMgJiYgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uO1xcclxcblxcdFxcdFxcdHZhciBtb3JwaE5vcm1hbHMgPSBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgJiYgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbDtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBSZW1vdmUgY3VycmVudCBtb3JwaEF0dHJpYnV0ZXNcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGluZmx1ZW5jZSA9IGluZmx1ZW5jZXNbIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGluZmx1ZW5jZVsgMSBdICE9PSAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggbW9ycGhUYXJnZXRzICkgZ2VvbWV0cnkucmVtb3ZlQXR0cmlidXRlKCAnbW9ycGhUYXJnZXQnICsgaSApO1xcclxcblxcdFxcdFxcdFxcdFxcdGlmICggbW9ycGhOb3JtYWxzICkgZ2VvbWV0cnkucmVtb3ZlQXR0cmlidXRlKCAnbW9ycGhOb3JtYWwnICsgaSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gQ29sbGVjdCBpbmZsdWVuY2VzXFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBpbmZsdWVuY2UgPSBpbmZsdWVuY2VzWyBpIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aW5mbHVlbmNlWyAwIF0gPSBpO1xcclxcblxcdFxcdFxcdFxcdGluZmx1ZW5jZVsgMSBdID0gb2JqZWN0SW5mbHVlbmNlc1sgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpbmZsdWVuY2VzLnNvcnQoIGFic051bWVyaWNhbFNvcnQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBBZGQgbW9ycGhBdHRyaWJ1dGVzXFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgODsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgaW5mbHVlbmNlID0gaW5mbHVlbmNlc1sgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggaW5mbHVlbmNlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBpbmRleCA9IGluZmx1ZW5jZVsgMCBdO1xcclxcblxcdFxcdFxcdFxcdFxcdHZhciB2YWx1ZSA9IGluZmx1ZW5jZVsgMSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBtb3JwaFRhcmdldHMgKSBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdtb3JwaFRhcmdldCcgKyBpLCBtb3JwaFRhcmdldHNbIGluZGV4IF0gKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG1vcnBoTm9ybWFscyApIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ21vcnBoTm9ybWFsJyArIGksIG1vcnBoTm9ybWFsc1sgaW5kZXggXSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdG1vcnBoSW5mbHVlbmNlc1sgaSBdID0gdmFsdWU7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29udGludWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRtb3JwaEluZmx1ZW5jZXNbIGkgXSA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHByb2dyYW0uZ2V0VW5pZm9ybXMoKS5zZXRWYWx1ZSggZ2wsICdtb3JwaFRhcmdldEluZmx1ZW5jZXMnLCBtb3JwaEluZmx1ZW5jZXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR1cGRhdGU6IHVwZGF0ZVxcclxcblxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gV2ViR0xJbmRleGVkQnVmZmVyUmVuZGVyZXIoIGdsLCBleHRlbnNpb25zLCBpbmZvUmVuZGVyICkge1xcclxcblxcclxcblxcdFxcdHZhciBtb2RlO1xcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIHNldE1vZGUoIHZhbHVlICkge1xcclxcblxcclxcblxcdFxcdFxcdG1vZGUgPSB2YWx1ZTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHR5cGUsIGJ5dGVzUGVyRWxlbWVudDtcXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBzZXRJbmRleCggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dHlwZSA9IHZhbHVlLnR5cGU7XFxyXFxuXFx0XFx0XFx0Ynl0ZXNQZXJFbGVtZW50ID0gdmFsdWUuYnl0ZXNQZXJFbGVtZW50O1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiByZW5kZXIoIHN0YXJ0LCBjb3VudCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRnbC5kcmF3RWxlbWVudHMoIG1vZGUsIGNvdW50LCB0eXBlLCBzdGFydCAqIGJ5dGVzUGVyRWxlbWVudCApO1xcclxcblxcclxcblxcdFxcdFxcdGluZm9SZW5kZXIuY2FsbHMgKys7XFxyXFxuXFx0XFx0XFx0aW5mb1JlbmRlci52ZXJ0aWNlcyArPSBjb3VudDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIG1vZGUgPT09IGdsLlRSSUFOR0xFUyApIGluZm9SZW5kZXIuZmFjZXMgKz0gY291bnQgLyAzO1xcclxcblxcdFxcdFxcdGVsc2UgaWYgKCBtb2RlID09PSBnbC5QT0lOVFMgKSBpbmZvUmVuZGVyLnBvaW50cyArPSBjb3VudDtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gcmVuZGVySW5zdGFuY2VzKCBnZW9tZXRyeSwgc3RhcnQsIGNvdW50ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMSW5kZXhlZEJ1ZmZlclJlbmRlcmVyOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRleHRlbnNpb24uZHJhd0VsZW1lbnRzSW5zdGFuY2VkQU5HTEUoIG1vZGUsIGNvdW50LCB0eXBlLCBzdGFydCAqIGJ5dGVzUGVyRWxlbWVudCwgZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpbmZvUmVuZGVyLmNhbGxzICsrO1xcclxcblxcdFxcdFxcdGluZm9SZW5kZXIudmVydGljZXMgKz0gY291bnQgKiBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIG1vZGUgPT09IGdsLlRSSUFOR0xFUyApIGluZm9SZW5kZXIuZmFjZXMgKz0gZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgKiBjb3VudCAvIDM7XFxyXFxuXFx0XFx0XFx0ZWxzZSBpZiAoIG1vZGUgPT09IGdsLlBPSU5UUyApIGluZm9SZW5kZXIucG9pbnRzICs9IGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICogY291bnQ7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdC8vXFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5zZXRNb2RlID0gc2V0TW9kZTtcXHJcXG5cXHRcXHR0aGlzLnNldEluZGV4ID0gc2V0SW5kZXg7XFxyXFxuXFx0XFx0dGhpcy5yZW5kZXIgPSByZW5kZXI7XFxyXFxuXFx0XFx0dGhpcy5yZW5kZXJJbnN0YW5jZXMgPSByZW5kZXJJbnN0YW5jZXM7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gV2ViR0xCdWZmZXJSZW5kZXJlciggZ2wsIGV4dGVuc2lvbnMsIGluZm9SZW5kZXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIG1vZGU7XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gc2V0TW9kZSggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0bW9kZSA9IHZhbHVlO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiByZW5kZXIoIHN0YXJ0LCBjb3VudCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRnbC5kcmF3QXJyYXlzKCBtb2RlLCBzdGFydCwgY291bnQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpbmZvUmVuZGVyLmNhbGxzICsrO1xcclxcblxcdFxcdFxcdGluZm9SZW5kZXIudmVydGljZXMgKz0gY291bnQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBtb2RlID09PSBnbC5UUklBTkdMRVMgKSBpbmZvUmVuZGVyLmZhY2VzICs9IGNvdW50IC8gMztcXHJcXG5cXHRcXHRcXHRlbHNlIGlmICggbW9kZSA9PT0gZ2wuUE9JTlRTICkgaW5mb1JlbmRlci5wb2ludHMgKz0gY291bnQ7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIHJlbmRlckluc3RhbmNlcyggZ2VvbWV0cnksIHN0YXJ0LCBjb3VudCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTEJ1ZmZlclJlbmRlcmVyOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggcG9zaXRpb24uaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb3VudCA9IHBvc2l0aW9uLmRhdGEuY291bnQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZXh0ZW5zaW9uLmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRSggbW9kZSwgMCwgY291bnQsIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRleHRlbnNpb24uZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKCBtb2RlLCBzdGFydCwgY291bnQsIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGluZm9SZW5kZXIuY2FsbHMgKys7XFxyXFxuXFx0XFx0XFx0aW5mb1JlbmRlci52ZXJ0aWNlcyArPSBjb3VudCAqIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50O1xcclxcblxcclxcblxcdFxcdFxcdGlmICggbW9kZSA9PT0gZ2wuVFJJQU5HTEVTICkgaW5mb1JlbmRlci5mYWNlcyArPSBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCAqIGNvdW50IC8gMztcXHJcXG5cXHRcXHRcXHRlbHNlIGlmICggbW9kZSA9PT0gZ2wuUE9JTlRTICkgaW5mb1JlbmRlci5wb2ludHMgKz0gZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgKiBjb3VudDtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0Ly9cXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnNldE1vZGUgPSBzZXRNb2RlO1xcclxcblxcdFxcdHRoaXMucmVuZGVyID0gcmVuZGVyO1xcclxcblxcdFxcdHRoaXMucmVuZGVySW5zdGFuY2VzID0gcmVuZGVySW5zdGFuY2VzO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIFdlYkdMR2VvbWV0cmllcyggZ2wsIGF0dHJpYnV0ZXMsIGluZm9NZW1vcnkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGdlb21ldHJpZXMgPSB7fTtcXHJcXG5cXHRcXHR2YXIgd2lyZWZyYW1lQXR0cmlidXRlcyA9IHt9O1xcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIG9uR2VvbWV0cnlEaXNwb3NlKCBldmVudCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgZ2VvbWV0cnkgPSBldmVudC50YXJnZXQ7XFxyXFxuXFx0XFx0XFx0dmFyIGJ1ZmZlcmdlb21ldHJ5ID0gZ2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGJ1ZmZlcmdlb21ldHJ5LmluZGV4ICE9PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGF0dHJpYnV0ZXMucmVtb3ZlKCBidWZmZXJnZW9tZXRyeS5pbmRleCApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgbmFtZSBpbiBidWZmZXJnZW9tZXRyeS5hdHRyaWJ1dGVzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGF0dHJpYnV0ZXMucmVtb3ZlKCBidWZmZXJnZW9tZXRyeS5hdHRyaWJ1dGVzWyBuYW1lIF0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Z2VvbWV0cnkucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbkdlb21ldHJ5RGlzcG9zZSApO1xcclxcblxcclxcblxcdFxcdFxcdGRlbGV0ZSBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdO1xcclxcblxcclxcblxcdFxcdFxcdC8vIFRPRE8gUmVtb3ZlIGR1cGxpY2F0ZSBjb2RlXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGF0dHJpYnV0ZSA9IHdpcmVmcmFtZUF0dHJpYnV0ZXNbIGdlb21ldHJ5LmlkIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBhdHRyaWJ1dGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YXR0cmlidXRlcy5yZW1vdmUoIGF0dHJpYnV0ZSApO1xcclxcblxcdFxcdFxcdFxcdGRlbGV0ZSB3aXJlZnJhbWVBdHRyaWJ1dGVzWyBnZW9tZXRyeS5pZCBdO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRhdHRyaWJ1dGUgPSB3aXJlZnJhbWVBdHRyaWJ1dGVzWyBidWZmZXJnZW9tZXRyeS5pZCBdO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggYXR0cmlidXRlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGF0dHJpYnV0ZXMucmVtb3ZlKCBhdHRyaWJ1dGUgKTtcXHJcXG5cXHRcXHRcXHRcXHRkZWxldGUgd2lyZWZyYW1lQXR0cmlidXRlc1sgYnVmZmVyZ2VvbWV0cnkuaWQgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly9cXHJcXG5cXHJcXG5cXHRcXHRcXHRpbmZvTWVtb3J5Lmdlb21ldHJpZXMgLS07XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIGdldCggb2JqZWN0LCBnZW9tZXRyeSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgYnVmZmVyZ2VvbWV0cnkgPSBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggYnVmZmVyZ2VvbWV0cnkgKSByZXR1cm4gYnVmZmVyZ2VvbWV0cnk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Z2VvbWV0cnkuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbkdlb21ldHJ5RGlzcG9zZSApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRidWZmZXJnZW9tZXRyeSA9IGdlb21ldHJ5O1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5fYnVmZmVyR2VvbWV0cnkgPT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRnZW9tZXRyeS5fYnVmZmVyR2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKS5zZXRGcm9tT2JqZWN0KCBvYmplY3QgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YnVmZmVyZ2VvbWV0cnkgPSBnZW9tZXRyeS5fYnVmZmVyR2VvbWV0cnk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF0gPSBidWZmZXJnZW9tZXRyeTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpbmZvTWVtb3J5Lmdlb21ldHJpZXMgKys7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGJ1ZmZlcmdlb21ldHJ5O1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiB1cGRhdGUoIGdlb21ldHJ5ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xcclxcblxcdFxcdFxcdHZhciBnZW9tZXRyeUF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggaW5kZXggIT09IG51bGwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YXR0cmlidXRlcy51cGRhdGUoIGluZGV4LCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgbmFtZSBpbiBnZW9tZXRyeUF0dHJpYnV0ZXMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YXR0cmlidXRlcy51cGRhdGUoIGdlb21ldHJ5QXR0cmlidXRlc1sgbmFtZSBdLCBnbC5BUlJBWV9CVUZGRVIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gbW9ycGggdGFyZ2V0c1xcclxcblxcclxcblxcdFxcdFxcdHZhciBtb3JwaEF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIG5hbWUgaW4gbW9ycGhBdHRyaWJ1dGVzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBhcnJheSA9IG1vcnBoQXR0cmlidXRlc1sgbmFtZSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0YXR0cmlidXRlcy51cGRhdGUoIGFycmF5WyBpIF0sIGdsLkFSUkFZX0JVRkZFUiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIGdldFdpcmVmcmFtZUF0dHJpYnV0ZSggZ2VvbWV0cnkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGF0dHJpYnV0ZSA9IHdpcmVmcmFtZUF0dHJpYnV0ZXNbIGdlb21ldHJ5LmlkIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBhdHRyaWJ1dGUgKSByZXR1cm4gYXR0cmlidXRlO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBpbmRpY2VzID0gW107XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGdlb21ldHJ5SW5kZXggPSBnZW9tZXRyeS5pbmRleDtcXHJcXG5cXHRcXHRcXHR2YXIgZ2VvbWV0cnlBdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBjb25zb2xlLnRpbWUoICd3aXJlZnJhbWUnICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBnZW9tZXRyeUluZGV4ICE9PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBhcnJheSA9IGdlb21ldHJ5SW5kZXguYXJyYXk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArPSAzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBhID0gYXJyYXlbIGkgKyAwIF07XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGIgPSBhcnJheVsgaSArIDEgXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgYyA9IGFycmF5WyBpICsgMiBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGluZGljZXMucHVzaCggYSwgYiwgYiwgYywgYywgYSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBhcnJheSA9IGdlb21ldHJ5QXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSAoIGFycmF5Lmxlbmd0aCAvIDMgKSAtIDE7IGkgPCBsOyBpICs9IDMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGEgPSBpICsgMDtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgYiA9IGkgKyAxO1xcclxcblxcdFxcdFxcdFxcdFxcdHZhciBjID0gaSArIDI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBiLCBjLCBjLCBhICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBjb25zb2xlLnRpbWVFbmQoICd3aXJlZnJhbWUnICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0YXR0cmlidXRlID0gbmV3ICggYXJyYXlNYXgoIGluZGljZXMgKSA+IDY1NTM1ID8gVWludDMyQnVmZmVyQXR0cmlidXRlIDogVWludDE2QnVmZmVyQXR0cmlidXRlICkoIGluZGljZXMsIDEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRhdHRyaWJ1dGVzLnVwZGF0ZSggYXR0cmlidXRlLCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiApO1xcclxcblxcclxcblxcdFxcdFxcdHdpcmVmcmFtZUF0dHJpYnV0ZXNbIGdlb21ldHJ5LmlkIF0gPSBhdHRyaWJ1dGU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGF0dHJpYnV0ZTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRnZXQ6IGdldCxcXHJcXG5cXHRcXHRcXHR1cGRhdGU6IHVwZGF0ZSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRnZXRXaXJlZnJhbWVBdHRyaWJ1dGU6IGdldFdpcmVmcmFtZUF0dHJpYnV0ZVxcclxcblxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gVW5pZm9ybXNDYWNoZSgpIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgbGlnaHRzID0ge307XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICggbGlnaHQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBsaWdodHNbIGxpZ2h0LmlkIF0gIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gbGlnaHRzWyBsaWdodC5pZCBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgdW5pZm9ybXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0c3dpdGNoICggbGlnaHQudHlwZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdEaXJlY3Rpb25hbExpZ2h0JzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR1bmlmb3JtcyA9IHtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkaXJlY3Rpb246IG5ldyBWZWN0b3IzKCksXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29sb3I6IG5ldyBDb2xvcigpLFxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNoYWRvdzogZmFsc2UsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2hhZG93QmlhczogMCxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzaGFkb3dSYWRpdXM6IDEsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2hhZG93TWFwU2l6ZTogbmV3IFZlY3RvcjIoKVxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH07XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnU3BvdExpZ2h0JzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR1bmlmb3JtcyA9IHtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRwb3NpdGlvbjogbmV3IFZlY3RvcjMoKSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkaXJlY3Rpb246IG5ldyBWZWN0b3IzKCksXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29sb3I6IG5ldyBDb2xvcigpLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRpc3RhbmNlOiAwLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbmVDb3M6IDAsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cGVudW1icmFDb3M6IDAsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGVjYXk6IDAsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2hhZG93OiBmYWxzZSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzaGFkb3dCaWFzOiAwLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNoYWRvd1JhZGl1czogMSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzaGFkb3dNYXBTaXplOiBuZXcgVmVjdG9yMigpXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdQb2ludExpZ2h0JzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR1bmlmb3JtcyA9IHtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRwb3NpdGlvbjogbmV3IFZlY3RvcjMoKSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb2xvcjogbmV3IENvbG9yKCksXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGlzdGFuY2U6IDAsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGVjYXk6IDAsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2hhZG93OiBmYWxzZSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzaGFkb3dCaWFzOiAwLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNoYWRvd1JhZGl1czogMSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzaGFkb3dNYXBTaXplOiBuZXcgVmVjdG9yMigpLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNoYWRvd0NhbWVyYU5lYXI6IDEsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2hhZG93Q2FtZXJhRmFyOiAxMDAwXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdIZW1pc3BoZXJlTGlnaHQnOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zID0ge1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRpcmVjdGlvbjogbmV3IFZlY3RvcjMoKSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRza3lDb2xvcjogbmV3IENvbG9yKCksXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Z3JvdW5kQ29sb3I6IG5ldyBDb2xvcigpXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdSZWN0QXJlYUxpZ2h0JzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR1bmlmb3JtcyA9IHtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb2xvcjogbmV3IENvbG9yKCksXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cG9zaXRpb246IG5ldyBWZWN0b3IzKCksXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aGFsZldpZHRoOiBuZXcgVmVjdG9yMygpLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGhhbGZIZWlnaHQ6IG5ldyBWZWN0b3IzKClcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBUT0RPIChhYmVsbmF0aW9uKTogc2V0IFJlY3RBcmVhTGlnaHQgc2hhZG93IHVuaWZvcm1zXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bGlnaHRzWyBsaWdodC5pZCBdID0gdW5pZm9ybXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHVuaWZvcm1zO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBXZWJHTExpZ2h0cygpIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgY2FjaGUgPSBuZXcgVW5pZm9ybXNDYWNoZSgpO1xcclxcblxcclxcblxcdFxcdHZhciBzdGF0ZSA9IHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRoYXNoOiAnJyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRhbWJpZW50OiBbIDAsIDAsIDAgXSxcXHJcXG5cXHRcXHRcXHRkaXJlY3Rpb25hbDogW10sXFxyXFxuXFx0XFx0XFx0ZGlyZWN0aW9uYWxTaGFkb3dNYXA6IFtdLFxcclxcblxcdFxcdFxcdGRpcmVjdGlvbmFsU2hhZG93TWF0cml4OiBbXSxcXHJcXG5cXHRcXHRcXHRzcG90OiBbXSxcXHJcXG5cXHRcXHRcXHRzcG90U2hhZG93TWFwOiBbXSxcXHJcXG5cXHRcXHRcXHRzcG90U2hhZG93TWF0cml4OiBbXSxcXHJcXG5cXHRcXHRcXHRyZWN0QXJlYTogW10sXFxyXFxuXFx0XFx0XFx0cG9pbnQ6IFtdLFxcclxcblxcdFxcdFxcdHBvaW50U2hhZG93TWFwOiBbXSxcXHJcXG5cXHRcXHRcXHRwb2ludFNoYWRvd01hdHJpeDogW10sXFxyXFxuXFx0XFx0XFx0aGVtaTogW11cXHJcXG5cXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdFxcdHZhciB2ZWN0b3IzID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHRcXHR2YXIgbWF0cml4NCA9IG5ldyBNYXRyaXg0KCk7XFxyXFxuXFx0XFx0dmFyIG1hdHJpeDQyID0gbmV3IE1hdHJpeDQoKTtcXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBzZXR1cCggbGlnaHRzLCBzaGFkb3dzLCBjYW1lcmEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHIgPSAwLCBnID0gMCwgYiA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGRpcmVjdGlvbmFsTGVuZ3RoID0gMDtcXHJcXG5cXHRcXHRcXHR2YXIgcG9pbnRMZW5ndGggPSAwO1xcclxcblxcdFxcdFxcdHZhciBzcG90TGVuZ3RoID0gMDtcXHJcXG5cXHRcXHRcXHR2YXIgcmVjdEFyZWFMZW5ndGggPSAwO1xcclxcblxcdFxcdFxcdHZhciBoZW1pTGVuZ3RoID0gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdmlld01hdHJpeCA9IGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2U7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbGlnaHRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGxpZ2h0ID0gbGlnaHRzWyBpIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGNvbG9yID0gbGlnaHQuY29sb3I7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGludGVuc2l0eSA9IGxpZ2h0LmludGVuc2l0eTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgZGlzdGFuY2UgPSBsaWdodC5kaXN0YW5jZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgc2hhZG93TWFwID0gKCBsaWdodC5zaGFkb3cgJiYgbGlnaHQuc2hhZG93Lm1hcCApID8gbGlnaHQuc2hhZG93Lm1hcC50ZXh0dXJlIDogbnVsbDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGxpZ2h0LmlzQW1iaWVudExpZ2h0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHIgKz0gY29sb3IuciAqIGludGVuc2l0eTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRnICs9IGNvbG9yLmcgKiBpbnRlbnNpdHk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0YiArPSBjb2xvci5iICogaW50ZW5zaXR5O1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIGxpZ2h0LmlzRGlyZWN0aW9uYWxMaWdodCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdW5pZm9ybXMgPSBjYWNoZS5nZXQoIGxpZ2h0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuY29sb3IuY29weSggbGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggbGlnaHQuaW50ZW5zaXR5ICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuZGlyZWN0aW9uLnN1YiggdmVjdG9yMyApO1xcclxcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24oIHZpZXdNYXRyaXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5zaGFkb3cgPSBsaWdodC5jYXN0U2hhZG93O1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggbGlnaHQuY2FzdFNoYWRvdyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgc2hhZG93ID0gbGlnaHQuc2hhZG93O1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLnNoYWRvd0JpYXMgPSBzaGFkb3cuYmlhcztcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5zaGFkb3dSYWRpdXMgPSBzaGFkb3cucmFkaXVzO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLnNoYWRvd01hcFNpemUgPSBzaGFkb3cubWFwU2l6ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUuZGlyZWN0aW9uYWxTaGFkb3dNYXBbIGRpcmVjdGlvbmFsTGVuZ3RoIF0gPSBzaGFkb3dNYXA7XFxyXFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUuZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXhbIGRpcmVjdGlvbmFsTGVuZ3RoIF0gPSBsaWdodC5zaGFkb3cubWF0cml4O1xcclxcblxcdFxcdFxcdFxcdFxcdHN0YXRlLmRpcmVjdGlvbmFsWyBkaXJlY3Rpb25hbExlbmd0aCBdID0gdW5pZm9ybXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0ZGlyZWN0aW9uYWxMZW5ndGggKys7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggbGlnaHQuaXNTcG90TGlnaHQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHVuaWZvcm1zID0gY2FjaGUuZ2V0KCBsaWdodCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5wb3NpdGlvbi5hcHBseU1hdHJpeDQoIHZpZXdNYXRyaXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5jb2xvci5jb3B5KCBjb2xvciApLm11bHRpcGx5U2NhbGFyKCBpbnRlbnNpdHkgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLmRpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xcclxcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLmRpcmVjdGlvbi5zdWIoIHZlY3RvcjMgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKCB2aWV3TWF0cml4ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuY29uZUNvcyA9IE1hdGguY29zKCBsaWdodC5hbmdsZSApO1xcclxcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLnBlbnVtYnJhQ29zID0gTWF0aC5jb3MoIGxpZ2h0LmFuZ2xlICogKCAxIC0gbGlnaHQucGVudW1icmEgKSApO1xcclxcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLmRlY2F5ID0gKCBsaWdodC5kaXN0YW5jZSA9PT0gMCApID8gMC4wIDogbGlnaHQuZGVjYXk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuc2hhZG93ID0gbGlnaHQuY2FzdFNoYWRvdztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGxpZ2h0LmNhc3RTaGFkb3cgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHNoYWRvdyA9IGxpZ2h0LnNoYWRvdztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5zaGFkb3dCaWFzID0gc2hhZG93LmJpYXM7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuc2hhZG93UmFkaXVzID0gc2hhZG93LnJhZGl1cztcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5zaGFkb3dNYXBTaXplID0gc2hhZG93Lm1hcFNpemU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHN0YXRlLnNwb3RTaGFkb3dNYXBbIHNwb3RMZW5ndGggXSA9IHNoYWRvd01hcDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZS5zcG90U2hhZG93TWF0cml4WyBzcG90TGVuZ3RoIF0gPSBsaWdodC5zaGFkb3cubWF0cml4O1xcclxcblxcdFxcdFxcdFxcdFxcdHN0YXRlLnNwb3RbIHNwb3RMZW5ndGggXSA9IHVuaWZvcm1zO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHNwb3RMZW5ndGggKys7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggbGlnaHQuaXNSZWN0QXJlYUxpZ2h0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciB1bmlmb3JtcyA9IGNhY2hlLmdldCggbGlnaHQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyAoYSkgaW50ZW5zaXR5IGNvbnRyb2xzIGlycmFkaWFuY2Ugb2YgZW50aXJlIGxpZ2h0XFxyXFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuY29sb3JcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQuY29weSggY29sb3IgKVxcclxcblxcdFxcdFxcdFxcdFxcdFxcdC5tdWx0aXBseVNjYWxhciggaW50ZW5zaXR5IC8gKCBsaWdodC53aWR0aCAqIGxpZ2h0LmhlaWdodCApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gKGIpIGludGVuc2l0eSBjb250cm9scyB0aGUgcmFkaWFuY2UgcGVyIGxpZ2h0IGFyZWFcXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyB1bmlmb3Jtcy5jb2xvci5jb3B5KCBjb2xvciApLm11bHRpcGx5U2NhbGFyKCBpbnRlbnNpdHkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5wb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMucG9zaXRpb24uYXBwbHlNYXRyaXg0KCB2aWV3TWF0cml4ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gZXh0cmFjdCBsb2NhbCByb3RhdGlvbiBvZiBsaWdodCB0byBkZXJpdmUgd2lkdGgvaGVpZ2h0IGhhbGYgdmVjdG9yc1xcclxcblxcdFxcdFxcdFxcdFxcdG1hdHJpeDQyLmlkZW50aXR5KCk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0bWF0cml4NC5jb3B5KCBsaWdodC5tYXRyaXhXb3JsZCApO1xcclxcblxcdFxcdFxcdFxcdFxcdG1hdHJpeDQucHJlbXVsdGlwbHkoIHZpZXdNYXRyaXggKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRtYXRyaXg0Mi5leHRyYWN0Um90YXRpb24oIG1hdHJpeDQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5oYWxmV2lkdGguc2V0KCBsaWdodC53aWR0aCAqIDAuNSwgMC4wLCAwLjAgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5oYWxmSGVpZ2h0LnNldCggMC4wLCBsaWdodC5oZWlnaHQgKiAwLjUsIDAuMCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLmhhbGZXaWR0aC5hcHBseU1hdHJpeDQoIG1hdHJpeDQyICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuaGFsZkhlaWdodC5hcHBseU1hdHJpeDQoIG1hdHJpeDQyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gVE9ETyAoYWJlbG5hdGlvbik6IFJlY3RBcmVhTGlnaHQgZGlzdGFuY2U/XFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdW5pZm9ybXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZS5yZWN0QXJlYVsgcmVjdEFyZWFMZW5ndGggXSA9IHVuaWZvcm1zO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHJlY3RBcmVhTGVuZ3RoICsrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIGxpZ2h0LmlzUG9pbnRMaWdodCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdW5pZm9ybXMgPSBjYWNoZS5nZXQoIGxpZ2h0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xcclxcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLnBvc2l0aW9uLmFwcGx5TWF0cml4NCggdmlld01hdHJpeCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLmNvbG9yLmNvcHkoIGxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIGxpZ2h0LmludGVuc2l0eSApO1xcclxcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLmRpc3RhbmNlID0gbGlnaHQuZGlzdGFuY2U7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuZGVjYXkgPSAoIGxpZ2h0LmRpc3RhbmNlID09PSAwICkgPyAwLjAgOiBsaWdodC5kZWNheTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5zaGFkb3cgPSBsaWdodC5jYXN0U2hhZG93O1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggbGlnaHQuY2FzdFNoYWRvdyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgc2hhZG93ID0gbGlnaHQuc2hhZG93O1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLnNoYWRvd0JpYXMgPSBzaGFkb3cuYmlhcztcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5zaGFkb3dSYWRpdXMgPSBzaGFkb3cucmFkaXVzO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLnNoYWRvd01hcFNpemUgPSBzaGFkb3cubWFwU2l6ZTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5zaGFkb3dDYW1lcmFOZWFyID0gc2hhZG93LmNhbWVyYS5uZWFyO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLnNoYWRvd0NhbWVyYUZhciA9IHNoYWRvdy5jYW1lcmEuZmFyO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZS5wb2ludFNoYWRvd01hcFsgcG9pbnRMZW5ndGggXSA9IHNoYWRvd01hcDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZS5wb2ludFNoYWRvd01hdHJpeFsgcG9pbnRMZW5ndGggXSA9IGxpZ2h0LnNoYWRvdy5tYXRyaXg7XFxyXFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUucG9pbnRbIHBvaW50TGVuZ3RoIF0gPSB1bmlmb3JtcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRwb2ludExlbmd0aCArKztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBsaWdodC5pc0hlbWlzcGhlcmVMaWdodCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdW5pZm9ybXMgPSBjYWNoZS5nZXQoIGxpZ2h0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKCB2aWV3TWF0cml4ICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLnNreUNvbG9yLmNvcHkoIGxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIGludGVuc2l0eSApO1xcclxcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLmdyb3VuZENvbG9yLmNvcHkoIGxpZ2h0Lmdyb3VuZENvbG9yICkubXVsdGlwbHlTY2FsYXIoIGludGVuc2l0eSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHN0YXRlLmhlbWlbIGhlbWlMZW5ndGggXSA9IHVuaWZvcm1zO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGhlbWlMZW5ndGggKys7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRzdGF0ZS5hbWJpZW50WyAwIF0gPSByO1xcclxcblxcdFxcdFxcdHN0YXRlLmFtYmllbnRbIDEgXSA9IGc7XFxyXFxuXFx0XFx0XFx0c3RhdGUuYW1iaWVudFsgMiBdID0gYjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRzdGF0ZS5kaXJlY3Rpb25hbC5sZW5ndGggPSBkaXJlY3Rpb25hbExlbmd0aDtcXHJcXG5cXHRcXHRcXHRzdGF0ZS5zcG90Lmxlbmd0aCA9IHNwb3RMZW5ndGg7XFxyXFxuXFx0XFx0XFx0c3RhdGUucmVjdEFyZWEubGVuZ3RoID0gcmVjdEFyZWFMZW5ndGg7XFxyXFxuXFx0XFx0XFx0c3RhdGUucG9pbnQubGVuZ3RoID0gcG9pbnRMZW5ndGg7XFxyXFxuXFx0XFx0XFx0c3RhdGUuaGVtaS5sZW5ndGggPSBoZW1pTGVuZ3RoO1xcclxcblxcclxcblxcdFxcdFxcdC8vIFRPRE8gKHNhbS1nLXN0ZWVsKSB3aHkgYXJlbid0IHdlIHVzaW5nIGpvaW5cXHJcXG5cXHRcXHRcXHRzdGF0ZS5oYXNoID0gZGlyZWN0aW9uYWxMZW5ndGggKyAnLCcgKyBwb2ludExlbmd0aCArICcsJyArIHNwb3RMZW5ndGggKyAnLCcgKyByZWN0QXJlYUxlbmd0aCArICcsJyArIGhlbWlMZW5ndGggKyAnLCcgKyBzaGFkb3dzLmxlbmd0aDtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHtcXHJcXG5cXHRcXHRcXHRzZXR1cDogc2V0dXAsXFxyXFxuXFx0XFx0XFx0c3RhdGU6IHN0YXRlXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBXZWJHTE9iamVjdHMoIGdlb21ldHJpZXMsIGluZm9SZW5kZXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHVwZGF0ZUxpc3QgPSB7fTtcXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiB1cGRhdGUoIG9iamVjdCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgZnJhbWUgPSBpbmZvUmVuZGVyLmZyYW1lO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcXHJcXG5cXHRcXHRcXHR2YXIgYnVmZmVyZ2VvbWV0cnkgPSBnZW9tZXRyaWVzLmdldCggb2JqZWN0LCBnZW9tZXRyeSApO1xcclxcblxcclxcblxcdFxcdFxcdC8vIFVwZGF0ZSBvbmNlIHBlciBmcmFtZVxcclxcblxcclxcblxcdFxcdFxcdGlmICggdXBkYXRlTGlzdFsgYnVmZmVyZ2VvbWV0cnkuaWQgXSAhPT0gZnJhbWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5pc0dlb21ldHJ5ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGJ1ZmZlcmdlb21ldHJ5LnVwZGF0ZUZyb21PYmplY3QoIG9iamVjdCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRnZW9tZXRyaWVzLnVwZGF0ZSggYnVmZmVyZ2VvbWV0cnkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR1cGRhdGVMaXN0WyBidWZmZXJnZW9tZXRyeS5pZCBdID0gZnJhbWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBidWZmZXJnZW9tZXRyeTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gY2xlYXIoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dXBkYXRlTGlzdCA9IHt9O1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4ge1xcclxcblxcclxcblxcdFxcdFxcdHVwZGF0ZTogdXBkYXRlLFxcclxcblxcdFxcdFxcdGNsZWFyOiBjbGVhclxcclxcblxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gYWRkTGluZU51bWJlcnMoIHN0cmluZyApIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgbGluZXMgPSBzdHJpbmcuc3BsaXQoICdcXFxcbicgKTtcXHJcXG5cXHJcXG5cXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0bGluZXNbIGkgXSA9ICggaSArIDEgKSArICc6ICcgKyBsaW5lc1sgaSBdO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gbGluZXMuam9pbiggJ1xcXFxuJyApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBXZWJHTFNoYWRlciggZ2wsIHR5cGUsIHN0cmluZyApIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCB0eXBlICk7XFxyXFxuXFxyXFxuXFx0XFx0Z2wuc2hhZGVyU291cmNlKCBzaGFkZXIsIHN0cmluZyApO1xcclxcblxcdFxcdGdsLmNvbXBpbGVTaGFkZXIoIHNoYWRlciApO1xcclxcblxcclxcblxcdFxcdGlmICggZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKCBzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTICkgPT09IGZhbHNlICkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFNoYWRlcjogU2hhZGVyIGNvdWxkblxcXFwndCBjb21waWxlLicgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCBnbC5nZXRTaGFkZXJJbmZvTG9nKCBzaGFkZXIgKSAhPT0gJycgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xTaGFkZXI6IGdsLmdldFNoYWRlckluZm9Mb2coKScsIHR5cGUgPT09IGdsLlZFUlRFWF9TSEFERVIgPyAndmVydGV4JyA6ICdmcmFnbWVudCcsIGdsLmdldFNoYWRlckluZm9Mb2coIHNoYWRlciApLCBhZGRMaW5lTnVtYmVycyggc3RyaW5nICkgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0Ly8gLS1lbmFibGUtcHJpdmlsZWdlZC13ZWJnbC1leHRlbnNpb25cXHJcXG5cXHRcXHQvLyBjb25zb2xlLmxvZyggdHlwZSwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfZGVidWdfc2hhZGVycycgKS5nZXRUcmFuc2xhdGVkU2hhZGVyU291cmNlKCBzaGFkZXIgKSApO1xcclxcblxcclxcblxcdFxcdHJldHVybiBzaGFkZXI7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0dmFyIHByb2dyYW1JZENvdW50ID0gMDtcXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBnZXRFbmNvZGluZ0NvbXBvbmVudHMoIGVuY29kaW5nICkge1xcclxcblxcclxcblxcdFxcdHN3aXRjaCAoIGVuY29kaW5nICkge1xcclxcblxcclxcblxcdFxcdFxcdGNhc2UgTGluZWFyRW5jb2Rpbmc6XFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIFsgJ0xpbmVhcicsICcoIHZhbHVlICknIF07XFxyXFxuXFx0XFx0XFx0Y2FzZSBzUkdCRW5jb2Rpbmc6XFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIFsgJ3NSR0InLCAnKCB2YWx1ZSApJyBdO1xcclxcblxcdFxcdFxcdGNhc2UgUkdCRUVuY29kaW5nOlxcclxcblxcdFxcdFxcdFxcdHJldHVybiBbICdSR0JFJywgJyggdmFsdWUgKScgXTtcXHJcXG5cXHRcXHRcXHRjYXNlIFJHQk03RW5jb2Rpbmc6XFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIFsgJ1JHQk0nLCAnKCB2YWx1ZSwgNy4wICknIF07XFxyXFxuXFx0XFx0XFx0Y2FzZSBSR0JNMTZFbmNvZGluZzpcXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWyAnUkdCTScsICcoIHZhbHVlLCAxNi4wICknIF07XFxyXFxuXFx0XFx0XFx0Y2FzZSBSR0JERW5jb2Rpbmc6XFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIFsgJ1JHQkQnLCAnKCB2YWx1ZSwgMjU2LjAgKScgXTtcXHJcXG5cXHRcXHRcXHRjYXNlIEdhbW1hRW5jb2Rpbmc6XFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIFsgJ0dhbW1hJywgJyggdmFsdWUsIGZsb2F0KCBHQU1NQV9GQUNUT1IgKSApJyBdO1xcclxcblxcdFxcdFxcdGRlZmF1bHQ6XFxyXFxuXFx0XFx0XFx0XFx0dGhyb3cgbmV3IEVycm9yKCAndW5zdXBwb3J0ZWQgZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gZ2V0VGV4ZWxEZWNvZGluZ0Z1bmN0aW9uKCBmdW5jdGlvbk5hbWUsIGVuY29kaW5nICkge1xcclxcblxcclxcblxcdFxcdHZhciBjb21wb25lbnRzID0gZ2V0RW5jb2RpbmdDb21wb25lbnRzKCBlbmNvZGluZyApO1xcclxcblxcdFxcdHJldHVybiAndmVjNCAnICsgZnVuY3Rpb25OYW1lICsgJyggdmVjNCB2YWx1ZSApIHsgcmV0dXJuICcgKyBjb21wb25lbnRzWyAwIF0gKyAnVG9MaW5lYXInICsgY29tcG9uZW50c1sgMSBdICsgJzsgfSc7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdGZ1bmN0aW9uIGdldFRleGVsRW5jb2RpbmdGdW5jdGlvbiggZnVuY3Rpb25OYW1lLCBlbmNvZGluZyApIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgY29tcG9uZW50cyA9IGdldEVuY29kaW5nQ29tcG9uZW50cyggZW5jb2RpbmcgKTtcXHJcXG5cXHRcXHRyZXR1cm4gJ3ZlYzQgJyArIGZ1bmN0aW9uTmFtZSArICcoIHZlYzQgdmFsdWUgKSB7IHJldHVybiBMaW5lYXJUbycgKyBjb21wb25lbnRzWyAwIF0gKyBjb21wb25lbnRzWyAxIF0gKyAnOyB9JztcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gZ2V0VG9uZU1hcHBpbmdGdW5jdGlvbiggZnVuY3Rpb25OYW1lLCB0b25lTWFwcGluZyApIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgdG9uZU1hcHBpbmdOYW1lO1xcclxcblxcclxcblxcdFxcdHN3aXRjaCAoIHRvbmVNYXBwaW5nICkge1xcclxcblxcclxcblxcdFxcdFxcdGNhc2UgTGluZWFyVG9uZU1hcHBpbmc6XFxyXFxuXFx0XFx0XFx0XFx0dG9uZU1hcHBpbmdOYW1lID0gJ0xpbmVhcic7XFxyXFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y2FzZSBSZWluaGFyZFRvbmVNYXBwaW5nOlxcclxcblxcdFxcdFxcdFxcdHRvbmVNYXBwaW5nTmFtZSA9ICdSZWluaGFyZCc7XFxyXFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y2FzZSBVbmNoYXJ0ZWQyVG9uZU1hcHBpbmc6XFxyXFxuXFx0XFx0XFx0XFx0dG9uZU1hcHBpbmdOYW1lID0gJ1VuY2hhcnRlZDInO1xcclxcblxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdGNhc2UgQ2luZW9uVG9uZU1hcHBpbmc6XFxyXFxuXFx0XFx0XFx0XFx0dG9uZU1hcHBpbmdOYW1lID0gJ09wdGltaXplZENpbmVvbic7XFxyXFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZGVmYXVsdDpcXHJcXG5cXHRcXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoICd1bnN1cHBvcnRlZCB0b25lTWFwcGluZzogJyArIHRvbmVNYXBwaW5nICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHJldHVybiAndmVjMyAnICsgZnVuY3Rpb25OYW1lICsgJyggdmVjMyBjb2xvciApIHsgcmV0dXJuICcgKyB0b25lTWFwcGluZ05hbWUgKyAnVG9uZU1hcHBpbmcoIGNvbG9yICk7IH0nO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBnZW5lcmF0ZUV4dGVuc2lvbnMoIGV4dGVuc2lvbnMsIHBhcmFtZXRlcnMsIHJlbmRlcmVyRXh0ZW5zaW9ucyApIHtcXHJcXG5cXHJcXG5cXHRcXHRleHRlbnNpb25zID0gZXh0ZW5zaW9ucyB8fCB7fTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgY2h1bmtzID0gW1xcclxcblxcdFxcdFxcdCggZXh0ZW5zaW9ucy5kZXJpdmF0aXZlcyB8fCBwYXJhbWV0ZXJzLmVudk1hcEN1YmVVViB8fCBwYXJhbWV0ZXJzLmJ1bXBNYXAgfHwgcGFyYW1ldGVycy5ub3JtYWxNYXAgfHwgcGFyYW1ldGVycy5mbGF0U2hhZGluZyApID8gJyNleHRlbnNpb24gR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzIDogZW5hYmxlJyA6ICcnLFxcclxcblxcdFxcdFxcdCggZXh0ZW5zaW9ucy5mcmFnRGVwdGggfHwgcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICkgJiYgcmVuZGVyZXJFeHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApID8gJyNleHRlbnNpb24gR0xfRVhUX2ZyYWdfZGVwdGggOiBlbmFibGUnIDogJycsXFxyXFxuXFx0XFx0XFx0KCBleHRlbnNpb25zLmRyYXdCdWZmZXJzICkgJiYgcmVuZGVyZXJFeHRlbnNpb25zLmdldCggJ1dFQkdMX2RyYXdfYnVmZmVycycgKSA/ICcjZXh0ZW5zaW9uIEdMX0VYVF9kcmF3X2J1ZmZlcnMgOiByZXF1aXJlJyA6ICcnLFxcclxcblxcdFxcdFxcdCggZXh0ZW5zaW9ucy5zaGFkZXJUZXh0dXJlTE9EIHx8IHBhcmFtZXRlcnMuZW52TWFwICkgJiYgcmVuZGVyZXJFeHRlbnNpb25zLmdldCggJ0VYVF9zaGFkZXJfdGV4dHVyZV9sb2QnICkgPyAnI2V4dGVuc2lvbiBHTF9FWFRfc2hhZGVyX3RleHR1cmVfbG9kIDogZW5hYmxlJyA6ICcnXFxyXFxuXFx0XFx0XTtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gY2h1bmtzLmZpbHRlciggZmlsdGVyRW1wdHlMaW5lICkuam9pbiggJ1xcXFxuJyApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBnZW5lcmF0ZURlZmluZXMoIGRlZmluZXMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGNodW5rcyA9IFtdO1xcclxcblxcclxcblxcdFxcdGZvciAoIHZhciBuYW1lIGluIGRlZmluZXMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHZhbHVlID0gZGVmaW5lc1sgbmFtZSBdO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdmFsdWUgPT09IGZhbHNlICkgY29udGludWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y2h1bmtzLnB1c2goICcjZGVmaW5lICcgKyBuYW1lICsgJyAnICsgdmFsdWUgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIGNodW5rcy5qb2luKCAnXFxcXG4nICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdGZ1bmN0aW9uIGZldGNoQXR0cmlidXRlTG9jYXRpb25zKCBnbCwgcHJvZ3JhbSApIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgYXR0cmlidXRlcyA9IHt9O1xcclxcblxcclxcblxcdFxcdHZhciBuID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuQUNUSVZFX0FUVFJJQlVURVMgKTtcXHJcXG5cXHJcXG5cXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBuOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBpbmZvID0gZ2wuZ2V0QWN0aXZlQXR0cmliKCBwcm9ncmFtLCBpICk7XFxyXFxuXFx0XFx0XFx0dmFyIG5hbWUgPSBpbmZvLm5hbWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gY29uc29sZS5sb2coICdUSFJFRS5XZWJHTFByb2dyYW06IEFDVElWRSBWRVJURVggQVRUUklCVVRFOicsIG5hbWUsIGkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRhdHRyaWJ1dGVzWyBuYW1lIF0gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgbmFtZSApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gYXR0cmlidXRlcztcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gZmlsdGVyRW1wdHlMaW5lKCBzdHJpbmcgKSB7XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHN0cmluZyAhPT0gJyc7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdGZ1bmN0aW9uIHJlcGxhY2VMaWdodE51bXMoIHN0cmluZywgcGFyYW1ldGVycyApIHtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gc3RyaW5nXFxyXFxuXFx0XFx0XFx0LnJlcGxhY2UoIC9OVU1fRElSX0xJR0hUUy9nLCBwYXJhbWV0ZXJzLm51bURpckxpZ2h0cyApXFxyXFxuXFx0XFx0XFx0LnJlcGxhY2UoIC9OVU1fU1BPVF9MSUdIVFMvZywgcGFyYW1ldGVycy5udW1TcG90TGlnaHRzIClcXHJcXG5cXHRcXHRcXHQucmVwbGFjZSggL05VTV9SRUNUX0FSRUFfTElHSFRTL2csIHBhcmFtZXRlcnMubnVtUmVjdEFyZWFMaWdodHMgKVxcclxcblxcdFxcdFxcdC5yZXBsYWNlKCAvTlVNX1BPSU5UX0xJR0hUUy9nLCBwYXJhbWV0ZXJzLm51bVBvaW50TGlnaHRzIClcXHJcXG5cXHRcXHRcXHQucmVwbGFjZSggL05VTV9IRU1JX0xJR0hUUy9nLCBwYXJhbWV0ZXJzLm51bUhlbWlMaWdodHMgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gcGFyc2VJbmNsdWRlcyggc3RyaW5nICkge1xcclxcblxcclxcblxcdFxcdHZhciBwYXR0ZXJuID0gL15bIFxcXFx0XSojaW5jbHVkZSArPChbXFxcXHdcXFxcZC5dKyk+L2dtO1xcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIHJlcGxhY2UoIG1hdGNoLCBpbmNsdWRlICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciByZXBsYWNlID0gU2hhZGVyQ2h1bmtbIGluY2x1ZGUgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHJlcGxhY2UgPT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoICdDYW4gbm90IHJlc29sdmUgI2luY2x1ZGUgPCcgKyBpbmNsdWRlICsgJz4nICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBwYXJzZUluY2x1ZGVzKCByZXBsYWNlICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcGF0dGVybiwgcmVwbGFjZSApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiB1bnJvbGxMb29wcyggc3RyaW5nICkge1xcclxcblxcclxcblxcdFxcdHZhciBwYXR0ZXJuID0gL2ZvciBcXFxcKCBpbnQgaSBcXFxcPSAoXFxcXGQrKVxcXFw7IGkgPCAoXFxcXGQrKVxcXFw7IGkgXFxcXCtcXFxcKyBcXFxcKSBcXFxceyhbXFxcXHNcXFxcU10rPykoPz1cXFxcfSlcXFxcfS9nO1xcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIHJlcGxhY2UoIG1hdGNoLCBzdGFydCwgZW5kLCBzbmlwcGV0ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB1bnJvbGwgPSAnJztcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IHBhcnNlSW50KCBzdGFydCApOyBpIDwgcGFyc2VJbnQoIGVuZCApOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHVucm9sbCArPSBzbmlwcGV0LnJlcGxhY2UoIC9cXFxcWyBpIFxcXFxdL2csICdbICcgKyBpICsgJyBdJyApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdW5yb2xsO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHBhdHRlcm4sIHJlcGxhY2UgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gV2ViR0xQcm9ncmFtKCByZW5kZXJlciwgZXh0ZW5zaW9ucywgY29kZSwgbWF0ZXJpYWwsIHNoYWRlciwgcGFyYW1ldGVycyApIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgZ2wgPSByZW5kZXJlci5jb250ZXh0O1xcclxcblxcclxcblxcdFxcdHZhciBkZWZpbmVzID0gbWF0ZXJpYWwuZGVmaW5lcztcXHJcXG5cXHJcXG5cXHRcXHR2YXIgdmVydGV4U2hhZGVyID0gc2hhZGVyLnZlcnRleFNoYWRlcjtcXHJcXG5cXHRcXHR2YXIgZnJhZ21lbnRTaGFkZXIgPSBzaGFkZXIuZnJhZ21lbnRTaGFkZXI7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfQkFTSUMnO1xcclxcblxcclxcblxcdFxcdGlmICggcGFyYW1ldGVycy5zaGFkb3dNYXBUeXBlID09PSBQQ0ZTaGFkb3dNYXAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0c2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9QQ0YnO1xcclxcblxcclxcblxcdFxcdH0gZWxzZSBpZiAoIHBhcmFtZXRlcnMuc2hhZG93TWFwVHlwZSA9PT0gUENGU29mdFNoYWRvd01hcCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRzaGFkb3dNYXBUeXBlRGVmaW5lID0gJ1NIQURPV01BUF9UWVBFX1BDRl9TT0ZUJztcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfQ1VCRSc7XFxyXFxuXFx0XFx0dmFyIGVudk1hcE1vZGVEZWZpbmUgPSAnRU5WTUFQX01PREVfUkVGTEVDVElPTic7XFxyXFxuXFx0XFx0dmFyIGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19NVUxUSVBMWSc7XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCBwYXJhbWV0ZXJzLmVudk1hcCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRzd2l0Y2ggKCBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjYXNlIEN1YmVSZWZsZWN0aW9uTWFwcGluZzpcXHJcXG5cXHRcXHRcXHRcXHRjYXNlIEN1YmVSZWZyYWN0aW9uTWFwcGluZzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0NVQkUnO1xcclxcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNhc2UgQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmc6XFxyXFxuXFx0XFx0XFx0XFx0Y2FzZSBDdWJlVVZSZWZyYWN0aW9uTWFwcGluZzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0NVQkVfVVYnO1xcclxcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNhc2UgRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmc6XFxyXFxuXFx0XFx0XFx0XFx0Y2FzZSBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0VRVUlSRUMnO1xcclxcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNhc2UgU3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0ZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9TUEhFUkUnO1xcclxcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRzd2l0Y2ggKCBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjYXNlIEN1YmVSZWZyYWN0aW9uTWFwcGluZzpcXHJcXG5cXHRcXHRcXHRcXHRjYXNlIEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nOlxcclxcblxcdFxcdFxcdFxcdFxcdGVudk1hcE1vZGVEZWZpbmUgPSAnRU5WTUFQX01PREVfUkVGUkFDVElPTic7XFxyXFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHN3aXRjaCAoIG1hdGVyaWFsLmNvbWJpbmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y2FzZSBNdWx0aXBseU9wZXJhdGlvbjpcXHJcXG5cXHRcXHRcXHRcXHRcXHRlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFknO1xcclxcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNhc2UgTWl4T3BlcmF0aW9uOlxcclxcblxcdFxcdFxcdFxcdFxcdGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19NSVgnO1xcclxcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNhc2UgQWRkT3BlcmF0aW9uOlxcclxcblxcdFxcdFxcdFxcdFxcdGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19BREQnO1xcclxcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGdhbW1hRmFjdG9yRGVmaW5lID0gKCByZW5kZXJlci5nYW1tYUZhY3RvciA+IDAgKSA/IHJlbmRlcmVyLmdhbW1hRmFjdG9yIDogMS4wO1xcclxcblxcclxcblxcdFxcdC8vIGNvbnNvbGUubG9nKCAnYnVpbGRpbmcgbmV3IHByb2dyYW0gJyApO1xcclxcblxcclxcblxcdFxcdC8vXFxyXFxuXFxyXFxuXFx0XFx0dmFyIGN1c3RvbUV4dGVuc2lvbnMgPSBnZW5lcmF0ZUV4dGVuc2lvbnMoIG1hdGVyaWFsLmV4dGVuc2lvbnMsIHBhcmFtZXRlcnMsIGV4dGVuc2lvbnMgKTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgY3VzdG9tRGVmaW5lcyA9IGdlbmVyYXRlRGVmaW5lcyggZGVmaW5lcyApO1xcclxcblxcclxcblxcdFxcdC8vXFxyXFxuXFxyXFxuXFx0XFx0dmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHByZWZpeFZlcnRleCwgcHJlZml4RnJhZ21lbnQ7XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCBtYXRlcmlhbC5pc1Jhd1NoYWRlck1hdGVyaWFsICkge1xcclxcblxcclxcblxcdFxcdFxcdHByZWZpeFZlcnRleCA9IFtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjdXN0b21EZWZpbmVzXFxyXFxuXFxyXFxuXFx0XFx0XFx0XS5maWx0ZXIoIGZpbHRlckVtcHR5TGluZSApLmpvaW4oICdcXFxcbicgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHByZWZpeFZlcnRleC5sZW5ndGggPiAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHByZWZpeFZlcnRleCArPSAnXFxcXG4nO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRwcmVmaXhGcmFnbWVudCA9IFtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjdXN0b21FeHRlbnNpb25zLFxcclxcblxcdFxcdFxcdFxcdGN1c3RvbURlZmluZXNcXHJcXG5cXHJcXG5cXHRcXHRcXHRdLmZpbHRlciggZmlsdGVyRW1wdHlMaW5lICkuam9pbiggJ1xcXFxuJyApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggcHJlZml4RnJhZ21lbnQubGVuZ3RoID4gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRwcmVmaXhGcmFnbWVudCArPSAnXFxcXG4nO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdHByZWZpeFZlcnRleCA9IFtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgZmxvYXQ7JyxcXHJcXG5cXHRcXHRcXHRcXHQncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgaW50OycsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0JyNkZWZpbmUgU0hBREVSX05BTUUgJyArIHNoYWRlci5uYW1lLFxcclxcblxcclxcblxcdFxcdFxcdFxcdGN1c3RvbURlZmluZXMsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5zdXBwb3J0c1ZlcnRleFRleHR1cmVzID8gJyNkZWZpbmUgVkVSVEVYX1RFWFRVUkVTJyA6ICcnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdCcjZGVmaW5lIEdBTU1BX0ZBQ1RPUiAnICsgZ2FtbWFGYWN0b3JEZWZpbmUsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0JyNkZWZpbmUgTUFYX0JPTkVTICcgKyBwYXJhbWV0ZXJzLm1heEJvbmVzLFxcclxcblxcdFxcdFxcdFxcdCggcGFyYW1ldGVycy51c2VGb2cgJiYgcGFyYW1ldGVycy5mb2cgKSA/ICcjZGVmaW5lIFVTRV9GT0cnIDogJycsXFxyXFxuXFx0XFx0XFx0XFx0KCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZ0V4cCApID8gJyNkZWZpbmUgRk9HX0VYUDInIDogJycsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5tYXAgPyAnI2RlZmluZSBVU0VfTUFQJyA6ICcnLFxcclxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgVVNFX0VOVk1BUCcgOiAnJyxcXHJcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBNb2RlRGVmaW5lIDogJycsXFxyXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5saWdodE1hcCA/ICcjZGVmaW5lIFVTRV9MSUdIVE1BUCcgOiAnJyxcXHJcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmFvTWFwID8gJyNkZWZpbmUgVVNFX0FPTUFQJyA6ICcnLFxcclxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuZW1pc3NpdmVNYXAgPyAnI2RlZmluZSBVU0VfRU1JU1NJVkVNQVAnIDogJycsXFxyXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5idW1wTWFwID8gJyNkZWZpbmUgVVNFX0JVTVBNQVAnIDogJycsXFxyXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5ub3JtYWxNYXAgPyAnI2RlZmluZSBVU0VfTk9STUFMTUFQJyA6ICcnLFxcclxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuZGlzcGxhY2VtZW50TWFwICYmIHBhcmFtZXRlcnMuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA/ICcjZGVmaW5lIFVTRV9ESVNQTEFDRU1FTlRNQVAnIDogJycsXFxyXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5zcGVjdWxhck1hcCA/ICcjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUCcgOiAnJyxcXHJcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLnJvdWdobmVzc01hcCA/ICcjZGVmaW5lIFVTRV9ST1VHSE5FU1NNQVAnIDogJycsXFxyXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5tZXRhbG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfTUVUQUxORVNTTUFQJyA6ICcnLFxcclxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuYWxwaGFNYXAgPyAnI2RlZmluZSBVU0VfQUxQSEFNQVAnIDogJycsXFxyXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy52ZXJ0ZXhDb2xvcnMgPyAnI2RlZmluZSBVU0VfQ09MT1InIDogJycsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5mbGF0U2hhZGluZyA/ICcjZGVmaW5lIEZMQVRfU0hBREVEJyA6ICcnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuc2tpbm5pbmcgPyAnI2RlZmluZSBVU0VfU0tJTk5JTkcnIDogJycsXFxyXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy51c2VWZXJ0ZXhUZXh0dXJlID8gJyNkZWZpbmUgQk9ORV9URVhUVVJFJyA6ICcnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzID8gJyNkZWZpbmUgVVNFX01PUlBIVEFSR0VUUycgOiAnJyxcXHJcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLm1vcnBoTm9ybWFscyAmJiBwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID09PSBmYWxzZSA/ICcjZGVmaW5lIFVTRV9NT1JQSE5PUk1BTFMnIDogJycsXFxyXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5kb3VibGVTaWRlZCA/ICcjZGVmaW5lIERPVUJMRV9TSURFRCcgOiAnJyxcXHJcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmZsaXBTaWRlZCA/ICcjZGVmaW5lIEZMSVBfU0lERUQnIDogJycsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0JyNkZWZpbmUgTlVNX0NMSVBQSU5HX1BMQU5FUyAnICsgcGFyYW1ldGVycy5udW1DbGlwcGluZ1BsYW5lcyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSBVU0VfU0hBRE9XTUFQJyA6ICcnLFxcclxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lICcgKyBzaGFkb3dNYXBUeXBlRGVmaW5lIDogJycsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5zaXplQXR0ZW51YXRpb24gPyAnI2RlZmluZSBVU0VfU0laRUFUVEVOVUFUSU9OJyA6ICcnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA/ICcjZGVmaW5lIFVTRV9MT0dERVBUSEJVRicgOiAnJyxcXHJcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgJiYgZXh0ZW5zaW9ucy5nZXQoICdFWFRfZnJhZ19kZXB0aCcgKSA/ICcjZGVmaW5lIFVTRV9MT0dERVBUSEJVRl9FWFQnIDogJycsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0J3VuaWZvcm0gbWF0NCBtb2RlbE1hdHJpeDsnLFxcclxcblxcdFxcdFxcdFxcdCd1bmlmb3JtIG1hdDQgbW9kZWxWaWV3TWF0cml4OycsXFxyXFxuXFx0XFx0XFx0XFx0J3VuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4OycsXFxyXFxuXFx0XFx0XFx0XFx0J3VuaWZvcm0gbWF0NCB2aWV3TWF0cml4OycsXFxyXFxuXFx0XFx0XFx0XFx0J3VuaWZvcm0gbWF0MyBub3JtYWxNYXRyaXg7JyxcXHJcXG5cXHRcXHRcXHRcXHQndW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uOycsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0J2F0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uOycsXFxyXFxuXFx0XFx0XFx0XFx0J2F0dHJpYnV0ZSB2ZWMzIG5vcm1hbDsnLFxcclxcblxcdFxcdFxcdFxcdCdhdHRyaWJ1dGUgdmVjMiB1djsnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdCcjaWZkZWYgVVNFX0NPTE9SJyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQnXFx0YXR0cmlidXRlIHZlYzMgY29sb3I7JyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQnI2VuZGlmJyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQnI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFMnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdCdcXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDA7JyxcXHJcXG5cXHRcXHRcXHRcXHQnXFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQxOycsXFxyXFxuXFx0XFx0XFx0XFx0J1xcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MjsnLFxcclxcblxcdFxcdFxcdFxcdCdcXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDM7JyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQnXFx0I2lmZGVmIFVTRV9NT1JQSE5PUk1BTFMnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdCdcXHRcXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDA7JyxcXHJcXG5cXHRcXHRcXHRcXHQnXFx0XFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwxOycsXFxyXFxuXFx0XFx0XFx0XFx0J1xcdFxcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMjsnLFxcclxcblxcdFxcdFxcdFxcdCdcXHRcXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDM7JyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQnXFx0I2Vsc2UnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdCdcXHRcXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDQ7JyxcXHJcXG5cXHRcXHRcXHRcXHQnXFx0XFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ1OycsXFxyXFxuXFx0XFx0XFx0XFx0J1xcdFxcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NjsnLFxcclxcblxcdFxcdFxcdFxcdCdcXHRcXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDc7JyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQnXFx0I2VuZGlmJyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQnI2VuZGlmJyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQnI2lmZGVmIFVTRV9TS0lOTklORycsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0J1xcdGF0dHJpYnV0ZSB2ZWM0IHNraW5JbmRleDsnLFxcclxcblxcdFxcdFxcdFxcdCdcXHRhdHRyaWJ1dGUgdmVjNCBza2luV2VpZ2h0OycsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0JyNlbmRpZicsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0J1xcXFxuJ1xcclxcblxcclxcblxcdFxcdFxcdF0uZmlsdGVyKCBmaWx0ZXJFbXB0eUxpbmUgKS5qb2luKCAnXFxcXG4nICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cHJlZml4RnJhZ21lbnQgPSBbXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y3VzdG9tRXh0ZW5zaW9ucyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgZmxvYXQ7JyxcXHJcXG5cXHRcXHRcXHRcXHQncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgaW50OycsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0JyNkZWZpbmUgU0hBREVSX05BTUUgJyArIHNoYWRlci5uYW1lLFxcclxcblxcclxcblxcdFxcdFxcdFxcdGN1c3RvbURlZmluZXMsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5hbHBoYVRlc3QgPyAnI2RlZmluZSBBTFBIQVRFU1QgJyArIHBhcmFtZXRlcnMuYWxwaGFUZXN0IDogJycsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0JyNkZWZpbmUgR0FNTUFfRkFDVE9SICcgKyBnYW1tYUZhY3RvckRlZmluZSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQoIHBhcmFtZXRlcnMudXNlRm9nICYmIHBhcmFtZXRlcnMuZm9nICkgPyAnI2RlZmluZSBVU0VfRk9HJyA6ICcnLFxcclxcblxcdFxcdFxcdFxcdCggcGFyYW1ldGVycy51c2VGb2cgJiYgcGFyYW1ldGVycy5mb2dFeHAgKSA/ICcjZGVmaW5lIEZPR19FWFAyJyA6ICcnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMubWFwID8gJyNkZWZpbmUgVVNFX01BUCcgOiAnJyxcXHJcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lIFVTRV9FTlZNQVAnIDogJycsXFxyXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwVHlwZURlZmluZSA6ICcnLFxcclxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcE1vZGVEZWZpbmUgOiAnJyxcXHJcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBCbGVuZGluZ0RlZmluZSA6ICcnLFxcclxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMubGlnaHRNYXAgPyAnI2RlZmluZSBVU0VfTElHSFRNQVAnIDogJycsXFxyXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5hb01hcCA/ICcjZGVmaW5lIFVTRV9BT01BUCcgOiAnJyxcXHJcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwID8gJyNkZWZpbmUgVVNFX0VNSVNTSVZFTUFQJyA6ICcnLFxcclxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuYnVtcE1hcCA/ICcjZGVmaW5lIFVTRV9CVU1QTUFQJyA6ICcnLFxcclxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMubm9ybWFsTWFwID8gJyNkZWZpbmUgVVNFX05PUk1BTE1BUCcgOiAnJyxcXHJcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwID8gJyNkZWZpbmUgVVNFX1NQRUNVTEFSTUFQJyA6ICcnLFxcclxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMucm91Z2huZXNzTWFwID8gJyNkZWZpbmUgVVNFX1JPVUdITkVTU01BUCcgOiAnJyxcXHJcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLm1ldGFsbmVzc01hcCA/ICcjZGVmaW5lIFVTRV9NRVRBTE5FU1NNQVAnIDogJycsXFxyXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5hbHBoYU1hcCA/ICcjZGVmaW5lIFVTRV9BTFBIQU1BUCcgOiAnJyxcXHJcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLnZlcnRleENvbG9ycyA/ICcjZGVmaW5lIFVTRV9DT0xPUicgOiAnJyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmdyYWRpZW50TWFwID8gJyNkZWZpbmUgVVNFX0dSQURJRU5UTUFQJyA6ICcnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgPyAnI2RlZmluZSBGTEFUX1NIQURFRCcgOiAnJyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmRvdWJsZVNpZGVkID8gJyNkZWZpbmUgRE9VQkxFX1NJREVEJyA6ICcnLFxcclxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuZmxpcFNpZGVkID8gJyNkZWZpbmUgRkxJUF9TSURFRCcgOiAnJyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQnI2RlZmluZSBOVU1fQ0xJUFBJTkdfUExBTkVTICcgKyBwYXJhbWV0ZXJzLm51bUNsaXBwaW5nUGxhbmVzLFxcclxcblxcdFxcdFxcdFxcdCcjZGVmaW5lIFVOSU9OX0NMSVBQSU5HX1BMQU5FUyAnICsgKCBwYXJhbWV0ZXJzLm51bUNsaXBwaW5nUGxhbmVzIC0gcGFyYW1ldGVycy5udW1DbGlwSW50ZXJzZWN0aW9uICksXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gJyNkZWZpbmUgVVNFX1NIQURPV01BUCcgOiAnJyxcXHJcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSAnICsgc2hhZG93TWFwVHlwZURlZmluZSA6ICcnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMucHJlbXVsdGlwbGllZEFscGhhID8gJyNkZWZpbmUgUFJFTVVMVElQTElFRF9BTFBIQScgOiAnJyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLnBoeXNpY2FsbHlDb3JyZWN0TGlnaHRzID8gJyNkZWZpbmUgUEhZU0lDQUxMWV9DT1JSRUNUX0xJR0hUUycgOiAnJyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUYnIDogJycsXFxyXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICYmIGV4dGVuc2lvbnMuZ2V0KCAnRVhUX2ZyYWdfZGVwdGgnICkgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUZfRVhUJyA6ICcnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuZW52TWFwICYmIGV4dGVuc2lvbnMuZ2V0KCAnRVhUX3NoYWRlcl90ZXh0dXJlX2xvZCcgKSA/ICcjZGVmaW5lIFRFWFRVUkVfTE9EX0VYVCcgOiAnJyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQndW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7JyxcXHJcXG5cXHRcXHRcXHRcXHQndW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uOycsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0KCBwYXJhbWV0ZXJzLnRvbmVNYXBwaW5nICE9PSBOb1RvbmVNYXBwaW5nICkgPyAnI2RlZmluZSBUT05FX01BUFBJTkcnIDogJycsXFxyXFxuXFx0XFx0XFx0XFx0KCBwYXJhbWV0ZXJzLnRvbmVNYXBwaW5nICE9PSBOb1RvbmVNYXBwaW5nICkgPyBTaGFkZXJDaHVua1sgJ3RvbmVtYXBwaW5nX3BhcnNfZnJhZ21lbnQnIF0gOiAnJywgLy8gdGhpcyBjb2RlIGlzIHJlcXVpcmVkIGhlcmUgYmVjYXVzZSBpdCBpcyB1c2VkIGJ5IHRoZSB0b25lTWFwcGluZygpIGZ1bmN0aW9uIGRlZmluZWQgYmVsb3dcXHJcXG5cXHRcXHRcXHRcXHQoIHBhcmFtZXRlcnMudG9uZU1hcHBpbmcgIT09IE5vVG9uZU1hcHBpbmcgKSA/IGdldFRvbmVNYXBwaW5nRnVuY3Rpb24oICd0b25lTWFwcGluZycsIHBhcmFtZXRlcnMudG9uZU1hcHBpbmcgKSA6ICcnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuZGl0aGVyaW5nID8gJyNkZWZpbmUgRElUSEVSSU5HJyA6ICcnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdCggcGFyYW1ldGVycy5vdXRwdXRFbmNvZGluZyB8fCBwYXJhbWV0ZXJzLm1hcEVuY29kaW5nIHx8IHBhcmFtZXRlcnMuZW52TWFwRW5jb2RpbmcgfHwgcGFyYW1ldGVycy5lbWlzc2l2ZU1hcEVuY29kaW5nICkgPyBTaGFkZXJDaHVua1sgJ2VuY29kaW5nc19wYXJzX2ZyYWdtZW50JyBdIDogJycsIC8vIHRoaXMgY29kZSBpcyByZXF1aXJlZCBoZXJlIGJlY2F1c2UgaXQgaXMgdXNlZCBieSB0aGUgdmFyaW91cyBlbmNvZGluZy9kZWNvZGluZyBmdW5jdGlvbiBkZWZpbmVkIGJlbG93XFxyXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5tYXBFbmNvZGluZyA/IGdldFRleGVsRGVjb2RpbmdGdW5jdGlvbiggJ21hcFRleGVsVG9MaW5lYXInLCBwYXJhbWV0ZXJzLm1hcEVuY29kaW5nICkgOiAnJyxcXHJcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmVudk1hcEVuY29kaW5nID8gZ2V0VGV4ZWxEZWNvZGluZ0Z1bmN0aW9uKCAnZW52TWFwVGV4ZWxUb0xpbmVhcicsIHBhcmFtZXRlcnMuZW52TWFwRW5jb2RpbmcgKSA6ICcnLFxcclxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuZW1pc3NpdmVNYXBFbmNvZGluZyA/IGdldFRleGVsRGVjb2RpbmdGdW5jdGlvbiggJ2VtaXNzaXZlTWFwVGV4ZWxUb0xpbmVhcicsIHBhcmFtZXRlcnMuZW1pc3NpdmVNYXBFbmNvZGluZyApIDogJycsXFxyXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5vdXRwdXRFbmNvZGluZyA/IGdldFRleGVsRW5jb2RpbmdGdW5jdGlvbiggJ2xpbmVhclRvT3V0cHV0VGV4ZWwnLCBwYXJhbWV0ZXJzLm91dHB1dEVuY29kaW5nICkgOiAnJyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmRlcHRoUGFja2luZyA/ICcjZGVmaW5lIERFUFRIX1BBQ0tJTkcgJyArIG1hdGVyaWFsLmRlcHRoUGFja2luZyA6ICcnLFxcclxcblxcclxcblxcdFxcdFxcdFxcdCdcXFxcbidcXHJcXG5cXHJcXG5cXHRcXHRcXHRdLmZpbHRlciggZmlsdGVyRW1wdHlMaW5lICkuam9pbiggJ1xcXFxuJyApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR2ZXJ0ZXhTaGFkZXIgPSBwYXJzZUluY2x1ZGVzKCB2ZXJ0ZXhTaGFkZXIgKTtcXHJcXG5cXHRcXHR2ZXJ0ZXhTaGFkZXIgPSByZXBsYWNlTGlnaHROdW1zKCB2ZXJ0ZXhTaGFkZXIsIHBhcmFtZXRlcnMgKTtcXHJcXG5cXHJcXG5cXHRcXHRmcmFnbWVudFNoYWRlciA9IHBhcnNlSW5jbHVkZXMoIGZyYWdtZW50U2hhZGVyICk7XFxyXFxuXFx0XFx0ZnJhZ21lbnRTaGFkZXIgPSByZXBsYWNlTGlnaHROdW1zKCBmcmFnbWVudFNoYWRlciwgcGFyYW1ldGVycyApO1xcclxcblxcclxcblxcdFxcdGlmICggISBtYXRlcmlhbC5pc1NoYWRlck1hdGVyaWFsICkge1xcclxcblxcclxcblxcdFxcdFxcdHZlcnRleFNoYWRlciA9IHVucm9sbExvb3BzKCB2ZXJ0ZXhTaGFkZXIgKTtcXHJcXG5cXHRcXHRcXHRmcmFnbWVudFNoYWRlciA9IHVucm9sbExvb3BzKCBmcmFnbWVudFNoYWRlciApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR2YXIgdmVydGV4R2xzbCA9IHByZWZpeFZlcnRleCArIHZlcnRleFNoYWRlcjtcXHJcXG5cXHRcXHR2YXIgZnJhZ21lbnRHbHNsID0gcHJlZml4RnJhZ21lbnQgKyBmcmFnbWVudFNoYWRlcjtcXHJcXG5cXHJcXG5cXHRcXHQvLyBjb25zb2xlLmxvZyggJypWRVJURVgqJywgdmVydGV4R2xzbCApO1xcclxcblxcdFxcdC8vIGNvbnNvbGUubG9nKCAnKkZSQUdNRU5UKicsIGZyYWdtZW50R2xzbCApO1xcclxcblxcclxcblxcdFxcdHZhciBnbFZlcnRleFNoYWRlciA9IFdlYkdMU2hhZGVyKCBnbCwgZ2wuVkVSVEVYX1NIQURFUiwgdmVydGV4R2xzbCApO1xcclxcblxcdFxcdHZhciBnbEZyYWdtZW50U2hhZGVyID0gV2ViR0xTaGFkZXIoIGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIGZyYWdtZW50R2xzbCApO1xcclxcblxcclxcblxcdFxcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZ2xWZXJ0ZXhTaGFkZXIgKTtcXHJcXG5cXHRcXHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGdsRnJhZ21lbnRTaGFkZXIgKTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBGb3JjZSBhIHBhcnRpY3VsYXIgYXR0cmlidXRlIHRvIGluZGV4IDAuXFxyXFxuXFxyXFxuXFx0XFx0aWYgKCBtYXRlcmlhbC5pbmRleDBBdHRyaWJ1dGVOYW1lICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Z2wuYmluZEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCAwLCBtYXRlcmlhbC5pbmRleDBBdHRyaWJ1dGVOYW1lICk7XFxyXFxuXFxyXFxuXFx0XFx0fSBlbHNlIGlmICggcGFyYW1ldGVycy5tb3JwaFRhcmdldHMgPT09IHRydWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gcHJvZ3JhbXMgd2l0aCBtb3JwaFRhcmdldHMgZGlzcGxhY2UgcG9zaXRpb24gb3V0IG9mIGF0dHJpYnV0ZSAwXFxyXFxuXFx0XFx0XFx0Z2wuYmluZEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCAwLCAncG9zaXRpb24nICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGdsLmxpbmtQcm9ncmFtKCBwcm9ncmFtICk7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHByb2dyYW1Mb2cgPSBnbC5nZXRQcm9ncmFtSW5mb0xvZyggcHJvZ3JhbSApO1xcclxcblxcdFxcdHZhciB2ZXJ0ZXhMb2cgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKCBnbFZlcnRleFNoYWRlciApO1xcclxcblxcdFxcdHZhciBmcmFnbWVudExvZyA9IGdsLmdldFNoYWRlckluZm9Mb2coIGdsRnJhZ21lbnRTaGFkZXIgKTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgcnVubmFibGUgPSB0cnVlO1xcclxcblxcdFxcdHZhciBoYXZlRGlhZ25vc3RpY3MgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdC8vIGNvbnNvbGUubG9nKCAnKipWRVJURVgqKicsIGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2RlYnVnX3NoYWRlcnMnICkuZ2V0VHJhbnNsYXRlZFNoYWRlclNvdXJjZSggZ2xWZXJ0ZXhTaGFkZXIgKSApO1xcclxcblxcdFxcdC8vIGNvbnNvbGUubG9nKCAnKipGUkFHTUVOVCoqJywgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfZGVidWdfc2hhZGVycycgKS5nZXRUcmFuc2xhdGVkU2hhZGVyU291cmNlKCBnbEZyYWdtZW50U2hhZGVyICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRpZiAoIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLkxJTktfU1RBVFVTICkgPT09IGZhbHNlICkge1xcclxcblxcclxcblxcdFxcdFxcdHJ1bm5hYmxlID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUHJvZ3JhbTogc2hhZGVyIGVycm9yOiAnLCBnbC5nZXRFcnJvcigpLCAnZ2wuVkFMSURBVEVfU1RBVFVTJywgZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuVkFMSURBVEVfU1RBVFVTICksICdnbC5nZXRQcm9ncmFtSW5mb0xvZycsIHByb2dyYW1Mb2csIHZlcnRleExvZywgZnJhZ21lbnRMb2cgKTtcXHJcXG5cXHJcXG5cXHRcXHR9IGVsc2UgaWYgKCBwcm9ncmFtTG9nICE9PSAnJyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW06IGdsLmdldFByb2dyYW1JbmZvTG9nKCknLCBwcm9ncmFtTG9nICk7XFxyXFxuXFxyXFxuXFx0XFx0fSBlbHNlIGlmICggdmVydGV4TG9nID09PSAnJyB8fCBmcmFnbWVudExvZyA9PT0gJycgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aGF2ZURpYWdub3N0aWNzID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGlmICggaGF2ZURpYWdub3N0aWNzICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuZGlhZ25vc3RpY3MgPSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cnVubmFibGU6IHJ1bm5hYmxlLFxcclxcblxcdFxcdFxcdFxcdG1hdGVyaWFsOiBtYXRlcmlhbCxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRwcm9ncmFtTG9nOiBwcm9ncmFtTG9nLFxcclxcblxcclxcblxcdFxcdFxcdFxcdHZlcnRleFNoYWRlcjoge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGxvZzogdmVydGV4TG9nLFxcclxcblxcdFxcdFxcdFxcdFxcdHByZWZpeDogcHJlZml4VmVydGV4XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmcmFnbWVudFNoYWRlcjoge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGxvZzogZnJhZ21lbnRMb2csXFxyXFxuXFx0XFx0XFx0XFx0XFx0cHJlZml4OiBwcmVmaXhGcmFnbWVudFxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHQvLyBjbGVhbiB1cFxcclxcblxcclxcblxcdFxcdGdsLmRlbGV0ZVNoYWRlciggZ2xWZXJ0ZXhTaGFkZXIgKTtcXHJcXG5cXHRcXHRnbC5kZWxldGVTaGFkZXIoIGdsRnJhZ21lbnRTaGFkZXIgKTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBzZXQgdXAgY2FjaGluZyBmb3IgdW5pZm9ybSBsb2NhdGlvbnNcXHJcXG5cXHJcXG5cXHRcXHR2YXIgY2FjaGVkVW5pZm9ybXM7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5nZXRVbmlmb3JtcyA9IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGNhY2hlZFVuaWZvcm1zID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y2FjaGVkVW5pZm9ybXMgPSBuZXcgV2ViR0xVbmlmb3JtcyggZ2wsIHByb2dyYW0sIHJlbmRlcmVyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBjYWNoZWRVbmlmb3JtcztcXHJcXG5cXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdFxcdC8vIHNldCB1cCBjYWNoaW5nIGZvciBhdHRyaWJ1dGUgbG9jYXRpb25zXFxyXFxuXFxyXFxuXFx0XFx0dmFyIGNhY2hlZEF0dHJpYnV0ZXM7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5nZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggY2FjaGVkQXR0cmlidXRlcyA9PT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNhY2hlZEF0dHJpYnV0ZXMgPSBmZXRjaEF0dHJpYnV0ZUxvY2F0aW9ucyggZ2wsIHByb2dyYW0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGNhY2hlZEF0dHJpYnV0ZXM7XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBmcmVlIHJlc291cmNlXFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdGdsLmRlbGV0ZVByb2dyYW0oIHByb2dyYW0gKTtcXHJcXG5cXHRcXHRcXHR0aGlzLnByb2dyYW0gPSB1bmRlZmluZWQ7XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBERVBSRUNBVEVEXFxyXFxuXFxyXFxuXFx0XFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR1bmlmb3Jtczoge1xcclxcblxcdFxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUHJvZ3JhbTogLnVuaWZvcm1zIGlzIG5vdyAuZ2V0VW5pZm9ybXMoKS4nICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2V0VW5pZm9ybXMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFx0XFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRhdHRyaWJ1dGVzOiB7XFxyXFxuXFx0XFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xQcm9ncmFtOiAuYXR0cmlidXRlcyBpcyBub3cgLmdldEF0dHJpYnV0ZXMoKS4nICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlcygpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fSApO1xcclxcblxcclxcblxcclxcblxcdFxcdC8vXFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5pZCA9IHByb2dyYW1JZENvdW50ICsrO1xcclxcblxcdFxcdHRoaXMuY29kZSA9IGNvZGU7XFxyXFxuXFx0XFx0dGhpcy51c2VkVGltZXMgPSAxO1xcclxcblxcdFxcdHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XFxyXFxuXFx0XFx0dGhpcy52ZXJ0ZXhTaGFkZXIgPSBnbFZlcnRleFNoYWRlcjtcXHJcXG5cXHRcXHR0aGlzLmZyYWdtZW50U2hhZGVyID0gZ2xGcmFnbWVudFNoYWRlcjtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBXZWJHTFByb2dyYW1zKCByZW5kZXJlciwgZXh0ZW5zaW9ucywgY2FwYWJpbGl0aWVzICkge1xcclxcblxcclxcblxcdFxcdHZhciBwcm9ncmFtcyA9IFtdO1xcclxcblxcclxcblxcdFxcdHZhciBzaGFkZXJJRHMgPSB7XFxyXFxuXFx0XFx0XFx0TWVzaERlcHRoTWF0ZXJpYWw6ICdkZXB0aCcsXFxyXFxuXFx0XFx0XFx0TWVzaERpc3RhbmNlTWF0ZXJpYWw6ICdkaXN0YW5jZVJHQkEnLFxcclxcblxcdFxcdFxcdE1lc2hOb3JtYWxNYXRlcmlhbDogJ25vcm1hbCcsXFxyXFxuXFx0XFx0XFx0TWVzaEJhc2ljTWF0ZXJpYWw6ICdiYXNpYycsXFxyXFxuXFx0XFx0XFx0TWVzaExhbWJlcnRNYXRlcmlhbDogJ2xhbWJlcnQnLFxcclxcblxcdFxcdFxcdE1lc2hQaG9uZ01hdGVyaWFsOiAncGhvbmcnLFxcclxcblxcdFxcdFxcdE1lc2hUb29uTWF0ZXJpYWw6ICdwaG9uZycsXFxyXFxuXFx0XFx0XFx0TWVzaFN0YW5kYXJkTWF0ZXJpYWw6ICdwaHlzaWNhbCcsXFxyXFxuXFx0XFx0XFx0TWVzaFBoeXNpY2FsTWF0ZXJpYWw6ICdwaHlzaWNhbCcsXFxyXFxuXFx0XFx0XFx0TGluZUJhc2ljTWF0ZXJpYWw6ICdiYXNpYycsXFxyXFxuXFx0XFx0XFx0TGluZURhc2hlZE1hdGVyaWFsOiAnZGFzaGVkJyxcXHJcXG5cXHRcXHRcXHRQb2ludHNNYXRlcmlhbDogJ3BvaW50cycsXFxyXFxuXFx0XFx0XFx0U2hhZG93TWF0ZXJpYWw6ICdzaGFkb3cnXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgcGFyYW1ldGVyTmFtZXMgPSBbXFxyXFxuXFx0XFx0XFx0XFxcInByZWNpc2lvblxcXCIsIFxcXCJzdXBwb3J0c1ZlcnRleFRleHR1cmVzXFxcIiwgXFxcIm1hcFxcXCIsIFxcXCJtYXBFbmNvZGluZ1xcXCIsIFxcXCJlbnZNYXBcXFwiLCBcXFwiZW52TWFwTW9kZVxcXCIsIFxcXCJlbnZNYXBFbmNvZGluZ1xcXCIsXFxyXFxuXFx0XFx0XFx0XFxcImxpZ2h0TWFwXFxcIiwgXFxcImFvTWFwXFxcIiwgXFxcImVtaXNzaXZlTWFwXFxcIiwgXFxcImVtaXNzaXZlTWFwRW5jb2RpbmdcXFwiLCBcXFwiYnVtcE1hcFxcXCIsIFxcXCJub3JtYWxNYXBcXFwiLCBcXFwiZGlzcGxhY2VtZW50TWFwXFxcIiwgXFxcInNwZWN1bGFyTWFwXFxcIixcXHJcXG5cXHRcXHRcXHRcXFwicm91Z2huZXNzTWFwXFxcIiwgXFxcIm1ldGFsbmVzc01hcFxcXCIsIFxcXCJncmFkaWVudE1hcFxcXCIsXFxyXFxuXFx0XFx0XFx0XFxcImFscGhhTWFwXFxcIiwgXFxcImNvbWJpbmVcXFwiLCBcXFwidmVydGV4Q29sb3JzXFxcIiwgXFxcImZvZ1xcXCIsIFxcXCJ1c2VGb2dcXFwiLCBcXFwiZm9nRXhwXFxcIixcXHJcXG5cXHRcXHRcXHRcXFwiZmxhdFNoYWRpbmdcXFwiLCBcXFwic2l6ZUF0dGVudWF0aW9uXFxcIiwgXFxcImxvZ2FyaXRobWljRGVwdGhCdWZmZXJcXFwiLCBcXFwic2tpbm5pbmdcXFwiLFxcclxcblxcdFxcdFxcdFxcXCJtYXhCb25lc1xcXCIsIFxcXCJ1c2VWZXJ0ZXhUZXh0dXJlXFxcIiwgXFxcIm1vcnBoVGFyZ2V0c1xcXCIsIFxcXCJtb3JwaE5vcm1hbHNcXFwiLFxcclxcblxcdFxcdFxcdFxcXCJtYXhNb3JwaFRhcmdldHNcXFwiLCBcXFwibWF4TW9ycGhOb3JtYWxzXFxcIiwgXFxcInByZW11bHRpcGxpZWRBbHBoYVxcXCIsXFxyXFxuXFx0XFx0XFx0XFxcIm51bURpckxpZ2h0c1xcXCIsIFxcXCJudW1Qb2ludExpZ2h0c1xcXCIsIFxcXCJudW1TcG90TGlnaHRzXFxcIiwgXFxcIm51bUhlbWlMaWdodHNcXFwiLCBcXFwibnVtUmVjdEFyZWFMaWdodHNcXFwiLFxcclxcblxcdFxcdFxcdFxcXCJzaGFkb3dNYXBFbmFibGVkXFxcIiwgXFxcInNoYWRvd01hcFR5cGVcXFwiLCBcXFwidG9uZU1hcHBpbmdcXFwiLCAncGh5c2ljYWxseUNvcnJlY3RMaWdodHMnLFxcclxcblxcdFxcdFxcdFxcXCJhbHBoYVRlc3RcXFwiLCBcXFwiZG91YmxlU2lkZWRcXFwiLCBcXFwiZmxpcFNpZGVkXFxcIiwgXFxcIm51bUNsaXBwaW5nUGxhbmVzXFxcIiwgXFxcIm51bUNsaXBJbnRlcnNlY3Rpb25cXFwiLCBcXFwiZGVwdGhQYWNraW5nXFxcIiwgXFxcImRpdGhlcmluZ1xcXCJcXHJcXG5cXHRcXHRdO1xcclxcblxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIGFsbG9jYXRlQm9uZXMoIG9iamVjdCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgc2tlbGV0b24gPSBvYmplY3Quc2tlbGV0b247XFxyXFxuXFx0XFx0XFx0dmFyIGJvbmVzID0gc2tlbGV0b24uYm9uZXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBjYXBhYmlsaXRpZXMuZmxvYXRWZXJ0ZXhUZXh0dXJlcyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gMTAyNDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGRlZmF1bHQgZm9yIHdoZW4gb2JqZWN0IGlzIG5vdCBzcGVjaWZpZWRcXHJcXG5cXHRcXHRcXHRcXHQvLyAoIGZvciBleGFtcGxlIHdoZW4gcHJlYnVpbGRpbmcgc2hhZGVyIHRvIGJlIHVzZWQgd2l0aCBtdWx0aXBsZSBvYmplY3RzIClcXHJcXG5cXHRcXHRcXHRcXHQvL1xcclxcblxcdFxcdFxcdFxcdC8vICAtIGxlYXZlIHNvbWUgZXh0cmEgc3BhY2UgZm9yIG90aGVyIHVuaWZvcm1zXFxyXFxuXFx0XFx0XFx0XFx0Ly8gIC0gbGltaXQgaGVyZSBpcyBBTkdMRSdzIDI1NCBtYXggdW5pZm9ybSB2ZWN0b3JzXFxyXFxuXFx0XFx0XFx0XFx0Ly8gICAgKHVwIHRvIDU0IHNob3VsZCBiZSBzYWZlKVxcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBuVmVydGV4VW5pZm9ybXMgPSBjYXBhYmlsaXRpZXMubWF4VmVydGV4VW5pZm9ybXM7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIG5WZXJ0ZXhNYXRyaWNlcyA9IE1hdGguZmxvb3IoICggblZlcnRleFVuaWZvcm1zIC0gMjAgKSAvIDQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgbWF4Qm9uZXMgPSBNYXRoLm1pbiggblZlcnRleE1hdHJpY2VzLCBib25lcy5sZW5ndGggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIG1heEJvbmVzIDwgYm9uZXMubGVuZ3RoICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFNrZWxldG9uIGhhcyAnICsgYm9uZXMubGVuZ3RoICsgJyBib25lcy4gVGhpcyBHUFUgc3VwcG9ydHMgJyArIG1heEJvbmVzICsgJy4nICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiBtYXhCb25lcztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIGdldFRleHR1cmVFbmNvZGluZ0Zyb21NYXAoIG1hcCwgZ2FtbWFPdmVycmlkZUxpbmVhciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgZW5jb2Rpbmc7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCAhIG1hcCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRlbmNvZGluZyA9IExpbmVhckVuY29kaW5nO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG1hcC5pc1RleHR1cmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZW5jb2RpbmcgPSBtYXAuZW5jb2Rpbmc7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggbWFwLmlzV2ViR0xSZW5kZXJUYXJnZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCBcXFwiVEhSRUUuV2ViR0xQcm9ncmFtcy5nZXRUZXh0dXJlRW5jb2RpbmdGcm9tTWFwOiBkb24ndCB1c2UgcmVuZGVyIHRhcmdldHMgYXMgdGV4dHVyZXMuIFVzZSB0aGVpciAudGV4dHVyZSBwcm9wZXJ0eSBpbnN0ZWFkLlxcXCIgKTtcXHJcXG5cXHRcXHRcXHRcXHRlbmNvZGluZyA9IG1hcC50ZXh0dXJlLmVuY29kaW5nO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBhZGQgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIFdlYkdMUmVuZGVyZXIuZ2FtbWFJbnB1dC9nYW1tYU91dHB1dCBwYXJhbWV0ZXIsIHNob3VsZCBwcm9iYWJseSBiZSByZW1vdmVkIGF0IHNvbWUgcG9pbnQuXFxyXFxuXFx0XFx0XFx0aWYgKCBlbmNvZGluZyA9PT0gTGluZWFyRW5jb2RpbmcgJiYgZ2FtbWFPdmVycmlkZUxpbmVhciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRlbmNvZGluZyA9IEdhbW1hRW5jb2Rpbmc7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBlbmNvZGluZztcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5nZXRQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCBtYXRlcmlhbCwgbGlnaHRzLCBzaGFkb3dzLCBmb2csIG5DbGlwUGxhbmVzLCBuQ2xpcEludGVyc2VjdGlvbiwgb2JqZWN0ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBzaGFkZXJJRCA9IHNoYWRlcklEc1sgbWF0ZXJpYWwudHlwZSBdO1xcclxcblxcclxcblxcdFxcdFxcdC8vIGhldXJpc3RpY3MgdG8gY3JlYXRlIHNoYWRlciBwYXJhbWV0ZXJzIGFjY29yZGluZyB0byBsaWdodHMgaW4gdGhlIHNjZW5lXFxyXFxuXFx0XFx0XFx0Ly8gKG5vdCB0byBibG93IG92ZXIgbWF4TGlnaHRzIGJ1ZGdldClcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbWF4Qm9uZXMgPSBvYmplY3QuaXNTa2lubmVkTWVzaCA/IGFsbG9jYXRlQm9uZXMoIG9iamVjdCApIDogMDtcXHJcXG5cXHRcXHRcXHR2YXIgcHJlY2lzaW9uID0gY2FwYWJpbGl0aWVzLnByZWNpc2lvbjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLnByZWNpc2lvbiAhPT0gbnVsbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRwcmVjaXNpb24gPSBjYXBhYmlsaXRpZXMuZ2V0TWF4UHJlY2lzaW9uKCBtYXRlcmlhbC5wcmVjaXNpb24gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHByZWNpc2lvbiAhPT0gbWF0ZXJpYWwucHJlY2lzaW9uICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUHJvZ3JhbS5nZXRQYXJhbWV0ZXJzOicsIG1hdGVyaWFsLnByZWNpc2lvbiwgJ25vdCBzdXBwb3J0ZWQsIHVzaW5nJywgcHJlY2lzaW9uLCAnaW5zdGVhZC4nICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgY3VycmVudFJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBwYXJhbWV0ZXJzID0ge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHNoYWRlcklEOiBzaGFkZXJJRCxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRwcmVjaXNpb246IHByZWNpc2lvbixcXHJcXG5cXHRcXHRcXHRcXHRzdXBwb3J0c1ZlcnRleFRleHR1cmVzOiBjYXBhYmlsaXRpZXMudmVydGV4VGV4dHVyZXMsXFxyXFxuXFx0XFx0XFx0XFx0b3V0cHV0RW5jb2Rpbmc6IGdldFRleHR1cmVFbmNvZGluZ0Zyb21NYXAoICggISBjdXJyZW50UmVuZGVyVGFyZ2V0ICkgPyBudWxsIDogY3VycmVudFJlbmRlclRhcmdldC50ZXh0dXJlLCByZW5kZXJlci5nYW1tYU91dHB1dCApLFxcclxcblxcdFxcdFxcdFxcdG1hcDogISEgbWF0ZXJpYWwubWFwLFxcclxcblxcdFxcdFxcdFxcdG1hcEVuY29kaW5nOiBnZXRUZXh0dXJlRW5jb2RpbmdGcm9tTWFwKCBtYXRlcmlhbC5tYXAsIHJlbmRlcmVyLmdhbW1hSW5wdXQgKSxcXHJcXG5cXHRcXHRcXHRcXHRlbnZNYXA6ICEhIG1hdGVyaWFsLmVudk1hcCxcXHJcXG5cXHRcXHRcXHRcXHRlbnZNYXBNb2RlOiBtYXRlcmlhbC5lbnZNYXAgJiYgbWF0ZXJpYWwuZW52TWFwLm1hcHBpbmcsXFxyXFxuXFx0XFx0XFx0XFx0ZW52TWFwRW5jb2Rpbmc6IGdldFRleHR1cmVFbmNvZGluZ0Zyb21NYXAoIG1hdGVyaWFsLmVudk1hcCwgcmVuZGVyZXIuZ2FtbWFJbnB1dCApLFxcclxcblxcdFxcdFxcdFxcdGVudk1hcEN1YmVVVjogKCAhISBtYXRlcmlhbC5lbnZNYXAgKSAmJiAoICggbWF0ZXJpYWwuZW52TWFwLm1hcHBpbmcgPT09IEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nICkgfHwgKCBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyA9PT0gQ3ViZVVWUmVmcmFjdGlvbk1hcHBpbmcgKSApLFxcclxcblxcdFxcdFxcdFxcdGxpZ2h0TWFwOiAhISBtYXRlcmlhbC5saWdodE1hcCxcXHJcXG5cXHRcXHRcXHRcXHRhb01hcDogISEgbWF0ZXJpYWwuYW9NYXAsXFxyXFxuXFx0XFx0XFx0XFx0ZW1pc3NpdmVNYXA6ICEhIG1hdGVyaWFsLmVtaXNzaXZlTWFwLFxcclxcblxcdFxcdFxcdFxcdGVtaXNzaXZlTWFwRW5jb2Rpbmc6IGdldFRleHR1cmVFbmNvZGluZ0Zyb21NYXAoIG1hdGVyaWFsLmVtaXNzaXZlTWFwLCByZW5kZXJlci5nYW1tYUlucHV0ICksXFxyXFxuXFx0XFx0XFx0XFx0YnVtcE1hcDogISEgbWF0ZXJpYWwuYnVtcE1hcCxcXHJcXG5cXHRcXHRcXHRcXHRub3JtYWxNYXA6ICEhIG1hdGVyaWFsLm5vcm1hbE1hcCxcXHJcXG5cXHRcXHRcXHRcXHRkaXNwbGFjZW1lbnRNYXA6ICEhIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCxcXHJcXG5cXHRcXHRcXHRcXHRyb3VnaG5lc3NNYXA6ICEhIG1hdGVyaWFsLnJvdWdobmVzc01hcCxcXHJcXG5cXHRcXHRcXHRcXHRtZXRhbG5lc3NNYXA6ICEhIG1hdGVyaWFsLm1ldGFsbmVzc01hcCxcXHJcXG5cXHRcXHRcXHRcXHRzcGVjdWxhck1hcDogISEgbWF0ZXJpYWwuc3BlY3VsYXJNYXAsXFxyXFxuXFx0XFx0XFx0XFx0YWxwaGFNYXA6ICEhIG1hdGVyaWFsLmFscGhhTWFwLFxcclxcblxcclxcblxcdFxcdFxcdFxcdGdyYWRpZW50TWFwOiAhISBtYXRlcmlhbC5ncmFkaWVudE1hcCxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb21iaW5lOiBtYXRlcmlhbC5jb21iaW5lLFxcclxcblxcclxcblxcdFxcdFxcdFxcdHZlcnRleENvbG9yczogbWF0ZXJpYWwudmVydGV4Q29sb3JzLFxcclxcblxcclxcblxcdFxcdFxcdFxcdGZvZzogISEgZm9nLFxcclxcblxcdFxcdFxcdFxcdHVzZUZvZzogbWF0ZXJpYWwuZm9nLFxcclxcblxcdFxcdFxcdFxcdGZvZ0V4cDogKCBmb2cgJiYgZm9nLmlzRm9nRXhwMiApLFxcclxcblxcclxcblxcdFxcdFxcdFxcdGZsYXRTaGFkaW5nOiBtYXRlcmlhbC5mbGF0U2hhZGluZyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzaXplQXR0ZW51YXRpb246IG1hdGVyaWFsLnNpemVBdHRlbnVhdGlvbixcXHJcXG5cXHRcXHRcXHRcXHRsb2dhcml0aG1pY0RlcHRoQnVmZmVyOiBjYXBhYmlsaXRpZXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcixcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRza2lubmluZzogbWF0ZXJpYWwuc2tpbm5pbmcgJiYgbWF4Qm9uZXMgPiAwLFxcclxcblxcdFxcdFxcdFxcdG1heEJvbmVzOiBtYXhCb25lcyxcXHJcXG5cXHRcXHRcXHRcXHR1c2VWZXJ0ZXhUZXh0dXJlOiBjYXBhYmlsaXRpZXMuZmxvYXRWZXJ0ZXhUZXh0dXJlcyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRtb3JwaFRhcmdldHM6IG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyxcXHJcXG5cXHRcXHRcXHRcXHRtb3JwaE5vcm1hbHM6IG1hdGVyaWFsLm1vcnBoTm9ybWFscyxcXHJcXG5cXHRcXHRcXHRcXHRtYXhNb3JwaFRhcmdldHM6IHJlbmRlcmVyLm1heE1vcnBoVGFyZ2V0cyxcXHJcXG5cXHRcXHRcXHRcXHRtYXhNb3JwaE5vcm1hbHM6IHJlbmRlcmVyLm1heE1vcnBoTm9ybWFscyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRudW1EaXJMaWdodHM6IGxpZ2h0cy5kaXJlY3Rpb25hbC5sZW5ndGgsXFxyXFxuXFx0XFx0XFx0XFx0bnVtUG9pbnRMaWdodHM6IGxpZ2h0cy5wb2ludC5sZW5ndGgsXFxyXFxuXFx0XFx0XFx0XFx0bnVtU3BvdExpZ2h0czogbGlnaHRzLnNwb3QubGVuZ3RoLFxcclxcblxcdFxcdFxcdFxcdG51bVJlY3RBcmVhTGlnaHRzOiBsaWdodHMucmVjdEFyZWEubGVuZ3RoLFxcclxcblxcdFxcdFxcdFxcdG51bUhlbWlMaWdodHM6IGxpZ2h0cy5oZW1pLmxlbmd0aCxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRudW1DbGlwcGluZ1BsYW5lczogbkNsaXBQbGFuZXMsXFxyXFxuXFx0XFx0XFx0XFx0bnVtQ2xpcEludGVyc2VjdGlvbjogbkNsaXBJbnRlcnNlY3Rpb24sXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZGl0aGVyaW5nOiBtYXRlcmlhbC5kaXRoZXJpbmcsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0c2hhZG93TWFwRW5hYmxlZDogcmVuZGVyZXIuc2hhZG93TWFwLmVuYWJsZWQgJiYgb2JqZWN0LnJlY2VpdmVTaGFkb3cgJiYgc2hhZG93cy5sZW5ndGggPiAwLFxcclxcblxcdFxcdFxcdFxcdHNoYWRvd01hcFR5cGU6IHJlbmRlcmVyLnNoYWRvd01hcC50eXBlLFxcclxcblxcclxcblxcdFxcdFxcdFxcdHRvbmVNYXBwaW5nOiByZW5kZXJlci50b25lTWFwcGluZyxcXHJcXG5cXHRcXHRcXHRcXHRwaHlzaWNhbGx5Q29ycmVjdExpZ2h0czogcmVuZGVyZXIucGh5c2ljYWxseUNvcnJlY3RMaWdodHMsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cHJlbXVsdGlwbGllZEFscGhhOiBtYXRlcmlhbC5wcmVtdWx0aXBsaWVkQWxwaGEsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YWxwaGFUZXN0OiBtYXRlcmlhbC5hbHBoYVRlc3QsXFxyXFxuXFx0XFx0XFx0XFx0ZG91YmxlU2lkZWQ6IG1hdGVyaWFsLnNpZGUgPT09IERvdWJsZVNpZGUsXFxyXFxuXFx0XFx0XFx0XFx0ZmxpcFNpZGVkOiBtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRkZXB0aFBhY2tpbmc6ICggbWF0ZXJpYWwuZGVwdGhQYWNraW5nICE9PSB1bmRlZmluZWQgKSA/IG1hdGVyaWFsLmRlcHRoUGFja2luZyA6IGZhbHNlXFxyXFxuXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gcGFyYW1ldGVycztcXHJcXG5cXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdFxcdHRoaXMuZ2V0UHJvZ3JhbUNvZGUgPSBmdW5jdGlvbiAoIG1hdGVyaWFsLCBwYXJhbWV0ZXJzICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBhcnJheSA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggcGFyYW1ldGVycy5zaGFkZXJJRCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLnNoYWRlcklEICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRhcnJheS5wdXNoKCBtYXRlcmlhbC5mcmFnbWVudFNoYWRlciApO1xcclxcblxcdFxcdFxcdFxcdGFycmF5LnB1c2goIG1hdGVyaWFsLnZlcnRleFNoYWRlciApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLmRlZmluZXMgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgbmFtZSBpbiBtYXRlcmlhbC5kZWZpbmVzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGFycmF5LnB1c2goIG5hbWUgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRhcnJheS5wdXNoKCBtYXRlcmlhbC5kZWZpbmVzWyBuYW1lIF0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IHBhcmFtZXRlck5hbWVzLmxlbmd0aDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzWyBwYXJhbWV0ZXJOYW1lc1sgaSBdIF0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0YXJyYXkucHVzaCggbWF0ZXJpYWwub25CZWZvcmVDb21waWxlLnRvU3RyaW5nKCkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRhcnJheS5wdXNoKCByZW5kZXJlci5nYW1tYU91dHB1dCApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBhcnJheS5qb2luKCk7XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmFjcXVpcmVQcm9ncmFtID0gZnVuY3Rpb24gKCBtYXRlcmlhbCwgc2hhZGVyLCBwYXJhbWV0ZXJzLCBjb2RlICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBwcm9ncmFtO1xcclxcblxcclxcblxcdFxcdFxcdC8vIENoZWNrIGlmIGNvZGUgaGFzIGJlZW4gYWxyZWFkeSBjb21waWxlZFxcclxcblxcdFxcdFxcdGZvciAoIHZhciBwID0gMCwgcGwgPSBwcm9ncmFtcy5sZW5ndGg7IHAgPCBwbDsgcCArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgcHJvZ3JhbUluZm8gPSBwcm9ncmFtc1sgcCBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggcHJvZ3JhbUluZm8uY29kZSA9PT0gY29kZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRwcm9ncmFtID0gcHJvZ3JhbUluZm87XFxyXFxuXFx0XFx0XFx0XFx0XFx0KysgcHJvZ3JhbS51c2VkVGltZXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRwcm9ncmFtID0gbmV3IFdlYkdMUHJvZ3JhbSggcmVuZGVyZXIsIGV4dGVuc2lvbnMsIGNvZGUsIG1hdGVyaWFsLCBzaGFkZXIsIHBhcmFtZXRlcnMgKTtcXHJcXG5cXHRcXHRcXHRcXHRwcm9ncmFtcy5wdXNoKCBwcm9ncmFtICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBwcm9ncmFtO1xcclxcblxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5yZWxlYXNlUHJvZ3JhbSA9IGZ1bmN0aW9uICggcHJvZ3JhbSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIC0tIHByb2dyYW0udXNlZFRpbWVzID09PSAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIFJlbW92ZSBmcm9tIHVub3JkZXJlZCBzZXRcXHJcXG5cXHRcXHRcXHRcXHR2YXIgaSA9IHByb2dyYW1zLmluZGV4T2YoIHByb2dyYW0gKTtcXHJcXG5cXHRcXHRcXHRcXHRwcm9ncmFtc1sgaSBdID0gcHJvZ3JhbXNbIHByb2dyYW1zLmxlbmd0aCAtIDEgXTtcXHJcXG5cXHRcXHRcXHRcXHRwcm9ncmFtcy5wb3AoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBGcmVlIFdlYkdMIHJlc291cmNlc1xcclxcblxcdFxcdFxcdFxcdHByb2dyYW0uZGVzdHJveSgpO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdFxcdC8vIEV4cG9zZWQgZm9yIHJlc291cmNlIG1vbml0b3JpbmcgJiBlcnJvciBmZWVkYmFjayB2aWEgcmVuZGVyZXIuaW5mbzpcXHJcXG5cXHRcXHR0aGlzLnByb2dyYW1zID0gcHJvZ3JhbXM7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gV2ViR0xUZXh0dXJlcyggX2dsLCBleHRlbnNpb25zLCBzdGF0ZSwgcHJvcGVydGllcywgY2FwYWJpbGl0aWVzLCB1dGlscywgaW5mb01lbW9yeSApIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgX2lzV2ViR0wyID0gKCB0eXBlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCcgJiYgX2dsIGluc3RhbmNlb2Ygd2luZG93LldlYkdMMlJlbmRlcmluZ0NvbnRleHQgKTtcXHJcXG5cXHRcXHR2YXIgX3ZpZGVvVGV4dHVyZXMgPSB7fTtcXHJcXG5cXHJcXG5cXHRcXHQvL1xcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIGNsYW1wVG9NYXhTaXplKCBpbWFnZSwgbWF4U2l6ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGltYWdlLndpZHRoID4gbWF4U2l6ZSB8fCBpbWFnZS5oZWlnaHQgPiBtYXhTaXplICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIFdhcm5pbmc6IFNjYWxpbmcgdGhyb3VnaCB0aGUgY2FudmFzIHdpbGwgb25seSB3b3JrIHdpdGggaW1hZ2VzIHRoYXQgdXNlXFxyXFxuXFx0XFx0XFx0XFx0Ly8gcHJlbXVsdGlwbGllZCBhbHBoYS5cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgc2NhbGUgPSBtYXhTaXplIC8gTWF0aC5tYXgoIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsICdjYW52YXMnICk7XFxyXFxuXFx0XFx0XFx0XFx0Y2FudmFzLndpZHRoID0gTWF0aC5mbG9vciggaW1hZ2Uud2lkdGggKiBzY2FsZSApO1xcclxcblxcdFxcdFxcdFxcdGNhbnZhcy5oZWlnaHQgPSBNYXRoLmZsb29yKCBpbWFnZS5oZWlnaHQgKiBzY2FsZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcXHJcXG5cXHRcXHRcXHRcXHRjb250ZXh0LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IGltYWdlIGlzIHRvbyBiaWcgKCcgKyBpbWFnZS53aWR0aCArICd4JyArIGltYWdlLmhlaWdodCArICcpLiBSZXNpemVkIHRvICcgKyBjYW52YXMud2lkdGggKyAneCcgKyBjYW52YXMuaGVpZ2h0LCBpbWFnZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiBjYW52YXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBpbWFnZTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gaXNQb3dlck9mVHdvKCBpbWFnZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gX01hdGguaXNQb3dlck9mVHdvKCBpbWFnZS53aWR0aCApICYmIF9NYXRoLmlzUG93ZXJPZlR3byggaW1hZ2UuaGVpZ2h0ICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIG1ha2VQb3dlck9mVHdvKCBpbWFnZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCB8fCBpbWFnZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50IHx8IGltYWdlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLCAnY2FudmFzJyApO1xcclxcblxcdFxcdFxcdFxcdGNhbnZhcy53aWR0aCA9IF9NYXRoLmZsb29yUG93ZXJPZlR3byggaW1hZ2Uud2lkdGggKTtcXHJcXG5cXHRcXHRcXHRcXHRjYW52YXMuaGVpZ2h0ID0gX01hdGguZmxvb3JQb3dlck9mVHdvKCBpbWFnZS5oZWlnaHQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XFxyXFxuXFx0XFx0XFx0XFx0Y29udGV4dC5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBpbWFnZSBpcyBub3QgcG93ZXIgb2YgdHdvICgnICsgaW1hZ2Uud2lkdGggKyAneCcgKyBpbWFnZS5oZWlnaHQgKyAnKS4gUmVzaXplZCB0byAnICsgY2FudmFzLndpZHRoICsgJ3gnICsgY2FudmFzLmhlaWdodCwgaW1hZ2UgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gY2FudmFzO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gaW1hZ2U7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIHRleHR1cmVOZWVkc1Bvd2VyT2ZUd28oIHRleHR1cmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuICggdGV4dHVyZS53cmFwUyAhPT0gQ2xhbXBUb0VkZ2VXcmFwcGluZyB8fCB0ZXh0dXJlLndyYXBUICE9PSBDbGFtcFRvRWRnZVdyYXBwaW5nICkgfHxcXHJcXG5cXHRcXHRcXHRcXHQoIHRleHR1cmUubWluRmlsdGVyICE9PSBOZWFyZXN0RmlsdGVyICYmIHRleHR1cmUubWluRmlsdGVyICE9PSBMaW5lYXJGaWx0ZXIgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gdGV4dHVyZU5lZWRzR2VuZXJhdGVNaXBtYXBzKCB0ZXh0dXJlLCBpc1Bvd2VyT2ZUd28gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICYmIGlzUG93ZXJPZlR3byAmJlxcclxcblxcdFxcdFxcdFxcdHRleHR1cmUubWluRmlsdGVyICE9PSBOZWFyZXN0RmlsdGVyICYmIHRleHR1cmUubWluRmlsdGVyICE9PSBMaW5lYXJGaWx0ZXI7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdC8vIEZhbGxiYWNrIGZpbHRlcnMgZm9yIG5vbi1wb3dlci1vZi0yIHRleHR1cmVzXFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gZmlsdGVyRmFsbGJhY2soIGYgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBmID09PSBOZWFyZXN0RmlsdGVyIHx8IGYgPT09IE5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyIHx8IGYgPT09IE5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIF9nbC5ORUFSRVNUO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gX2dsLkxJTkVBUjtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0Ly9cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBvblRleHR1cmVEaXNwb3NlKCBldmVudCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdGV4dHVyZSA9IGV2ZW50LnRhcmdldDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0ZXh0dXJlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xcclxcblxcclxcblxcdFxcdFxcdGRlYWxsb2NhdGVUZXh0dXJlKCB0ZXh0dXJlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0ZXh0dXJlLmlzVmlkZW9UZXh0dXJlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGRlbGV0ZSBfdmlkZW9UZXh0dXJlc1sgdGV4dHVyZS5pZCBdO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpbmZvTWVtb3J5LnRleHR1cmVzIC0tO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBvblJlbmRlclRhcmdldERpc3Bvc2UoIGV2ZW50ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciByZW5kZXJUYXJnZXQgPSBldmVudC50YXJnZXQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmVuZGVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25SZW5kZXJUYXJnZXREaXNwb3NlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZGVhbGxvY2F0ZVJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aW5mb01lbW9yeS50ZXh0dXJlcyAtLTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0Ly9cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBkZWFsbG9jYXRlVGV4dHVyZSggdGV4dHVyZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGV4dHVyZS5pbWFnZSAmJiB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGN1YmUgdGV4dHVyZVxcclxcblxcclxcblxcdFxcdFxcdFxcdF9nbC5kZWxldGVUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyAyRCB0ZXh0dXJlXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsSW5pdCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xcclxcblxcclxcblxcdFxcdFxcdFxcdF9nbC5kZWxldGVUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyByZW1vdmUgYWxsIHdlYmdsIHByb3BlcnRpZXNcXHJcXG5cXHRcXHRcXHRwcm9wZXJ0aWVzLnJlbW92ZSggdGV4dHVyZSApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBkZWFsbG9jYXRlUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICk7XFxyXFxuXFx0XFx0XFx0dmFyIHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldC50ZXh0dXJlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCAhIHJlbmRlclRhcmdldCApIHJldHVybjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0X2dsLmRlbGV0ZVRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmRpc3Bvc2UoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCByZW5kZXJUYXJnZXQuaXNXZWJHTFJlbmRlclRhcmdldEN1YmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRfZ2wuZGVsZXRlRnJhbWVidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0gKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyICkgX2dsLmRlbGV0ZVJlbmRlcmJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXJbIGkgXSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdF9nbC5kZWxldGVGcmFtZWJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgKTtcXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyICkgX2dsLmRlbGV0ZVJlbmRlcmJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cHJvcGVydGllcy5yZW1vdmUoIHJlbmRlclRhcmdldC50ZXh0dXJlICk7XFxyXFxuXFx0XFx0XFx0cHJvcGVydGllcy5yZW1vdmUoIHJlbmRlclRhcmdldCApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHQvL1xcclxcblxcclxcblxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIHNldFRleHR1cmUyRCggdGV4dHVyZSwgc2xvdCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGV4dHVyZS52ZXJzaW9uID4gMCAmJiB0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gIT09IHRleHR1cmUudmVyc2lvbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgaW1hZ2UgPSB0ZXh0dXJlLmltYWdlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggaW1hZ2UgPT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIG1hcmtlZCBmb3IgdXBkYXRlIGJ1dCBpbWFnZSBpcyB1bmRlZmluZWQnLCB0ZXh0dXJlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggaW1hZ2UuY29tcGxldGUgPT09IGZhbHNlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgbWFya2VkIGZvciB1cGRhdGUgYnV0IGltYWdlIGlzIGluY29tcGxldGUnLCB0ZXh0dXJlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR1cGxvYWRUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcywgdGV4dHVyZSwgc2xvdCApO1xcclxcblxcdFxcdFxcdFxcdFxcdHJldHVybjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcXHJcXG5cXHRcXHRcXHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIHNldFRleHR1cmVDdWJlKCB0ZXh0dXJlLCBzbG90ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0ZXh0dXJlLmltYWdlLmxlbmd0aCA9PT0gNiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHRleHR1cmUudmVyc2lvbiA+IDAgJiYgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uICE9PSB0ZXh0dXJlLnZlcnNpb24gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAhIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpbmZvTWVtb3J5LnRleHR1cmVzICsrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdGV4dHVyZS5mbGlwWSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBpc0NvbXByZXNzZWQgPSAoIHRleHR1cmUgJiYgdGV4dHVyZS5pc0NvbXByZXNzZWRUZXh0dXJlICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGlzRGF0YVRleHR1cmUgPSAoIHRleHR1cmUuaW1hZ2VbIDAgXSAmJiB0ZXh0dXJlLmltYWdlWyAwIF0uaXNEYXRhVGV4dHVyZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBjdWJlSW1hZ2UgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggISBpc0NvbXByZXNzZWQgJiYgISBpc0RhdGFUZXh0dXJlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGN1YmVJbWFnZVsgaSBdID0gY2xhbXBUb01heFNpemUoIHRleHR1cmUuaW1hZ2VbIGkgXSwgY2FwYWJpbGl0aWVzLm1heEN1YmVtYXBTaXplICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjdWJlSW1hZ2VbIGkgXSA9IGlzRGF0YVRleHR1cmUgPyB0ZXh0dXJlLmltYWdlWyBpIF0uaW1hZ2UgOiB0ZXh0dXJlLmltYWdlWyBpIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgaW1hZ2UgPSBjdWJlSW1hZ2VbIDAgXSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpc1Bvd2VyT2ZUd29JbWFnZSA9IGlzUG93ZXJPZlR3byggaW1hZ2UgKSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRnbEZvcm1hdCA9IHV0aWxzLmNvbnZlcnQoIHRleHR1cmUuZm9ybWF0ICksXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2xUeXBlID0gdXRpbHMuY29udmVydCggdGV4dHVyZS50eXBlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlLCBpc1Bvd2VyT2ZUd29JbWFnZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCAhIGlzQ29tcHJlc3NlZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGlzRGF0YVRleHR1cmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsRm9ybWF0LCBjdWJlSW1hZ2VbIGkgXS53aWR0aCwgY3ViZUltYWdlWyBpIF0uaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBjdWJlSW1hZ2VbIGkgXS5kYXRhICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgMCwgZ2xGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIGN1YmVJbWFnZVsgaSBdICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIG1pcG1hcCwgbWlwbWFwcyA9IGN1YmVJbWFnZVsgaSBdLm1pcG1hcHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG1pcG1hcHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bWlwbWFwID0gbWlwbWFwc1sgaiBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggdGV4dHVyZS5mb3JtYXQgIT09IFJHQkFGb3JtYXQgJiYgdGV4dHVyZS5mb3JtYXQgIT09IFJHQkZvcm1hdCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHN0YXRlLmdldENvbXByZXNzZWRUZXh0dXJlRm9ybWF0cygpLmluZGV4T2YoIGdsRm9ybWF0ICkgPiAtIDEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0c3RhdGUuY29tcHJlc3NlZFRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCBqLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBtaXBtYXAuZGF0YSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnNldFRleHR1cmVDdWJlKCknICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIGosIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5kYXRhICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggdGV4dHVyZU5lZWRzR2VuZXJhdGVNaXBtYXBzKCB0ZXh0dXJlLCBpc1Bvd2VyT2ZUd29JbWFnZSApICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfQ1VCRV9NQVAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uID0gdGV4dHVyZS52ZXJzaW9uO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggdGV4dHVyZS5vblVwZGF0ZSApIHRleHR1cmUub25VcGRhdGUoIHRleHR1cmUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBzZXRUZXh0dXJlQ3ViZUR5bmFtaWMoIHRleHR1cmUsIHNsb3QgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xcclxcblxcdFxcdFxcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZSApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBzZXRUZXh0dXJlUGFyYW1ldGVycyggdGV4dHVyZVR5cGUsIHRleHR1cmUsIGlzUG93ZXJPZlR3b0ltYWdlICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBleHRlbnNpb247XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBpc1Bvd2VyT2ZUd29JbWFnZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfUywgdXRpbHMuY29udmVydCggdGV4dHVyZS53cmFwUyApICk7XFxyXFxuXFx0XFx0XFx0XFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1QsIHV0aWxzLmNvbnZlcnQoIHRleHR1cmUud3JhcFQgKSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdXRpbHMuY29udmVydCggdGV4dHVyZS5tYWdGaWx0ZXIgKSApO1xcclxcblxcdFxcdFxcdFxcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdXRpbHMuY29udmVydCggdGV4dHVyZS5taW5GaWx0ZXIgKSApO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1MsIF9nbC5DTEFNUF9UT19FREdFICk7XFxyXFxuXFx0XFx0XFx0XFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1QsIF9nbC5DTEFNUF9UT19FREdFICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB0ZXh0dXJlLndyYXBTICE9PSBDbGFtcFRvRWRnZVdyYXBwaW5nIHx8IHRleHR1cmUud3JhcFQgIT09IENsYW1wVG9FZGdlV3JhcHBpbmcgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBpcyBub3QgcG93ZXIgb2YgdHdvLiBUZXh0dXJlLndyYXBTIGFuZCBUZXh0dXJlLndyYXBUIHNob3VsZCBiZSBzZXQgdG8gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZy4nLCB0ZXh0dXJlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZmlsdGVyRmFsbGJhY2soIHRleHR1cmUubWFnRmlsdGVyICkgKTtcXHJcXG5cXHRcXHRcXHRcXHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01JTl9GSUxURVIsIGZpbHRlckZhbGxiYWNrKCB0ZXh0dXJlLm1pbkZpbHRlciApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTmVhcmVzdEZpbHRlciAmJiB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTGluZWFyRmlsdGVyICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgaXMgbm90IHBvd2VyIG9mIHR3by4gVGV4dHVyZS5taW5GaWx0ZXIgc2hvdWxkIGJlIHNldCB0byBUSFJFRS5OZWFyZXN0RmlsdGVyIG9yIFRIUkVFLkxpbmVhckZpbHRlci4nLCB0ZXh0dXJlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGV4dGVuc2lvbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHRleHR1cmUudHlwZSA9PT0gRmxvYXRUeXBlICYmIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyApID09PSBudWxsICkgcmV0dXJuO1xcclxcblxcdFxcdFxcdFxcdGlmICggdGV4dHVyZS50eXBlID09PSBIYWxmRmxvYXRUeXBlICYmIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInICkgPT09IG51bGwgKSByZXR1cm47XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB0ZXh0dXJlLmFuaXNvdHJvcHkgPiAxIHx8IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICkuX19jdXJyZW50QW5pc290cm9weSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRfZ2wudGV4UGFyYW1ldGVyZiggdGV4dHVyZVR5cGUsIGV4dGVuc2lvbi5URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCwgTWF0aC5taW4oIHRleHR1cmUuYW5pc290cm9weSwgY2FwYWJpbGl0aWVzLmdldE1heEFuaXNvdHJvcHkoKSApICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0cHJvcGVydGllcy5nZXQoIHRleHR1cmUgKS5fX2N1cnJlbnRBbmlzb3Ryb3B5ID0gdGV4dHVyZS5hbmlzb3Ryb3B5O1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIHVwbG9hZFRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90ICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbEluaXQgPT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsSW5pdCA9IHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB0ZXh0dXJlLmlzVmlkZW9UZXh0dXJlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdF92aWRlb1RleHR1cmVzWyB0ZXh0dXJlLmlkIF0gPSB0ZXh0dXJlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpbmZvTWVtb3J5LnRleHR1cmVzICsrO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XFxyXFxuXFx0XFx0XFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xcclxcblxcclxcblxcdFxcdFxcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRleHR1cmUuZmxpcFkgKTtcXHJcXG5cXHRcXHRcXHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSApO1xcclxcblxcdFxcdFxcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19BTElHTk1FTlQsIHRleHR1cmUudW5wYWNrQWxpZ25tZW50ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGltYWdlID0gY2xhbXBUb01heFNpemUoIHRleHR1cmUuaW1hZ2UsIGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlU2l6ZSApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGV4dHVyZU5lZWRzUG93ZXJPZlR3byggdGV4dHVyZSApICYmIGlzUG93ZXJPZlR3byggaW1hZ2UgKSA9PT0gZmFsc2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aW1hZ2UgPSBtYWtlUG93ZXJPZlR3byggaW1hZ2UgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGlzUG93ZXJPZlR3b0ltYWdlID0gaXNQb3dlck9mVHdvKCBpbWFnZSApLFxcclxcblxcdFxcdFxcdFxcdGdsRm9ybWF0ID0gdXRpbHMuY29udmVydCggdGV4dHVyZS5mb3JtYXQgKSxcXHJcXG5cXHRcXHRcXHRcXHRnbFR5cGUgPSB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlLnR5cGUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfMkQsIHRleHR1cmUsIGlzUG93ZXJPZlR3b0ltYWdlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG1pcG1hcCwgbWlwbWFwcyA9IHRleHR1cmUubWlwbWFwcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRleHR1cmUuaXNEZXB0aFRleHR1cmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gcG9wdWxhdGUgZGVwdGggdGV4dHVyZSB3aXRoIGR1bW15IGRhdGFcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuREVQVEhfQ09NUE9ORU5UO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggdGV4dHVyZS50eXBlID09PSBGbG9hdFR5cGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAhIF9pc1dlYkdMMiApIHRocm93IG5ldyBFcnJvciggJ0Zsb2F0IERlcHRoIFRleHR1cmUgb25seSBzdXBwb3J0ZWQgaW4gV2ViR0wyLjAnICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0aW50ZXJuYWxGb3JtYXQgPSBfZ2wuREVQVEhfQ09NUE9ORU5UMzJGO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIF9pc1dlYkdMMiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBXZWJHTCAyLjAgcmVxdWlyZXMgc2lnbmVkIGludGVybmFsZm9ybWF0IGZvciBnbFRleEltYWdlMkRcXHJcXG5cXHRcXHRcXHRcXHRcXHRpbnRlcm5hbEZvcm1hdCA9IF9nbC5ERVBUSF9DT01QT05FTlQxNjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB0ZXh0dXJlLmZvcm1hdCA9PT0gRGVwdGhGb3JtYXQgJiYgaW50ZXJuYWxGb3JtYXQgPT09IF9nbC5ERVBUSF9DT01QT05FTlQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gVGhlIGVycm9yIElOVkFMSURfT1BFUkFUSU9OIGlzIGdlbmVyYXRlZCBieSB0ZXhJbWFnZTJEIGlmIGZvcm1hdCBhbmQgaW50ZXJuYWxmb3JtYXQgYXJlXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gREVQVEhfQ09NUE9ORU5UIGFuZCB0eXBlIGlzIG5vdCBVTlNJR05FRF9TSE9SVCBvciBVTlNJR05FRF9JTlRcXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyAoaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvd2ViZ2wvZXh0ZW5zaW9ucy9XRUJHTF9kZXB0aF90ZXh0dXJlLylcXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHRleHR1cmUudHlwZSAhPT0gVW5zaWduZWRTaG9ydFR5cGUgJiYgdGV4dHVyZS50eXBlICE9PSBVbnNpZ25lZEludFR5cGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVXNlIFVuc2lnbmVkU2hvcnRUeXBlIG9yIFVuc2lnbmVkSW50VHlwZSBmb3IgRGVwdGhGb3JtYXQgRGVwdGhUZXh0dXJlLicgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLnR5cGUgPSBVbnNpZ25lZFNob3J0VHlwZTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRnbFR5cGUgPSB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlLnR5cGUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIERlcHRoIHN0ZW5jaWwgdGV4dHVyZXMgbmVlZCB0aGUgREVQVEhfU1RFTkNJTCBpbnRlcm5hbCBmb3JtYXRcXHJcXG5cXHRcXHRcXHRcXHQvLyAoaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvd2ViZ2wvZXh0ZW5zaW9ucy9XRUJHTF9kZXB0aF90ZXh0dXJlLylcXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHRleHR1cmUuZm9ybWF0ID09PSBEZXB0aFN0ZW5jaWxGb3JtYXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aW50ZXJuYWxGb3JtYXQgPSBfZ2wuREVQVEhfU1RFTkNJTDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBUaGUgZXJyb3IgSU5WQUxJRF9PUEVSQVRJT04gaXMgZ2VuZXJhdGVkIGJ5IHRleEltYWdlMkQgaWYgZm9ybWF0IGFuZCBpbnRlcm5hbGZvcm1hdCBhcmVcXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBERVBUSF9TVEVOQ0lMIGFuZCB0eXBlIGlzIG5vdCBVTlNJR05FRF9JTlRfMjRfOF9XRUJHTC5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyAoaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvd2ViZ2wvZXh0ZW5zaW9ucy9XRUJHTF9kZXB0aF90ZXh0dXJlLylcXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHRleHR1cmUudHlwZSAhPT0gVW5zaWduZWRJbnQyNDhUeXBlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFVzZSBVbnNpZ25lZEludDI0OFR5cGUgZm9yIERlcHRoU3RlbmNpbEZvcm1hdCBEZXB0aFRleHR1cmUuJyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHRleHR1cmUudHlwZSA9IFVuc2lnbmVkSW50MjQ4VHlwZTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRnbFR5cGUgPSB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlLnR5cGUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBpbnRlcm5hbEZvcm1hdCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbnVsbCApO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIHRleHR1cmUuaXNEYXRhVGV4dHVyZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyB1c2UgbWFudWFsbHkgY3JlYXRlZCBtaXBtYXBzIGlmIGF2YWlsYWJsZVxcclxcblxcdFxcdFxcdFxcdC8vIGlmIHRoZXJlIGFyZSBubyBtYW51YWwgbWlwbWFwc1xcclxcblxcdFxcdFxcdFxcdC8vIHNldCAwIGxldmVsIG1pcG1hcCBhbmQgdGhlbiB1c2UgR0wgdG8gZ2VuZXJhdGUgb3RoZXIgbWlwbWFwIGxldmVsc1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggbWlwbWFwcy5sZW5ndGggPiAwICYmIGlzUG93ZXJPZlR3b0ltYWdlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEZvcm1hdCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UuZGF0YSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCB0ZXh0dXJlLmlzQ29tcHJlc3NlZFRleHR1cmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG1pcG1hcHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0bWlwbWFwID0gbWlwbWFwc1sgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggdGV4dHVyZS5mb3JtYXQgIT09IFJHQkFGb3JtYXQgJiYgdGV4dHVyZS5mb3JtYXQgIT09IFJHQkZvcm1hdCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHN0YXRlLmdldENvbXByZXNzZWRUZXh0dXJlRm9ybWF0cygpLmluZGV4T2YoIGdsRm9ybWF0ICkgPiAtIDEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c3RhdGUuY29tcHJlc3NlZFRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBtaXBtYXAuZGF0YSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnVwbG9hZFRleHR1cmUoKScgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gcmVndWxhciBUZXh0dXJlIChpbWFnZSwgdmlkZW8sIGNhbnZhcylcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyB1c2UgbWFudWFsbHkgY3JlYXRlZCBtaXBtYXBzIGlmIGF2YWlsYWJsZVxcclxcblxcdFxcdFxcdFxcdC8vIGlmIHRoZXJlIGFyZSBubyBtYW51YWwgbWlwbWFwc1xcclxcblxcdFxcdFxcdFxcdC8vIHNldCAwIGxldmVsIG1pcG1hcCBhbmQgdGhlbiB1c2UgR0wgdG8gZ2VuZXJhdGUgb3RoZXIgbWlwbWFwIGxldmVsc1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggbWlwbWFwcy5sZW5ndGggPiAwICYmIGlzUG93ZXJPZlR3b0ltYWdlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIDAsIGdsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0ZXh0dXJlTmVlZHNHZW5lcmF0ZU1pcG1hcHMoIHRleHR1cmUsIGlzUG93ZXJPZlR3b0ltYWdlICkgKSBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFXzJEICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uID0gdGV4dHVyZS52ZXJzaW9uO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGV4dHVyZS5vblVwZGF0ZSApIHRleHR1cmUub25VcGRhdGUoIHRleHR1cmUgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0Ly8gUmVuZGVyIHRhcmdldHNcXHJcXG5cXHJcXG5cXHRcXHQvLyBTZXR1cCBzdG9yYWdlIGZvciB0YXJnZXQgdGV4dHVyZSBhbmQgYmluZCBpdCB0byBjb3JyZWN0IGZyYW1lYnVmZmVyXFxyXFxuXFx0XFx0ZnVuY3Rpb24gc2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUoIGZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQsIGF0dGFjaG1lbnQsIHRleHR1cmVUYXJnZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGdsRm9ybWF0ID0gdXRpbHMuY29udmVydCggcmVuZGVyVGFyZ2V0LnRleHR1cmUuZm9ybWF0ICk7XFxyXFxuXFx0XFx0XFx0dmFyIGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQoIHJlbmRlclRhcmdldC50ZXh0dXJlLnR5cGUgKTtcXHJcXG5cXHRcXHRcXHRzdGF0ZS50ZXhJbWFnZTJEKCB0ZXh0dXJlVGFyZ2V0LCAwLCBnbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBudWxsICk7XFxyXFxuXFx0XFx0XFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xcclxcblxcdFxcdFxcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggX2dsLkZSQU1FQlVGRkVSLCBhdHRhY2htZW50LCB0ZXh0dXJlVGFyZ2V0LCBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZSwgMCApO1xcclxcblxcdFxcdFxcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHQvLyBTZXR1cCBzdG9yYWdlIGZvciBpbnRlcm5hbCBkZXB0aC9zdGVuY2lsIGJ1ZmZlcnMgYW5kIGJpbmQgdG8gY29ycmVjdCBmcmFtZWJ1ZmZlclxcclxcblxcdFxcdGZ1bmN0aW9uIHNldHVwUmVuZGVyQnVmZmVyU3RvcmFnZSggcmVuZGVyYnVmZmVyLCByZW5kZXJUYXJnZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0X2dsLmJpbmRSZW5kZXJidWZmZXIoIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmICEgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0X2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIF9nbC5SRU5ERVJCVUZGRVIsIF9nbC5ERVBUSF9DT01QT05FTlQxNiwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XFxyXFxuXFx0XFx0XFx0XFx0X2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9BVFRBQ0hNRU5ULCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0X2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIF9nbC5SRU5ERVJCVUZGRVIsIF9nbC5ERVBUSF9TVEVOQ0lMLCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcXHJcXG5cXHRcXHRcXHRcXHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBGSVhNRTogV2UgZG9uJ3Qgc3VwcG9ydCAhZGVwdGggIXN0ZW5jaWxcXHJcXG5cXHRcXHRcXHRcXHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLlJHQkE0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0X2dsLmJpbmRSZW5kZXJidWZmZXIoIF9nbC5SRU5ERVJCVUZGRVIsIG51bGwgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0Ly8gU2V0dXAgcmVzb3VyY2VzIGZvciBhIERlcHRoIFRleHR1cmUgZm9yIGEgRkJPIChuZWVkcyBhbiBleHRlbnNpb24pXFxyXFxuXFx0XFx0ZnVuY3Rpb24gc2V0dXBEZXB0aFRleHR1cmUoIGZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGlzQ3ViZSA9ICggcmVuZGVyVGFyZ2V0ICYmIHJlbmRlclRhcmdldC5pc1dlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApO1xcclxcblxcdFxcdFxcdGlmICggaXNDdWJlICkgdGhyb3cgbmV3IEVycm9yKCAnRGVwdGggVGV4dHVyZSB3aXRoIGN1YmUgcmVuZGVyIHRhcmdldHMgaXMgbm90IHN1cHBvcnRlZCcgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCAhICggcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSAmJiByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmlzRGVwdGhUZXh0dXJlICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhyb3cgbmV3IEVycm9yKCAncmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFRIUkVFLkRlcHRoVGV4dHVyZScgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gdXBsb2FkIGFuIGVtcHR5IGRlcHRoIHRleHR1cmUgd2l0aCBmcmFtZWJ1ZmZlciBzaXplXFxyXFxuXFx0XFx0XFx0aWYgKCAhIHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlICkuX193ZWJnbFRleHR1cmUgfHxcXHJcXG5cXHRcXHRcXHRcXHRcXHRyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmltYWdlLndpZHRoICE9PSByZW5kZXJUYXJnZXQud2lkdGggfHxcXHJcXG5cXHRcXHRcXHRcXHRcXHRyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmltYWdlLmhlaWdodCAhPT0gcmVuZGVyVGFyZ2V0LmhlaWdodCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmltYWdlLndpZHRoID0gcmVuZGVyVGFyZ2V0LndpZHRoO1xcclxcblxcdFxcdFxcdFxcdHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuaW1hZ2UuaGVpZ2h0ID0gcmVuZGVyVGFyZ2V0LmhlaWdodDtcXHJcXG5cXHRcXHRcXHRcXHRyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0c2V0VGV4dHVyZTJEKCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLCAwICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHdlYmdsRGVwdGhUZXh0dXJlID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuZm9ybWF0ID09PSBEZXB0aEZvcm1hdCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX0FUVEFDSE1FTlQsIF9nbC5URVhUVVJFXzJELCB3ZWJnbERlcHRoVGV4dHVyZSwgMCApO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuZm9ybWF0ID09PSBEZXB0aFN0ZW5jaWxGb3JtYXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0X2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIF9nbC5URVhUVVJFXzJELCB3ZWJnbERlcHRoVGV4dHVyZSwgMCApO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhyb3cgbmV3IEVycm9yKCAnVW5rbm93biBkZXB0aFRleHR1cmUgZm9ybWF0JyApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0Ly8gU2V0dXAgR0wgcmVzb3VyY2VzIGZvciBhIG5vbi10ZXh0dXJlIGRlcHRoIGJ1ZmZlclxcclxcblxcdFxcdGZ1bmN0aW9uIHNldHVwRGVwdGhSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgaXNDdWJlID0gKCByZW5kZXJUYXJnZXQuaXNXZWJHTFJlbmRlclRhcmdldEN1YmUgPT09IHRydWUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBpc0N1YmUgKSB0aHJvdyBuZXcgRXJyb3IoICd0YXJnZXQuZGVwdGhUZXh0dXJlIG5vdCBzdXBwb3J0ZWQgaW4gQ3ViZSByZW5kZXIgdGFyZ2V0cycgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzZXR1cERlcHRoVGV4dHVyZSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCApO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBpc0N1YmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyWyBpIF0gPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0c2V0dXBSZW5kZXJCdWZmZXJTdG9yYWdlKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlclsgaSBdLCByZW5kZXJUYXJnZXQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIgPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0c2V0dXBSZW5kZXJCdWZmZXJTdG9yYWdlKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciwgcmVuZGVyVGFyZ2V0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIG51bGwgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0Ly8gU2V0IHVwIEdMIHJlc291cmNlcyBmb3IgdGhlIHJlbmRlciB0YXJnZXRcXHJcXG5cXHRcXHRmdW5jdGlvbiBzZXR1cFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApO1xcclxcblxcdFxcdFxcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xcclxcblxcclxcblxcdFxcdFxcdHJlbmRlclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSApO1xcclxcblxcclxcblxcdFxcdFxcdHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpbmZvTWVtb3J5LnRleHR1cmVzICsrO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBpc0N1YmUgPSAoIHJlbmRlclRhcmdldC5pc1dlYkdMUmVuZGVyVGFyZ2V0Q3ViZSA9PT0gdHJ1ZSApO1xcclxcblxcdFxcdFxcdHZhciBpc1RhcmdldFBvd2VyT2ZUd28gPSBpc1Bvd2VyT2ZUd28oIHJlbmRlclRhcmdldCApO1xcclxcblxcclxcblxcdFxcdFxcdC8vIFNldHVwIGZyYW1lYnVmZmVyXFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBpc0N1YmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0gPSBfZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciA9IF9nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBTZXR1cCBjb2xvciBidWZmZXJcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGlzQ3ViZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XFxyXFxuXFx0XFx0XFx0XFx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCByZW5kZXJUYXJnZXQudGV4dHVyZSwgaXNUYXJnZXRQb3dlck9mVHdvICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSwgcmVuZGVyVGFyZ2V0LCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAsIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggdGV4dHVyZU5lZWRzR2VuZXJhdGVNaXBtYXBzKCByZW5kZXJUYXJnZXQudGV4dHVyZSwgaXNUYXJnZXRQb3dlck9mVHdvICkgKSBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFX0NVQkVfTUFQICk7XFxyXFxuXFx0XFx0XFx0XFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCBudWxsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XFxyXFxuXFx0XFx0XFx0XFx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFXzJELCByZW5kZXJUYXJnZXQudGV4dHVyZSwgaXNUYXJnZXRQb3dlck9mVHdvICk7XFxyXFxuXFx0XFx0XFx0XFx0c2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgX2dsLlRFWFRVUkVfMkQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyggcmVuZGVyVGFyZ2V0LnRleHR1cmUsIGlzVGFyZ2V0UG93ZXJPZlR3byApICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV8yRCApO1xcclxcblxcdFxcdFxcdFxcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBTZXR1cCBkZXB0aCBhbmQgc3RlbmNpbCBidWZmZXJzXFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0c2V0dXBEZXB0aFJlbmRlcmJ1ZmZlciggcmVuZGVyVGFyZ2V0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiB1cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAoIHJlbmRlclRhcmdldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdGV4dHVyZSA9IHJlbmRlclRhcmdldC50ZXh0dXJlO1xcclxcblxcdFxcdFxcdHZhciBpc1RhcmdldFBvd2VyT2ZUd28gPSBpc1Bvd2VyT2ZUd28oIHJlbmRlclRhcmdldCApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGV4dHVyZU5lZWRzR2VuZXJhdGVNaXBtYXBzKCB0ZXh0dXJlLCBpc1RhcmdldFBvd2VyT2ZUd28gKSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgdGFyZ2V0ID0gcmVuZGVyVGFyZ2V0LmlzV2ViR0xSZW5kZXJUYXJnZXRDdWJlID8gX2dsLlRFWFRVUkVfQ1VCRV9NQVAgOiBfZ2wuVEVYVFVSRV8yRDtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgd2ViZ2xUZXh0dXJlID0gcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzdGF0ZS5iaW5kVGV4dHVyZSggdGFyZ2V0LCB3ZWJnbFRleHR1cmUgKTtcXHJcXG5cXHRcXHRcXHRcXHRfZ2wuZ2VuZXJhdGVNaXBtYXAoIHRhcmdldCApO1xcclxcblxcdFxcdFxcdFxcdHN0YXRlLmJpbmRUZXh0dXJlKCB0YXJnZXQsIG51bGwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIHVwZGF0ZVZpZGVvVGV4dHVyZXMoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGlkIGluIF92aWRlb1RleHR1cmVzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdF92aWRlb1RleHR1cmVzWyBpZCBdLnVwZGF0ZSgpO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5zZXRUZXh0dXJlMkQgPSBzZXRUZXh0dXJlMkQ7XFxyXFxuXFx0XFx0dGhpcy5zZXRUZXh0dXJlQ3ViZSA9IHNldFRleHR1cmVDdWJlO1xcclxcblxcdFxcdHRoaXMuc2V0VGV4dHVyZUN1YmVEeW5hbWljID0gc2V0VGV4dHVyZUN1YmVEeW5hbWljO1xcclxcblxcdFxcdHRoaXMuc2V0dXBSZW5kZXJUYXJnZXQgPSBzZXR1cFJlbmRlclRhcmdldDtcXHJcXG5cXHRcXHR0aGlzLnVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCA9IHVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcDtcXHJcXG5cXHRcXHR0aGlzLnVwZGF0ZVZpZGVvVGV4dHVyZXMgPSB1cGRhdGVWaWRlb1RleHR1cmVzO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIGZvcmRhY2lvdXMgLyBmb3JkYWNpb3VzLmdpdGh1Yi5pb1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIFdlYkdMUHJvcGVydGllcygpIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgcHJvcGVydGllcyA9IHt9O1xcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIGdldCggb2JqZWN0ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB1dWlkID0gb2JqZWN0LnV1aWQ7XFxyXFxuXFx0XFx0XFx0dmFyIG1hcCA9IHByb3BlcnRpZXNbIHV1aWQgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIG1hcCA9PT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdG1hcCA9IHt9O1xcclxcblxcdFxcdFxcdFxcdHByb3BlcnRpZXNbIHV1aWQgXSA9IG1hcDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIG1hcDtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gcmVtb3ZlKCBvYmplY3QgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZGVsZXRlIHByb3BlcnRpZXNbIG9iamVjdC51dWlkIF07XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIGNsZWFyKCkge1xcclxcblxcclxcblxcdFxcdFxcdHByb3BlcnRpZXMgPSB7fTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHtcXHJcXG5cXHRcXHRcXHRnZXQ6IGdldCxcXHJcXG5cXHRcXHRcXHRyZW1vdmU6IHJlbW92ZSxcXHJcXG5cXHRcXHRcXHRjbGVhcjogY2xlYXJcXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIFdlYkdMU3RhdGUoIGdsLCBleHRlbnNpb25zLCB1dGlscyApIHtcXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBDb2xvckJ1ZmZlcigpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbG9ja2VkID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGNvbG9yID0gbmV3IFZlY3RvcjQoKTtcXHJcXG5cXHRcXHRcXHR2YXIgY3VycmVudENvbG9yTWFzayA9IG51bGw7XFxyXFxuXFx0XFx0XFx0dmFyIGN1cnJlbnRDb2xvckNsZWFyID0gbmV3IFZlY3RvcjQoIDAsIDAsIDAsIDAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4ge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHNldE1hc2s6IGZ1bmN0aW9uICggY29sb3JNYXNrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggY3VycmVudENvbG9yTWFzayAhPT0gY29sb3JNYXNrICYmICEgbG9ja2VkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGdsLmNvbG9yTWFzayggY29sb3JNYXNrLCBjb2xvck1hc2ssIGNvbG9yTWFzaywgY29sb3JNYXNrICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y3VycmVudENvbG9yTWFzayA9IGNvbG9yTWFzaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzZXRMb2NrZWQ6IGZ1bmN0aW9uICggbG9jayApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRsb2NrZWQgPSBsb2NrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0c2V0Q2xlYXI6IGZ1bmN0aW9uICggciwgZywgYiwgYSwgcHJlbXVsdGlwbGllZEFscGhhICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggcHJlbXVsdGlwbGllZEFscGhhID09PSB0cnVlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHIgKj0gYTsgZyAqPSBhOyBiICo9IGE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNvbG9yLnNldCggciwgZywgYiwgYSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggY3VycmVudENvbG9yQ2xlYXIuZXF1YWxzKCBjb2xvciApID09PSBmYWxzZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRnbC5jbGVhckNvbG9yKCByLCBnLCBiLCBhICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y3VycmVudENvbG9yQ2xlYXIuY29weSggY29sb3IgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXNldDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGxvY2tlZCA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGN1cnJlbnRDb2xvck1hc2sgPSBudWxsO1xcclxcblxcdFxcdFxcdFxcdFxcdGN1cnJlbnRDb2xvckNsZWFyLnNldCggLSAxLCAwLCAwLCAwICk7IC8vIHNldCB0byBpbnZhbGlkIHN0YXRlXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIERlcHRoQnVmZmVyKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBsb2NrZWQgPSBmYWxzZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgY3VycmVudERlcHRoTWFzayA9IG51bGw7XFxyXFxuXFx0XFx0XFx0dmFyIGN1cnJlbnREZXB0aEZ1bmMgPSBudWxsO1xcclxcblxcdFxcdFxcdHZhciBjdXJyZW50RGVwdGhDbGVhciA9IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzZXRUZXN0OiBmdW5jdGlvbiAoIGRlcHRoVGVzdCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGRlcHRoVGVzdCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRlbmFibGUoIGdsLkRFUFRIX1RFU1QgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGRpc2FibGUoIGdsLkRFUFRIX1RFU1QgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzZXRNYXNrOiBmdW5jdGlvbiAoIGRlcHRoTWFzayApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGN1cnJlbnREZXB0aE1hc2sgIT09IGRlcHRoTWFzayAmJiAhIGxvY2tlZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRnbC5kZXB0aE1hc2soIGRlcHRoTWFzayApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGN1cnJlbnREZXB0aE1hc2sgPSBkZXB0aE1hc2s7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0c2V0RnVuYzogZnVuY3Rpb24gKCBkZXB0aEZ1bmMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBjdXJyZW50RGVwdGhGdW5jICE9PSBkZXB0aEZ1bmMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBkZXB0aEZ1bmMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c3dpdGNoICggZGVwdGhGdW5jICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgTmV2ZXJEZXB0aDpcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC5kZXB0aEZ1bmMoIGdsLk5FVkVSICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSBBbHdheXNEZXB0aDpcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC5kZXB0aEZ1bmMoIGdsLkFMV0FZUyApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgTGVzc0RlcHRoOlxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLmRlcHRoRnVuYyggZ2wuTEVTUyApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgTGVzc0VxdWFsRGVwdGg6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wuZGVwdGhGdW5jKCBnbC5MRVFVQUwgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjYXNlIEVxdWFsRGVwdGg6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wuZGVwdGhGdW5jKCBnbC5FUVVBTCApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgR3JlYXRlckVxdWFsRGVwdGg6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wuZGVwdGhGdW5jKCBnbC5HRVFVQUwgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjYXNlIEdyZWF0ZXJEZXB0aDpcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC5kZXB0aEZ1bmMoIGdsLkdSRUFURVIgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjYXNlIE5vdEVxdWFsRGVwdGg6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wuZGVwdGhGdW5jKCBnbC5OT1RFUVVBTCApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRlZmF1bHQ6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wuZGVwdGhGdW5jKCBnbC5MRVFVQUwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjdXJyZW50RGVwdGhGdW5jID0gZGVwdGhGdW5jO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9LFxcclxcblxcclxcblxcdFxcdFxcdFxcdHNldExvY2tlZDogZnVuY3Rpb24gKCBsb2NrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGxvY2tlZCA9IGxvY2s7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzZXRDbGVhcjogZnVuY3Rpb24gKCBkZXB0aCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGN1cnJlbnREZXB0aENsZWFyICE9PSBkZXB0aCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRnbC5jbGVhckRlcHRoKCBkZXB0aCApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGN1cnJlbnREZXB0aENsZWFyID0gZGVwdGg7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmVzZXQ6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRsb2NrZWQgPSBmYWxzZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRjdXJyZW50RGVwdGhNYXNrID0gbnVsbDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRjdXJyZW50RGVwdGhGdW5jID0gbnVsbDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRjdXJyZW50RGVwdGhDbGVhciA9IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIFN0ZW5jaWxCdWZmZXIoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGxvY2tlZCA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBjdXJyZW50U3RlbmNpbE1hc2sgPSBudWxsO1xcclxcblxcdFxcdFxcdHZhciBjdXJyZW50U3RlbmNpbEZ1bmMgPSBudWxsO1xcclxcblxcdFxcdFxcdHZhciBjdXJyZW50U3RlbmNpbFJlZiA9IG51bGw7XFxyXFxuXFx0XFx0XFx0dmFyIGN1cnJlbnRTdGVuY2lsRnVuY01hc2sgPSBudWxsO1xcclxcblxcdFxcdFxcdHZhciBjdXJyZW50U3RlbmNpbEZhaWwgPSBudWxsO1xcclxcblxcdFxcdFxcdHZhciBjdXJyZW50U3RlbmNpbFpGYWlsID0gbnVsbDtcXHJcXG5cXHRcXHRcXHR2YXIgY3VycmVudFN0ZW5jaWxaUGFzcyA9IG51bGw7XFxyXFxuXFx0XFx0XFx0dmFyIGN1cnJlbnRTdGVuY2lsQ2xlYXIgPSBudWxsO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0c2V0VGVzdDogZnVuY3Rpb24gKCBzdGVuY2lsVGVzdCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHN0ZW5jaWxUZXN0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGVuYWJsZSggZ2wuU1RFTkNJTF9URVNUICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRkaXNhYmxlKCBnbC5TVEVOQ0lMX1RFU1QgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzZXRNYXNrOiBmdW5jdGlvbiAoIHN0ZW5jaWxNYXNrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggY3VycmVudFN0ZW5jaWxNYXNrICE9PSBzdGVuY2lsTWFzayAmJiAhIGxvY2tlZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRnbC5zdGVuY2lsTWFzayggc3RlbmNpbE1hc2sgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjdXJyZW50U3RlbmNpbE1hc2sgPSBzdGVuY2lsTWFzaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzZXRGdW5jOiBmdW5jdGlvbiAoIHN0ZW5jaWxGdW5jLCBzdGVuY2lsUmVmLCBzdGVuY2lsTWFzayApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGN1cnJlbnRTdGVuY2lsRnVuYyAhPT0gc3RlbmNpbEZ1bmMgfHxcXHJcXG5cXHRcXHRcXHRcXHRcXHQgICAgIGN1cnJlbnRTdGVuY2lsUmVmIFxcdCE9PSBzdGVuY2lsUmVmIFxcdHx8XFxyXFxuXFx0XFx0XFx0XFx0XFx0ICAgICBjdXJyZW50U3RlbmNpbEZ1bmNNYXNrICE9PSBzdGVuY2lsTWFzayApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRnbC5zdGVuY2lsRnVuYyggc3RlbmNpbEZ1bmMsIHN0ZW5jaWxSZWYsIHN0ZW5jaWxNYXNrICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y3VycmVudFN0ZW5jaWxGdW5jID0gc3RlbmNpbEZ1bmM7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y3VycmVudFN0ZW5jaWxSZWYgPSBzdGVuY2lsUmVmO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGN1cnJlbnRTdGVuY2lsRnVuY01hc2sgPSBzdGVuY2lsTWFzaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzZXRPcDogZnVuY3Rpb24gKCBzdGVuY2lsRmFpbCwgc3RlbmNpbFpGYWlsLCBzdGVuY2lsWlBhc3MgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBjdXJyZW50U3RlbmNpbEZhaWxcXHQgIT09IHN0ZW5jaWxGYWlsIFxcdHx8XFxyXFxuXFx0XFx0XFx0XFx0XFx0ICAgICBjdXJyZW50U3RlbmNpbFpGYWlsICE9PSBzdGVuY2lsWkZhaWwgfHxcXHJcXG5cXHRcXHRcXHRcXHRcXHQgICAgIGN1cnJlbnRTdGVuY2lsWlBhc3MgIT09IHN0ZW5jaWxaUGFzcyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRnbC5zdGVuY2lsT3AoIHN0ZW5jaWxGYWlsLCBzdGVuY2lsWkZhaWwsIHN0ZW5jaWxaUGFzcyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGN1cnJlbnRTdGVuY2lsRmFpbCA9IHN0ZW5jaWxGYWlsO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGN1cnJlbnRTdGVuY2lsWkZhaWwgPSBzdGVuY2lsWkZhaWw7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y3VycmVudFN0ZW5jaWxaUGFzcyA9IHN0ZW5jaWxaUGFzcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzZXRMb2NrZWQ6IGZ1bmN0aW9uICggbG9jayApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRsb2NrZWQgPSBsb2NrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0c2V0Q2xlYXI6IGZ1bmN0aW9uICggc3RlbmNpbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGN1cnJlbnRTdGVuY2lsQ2xlYXIgIT09IHN0ZW5jaWwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2wuY2xlYXJTdGVuY2lsKCBzdGVuY2lsICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y3VycmVudFN0ZW5jaWxDbGVhciA9IHN0ZW5jaWw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmVzZXQ6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRsb2NrZWQgPSBmYWxzZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRjdXJyZW50U3RlbmNpbE1hc2sgPSBudWxsO1xcclxcblxcdFxcdFxcdFxcdFxcdGN1cnJlbnRTdGVuY2lsRnVuYyA9IG51bGw7XFxyXFxuXFx0XFx0XFx0XFx0XFx0Y3VycmVudFN0ZW5jaWxSZWYgPSBudWxsO1xcclxcblxcdFxcdFxcdFxcdFxcdGN1cnJlbnRTdGVuY2lsRnVuY01hc2sgPSBudWxsO1xcclxcblxcdFxcdFxcdFxcdFxcdGN1cnJlbnRTdGVuY2lsRmFpbCA9IG51bGw7XFxyXFxuXFx0XFx0XFx0XFx0XFx0Y3VycmVudFN0ZW5jaWxaRmFpbCA9IG51bGw7XFxyXFxuXFx0XFx0XFx0XFx0XFx0Y3VycmVudFN0ZW5jaWxaUGFzcyA9IG51bGw7XFxyXFxuXFx0XFx0XFx0XFx0XFx0Y3VycmVudFN0ZW5jaWxDbGVhciA9IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdC8vXFxyXFxuXFxyXFxuXFx0XFx0dmFyIGNvbG9yQnVmZmVyID0gbmV3IENvbG9yQnVmZmVyKCk7XFxyXFxuXFx0XFx0dmFyIGRlcHRoQnVmZmVyID0gbmV3IERlcHRoQnVmZmVyKCk7XFxyXFxuXFx0XFx0dmFyIHN0ZW5jaWxCdWZmZXIgPSBuZXcgU3RlbmNpbEJ1ZmZlcigpO1xcclxcblxcclxcblxcdFxcdHZhciBtYXhWZXJ0ZXhBdHRyaWJ1dGVzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkVSVEVYX0FUVFJJQlMgKTtcXHJcXG5cXHRcXHR2YXIgbmV3QXR0cmlidXRlcyA9IG5ldyBVaW50OEFycmF5KCBtYXhWZXJ0ZXhBdHRyaWJ1dGVzICk7XFxyXFxuXFx0XFx0dmFyIGVuYWJsZWRBdHRyaWJ1dGVzID0gbmV3IFVpbnQ4QXJyYXkoIG1heFZlcnRleEF0dHJpYnV0ZXMgKTtcXHJcXG5cXHRcXHR2YXIgYXR0cmlidXRlRGl2aXNvcnMgPSBuZXcgVWludDhBcnJheSggbWF4VmVydGV4QXR0cmlidXRlcyApO1xcclxcblxcclxcblxcdFxcdHZhciBjYXBhYmlsaXRpZXMgPSB7fTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID0gbnVsbDtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgY3VycmVudFByb2dyYW0gPSBudWxsO1xcclxcblxcclxcblxcdFxcdHZhciBjdXJyZW50QmxlbmRpbmcgPSBudWxsO1xcclxcblxcdFxcdHZhciBjdXJyZW50QmxlbmRFcXVhdGlvbiA9IG51bGw7XFxyXFxuXFx0XFx0dmFyIGN1cnJlbnRCbGVuZFNyYyA9IG51bGw7XFxyXFxuXFx0XFx0dmFyIGN1cnJlbnRCbGVuZERzdCA9IG51bGw7XFxyXFxuXFx0XFx0dmFyIGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBudWxsO1xcclxcblxcdFxcdHZhciBjdXJyZW50QmxlbmRTcmNBbHBoYSA9IG51bGw7XFxyXFxuXFx0XFx0dmFyIGN1cnJlbnRCbGVuZERzdEFscGhhID0gbnVsbDtcXHJcXG5cXHRcXHR2YXIgY3VycmVudFByZW11bHRpcGxlZEFscGhhID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGN1cnJlbnRGbGlwU2lkZWQgPSBudWxsO1xcclxcblxcdFxcdHZhciBjdXJyZW50Q3VsbEZhY2UgPSBudWxsO1xcclxcblxcclxcblxcdFxcdHZhciBjdXJyZW50TGluZVdpZHRoID0gbnVsbDtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgY3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgPSBudWxsO1xcclxcblxcdFxcdHZhciBjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzID0gbnVsbDtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgbWF4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTICk7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHZlcnNpb24gPSBwYXJzZUZsb2F0KCAvXldlYkdMXFxcXCAoWzAtOV0pLy5leGVjKCBnbC5nZXRQYXJhbWV0ZXIoIGdsLlZFUlNJT04gKSApWyAxIF0gKTtcXHJcXG5cXHRcXHR2YXIgbGluZVdpZHRoQXZhaWxhYmxlID0gcGFyc2VGbG9hdCggdmVyc2lvbiApID49IDEuMDtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgY3VycmVudFRleHR1cmVTbG90ID0gbnVsbDtcXHJcXG5cXHRcXHR2YXIgY3VycmVudEJvdW5kVGV4dHVyZXMgPSB7fTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgY3VycmVudFNjaXNzb3IgPSBuZXcgVmVjdG9yNCgpO1xcclxcblxcdFxcdHZhciBjdXJyZW50Vmlld3BvcnQgPSBuZXcgVmVjdG9yNCgpO1xcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIGNyZWF0ZVRleHR1cmUoIHR5cGUsIHRhcmdldCwgY291bnQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGRhdGEgPSBuZXcgVWludDhBcnJheSggNCApOyAvLyA0IGlzIHJlcXVpcmVkIHRvIG1hdGNoIGRlZmF1bHQgdW5wYWNrIGFsaWdubWVudCBvZiA0LlxcclxcblxcdFxcdFxcdHZhciB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xcclxcblxcclxcblxcdFxcdFxcdGdsLmJpbmRUZXh0dXJlKCB0eXBlLCB0ZXh0dXJlICk7XFxyXFxuXFx0XFx0XFx0Z2wudGV4UGFyYW1ldGVyaSggdHlwZSwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUICk7XFxyXFxuXFx0XFx0XFx0Z2wudGV4UGFyYW1ldGVyaSggdHlwZSwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgY291bnQ7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Z2wudGV4SW1hZ2UyRCggdGFyZ2V0ICsgaSwgMCwgZ2wuUkdCQSwgMSwgMSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgZGF0YSApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGV4dHVyZTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGVtcHR5VGV4dHVyZXMgPSB7fTtcXHJcXG5cXHRcXHRlbXB0eVRleHR1cmVzWyBnbC5URVhUVVJFXzJEIF0gPSBjcmVhdGVUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFXzJELCAxICk7XFxyXFxuXFx0XFx0ZW1wdHlUZXh0dXJlc1sgZ2wuVEVYVFVSRV9DVUJFX01BUCBdID0gY3JlYXRlVGV4dHVyZSggZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YLCA2ICk7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gaW5pdFxcclxcblxcclxcblxcdFxcdGNvbG9yQnVmZmVyLnNldENsZWFyKCAwLCAwLCAwLCAxICk7XFxyXFxuXFx0XFx0ZGVwdGhCdWZmZXIuc2V0Q2xlYXIoIDEgKTtcXHJcXG5cXHRcXHRzdGVuY2lsQnVmZmVyLnNldENsZWFyKCAwICk7XFxyXFxuXFxyXFxuXFx0XFx0ZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XFxyXFxuXFx0XFx0ZGVwdGhCdWZmZXIuc2V0RnVuYyggTGVzc0VxdWFsRGVwdGggKTtcXHJcXG5cXHJcXG5cXHRcXHRzZXRGbGlwU2lkZWQoIGZhbHNlICk7XFxyXFxuXFx0XFx0c2V0Q3VsbEZhY2UoIEN1bGxGYWNlQmFjayApO1xcclxcblxcdFxcdGVuYWJsZSggZ2wuQ1VMTF9GQUNFICk7XFxyXFxuXFxyXFxuXFx0XFx0ZW5hYmxlKCBnbC5CTEVORCApO1xcclxcblxcdFxcdHNldEJsZW5kaW5nKCBOb3JtYWxCbGVuZGluZyApO1xcclxcblxcclxcblxcdFxcdC8vXFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gaW5pdEF0dHJpYnV0ZXMoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbmV3QXR0cmlidXRlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdG5ld0F0dHJpYnV0ZXNbIGkgXSA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRuZXdBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9IDE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBlbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPT09IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIGF0dHJpYnV0ZSApO1xcclxcblxcdFxcdFxcdFxcdGVuYWJsZWRBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9IDE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggYXR0cmlidXRlRGl2aXNvcnNbIGF0dHJpYnV0ZSBdICE9PSAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZXh0ZW5zaW9uLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRSggYXR0cmlidXRlLCAwICk7XFxyXFxuXFx0XFx0XFx0XFx0YXR0cmlidXRlRGl2aXNvcnNbIGF0dHJpYnV0ZSBdID0gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIGVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IoIGF0dHJpYnV0ZSwgbWVzaFBlckF0dHJpYnV0ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRuZXdBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9IDE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBlbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPT09IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIGF0dHJpYnV0ZSApO1xcclxcblxcdFxcdFxcdFxcdGVuYWJsZWRBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9IDE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggYXR0cmlidXRlRGl2aXNvcnNbIGF0dHJpYnV0ZSBdICE9PSBtZXNoUGVyQXR0cmlidXRlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZXh0ZW5zaW9uLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRSggYXR0cmlidXRlLCBtZXNoUGVyQXR0cmlidXRlICk7XFxyXFxuXFx0XFx0XFx0XFx0YXR0cmlidXRlRGl2aXNvcnNbIGF0dHJpYnV0ZSBdID0gbWVzaFBlckF0dHJpYnV0ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIGRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCkge1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGVuYWJsZWRBdHRyaWJ1dGVzLmxlbmd0aDsgaSAhPT0gbDsgKysgaSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gIT09IG5ld0F0dHJpYnV0ZXNbIGkgXSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoIGkgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRlbmFibGVkQXR0cmlidXRlc1sgaSBdID0gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBlbmFibGUoIGlkICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggY2FwYWJpbGl0aWVzWyBpZCBdICE9PSB0cnVlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGdsLmVuYWJsZSggaWQgKTtcXHJcXG5cXHRcXHRcXHRcXHRjYXBhYmlsaXRpZXNbIGlkIF0gPSB0cnVlO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gZGlzYWJsZSggaWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBjYXBhYmlsaXRpZXNbIGlkIF0gIT09IGZhbHNlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGdsLmRpc2FibGUoIGlkICk7XFxyXFxuXFx0XFx0XFx0XFx0Y2FwYWJpbGl0aWVzWyBpZCBdID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBnZXRDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPT09IG51bGwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID0gW107XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKSB8fFxcclxcblxcdFxcdFxcdFxcdCAgICAgZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSB8fFxcclxcblxcdFxcdFxcdFxcdCAgICAgZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjMScgKSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgZm9ybWF0cyA9IGdsLmdldFBhcmFtZXRlciggZ2wuQ09NUFJFU1NFRF9URVhUVVJFX0ZPUk1BVFMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBmb3JtYXRzLmxlbmd0aDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMucHVzaCggZm9ybWF0c1sgaSBdICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cztcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gdXNlUHJvZ3JhbSggcHJvZ3JhbSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGN1cnJlbnRQcm9ncmFtICE9PSBwcm9ncmFtICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGdsLnVzZVByb2dyYW0oIHByb2dyYW0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjdXJyZW50UHJvZ3JhbSA9IHByb2dyYW07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gc2V0QmxlbmRpbmcoIGJsZW5kaW5nLCBibGVuZEVxdWF0aW9uLCBibGVuZFNyYywgYmxlbmREc3QsIGJsZW5kRXF1YXRpb25BbHBoYSwgYmxlbmRTcmNBbHBoYSwgYmxlbmREc3RBbHBoYSwgcHJlbXVsdGlwbGllZEFscGhhICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggYmxlbmRpbmcgIT09IE5vQmxlbmRpbmcgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZW5hYmxlKCBnbC5CTEVORCApO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZGlzYWJsZSggZ2wuQkxFTkQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBibGVuZGluZyAhPT0gQ3VzdG9tQmxlbmRpbmcgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBibGVuZGluZyAhPT0gY3VycmVudEJsZW5kaW5nIHx8IHByZW11bHRpcGxpZWRBbHBoYSAhPT0gY3VycmVudFByZW11bHRpcGxlZEFscGhhICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHN3aXRjaCAoIGJsZW5kaW5nICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgQWRkaXRpdmVCbGVuZGluZzpcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHByZW11bHRpcGxpZWRBbHBoYSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoIGdsLkZVTkNfQURELCBnbC5GVU5DX0FERCApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKCBnbC5PTkUsIGdsLk9ORSwgZ2wuT05FLCBnbC5PTkUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLmJsZW5kRXF1YXRpb24oIGdsLkZVTkNfQUREICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wuYmxlbmRGdW5jKCBnbC5TUkNfQUxQSEEsIGdsLk9ORSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlIFN1YnRyYWN0aXZlQmxlbmRpbmc6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBwcmVtdWx0aXBsaWVkQWxwaGEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKCBnbC5GVU5DX0FERCwgZ2wuRlVOQ19BREQgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZ2wuWkVSTywgZ2wuWkVSTywgZ2wuT05FX01JTlVTX1NSQ19DT0xPUiwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wuYmxlbmRFcXVhdGlvbiggZ2wuRlVOQ19BREQgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC5ibGVuZEZ1bmMoIGdsLlpFUk8sIGdsLk9ORV9NSU5VU19TUkNfQ09MT1IgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSBNdWx0aXBseUJsZW5kaW5nOlxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggcHJlbXVsdGlwbGllZEFscGhhICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggZ2wuRlVOQ19BREQsIGdsLkZVTkNfQUREICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoIGdsLlpFUk8sIGdsLlNSQ19DT0xPUiwgZ2wuWkVSTywgZ2wuU1JDX0FMUEhBICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC5ibGVuZEVxdWF0aW9uKCBnbC5GVU5DX0FERCApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLmJsZW5kRnVuYyggZ2wuWkVSTywgZ2wuU1JDX0NPTE9SICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGRlZmF1bHQ6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBwcmVtdWx0aXBsaWVkQWxwaGEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKCBnbC5GVU5DX0FERCwgZ2wuRlVOQ19BREQgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggZ2wuRlVOQ19BREQsIGdsLkZVTkNfQUREICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoIGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y3VycmVudEJsZW5kRXF1YXRpb24gPSBudWxsO1xcclxcblxcdFxcdFxcdFxcdGN1cnJlbnRCbGVuZFNyYyA9IG51bGw7XFxyXFxuXFx0XFx0XFx0XFx0Y3VycmVudEJsZW5kRHN0ID0gbnVsbDtcXHJcXG5cXHRcXHRcXHRcXHRjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhID0gbnVsbDtcXHJcXG5cXHRcXHRcXHRcXHRjdXJyZW50QmxlbmRTcmNBbHBoYSA9IG51bGw7XFxyXFxuXFx0XFx0XFx0XFx0Y3VycmVudEJsZW5kRHN0QWxwaGEgPSBudWxsO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YmxlbmRFcXVhdGlvbkFscGhhID0gYmxlbmRFcXVhdGlvbkFscGhhIHx8IGJsZW5kRXF1YXRpb247XFxyXFxuXFx0XFx0XFx0XFx0YmxlbmRTcmNBbHBoYSA9IGJsZW5kU3JjQWxwaGEgfHwgYmxlbmRTcmM7XFxyXFxuXFx0XFx0XFx0XFx0YmxlbmREc3RBbHBoYSA9IGJsZW5kRHN0QWxwaGEgfHwgYmxlbmREc3Q7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBibGVuZEVxdWF0aW9uICE9PSBjdXJyZW50QmxlbmRFcXVhdGlvbiB8fCBibGVuZEVxdWF0aW9uQWxwaGEgIT09IGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Z2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKCB1dGlscy5jb252ZXJ0KCBibGVuZEVxdWF0aW9uICksIHV0aWxzLmNvbnZlcnQoIGJsZW5kRXF1YXRpb25BbHBoYSApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y3VycmVudEJsZW5kRXF1YXRpb24gPSBibGVuZEVxdWF0aW9uO1xcclxcblxcdFxcdFxcdFxcdFxcdGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBibGVuZEVxdWF0aW9uQWxwaGE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggYmxlbmRTcmMgIT09IGN1cnJlbnRCbGVuZFNyYyB8fCBibGVuZERzdCAhPT0gY3VycmVudEJsZW5kRHN0IHx8IGJsZW5kU3JjQWxwaGEgIT09IGN1cnJlbnRCbGVuZFNyY0FscGhhIHx8IGJsZW5kRHN0QWxwaGEgIT09IGN1cnJlbnRCbGVuZERzdEFscGhhICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKCB1dGlscy5jb252ZXJ0KCBibGVuZFNyYyApLCB1dGlscy5jb252ZXJ0KCBibGVuZERzdCApLCB1dGlscy5jb252ZXJ0KCBibGVuZFNyY0FscGhhICksIHV0aWxzLmNvbnZlcnQoIGJsZW5kRHN0QWxwaGEgKSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGN1cnJlbnRCbGVuZFNyYyA9IGJsZW5kU3JjO1xcclxcblxcdFxcdFxcdFxcdFxcdGN1cnJlbnRCbGVuZERzdCA9IGJsZW5kRHN0O1xcclxcblxcdFxcdFxcdFxcdFxcdGN1cnJlbnRCbGVuZFNyY0FscGhhID0gYmxlbmRTcmNBbHBoYTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRjdXJyZW50QmxlbmREc3RBbHBoYSA9IGJsZW5kRHN0QWxwaGE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRjdXJyZW50QmxlbmRpbmcgPSBibGVuZGluZztcXHJcXG5cXHRcXHRcXHRjdXJyZW50UHJlbXVsdGlwbGVkQWxwaGEgPSBwcmVtdWx0aXBsaWVkQWxwaGE7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIHNldE1hdGVyaWFsKCBtYXRlcmlhbCwgZnJvbnRGYWNlQ1cgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0bWF0ZXJpYWwuc2lkZSA9PT0gRG91YmxlU2lkZVxcclxcblxcdFxcdFxcdFxcdD8gZGlzYWJsZSggZ2wuQ1VMTF9GQUNFIClcXHJcXG5cXHRcXHRcXHRcXHQ6IGVuYWJsZSggZ2wuQ1VMTF9GQUNFICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGZsaXBTaWRlZCA9ICggbWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUgKTtcXHJcXG5cXHRcXHRcXHRpZiAoIGZyb250RmFjZUNXICkgZmxpcFNpZGVkID0gISBmbGlwU2lkZWQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0c2V0RmxpcFNpZGVkKCBmbGlwU2lkZWQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRtYXRlcmlhbC50cmFuc3BhcmVudCA9PT0gdHJ1ZVxcclxcblxcdFxcdFxcdFxcdD8gc2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nLCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uLCBtYXRlcmlhbC5ibGVuZFNyYywgbWF0ZXJpYWwuYmxlbmREc3QsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb25BbHBoYSwgbWF0ZXJpYWwuYmxlbmRTcmNBbHBoYSwgbWF0ZXJpYWwuYmxlbmREc3RBbHBoYSwgbWF0ZXJpYWwucHJlbXVsdGlwbGllZEFscGhhIClcXHJcXG5cXHRcXHRcXHRcXHQ6IHNldEJsZW5kaW5nKCBOb0JsZW5kaW5nICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZGVwdGhCdWZmZXIuc2V0RnVuYyggbWF0ZXJpYWwuZGVwdGhGdW5jICk7XFxyXFxuXFx0XFx0XFx0ZGVwdGhCdWZmZXIuc2V0VGVzdCggbWF0ZXJpYWwuZGVwdGhUZXN0ICk7XFxyXFxuXFx0XFx0XFx0ZGVwdGhCdWZmZXIuc2V0TWFzayggbWF0ZXJpYWwuZGVwdGhXcml0ZSApO1xcclxcblxcdFxcdFxcdGNvbG9yQnVmZmVyLnNldE1hc2soIG1hdGVyaWFsLmNvbG9yV3JpdGUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRzZXRQb2x5Z29uT2Zmc2V0KCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0LCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0RmFjdG9yLCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0VW5pdHMgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0Ly9cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBzZXRGbGlwU2lkZWQoIGZsaXBTaWRlZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGN1cnJlbnRGbGlwU2lkZWQgIT09IGZsaXBTaWRlZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGZsaXBTaWRlZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRnbC5mcm9udEZhY2UoIGdsLkNXICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRnbC5mcm9udEZhY2UoIGdsLkNDVyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjdXJyZW50RmxpcFNpZGVkID0gZmxpcFNpZGVkO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gc2V0Q3VsbEZhY2UoIGN1bGxGYWNlICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggY3VsbEZhY2UgIT09IEN1bGxGYWNlTm9uZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRlbmFibGUoIGdsLkNVTExfRkFDRSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggY3VsbEZhY2UgIT09IGN1cnJlbnRDdWxsRmFjZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGN1bGxGYWNlID09PSBDdWxsRmFjZUJhY2sgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2wuY3VsbEZhY2UoIGdsLkJBQ0sgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBjdWxsRmFjZSA9PT0gQ3VsbEZhY2VGcm9udCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRnbC5jdWxsRmFjZSggZ2wuRlJPTlQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGdsLmN1bGxGYWNlKCBnbC5GUk9OVF9BTkRfQkFDSyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRkaXNhYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y3VycmVudEN1bGxGYWNlID0gY3VsbEZhY2U7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIHNldExpbmVXaWR0aCggd2lkdGggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB3aWR0aCAhPT0gY3VycmVudExpbmVXaWR0aCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGxpbmVXaWR0aEF2YWlsYWJsZSApIGdsLmxpbmVXaWR0aCggd2lkdGggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjdXJyZW50TGluZVdpZHRoID0gd2lkdGg7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBzZXRQb2x5Z29uT2Zmc2V0KCBwb2x5Z29uT2Zmc2V0LCBmYWN0b3IsIHVuaXRzICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggcG9seWdvbk9mZnNldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRlbmFibGUoIGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGN1cnJlbnRQb2x5Z29uT2Zmc2V0RmFjdG9yICE9PSBmYWN0b3IgfHwgY3VycmVudFBvbHlnb25PZmZzZXRVbml0cyAhPT0gdW5pdHMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Z2wucG9seWdvbk9mZnNldCggZmFjdG9yLCB1bml0cyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGN1cnJlbnRQb2x5Z29uT2Zmc2V0RmFjdG9yID0gZmFjdG9yO1xcclxcblxcdFxcdFxcdFxcdFxcdGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgPSB1bml0cztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRkaXNhYmxlKCBnbC5QT0xZR09OX09GRlNFVF9GSUxMICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBzZXRTY2lzc29yVGVzdCggc2Npc3NvclRlc3QgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBzY2lzc29yVGVzdCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRlbmFibGUoIGdsLlNDSVNTT1JfVEVTVCApO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZGlzYWJsZSggZ2wuU0NJU1NPUl9URVNUICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHQvLyB0ZXh0dXJlXFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gYWN0aXZlVGV4dHVyZSggd2ViZ2xTbG90ICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggd2ViZ2xTbG90ID09PSB1bmRlZmluZWQgKSB3ZWJnbFNsb3QgPSBnbC5URVhUVVJFMCArIG1heFRleHR1cmVzIC0gMTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGN1cnJlbnRUZXh0dXJlU2xvdCAhPT0gd2ViZ2xTbG90ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGdsLmFjdGl2ZVRleHR1cmUoIHdlYmdsU2xvdCApO1xcclxcblxcdFxcdFxcdFxcdGN1cnJlbnRUZXh0dXJlU2xvdCA9IHdlYmdsU2xvdDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIGJpbmRUZXh0dXJlKCB3ZWJnbFR5cGUsIHdlYmdsVGV4dHVyZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGN1cnJlbnRUZXh0dXJlU2xvdCA9PT0gbnVsbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRhY3RpdmVUZXh0dXJlKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHZhciBib3VuZFRleHR1cmUgPSBjdXJyZW50Qm91bmRUZXh0dXJlc1sgY3VycmVudFRleHR1cmVTbG90IF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBib3VuZFRleHR1cmUgPT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRib3VuZFRleHR1cmUgPSB7IHR5cGU6IHVuZGVmaW5lZCwgdGV4dHVyZTogdW5kZWZpbmVkIH07XFxyXFxuXFx0XFx0XFx0XFx0Y3VycmVudEJvdW5kVGV4dHVyZXNbIGN1cnJlbnRUZXh0dXJlU2xvdCBdID0gYm91bmRUZXh0dXJlO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGJvdW5kVGV4dHVyZS50eXBlICE9PSB3ZWJnbFR5cGUgfHwgYm91bmRUZXh0dXJlLnRleHR1cmUgIT09IHdlYmdsVGV4dHVyZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRnbC5iaW5kVGV4dHVyZSggd2ViZ2xUeXBlLCB3ZWJnbFRleHR1cmUgfHwgZW1wdHlUZXh0dXJlc1sgd2ViZ2xUeXBlIF0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRib3VuZFRleHR1cmUudHlwZSA9IHdlYmdsVHlwZTtcXHJcXG5cXHRcXHRcXHRcXHRib3VuZFRleHR1cmUudGV4dHVyZSA9IHdlYmdsVGV4dHVyZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIGNvbXByZXNzZWRUZXhJbWFnZTJEKCkge1xcclxcblxcclxcblxcdFxcdFxcdHRyeSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Z2wuY29tcHJlc3NlZFRleEltYWdlMkQuYXBwbHkoIGdsLCBhcmd1bWVudHMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGNhdGNoICggZXJyb3IgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMU3RhdGU6JywgZXJyb3IgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIHRleEltYWdlMkQoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dHJ5IHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRnbC50ZXhJbWFnZTJELmFwcGx5KCBnbCwgYXJndW1lbnRzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBjYXRjaCAoIGVycm9yICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFN0YXRlOicsIGVycm9yICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHQvL1xcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIHNjaXNzb3IoIHNjaXNzb3IgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBjdXJyZW50U2Npc3Nvci5lcXVhbHMoIHNjaXNzb3IgKSA9PT0gZmFsc2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Z2wuc2Npc3Nvciggc2Npc3Nvci54LCBzY2lzc29yLnksIHNjaXNzb3Iueiwgc2Npc3Nvci53ICk7XFxyXFxuXFx0XFx0XFx0XFx0Y3VycmVudFNjaXNzb3IuY29weSggc2Npc3NvciApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gdmlld3BvcnQoIHZpZXdwb3J0ICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggY3VycmVudFZpZXdwb3J0LmVxdWFscyggdmlld3BvcnQgKSA9PT0gZmFsc2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Z2wudmlld3BvcnQoIHZpZXdwb3J0LngsIHZpZXdwb3J0LnksIHZpZXdwb3J0LnosIHZpZXdwb3J0LncgKTtcXHJcXG5cXHRcXHRcXHRcXHRjdXJyZW50Vmlld3BvcnQuY29weSggdmlld3BvcnQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdC8vXFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gcmVzZXQoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZW5hYmxlZEF0dHJpYnV0ZXMubGVuZ3RoOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggZW5hYmxlZEF0dHJpYnV0ZXNbIGkgXSA9PT0gMSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoIGkgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRlbmFibGVkQXR0cmlidXRlc1sgaSBdID0gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGNhcGFiaWxpdGllcyA9IHt9O1xcclxcblxcclxcblxcdFxcdFxcdGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y3VycmVudFRleHR1cmVTbG90ID0gbnVsbDtcXHJcXG5cXHRcXHRcXHRjdXJyZW50Qm91bmRUZXh0dXJlcyA9IHt9O1xcclxcblxcclxcblxcdFxcdFxcdGN1cnJlbnRQcm9ncmFtID0gbnVsbDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjdXJyZW50QmxlbmRpbmcgPSBudWxsO1xcclxcblxcclxcblxcdFxcdFxcdGN1cnJlbnRGbGlwU2lkZWQgPSBudWxsO1xcclxcblxcdFxcdFxcdGN1cnJlbnRDdWxsRmFjZSA9IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29sb3JCdWZmZXIucmVzZXQoKTtcXHJcXG5cXHRcXHRcXHRkZXB0aEJ1ZmZlci5yZXNldCgpO1xcclxcblxcdFxcdFxcdHN0ZW5jaWxCdWZmZXIucmVzZXQoKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRidWZmZXJzOiB7XFxyXFxuXFx0XFx0XFx0XFx0Y29sb3I6IGNvbG9yQnVmZmVyLFxcclxcblxcdFxcdFxcdFxcdGRlcHRoOiBkZXB0aEJ1ZmZlcixcXHJcXG5cXHRcXHRcXHRcXHRzdGVuY2lsOiBzdGVuY2lsQnVmZmVyXFxyXFxuXFx0XFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRpbml0QXR0cmlidXRlczogaW5pdEF0dHJpYnV0ZXMsXFxyXFxuXFx0XFx0XFx0ZW5hYmxlQXR0cmlidXRlOiBlbmFibGVBdHRyaWJ1dGUsXFxyXFxuXFx0XFx0XFx0ZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvcjogZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvcixcXHJcXG5cXHRcXHRcXHRkaXNhYmxlVW51c2VkQXR0cmlidXRlczogZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMsXFxyXFxuXFx0XFx0XFx0ZW5hYmxlOiBlbmFibGUsXFxyXFxuXFx0XFx0XFx0ZGlzYWJsZTogZGlzYWJsZSxcXHJcXG5cXHRcXHRcXHRnZXRDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHM6IGdldENvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyxcXHJcXG5cXHJcXG5cXHRcXHRcXHR1c2VQcm9ncmFtOiB1c2VQcm9ncmFtLFxcclxcblxcclxcblxcdFxcdFxcdHNldEJsZW5kaW5nOiBzZXRCbGVuZGluZyxcXHJcXG5cXHRcXHRcXHRzZXRNYXRlcmlhbDogc2V0TWF0ZXJpYWwsXFxyXFxuXFxyXFxuXFx0XFx0XFx0c2V0RmxpcFNpZGVkOiBzZXRGbGlwU2lkZWQsXFxyXFxuXFx0XFx0XFx0c2V0Q3VsbEZhY2U6IHNldEN1bGxGYWNlLFxcclxcblxcclxcblxcdFxcdFxcdHNldExpbmVXaWR0aDogc2V0TGluZVdpZHRoLFxcclxcblxcdFxcdFxcdHNldFBvbHlnb25PZmZzZXQ6IHNldFBvbHlnb25PZmZzZXQsXFxyXFxuXFxyXFxuXFx0XFx0XFx0c2V0U2Npc3NvclRlc3Q6IHNldFNjaXNzb3JUZXN0LFxcclxcblxcclxcblxcdFxcdFxcdGFjdGl2ZVRleHR1cmU6IGFjdGl2ZVRleHR1cmUsXFxyXFxuXFx0XFx0XFx0YmluZFRleHR1cmU6IGJpbmRUZXh0dXJlLFxcclxcblxcdFxcdFxcdGNvbXByZXNzZWRUZXhJbWFnZTJEOiBjb21wcmVzc2VkVGV4SW1hZ2UyRCxcXHJcXG5cXHRcXHRcXHR0ZXhJbWFnZTJEOiB0ZXhJbWFnZTJELFxcclxcblxcclxcblxcdFxcdFxcdHNjaXNzb3I6IHNjaXNzb3IsXFxyXFxuXFx0XFx0XFx0dmlld3BvcnQ6IHZpZXdwb3J0LFxcclxcblxcclxcblxcdFxcdFxcdHJlc2V0OiByZXNldFxcclxcblxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gV2ViR0xDYXBhYmlsaXRpZXMoIGdsLCBleHRlbnNpb25zLCBwYXJhbWV0ZXJzICkge1xcclxcblxcclxcblxcdFxcdHZhciBtYXhBbmlzb3Ryb3B5O1xcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIGdldE1heEFuaXNvdHJvcHkoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBtYXhBbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgKSByZXR1cm4gbWF4QW5pc290cm9weTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bWF4QW5pc290cm9weSA9IGdsLmdldFBhcmFtZXRlciggZXh0ZW5zaW9uLk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCApO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bWF4QW5pc290cm9weSA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBtYXhBbmlzb3Ryb3B5O1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBnZXRNYXhQcmVjaXNpb24oIHByZWNpc2lvbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHByZWNpc2lvbiA9PT0gJ2hpZ2hwJyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuVkVSVEVYX1NIQURFUiwgZ2wuSElHSF9GTE9BVCApLnByZWNpc2lvbiA+IDAgJiZcXHJcXG5cXHRcXHRcXHRcXHQgICAgIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5ISUdIX0ZMT0FUICkucHJlY2lzaW9uID4gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gJ2hpZ2hwJztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cHJlY2lzaW9uID0gJ21lZGl1bXAnO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHByZWNpc2lvbiA9PT0gJ21lZGl1bXAnICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBnbC5WRVJURVhfU0hBREVSLCBnbC5NRURJVU1fRkxPQVQgKS5wcmVjaXNpb24gPiAwICYmXFxyXFxuXFx0XFx0XFx0XFx0ICAgICBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTUVESVVNX0ZMT0FUICkucHJlY2lzaW9uID4gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gJ21lZGl1bXAnO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuICdsb3dwJztcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHByZWNpc2lvbiA9IHBhcmFtZXRlcnMucHJlY2lzaW9uICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnByZWNpc2lvbiA6ICdoaWdocCc7XFxyXFxuXFx0XFx0dmFyIG1heFByZWNpc2lvbiA9IGdldE1heFByZWNpc2lvbiggcHJlY2lzaW9uICk7XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCBtYXhQcmVjaXNpb24gIT09IHByZWNpc2lvbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOicsIHByZWNpc2lvbiwgJ25vdCBzdXBwb3J0ZWQsIHVzaW5nJywgbWF4UHJlY2lzaW9uLCAnaW5zdGVhZC4nICk7XFxyXFxuXFx0XFx0XFx0cHJlY2lzaW9uID0gbWF4UHJlY2lzaW9uO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR2YXIgbG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA9IHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA9PT0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgbWF4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTICk7XFxyXFxuXFx0XFx0dmFyIG1heFZlcnRleFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcXHJcXG5cXHRcXHR2YXIgbWF4VGV4dHVyZVNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9URVhUVVJFX1NJWkUgKTtcXHJcXG5cXHRcXHR2YXIgbWF4Q3ViZW1hcFNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9DVUJFX01BUF9URVhUVVJFX1NJWkUgKTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgbWF4QXR0cmlidXRlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9BVFRSSUJTICk7XFxyXFxuXFx0XFx0dmFyIG1heFZlcnRleFVuaWZvcm1zID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkVSVEVYX1VOSUZPUk1fVkVDVE9SUyApO1xcclxcblxcdFxcdHZhciBtYXhWYXJ5aW5ncyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZBUllJTkdfVkVDVE9SUyApO1xcclxcblxcdFxcdHZhciBtYXhGcmFnbWVudFVuaWZvcm1zID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfRlJBR01FTlRfVU5JRk9STV9WRUNUT1JTICk7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHZlcnRleFRleHR1cmVzID0gbWF4VmVydGV4VGV4dHVyZXMgPiAwO1xcclxcblxcdFxcdHZhciBmbG9hdEZyYWdtZW50VGV4dHVyZXMgPSAhISBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xcclxcblxcdFxcdHZhciBmbG9hdFZlcnRleFRleHR1cmVzID0gdmVydGV4VGV4dHVyZXMgJiYgZmxvYXRGcmFnbWVudFRleHR1cmVzO1xcclxcblxcclxcblxcdFxcdHJldHVybiB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Z2V0TWF4QW5pc290cm9weTogZ2V0TWF4QW5pc290cm9weSxcXHJcXG5cXHRcXHRcXHRnZXRNYXhQcmVjaXNpb246IGdldE1heFByZWNpc2lvbixcXHJcXG5cXHJcXG5cXHRcXHRcXHRwcmVjaXNpb246IHByZWNpc2lvbixcXHJcXG5cXHRcXHRcXHRsb2dhcml0aG1pY0RlcHRoQnVmZmVyOiBsb2dhcml0aG1pY0RlcHRoQnVmZmVyLFxcclxcblxcclxcblxcdFxcdFxcdG1heFRleHR1cmVzOiBtYXhUZXh0dXJlcyxcXHJcXG5cXHRcXHRcXHRtYXhWZXJ0ZXhUZXh0dXJlczogbWF4VmVydGV4VGV4dHVyZXMsXFxyXFxuXFx0XFx0XFx0bWF4VGV4dHVyZVNpemU6IG1heFRleHR1cmVTaXplLFxcclxcblxcdFxcdFxcdG1heEN1YmVtYXBTaXplOiBtYXhDdWJlbWFwU2l6ZSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRtYXhBdHRyaWJ1dGVzOiBtYXhBdHRyaWJ1dGVzLFxcclxcblxcdFxcdFxcdG1heFZlcnRleFVuaWZvcm1zOiBtYXhWZXJ0ZXhVbmlmb3JtcyxcXHJcXG5cXHRcXHRcXHRtYXhWYXJ5aW5nczogbWF4VmFyeWluZ3MsXFxyXFxuXFx0XFx0XFx0bWF4RnJhZ21lbnRVbmlmb3JtczogbWF4RnJhZ21lbnRVbmlmb3JtcyxcXHJcXG5cXHJcXG5cXHRcXHRcXHR2ZXJ0ZXhUZXh0dXJlczogdmVydGV4VGV4dHVyZXMsXFxyXFxuXFx0XFx0XFx0ZmxvYXRGcmFnbWVudFRleHR1cmVzOiBmbG9hdEZyYWdtZW50VGV4dHVyZXMsXFxyXFxuXFx0XFx0XFx0ZmxvYXRWZXJ0ZXhUZXh0dXJlczogZmxvYXRWZXJ0ZXhUZXh0dXJlc1xcclxcblxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICogQGF1dGhvciBncmVnZ21hbiAvIGh0dHA6Ly9nYW1lcy5ncmVnZ21hbi5jb20vXFxyXFxuXFx0ICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xcclxcblxcdCAqIEBhdXRob3IgdHNjaHdcXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApIHtcXHJcXG5cXHJcXG5cXHRcXHRDYW1lcmEuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdQZXJzcGVjdGl2ZUNhbWVyYSc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5mb3YgPSBmb3YgIT09IHVuZGVmaW5lZCA/IGZvdiA6IDUwO1xcclxcblxcdFxcdHRoaXMuem9vbSA9IDE7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5uZWFyID0gbmVhciAhPT0gdW5kZWZpbmVkID8gbmVhciA6IDAuMTtcXHJcXG5cXHRcXHR0aGlzLmZhciA9IGZhciAhPT0gdW5kZWZpbmVkID8gZmFyIDogMjAwMDtcXHJcXG5cXHRcXHR0aGlzLmZvY3VzID0gMTA7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5hc3BlY3QgPSBhc3BlY3QgIT09IHVuZGVmaW5lZCA/IGFzcGVjdCA6IDE7XFxyXFxuXFx0XFx0dGhpcy52aWV3ID0gbnVsbDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmZpbG1HYXVnZSA9IDM1O1xcdC8vIHdpZHRoIG9mIHRoZSBmaWxtIChkZWZhdWx0IGluIG1pbGxpbWV0ZXJzKVxcclxcblxcdFxcdHRoaXMuZmlsbU9mZnNldCA9IDA7XFx0Ly8gaG9yaXpvbnRhbCBmaWxtIG9mZnNldCAoc2FtZSB1bml0IGFzIGdhdWdlKVxcclxcblxcclxcblxcdFxcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRQZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBDYW1lcmEucHJvdG90eXBlICksIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zdHJ1Y3RvcjogUGVyc3BlY3RpdmVDYW1lcmEsXFxyXFxuXFxyXFxuXFx0XFx0aXNQZXJzcGVjdGl2ZUNhbWVyYTogdHJ1ZSxcXHJcXG5cXHJcXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xcclxcblxcclxcblxcdFxcdFxcdENhbWVyYS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuZm92ID0gc291cmNlLmZvdjtcXHJcXG5cXHRcXHRcXHR0aGlzLnpvb20gPSBzb3VyY2Uuem9vbTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm5lYXIgPSBzb3VyY2UubmVhcjtcXHJcXG5cXHRcXHRcXHR0aGlzLmZhciA9IHNvdXJjZS5mYXI7XFxyXFxuXFx0XFx0XFx0dGhpcy5mb2N1cyA9IHNvdXJjZS5mb2N1cztcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmFzcGVjdCA9IHNvdXJjZS5hc3BlY3Q7XFxyXFxuXFx0XFx0XFx0dGhpcy52aWV3ID0gc291cmNlLnZpZXcgPT09IG51bGwgPyBudWxsIDogT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS52aWV3ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5maWxtR2F1Z2UgPSBzb3VyY2UuZmlsbUdhdWdlO1xcclxcblxcdFxcdFxcdHRoaXMuZmlsbU9mZnNldCA9IHNvdXJjZS5maWxtT2Zmc2V0O1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0LyoqXFxyXFxuXFx0XFx0ICogU2V0cyB0aGUgRk9WIGJ5IGZvY2FsIGxlbmd0aCBpbiByZXNwZWN0IHRvIHRoZSBjdXJyZW50IC5maWxtR2F1Z2UuXFxyXFxuXFx0XFx0ICpcXHJcXG5cXHRcXHQgKiBUaGUgZGVmYXVsdCBmaWxtIGdhdWdlIGlzIDM1LCBzbyB0aGF0IHRoZSBmb2NhbCBsZW5ndGggY2FuIGJlIHNwZWNpZmllZCBmb3JcXHJcXG5cXHRcXHQgKiBhIDM1bW0gKGZ1bGwgZnJhbWUpIGNhbWVyYS5cXHJcXG5cXHRcXHQgKlxcclxcblxcdFxcdCAqIFZhbHVlcyBmb3IgZm9jYWwgbGVuZ3RoIGFuZCBmaWxtIGdhdWdlIG11c3QgaGF2ZSB0aGUgc2FtZSB1bml0LlxcclxcblxcdFxcdCAqL1xcclxcblxcdFxcdHNldEZvY2FsTGVuZ3RoOiBmdW5jdGlvbiAoIGZvY2FsTGVuZ3RoICkge1xcclxcblxcclxcblxcdFxcdFxcdC8vIHNlZSBodHRwOi8vd3d3LmJvYmF0a2lucy5jb20vcGhvdG9ncmFwaHkvdGVjaG5pY2FsL2ZpZWxkX29mX3ZpZXcuaHRtbFxcclxcblxcdFxcdFxcdHZhciB2RXh0ZW50U2xvcGUgPSAwLjUgKiB0aGlzLmdldEZpbG1IZWlnaHQoKSAvIGZvY2FsTGVuZ3RoO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuZm92ID0gX01hdGguUkFEMkRFRyAqIDIgKiBNYXRoLmF0YW4oIHZFeHRlbnRTbG9wZSApO1xcclxcblxcdFxcdFxcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0LyoqXFxyXFxuXFx0XFx0ICogQ2FsY3VsYXRlcyB0aGUgZm9jYWwgbGVuZ3RoIGZyb20gdGhlIGN1cnJlbnQgLmZvdiBhbmQgLmZpbG1HYXVnZS5cXHJcXG5cXHRcXHQgKi9cXHJcXG5cXHRcXHRnZXRGb2NhbExlbmd0aDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB2RXh0ZW50U2xvcGUgPSBNYXRoLnRhbiggX01hdGguREVHMlJBRCAqIDAuNSAqIHRoaXMuZm92ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIDAuNSAqIHRoaXMuZ2V0RmlsbUhlaWdodCgpIC8gdkV4dGVudFNsb3BlO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Z2V0RWZmZWN0aXZlRk9WOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIF9NYXRoLlJBRDJERUcgKiAyICogTWF0aC5hdGFuKFxcclxcblxcdFxcdFxcdFxcdE1hdGgudGFuKCBfTWF0aC5ERUcyUkFEICogMC41ICogdGhpcy5mb3YgKSAvIHRoaXMuem9vbSApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Z2V0RmlsbVdpZHRoOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gZmlsbSBub3QgY29tcGxldGVseSBjb3ZlcmVkIGluIHBvcnRyYWl0IGZvcm1hdCAoYXNwZWN0IDwgMSlcXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5maWxtR2F1Z2UgKiBNYXRoLm1pbiggdGhpcy5hc3BlY3QsIDEgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGdldEZpbG1IZWlnaHQ6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBmaWxtIG5vdCBjb21wbGV0ZWx5IGNvdmVyZWQgaW4gbGFuZHNjYXBlIGZvcm1hdCAoYXNwZWN0ID4gMSlcXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5maWxtR2F1Z2UgLyBNYXRoLm1heCggdGhpcy5hc3BlY3QsIDEgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdC8qKlxcclxcblxcdFxcdCAqIFNldHMgYW4gb2Zmc2V0IGluIGEgbGFyZ2VyIGZydXN0dW0uIFRoaXMgaXMgdXNlZnVsIGZvciBtdWx0aS13aW5kb3cgb3JcXHJcXG5cXHRcXHQgKiBtdWx0aS1tb25pdG9yL211bHRpLW1hY2hpbmUgc2V0dXBzLlxcclxcblxcdFxcdCAqXFxyXFxuXFx0XFx0ICogRm9yIGV4YW1wbGUsIGlmIHlvdSBoYXZlIDN4MiBtb25pdG9ycyBhbmQgZWFjaCBtb25pdG9yIGlzIDE5MjB4MTA4MCBhbmRcXHJcXG5cXHRcXHQgKiB0aGUgbW9uaXRvcnMgYXJlIGluIGdyaWQgbGlrZSB0aGlzXFxyXFxuXFx0XFx0ICpcXHJcXG5cXHRcXHQgKiAgICstLS0rLS0tKy0tLStcXHJcXG5cXHRcXHQgKiAgIHwgQSB8IEIgfCBDIHxcXHJcXG5cXHRcXHQgKiAgICstLS0rLS0tKy0tLStcXHJcXG5cXHRcXHQgKiAgIHwgRCB8IEUgfCBGIHxcXHJcXG5cXHRcXHQgKiAgICstLS0rLS0tKy0tLStcXHJcXG5cXHRcXHQgKlxcclxcblxcdFxcdCAqIHRoZW4gZm9yIGVhY2ggbW9uaXRvciB5b3Ugd291bGQgY2FsbCBpdCBsaWtlIHRoaXNcXHJcXG5cXHRcXHQgKlxcclxcblxcdFxcdCAqICAgdmFyIHcgPSAxOTIwO1xcclxcblxcdFxcdCAqICAgdmFyIGggPSAxMDgwO1xcclxcblxcdFxcdCAqICAgdmFyIGZ1bGxXaWR0aCA9IHcgKiAzO1xcclxcblxcdFxcdCAqICAgdmFyIGZ1bGxIZWlnaHQgPSBoICogMjtcXHJcXG5cXHRcXHQgKlxcclxcblxcdFxcdCAqICAgLS1BLS1cXHJcXG5cXHRcXHQgKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDAsIGggKiAwLCB3LCBoICk7XFxyXFxuXFx0XFx0ICogICAtLUItLVxcclxcblxcdFxcdCAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMSwgaCAqIDAsIHcsIGggKTtcXHJcXG5cXHRcXHQgKiAgIC0tQy0tXFxyXFxuXFx0XFx0ICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAyLCBoICogMCwgdywgaCApO1xcclxcblxcdFxcdCAqICAgLS1ELS1cXHJcXG5cXHRcXHQgKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDAsIGggKiAxLCB3LCBoICk7XFxyXFxuXFx0XFx0ICogICAtLUUtLVxcclxcblxcdFxcdCAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMSwgaCAqIDEsIHcsIGggKTtcXHJcXG5cXHRcXHQgKiAgIC0tRi0tXFxyXFxuXFx0XFx0ICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAyLCBoICogMSwgdywgaCApO1xcclxcblxcdFxcdCAqXFxyXFxuXFx0XFx0ICogICBOb3RlIHRoZXJlIGlzIG5vIHJlYXNvbiBtb25pdG9ycyBoYXZlIHRvIGJlIHRoZSBzYW1lIHNpemUgb3IgaW4gYSBncmlkLlxcclxcblxcdFxcdCAqL1xcclxcblxcdFxcdHNldFZpZXdPZmZzZXQ6IGZ1bmN0aW9uICggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuYXNwZWN0ID0gZnVsbFdpZHRoIC8gZnVsbEhlaWdodDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMudmlldyA9PT0gbnVsbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnZpZXcgPSB7XFxyXFxuXFx0XFx0XFx0XFx0XFx0ZW5hYmxlZDogdHJ1ZSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRmdWxsV2lkdGg6IDEsXFxyXFxuXFx0XFx0XFx0XFx0XFx0ZnVsbEhlaWdodDogMSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRvZmZzZXRYOiAwLFxcclxcblxcdFxcdFxcdFxcdFxcdG9mZnNldFk6IDAsXFxyXFxuXFx0XFx0XFx0XFx0XFx0d2lkdGg6IDEsXFxyXFxuXFx0XFx0XFx0XFx0XFx0aGVpZ2h0OiAxXFxyXFxuXFx0XFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy52aWV3LmVuYWJsZWQgPSB0cnVlO1xcclxcblxcdFxcdFxcdHRoaXMudmlldy5mdWxsV2lkdGggPSBmdWxsV2lkdGg7XFxyXFxuXFx0XFx0XFx0dGhpcy52aWV3LmZ1bGxIZWlnaHQgPSBmdWxsSGVpZ2h0O1xcclxcblxcdFxcdFxcdHRoaXMudmlldy5vZmZzZXRYID0geDtcXHJcXG5cXHRcXHRcXHR0aGlzLnZpZXcub2Zmc2V0WSA9IHk7XFxyXFxuXFx0XFx0XFx0dGhpcy52aWV3LndpZHRoID0gd2lkdGg7XFxyXFxuXFx0XFx0XFx0dGhpcy52aWV3LmhlaWdodCA9IGhlaWdodDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNsZWFyVmlld09mZnNldDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy52aWV3ICE9PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMudmlldy5lbmFibGVkID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0dXBkYXRlUHJvamVjdGlvbk1hdHJpeDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBuZWFyID0gdGhpcy5uZWFyLFxcclxcblxcdFxcdFxcdFxcdHRvcCA9IG5lYXIgKiBNYXRoLnRhbihcXHJcXG5cXHRcXHRcXHRcXHRcXHRfTWF0aC5ERUcyUkFEICogMC41ICogdGhpcy5mb3YgKSAvIHRoaXMuem9vbSxcXHJcXG5cXHRcXHRcXHRcXHRoZWlnaHQgPSAyICogdG9wLFxcclxcblxcdFxcdFxcdFxcdHdpZHRoID0gdGhpcy5hc3BlY3QgKiBoZWlnaHQsXFxyXFxuXFx0XFx0XFx0XFx0bGVmdCA9IC0gMC41ICogd2lkdGgsXFxyXFxuXFx0XFx0XFx0XFx0dmlldyA9IHRoaXMudmlldztcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMudmlldyAhPT0gbnVsbCAmJiB0aGlzLnZpZXcuZW5hYmxlZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgZnVsbFdpZHRoID0gdmlldy5mdWxsV2lkdGgsXFxyXFxuXFx0XFx0XFx0XFx0XFx0ZnVsbEhlaWdodCA9IHZpZXcuZnVsbEhlaWdodDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRsZWZ0ICs9IHZpZXcub2Zmc2V0WCAqIHdpZHRoIC8gZnVsbFdpZHRoO1xcclxcblxcdFxcdFxcdFxcdHRvcCAtPSB2aWV3Lm9mZnNldFkgKiBoZWlnaHQgLyBmdWxsSGVpZ2h0O1xcclxcblxcdFxcdFxcdFxcdHdpZHRoICo9IHZpZXcud2lkdGggLyBmdWxsV2lkdGg7XFxyXFxuXFx0XFx0XFx0XFx0aGVpZ2h0ICo9IHZpZXcuaGVpZ2h0IC8gZnVsbEhlaWdodDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHNrZXcgPSB0aGlzLmZpbG1PZmZzZXQ7XFxyXFxuXFx0XFx0XFx0aWYgKCBza2V3ICE9PSAwICkgbGVmdCArPSBuZWFyICogc2tldyAvIHRoaXMuZ2V0RmlsbVdpZHRoKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VQZXJzcGVjdGl2ZSggbGVmdCwgbGVmdCArIHdpZHRoLCB0b3AsIHRvcCAtIGhlaWdodCwgbmVhciwgdGhpcy5mYXIgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBkYXRhID0gT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZGF0YS5vYmplY3QuZm92ID0gdGhpcy5mb3Y7XFxyXFxuXFx0XFx0XFx0ZGF0YS5vYmplY3Quem9vbSA9IHRoaXMuem9vbTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRkYXRhLm9iamVjdC5uZWFyID0gdGhpcy5uZWFyO1xcclxcblxcdFxcdFxcdGRhdGEub2JqZWN0LmZhciA9IHRoaXMuZmFyO1xcclxcblxcdFxcdFxcdGRhdGEub2JqZWN0LmZvY3VzID0gdGhpcy5mb2N1cztcXHJcXG5cXHJcXG5cXHRcXHRcXHRkYXRhLm9iamVjdC5hc3BlY3QgPSB0aGlzLmFzcGVjdDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMudmlldyAhPT0gbnVsbCApIGRhdGEub2JqZWN0LnZpZXcgPSBPYmplY3QuYXNzaWduKCB7fSwgdGhpcy52aWV3ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZGF0YS5vYmplY3QuZmlsbUdhdWdlID0gdGhpcy5maWxtR2F1Z2U7XFxyXFxuXFx0XFx0XFx0ZGF0YS5vYmplY3QuZmlsbU9mZnNldCA9IHRoaXMuZmlsbU9mZnNldDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZGF0YTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gQXJyYXlDYW1lcmEoIGFycmF5ICkge1xcclxcblxcclxcblxcdFxcdFBlcnNwZWN0aXZlQ2FtZXJhLmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmNhbWVyYXMgPSBhcnJheSB8fCBbXTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0QXJyYXlDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlICksIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zdHJ1Y3RvcjogQXJyYXlDYW1lcmEsXFxyXFxuXFxyXFxuXFx0XFx0aXNBcnJheUNhbWVyYTogdHJ1ZVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIFdlYlZSTWFuYWdlciggcmVuZGVyZXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHNjb3BlID0gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR2YXIgZGV2aWNlID0gbnVsbDtcXHJcXG5cXHRcXHR2YXIgZnJhbWVEYXRhID0gbnVsbDtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgcG9zZVRhcmdldCA9IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAnVlJGcmFtZURhdGEnIGluIHdpbmRvdyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmcmFtZURhdGEgPSBuZXcgd2luZG93LlZSRnJhbWVEYXRhKCk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHZhciBtYXRyaXhXb3JsZEludmVyc2UgPSBuZXcgTWF0cml4NCgpO1xcclxcblxcclxcblxcdFxcdHZhciBjYW1lcmFMID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCk7XFxyXFxuXFx0XFx0Y2FtZXJhTC5ib3VuZHMgPSBuZXcgVmVjdG9yNCggMC4wLCAwLjAsIDAuNSwgMS4wICk7XFxyXFxuXFx0XFx0Y2FtZXJhTC5sYXllcnMuZW5hYmxlKCAxICk7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGNhbWVyYVIgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKTtcXHJcXG5cXHRcXHRjYW1lcmFSLmJvdW5kcyA9IG5ldyBWZWN0b3I0KCAwLjUsIDAuMCwgMC41LCAxLjAgKTtcXHJcXG5cXHRcXHRjYW1lcmFSLmxheWVycy5lbmFibGUoIDIgKTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgY2FtZXJhVlIgPSBuZXcgQXJyYXlDYW1lcmEoIFsgY2FtZXJhTCwgY2FtZXJhUiBdICk7XFxyXFxuXFx0XFx0Y2FtZXJhVlIubGF5ZXJzLmVuYWJsZSggMSApO1xcclxcblxcdFxcdGNhbWVyYVZSLmxheWVycy5lbmFibGUoIDIgKTtcXHJcXG5cXHJcXG5cXHRcXHQvL1xcclxcblxcclxcblxcdFxcdHZhciBjdXJyZW50U2l6ZSwgY3VycmVudFBpeGVsUmF0aW87XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gb25WUkRpc3BsYXlQcmVzZW50Q2hhbmdlKCkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggZGV2aWNlICE9PSBudWxsICYmIGRldmljZS5pc1ByZXNlbnRpbmcgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGV5ZVBhcmFtZXRlcnMgPSBkZXZpY2UuZ2V0RXllUGFyYW1ldGVycyggJ2xlZnQnICk7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIHJlbmRlcldpZHRoID0gZXllUGFyYW1ldGVycy5yZW5kZXJXaWR0aDtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgcmVuZGVySGVpZ2h0ID0gZXllUGFyYW1ldGVycy5yZW5kZXJIZWlnaHQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y3VycmVudFBpeGVsUmF0aW8gPSByZW5kZXJlci5nZXRQaXhlbFJhdGlvKCk7XFxyXFxuXFx0XFx0XFx0XFx0Y3VycmVudFNpemUgPSByZW5kZXJlci5nZXRTaXplKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmVuZGVyZXIuc2V0RHJhd2luZ0J1ZmZlclNpemUoIHJlbmRlcldpZHRoICogMiwgcmVuZGVySGVpZ2h0LCAxICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggc2NvcGUuZW5hYmxlZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZW5kZXJlci5zZXREcmF3aW5nQnVmZmVyU2l6ZSggY3VycmVudFNpemUud2lkdGgsIGN1cnJlbnRTaXplLmhlaWdodCwgY3VycmVudFBpeGVsUmF0aW8gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGlmICggdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICd2cmRpc3BsYXlwcmVzZW50Y2hhbmdlJywgb25WUkRpc3BsYXlQcmVzZW50Q2hhbmdlLCBmYWxzZSApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHQvL1xcclxcblxcclxcblxcdFxcdHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdHRoaXMuZ2V0RGV2aWNlID0gZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBkZXZpY2U7XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnNldERldmljZSA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkgZGV2aWNlID0gdmFsdWU7XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnNldFBvc2VUYXJnZXQgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICkgcG9zZVRhcmdldCA9IG9iamVjdDtcXHJcXG5cXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdFxcdHRoaXMuZ2V0Q2FtZXJhID0gZnVuY3Rpb24gKCBjYW1lcmEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBkZXZpY2UgPT09IG51bGwgKSByZXR1cm4gY2FtZXJhO1xcclxcblxcclxcblxcdFxcdFxcdGRldmljZS5kZXB0aE5lYXIgPSBjYW1lcmEubmVhcjtcXHJcXG5cXHRcXHRcXHRkZXZpY2UuZGVwdGhGYXIgPSBjYW1lcmEuZmFyO1xcclxcblxcclxcblxcdFxcdFxcdGRldmljZS5nZXRGcmFtZURhdGEoIGZyYW1lRGF0YSApO1xcclxcblxcclxcblxcdFxcdFxcdC8vXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHBvc2UgPSBmcmFtZURhdGEucG9zZTtcXHJcXG5cXHRcXHRcXHR2YXIgcG9zZU9iamVjdCA9IHBvc2VUYXJnZXQgIT09IG51bGwgPyBwb3NlVGFyZ2V0IDogY2FtZXJhO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggcG9zZS5wb3NpdGlvbiAhPT0gbnVsbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRwb3NlT2JqZWN0LnBvc2l0aW9uLmZyb21BcnJheSggcG9zZS5wb3NpdGlvbiApO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cG9zZU9iamVjdC5wb3NpdGlvbi5zZXQoIDAsIDAsIDAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBwb3NlLm9yaWVudGF0aW9uICE9PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHBvc2VPYmplY3QucXVhdGVybmlvbi5mcm9tQXJyYXkoIHBvc2Uub3JpZW50YXRpb24gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cG9zZU9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCgpO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggZGV2aWNlLmlzUHJlc2VudGluZyA9PT0gZmFsc2UgKSByZXR1cm4gY2FtZXJhO1xcclxcblxcclxcblxcdFxcdFxcdC8vXFxyXFxuXFxyXFxuXFx0XFx0XFx0Y2FtZXJhTC5uZWFyID0gY2FtZXJhLm5lYXI7XFxyXFxuXFx0XFx0XFx0Y2FtZXJhUi5uZWFyID0gY2FtZXJhLm5lYXI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y2FtZXJhTC5mYXIgPSBjYW1lcmEuZmFyO1xcclxcblxcdFxcdFxcdGNhbWVyYVIuZmFyID0gY2FtZXJhLmZhcjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjYW1lcmFWUi5tYXRyaXhXb3JsZC5jb3B5KCBjYW1lcmEubWF0cml4V29ybGQgKTtcXHJcXG5cXHRcXHRcXHRjYW1lcmFWUi5tYXRyaXhXb3JsZEludmVyc2UuY29weSggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xcclxcblxcclxcblxcdFxcdFxcdGNhbWVyYUwubWF0cml4V29ybGRJbnZlcnNlLmZyb21BcnJheSggZnJhbWVEYXRhLmxlZnRWaWV3TWF0cml4ICk7XFxyXFxuXFx0XFx0XFx0Y2FtZXJhUi5tYXRyaXhXb3JsZEludmVyc2UuZnJvbUFycmF5KCBmcmFtZURhdGEucmlnaHRWaWV3TWF0cml4ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHBhcmVudCA9IHBvc2VPYmplY3QucGFyZW50O1xcclxcblxcclxcblxcdFxcdFxcdGlmICggcGFyZW50ICE9PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdG1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBwYXJlbnQubWF0cml4V29ybGQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjYW1lcmFMLm1hdHJpeFdvcmxkSW52ZXJzZS5tdWx0aXBseSggbWF0cml4V29ybGRJbnZlcnNlICk7XFxyXFxuXFx0XFx0XFx0XFx0Y2FtZXJhUi5tYXRyaXhXb3JsZEludmVyc2UubXVsdGlwbHkoIG1hdHJpeFdvcmxkSW52ZXJzZSApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBlbnZNYXAgYW5kIE1pcnJvciBuZWVkcyBjYW1lcmEubWF0cml4V29ybGRcXHJcXG5cXHJcXG5cXHRcXHRcXHRjYW1lcmFMLm1hdHJpeFdvcmxkLmdldEludmVyc2UoIGNhbWVyYUwubWF0cml4V29ybGRJbnZlcnNlICk7XFxyXFxuXFx0XFx0XFx0Y2FtZXJhUi5tYXRyaXhXb3JsZC5nZXRJbnZlcnNlKCBjYW1lcmFSLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xcclxcblxcclxcblxcdFxcdFxcdGNhbWVyYUwucHJvamVjdGlvbk1hdHJpeC5mcm9tQXJyYXkoIGZyYW1lRGF0YS5sZWZ0UHJvamVjdGlvbk1hdHJpeCApO1xcclxcblxcdFxcdFxcdGNhbWVyYVIucHJvamVjdGlvbk1hdHJpeC5mcm9tQXJyYXkoIGZyYW1lRGF0YS5yaWdodFByb2plY3Rpb25NYXRyaXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBIQUNLIEBtcmRvb2JcXHJcXG5cXHRcXHRcXHQvLyBodHRwczovL2dpdGh1Yi5jb20vdzNjL3dlYnZyL2lzc3Vlcy8yMDNcXHJcXG5cXHJcXG5cXHRcXHRcXHRjYW1lcmFWUi5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIGNhbWVyYUwucHJvamVjdGlvbk1hdHJpeCApO1xcclxcblxcclxcblxcdFxcdFxcdC8vXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGxheWVycyA9IGRldmljZS5nZXRMYXllcnMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGxheWVycy5sZW5ndGggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGxheWVyID0gbGF5ZXJzWyAwIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBsYXllci5sZWZ0Qm91bmRzICE9PSBudWxsICYmIGxheWVyLmxlZnRCb3VuZHMubGVuZ3RoID09PSA0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNhbWVyYUwuYm91bmRzLmZyb21BcnJheSggbGF5ZXIubGVmdEJvdW5kcyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGxheWVyLnJpZ2h0Qm91bmRzICE9PSBudWxsICYmIGxheWVyLnJpZ2h0Qm91bmRzLmxlbmd0aCA9PT0gNCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRjYW1lcmFSLmJvdW5kcy5mcm9tQXJyYXkoIGxheWVyLnJpZ2h0Qm91bmRzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gY2FtZXJhVlI7XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnN1Ym1pdEZyYW1lID0gZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggZGV2aWNlICYmIGRldmljZS5pc1ByZXNlbnRpbmcgKSBkZXZpY2Uuc3VibWl0RnJhbWUoKTtcXHJcXG5cXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdFxcdHRoaXMuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAndnJkaXNwbGF5cHJlc2VudGNoYW5nZScsIG9uVlJEaXNwbGF5UHJlc2VudENoYW5nZSApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIFdlYkdMRXh0ZW5zaW9ucyggZ2wgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGV4dGVuc2lvbnMgPSB7fTtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4ge1xcclxcblxcclxcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCBuYW1lICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggZXh0ZW5zaW9uc1sgbmFtZSBdICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGV4dGVuc2lvbnNbIG5hbWUgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGV4dGVuc2lvbjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzd2l0Y2ggKCBuYW1lICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ1dFQkdMX2RlcHRoX3RleHR1cmUnOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2RlcHRoX3RleHR1cmUnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnTU9aX1dFQkdMX2RlcHRoX3RleHR1cmUnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX1dFQkdMX2RlcHRoX3RleHR1cmUnICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnTU9aX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdNT1pfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Yyc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEnOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxJyApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGRlZmF1bHQ6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCBuYW1lICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6ICcgKyBuYW1lICsgJyBleHRlbnNpb24gbm90IHN1cHBvcnRlZC4nICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdGV4dGVuc2lvbnNbIG5hbWUgXSA9IGV4dGVuc2lvbjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZXh0ZW5zaW9uO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIHRzY2h3XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gV2ViR0xDbGlwcGluZygpIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgc2NvcGUgPSB0aGlzLFxcclxcblxcclxcblxcdFxcdFxcdGdsb2JhbFN0YXRlID0gbnVsbCxcXHJcXG5cXHRcXHRcXHRudW1HbG9iYWxQbGFuZXMgPSAwLFxcclxcblxcdFxcdFxcdGxvY2FsQ2xpcHBpbmdFbmFibGVkID0gZmFsc2UsXFxyXFxuXFx0XFx0XFx0cmVuZGVyaW5nU2hhZG93cyA9IGZhbHNlLFxcclxcblxcclxcblxcdFxcdFxcdHBsYW5lID0gbmV3IFBsYW5lKCksXFxyXFxuXFx0XFx0XFx0dmlld05vcm1hbE1hdHJpeCA9IG5ldyBNYXRyaXgzKCksXFxyXFxuXFxyXFxuXFx0XFx0XFx0dW5pZm9ybSA9IHsgdmFsdWU6IG51bGwsIG5lZWRzVXBkYXRlOiBmYWxzZSB9O1xcclxcblxcclxcblxcdFxcdHRoaXMudW5pZm9ybSA9IHVuaWZvcm07XFxyXFxuXFx0XFx0dGhpcy5udW1QbGFuZXMgPSAwO1xcclxcblxcdFxcdHRoaXMubnVtSW50ZXJzZWN0aW9uID0gMDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmluaXQgPSBmdW5jdGlvbiAoIHBsYW5lcywgZW5hYmxlTG9jYWxDbGlwcGluZywgY2FtZXJhICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBlbmFibGVkID1cXHJcXG5cXHRcXHRcXHRcXHRwbGFuZXMubGVuZ3RoICE9PSAwIHx8XFxyXFxuXFx0XFx0XFx0XFx0ZW5hYmxlTG9jYWxDbGlwcGluZyB8fFxcclxcblxcdFxcdFxcdFxcdC8vIGVuYWJsZSBzdGF0ZSBvZiBwcmV2aW91cyBmcmFtZSAtIHRoZSBjbGlwcGluZyBjb2RlIGhhcyB0b1xcclxcblxcdFxcdFxcdFxcdC8vIHJ1biBhbm90aGVyIGZyYW1lIGluIG9yZGVyIHRvIHJlc2V0IHRoZSBzdGF0ZTpcXHJcXG5cXHRcXHRcXHRcXHRudW1HbG9iYWxQbGFuZXMgIT09IDAgfHxcXHJcXG5cXHRcXHRcXHRcXHRsb2NhbENsaXBwaW5nRW5hYmxlZDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRsb2NhbENsaXBwaW5nRW5hYmxlZCA9IGVuYWJsZUxvY2FsQ2xpcHBpbmc7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Z2xvYmFsU3RhdGUgPSBwcm9qZWN0UGxhbmVzKCBwbGFuZXMsIGNhbWVyYSwgMCApO1xcclxcblxcdFxcdFxcdG51bUdsb2JhbFBsYW5lcyA9IHBsYW5lcy5sZW5ndGg7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGVuYWJsZWQ7XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmJlZ2luU2hhZG93cyA9IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZW5kZXJpbmdTaGFkb3dzID0gdHJ1ZTtcXHJcXG5cXHRcXHRcXHRwcm9qZWN0UGxhbmVzKCBudWxsICk7XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmVuZFNoYWRvd3MgPSBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmVuZGVyaW5nU2hhZG93cyA9IGZhbHNlO1xcclxcblxcdFxcdFxcdHJlc2V0R2xvYmFsU3RhdGUoKTtcXHJcXG5cXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdFxcdHRoaXMuc2V0U3RhdGUgPSBmdW5jdGlvbiAoIHBsYW5lcywgY2xpcEludGVyc2VjdGlvbiwgY2xpcFNoYWRvd3MsIGNhbWVyYSwgY2FjaGUsIGZyb21DYWNoZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoICEgbG9jYWxDbGlwcGluZ0VuYWJsZWQgfHwgcGxhbmVzID09PSBudWxsIHx8IHBsYW5lcy5sZW5ndGggPT09IDAgfHwgcmVuZGVyaW5nU2hhZG93cyAmJiAhIGNsaXBTaGFkb3dzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIHRoZXJlJ3Mgbm8gbG9jYWwgY2xpcHBpbmdcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHJlbmRlcmluZ1NoYWRvd3MgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdGhlcmUncyBubyBnbG9iYWwgY2xpcHBpbmdcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRwcm9qZWN0UGxhbmVzKCBudWxsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRyZXNldEdsb2JhbFN0YXRlKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIG5HbG9iYWwgPSByZW5kZXJpbmdTaGFkb3dzID8gMCA6IG51bUdsb2JhbFBsYW5lcyxcXHJcXG5cXHRcXHRcXHRcXHRcXHRsR2xvYmFsID0gbkdsb2JhbCAqIDQsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0ZHN0QXJyYXkgPSBjYWNoZS5jbGlwcGluZ1N0YXRlIHx8IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dW5pZm9ybS52YWx1ZSA9IGRzdEFycmF5OyAvLyBlbnN1cmUgdW5pcXVlIHN0YXRlXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZHN0QXJyYXkgPSBwcm9qZWN0UGxhbmVzKCBwbGFuZXMsIGNhbWVyYSwgbEdsb2JhbCwgZnJvbUNhY2hlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBsR2xvYmFsOyArKyBpICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGRzdEFycmF5WyBpIF0gPSBnbG9iYWxTdGF0ZVsgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjYWNoZS5jbGlwcGluZ1N0YXRlID0gZHN0QXJyYXk7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5udW1JbnRlcnNlY3Rpb24gPSBjbGlwSW50ZXJzZWN0aW9uID8gdGhpcy5udW1QbGFuZXMgOiAwO1xcclxcblxcdFxcdFxcdFxcdHRoaXMubnVtUGxhbmVzICs9IG5HbG9iYWw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gcmVzZXRHbG9iYWxTdGF0ZSgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHVuaWZvcm0udmFsdWUgIT09IGdsb2JhbFN0YXRlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHVuaWZvcm0udmFsdWUgPSBnbG9iYWxTdGF0ZTtcXHJcXG5cXHRcXHRcXHRcXHR1bmlmb3JtLm5lZWRzVXBkYXRlID0gbnVtR2xvYmFsUGxhbmVzID4gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0c2NvcGUubnVtUGxhbmVzID0gbnVtR2xvYmFsUGxhbmVzO1xcclxcblxcdFxcdFxcdHNjb3BlLm51bUludGVyc2VjdGlvbiA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIHByb2plY3RQbGFuZXMoIHBsYW5lcywgY2FtZXJhLCBkc3RPZmZzZXQsIHNraXBUcmFuc2Zvcm0gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG5QbGFuZXMgPSBwbGFuZXMgIT09IG51bGwgPyBwbGFuZXMubGVuZ3RoIDogMCxcXHJcXG5cXHRcXHRcXHRcXHRkc3RBcnJheSA9IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBuUGxhbmVzICE9PSAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGRzdEFycmF5ID0gdW5pZm9ybS52YWx1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHNraXBUcmFuc2Zvcm0gIT09IHRydWUgfHwgZHN0QXJyYXkgPT09IG51bGwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGZsYXRTaXplID0gZHN0T2Zmc2V0ICsgblBsYW5lcyAqIDQsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmlld01hdHJpeCA9IGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2U7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmlld05vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIHZpZXdNYXRyaXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGRzdEFycmF5ID09PSBudWxsIHx8IGRzdEFycmF5Lmxlbmd0aCA8IGZsYXRTaXplICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGRzdEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggZmxhdFNpemUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpNCA9IGRzdE9mZnNldDsgaSAhPT0gblBsYW5lczsgKysgaSwgaTQgKz0gNCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRwbGFuZS5jb3B5KCBwbGFuZXNbIGkgXSApLmFwcGx5TWF0cml4NCggdmlld01hdHJpeCwgdmlld05vcm1hbE1hdHJpeCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHBsYW5lLm5vcm1hbC50b0FycmF5KCBkc3RBcnJheSwgaTQgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRkc3RBcnJheVsgaTQgKyAzIF0gPSBwbGFuZS5jb25zdGFudDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHVuaWZvcm0udmFsdWUgPSBkc3RBcnJheTtcXHJcXG5cXHRcXHRcXHRcXHR1bmlmb3JtLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0c2NvcGUubnVtUGxhbmVzID0gblBsYW5lcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZHN0QXJyYXk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIHRoZXNwaXRlIC8gaHR0cDovL3d3dy50d2l0dGVyLmNvbS90aGVzcGl0ZVxcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIFdlYkdMVXRpbHMoIGdsLCBleHRlbnNpb25zICkge1xcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIGNvbnZlcnQoIHAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGV4dGVuc2lvbjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHAgPT09IFJlcGVhdFdyYXBwaW5nICkgcmV0dXJuIGdsLlJFUEVBVDtcXHJcXG5cXHRcXHRcXHRpZiAoIHAgPT09IENsYW1wVG9FZGdlV3JhcHBpbmcgKSByZXR1cm4gZ2wuQ0xBTVBfVE9fRURHRTtcXHJcXG5cXHRcXHRcXHRpZiAoIHAgPT09IE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcgKSByZXR1cm4gZ2wuTUlSUk9SRURfUkVQRUFUO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggcCA9PT0gTmVhcmVzdEZpbHRlciApIHJldHVybiBnbC5ORUFSRVNUO1xcclxcblxcdFxcdFxcdGlmICggcCA9PT0gTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgKSByZXR1cm4gZ2wuTkVBUkVTVF9NSVBNQVBfTkVBUkVTVDtcXHJcXG5cXHRcXHRcXHRpZiAoIHAgPT09IE5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIgKSByZXR1cm4gZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggcCA9PT0gTGluZWFyRmlsdGVyICkgcmV0dXJuIGdsLkxJTkVBUjtcXHJcXG5cXHRcXHRcXHRpZiAoIHAgPT09IExpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIgKSByZXR1cm4gZ2wuTElORUFSX01JUE1BUF9ORUFSRVNUO1xcclxcblxcdFxcdFxcdGlmICggcCA9PT0gTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyICkgcmV0dXJuIGdsLkxJTkVBUl9NSVBNQVBfTElORUFSO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggcCA9PT0gVW5zaWduZWRCeXRlVHlwZSApIHJldHVybiBnbC5VTlNJR05FRF9CWVRFO1xcclxcblxcdFxcdFxcdGlmICggcCA9PT0gVW5zaWduZWRTaG9ydDQ0NDRUeXBlICkgcmV0dXJuIGdsLlVOU0lHTkVEX1NIT1JUXzRfNF80XzQ7XFxyXFxuXFx0XFx0XFx0aWYgKCBwID09PSBVbnNpZ25lZFNob3J0NTU1MVR5cGUgKSByZXR1cm4gZ2wuVU5TSUdORURfU0hPUlRfNV81XzVfMTtcXHJcXG5cXHRcXHRcXHRpZiAoIHAgPT09IFVuc2lnbmVkU2hvcnQ1NjVUeXBlICkgcmV0dXJuIGdsLlVOU0lHTkVEX1NIT1JUXzVfNl81O1xcclxcblxcclxcblxcdFxcdFxcdGlmICggcCA9PT0gQnl0ZVR5cGUgKSByZXR1cm4gZ2wuQllURTtcXHJcXG5cXHRcXHRcXHRpZiAoIHAgPT09IFNob3J0VHlwZSApIHJldHVybiBnbC5TSE9SVDtcXHJcXG5cXHRcXHRcXHRpZiAoIHAgPT09IFVuc2lnbmVkU2hvcnRUeXBlICkgcmV0dXJuIGdsLlVOU0lHTkVEX1NIT1JUO1xcclxcblxcdFxcdFxcdGlmICggcCA9PT0gSW50VHlwZSApIHJldHVybiBnbC5JTlQ7XFxyXFxuXFx0XFx0XFx0aWYgKCBwID09PSBVbnNpZ25lZEludFR5cGUgKSByZXR1cm4gZ2wuVU5TSUdORURfSU5UO1xcclxcblxcdFxcdFxcdGlmICggcCA9PT0gRmxvYXRUeXBlICkgcmV0dXJuIGdsLkZMT0FUO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggcCA9PT0gSGFsZkZsb2F0VHlwZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSByZXR1cm4gZXh0ZW5zaW9uLkhBTEZfRkxPQVRfT0VTO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHAgPT09IEFscGhhRm9ybWF0ICkgcmV0dXJuIGdsLkFMUEhBO1xcclxcblxcdFxcdFxcdGlmICggcCA9PT0gUkdCRm9ybWF0ICkgcmV0dXJuIGdsLlJHQjtcXHJcXG5cXHRcXHRcXHRpZiAoIHAgPT09IFJHQkFGb3JtYXQgKSByZXR1cm4gZ2wuUkdCQTtcXHJcXG5cXHRcXHRcXHRpZiAoIHAgPT09IEx1bWluYW5jZUZvcm1hdCApIHJldHVybiBnbC5MVU1JTkFOQ0U7XFxyXFxuXFx0XFx0XFx0aWYgKCBwID09PSBMdW1pbmFuY2VBbHBoYUZvcm1hdCApIHJldHVybiBnbC5MVU1JTkFOQ0VfQUxQSEE7XFxyXFxuXFx0XFx0XFx0aWYgKCBwID09PSBEZXB0aEZvcm1hdCApIHJldHVybiBnbC5ERVBUSF9DT01QT05FTlQ7XFxyXFxuXFx0XFx0XFx0aWYgKCBwID09PSBEZXB0aFN0ZW5jaWxGb3JtYXQgKSByZXR1cm4gZ2wuREVQVEhfU1RFTkNJTDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHAgPT09IEFkZEVxdWF0aW9uICkgcmV0dXJuIGdsLkZVTkNfQUREO1xcclxcblxcdFxcdFxcdGlmICggcCA9PT0gU3VidHJhY3RFcXVhdGlvbiApIHJldHVybiBnbC5GVU5DX1NVQlRSQUNUO1xcclxcblxcdFxcdFxcdGlmICggcCA9PT0gUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24gKSByZXR1cm4gZ2wuRlVOQ19SRVZFUlNFX1NVQlRSQUNUO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggcCA9PT0gWmVyb0ZhY3RvciApIHJldHVybiBnbC5aRVJPO1xcclxcblxcdFxcdFxcdGlmICggcCA9PT0gT25lRmFjdG9yICkgcmV0dXJuIGdsLk9ORTtcXHJcXG5cXHRcXHRcXHRpZiAoIHAgPT09IFNyY0NvbG9yRmFjdG9yICkgcmV0dXJuIGdsLlNSQ19DT0xPUjtcXHJcXG5cXHRcXHRcXHRpZiAoIHAgPT09IE9uZU1pbnVzU3JjQ29sb3JGYWN0b3IgKSByZXR1cm4gZ2wuT05FX01JTlVTX1NSQ19DT0xPUjtcXHJcXG5cXHRcXHRcXHRpZiAoIHAgPT09IFNyY0FscGhhRmFjdG9yICkgcmV0dXJuIGdsLlNSQ19BTFBIQTtcXHJcXG5cXHRcXHRcXHRpZiAoIHAgPT09IE9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgKSByZXR1cm4gZ2wuT05FX01JTlVTX1NSQ19BTFBIQTtcXHJcXG5cXHRcXHRcXHRpZiAoIHAgPT09IERzdEFscGhhRmFjdG9yICkgcmV0dXJuIGdsLkRTVF9BTFBIQTtcXHJcXG5cXHRcXHRcXHRpZiAoIHAgPT09IE9uZU1pbnVzRHN0QWxwaGFGYWN0b3IgKSByZXR1cm4gZ2wuT05FX01JTlVTX0RTVF9BTFBIQTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHAgPT09IERzdENvbG9yRmFjdG9yICkgcmV0dXJuIGdsLkRTVF9DT0xPUjtcXHJcXG5cXHRcXHRcXHRpZiAoIHAgPT09IE9uZU1pbnVzRHN0Q29sb3JGYWN0b3IgKSByZXR1cm4gZ2wuT05FX01JTlVTX0RTVF9DT0xPUjtcXHJcXG5cXHRcXHRcXHRpZiAoIHAgPT09IFNyY0FscGhhU2F0dXJhdGVGYWN0b3IgKSByZXR1cm4gZ2wuU1JDX0FMUEhBX1NBVFVSQVRFO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggcCA9PT0gUkdCX1MzVENfRFhUMV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9TM1RDX0RYVDFfRm9ybWF0IHx8XFxyXFxuXFx0XFx0XFx0XFx0cCA9PT0gUkdCQV9TM1RDX0RYVDNfRm9ybWF0IHx8IHAgPT09IFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggcCA9PT0gUkdCX1MzVENfRFhUMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFQ7XFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBwID09PSBSR0JBX1MzVENfRFhUMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhUO1xcclxcblxcdFxcdFxcdFxcdFxcdGlmICggcCA9PT0gUkdCQV9TM1RDX0RYVDNfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHAgPT09IFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHAgPT09IFJHQl9QVlJUQ180QlBQVjFfRm9ybWF0IHx8IHAgPT09IFJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0IHx8XFxyXFxuXFx0XFx0XFx0XFx0cCA9PT0gUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0IHx8IHAgPT09IFJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHAgPT09IFJHQl9QVlJUQ180QlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9QVlJUQ180QlBQVjFfSU1HO1xcclxcblxcdFxcdFxcdFxcdFxcdGlmICggcCA9PT0gUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX1BWUlRDXzJCUFBWMV9JTUc7XFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBwID09PSBSR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9QVlJUQ180QlBQVjFfSU1HO1xcclxcblxcdFxcdFxcdFxcdFxcdGlmICggcCA9PT0gUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUFZSVENfMkJQUFYxX0lNRztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggcCA9PT0gUkdCX0VUQzFfRm9ybWF0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEnICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX0VUQzFfV0VCR0w7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggcCA9PT0gTWluRXF1YXRpb24gfHwgcCA9PT0gTWF4RXF1YXRpb24gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfYmxlbmRfbWlubWF4JyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggcCA9PT0gTWluRXF1YXRpb24gKSByZXR1cm4gZXh0ZW5zaW9uLk1JTl9FWFQ7XFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBwID09PSBNYXhFcXVhdGlvbiApIHJldHVybiBleHRlbnNpb24uTUFYX0VYVDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggcCA9PT0gVW5zaWduZWRJbnQyNDhUeXBlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfZGVwdGhfdGV4dHVyZScgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHJldHVybiBleHRlbnNpb24uVU5TSUdORURfSU5UXzI0XzhfV0VCR0w7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiAwO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4geyBjb252ZXJ0OiBjb252ZXJ0IH07XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3Igc3VwZXJlZ2diZXJ0IC8gaHR0cDovL3d3dy5wYXVsYnJ1bnQuY28udWsvXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcclxcblxcdCAqIEBhdXRob3Igc3ppbWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9cXHJcXG5cXHQgKiBAYXV0aG9yIHRzY2h3XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gV2ViR0xSZW5kZXJlciggcGFyYW1ldGVycyApIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zb2xlLmxvZyggJ1RIUkVFLldlYkdMUmVuZGVyZXInLCBSRVZJU0lPTiApO1xcclxcblxcclxcblxcdFxcdHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xcclxcblxcclxcblxcdFxcdHZhciBfY2FudmFzID0gcGFyYW1ldGVycy5jYW52YXMgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY2FudmFzIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsICdjYW52YXMnICksXFxyXFxuXFx0XFx0XFx0X2NvbnRleHQgPSBwYXJhbWV0ZXJzLmNvbnRleHQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY29udGV4dCA6IG51bGwsXFxyXFxuXFxyXFxuXFx0XFx0XFx0X2FscGhhID0gcGFyYW1ldGVycy5hbHBoYSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5hbHBoYSA6IGZhbHNlLFxcclxcblxcdFxcdFxcdF9kZXB0aCA9IHBhcmFtZXRlcnMuZGVwdGggIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuZGVwdGggOiB0cnVlLFxcclxcblxcdFxcdFxcdF9zdGVuY2lsID0gcGFyYW1ldGVycy5zdGVuY2lsICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnN0ZW5jaWwgOiB0cnVlLFxcclxcblxcdFxcdFxcdF9hbnRpYWxpYXMgPSBwYXJhbWV0ZXJzLmFudGlhbGlhcyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5hbnRpYWxpYXMgOiBmYWxzZSxcXHJcXG5cXHRcXHRcXHRfcHJlbXVsdGlwbGllZEFscGhhID0gcGFyYW1ldGVycy5wcmVtdWx0aXBsaWVkQWxwaGEgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucHJlbXVsdGlwbGllZEFscGhhIDogdHJ1ZSxcXHJcXG5cXHRcXHRcXHRfcHJlc2VydmVEcmF3aW5nQnVmZmVyID0gcGFyYW1ldGVycy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucHJlc2VydmVEcmF3aW5nQnVmZmVyIDogZmFsc2UsXFxyXFxuXFx0XFx0XFx0X3Bvd2VyUHJlZmVyZW5jZSA9IHBhcmFtZXRlcnMucG93ZXJQcmVmZXJlbmNlICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnBvd2VyUHJlZmVyZW5jZSA6ICdkZWZhdWx0JztcXHJcXG5cXHJcXG5cXHRcXHR2YXIgbGlnaHRzQXJyYXkgPSBbXTtcXHJcXG5cXHRcXHR2YXIgc2hhZG93c0FycmF5ID0gW107XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGN1cnJlbnRSZW5kZXJMaXN0ID0gbnVsbDtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgc3ByaXRlc0FycmF5ID0gW107XFxyXFxuXFx0XFx0dmFyIGZsYXJlc0FycmF5ID0gW107XFxyXFxuXFxyXFxuXFx0XFx0Ly8gcHVibGljIHByb3BlcnRpZXNcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmRvbUVsZW1lbnQgPSBfY2FudmFzO1xcclxcblxcdFxcdHRoaXMuY29udGV4dCA9IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gY2xlYXJpbmdcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmF1dG9DbGVhciA9IHRydWU7XFxyXFxuXFx0XFx0dGhpcy5hdXRvQ2xlYXJDb2xvciA9IHRydWU7XFxyXFxuXFx0XFx0dGhpcy5hdXRvQ2xlYXJEZXB0aCA9IHRydWU7XFxyXFxuXFx0XFx0dGhpcy5hdXRvQ2xlYXJTdGVuY2lsID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBzY2VuZSBncmFwaFxcclxcblxcclxcblxcdFxcdHRoaXMuc29ydE9iamVjdHMgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdC8vIHVzZXItZGVmaW5lZCBjbGlwcGluZ1xcclxcblxcclxcblxcdFxcdHRoaXMuY2xpcHBpbmdQbGFuZXMgPSBbXTtcXHJcXG5cXHRcXHR0aGlzLmxvY2FsQ2xpcHBpbmdFbmFibGVkID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gcGh5c2ljYWxseSBiYXNlZCBzaGFkaW5nXFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5nYW1tYUZhY3RvciA9IDIuMDtcXHQvLyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcXHJcXG5cXHRcXHR0aGlzLmdhbW1hSW5wdXQgPSBmYWxzZTtcXHJcXG5cXHRcXHR0aGlzLmdhbW1hT3V0cHV0ID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gcGh5c2ljYWwgbGlnaHRzXFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5waHlzaWNhbGx5Q29ycmVjdExpZ2h0cyA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdC8vIHRvbmUgbWFwcGluZ1xcclxcblxcclxcblxcdFxcdHRoaXMudG9uZU1hcHBpbmcgPSBMaW5lYXJUb25lTWFwcGluZztcXHJcXG5cXHRcXHR0aGlzLnRvbmVNYXBwaW5nRXhwb3N1cmUgPSAxLjA7XFxyXFxuXFx0XFx0dGhpcy50b25lTWFwcGluZ1doaXRlUG9pbnQgPSAxLjA7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gbW9ycGhzXFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5tYXhNb3JwaFRhcmdldHMgPSA4O1xcclxcblxcdFxcdHRoaXMubWF4TW9ycGhOb3JtYWxzID0gNDtcXHJcXG5cXHJcXG5cXHRcXHQvLyBpbnRlcm5hbCBwcm9wZXJ0aWVzXFxyXFxuXFxyXFxuXFx0XFx0dmFyIF90aGlzID0gdGhpcyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRfaXNDb250ZXh0TG9zdCA9IGZhbHNlLFxcclxcblxcclxcblxcdFxcdFxcdC8vIGludGVybmFsIHN0YXRlIGNhY2hlXFxyXFxuXFxyXFxuXFx0XFx0XFx0X2N1cnJlbnRSZW5kZXJUYXJnZXQgPSBudWxsLFxcclxcblxcdFxcdFxcdF9jdXJyZW50RnJhbWVidWZmZXIgPSBudWxsLFxcclxcblxcdFxcdFxcdF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0gMSxcXHJcXG5cXHRcXHRcXHRfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9ICcnLFxcclxcblxcclxcblxcdFxcdFxcdF9jdXJyZW50Q2FtZXJhID0gbnVsbCxcXHJcXG5cXHRcXHRcXHRfY3VycmVudEFycmF5Q2FtZXJhID0gbnVsbCxcXHJcXG5cXHJcXG5cXHRcXHRcXHRfY3VycmVudFZpZXdwb3J0ID0gbmV3IFZlY3RvcjQoKSxcXHJcXG5cXHRcXHRcXHRfY3VycmVudFNjaXNzb3IgPSBuZXcgVmVjdG9yNCgpLFxcclxcblxcdFxcdFxcdF9jdXJyZW50U2Npc3NvclRlc3QgPSBudWxsLFxcclxcblxcclxcblxcdFxcdFxcdC8vXFxyXFxuXFxyXFxuXFx0XFx0XFx0X3VzZWRUZXh0dXJlVW5pdHMgPSAwLFxcclxcblxcclxcblxcdFxcdFxcdC8vXFxyXFxuXFxyXFxuXFx0XFx0XFx0X3dpZHRoID0gX2NhbnZhcy53aWR0aCxcXHJcXG5cXHRcXHRcXHRfaGVpZ2h0ID0gX2NhbnZhcy5oZWlnaHQsXFxyXFxuXFxyXFxuXFx0XFx0XFx0X3BpeGVsUmF0aW8gPSAxLFxcclxcblxcclxcblxcdFxcdFxcdF92aWV3cG9ydCA9IG5ldyBWZWN0b3I0KCAwLCAwLCBfd2lkdGgsIF9oZWlnaHQgKSxcXHJcXG5cXHRcXHRcXHRfc2Npc3NvciA9IG5ldyBWZWN0b3I0KCAwLCAwLCBfd2lkdGgsIF9oZWlnaHQgKSxcXHJcXG5cXHRcXHRcXHRfc2Npc3NvclRlc3QgPSBmYWxzZSxcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBmcnVzdHVtXFxyXFxuXFxyXFxuXFx0XFx0XFx0X2ZydXN0dW0gPSBuZXcgRnJ1c3R1bSgpLFxcclxcblxcclxcblxcdFxcdFxcdC8vIGNsaXBwaW5nXFxyXFxuXFxyXFxuXFx0XFx0XFx0X2NsaXBwaW5nID0gbmV3IFdlYkdMQ2xpcHBpbmcoKSxcXHJcXG5cXHRcXHRcXHRfY2xpcHBpbmdFbmFibGVkID0gZmFsc2UsXFxyXFxuXFx0XFx0XFx0X2xvY2FsQ2xpcHBpbmdFbmFibGVkID0gZmFsc2UsXFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gY2FtZXJhIG1hdHJpY2VzIGNhY2hlXFxyXFxuXFxyXFxuXFx0XFx0XFx0X3Byb2pTY3JlZW5NYXRyaXggPSBuZXcgTWF0cml4NCgpLFxcclxcblxcclxcblxcdFxcdFxcdF92ZWN0b3IzID0gbmV3IFZlY3RvcjMoKSxcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBpbmZvXFxyXFxuXFxyXFxuXFx0XFx0XFx0X2luZm9NZW1vcnkgPSB7XFxyXFxuXFx0XFx0XFx0XFx0Z2VvbWV0cmllczogMCxcXHJcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlczogMFxcclxcblxcdFxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0XFx0X2luZm9SZW5kZXIgPSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZnJhbWU6IDAsXFxyXFxuXFx0XFx0XFx0XFx0Y2FsbHM6IDAsXFxyXFxuXFx0XFx0XFx0XFx0dmVydGljZXM6IDAsXFxyXFxuXFx0XFx0XFx0XFx0ZmFjZXM6IDAsXFxyXFxuXFx0XFx0XFx0XFx0cG9pbnRzOiAwXFxyXFxuXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmluZm8gPSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmVuZGVyOiBfaW5mb1JlbmRlcixcXHJcXG5cXHRcXHRcXHRtZW1vcnk6IF9pbmZvTWVtb3J5LFxcclxcblxcdFxcdFxcdHByb2dyYW1zOiBudWxsXFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBnZXRUYXJnZXRQaXhlbFJhdGlvKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBfY3VycmVudFJlbmRlclRhcmdldCA9PT0gbnVsbCA/IF9waXhlbFJhdGlvIDogMTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0Ly8gaW5pdGlhbGl6ZVxcclxcblxcclxcblxcdFxcdHZhciBfZ2w7XFxyXFxuXFxyXFxuXFx0XFx0dHJ5IHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgY29udGV4dEF0dHJpYnV0ZXMgPSB7XFxyXFxuXFx0XFx0XFx0XFx0YWxwaGE6IF9hbHBoYSxcXHJcXG5cXHRcXHRcXHRcXHRkZXB0aDogX2RlcHRoLFxcclxcblxcdFxcdFxcdFxcdHN0ZW5jaWw6IF9zdGVuY2lsLFxcclxcblxcdFxcdFxcdFxcdGFudGlhbGlhczogX2FudGlhbGlhcyxcXHJcXG5cXHRcXHRcXHRcXHRwcmVtdWx0aXBsaWVkQWxwaGE6IF9wcmVtdWx0aXBsaWVkQWxwaGEsXFxyXFxuXFx0XFx0XFx0XFx0cHJlc2VydmVEcmF3aW5nQnVmZmVyOiBfcHJlc2VydmVEcmF3aW5nQnVmZmVyLFxcclxcblxcdFxcdFxcdFxcdHBvd2VyUHJlZmVyZW5jZTogX3Bvd2VyUHJlZmVyZW5jZVxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gZXZlbnQgbGlzdGVuZXJzIG11c3QgYmUgcmVnaXN0ZXJlZCBiZWZvcmUgV2ViR0wgY29udGV4dCBpcyBjcmVhdGVkLCBzZWUgIzEyNzUzXFxyXFxuXFxyXFxuXFx0XFx0XFx0X2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCAnd2ViZ2xjb250ZXh0bG9zdCcsIG9uQ29udGV4dExvc3QsIGZhbHNlICk7XFxyXFxuXFx0XFx0XFx0X2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCAnd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCBvbkNvbnRleHRSZXN0b3JlLCBmYWxzZSApO1xcclxcblxcclxcblxcdFxcdFxcdF9nbCA9IF9jb250ZXh0IHx8IF9jYW52YXMuZ2V0Q29udGV4dCggJ3dlYmdsJywgY29udGV4dEF0dHJpYnV0ZXMgKSB8fCBfY2FudmFzLmdldENvbnRleHQoICdleHBlcmltZW50YWwtd2ViZ2wnLCBjb250ZXh0QXR0cmlidXRlcyApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggX2dsID09PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggX2NhbnZhcy5nZXRDb250ZXh0KCAnd2ViZ2wnICkgIT09IG51bGwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhyb3cgbmV3IEVycm9yKCAnRXJyb3IgY3JlYXRpbmcgV2ViR0wgY29udGV4dCB3aXRoIHlvdXIgc2VsZWN0ZWQgYXR0cmlidXRlcy4nICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoICdFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0LicgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdC8vIFNvbWUgZXhwZXJpbWVudGFsLXdlYmdsIGltcGxlbWVudGF0aW9ucyBkbyBub3QgaGF2ZSBnZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXRcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQgPT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0ID0gZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB7ICdyYW5nZU1pbic6IDEsICdyYW5nZU1heCc6IDEsICdwcmVjaXNpb24nOiAxIH07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fSBjYXRjaCAoIGVycm9yICkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAnICsgZXJyb3IubWVzc2FnZSApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR2YXIgZXh0ZW5zaW9ucywgY2FwYWJpbGl0aWVzLCBzdGF0ZTtcXHJcXG5cXHRcXHR2YXIgcHJvcGVydGllcywgdGV4dHVyZXMsIGF0dHJpYnV0ZXMsIGdlb21ldHJpZXMsIG9iamVjdHMsIGxpZ2h0cztcXHJcXG5cXHRcXHR2YXIgcHJvZ3JhbUNhY2hlLCByZW5kZXJMaXN0cztcXHJcXG5cXHJcXG5cXHRcXHR2YXIgYmFja2dyb3VuZCwgbW9ycGh0YXJnZXRzLCBidWZmZXJSZW5kZXJlciwgaW5kZXhlZEJ1ZmZlclJlbmRlcmVyO1xcclxcblxcdFxcdHZhciBmbGFyZVJlbmRlcmVyLCBzcHJpdGVSZW5kZXJlcjtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgdXRpbHM7XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gaW5pdEdMQ29udGV4dCgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRleHRlbnNpb25zID0gbmV3IFdlYkdMRXh0ZW5zaW9ucyggX2dsICk7XFxyXFxuXFx0XFx0XFx0ZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9kZXB0aF90ZXh0dXJlJyApO1xcclxcblxcdFxcdFxcdGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXQnICk7XFxyXFxuXFx0XFx0XFx0ZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInICk7XFxyXFxuXFx0XFx0XFx0ZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0JyApO1xcclxcblxcdFxcdFxcdGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInICk7XFxyXFxuXFx0XFx0XFx0ZXh0ZW5zaW9ucy5nZXQoICdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnICk7XFxyXFxuXFx0XFx0XFx0ZXh0ZW5zaW9ucy5nZXQoICdPRVNfZWxlbWVudF9pbmRleF91aW50JyApO1xcclxcblxcdFxcdFxcdGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR1dGlscyA9IG5ldyBXZWJHTFV0aWxzKCBfZ2wsIGV4dGVuc2lvbnMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjYXBhYmlsaXRpZXMgPSBuZXcgV2ViR0xDYXBhYmlsaXRpZXMoIF9nbCwgZXh0ZW5zaW9ucywgcGFyYW1ldGVycyApO1xcclxcblxcclxcblxcdFxcdFxcdHN0YXRlID0gbmV3IFdlYkdMU3RhdGUoIF9nbCwgZXh0ZW5zaW9ucywgdXRpbHMgKTtcXHJcXG5cXHRcXHRcXHRzdGF0ZS5zY2lzc29yKCBfY3VycmVudFNjaXNzb3IuY29weSggX3NjaXNzb3IgKS5tdWx0aXBseVNjYWxhciggX3BpeGVsUmF0aW8gKSApO1xcclxcblxcdFxcdFxcdHN0YXRlLnZpZXdwb3J0KCBfY3VycmVudFZpZXdwb3J0LmNvcHkoIF92aWV3cG9ydCApLm11bHRpcGx5U2NhbGFyKCBfcGl4ZWxSYXRpbyApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cHJvcGVydGllcyA9IG5ldyBXZWJHTFByb3BlcnRpZXMoKTtcXHJcXG5cXHRcXHRcXHR0ZXh0dXJlcyA9IG5ldyBXZWJHTFRleHR1cmVzKCBfZ2wsIGV4dGVuc2lvbnMsIHN0YXRlLCBwcm9wZXJ0aWVzLCBjYXBhYmlsaXRpZXMsIHV0aWxzLCBfaW5mb01lbW9yeSApO1xcclxcblxcdFxcdFxcdGF0dHJpYnV0ZXMgPSBuZXcgV2ViR0xBdHRyaWJ1dGVzKCBfZ2wgKTtcXHJcXG5cXHRcXHRcXHRnZW9tZXRyaWVzID0gbmV3IFdlYkdMR2VvbWV0cmllcyggX2dsLCBhdHRyaWJ1dGVzLCBfaW5mb01lbW9yeSApO1xcclxcblxcdFxcdFxcdG9iamVjdHMgPSBuZXcgV2ViR0xPYmplY3RzKCBnZW9tZXRyaWVzLCBfaW5mb1JlbmRlciApO1xcclxcblxcdFxcdFxcdG1vcnBodGFyZ2V0cyA9IG5ldyBXZWJHTE1vcnBodGFyZ2V0cyggX2dsICk7XFxyXFxuXFx0XFx0XFx0cHJvZ3JhbUNhY2hlID0gbmV3IFdlYkdMUHJvZ3JhbXMoIF90aGlzLCBleHRlbnNpb25zLCBjYXBhYmlsaXRpZXMgKTtcXHJcXG5cXHRcXHRcXHRsaWdodHMgPSBuZXcgV2ViR0xMaWdodHMoKTtcXHJcXG5cXHRcXHRcXHRyZW5kZXJMaXN0cyA9IG5ldyBXZWJHTFJlbmRlckxpc3RzKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0YmFja2dyb3VuZCA9IG5ldyBXZWJHTEJhY2tncm91bmQoIF90aGlzLCBzdGF0ZSwgZ2VvbWV0cmllcywgX3ByZW11bHRpcGxpZWRBbHBoYSApO1xcclxcblxcclxcblxcdFxcdFxcdGJ1ZmZlclJlbmRlcmVyID0gbmV3IFdlYkdMQnVmZmVyUmVuZGVyZXIoIF9nbCwgZXh0ZW5zaW9ucywgX2luZm9SZW5kZXIgKTtcXHJcXG5cXHRcXHRcXHRpbmRleGVkQnVmZmVyUmVuZGVyZXIgPSBuZXcgV2ViR0xJbmRleGVkQnVmZmVyUmVuZGVyZXIoIF9nbCwgZXh0ZW5zaW9ucywgX2luZm9SZW5kZXIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmbGFyZVJlbmRlcmVyID0gbmV3IFdlYkdMRmxhcmVSZW5kZXJlciggX3RoaXMsIF9nbCwgc3RhdGUsIHRleHR1cmVzLCBjYXBhYmlsaXRpZXMgKTtcXHJcXG5cXHRcXHRcXHRzcHJpdGVSZW5kZXJlciA9IG5ldyBXZWJHTFNwcml0ZVJlbmRlcmVyKCBfdGhpcywgX2dsLCBzdGF0ZSwgdGV4dHVyZXMsIGNhcGFiaWxpdGllcyApO1xcclxcblxcclxcblxcdFxcdFxcdF90aGlzLmluZm8ucHJvZ3JhbXMgPSBwcm9ncmFtQ2FjaGUucHJvZ3JhbXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0X3RoaXMuY29udGV4dCA9IF9nbDtcXHJcXG5cXHRcXHRcXHRfdGhpcy5jYXBhYmlsaXRpZXMgPSBjYXBhYmlsaXRpZXM7XFxyXFxuXFx0XFx0XFx0X3RoaXMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XFxyXFxuXFx0XFx0XFx0X3RoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XFxyXFxuXFx0XFx0XFx0X3RoaXMucmVuZGVyTGlzdHMgPSByZW5kZXJMaXN0cztcXHJcXG5cXHRcXHRcXHRfdGhpcy5zdGF0ZSA9IHN0YXRlO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRpbml0R0xDb250ZXh0KCk7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gdnJcXHJcXG5cXHJcXG5cXHRcXHR2YXIgdnIgPSBuZXcgV2ViVlJNYW5hZ2VyKCBfdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudnIgPSB2cjtcXHJcXG5cXHJcXG5cXHRcXHQvLyBzaGFkb3cgbWFwXFxyXFxuXFxyXFxuXFx0XFx0dmFyIHNoYWRvd01hcCA9IG5ldyBXZWJHTFNoYWRvd01hcCggX3RoaXMsIG9iamVjdHMsIGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlU2l6ZSApO1xcclxcblxcclxcblxcdFxcdHRoaXMuc2hhZG93TWFwID0gc2hhZG93TWFwO1xcclxcblxcclxcblxcdFxcdC8vIEFQSVxcclxcblxcclxcblxcdFxcdHRoaXMuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gX2dsO1xcclxcblxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5nZXRDb250ZXh0QXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gX2dsLmdldENvbnRleHRBdHRyaWJ1dGVzKCk7XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmZvcmNlQ29udGV4dExvc3MgPSBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfbG9zZV9jb250ZXh0JyApO1xcclxcblxcdFxcdFxcdGlmICggZXh0ZW5zaW9uICkgZXh0ZW5zaW9uLmxvc2VDb250ZXh0KCk7XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmZvcmNlQ29udGV4dFJlc3RvcmUgPSBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfbG9zZV9jb250ZXh0JyApO1xcclxcblxcdFxcdFxcdGlmICggZXh0ZW5zaW9uICkgZXh0ZW5zaW9uLnJlc3RvcmVDb250ZXh0KCk7XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmdldFBpeGVsUmF0aW8gPSBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIF9waXhlbFJhdGlvO1xcclxcblxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5zZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSByZXR1cm47XFxyXFxuXFxyXFxuXFx0XFx0XFx0X3BpeGVsUmF0aW8gPSB2YWx1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnNldFNpemUoIF93aWR0aCwgX2hlaWdodCwgZmFsc2UgKTtcXHJcXG5cXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdFxcdHRoaXMuZ2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4ge1xcclxcblxcdFxcdFxcdFxcdHdpZHRoOiBfd2lkdGgsXFxyXFxuXFx0XFx0XFx0XFx0aGVpZ2h0OiBfaGVpZ2h0XFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdFxcdHRoaXMuc2V0U2l6ZSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgdXBkYXRlU3R5bGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGRldmljZSA9IHZyLmdldERldmljZSgpO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggZGV2aWNlICYmIGRldmljZS5pc1ByZXNlbnRpbmcgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogQ2FuXFxcXCd0IGNoYW5nZSBzaXplIHdoaWxlIFZSIGRldmljZSBpcyBwcmVzZW50aW5nLicgKTtcXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdF93aWR0aCA9IHdpZHRoO1xcclxcblxcdFxcdFxcdF9oZWlnaHQgPSBoZWlnaHQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0X2NhbnZhcy53aWR0aCA9IHdpZHRoICogX3BpeGVsUmF0aW87XFxyXFxuXFx0XFx0XFx0X2NhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiBfcGl4ZWxSYXRpbztcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHVwZGF0ZVN0eWxlICE9PSBmYWxzZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRfY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xcclxcblxcdFxcdFxcdFxcdF9jYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5zZXRWaWV3cG9ydCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xcclxcblxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5nZXREcmF3aW5nQnVmZmVyU2l6ZSA9IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4ge1xcclxcblxcdFxcdFxcdFxcdHdpZHRoOiBfd2lkdGggKiBfcGl4ZWxSYXRpbyxcXHJcXG5cXHRcXHRcXHRcXHRoZWlnaHQ6IF9oZWlnaHQgKiBfcGl4ZWxSYXRpb1xcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnNldERyYXdpbmdCdWZmZXJTaXplID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCBwaXhlbFJhdGlvICkge1xcclxcblxcclxcblxcdFxcdFxcdF93aWR0aCA9IHdpZHRoO1xcclxcblxcdFxcdFxcdF9oZWlnaHQgPSBoZWlnaHQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0X3BpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xcclxcblxcclxcblxcdFxcdFxcdF9jYW52YXMud2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XFxyXFxuXFx0XFx0XFx0X2NhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuc2V0Vmlld3BvcnQoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcXHJcXG5cXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdFxcdHRoaXMuc2V0Vmlld3BvcnQgPSBmdW5jdGlvbiAoIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0X3ZpZXdwb3J0LnNldCggeCwgX2hlaWdodCAtIHkgLSBoZWlnaHQsIHdpZHRoLCBoZWlnaHQgKTtcXHJcXG5cXHRcXHRcXHRzdGF0ZS52aWV3cG9ydCggX2N1cnJlbnRWaWV3cG9ydC5jb3B5KCBfdmlld3BvcnQgKS5tdWx0aXBseVNjYWxhciggX3BpeGVsUmF0aW8gKSApO1xcclxcblxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5zZXRTY2lzc29yID0gZnVuY3Rpb24gKCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xcclxcblxcclxcblxcdFxcdFxcdF9zY2lzc29yLnNldCggeCwgX2hlaWdodCAtIHkgLSBoZWlnaHQsIHdpZHRoLCBoZWlnaHQgKTtcXHJcXG5cXHRcXHRcXHRzdGF0ZS5zY2lzc29yKCBfY3VycmVudFNjaXNzb3IuY29weSggX3NjaXNzb3IgKS5tdWx0aXBseVNjYWxhciggX3BpeGVsUmF0aW8gKSApO1xcclxcblxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5zZXRTY2lzc29yVGVzdCA9IGZ1bmN0aW9uICggYm9vbGVhbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRzdGF0ZS5zZXRTY2lzc29yVGVzdCggX3NjaXNzb3JUZXN0ID0gYm9vbGVhbiApO1xcclxcblxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0Ly8gQ2xlYXJpbmdcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmdldENsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGJhY2tncm91bmQuZ2V0Q2xlYXJDb2xvcigpO1xcclxcblxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5zZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdGJhY2tncm91bmQuc2V0Q2xlYXJDb2xvci5hcHBseSggYmFja2dyb3VuZCwgYXJndW1lbnRzICk7XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmdldENsZWFyQWxwaGEgPSBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGJhY2tncm91bmQuZ2V0Q2xlYXJBbHBoYSgpO1xcclxcblxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5zZXRDbGVhckFscGhhID0gZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdGJhY2tncm91bmQuc2V0Q2xlYXJBbHBoYS5hcHBseSggYmFja2dyb3VuZCwgYXJndW1lbnRzICk7XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmNsZWFyID0gZnVuY3Rpb24gKCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGJpdHMgPSAwO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggY29sb3IgPT09IHVuZGVmaW5lZCB8fCBjb2xvciApIGJpdHMgfD0gX2dsLkNPTE9SX0JVRkZFUl9CSVQ7XFxyXFxuXFx0XFx0XFx0aWYgKCBkZXB0aCA9PT0gdW5kZWZpbmVkIHx8IGRlcHRoICkgYml0cyB8PSBfZ2wuREVQVEhfQlVGRkVSX0JJVDtcXHJcXG5cXHRcXHRcXHRpZiAoIHN0ZW5jaWwgPT09IHVuZGVmaW5lZCB8fCBzdGVuY2lsICkgYml0cyB8PSBfZ2wuU1RFTkNJTF9CVUZGRVJfQklUO1xcclxcblxcclxcblxcdFxcdFxcdF9nbC5jbGVhciggYml0cyApO1xcclxcblxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5jbGVhckNvbG9yID0gZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuY2xlYXIoIHRydWUsIGZhbHNlLCBmYWxzZSApO1xcclxcblxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5jbGVhckRlcHRoID0gZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuY2xlYXIoIGZhbHNlLCB0cnVlLCBmYWxzZSApO1xcclxcblxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5jbGVhclN0ZW5jaWwgPSBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5jbGVhciggZmFsc2UsIGZhbHNlLCB0cnVlICk7XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmNsZWFyVGFyZ2V0ID0gZnVuY3Rpb24gKCByZW5kZXJUYXJnZXQsIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XFxyXFxuXFx0XFx0XFx0dGhpcy5jbGVhciggY29sb3IsIGRlcHRoLCBzdGVuY2lsICk7XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHQvL1xcclxcblxcclxcblxcdFxcdHRoaXMuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRfY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoICd3ZWJnbGNvbnRleHRsb3N0Jywgb25Db250ZXh0TG9zdCwgZmFsc2UgKTtcXHJcXG5cXHRcXHRcXHRfY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoICd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIG9uQ29udGV4dFJlc3RvcmUsIGZhbHNlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmVuZGVyTGlzdHMuZGlzcG9zZSgpO1xcclxcblxcclxcblxcdFxcdFxcdHZyLmRpc3Bvc2UoKTtcXHJcXG5cXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdFxcdC8vIEV2ZW50c1xcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIG9uQ29udGV4dExvc3QoIGV2ZW50ICkge1xcclxcblxcclxcblxcdFxcdFxcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS5sb2coICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBDb250ZXh0IExvc3QuJyApO1xcclxcblxcclxcblxcdFxcdFxcdF9pc0NvbnRleHRMb3N0ID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gb25Db250ZXh0UmVzdG9yZSggLyogZXZlbnQgKi8gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS5sb2coICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBDb250ZXh0IFJlc3RvcmVkLicgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRfaXNDb250ZXh0TG9zdCA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdFxcdGluaXRHTENvbnRleHQoKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gb25NYXRlcmlhbERpc3Bvc2UoIGV2ZW50ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBtYXRlcmlhbCA9IGV2ZW50LnRhcmdldDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRtYXRlcmlhbC5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uTWF0ZXJpYWxEaXNwb3NlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZGVhbGxvY2F0ZU1hdGVyaWFsKCBtYXRlcmlhbCApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHQvLyBCdWZmZXIgZGVhbGxvY2F0aW9uXFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gZGVhbGxvY2F0ZU1hdGVyaWFsKCBtYXRlcmlhbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZWxlYXNlTWF0ZXJpYWxQcm9ncmFtUmVmZXJlbmNlKCBtYXRlcmlhbCApO1xcclxcblxcclxcblxcdFxcdFxcdHByb3BlcnRpZXMucmVtb3ZlKCBtYXRlcmlhbCApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiByZWxlYXNlTWF0ZXJpYWxQcm9ncmFtUmVmZXJlbmNlKCBtYXRlcmlhbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcHJvZ3JhbUluZm8gPSBwcm9wZXJ0aWVzLmdldCggbWF0ZXJpYWwgKS5wcm9ncmFtO1xcclxcblxcclxcblxcdFxcdFxcdG1hdGVyaWFsLnByb2dyYW0gPSB1bmRlZmluZWQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBwcm9ncmFtSW5mbyAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHByb2dyYW1DYWNoZS5yZWxlYXNlUHJvZ3JhbSggcHJvZ3JhbUluZm8gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdC8vIEJ1ZmZlciByZW5kZXJpbmdcXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiByZW5kZXJPYmplY3RJbW1lZGlhdGUoIG9iamVjdCwgcHJvZ3JhbSwgbWF0ZXJpYWwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0b2JqZWN0LnJlbmRlciggZnVuY3Rpb24gKCBvYmplY3QgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0X3RoaXMucmVuZGVyQnVmZmVySW1tZWRpYXRlKCBvYmplY3QsIHByb2dyYW0sIG1hdGVyaWFsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnJlbmRlckJ1ZmZlckltbWVkaWF0ZSA9IGZ1bmN0aW9uICggb2JqZWN0LCBwcm9ncmFtLCBtYXRlcmlhbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRzdGF0ZS5pbml0QXR0cmlidXRlcygpO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBidWZmZXJzID0gcHJvcGVydGllcy5nZXQoIG9iamVjdCApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggb2JqZWN0Lmhhc1Bvc2l0aW9ucyAmJiAhIGJ1ZmZlcnMucG9zaXRpb24gKSBidWZmZXJzLnBvc2l0aW9uID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xcclxcblxcdFxcdFxcdGlmICggb2JqZWN0Lmhhc05vcm1hbHMgJiYgISBidWZmZXJzLm5vcm1hbCApIGJ1ZmZlcnMubm9ybWFsID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xcclxcblxcdFxcdFxcdGlmICggb2JqZWN0Lmhhc1V2cyAmJiAhIGJ1ZmZlcnMudXYgKSBidWZmZXJzLnV2ID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xcclxcblxcdFxcdFxcdGlmICggb2JqZWN0Lmhhc0NvbG9ycyAmJiAhIGJ1ZmZlcnMuY29sb3IgKSBidWZmZXJzLmNvbG9yID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBwcm9ncmFtQXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggb2JqZWN0Lmhhc1Bvc2l0aW9ucyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVycy5wb3NpdGlvbiApO1xcclxcblxcdFxcdFxcdFxcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QucG9zaXRpb25BcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggcHJvZ3JhbUF0dHJpYnV0ZXMucG9zaXRpb24gKTtcXHJcXG5cXHRcXHRcXHRcXHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggcHJvZ3JhbUF0dHJpYnV0ZXMucG9zaXRpb24sIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBvYmplY3QuaGFzTm9ybWFscyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVycy5ub3JtYWwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoICEgbWF0ZXJpYWwuaXNNZXNoUGhvbmdNYXRlcmlhbCAmJlxcclxcblxcdFxcdFxcdFxcdFxcdCEgbWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCAmJlxcclxcblxcdFxcdFxcdFxcdFxcdCEgbWF0ZXJpYWwuaXNNZXNoTm9ybWFsTWF0ZXJpYWwgJiZcXHJcXG5cXHRcXHRcXHRcXHRcXHRtYXRlcmlhbC5mbGF0U2hhZGluZyA9PT0gdHJ1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBvYmplY3QuY291bnQgKiAzOyBpIDwgbDsgaSArPSA5ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBhcnJheSA9IG9iamVjdC5ub3JtYWxBcnJheTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgbnggPSAoIGFycmF5WyBpICsgMCBdICsgYXJyYXlbIGkgKyAzIF0gKyBhcnJheVsgaSArIDYgXSApIC8gMztcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgbnkgPSAoIGFycmF5WyBpICsgMSBdICsgYXJyYXlbIGkgKyA0IF0gKyBhcnJheVsgaSArIDcgXSApIC8gMztcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgbnogPSAoIGFycmF5WyBpICsgMiBdICsgYXJyYXlbIGkgKyA1IF0gKyBhcnJheVsgaSArIDggXSApIC8gMztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRhcnJheVsgaSArIDAgXSA9IG54O1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGFycmF5WyBpICsgMSBdID0gbnk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0YXJyYXlbIGkgKyAyIF0gPSBuejtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRhcnJheVsgaSArIDMgXSA9IG54O1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGFycmF5WyBpICsgNCBdID0gbnk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0YXJyYXlbIGkgKyA1IF0gPSBuejtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRhcnJheVsgaSArIDYgXSA9IG54O1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGFycmF5WyBpICsgNyBdID0gbnk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0YXJyYXlbIGkgKyA4IF0gPSBuejtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3Qubm9ybWFsQXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIHByb2dyYW1BdHRyaWJ1dGVzLm5vcm1hbCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBwcm9ncmFtQXR0cmlidXRlcy5ub3JtYWwsIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBvYmplY3QuaGFzVXZzICYmIG1hdGVyaWFsLm1hcCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVycy51diApO1xcclxcblxcdFxcdFxcdFxcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QudXZBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggcHJvZ3JhbUF0dHJpYnV0ZXMudXYgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggcHJvZ3JhbUF0dHJpYnV0ZXMudXYsIDIsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBvYmplY3QuaGFzQ29sb3JzICYmIG1hdGVyaWFsLnZlcnRleENvbG9ycyAhPT0gTm9Db2xvcnMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMuY29sb3IgKTtcXHJcXG5cXHRcXHRcXHRcXHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0LmNvbG9yQXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIHByb2dyYW1BdHRyaWJ1dGVzLmNvbG9yICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIHByb2dyYW1BdHRyaWJ1dGVzLmNvbG9yLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0X2dsLmRyYXdBcnJheXMoIF9nbC5UUklBTkdMRVMsIDAsIG9iamVjdC5jb3VudCApO1xcclxcblxcclxcblxcdFxcdFxcdG9iamVjdC5jb3VudCA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnJlbmRlckJ1ZmZlckRpcmVjdCA9IGZ1bmN0aW9uICggY2FtZXJhLCBmb2csIGdlb21ldHJ5LCBtYXRlcmlhbCwgb2JqZWN0LCBncm91cCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgZnJvbnRGYWNlQ1cgPSAoIG9iamVjdC5pc01lc2ggJiYgb2JqZWN0Lm1hdHJpeFdvcmxkLmRldGVybWluYW50KCkgPCAwICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0c3RhdGUuc2V0TWF0ZXJpYWwoIG1hdGVyaWFsLCBmcm9udEZhY2VDVyApO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBmb2csIG1hdGVyaWFsLCBvYmplY3QgKTtcXHJcXG5cXHRcXHRcXHR2YXIgZ2VvbWV0cnlQcm9ncmFtID0gZ2VvbWV0cnkuaWQgKyAnXycgKyBwcm9ncmFtLmlkICsgJ18nICsgKCBtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdXBkYXRlQnVmZmVycyA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggZ2VvbWV0cnlQcm9ncmFtICE9PSBfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9IGdlb21ldHJ5UHJvZ3JhbTtcXHJcXG5cXHRcXHRcXHRcXHR1cGRhdGVCdWZmZXJzID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBvYmplY3QubW9ycGhUYXJnZXRJbmZsdWVuY2VzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdG1vcnBodGFyZ2V0cy51cGRhdGUoIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBwcm9ncmFtICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dXBkYXRlQnVmZmVycyA9IHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdC8vXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XFxyXFxuXFx0XFx0XFx0dmFyIHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcXHJcXG5cXHRcXHRcXHR2YXIgcmFuZ2VGYWN0b3IgPSAxO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwud2lyZWZyYW1lID09PSB0cnVlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGluZGV4ID0gZ2VvbWV0cmllcy5nZXRXaXJlZnJhbWVBdHRyaWJ1dGUoIGdlb21ldHJ5ICk7XFxyXFxuXFx0XFx0XFx0XFx0cmFuZ2VGYWN0b3IgPSAyO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgYXR0cmlidXRlO1xcclxcblxcdFxcdFxcdHZhciByZW5kZXJlciA9IGJ1ZmZlclJlbmRlcmVyO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggaW5kZXggIT09IG51bGwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YXR0cmlidXRlID0gYXR0cmlidXRlcy5nZXQoIGluZGV4ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmVuZGVyZXIgPSBpbmRleGVkQnVmZmVyUmVuZGVyZXI7XFxyXFxuXFx0XFx0XFx0XFx0cmVuZGVyZXIuc2V0SW5kZXgoIGF0dHJpYnV0ZSApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0c2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGF0dHJpYnV0ZS5idWZmZXIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdC8vXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGRhdGFDb3VudCA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRkYXRhQ291bnQgPSBpbmRleC5jb3VudDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGRhdGFDb3VudCA9IHBvc2l0aW9uLmNvdW50O1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcmFuZ2VTdGFydCA9IGdlb21ldHJ5LmRyYXdSYW5nZS5zdGFydCAqIHJhbmdlRmFjdG9yO1xcclxcblxcdFxcdFxcdHZhciByYW5nZUNvdW50ID0gZ2VvbWV0cnkuZHJhd1JhbmdlLmNvdW50ICogcmFuZ2VGYWN0b3I7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGdyb3VwU3RhcnQgPSBncm91cCAhPT0gbnVsbCA/IGdyb3VwLnN0YXJ0ICogcmFuZ2VGYWN0b3IgOiAwO1xcclxcblxcdFxcdFxcdHZhciBncm91cENvdW50ID0gZ3JvdXAgIT09IG51bGwgPyBncm91cC5jb3VudCAqIHJhbmdlRmFjdG9yIDogSW5maW5pdHk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGRyYXdTdGFydCA9IE1hdGgubWF4KCByYW5nZVN0YXJ0LCBncm91cFN0YXJ0ICk7XFxyXFxuXFx0XFx0XFx0dmFyIGRyYXdFbmQgPSBNYXRoLm1pbiggZGF0YUNvdW50LCByYW5nZVN0YXJ0ICsgcmFuZ2VDb3VudCwgZ3JvdXBTdGFydCArIGdyb3VwQ291bnQgKSAtIDE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGRyYXdDb3VudCA9IE1hdGgubWF4KCAwLCBkcmF3RW5kIC0gZHJhd1N0YXJ0ICsgMSApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggZHJhd0NvdW50ID09PSAwICkgcmV0dXJuO1xcclxcblxcclxcblxcdFxcdFxcdC8vXFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBvYmplY3QuaXNNZXNoICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggbWF0ZXJpYWwud2lyZWZyYW1lID09PSB0cnVlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHN0YXRlLnNldExpbmVXaWR0aCggbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoICogZ2V0VGFyZ2V0UGl4ZWxSYXRpbygpICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLkxJTkVTICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRzd2l0Y2ggKCBvYmplY3QuZHJhd01vZGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSBUcmlhbmdsZXNEcmF3TW9kZTpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuVFJJQU5HTEVTICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSBUcmlhbmdsZVN0cmlwRHJhd01vZGU6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLlRSSUFOR0xFX1NUUklQICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSBUcmlhbmdsZUZhbkRyYXdNb2RlOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5UUklBTkdMRV9GQU4gKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG9iamVjdC5pc0xpbmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGxpbmVXaWR0aCA9IG1hdGVyaWFsLmxpbmV3aWR0aDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGxpbmVXaWR0aCA9PT0gdW5kZWZpbmVkICkgbGluZVdpZHRoID0gMTsgLy8gTm90IHVzaW5nIExpbmUqTWF0ZXJpYWxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzdGF0ZS5zZXRMaW5lV2lkdGgoIGxpbmVXaWR0aCAqIGdldFRhcmdldFBpeGVsUmF0aW8oKSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggb2JqZWN0LmlzTGluZVNlZ21lbnRzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5MSU5FUyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIG9iamVjdC5pc0xpbmVMb29wICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5MSU5FX0xPT1AgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5MSU5FX1NUUklQICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG9iamVjdC5pc1BvaW50cyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuUE9JTlRTICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID4gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRyZW5kZXJlci5yZW5kZXJJbnN0YW5jZXMoIGdlb21ldHJ5LCBkcmF3U3RhcnQsIGRyYXdDb3VudCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJlbmRlcmVyLnJlbmRlciggZHJhd1N0YXJ0LCBkcmF3Q291bnQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBzZXR1cFZlcnRleEF0dHJpYnV0ZXMoIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSwgc3RhcnRJbmRleCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGdlb21ldHJ5ICYmIGdlb21ldHJ5LmlzSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICkgPT09IG51bGwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIuc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBzdGFydEluZGV4ID09PSB1bmRlZmluZWQgKSBzdGFydEluZGV4ID0gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRzdGF0ZS5pbml0QXR0cmlidXRlcygpO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBnZW9tZXRyeUF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBwcm9ncmFtQXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBtYXRlcmlhbERlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgPSBtYXRlcmlhbC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBuYW1lIGluIHByb2dyYW1BdHRyaWJ1dGVzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBwcm9ncmFtQXR0cmlidXRlID0gcHJvZ3JhbUF0dHJpYnV0ZXNbIG5hbWUgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHByb2dyYW1BdHRyaWJ1dGUgPj0gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgZ2VvbWV0cnlBdHRyaWJ1dGUgPSBnZW9tZXRyeUF0dHJpYnV0ZXNbIG5hbWUgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGdlb21ldHJ5QXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIG5vcm1hbGl6ZWQgPSBnZW9tZXRyeUF0dHJpYnV0ZS5ub3JtYWxpemVkO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBzaXplID0gZ2VvbWV0cnlBdHRyaWJ1dGUuaXRlbVNpemU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMuZ2V0KCBnZW9tZXRyeUF0dHJpYnV0ZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFRPRE8gQXR0cmlidXRlIG1heSBub3QgYmUgYXZhaWxhYmxlIG9uIGNvbnRleHQgcmVzdG9yZVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggYXR0cmlidXRlID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgYnVmZmVyID0gYXR0cmlidXRlLmJ1ZmZlcjtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgdHlwZSA9IGF0dHJpYnV0ZS50eXBlO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBieXRlc1BlckVsZW1lbnQgPSBhdHRyaWJ1dGUuYnl0ZXNQZXJFbGVtZW50O1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgZGF0YSA9IGdlb21ldHJ5QXR0cmlidXRlLmRhdGE7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIHN0cmlkZSA9IGRhdGEuc3RyaWRlO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBvZmZzZXQgPSBnZW9tZXRyeUF0dHJpYnV0ZS5vZmZzZXQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhICYmIGRhdGEuaXNJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGVBbmREaXZpc29yKCBwcm9ncmFtQXR0cmlidXRlLCBkYXRhLm1lc2hQZXJBdHRyaWJ1dGUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPSBkYXRhLm1lc2hQZXJBdHRyaWJ1dGUgKiBkYXRhLmNvdW50O1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggcHJvZ3JhbUF0dHJpYnV0ZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVyICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIHByb2dyYW1BdHRyaWJ1dGUsIHNpemUsIHR5cGUsIG5vcm1hbGl6ZWQsIHN0cmlkZSAqIGJ5dGVzUGVyRWxlbWVudCwgKCBzdGFydEluZGV4ICogc3RyaWRlICsgb2Zmc2V0ICkgKiBieXRlc1BlckVsZW1lbnQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvciggcHJvZ3JhbUF0dHJpYnV0ZSwgZ2VvbWV0cnlBdHRyaWJ1dGUubWVzaFBlckF0dHJpYnV0ZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA9IGdlb21ldHJ5QXR0cmlidXRlLm1lc2hQZXJBdHRyaWJ1dGUgKiBnZW9tZXRyeUF0dHJpYnV0ZS5jb3VudDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIHByb2dyYW1BdHRyaWJ1dGUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlciApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBwcm9ncmFtQXR0cmlidXRlLCBzaXplLCB0eXBlLCBub3JtYWxpemVkLCAwLCBzdGFydEluZGV4ICogc2l6ZSAqIGJ5dGVzUGVyRWxlbWVudCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBtYXRlcmlhbERlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgdmFsdWUgPSBtYXRlcmlhbERlZmF1bHRBdHRyaWJ1dGVWYWx1ZXNbIG5hbWUgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c3dpdGNoICggdmFsdWUubGVuZ3RoICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgMjpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRfZ2wudmVydGV4QXR0cmliMmZ2KCBwcm9ncmFtQXR0cmlidXRlLCB2YWx1ZSApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgMzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRfZ2wudmVydGV4QXR0cmliM2Z2KCBwcm9ncmFtQXR0cmlidXRlLCB2YWx1ZSApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgNDpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRfZ2wudmVydGV4QXR0cmliNGZ2KCBwcm9ncmFtQXR0cmlidXRlLCB2YWx1ZSApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRlZmF1bHQ6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0X2dsLnZlcnRleEF0dHJpYjFmdiggcHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdC8vIENvbXBpbGVcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmNvbXBpbGUgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0bGlnaHRzQXJyYXkubGVuZ3RoID0gMDtcXHJcXG5cXHRcXHRcXHRzaGFkb3dzQXJyYXkubGVuZ3RoID0gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRzY2VuZS50cmF2ZXJzZSggZnVuY3Rpb24gKCBvYmplY3QgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBvYmplY3QuaXNMaWdodCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRsaWdodHNBcnJheS5wdXNoKCBvYmplY3QgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG9iamVjdC5jYXN0U2hhZG93ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHNoYWRvd3NBcnJheS5wdXNoKCBvYmplY3QgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRsaWdodHMuc2V0dXAoIGxpZ2h0c0FycmF5LCBzaGFkb3dzQXJyYXksIGNhbWVyYSApO1xcclxcblxcclxcblxcdFxcdFxcdHNjZW5lLnRyYXZlcnNlKCBmdW5jdGlvbiAoIG9iamVjdCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIG9iamVjdC5tYXRlcmlhbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIEFycmF5LmlzQXJyYXkoIG9iamVjdC5tYXRlcmlhbCApICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IG9iamVjdC5tYXRlcmlhbC5sZW5ndGg7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aW5pdE1hdGVyaWFsKCBvYmplY3QubWF0ZXJpYWxbIGkgXSwgc2NlbmUuZm9nLCBvYmplY3QgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpbml0TWF0ZXJpYWwoIG9iamVjdC5tYXRlcmlhbCwgc2NlbmUuZm9nLCBvYmplY3QgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH0gKTtcXHJcXG5cXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdFxcdC8vIEFuaW1hdGlvbiBMb29wXFxyXFxuXFxyXFxuXFx0XFx0dmFyIGlzQW5pbWF0aW5nID0gZmFsc2U7XFxyXFxuXFx0XFx0dmFyIG9uQW5pbWF0aW9uRnJhbWUgPSBudWxsO1xcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIHN0YXJ0KCkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggaXNBbmltYXRpbmcgKSByZXR1cm47XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGRldmljZSA9IHZyLmdldERldmljZSgpO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggZGV2aWNlICYmIGRldmljZS5pc1ByZXNlbnRpbmcgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZGV2aWNlLnJlcXVlc3RBbmltYXRpb25GcmFtZSggbG9vcCApO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggbG9vcCApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpc0FuaW1hdGluZyA9IHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIGxvb3AoIHRpbWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBvbkFuaW1hdGlvbkZyYW1lICE9PSBudWxsICkgb25BbmltYXRpb25GcmFtZSggdGltZSApO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBkZXZpY2UgPSB2ci5nZXREZXZpY2UoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGRldmljZSAmJiBkZXZpY2UuaXNQcmVzZW50aW5nICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGRldmljZS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIGxvb3AgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIGxvb3AgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHRoaXMuYW5pbWF0ZSA9IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0b25BbmltYXRpb25GcmFtZSA9IGNhbGxiYWNrO1xcclxcblxcdFxcdFxcdHN0YXJ0KCk7XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBSZW5kZXJpbmdcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSwgcmVuZGVyVGFyZ2V0LCBmb3JjZUNsZWFyICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggISAoIGNhbWVyYSAmJiBjYW1lcmEuaXNDYW1lcmEgKSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZW5kZXI6IGNhbWVyYSBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuQ2FtZXJhLicgKTtcXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggX2lzQ29udGV4dExvc3QgKSByZXR1cm47XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gcmVzZXQgY2FjaGluZyBmb3IgdGhpcyBmcmFtZVxcclxcblxcclxcblxcdFxcdFxcdF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtID0gJyc7XFxyXFxuXFx0XFx0XFx0X2N1cnJlbnRNYXRlcmlhbElkID0gLSAxO1xcclxcblxcdFxcdFxcdF9jdXJyZW50Q2FtZXJhID0gbnVsbDtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyB1cGRhdGUgc2NlbmUgZ3JhcGhcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHNjZW5lLmF1dG9VcGRhdGUgPT09IHRydWUgKSBzY2VuZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xcclxcblxcclxcblxcdFxcdFxcdC8vIHVwZGF0ZSBjYW1lcmEgbWF0cmljZXMgYW5kIGZydXN0dW1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGNhbWVyYS5wYXJlbnQgPT09IG51bGwgKSBjYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHZyLmVuYWJsZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y2FtZXJhID0gdnIuZ2V0Q2FtZXJhKCBjYW1lcmEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0X3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcXHJcXG5cXHRcXHRcXHRfZnJ1c3R1bS5zZXRGcm9tTWF0cml4KCBfcHJvalNjcmVlbk1hdHJpeCApO1xcclxcblxcclxcblxcdFxcdFxcdGxpZ2h0c0FycmF5Lmxlbmd0aCA9IDA7XFxyXFxuXFx0XFx0XFx0c2hhZG93c0FycmF5Lmxlbmd0aCA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0c3ByaXRlc0FycmF5Lmxlbmd0aCA9IDA7XFxyXFxuXFx0XFx0XFx0ZmxhcmVzQXJyYXkubGVuZ3RoID0gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRfbG9jYWxDbGlwcGluZ0VuYWJsZWQgPSB0aGlzLmxvY2FsQ2xpcHBpbmdFbmFibGVkO1xcclxcblxcdFxcdFxcdF9jbGlwcGluZ0VuYWJsZWQgPSBfY2xpcHBpbmcuaW5pdCggdGhpcy5jbGlwcGluZ1BsYW5lcywgX2xvY2FsQ2xpcHBpbmdFbmFibGVkLCBjYW1lcmEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjdXJyZW50UmVuZGVyTGlzdCA9IHJlbmRlckxpc3RzLmdldCggc2NlbmUsIGNhbWVyYSApO1xcclxcblxcdFxcdFxcdGN1cnJlbnRSZW5kZXJMaXN0LmluaXQoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRwcm9qZWN0T2JqZWN0KCBzY2VuZSwgY2FtZXJhLCBfdGhpcy5zb3J0T2JqZWN0cyApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggX3RoaXMuc29ydE9iamVjdHMgPT09IHRydWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y3VycmVudFJlbmRlckxpc3Quc29ydCgpO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvL1xcclxcblxcclxcblxcdFxcdFxcdHRleHR1cmVzLnVwZGF0ZVZpZGVvVGV4dHVyZXMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvL1xcclxcblxcclxcblxcdFxcdFxcdGlmICggX2NsaXBwaW5nRW5hYmxlZCApIF9jbGlwcGluZy5iZWdpblNoYWRvd3MoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRzaGFkb3dNYXAucmVuZGVyKCBzaGFkb3dzQXJyYXksIHNjZW5lLCBjYW1lcmEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRsaWdodHMuc2V0dXAoIGxpZ2h0c0FycmF5LCBzaGFkb3dzQXJyYXksIGNhbWVyYSApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggX2NsaXBwaW5nRW5hYmxlZCApIF9jbGlwcGluZy5lbmRTaGFkb3dzKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly9cXHJcXG5cXHJcXG5cXHRcXHRcXHRfaW5mb1JlbmRlci5mcmFtZSArKztcXHJcXG5cXHRcXHRcXHRfaW5mb1JlbmRlci5jYWxscyA9IDA7XFxyXFxuXFx0XFx0XFx0X2luZm9SZW5kZXIudmVydGljZXMgPSAwO1xcclxcblxcdFxcdFxcdF9pbmZvUmVuZGVyLmZhY2VzID0gMDtcXHJcXG5cXHRcXHRcXHRfaW5mb1JlbmRlci5wb2ludHMgPSAwO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggcmVuZGVyVGFyZ2V0ID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmVuZGVyVGFyZ2V0ID0gbnVsbDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5zZXRSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xcclxcblxcclxcblxcdFxcdFxcdC8vXFxyXFxuXFxyXFxuXFx0XFx0XFx0YmFja2dyb3VuZC5yZW5kZXIoIGN1cnJlbnRSZW5kZXJMaXN0LCBzY2VuZSwgY2FtZXJhLCBmb3JjZUNsZWFyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gcmVuZGVyIHNjZW5lXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG9wYXF1ZU9iamVjdHMgPSBjdXJyZW50UmVuZGVyTGlzdC5vcGFxdWU7XFxyXFxuXFx0XFx0XFx0dmFyIHRyYW5zcGFyZW50T2JqZWN0cyA9IGN1cnJlbnRSZW5kZXJMaXN0LnRyYW5zcGFyZW50O1xcclxcblxcclxcblxcdFxcdFxcdGlmICggc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgb3ZlcnJpZGVNYXRlcmlhbCA9IHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBvcGFxdWVPYmplY3RzLmxlbmd0aCApIHJlbmRlck9iamVjdHMoIG9wYXF1ZU9iamVjdHMsIHNjZW5lLCBjYW1lcmEsIG92ZXJyaWRlTWF0ZXJpYWwgKTtcXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHRyYW5zcGFyZW50T2JqZWN0cy5sZW5ndGggKSByZW5kZXJPYmplY3RzKCB0cmFuc3BhcmVudE9iamVjdHMsIHNjZW5lLCBjYW1lcmEsIG92ZXJyaWRlTWF0ZXJpYWwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIG9wYXF1ZSBwYXNzIChmcm9udC10by1iYWNrIG9yZGVyKVxcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggb3BhcXVlT2JqZWN0cy5sZW5ndGggKSByZW5kZXJPYmplY3RzKCBvcGFxdWVPYmplY3RzLCBzY2VuZSwgY2FtZXJhICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gdHJhbnNwYXJlbnQgcGFzcyAoYmFjay10by1mcm9udCBvcmRlcilcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHRyYW5zcGFyZW50T2JqZWN0cy5sZW5ndGggKSByZW5kZXJPYmplY3RzKCB0cmFuc3BhcmVudE9iamVjdHMsIHNjZW5lLCBjYW1lcmEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gY3VzdG9tIHJlbmRlcmVyc1xcclxcblxcclxcblxcdFxcdFxcdHNwcml0ZVJlbmRlcmVyLnJlbmRlciggc3ByaXRlc0FycmF5LCBzY2VuZSwgY2FtZXJhICk7XFxyXFxuXFx0XFx0XFx0ZmxhcmVSZW5kZXJlci5yZW5kZXIoIGZsYXJlc0FycmF5LCBzY2VuZSwgY2FtZXJhLCBfY3VycmVudFZpZXdwb3J0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gR2VuZXJhdGUgbWlwbWFwIGlmIHdlJ3JlIHVzaW5nIGFueSBraW5kIG9mIG1pcG1hcCBmaWx0ZXJpbmdcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHJlbmRlclRhcmdldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlcy51cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAoIHJlbmRlclRhcmdldCApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBFbnN1cmUgZGVwdGggYnVmZmVyIHdyaXRpbmcgaXMgZW5hYmxlZCBzbyBpdCBjYW4gYmUgY2xlYXJlZCBvbiBuZXh0IHJlbmRlclxcclxcblxcclxcblxcdFxcdFxcdHN0YXRlLmJ1ZmZlcnMuZGVwdGguc2V0VGVzdCggdHJ1ZSApO1xcclxcblxcdFxcdFxcdHN0YXRlLmJ1ZmZlcnMuZGVwdGguc2V0TWFzayggdHJ1ZSApO1xcclxcblxcdFxcdFxcdHN0YXRlLmJ1ZmZlcnMuY29sb3Iuc2V0TWFzayggdHJ1ZSApO1xcclxcblxcclxcblxcdFxcdFxcdHN0YXRlLnNldFBvbHlnb25PZmZzZXQoIGZhbHNlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB2ci5lbmFibGVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZyLnN1Ym1pdEZyYW1lKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdC8vIF9nbC5maW5pc2goKTtcXHJcXG5cXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdFxcdC8qXFxyXFxuXFx0XFx0Ly8gVE9ETyBEdXBsaWNhdGVkIGNvZGUgKEZydXN0dW0pXFxyXFxuXFxyXFxuXFx0XFx0dmFyIF9zcGhlcmUgPSBuZXcgU3BoZXJlKCk7XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gaXNPYmplY3RWaWV3YWJsZSggb2JqZWN0ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsIClcXHJcXG5cXHRcXHRcXHRcXHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRfc3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICkuXFxyXFxuXFx0XFx0XFx0YXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gaXNTcGhlcmVWaWV3YWJsZSggX3NwaGVyZSApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBpc1Nwcml0ZVZpZXdhYmxlKCBzcHJpdGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0X3NwaGVyZS5jZW50ZXIuc2V0KCAwLCAwLCAwICk7XFxyXFxuXFx0XFx0XFx0X3NwaGVyZS5yYWRpdXMgPSAwLjcwNzEwNjc4MTE4NjU0NzY7XFxyXFxuXFx0XFx0XFx0X3NwaGVyZS5hcHBseU1hdHJpeDQoIHNwcml0ZS5tYXRyaXhXb3JsZCApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBpc1NwaGVyZVZpZXdhYmxlKCBfc3BoZXJlICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIGlzU3BoZXJlVmlld2FibGUoIHNwaGVyZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoICEgX2ZydXN0dW0uaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkgKSByZXR1cm4gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG51bVBsYW5lcyA9IF9jbGlwcGluZy5udW1QbGFuZXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBudW1QbGFuZXMgPT09IDAgKSByZXR1cm4gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcGxhbmVzID0gX3RoaXMuY2xpcHBpbmdQbGFuZXMsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y2VudGVyID0gc3BoZXJlLmNlbnRlcixcXHJcXG5cXHRcXHRcXHRcXHRuZWdSYWQgPSAtIHNwaGVyZS5yYWRpdXMsXFxyXFxuXFx0XFx0XFx0XFx0aSA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZG8ge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIG91dCB3aGVuIGRlZXBlciB0aGFuIHJhZGl1cyBpbiB0aGUgbmVnYXRpdmUgaGFsZnNwYWNlXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBwbGFuZXNbIGkgXS5kaXN0YW5jZVRvUG9pbnQoIGNlbnRlciApIDwgbmVnUmFkICkgcmV0dXJuIGZhbHNlO1xcclxcblxcclxcblxcdFxcdFxcdH0gd2hpbGUgKCArKyBpICE9PSBudW1QbGFuZXMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFx0XFx0Ki9cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBwcm9qZWN0T2JqZWN0KCBvYmplY3QsIGNhbWVyYSwgc29ydE9iamVjdHMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBvYmplY3QudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHZpc2libGUgPSBvYmplY3QubGF5ZXJzLnRlc3QoIGNhbWVyYS5sYXllcnMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHZpc2libGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBvYmplY3QuaXNMaWdodCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRsaWdodHNBcnJheS5wdXNoKCBvYmplY3QgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG9iamVjdC5jYXN0U2hhZG93ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHNoYWRvd3NBcnJheS5wdXNoKCBvYmplY3QgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggb2JqZWN0LmlzU3ByaXRlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggISBvYmplY3QuZnJ1c3R1bUN1bGxlZCB8fCBfZnJ1c3R1bS5pbnRlcnNlY3RzU3ByaXRlKCBvYmplY3QgKSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRzcHJpdGVzQXJyYXkucHVzaCggb2JqZWN0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIG9iamVjdC5pc0xlbnNGbGFyZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmbGFyZXNBcnJheS5wdXNoKCBvYmplY3QgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBvYmplY3QuaXNJbW1lZGlhdGVSZW5kZXJPYmplY3QgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBzb3J0T2JqZWN0cyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG9iamVjdC5tYXRyaXhXb3JsZCApXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0LmFwcGx5TWF0cml4NCggX3Byb2pTY3JlZW5NYXRyaXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y3VycmVudFJlbmRlckxpc3QucHVzaCggb2JqZWN0LCBudWxsLCBvYmplY3QubWF0ZXJpYWwsIF92ZWN0b3IzLnosIG51bGwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBvYmplY3QuaXNNZXNoIHx8IG9iamVjdC5pc0xpbmUgfHwgb2JqZWN0LmlzUG9pbnRzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggb2JqZWN0LmlzU2tpbm5lZE1lc2ggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0LnNrZWxldG9uLnVwZGF0ZSgpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoICEgb2JqZWN0LmZydXN0dW1DdWxsZWQgfHwgX2ZydXN0dW0uaW50ZXJzZWN0c09iamVjdCggb2JqZWN0ICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBzb3J0T2JqZWN0cyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG9iamVjdC5tYXRyaXhXb3JsZCApXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0LmFwcGx5TWF0cml4NCggX3Byb2pTY3JlZW5NYXRyaXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0cy51cGRhdGUoIG9iamVjdCApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIEFycmF5LmlzQXJyYXkoIG1hdGVyaWFsICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBncm91cHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgZ3JvdXAgPSBncm91cHNbIGkgXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsWyBncm91cC5tYXRlcmlhbEluZGV4IF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBncm91cE1hdGVyaWFsICYmIGdyb3VwTWF0ZXJpYWwudmlzaWJsZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjdXJyZW50UmVuZGVyTGlzdC5wdXNoKCBvYmplY3QsIGdlb21ldHJ5LCBncm91cE1hdGVyaWFsLCBfdmVjdG9yMy56LCBncm91cCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICggbWF0ZXJpYWwudmlzaWJsZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjdXJyZW50UmVuZGVyTGlzdC5wdXNoKCBvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgX3ZlY3RvcjMueiwgbnVsbCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRwcm9qZWN0T2JqZWN0KCBjaGlsZHJlblsgaSBdLCBjYW1lcmEsIHNvcnRPYmplY3RzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiByZW5kZXJPYmplY3RzKCByZW5kZXJMaXN0LCBzY2VuZSwgY2FtZXJhLCBvdmVycmlkZU1hdGVyaWFsICkge1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHJlbmRlckxpc3QubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgcmVuZGVySXRlbSA9IHJlbmRlckxpc3RbIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgb2JqZWN0ID0gcmVuZGVySXRlbS5vYmplY3Q7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGdlb21ldHJ5ID0gcmVuZGVySXRlbS5nZW9tZXRyeTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgbWF0ZXJpYWwgPSBvdmVycmlkZU1hdGVyaWFsID09PSB1bmRlZmluZWQgPyByZW5kZXJJdGVtLm1hdGVyaWFsIDogb3ZlcnJpZGVNYXRlcmlhbDtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgZ3JvdXAgPSByZW5kZXJJdGVtLmdyb3VwO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggY2FtZXJhLmlzQXJyYXlDYW1lcmEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0X2N1cnJlbnRBcnJheUNhbWVyYSA9IGNhbWVyYTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgY2FtZXJhcyA9IGNhbWVyYS5jYW1lcmFzO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBqID0gMCwgamwgPSBjYW1lcmFzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBjYW1lcmEyID0gY2FtZXJhc1sgaiBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggb2JqZWN0LmxheWVycy50ZXN0KCBjYW1lcmEyLmxheWVycyApICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBib3VuZHMgPSBjYW1lcmEyLmJvdW5kcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgeCA9IGJvdW5kcy54ICogX3dpZHRoO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciB5ID0gYm91bmRzLnkgKiBfaGVpZ2h0O1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciB3aWR0aCA9IGJvdW5kcy56ICogX3dpZHRoO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBoZWlnaHQgPSBib3VuZHMudyAqIF9oZWlnaHQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c3RhdGUudmlld3BvcnQoIF9jdXJyZW50Vmlld3BvcnQuc2V0KCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkubXVsdGlwbHlTY2FsYXIoIF9waXhlbFJhdGlvICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZW5kZXJPYmplY3QoIG9iamVjdCwgc2NlbmUsIGNhbWVyYTIsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0X2N1cnJlbnRBcnJheUNhbWVyYSA9IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmVuZGVyT2JqZWN0KCBvYmplY3QsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiByZW5kZXJPYmplY3QoIG9iamVjdCwgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRvYmplY3Qub25CZWZvcmVSZW5kZXIoIF90aGlzLCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0b2JqZWN0Lm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBvYmplY3QubWF0cml4V29ybGQgKTtcXHJcXG5cXHRcXHRcXHRvYmplY3Qubm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggb2JqZWN0Lm1vZGVsVmlld01hdHJpeCApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggb2JqZWN0LmlzSW1tZWRpYXRlUmVuZGVyT2JqZWN0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBmcm9udEZhY2VDVyA9ICggb2JqZWN0LmlzTWVzaCAmJiBvYmplY3QubWF0cml4V29ybGQuZGV0ZXJtaW5hbnQoKSA8IDAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzdGF0ZS5zZXRNYXRlcmlhbCggbWF0ZXJpYWwsIGZyb250RmFjZUNXICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHByb2dyYW0gPSBzZXRQcm9ncmFtKCBjYW1lcmEsIHNjZW5lLmZvZywgbWF0ZXJpYWwsIG9iamVjdCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtID0gJyc7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmVuZGVyT2JqZWN0SW1tZWRpYXRlKCBvYmplY3QsIHByb2dyYW0sIG1hdGVyaWFsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRfdGhpcy5yZW5kZXJCdWZmZXJEaXJlY3QoIGNhbWVyYSwgc2NlbmUuZm9nLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0b2JqZWN0Lm9uQWZ0ZXJSZW5kZXIoIF90aGlzLCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIGluaXRNYXRlcmlhbCggbWF0ZXJpYWwsIGZvZywgb2JqZWN0ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBtYXRlcmlhbFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggbWF0ZXJpYWwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcGFyYW1ldGVycyA9IHByb2dyYW1DYWNoZS5nZXRQYXJhbWV0ZXJzKFxcclxcblxcdFxcdFxcdFxcdG1hdGVyaWFsLCBsaWdodHMuc3RhdGUsIHNoYWRvd3NBcnJheSwgZm9nLCBfY2xpcHBpbmcubnVtUGxhbmVzLCBfY2xpcHBpbmcubnVtSW50ZXJzZWN0aW9uLCBvYmplY3QgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgY29kZSA9IHByb2dyYW1DYWNoZS5nZXRQcm9ncmFtQ29kZSggbWF0ZXJpYWwsIHBhcmFtZXRlcnMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcHJvZ3JhbSA9IG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtO1xcclxcblxcdFxcdFxcdHZhciBwcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBuZXcgbWF0ZXJpYWxcXHJcXG5cXHRcXHRcXHRcXHRtYXRlcmlhbC5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uTWF0ZXJpYWxEaXNwb3NlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggcHJvZ3JhbS5jb2RlICE9PSBjb2RlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGNoYW5nZWQgZ2xzbCBvciBwYXJhbWV0ZXJzXFxyXFxuXFx0XFx0XFx0XFx0cmVsZWFzZU1hdGVyaWFsUHJvZ3JhbVJlZmVyZW5jZSggbWF0ZXJpYWwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBwYXJhbWV0ZXJzLnNoYWRlcklEICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gc2FtZSBnbHNsIGFuZCB1bmlmb3JtIGxpc3RcXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBvbmx5IHJlYnVpbGQgdW5pZm9ybSBsaXN0XFxyXFxuXFx0XFx0XFx0XFx0cHJvZ3JhbUNoYW5nZSA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHByb2dyYW1DaGFuZ2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBwYXJhbWV0ZXJzLnNoYWRlcklEICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBzaGFkZXIgPSBTaGFkZXJMaWJbIHBhcmFtZXRlcnMuc2hhZGVySUQgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRtYXRlcmlhbFByb3BlcnRpZXMuc2hhZGVyID0ge1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdG5hbWU6IG1hdGVyaWFsLnR5cGUsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dW5pZm9ybXM6IFVuaWZvcm1zVXRpbHMuY2xvbmUoIHNoYWRlci51bmlmb3JtcyApLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHZlcnRleFNoYWRlcjogc2hhZGVyLnZlcnRleFNoYWRlcixcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRmcmFnbWVudFNoYWRlcjogc2hhZGVyLmZyYWdtZW50U2hhZGVyXFxyXFxuXFx0XFx0XFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsUHJvcGVydGllcy5zaGFkZXIgPSB7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0bmFtZTogbWF0ZXJpYWwudHlwZSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR1bmlmb3JtczogbWF0ZXJpYWwudW5pZm9ybXMsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmVydGV4U2hhZGVyOiBtYXRlcmlhbC52ZXJ0ZXhTaGFkZXIsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZnJhZ21lbnRTaGFkZXI6IG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyXFxyXFxuXFx0XFx0XFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bWF0ZXJpYWwub25CZWZvcmVDb21waWxlKCBtYXRlcmlhbFByb3BlcnRpZXMuc2hhZGVyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cHJvZ3JhbSA9IHByb2dyYW1DYWNoZS5hY3F1aXJlUHJvZ3JhbSggbWF0ZXJpYWwsIG1hdGVyaWFsUHJvcGVydGllcy5zaGFkZXIsIHBhcmFtZXRlcnMsIGNvZGUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbSA9IHByb2dyYW07XFxyXFxuXFx0XFx0XFx0XFx0bWF0ZXJpYWwucHJvZ3JhbSA9IHByb2dyYW07XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHZhciBwcm9ncmFtQXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwubW9ycGhUYXJnZXRzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoVGFyZ2V0cyA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgX3RoaXMubWF4TW9ycGhUYXJnZXRzOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggcHJvZ3JhbUF0dHJpYnV0ZXNbICdtb3JwaFRhcmdldCcgKyBpIF0gPj0gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXRlcmlhbC5udW1TdXBwb3J0ZWRNb3JwaFRhcmdldHMgKys7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhOb3JtYWxzID0gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBfdGhpcy5tYXhNb3JwaE5vcm1hbHM7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBwcm9ncmFtQXR0cmlidXRlc1sgJ21vcnBoTm9ybWFsJyArIGkgXSA+PSAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoTm9ybWFscyArKztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdW5pZm9ybXMgPSBtYXRlcmlhbFByb3BlcnRpZXMuc2hhZGVyLnVuaWZvcm1zO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggISBtYXRlcmlhbC5pc1NoYWRlck1hdGVyaWFsICYmXFxyXFxuXFx0XFx0XFx0XFx0ISBtYXRlcmlhbC5pc1Jhd1NoYWRlck1hdGVyaWFsIHx8XFxyXFxuXFx0XFx0XFx0XFx0bWF0ZXJpYWwuY2xpcHBpbmcgPT09IHRydWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLm51bUNsaXBwaW5nUGxhbmVzID0gX2NsaXBwaW5nLm51bVBsYW5lcztcXHJcXG5cXHRcXHRcXHRcXHRtYXRlcmlhbFByb3BlcnRpZXMubnVtSW50ZXJzZWN0aW9uID0gX2NsaXBwaW5nLm51bUludGVyc2VjdGlvbjtcXHJcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5jbGlwcGluZ1BsYW5lcyA9IF9jbGlwcGluZy51bmlmb3JtO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRtYXRlcmlhbFByb3BlcnRpZXMuZm9nID0gZm9nO1xcclxcblxcclxcblxcdFxcdFxcdC8vIHN0b3JlIHRoZSBsaWdodCBzZXR1cCBpdCB3YXMgY3JlYXRlZCBmb3JcXHJcXG5cXHJcXG5cXHRcXHRcXHRtYXRlcmlhbFByb3BlcnRpZXMubGlnaHRzSGFzaCA9IGxpZ2h0cy5zdGF0ZS5oYXNoO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwubGlnaHRzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIHdpcmUgdXAgdGhlIG1hdGVyaWFsIHRvIHRoaXMgcmVuZGVyZXIncyBsaWdodGluZyBzdGF0ZVxcclxcblxcclxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmFtYmllbnRMaWdodENvbG9yLnZhbHVlID0gbGlnaHRzLnN0YXRlLmFtYmllbnQ7XFxyXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodHMudmFsdWUgPSBsaWdodHMuc3RhdGUuZGlyZWN0aW9uYWw7XFxyXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuc3BvdExpZ2h0cy52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5zcG90O1xcclxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLnJlY3RBcmVhTGlnaHRzLnZhbHVlID0gbGlnaHRzLnN0YXRlLnJlY3RBcmVhO1xcclxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLnBvaW50TGlnaHRzLnZhbHVlID0gbGlnaHRzLnN0YXRlLnBvaW50O1xcclxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodHMudmFsdWUgPSBsaWdodHMuc3RhdGUuaGVtaTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5kaXJlY3Rpb25hbFNoYWRvd01hcC52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5kaXJlY3Rpb25hbFNoYWRvd01hcDtcXHJcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5kaXJlY3Rpb25hbFNoYWRvd01hdHJpeC52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5kaXJlY3Rpb25hbFNoYWRvd01hdHJpeDtcXHJcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5zcG90U2hhZG93TWFwLnZhbHVlID0gbGlnaHRzLnN0YXRlLnNwb3RTaGFkb3dNYXA7XFxyXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuc3BvdFNoYWRvd01hdHJpeC52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5zcG90U2hhZG93TWF0cml4O1xcclxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLnBvaW50U2hhZG93TWFwLnZhbHVlID0gbGlnaHRzLnN0YXRlLnBvaW50U2hhZG93TWFwO1xcclxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLnBvaW50U2hhZG93TWF0cml4LnZhbHVlID0gbGlnaHRzLnN0YXRlLnBvaW50U2hhZG93TWF0cml4O1xcclxcblxcdFxcdFxcdFxcdC8vIFRPRE8gKGFiZWxuYXRpb24pOiBhZGQgYXJlYSBsaWdodHMgc2hhZG93IGluZm8gdG8gdW5pZm9ybXNcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHByb2dVbmlmb3JtcyA9IG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtLmdldFVuaWZvcm1zKCksXFxyXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXNMaXN0ID1cXHJcXG5cXHRcXHRcXHRcXHRcXHRXZWJHTFVuaWZvcm1zLnNlcVdpdGhWYWx1ZSggcHJvZ1VuaWZvcm1zLnNlcSwgdW5pZm9ybXMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXNMaXN0ID0gdW5pZm9ybXNMaXN0O1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBzZXRQcm9ncmFtKCBjYW1lcmEsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRfdXNlZFRleHR1cmVVbml0cyA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG1hdGVyaWFsUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCBtYXRlcmlhbCApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggX2NsaXBwaW5nRW5hYmxlZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIF9sb2NhbENsaXBwaW5nRW5hYmxlZCB8fCBjYW1lcmEgIT09IF9jdXJyZW50Q2FtZXJhICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciB1c2VDYWNoZSA9XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FtZXJhID09PSBfY3VycmVudENhbWVyYSAmJlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsLmlkID09PSBfY3VycmVudE1hdGVyaWFsSWQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gd2UgbWlnaHQgd2FudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gd2l0aCBzb21lIENsaXBwaW5nR3JvdXBcXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBvYmplY3QgaW5zdGVhZCBvZiB0aGUgbWF0ZXJpYWwsIG9uY2UgaXQgYmVjb21lcyBmZWFzaWJsZVxcclxcblxcdFxcdFxcdFxcdFxcdC8vICgjODQ2NSwgIzgzNzkpXFxyXFxuXFx0XFx0XFx0XFx0XFx0X2NsaXBwaW5nLnNldFN0YXRlKFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsLmNsaXBwaW5nUGxhbmVzLCBtYXRlcmlhbC5jbGlwSW50ZXJzZWN0aW9uLCBtYXRlcmlhbC5jbGlwU2hhZG93cyxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYW1lcmEsIG1hdGVyaWFsUHJvcGVydGllcywgdXNlQ2FjaGUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwubmVlZHNVcGRhdGUgPT09IGZhbHNlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuZm9nICYmIG1hdGVyaWFsUHJvcGVydGllcy5mb2cgIT09IGZvZyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggbWF0ZXJpYWwubGlnaHRzICYmIG1hdGVyaWFsUHJvcGVydGllcy5saWdodHNIYXNoICE9PSBsaWdodHMuc3RhdGUuaGFzaCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggbWF0ZXJpYWxQcm9wZXJ0aWVzLm51bUNsaXBwaW5nUGxhbmVzICE9PSB1bmRlZmluZWQgJiZcXHJcXG5cXHRcXHRcXHRcXHRcXHQoIG1hdGVyaWFsUHJvcGVydGllcy5udW1DbGlwcGluZ1BsYW5lcyAhPT0gX2NsaXBwaW5nLm51bVBsYW5lcyB8fFxcclxcblxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsUHJvcGVydGllcy5udW1JbnRlcnNlY3Rpb24gIT09IF9jbGlwcGluZy5udW1JbnRlcnNlY3Rpb24gKSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLm5lZWRzVXBkYXRlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGluaXRNYXRlcmlhbCggbWF0ZXJpYWwsIGZvZywgb2JqZWN0ICk7XFxyXFxuXFx0XFx0XFx0XFx0bWF0ZXJpYWwubmVlZHNVcGRhdGUgPSBmYWxzZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHJlZnJlc2hQcm9ncmFtID0gZmFsc2U7XFxyXFxuXFx0XFx0XFx0dmFyIHJlZnJlc2hNYXRlcmlhbCA9IGZhbHNlO1xcclxcblxcdFxcdFxcdHZhciByZWZyZXNoTGlnaHRzID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHByb2dyYW0gPSBtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbSxcXHJcXG5cXHRcXHRcXHRcXHRwX3VuaWZvcm1zID0gcHJvZ3JhbS5nZXRVbmlmb3JtcygpLFxcclxcblxcdFxcdFxcdFxcdG1fdW5pZm9ybXMgPSBtYXRlcmlhbFByb3BlcnRpZXMuc2hhZGVyLnVuaWZvcm1zO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggc3RhdGUudXNlUHJvZ3JhbSggcHJvZ3JhbS5wcm9ncmFtICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmVmcmVzaFByb2dyYW0gPSB0cnVlO1xcclxcblxcdFxcdFxcdFxcdHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7XFxyXFxuXFx0XFx0XFx0XFx0cmVmcmVzaExpZ2h0cyA9IHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwuaWQgIT09IF9jdXJyZW50TWF0ZXJpYWxJZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRfY3VycmVudE1hdGVyaWFsSWQgPSBtYXRlcmlhbC5pZDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZWZyZXNoTWF0ZXJpYWwgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHJlZnJlc2hQcm9ncmFtIHx8IGNhbWVyYSAhPT0gX2N1cnJlbnRDYW1lcmEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAncHJvamVjdGlvbk1hdHJpeCcsIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBjYXBhYmlsaXRpZXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRwX3VuaWZvcm1zLnNldFZhbHVlKCBfZ2wsICdsb2dEZXB0aEJ1ZkZDJyxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQyLjAgLyAoIE1hdGgubG9nKCBjYW1lcmEuZmFyICsgMS4wICkgLyBNYXRoLkxOMiApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIEF2b2lkIHVubmVlZGVkIHVuaWZvcm0gdXBkYXRlcyBwZXIgQXJyYXlDYW1lcmEncyBzdWItY2FtZXJhXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBfY3VycmVudENhbWVyYSAhPT0gKCBfY3VycmVudEFycmF5Q2FtZXJhIHx8IGNhbWVyYSApICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdF9jdXJyZW50Q2FtZXJhID0gKCBfY3VycmVudEFycmF5Q2FtZXJhIHx8IGNhbWVyYSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIGxpZ2h0aW5nIHVuaWZvcm1zIGRlcGVuZCBvbiB0aGUgY2FtZXJhIHNvIGVuZm9yY2UgYW4gdXBkYXRlXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gbm93LCBpbiBjYXNlIHRoaXMgbWF0ZXJpYWwgc3VwcG9ydHMgbGlnaHRzIC0gb3IgbGF0ZXIsIHdoZW5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyB0aGUgbmV4dCBtYXRlcmlhbCB0aGF0IGRvZXMgZ2V0cyBhY3RpdmF0ZWQ6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmVmcmVzaE1hdGVyaWFsID0gdHJ1ZTtcXHRcXHQvLyBzZXQgdG8gdHJ1ZSBvbiBtYXRlcmlhbCBjaGFuZ2VcXHJcXG5cXHRcXHRcXHRcXHRcXHRyZWZyZXNoTGlnaHRzID0gdHJ1ZTtcXHRcXHQvLyByZW1haW5zIHNldCB1bnRpbCB1cGRhdGUgZG9uZVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBsb2FkIG1hdGVyaWFsIHNwZWNpZmljIHVuaWZvcm1zXFxyXFxuXFx0XFx0XFx0XFx0Ly8gKHNoYWRlciBtYXRlcmlhbCBhbHNvIGdldHMgdGhlbSBmb3IgdGhlIHNha2Ugb2YgZ2VuZXJpY2l0eSlcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIG1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgfHxcXHJcXG5cXHRcXHRcXHRcXHRcXHRtYXRlcmlhbC5pc01lc2hQaG9uZ01hdGVyaWFsIHx8XFxyXFxuXFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCB8fFxcclxcblxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsLmVudk1hcCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdUNhbVBvcyA9IHBfdW5pZm9ybXMubWFwLmNhbWVyYVBvc2l0aW9uO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggdUNhbVBvcyAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHVDYW1Qb3Muc2V0VmFsdWUoIF9nbCxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIG1hdGVyaWFsLmlzTWVzaFBob25nTWF0ZXJpYWwgfHxcXHJcXG5cXHRcXHRcXHRcXHRcXHRtYXRlcmlhbC5pc01lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcXHJcXG5cXHRcXHRcXHRcXHRcXHRtYXRlcmlhbC5pc01lc2hCYXNpY01hdGVyaWFsIHx8XFxyXFxuXFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCB8fFxcclxcblxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgfHxcXHJcXG5cXHRcXHRcXHRcXHRcXHRtYXRlcmlhbC5za2lubmluZyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRwX3VuaWZvcm1zLnNldFZhbHVlKCBfZ2wsICd2aWV3TWF0cml4JywgY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gc2tpbm5pbmcgdW5pZm9ybXMgbXVzdCBiZSBzZXQgZXZlbiBpZiBtYXRlcmlhbCBkaWRuJ3QgY2hhbmdlXFxyXFxuXFx0XFx0XFx0Ly8gYXV0by1zZXR0aW5nIG9mIHRleHR1cmUgdW5pdCBmb3IgYm9uZSB0ZXh0dXJlIG11c3QgZ28gYmVmb3JlIG90aGVyIHRleHR1cmVzXFxyXFxuXFx0XFx0XFx0Ly8gbm90IHN1cmUgd2h5LCBidXQgb3RoZXJ3aXNlIHdlaXJkIHRoaW5ncyBoYXBwZW5cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLnNraW5uaW5nICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHBfdW5pZm9ybXMuc2V0T3B0aW9uYWwoIF9nbCwgb2JqZWN0LCAnYmluZE1hdHJpeCcgKTtcXHJcXG5cXHRcXHRcXHRcXHRwX3VuaWZvcm1zLnNldE9wdGlvbmFsKCBfZ2wsIG9iamVjdCwgJ2JpbmRNYXRyaXhJbnZlcnNlJyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBza2VsZXRvbiA9IG9iamVjdC5za2VsZXRvbjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHNrZWxldG9uICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBib25lcyA9IHNrZWxldG9uLmJvbmVzO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggY2FwYWJpbGl0aWVzLmZsb2F0VmVydGV4VGV4dHVyZXMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBza2VsZXRvbi5ib25lVGV4dHVyZSA9PT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGxheW91dCAoMSBtYXRyaXggPSA0IHBpeGVscylcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyAgICAgIFJHQkEgUkdCQSBSR0JBIFJHQkEgKD0+IGNvbHVtbjEsIGNvbHVtbjIsIGNvbHVtbjMsIGNvbHVtbjQpXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gIHdpdGggIDh4OCAgcGl4ZWwgdGV4dHVyZSBtYXggICAxNiBib25lcyAqIDQgcGl4ZWxzID0gICg4ICogOClcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyAgICAgICAxNngxNiBwaXhlbCB0ZXh0dXJlIG1heCAgIDY0IGJvbmVzICogNCBwaXhlbHMgPSAoMTYgKiAxNilcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyAgICAgICAzMngzMiBwaXhlbCB0ZXh0dXJlIG1heCAgMjU2IGJvbmVzICogNCBwaXhlbHMgPSAoMzIgKiAzMilcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyAgICAgICA2NHg2NCBwaXhlbCB0ZXh0dXJlIG1heCAxMDI0IGJvbmVzICogNCBwaXhlbHMgPSAoNjQgKiA2NClcXHJcXG5cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgc2l6ZSA9IE1hdGguc3FydCggYm9uZXMubGVuZ3RoICogNCApOyAvLyA0IHBpeGVscyBuZWVkZWQgZm9yIDEgbWF0cml4XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2l6ZSA9IF9NYXRoLmNlaWxQb3dlck9mVHdvKCBzaXplICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2l6ZSA9IE1hdGgubWF4KCBzaXplLCA0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIHNpemUgKiBzaXplICogNCApOyAvLyA0IGZsb2F0cyBwZXIgUkdCQSBwaXhlbFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJvbmVNYXRyaWNlcy5zZXQoIHNrZWxldG9uLmJvbmVNYXRyaWNlcyApOyAvLyBjb3B5IGN1cnJlbnQgdmFsdWVzXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGJvbmVUZXh0dXJlID0gbmV3IERhdGFUZXh0dXJlKCBib25lTWF0cmljZXMsIHNpemUsIHNpemUsIFJHQkFGb3JtYXQsIEZsb2F0VHlwZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNrZWxldG9uLmJvbmVNYXRyaWNlcyA9IGJvbmVNYXRyaWNlcztcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRza2VsZXRvbi5ib25lVGV4dHVyZSA9IGJvbmVUZXh0dXJlO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNrZWxldG9uLmJvbmVUZXh0dXJlU2l6ZSA9IHNpemU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ2JvbmVUZXh0dXJlJywgc2tlbGV0b24uYm9uZVRleHR1cmUgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRwX3VuaWZvcm1zLnNldFZhbHVlKCBfZ2wsICdib25lVGV4dHVyZVNpemUnLCBza2VsZXRvbi5ib25lVGV4dHVyZVNpemUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHBfdW5pZm9ybXMuc2V0T3B0aW9uYWwoIF9nbCwgc2tlbGV0b24sICdib25lTWF0cmljZXMnICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCByZWZyZXNoTWF0ZXJpYWwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAndG9uZU1hcHBpbmdFeHBvc3VyZScsIF90aGlzLnRvbmVNYXBwaW5nRXhwb3N1cmUgKTtcXHJcXG5cXHRcXHRcXHRcXHRwX3VuaWZvcm1zLnNldFZhbHVlKCBfZ2wsICd0b25lTWFwcGluZ1doaXRlUG9pbnQnLCBfdGhpcy50b25lTWFwcGluZ1doaXRlUG9pbnQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIG1hdGVyaWFsLmxpZ2h0cyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyB0aGUgY3VycmVudCBtYXRlcmlhbCByZXF1aXJlcyBsaWdodGluZyBpbmZvXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gbm90ZTogYWxsIGxpZ2h0aW5nIHVuaWZvcm1zIGFyZSBhbHdheXMgc2V0IGNvcnJlY3RseVxcclxcblxcdFxcdFxcdFxcdFxcdC8vIHRoZXkgc2ltcGx5IHJlZmVyZW5jZSB0aGUgcmVuZGVyZXIncyBzdGF0ZSBmb3IgdGhlaXJcXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyB2YWx1ZXNcXHJcXG5cXHRcXHRcXHRcXHRcXHQvL1xcclxcblxcdFxcdFxcdFxcdFxcdC8vIHVzZSB0aGUgY3VycmVudCBtYXRlcmlhbCdzIC5uZWVkc1VwZGF0ZSBmbGFncyB0byBzZXRcXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyB0aGUgR0wgc3RhdGUgd2hlbiByZXF1aXJlZFxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdG1hcmtVbmlmb3Jtc0xpZ2h0c05lZWRzVXBkYXRlKCBtX3VuaWZvcm1zLCByZWZyZXNoTGlnaHRzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIHJlZnJlc2ggdW5pZm9ybXMgY29tbW9uIHRvIHNldmVyYWwgbWF0ZXJpYWxzXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBmb2cgJiYgbWF0ZXJpYWwuZm9nICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHJlZnJlc2hVbmlmb3Jtc0ZvZyggbV91bmlmb3JtcywgZm9nICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggbWF0ZXJpYWwuaXNNZXNoQmFzaWNNYXRlcmlhbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRyZWZyZXNoVW5pZm9ybXNDb21tb24oIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNNZXNoTGFtYmVydE1hdGVyaWFsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRyZWZyZXNoVW5pZm9ybXNMYW1iZXJ0KCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzTWVzaFBob25nTWF0ZXJpYWwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggbWF0ZXJpYWwuaXNNZXNoVG9vbk1hdGVyaWFsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHJlZnJlc2hVbmlmb3Jtc1Rvb24oIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZWZyZXNoVW5pZm9ybXNQaG9uZyggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRyZWZyZXNoVW5pZm9ybXNDb21tb24oIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5pc01lc2hQaHlzaWNhbE1hdGVyaWFsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHJlZnJlc2hVbmlmb3Jtc1BoeXNpY2FsKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmVmcmVzaFVuaWZvcm1zU3RhbmRhcmQoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzTWVzaERlcHRoTWF0ZXJpYWwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xcclxcblxcdFxcdFxcdFxcdFxcdHJlZnJlc2hVbmlmb3Jtc0RlcHRoKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzTWVzaERpc3RhbmNlTWF0ZXJpYWwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xcclxcblxcdFxcdFxcdFxcdFxcdHJlZnJlc2hVbmlmb3Jtc0Rpc3RhbmNlKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzTWVzaE5vcm1hbE1hdGVyaWFsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRyZWZyZXNoVW5pZm9ybXNOb3JtYWwoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNMaW5lQmFzaWNNYXRlcmlhbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRyZWZyZXNoVW5pZm9ybXNMaW5lKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggbWF0ZXJpYWwuaXNMaW5lRGFzaGVkTWF0ZXJpYWwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmVmcmVzaFVuaWZvcm1zRGFzaCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNQb2ludHNNYXRlcmlhbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRyZWZyZXNoVW5pZm9ybXNQb2ludHMoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNTaGFkb3dNYXRlcmlhbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRtX3VuaWZvcm1zLmNvbG9yLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XFxyXFxuXFx0XFx0XFx0XFx0XFx0bV91bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gUmVjdEFyZWFMaWdodCBUZXh0dXJlXFxyXFxuXFx0XFx0XFx0XFx0Ly8gVE9ETyAobXJkb29iKTogRmluZCBhIG5pY2VyIGltcGxlbWVudGF0aW9uXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBtX3VuaWZvcm1zLmx0Y01hdCAhPT0gdW5kZWZpbmVkICkgbV91bmlmb3Jtcy5sdGNNYXQudmFsdWUgPSBVbmlmb3Jtc0xpYi5MVENfTUFUX1RFWFRVUkU7XFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBtX3VuaWZvcm1zLmx0Y01hZyAhPT0gdW5kZWZpbmVkICkgbV91bmlmb3Jtcy5sdGNNYWcudmFsdWUgPSBVbmlmb3Jtc0xpYi5MVENfTUFHX1RFWFRVUkU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0V2ViR0xVbmlmb3Jtcy51cGxvYWQoXFxyXFxuXFx0XFx0XFx0XFx0XFx0X2dsLCBtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXNMaXN0LCBtX3VuaWZvcm1zLCBfdGhpcyApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBjb21tb24gbWF0cmljZXNcXHJcXG5cXHJcXG5cXHRcXHRcXHRwX3VuaWZvcm1zLnNldFZhbHVlKCBfZ2wsICdtb2RlbFZpZXdNYXRyaXgnLCBvYmplY3QubW9kZWxWaWV3TWF0cml4ICk7XFxyXFxuXFx0XFx0XFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAnbm9ybWFsTWF0cml4Jywgb2JqZWN0Lm5vcm1hbE1hdHJpeCApO1xcclxcblxcdFxcdFxcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ21vZGVsTWF0cml4Jywgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHByb2dyYW07XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdC8vIFVuaWZvcm1zIChyZWZyZXNoIHVuaWZvcm1zIG9iamVjdHMpXFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zQ29tbW9uKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5jb2xvciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwuZW1pc3NpdmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuZW1pc3NpdmUudmFsdWUuY29weSggbWF0ZXJpYWwuZW1pc3NpdmUgKS5tdWx0aXBseVNjYWxhciggbWF0ZXJpYWwuZW1pc3NpdmVJbnRlbnNpdHkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5tYXAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMubWFwLnZhbHVlID0gbWF0ZXJpYWwubWFwO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLmFscGhhTWFwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmFscGhhTWFwLnZhbHVlID0gbWF0ZXJpYWwuYWxwaGFNYXA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwuc3BlY3VsYXJNYXAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuc3BlY3VsYXJNYXAudmFsdWUgPSBtYXRlcmlhbC5zcGVjdWxhck1hcDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5lbnZNYXAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuZW52TWFwLnZhbHVlID0gbWF0ZXJpYWwuZW52TWFwO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGRvbid0IGZsaXAgQ3ViZVRleHR1cmUgZW52TWFwcywgZmxpcCBldmVyeXRoaW5nIGVsc2U6XFxyXFxuXFx0XFx0XFx0XFx0Ly8gIFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZSB3aWxsIGJlIGZsaXBwZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XFxyXFxuXFx0XFx0XFx0XFx0Ly8gIFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZS50ZXh0dXJlIHdpbGwgYmUgZmxpcHBlZCBiZWNhdXNlIGl0J3MgYSBUZXh0dXJlIGFuZCBOT1QgYSBDdWJlVGV4dHVyZVxcclxcblxcdFxcdFxcdFxcdC8vIHRoaXMgY2hlY2sgbXVzdCBiZSBoYW5kbGVkIGRpZmZlcmVudGx5LCBvciByZW1vdmVkIGVudGlyZWx5LCBpZiBXZWJHTFJlbmRlclRhcmdldEN1YmUgdXNlcyBhIEN1YmVUZXh0dXJlIGluIHRoZSBmdXR1cmVcXHJcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5mbGlwRW52TWFwLnZhbHVlID0gKCAhICggbWF0ZXJpYWwuZW52TWFwICYmIG1hdGVyaWFsLmVudk1hcC5pc0N1YmVUZXh0dXJlICkgKSA/IDEgOiAtIDE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMucmVmbGVjdGl2aXR5LnZhbHVlID0gbWF0ZXJpYWwucmVmbGVjdGl2aXR5O1xcclxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLnJlZnJhY3Rpb25SYXRpby52YWx1ZSA9IG1hdGVyaWFsLnJlZnJhY3Rpb25SYXRpbztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5saWdodE1hcCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5saWdodE1hcC52YWx1ZSA9IG1hdGVyaWFsLmxpZ2h0TWFwO1xcclxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmxpZ2h0TWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwubGlnaHRNYXBJbnRlbnNpdHk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwuYW9NYXAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuYW9NYXAudmFsdWUgPSBtYXRlcmlhbC5hb01hcDtcXHJcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5hb01hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmFvTWFwSW50ZW5zaXR5O1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyB1diByZXBlYXQgYW5kIG9mZnNldCBzZXR0aW5nIHByaW9yaXRpZXNcXHJcXG5cXHRcXHRcXHQvLyAxLiBjb2xvciBtYXBcXHJcXG5cXHRcXHRcXHQvLyAyLiBzcGVjdWxhciBtYXBcXHJcXG5cXHRcXHRcXHQvLyAzLiBub3JtYWwgbWFwXFxyXFxuXFx0XFx0XFx0Ly8gNC4gYnVtcCBtYXBcXHJcXG5cXHRcXHRcXHQvLyA1LiBhbHBoYSBtYXBcXHJcXG5cXHRcXHRcXHQvLyA2LiBlbWlzc2l2ZSBtYXBcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdXZTY2FsZU1hcDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLm1hcCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwubWFwO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLnNwZWN1bGFyTWFwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5zcGVjdWxhck1hcDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5ub3JtYWxNYXAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLm5vcm1hbE1hcDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5idW1wTWFwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5idW1wTWFwO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLnJvdWdobmVzc01hcCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwucm91Z2huZXNzTWFwO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLm1ldGFsbmVzc01hcCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwubWV0YWxuZXNzTWFwO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmFscGhhTWFwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5hbHBoYU1hcDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5lbWlzc2l2ZU1hcCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggdXZTY2FsZU1hcCAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB1dlNjYWxlTWFwLmlzV2ViR0xSZW5kZXJUYXJnZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dXZTY2FsZU1hcCA9IHV2U2NhbGVNYXAudGV4dHVyZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB1dlNjYWxlTWFwLm1hdHJpeEF1dG9VcGRhdGUgPT09IHRydWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIG9mZnNldCA9IHV2U2NhbGVNYXAub2Zmc2V0O1xcclxcblxcdFxcdFxcdFxcdFxcdHZhciByZXBlYXQgPSB1dlNjYWxlTWFwLnJlcGVhdDtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgcm90YXRpb24gPSB1dlNjYWxlTWFwLnJvdGF0aW9uO1xcclxcblxcdFxcdFxcdFxcdFxcdHZhciBjZW50ZXIgPSB1dlNjYWxlTWFwLmNlbnRlcjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR1dlNjYWxlTWFwLm1hdHJpeC5zZXRVdlRyYW5zZm9ybSggb2Zmc2V0LngsIG9mZnNldC55LCByZXBlYXQueCwgcmVwZWF0LnksIHJvdGF0aW9uLCBjZW50ZXIueCwgY2VudGVyLnkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMudXZUcmFuc2Zvcm0udmFsdWUuY29weSggdXZTY2FsZU1hcC5tYXRyaXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0xpbmUoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XFxyXFxuXFx0XFx0XFx0dW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0Rhc2goIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR1bmlmb3Jtcy5kYXNoU2l6ZS52YWx1ZSA9IG1hdGVyaWFsLmRhc2hTaXplO1xcclxcblxcdFxcdFxcdHVuaWZvcm1zLnRvdGFsU2l6ZS52YWx1ZSA9IG1hdGVyaWFsLmRhc2hTaXplICsgbWF0ZXJpYWwuZ2FwU2l6ZTtcXHJcXG5cXHRcXHRcXHR1bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IG1hdGVyaWFsLnNjYWxlO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQb2ludHMoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XFxyXFxuXFx0XFx0XFx0dW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XFxyXFxuXFx0XFx0XFx0dW5pZm9ybXMuc2l6ZS52YWx1ZSA9IG1hdGVyaWFsLnNpemUgKiBfcGl4ZWxSYXRpbztcXHJcXG5cXHRcXHRcXHR1bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IF9oZWlnaHQgKiAwLjU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dW5pZm9ybXMubWFwLnZhbHVlID0gbWF0ZXJpYWwubWFwO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwubWFwICE9PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggbWF0ZXJpYWwubWFwLm1hdHJpeEF1dG9VcGRhdGUgPT09IHRydWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIG9mZnNldCA9IG1hdGVyaWFsLm1hcC5vZmZzZXQ7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHJlcGVhdCA9IG1hdGVyaWFsLm1hcC5yZXBlYXQ7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHJvdGF0aW9uID0gbWF0ZXJpYWwubWFwLnJvdGF0aW9uO1xcclxcblxcdFxcdFxcdFxcdFxcdHZhciBjZW50ZXIgPSBtYXRlcmlhbC5tYXAuY2VudGVyO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsLm1hcC5tYXRyaXguc2V0VXZUcmFuc2Zvcm0oIG9mZnNldC54LCBvZmZzZXQueSwgcmVwZWF0LngsIHJlcGVhdC55LCByb3RhdGlvbiwgY2VudGVyLngsIGNlbnRlci55ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLnV2VHJhbnNmb3JtLnZhbHVlLmNvcHkoIG1hdGVyaWFsLm1hcC5tYXRyaXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0ZvZyggdW5pZm9ybXMsIGZvZyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR1bmlmb3Jtcy5mb2dDb2xvci52YWx1ZSA9IGZvZy5jb2xvcjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGZvZy5pc0ZvZyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5mb2dOZWFyLnZhbHVlID0gZm9nLm5lYXI7XFxyXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuZm9nRmFyLnZhbHVlID0gZm9nLmZhcjtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBmb2cuaXNGb2dFeHAyICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmZvZ0RlbnNpdHkudmFsdWUgPSBmb2cuZGVuc2l0eTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0xhbWJlcnQoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLmVtaXNzaXZlTWFwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmVtaXNzaXZlTWFwLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQaG9uZyggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xcclxcblxcclxcblxcdFxcdFxcdHVuaWZvcm1zLnNwZWN1bGFyLnZhbHVlID0gbWF0ZXJpYWwuc3BlY3VsYXI7XFxyXFxuXFx0XFx0XFx0dW5pZm9ybXMuc2hpbmluZXNzLnZhbHVlID0gTWF0aC5tYXgoIG1hdGVyaWFsLnNoaW5pbmVzcywgMWUtNCApOyAvLyB0byBwcmV2ZW50IHBvdyggMC4wLCAwLjAgKVxcclxcblxcclxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwuZW1pc3NpdmVNYXAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuZW1pc3NpdmVNYXAudmFsdWUgPSBtYXRlcmlhbC5lbWlzc2l2ZU1hcDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5idW1wTWFwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmJ1bXBNYXAudmFsdWUgPSBtYXRlcmlhbC5idW1wTWFwO1xcclxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmJ1bXBTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBTY2FsZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5ub3JtYWxNYXAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMubm9ybWFsTWFwLnZhbHVlID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xcclxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLm5vcm1hbFNjYWxlLnZhbHVlLmNvcHkoIG1hdGVyaWFsLm5vcm1hbFNjYWxlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcXHJcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlO1xcclxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmRpc3BsYWNlbWVudEJpYXMudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zVG9vbiggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xcclxcblxcclxcblxcdFxcdFxcdHJlZnJlc2hVbmlmb3Jtc1Bob25nKCB1bmlmb3JtcywgbWF0ZXJpYWwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLmdyYWRpZW50TWFwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmdyYWRpZW50TWFwLnZhbHVlID0gbWF0ZXJpYWwuZ3JhZGllbnRNYXA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNTdGFuZGFyZCggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xcclxcblxcclxcblxcdFxcdFxcdHVuaWZvcm1zLnJvdWdobmVzcy52YWx1ZSA9IG1hdGVyaWFsLnJvdWdobmVzcztcXHJcXG5cXHRcXHRcXHR1bmlmb3Jtcy5tZXRhbG5lc3MudmFsdWUgPSBtYXRlcmlhbC5tZXRhbG5lc3M7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5yb3VnaG5lc3NNYXAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMucm91Z2huZXNzTWFwLnZhbHVlID0gbWF0ZXJpYWwucm91Z2huZXNzTWFwO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLm1ldGFsbmVzc01hcCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5tZXRhbG5lc3NNYXAudmFsdWUgPSBtYXRlcmlhbC5tZXRhbG5lc3NNYXA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwuZW1pc3NpdmVNYXAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuZW1pc3NpdmVNYXAudmFsdWUgPSBtYXRlcmlhbC5lbWlzc2l2ZU1hcDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5idW1wTWFwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmJ1bXBNYXAudmFsdWUgPSBtYXRlcmlhbC5idW1wTWFwO1xcclxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmJ1bXBTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBTY2FsZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5ub3JtYWxNYXAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMubm9ybWFsTWFwLnZhbHVlID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xcclxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLm5vcm1hbFNjYWxlLnZhbHVlLmNvcHkoIG1hdGVyaWFsLm5vcm1hbFNjYWxlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcXHJcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlO1xcclxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmRpc3BsYWNlbWVudEJpYXMudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLmVudk1hcCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvL3VuaWZvcm1zLmVudk1hcC52YWx1ZSA9IG1hdGVyaWFsLmVudk1hcDsgLy8gcGFydCBvZiB1bmlmb3JtcyBjb21tb25cXHJcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5lbnZNYXBJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5lbnZNYXBJbnRlbnNpdHk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQaHlzaWNhbCggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xcclxcblxcclxcblxcdFxcdFxcdHVuaWZvcm1zLmNsZWFyQ29hdC52YWx1ZSA9IG1hdGVyaWFsLmNsZWFyQ29hdDtcXHJcXG5cXHRcXHRcXHR1bmlmb3Jtcy5jbGVhckNvYXRSb3VnaG5lc3MudmFsdWUgPSBtYXRlcmlhbC5jbGVhckNvYXRSb3VnaG5lc3M7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmVmcmVzaFVuaWZvcm1zU3RhbmRhcmQoIHVuaWZvcm1zLCBtYXRlcmlhbCApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNEZXB0aCggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcXHJcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlO1xcclxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmRpc3BsYWNlbWVudEJpYXMudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zRGlzdGFuY2UoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRNYXAudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XFxyXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50U2NhbGUudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZTtcXHJcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRCaWFzLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50QmlhcztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dW5pZm9ybXMucmVmZXJlbmNlUG9zaXRpb24udmFsdWUuY29weSggbWF0ZXJpYWwucmVmZXJlbmNlUG9zaXRpb24gKTtcXHJcXG5cXHRcXHRcXHR1bmlmb3Jtcy5uZWFyRGlzdGFuY2UudmFsdWUgPSBtYXRlcmlhbC5uZWFyRGlzdGFuY2U7XFxyXFxuXFx0XFx0XFx0dW5pZm9ybXMuZmFyRGlzdGFuY2UudmFsdWUgPSBtYXRlcmlhbC5mYXJEaXN0YW5jZTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTm9ybWFsKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5idW1wTWFwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmJ1bXBNYXAudmFsdWUgPSBtYXRlcmlhbC5idW1wTWFwO1xcclxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmJ1bXBTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBTY2FsZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5ub3JtYWxNYXAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMubm9ybWFsTWFwLnZhbHVlID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xcclxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLm5vcm1hbFNjYWxlLnZhbHVlLmNvcHkoIG1hdGVyaWFsLm5vcm1hbFNjYWxlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcXHJcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlO1xcclxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmRpc3BsYWNlbWVudEJpYXMudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0Ly8gSWYgdW5pZm9ybXMgYXJlIG1hcmtlZCBhcyBjbGVhbiwgdGhleSBkb24ndCBuZWVkIHRvIGJlIGxvYWRlZCB0byB0aGUgR1BVLlxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIG1hcmtVbmlmb3Jtc0xpZ2h0c05lZWRzVXBkYXRlKCB1bmlmb3JtcywgdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dW5pZm9ybXMuYW1iaWVudExpZ2h0Q29sb3IubmVlZHNVcGRhdGUgPSB2YWx1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xcclxcblxcdFxcdFxcdHVuaWZvcm1zLnBvaW50TGlnaHRzLm5lZWRzVXBkYXRlID0gdmFsdWU7XFxyXFxuXFx0XFx0XFx0dW5pZm9ybXMuc3BvdExpZ2h0cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xcclxcblxcdFxcdFxcdHVuaWZvcm1zLnJlY3RBcmVhTGlnaHRzLm5lZWRzVXBkYXRlID0gdmFsdWU7XFxyXFxuXFx0XFx0XFx0dW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHQvLyBHTCBzdGF0ZSBzZXR0aW5nXFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5zZXRGYWNlQ3VsbGluZyA9IGZ1bmN0aW9uICggY3VsbEZhY2UsIGZyb250RmFjZURpcmVjdGlvbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRzdGF0ZS5zZXRDdWxsRmFjZSggY3VsbEZhY2UgKTtcXHJcXG5cXHRcXHRcXHRzdGF0ZS5zZXRGbGlwU2lkZWQoIGZyb250RmFjZURpcmVjdGlvbiA9PT0gRnJvbnRGYWNlRGlyZWN0aW9uQ1cgKTtcXHJcXG5cXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdFxcdC8vIFRleHR1cmVzXFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gYWxsb2NUZXh0dXJlVW5pdCgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdGV4dHVyZVVuaXQgPSBfdXNlZFRleHR1cmVVbml0cztcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRleHR1cmVVbml0ID49IGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlcyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUcnlpbmcgdG8gdXNlICcgKyB0ZXh0dXJlVW5pdCArICcgdGV4dHVyZSB1bml0cyB3aGlsZSB0aGlzIEdQVSBzdXBwb3J0cyBvbmx5ICcgKyBjYXBhYmlsaXRpZXMubWF4VGV4dHVyZXMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0X3VzZWRUZXh0dXJlVW5pdHMgKz0gMTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGV4dHVyZVVuaXQ7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHRoaXMuYWxsb2NUZXh0dXJlVW5pdCA9IGFsbG9jVGV4dHVyZVVuaXQ7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gdGhpcy5zZXRUZXh0dXJlMkQgPSBzZXRUZXh0dXJlMkQ7XFxyXFxuXFx0XFx0dGhpcy5zZXRUZXh0dXJlMkQgPSAoIGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgd2FybmVkID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHk6IHBlZWwgdGV4dHVyZS50ZXh0dXJlXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHNldFRleHR1cmUyRCggdGV4dHVyZSwgc2xvdCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHRleHR1cmUgJiYgdGV4dHVyZS5pc1dlYkdMUmVuZGVyVGFyZ2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggISB3YXJuZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCBcXFwiVEhSRUUuV2ViR0xSZW5kZXJlci5zZXRUZXh0dXJlMkQ6IGRvbid0IHVzZSByZW5kZXIgdGFyZ2V0cyBhcyB0ZXh0dXJlcy4gVXNlIHRoZWlyIC50ZXh0dXJlIHByb3BlcnR5IGluc3RlYWQuXFxcIiApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHdhcm5lZCA9IHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHRleHR1cmUgPSB0ZXh0dXJlLnRleHR1cmU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHRleHR1cmVzLnNldFRleHR1cmUyRCggdGV4dHVyZSwgc2xvdCApO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5zZXRUZXh0dXJlID0gKCBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHdhcm5lZCA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBzZXRUZXh0dXJlKCB0ZXh0dXJlLCBzbG90ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggISB3YXJuZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCBcXFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNldFRleHR1cmUgaXMgZGVwcmVjYXRlZCwgdXNlIHNldFRleHR1cmUyRCBpbnN0ZWFkLlxcXCIgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR3YXJuZWQgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlcy5zZXRUZXh0dXJlMkQoIHRleHR1cmUsIHNsb3QgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0oKSApO1xcclxcblxcclxcblxcdFxcdHRoaXMuc2V0VGV4dHVyZUN1YmUgPSAoIGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgd2FybmVkID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHNldFRleHR1cmVDdWJlKCB0ZXh0dXJlLCBzbG90ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OiBwZWVsIHRleHR1cmUudGV4dHVyZVxcclxcblxcdFxcdFxcdFxcdGlmICggdGV4dHVyZSAmJiB0ZXh0dXJlLmlzV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggISB3YXJuZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCBcXFwiVEhSRUUuV2ViR0xSZW5kZXJlci5zZXRUZXh0dXJlQ3ViZTogZG9uJ3QgdXNlIGN1YmUgcmVuZGVyIHRhcmdldHMgYXMgdGV4dHVyZXMuIFVzZSB0aGVpciAudGV4dHVyZSBwcm9wZXJ0eSBpbnN0ZWFkLlxcXCIgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR3YXJuZWQgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlID0gdGV4dHVyZS50ZXh0dXJlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBjdXJyZW50bHkgcmVseWluZyBvbiB0aGUgZmFjdCB0aGF0IFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZS50ZXh0dXJlIGlzIGEgVGV4dHVyZSBhbmQgTk9UIGEgQ3ViZVRleHR1cmVcXHJcXG5cXHRcXHRcXHRcXHQvLyBUT0RPOiB1bmlmeSB0aGVzZSBjb2RlIHBhdGhzXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCAoIHRleHR1cmUgJiYgdGV4dHVyZS5pc0N1YmVUZXh0dXJlICkgfHxcXHJcXG5cXHRcXHRcXHRcXHRcXHQoIEFycmF5LmlzQXJyYXkoIHRleHR1cmUuaW1hZ2UgKSAmJiB0ZXh0dXJlLmltYWdlLmxlbmd0aCA9PT0gNiApICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIENvbXByZXNzZWRUZXh0dXJlIGNhbiBoYXZlIEFycmF5IGluIGltYWdlIDovXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdGhpcyBmdW5jdGlvbiBhbG9uZSBzaG91bGQgdGFrZSBjYXJlIG9mIGN1YmUgdGV4dHVyZXNcXHJcXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlcy5zZXRUZXh0dXJlQ3ViZSggdGV4dHVyZSwgc2xvdCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gYXNzdW1lZDogdGV4dHVyZSBwcm9wZXJ0eSBvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmVcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlcy5zZXRUZXh0dXJlQ3ViZUR5bmFtaWMoIHRleHR1cmUsIHNsb3QgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR9KCkgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmdldFJlbmRlclRhcmdldCA9IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gX2N1cnJlbnRSZW5kZXJUYXJnZXQ7XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnNldFJlbmRlclRhcmdldCA9IGZ1bmN0aW9uICggcmVuZGVyVGFyZ2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdF9jdXJyZW50UmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0O1xcclxcblxcclxcblxcdFxcdFxcdGlmICggcmVuZGVyVGFyZ2V0ICYmIHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKS5fX3dlYmdsRnJhbWVidWZmZXIgPT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlcy5zZXR1cFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHZhciBmcmFtZWJ1ZmZlciA9IG51bGw7XFxyXFxuXFx0XFx0XFx0dmFyIGlzQ3ViZSA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggcmVuZGVyVGFyZ2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBfX3dlYmdsRnJhbWVidWZmZXIgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICkuX193ZWJnbEZyYW1lYnVmZmVyO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggcmVuZGVyVGFyZ2V0LmlzV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGZyYW1lYnVmZmVyID0gX193ZWJnbEZyYW1lYnVmZmVyWyByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRpc0N1YmUgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0ZnJhbWVidWZmZXIgPSBfX3dlYmdsRnJhbWVidWZmZXI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdF9jdXJyZW50Vmlld3BvcnQuY29weSggcmVuZGVyVGFyZ2V0LnZpZXdwb3J0ICk7XFxyXFxuXFx0XFx0XFx0XFx0X2N1cnJlbnRTY2lzc29yLmNvcHkoIHJlbmRlclRhcmdldC5zY2lzc29yICk7XFxyXFxuXFx0XFx0XFx0XFx0X2N1cnJlbnRTY2lzc29yVGVzdCA9IHJlbmRlclRhcmdldC5zY2lzc29yVGVzdDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdF9jdXJyZW50Vmlld3BvcnQuY29weSggX3ZpZXdwb3J0ICkubXVsdGlwbHlTY2FsYXIoIF9waXhlbFJhdGlvICk7XFxyXFxuXFx0XFx0XFx0XFx0X2N1cnJlbnRTY2lzc29yLmNvcHkoIF9zY2lzc29yICkubXVsdGlwbHlTY2FsYXIoIF9waXhlbFJhdGlvICk7XFxyXFxuXFx0XFx0XFx0XFx0X2N1cnJlbnRTY2lzc29yVGVzdCA9IF9zY2lzc29yVGVzdDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBfY3VycmVudEZyYW1lYnVmZmVyICE9PSBmcmFtZWJ1ZmZlciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XFxyXFxuXFx0XFx0XFx0XFx0X2N1cnJlbnRGcmFtZWJ1ZmZlciA9IGZyYW1lYnVmZmVyO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRzdGF0ZS52aWV3cG9ydCggX2N1cnJlbnRWaWV3cG9ydCApO1xcclxcblxcdFxcdFxcdHN0YXRlLnNjaXNzb3IoIF9jdXJyZW50U2Npc3NvciApO1xcclxcblxcdFxcdFxcdHN0YXRlLnNldFNjaXNzb3JUZXN0KCBfY3VycmVudFNjaXNzb3JUZXN0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBpc0N1YmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldC50ZXh0dXJlICk7XFxyXFxuXFx0XFx0XFx0XFx0X2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUsIHJlbmRlclRhcmdldC5hY3RpdmVNaXBNYXBMZXZlbCApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdFxcdHRoaXMucmVhZFJlbmRlclRhcmdldFBpeGVscyA9IGZ1bmN0aW9uICggcmVuZGVyVGFyZ2V0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBidWZmZXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCAhICggcmVuZGVyVGFyZ2V0ICYmIHJlbmRlclRhcmdldC5pc1dlYkdMUmVuZGVyVGFyZ2V0ICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC4nICk7XFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgZnJhbWVidWZmZXIgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICkuX193ZWJnbEZyYW1lYnVmZmVyO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggZnJhbWVidWZmZXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHJlc3RvcmUgPSBmYWxzZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGZyYW1lYnVmZmVyICE9PSBfY3VycmVudEZyYW1lYnVmZmVyICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRyZXN0b3JlID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dHJ5IHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdGV4dHVyZSA9IHJlbmRlclRhcmdldC50ZXh0dXJlO1xcclxcblxcdFxcdFxcdFxcdFxcdHZhciB0ZXh0dXJlRm9ybWF0ID0gdGV4dHVyZS5mb3JtYXQ7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHRleHR1cmVUeXBlID0gdGV4dHVyZS50eXBlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggdGV4dHVyZUZvcm1hdCAhPT0gUkdCQUZvcm1hdCAmJiB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlRm9ybWF0ICkgIT09IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5JTVBMRU1FTlRBVElPTl9DT0xPUl9SRUFEX0ZPUk1BVCApICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgaW4gUkdCQSBvciBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIGZvcm1hdC4nICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHRleHR1cmVUeXBlICE9PSBVbnNpZ25lZEJ5dGVUeXBlICYmIHV0aWxzLmNvbnZlcnQoIHRleHR1cmVUeXBlICkgIT09IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5JTVBMRU1FTlRBVElPTl9DT0xPUl9SRUFEX1RZUEUgKSAmJiAvLyBJRTExLCBFZGdlIGFuZCBDaHJvbWUgTWFjIDwgNTIgKCM5NTEzKVxcclxcblxcdFxcdFxcdFxcdFxcdFxcdCEgKCB0ZXh0dXJlVHlwZSA9PT0gRmxvYXRUeXBlICYmICggZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdCcgKSB8fCBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdCcgKSApICkgJiYgLy8gQ2hyb21lIE1hYyA+PSA1MiBhbmQgRmlyZWZveFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdCEgKCB0ZXh0dXJlVHlwZSA9PT0gSGFsZkZsb2F0VHlwZSAmJiBleHRlbnNpb25zLmdldCggJ0VYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdCcgKSApICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgaW4gVW5zaWduZWRCeXRlVHlwZSBvciBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIHR5cGUuJyApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBfZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyggX2dsLkZSQU1FQlVGRkVSICkgPT09IF9nbC5GUkFNRUJVRkZFUl9DT01QTEVURSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyB0aGUgZm9sbG93aW5nIGlmIHN0YXRlbWVudCBlbnN1cmVzIHZhbGlkIHJlYWQgcmVxdWVzdHMgKG5vIG91dC1vZi1ib3VuZHMgcGl4ZWxzLCBzZWUgIzg2MDQpXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCAoIHggPj0gMCAmJiB4IDw9ICggcmVuZGVyVGFyZ2V0LndpZHRoIC0gd2lkdGggKSApICYmICggeSA+PSAwICYmIHkgPD0gKCByZW5kZXJUYXJnZXQuaGVpZ2h0IC0gaGVpZ2h0ICkgKSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRfZ2wucmVhZFBpeGVscyggeCwgeSwgd2lkdGgsIGhlaWdodCwgdXRpbHMuY29udmVydCggdGV4dHVyZUZvcm1hdCApLCB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlVHlwZSApLCBidWZmZXIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZWFkUGl4ZWxzIGZyb20gcmVuZGVyVGFyZ2V0IGZhaWxlZC4gRnJhbWVidWZmZXIgbm90IGNvbXBsZXRlLicgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBmaW5hbGx5IHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHJlc3RvcmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfY3VycmVudEZyYW1lYnVmZmVyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIEZvZ0V4cDIoIGNvbG9yLCBkZW5zaXR5ICkge1xcclxcblxcclxcblxcdFxcdHRoaXMubmFtZSA9ICcnO1xcclxcblxcclxcblxcdFxcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIGNvbG9yICk7XFxyXFxuXFx0XFx0dGhpcy5kZW5zaXR5ID0gKCBkZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGRlbnNpdHkgOiAwLjAwMDI1O1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRGb2dFeHAyLnByb3RvdHlwZS5pc0ZvZ0V4cDIgPSB0cnVlO1xcclxcblxcclxcblxcdEZvZ0V4cDIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdHJldHVybiBuZXcgRm9nRXhwMiggdGhpcy5jb2xvci5nZXRIZXgoKSwgdGhpcy5kZW5zaXR5ICk7XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHRGb2dFeHAyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoIC8qIG1ldGEgKi8gKSB7XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHtcXHJcXG5cXHRcXHRcXHR0eXBlOiAnRm9nRXhwMicsXFxyXFxuXFx0XFx0XFx0Y29sb3I6IHRoaXMuY29sb3IuZ2V0SGV4KCksXFxyXFxuXFx0XFx0XFx0ZGVuc2l0eTogdGhpcy5kZW5zaXR5XFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHR9O1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBGb2coIGNvbG9yLCBuZWFyLCBmYXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5uYW1lID0gJyc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggY29sb3IgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm5lYXIgPSAoIG5lYXIgIT09IHVuZGVmaW5lZCApID8gbmVhciA6IDE7XFxyXFxuXFx0XFx0dGhpcy5mYXIgPSAoIGZhciAhPT0gdW5kZWZpbmVkICkgPyBmYXIgOiAxMDAwO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRGb2cucHJvdG90eXBlLmlzRm9nID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRGb2cucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdHJldHVybiBuZXcgRm9nKCB0aGlzLmNvbG9yLmdldEhleCgpLCB0aGlzLm5lYXIsIHRoaXMuZmFyICk7XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHRGb2cucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggLyogbWV0YSAqLyApIHtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4ge1xcclxcblxcdFxcdFxcdHR5cGU6ICdGb2cnLFxcclxcblxcdFxcdFxcdGNvbG9yOiB0aGlzLmNvbG9yLmdldEhleCgpLFxcclxcblxcdFxcdFxcdG5lYXI6IHRoaXMubmVhcixcXHJcXG5cXHRcXHRcXHRmYXI6IHRoaXMuZmFyXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHR9O1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gU2NlbmUoKSB7XFxyXFxuXFxyXFxuXFx0XFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdTY2VuZSc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5iYWNrZ3JvdW5kID0gbnVsbDtcXHJcXG5cXHRcXHR0aGlzLmZvZyA9IG51bGw7XFxyXFxuXFx0XFx0dGhpcy5vdmVycmlkZU1hdGVyaWFsID0gbnVsbDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmF1dG9VcGRhdGUgPSB0cnVlOyAvLyBjaGVja2VkIGJ5IHRoZSByZW5kZXJlclxcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRTY2VuZS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xcclxcblxcclxcblxcdFxcdGNvbnN0cnVjdG9yOiBTY2VuZSxcXHJcXG5cXHJcXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xcclxcblxcclxcblxcdFxcdFxcdE9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSwgcmVjdXJzaXZlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBzb3VyY2UuYmFja2dyb3VuZCAhPT0gbnVsbCApIHRoaXMuYmFja2dyb3VuZCA9IHNvdXJjZS5iYWNrZ3JvdW5kLmNsb25lKCk7XFxyXFxuXFx0XFx0XFx0aWYgKCBzb3VyY2UuZm9nICE9PSBudWxsICkgdGhpcy5mb2cgPSBzb3VyY2UuZm9nLmNsb25lKCk7XFxyXFxuXFx0XFx0XFx0aWYgKCBzb3VyY2Uub3ZlcnJpZGVNYXRlcmlhbCAhPT0gbnVsbCApIHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IHNvdXJjZS5vdmVycmlkZU1hdGVyaWFsLmNsb25lKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5hdXRvVXBkYXRlID0gc291cmNlLmF1dG9VcGRhdGU7XFxyXFxuXFx0XFx0XFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHR0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgZGF0YSA9IE9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5iYWNrZ3JvdW5kICE9PSBudWxsICkgZGF0YS5vYmplY3QuYmFja2dyb3VuZCA9IHRoaXMuYmFja2dyb3VuZC50b0pTT04oIG1ldGEgKTtcXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMuZm9nICE9PSBudWxsICkgZGF0YS5vYmplY3QuZm9nID0gdGhpcy5mb2cudG9KU09OKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGRhdGE7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xcclxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gTGVuc0ZsYXJlKCB0ZXh0dXJlLCBzaXplLCBkaXN0YW5jZSwgYmxlbmRpbmcsIGNvbG9yICkge1xcclxcblxcclxcblxcdFxcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmxlbnNGbGFyZXMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnBvc2l0aW9uU2NyZWVuID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHRcXHR0aGlzLmN1c3RvbVVwZGF0ZUNhbGxiYWNrID0gdW5kZWZpbmVkO1xcclxcblxcclxcblxcdFxcdGlmICggdGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuYWRkKCB0ZXh0dXJlLCBzaXplLCBkaXN0YW5jZSwgYmxlbmRpbmcsIGNvbG9yICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRMZW5zRmxhcmUucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICksIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zdHJ1Y3RvcjogTGVuc0ZsYXJlLFxcclxcblxcclxcblxcdFxcdGlzTGVuc0ZsYXJlOiB0cnVlLFxcclxcblxcclxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xcclxcblxcclxcblxcdFxcdFxcdE9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMucG9zaXRpb25TY3JlZW4uY29weSggc291cmNlLnBvc2l0aW9uU2NyZWVuICk7XFxyXFxuXFx0XFx0XFx0dGhpcy5jdXN0b21VcGRhdGVDYWxsYmFjayA9IHNvdXJjZS5jdXN0b21VcGRhdGVDYWxsYmFjaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzb3VyY2UubGVuc0ZsYXJlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMubGVuc0ZsYXJlcy5wdXNoKCBzb3VyY2UubGVuc0ZsYXJlc1sgaSBdICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0YWRkOiBmdW5jdGlvbiAoIHRleHR1cmUsIHNpemUsIGRpc3RhbmNlLCBibGVuZGluZywgY29sb3IsIG9wYWNpdHkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBzaXplID09PSB1bmRlZmluZWQgKSBzaXplID0gLSAxO1xcclxcblxcdFxcdFxcdGlmICggZGlzdGFuY2UgPT09IHVuZGVmaW5lZCApIGRpc3RhbmNlID0gMDtcXHJcXG5cXHRcXHRcXHRpZiAoIG9wYWNpdHkgPT09IHVuZGVmaW5lZCApIG9wYWNpdHkgPSAxO1xcclxcblxcdFxcdFxcdGlmICggY29sb3IgPT09IHVuZGVmaW5lZCApIGNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApO1xcclxcblxcdFxcdFxcdGlmICggYmxlbmRpbmcgPT09IHVuZGVmaW5lZCApIGJsZW5kaW5nID0gTm9ybWFsQmxlbmRpbmc7XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZGlzdGFuY2UgPSBNYXRoLm1pbiggZGlzdGFuY2UsIE1hdGgubWF4KCAwLCBkaXN0YW5jZSApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5sZW5zRmxhcmVzLnB1c2goIHtcXHJcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlOiB0ZXh0dXJlLFxcdC8vIFRIUkVFLlRleHR1cmVcXHJcXG5cXHRcXHRcXHRcXHRzaXplOiBzaXplLCBcXHRcXHQvLyBzaXplIGluIHBpeGVscyAoLTEgPSB1c2UgdGV4dHVyZS53aWR0aClcXHJcXG5cXHRcXHRcXHRcXHRkaXN0YW5jZTogZGlzdGFuY2UsIFxcdC8vIGRpc3RhbmNlICgwLTEpIGZyb20gbGlnaHQgc291cmNlICgwPWF0IGxpZ2h0IHNvdXJjZSlcXHJcXG5cXHRcXHRcXHRcXHR4OiAwLCB5OiAwLCB6OiAwLFxcdC8vIHNjcmVlbiBwb3NpdGlvbiAoLTEgPT4gMSkgeiA9IDAgaXMgaW4gZnJvbnQgeiA9IDEgaXMgYmFja1xcclxcblxcdFxcdFxcdFxcdHNjYWxlOiAxLCBcXHRcXHQvLyBzY2FsZVxcclxcblxcdFxcdFxcdFxcdHJvdGF0aW9uOiAwLCBcXHRcXHQvLyByb3RhdGlvblxcclxcblxcdFxcdFxcdFxcdG9wYWNpdHk6IG9wYWNpdHksXFx0Ly8gb3BhY2l0eVxcclxcblxcdFxcdFxcdFxcdGNvbG9yOiBjb2xvcixcXHRcXHQvLyBjb2xvclxcclxcblxcdFxcdFxcdFxcdGJsZW5kaW5nOiBibGVuZGluZ1xcdC8vIGJsZW5kaW5nXFxyXFxuXFx0XFx0XFx0fSApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0LypcXHJcXG5cXHRcXHQgKiBVcGRhdGUgbGVucyBmbGFyZXMgdXBkYXRlIHBvc2l0aW9ucyBvbiBhbGwgZmxhcmVzIGJhc2VkIG9uIHRoZSBzY3JlZW4gcG9zaXRpb25cXHJcXG5cXHRcXHQgKiBTZXQgbXlMZW5zRmxhcmUuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgdG8gYWx0ZXIgdGhlIGZsYXJlcyBpbiB5b3VyIHByb2plY3Qgc3BlY2lmaWMgd2F5LlxcclxcblxcdFxcdCAqL1xcclxcblxcclxcblxcdFxcdHVwZGF0ZUxlbnNGbGFyZXM6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgZiwgZmwgPSB0aGlzLmxlbnNGbGFyZXMubGVuZ3RoO1xcclxcblxcdFxcdFxcdHZhciBmbGFyZTtcXHJcXG5cXHRcXHRcXHR2YXIgdmVjWCA9IC0gdGhpcy5wb3NpdGlvblNjcmVlbi54ICogMjtcXHJcXG5cXHRcXHRcXHR2YXIgdmVjWSA9IC0gdGhpcy5wb3NpdGlvblNjcmVlbi55ICogMjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCBmID0gMDsgZiA8IGZsOyBmICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZsYXJlID0gdGhpcy5sZW5zRmxhcmVzWyBmIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZmxhcmUueCA9IHRoaXMucG9zaXRpb25TY3JlZW4ueCArIHZlY1ggKiBmbGFyZS5kaXN0YW5jZTtcXHJcXG5cXHRcXHRcXHRcXHRmbGFyZS55ID0gdGhpcy5wb3NpdGlvblNjcmVlbi55ICsgdmVjWSAqIGZsYXJlLmRpc3RhbmNlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZsYXJlLndhbnRlZFJvdGF0aW9uID0gZmxhcmUueCAqIE1hdGguUEkgKiAwLjI1O1xcclxcblxcdFxcdFxcdFxcdGZsYXJlLnJvdGF0aW9uICs9ICggZmxhcmUud2FudGVkUm90YXRpb24gLSBmbGFyZS5yb3RhdGlvbiApICogMC4yNTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcclxcblxcdCAqXFxyXFxuXFx0ICogcGFyYW1ldGVycyA9IHtcXHJcXG5cXHQgKiAgY29sb3I6IDxoZXg+LFxcclxcblxcdCAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxcclxcblxcdCAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxyXFxuXFx0ICpcXHJcXG5cXHQgKlxcdHV2T2Zmc2V0OiBuZXcgVEhSRUUuVmVjdG9yMigpLFxcclxcblxcdCAqXFx0dXZTY2FsZTogbmV3IFRIUkVFLlZlY3RvcjIoKVxcclxcblxcdCAqIH1cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBTcHJpdGVNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcXHJcXG5cXHJcXG5cXHRcXHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50eXBlID0gJ1Nwcml0ZU1hdGVyaWFsJztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApO1xcclxcblxcdFxcdHRoaXMubWFwID0gbnVsbDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnJvdGF0aW9uID0gMDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmZvZyA9IGZhbHNlO1xcclxcblxcdFxcdHRoaXMubGlnaHRzID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0U3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XFxyXFxuXFx0U3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ByaXRlTWF0ZXJpYWw7XFxyXFxuXFx0U3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlLmlzU3ByaXRlTWF0ZXJpYWwgPSB0cnVlO1xcclxcblxcclxcblxcdFNwcml0ZU1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcXHJcXG5cXHRcXHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5yb3RhdGlvbiA9IHNvdXJjZS5yb3RhdGlvbjtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHR9O1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXFxyXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBTcHJpdGUoIG1hdGVyaWFsICkge1xcclxcblxcclxcblxcdFxcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnU3ByaXRlJztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm1hdGVyaWFsID0gKCBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkICkgPyBtYXRlcmlhbCA6IG5ldyBTcHJpdGVNYXRlcmlhbCgpO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRTcHJpdGUucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICksIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zdHJ1Y3RvcjogU3ByaXRlLFxcclxcblxcclxcblxcdFxcdGlzU3ByaXRlOiB0cnVlLFxcclxcblxcclxcblxcdFxcdHJheWNhc3Q6ICggZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBpbnRlcnNlY3RQb2ludCA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0XFx0dmFyIHdvcmxkUG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdFxcdHZhciB3b3JsZFNjYWxlID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHdvcmxkUG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XFxyXFxuXFx0XFx0XFx0XFx0cmF5Y2FzdGVyLnJheS5jbG9zZXN0UG9pbnRUb1BvaW50KCB3b3JsZFBvc2l0aW9uLCBpbnRlcnNlY3RQb2ludCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHdvcmxkU2NhbGUuc2V0RnJvbU1hdHJpeFNjYWxlKCB0aGlzLm1hdHJpeFdvcmxkICk7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGd1ZXNzU2l6ZVNxID0gd29ybGRTY2FsZS54ICogd29ybGRTY2FsZS55IC8gNDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHdvcmxkUG9zaXRpb24uZGlzdGFuY2VUb1NxdWFyZWQoIGludGVyc2VjdFBvaW50ICkgPiBndWVzc1NpemVTcSApIHJldHVybjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlcnNlY3RQb2ludCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSByZXR1cm47XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aW50ZXJzZWN0cy5wdXNoKCB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxcclxcblxcdFxcdFxcdFxcdFxcdHBvaW50OiBpbnRlcnNlY3RQb2ludC5jbG9uZSgpLFxcclxcblxcdFxcdFxcdFxcdFxcdGZhY2U6IG51bGwsXFxyXFxuXFx0XFx0XFx0XFx0XFx0b2JqZWN0OiB0aGlzXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSApO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpICksXFxyXFxuXFxyXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMubWF0ZXJpYWwgKS5jb3B5KCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xcclxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBMT0QoKSB7XFxyXFxuXFxyXFxuXFx0XFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdMT0QnO1xcclxcblxcclxcblxcdFxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLCB7XFxyXFxuXFx0XFx0XFx0bGV2ZWxzOiB7XFxyXFxuXFx0XFx0XFx0XFx0ZW51bWVyYWJsZTogdHJ1ZSxcXHJcXG5cXHRcXHRcXHRcXHR2YWx1ZTogW11cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFx0XFx0fSApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRMT0QucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICksIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zdHJ1Y3RvcjogTE9ELFxcclxcblxcclxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xcclxcblxcclxcblxcdFxcdFxcdE9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSwgZmFsc2UgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbGV2ZWxzID0gc291cmNlLmxldmVscztcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgbGV2ZWwgPSBsZXZlbHNbIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmFkZExldmVsKCBsZXZlbC5vYmplY3QuY2xvbmUoKSwgbGV2ZWwuZGlzdGFuY2UgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRhZGRMZXZlbDogZnVuY3Rpb24gKCBvYmplY3QsIGRpc3RhbmNlICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggZGlzdGFuY2UgPT09IHVuZGVmaW5lZCApIGRpc3RhbmNlID0gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRkaXN0YW5jZSA9IE1hdGguYWJzKCBkaXN0YW5jZSApO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgbCA9IDA7IGwgPCBsZXZlbHMubGVuZ3RoOyBsICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggZGlzdGFuY2UgPCBsZXZlbHNbIGwgXS5kaXN0YW5jZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGxldmVscy5zcGxpY2UoIGwsIDAsIHsgZGlzdGFuY2U6IGRpc3RhbmNlLCBvYmplY3Q6IG9iamVjdCB9ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5hZGQoIG9iamVjdCApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Z2V0T2JqZWN0Rm9yRGlzdGFuY2U6IGZ1bmN0aW9uICggZGlzdGFuY2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMSwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggZGlzdGFuY2UgPCBsZXZlbHNbIGkgXS5kaXN0YW5jZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBsZXZlbHNbIGkgLSAxIF0ub2JqZWN0O1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0cmF5Y2FzdDogKCBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG1hdHJpeFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdG1hdHJpeFBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIG1hdHJpeFBvc2l0aW9uICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5nZXRPYmplY3RGb3JEaXN0YW5jZSggZGlzdGFuY2UgKS5yYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0oKSApLFxcclxcblxcclxcblxcdFxcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0XFx0dmFyIHYyID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCBjYW1lcmEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggbGV2ZWxzLmxlbmd0aCA+IDEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0djEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2Mi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgZGlzdGFuY2UgPSB2MS5kaXN0YW5jZVRvKCB2MiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGxldmVsc1sgMCBdLm9iamVjdC52aXNpYmxlID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDEsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGRpc3RhbmNlID49IGxldmVsc1sgaSBdLmRpc3RhbmNlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGxldmVsc1sgaSAtIDEgXS5vYmplY3QudmlzaWJsZSA9IGZhbHNlO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGxldmVsc1sgaSBdLm9iamVjdC52aXNpYmxlID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRsZXZlbHNbIGkgXS5vYmplY3QudmlzaWJsZSA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR9KCksXFxyXFxuXFxyXFxuXFx0XFx0dG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGRhdGEgPSBPYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRkYXRhLm9iamVjdC5sZXZlbHMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbGV2ZWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGxldmVsID0gbGV2ZWxzWyBpIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZGF0YS5vYmplY3QubGV2ZWxzLnB1c2goIHtcXHJcXG5cXHRcXHRcXHRcXHRcXHRvYmplY3Q6IGxldmVsLm9iamVjdC51dWlkLFxcclxcblxcdFxcdFxcdFxcdFxcdGRpc3RhbmNlOiBsZXZlbC5kaXN0YW5jZVxcclxcblxcdFxcdFxcdFxcdH0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGRhdGE7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xcclxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxyXFxuXFx0ICogQGF1dGhvciBtaWNoYWVsIGd1ZXJyZXJvIC8gaHR0cDovL3JlYWxpdHltZWx0ZG93bi5jb21cXHJcXG5cXHQgKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBTa2VsZXRvbiggYm9uZXMsIGJvbmVJbnZlcnNlcyApIHtcXHJcXG5cXHJcXG5cXHRcXHQvLyBjb3B5IHRoZSBib25lIGFycmF5XFxyXFxuXFxyXFxuXFx0XFx0Ym9uZXMgPSBib25lcyB8fCBbXTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmJvbmVzID0gYm9uZXMuc2xpY2UoIDAgKTtcXHJcXG5cXHRcXHR0aGlzLmJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIHRoaXMuYm9uZXMubGVuZ3RoICogMTYgKTtcXHJcXG5cXHJcXG5cXHRcXHQvLyB1c2UgdGhlIHN1cHBsaWVkIGJvbmUgaW52ZXJzZXMgb3IgY2FsY3VsYXRlIHRoZSBpbnZlcnNlc1xcclxcblxcclxcblxcdFxcdGlmICggYm9uZUludmVyc2VzID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5jYWxjdWxhdGVJbnZlcnNlcygpO1xcclxcblxcclxcblxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmJvbmVzLmxlbmd0aCA9PT0gYm9uZUludmVyc2VzLmxlbmd0aCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmJvbmVJbnZlcnNlcyA9IGJvbmVJbnZlcnNlcy5zbGljZSggMCApO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU2tlbGV0b24gYm9uZUludmVyc2VzIGlzIHRoZSB3cm9uZyBsZW5ndGguJyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuYm9uZUludmVyc2VzID0gW107XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5ib25lSW52ZXJzZXMucHVzaCggbmV3IE1hdHJpeDQoKSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRPYmplY3QuYXNzaWduKCBTa2VsZXRvbi5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHRjYWxjdWxhdGVJbnZlcnNlczogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuYm9uZUludmVyc2VzID0gW107XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGludmVyc2UgPSBuZXcgTWF0cml4NCgpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggdGhpcy5ib25lc1sgaSBdICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5ib25lc1sgaSBdLm1hdHJpeFdvcmxkICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuYm9uZUludmVyc2VzLnB1c2goIGludmVyc2UgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRwb3NlOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGJvbmUsIGksIGlsO1xcclxcblxcclxcblxcdFxcdFxcdC8vIHJlY292ZXIgdGhlIGJpbmQtdGltZSB3b3JsZCBtYXRyaWNlc1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ym9uZSA9IHRoaXMuYm9uZXNbIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGJvbmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ym9uZS5tYXRyaXhXb3JsZC5nZXRJbnZlcnNlKCB0aGlzLmJvbmVJbnZlcnNlc1sgaSBdICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBjb21wdXRlIHRoZSBsb2NhbCBtYXRyaWNlcywgcG9zaXRpb25zLCByb3RhdGlvbnMgYW5kIHNjYWxlc1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ym9uZSA9IHRoaXMuYm9uZXNbIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGJvbmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBib25lLnBhcmVudCAmJiBib25lLnBhcmVudC5pc0JvbmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ym9uZS5tYXRyaXguZ2V0SW52ZXJzZSggYm9uZS5wYXJlbnQubWF0cml4V29ybGQgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRib25lLm1hdHJpeC5tdWx0aXBseSggYm9uZS5tYXRyaXhXb3JsZCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ym9uZS5tYXRyaXguY29weSggYm9uZS5tYXRyaXhXb3JsZCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRib25lLm1hdHJpeC5kZWNvbXBvc2UoIGJvbmUucG9zaXRpb24sIGJvbmUucXVhdGVybmlvbiwgYm9uZS5zY2FsZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHR1cGRhdGU6ICggZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBvZmZzZXRNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xcclxcblxcdFxcdFxcdHZhciBpZGVudGl0eU1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgYm9uZXMgPSB0aGlzLmJvbmVzO1xcclxcblxcdFxcdFxcdFxcdHZhciBib25lSW52ZXJzZXMgPSB0aGlzLmJvbmVJbnZlcnNlcztcXHJcXG5cXHRcXHRcXHRcXHR2YXIgYm9uZU1hdHJpY2VzID0gdGhpcy5ib25lTWF0cmljZXM7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGJvbmVUZXh0dXJlID0gdGhpcy5ib25lVGV4dHVyZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBmbGF0dGVuIGJvbmUgbWF0cmljZXMgdG8gYXJyYXlcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gY29tcHV0ZSB0aGUgb2Zmc2V0IGJldHdlZW4gdGhlIGN1cnJlbnQgYW5kIHRoZSBvcmlnaW5hbCB0cmFuc2Zvcm1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgbWF0cml4ID0gYm9uZXNbIGkgXSA/IGJvbmVzWyBpIF0ubWF0cml4V29ybGQgOiBpZGVudGl0eU1hdHJpeDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRvZmZzZXRNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4LCBib25lSW52ZXJzZXNbIGkgXSApO1xcclxcblxcdFxcdFxcdFxcdFxcdG9mZnNldE1hdHJpeC50b0FycmF5KCBib25lTWF0cmljZXMsIGkgKiAxNiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGJvbmVUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ym9uZVRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0gKSgpLFxcclxcblxcclxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyBTa2VsZXRvbiggdGhpcy5ib25lcywgdGhpcy5ib25lSW52ZXJzZXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXFxyXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXHJcXG5cXHQgKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBCb25lKCkge1xcclxcblxcclxcblxcdFxcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnQm9uZSc7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdEJvbmUucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICksIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zdHJ1Y3RvcjogQm9uZSxcXHJcXG5cXHJcXG5cXHRcXHRpc0JvbmU6IHRydWVcXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cXHJcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcclxcblxcdCAqIEBhdXRob3IgaWtlcnIgLyBodHRwOi8vdmVyb2xkLmNvbVxcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIFNraW5uZWRNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0TWVzaC5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnU2tpbm5lZE1lc2gnO1xcclxcblxcclxcblxcdFxcdHRoaXMuYmluZE1vZGUgPSAnYXR0YWNoZWQnO1xcclxcblxcdFxcdHRoaXMuYmluZE1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XFxyXFxuXFx0XFx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZSA9IG5ldyBNYXRyaXg0KCk7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGJvbmVzID0gdGhpcy5pbml0Qm9uZXMoKTtcXHJcXG5cXHRcXHR2YXIgc2tlbGV0b24gPSBuZXcgU2tlbGV0b24oIGJvbmVzICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5iaW5kKCBza2VsZXRvbiwgdGhpcy5tYXRyaXhXb3JsZCApO1xcclxcblxcclxcblxcdFxcdHRoaXMubm9ybWFsaXplU2tpbldlaWdodHMoKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0U2tpbm5lZE1lc2gucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTWVzaC5wcm90b3R5cGUgKSwge1xcclxcblxcclxcblxcdFxcdGNvbnN0cnVjdG9yOiBTa2lubmVkTWVzaCxcXHJcXG5cXHJcXG5cXHRcXHRpc1NraW5uZWRNZXNoOiB0cnVlLFxcclxcblxcclxcblxcdFxcdGluaXRCb25lczogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBib25lcyA9IFtdLCBib25lLCBnYm9uZTtcXHJcXG5cXHRcXHRcXHR2YXIgaSwgaWw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmdlb21ldHJ5ICYmIHRoaXMuZ2VvbWV0cnkuYm9uZXMgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBmaXJzdCwgY3JlYXRlIGFycmF5IG9mICdCb25lJyBvYmplY3RzIGZyb20gZ2VvbWV0cnkgZGF0YVxcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMuZ2VvbWV0cnkuYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Z2JvbmUgPSB0aGlzLmdlb21ldHJ5LmJvbmVzWyBpIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gY3JlYXRlIG5ldyAnQm9uZScgb2JqZWN0XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ym9uZSA9IG5ldyBCb25lKCk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0Ym9uZXMucHVzaCggYm9uZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIGFwcGx5IHZhbHVlc1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGJvbmUubmFtZSA9IGdib25lLm5hbWU7XFxyXFxuXFx0XFx0XFx0XFx0XFx0Ym9uZS5wb3NpdGlvbi5mcm9tQXJyYXkoIGdib25lLnBvcyApO1xcclxcblxcdFxcdFxcdFxcdFxcdGJvbmUucXVhdGVybmlvbi5mcm9tQXJyYXkoIGdib25lLnJvdHEgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGdib25lLnNjbCAhPT0gdW5kZWZpbmVkICkgYm9uZS5zY2FsZS5mcm9tQXJyYXkoIGdib25lLnNjbCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBzZWNvbmQsIGNyZWF0ZSBib25lIGhpZXJhcmNoeVxcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMuZ2VvbWV0cnkuYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Z2JvbmUgPSB0aGlzLmdlb21ldHJ5LmJvbmVzWyBpIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAoIGdib25lLnBhcmVudCAhPT0gLSAxICkgJiYgKCBnYm9uZS5wYXJlbnQgIT09IG51bGwgKSAmJiAoIGJvbmVzWyBnYm9uZS5wYXJlbnQgXSAhPT0gdW5kZWZpbmVkICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gc3Vic2VxdWVudCBib25lcyBpbiB0aGUgaGllcmFyY2h5XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ym9uZXNbIGdib25lLnBhcmVudCBdLmFkZCggYm9uZXNbIGkgXSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gdG9wbW9zdCBib25lLCBpbW1lZGlhdGUgY2hpbGQgb2YgdGhlIHNraW5uZWQgbWVzaFxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuYWRkKCBib25lc1sgaSBdICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gbm93IHRoZSBib25lcyBhcmUgcGFydCBvZiB0aGUgc2NlbmUgZ3JhcGggYW5kIGNoaWxkcmVuIG9mIHRoZSBza2lubmVkIG1lc2guXFxyXFxuXFx0XFx0XFx0Ly8gbGV0J3MgdXBkYXRlIHRoZSBjb3JyZXNwb25kaW5nIG1hdHJpY2VzXFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBib25lcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGJpbmQ6IGZ1bmN0aW9uICggc2tlbGV0b24sIGJpbmRNYXRyaXggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5za2VsZXRvbiA9IHNrZWxldG9uO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggYmluZE1hdHJpeCA9PT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnNrZWxldG9uLmNhbGN1bGF0ZUludmVyc2VzKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YmluZE1hdHJpeCA9IHRoaXMubWF0cml4V29ybGQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHRoaXMuYmluZE1hdHJpeC5jb3B5KCBiaW5kTWF0cml4ICk7XFxyXFxuXFx0XFx0XFx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZS5nZXRJbnZlcnNlKCBiaW5kTWF0cml4ICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRwb3NlOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5za2VsZXRvbi5wb3NlKCk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRub3JtYWxpemVTa2luV2VpZ2h0czogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBzY2FsZSwgaTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMuZ2VvbWV0cnkgJiYgdGhpcy5nZW9tZXRyeS5pc0dlb21ldHJ5ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDwgdGhpcy5nZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGg7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHN3ID0gdGhpcy5nZW9tZXRyeS5za2luV2VpZ2h0c1sgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHNjYWxlID0gMS4wIC8gc3cubWFuaGF0dGFuTGVuZ3RoKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBzY2FsZSAhPT0gSW5maW5pdHkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0c3cubXVsdGlwbHlTY2FsYXIoIHNjYWxlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRzdy5zZXQoIDEsIDAsIDAsIDAgKTsgLy8gZG8gc29tZXRoaW5nIHJlYXNvbmFibGVcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIHRoaXMuZ2VvbWV0cnkgJiYgdGhpcy5nZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciB2ZWMgPSBuZXcgVmVjdG9yNCgpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBza2luV2VpZ2h0ID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnNraW5XZWlnaHQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggaSA9IDA7IGkgPCBza2luV2VpZ2h0LmNvdW50OyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZlYy54ID0gc2tpbldlaWdodC5nZXRYKCBpICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmVjLnkgPSBza2luV2VpZ2h0LmdldFkoIGkgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2ZWMueiA9IHNraW5XZWlnaHQuZ2V0WiggaSApO1xcclxcblxcdFxcdFxcdFxcdFxcdHZlYy53ID0gc2tpbldlaWdodC5nZXRXKCBpICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0c2NhbGUgPSAxLjAgLyB2ZWMubWFuaGF0dGFuTGVuZ3RoKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBzY2FsZSAhPT0gSW5maW5pdHkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmVjLm11bHRpcGx5U2NhbGFyKCBzY2FsZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmVjLnNldCggMSwgMCwgMCwgMCApOyAvLyBkbyBzb21ldGhpbmcgcmVhc29uYWJsZVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRza2luV2VpZ2h0LnNldFhZWlcoIGksIHZlYy54LCB2ZWMueSwgdmVjLnosIHZlYy53ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHVwZGF0ZU1hdHJpeFdvcmxkOiBmdW5jdGlvbiAoIGZvcmNlICkge1xcclxcblxcclxcblxcdFxcdFxcdE1lc2gucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkLmNhbGwoIHRoaXMsIGZvcmNlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmJpbmRNb2RlID09PSAnYXR0YWNoZWQnICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIHRoaXMuYmluZE1vZGUgPT09ICdkZXRhY2hlZCcgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZS5nZXRJbnZlcnNlKCB0aGlzLmJpbmRNYXRyaXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNraW5uZWRNZXNoOiBVbnJlY29nbml6ZWQgYmluZE1vZGU6ICcgKyB0aGlzLmJpbmRNb2RlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwgKS5jb3B5KCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBwYXJhbWV0ZXJzID0ge1xcclxcblxcdCAqICBjb2xvcjogPGhleD4sXFxyXFxuXFx0ICogIG9wYWNpdHk6IDxmbG9hdD4sXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiAgbGluZXdpZHRoOiA8ZmxvYXQ+LFxcclxcblxcdCAqICBsaW5lY2FwOiBcXFwicm91bmRcXFwiLFxcclxcblxcdCAqICBsaW5lam9pbjogXFxcInJvdW5kXFxcIlxcclxcblxcdCAqIH1cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBMaW5lQmFzaWNNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcXHJcXG5cXHJcXG5cXHRcXHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50eXBlID0gJ0xpbmVCYXNpY01hdGVyaWFsJztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApO1xcclxcblxcclxcblxcdFxcdHRoaXMubGluZXdpZHRoID0gMTtcXHJcXG5cXHRcXHR0aGlzLmxpbmVjYXAgPSAncm91bmQnO1xcclxcblxcdFxcdHRoaXMubGluZWpvaW4gPSAncm91bmQnO1xcclxcblxcclxcblxcdFxcdHRoaXMubGlnaHRzID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0TGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XFxyXFxuXFx0TGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGluZUJhc2ljTWF0ZXJpYWw7XFxyXFxuXFxyXFxuXFx0TGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmlzTGluZUJhc2ljTWF0ZXJpYWwgPSB0cnVlO1xcclxcblxcclxcblxcdExpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmxpbmV3aWR0aCA9IHNvdXJjZS5saW5ld2lkdGg7XFxyXFxuXFx0XFx0dGhpcy5saW5lY2FwID0gc291cmNlLmxpbmVjYXA7XFxyXFxuXFx0XFx0dGhpcy5saW5lam9pbiA9IHNvdXJjZS5saW5lam9pbjtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHR9O1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsLCBtb2RlICkge1xcclxcblxcclxcblxcdFxcdGlmICggbW9kZSA9PT0gMSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5MaW5lOiBwYXJhbWV0ZXIgVEhSRUUuTGluZVBpZWNlcyBubyBsb25nZXIgc3VwcG9ydGVkLiBDcmVhdGVkIFRIUkVFLkxpbmVTZWdtZW50cyBpbnN0ZWFkLicgKTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gbmV3IExpbmVTZWdtZW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnTGluZSc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgPyBnZW9tZXRyeSA6IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xcclxcblxcdFxcdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWwgOiBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZiB9ICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdExpbmUucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICksIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zdHJ1Y3RvcjogTGluZSxcXHJcXG5cXHJcXG5cXHRcXHRpc0xpbmU6IHRydWUsXFxyXFxuXFxyXFxuXFx0XFx0cmF5Y2FzdDogKCBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGludmVyc2VNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xcclxcblxcdFxcdFxcdHZhciByYXkgPSBuZXcgUmF5KCk7XFxyXFxuXFx0XFx0XFx0dmFyIHNwaGVyZSA9IG5ldyBTcGhlcmUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBwcmVjaXNpb24gPSByYXljYXN0ZXIubGluZVByZWNpc2lvbjtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgcHJlY2lzaW9uU3EgPSBwcmVjaXNpb24gKiBwcmVjaXNpb247XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgbWF0cml4V29ybGQgPSB0aGlzLm1hdHJpeFdvcmxkO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKTtcXHJcXG5cXHRcXHRcXHRcXHRzcGhlcmUuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggcmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSA9PT0gZmFsc2UgKSByZXR1cm47XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly9cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpbnZlcnNlTWF0cml4LmdldEludmVyc2UoIG1hdHJpeFdvcmxkICk7XFxyXFxuXFx0XFx0XFx0XFx0cmF5LmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIGludmVyc2VNYXRyaXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgdlN0YXJ0ID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgdkVuZCA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGludGVyU2VnbWVudCA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGludGVyUmF5ID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgc3RlcCA9ICggdGhpcyAmJiB0aGlzLmlzTGluZVNlZ21lbnRzICkgPyAyIDogMTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xcclxcblxcdFxcdFxcdFxcdFxcdHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggaW5kZXggIT09IG51bGwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGluZGljZXMgPSBpbmRleC5hcnJheTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aCAtIDE7IGkgPCBsOyBpICs9IHN0ZXAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGEgPSBpbmRpY2VzWyBpIF07XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGIgPSBpbmRpY2VzWyBpICsgMSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZTdGFydC5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYSAqIDMgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2RW5kLmZyb21BcnJheSggcG9zaXRpb25zLCBiICogMyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBkaXN0U3EgPSByYXkuZGlzdGFuY2VTcVRvU2VnbWVudCggdlN0YXJ0LCB2RW5kLCBpbnRlclJheSwgaW50ZXJTZWdtZW50ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBkaXN0U3EgPiBwcmVjaXNpb25TcSApIGNvbnRpbnVlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGludGVyUmF5LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApOyAvL01vdmUgYmFjayB0byB3b3JsZCBzcGFjZSBmb3IgZGlzdGFuY2UgY2FsY3VsYXRpb25cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlclJheSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpbnRlcnNlY3RzLnB1c2goIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkaXN0YW5jZTogZGlzdGFuY2UsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gV2hhdCBkbyB3ZSB3YW50PyBpbnRlcnNlY3Rpb24gcG9pbnQgb24gdGhlIHJheSBvciBvbiB0aGUgc2VnbWVudD8/XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gcG9pbnQ6IHJheWNhc3Rlci5yYXkuYXQoIGRpc3RhbmNlICksXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cG9pbnQ6IGludGVyU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGluZGV4OiBpLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGZhY2U6IG51bGwsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZmFjZUluZGV4OiBudWxsLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdDogdGhpc1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBwb3NpdGlvbnMubGVuZ3RoIC8gMyAtIDE7IGkgPCBsOyBpICs9IHN0ZXAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dlN0YXJ0LmZyb21BcnJheSggcG9zaXRpb25zLCAzICogaSApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZFbmQuZnJvbUFycmF5KCBwb3NpdGlvbnMsIDMgKiBpICsgMyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBkaXN0U3EgPSByYXkuZGlzdGFuY2VTcVRvU2VnbWVudCggdlN0YXJ0LCB2RW5kLCBpbnRlclJheSwgaW50ZXJTZWdtZW50ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBkaXN0U3EgPiBwcmVjaXNpb25TcSApIGNvbnRpbnVlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGludGVyUmF5LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApOyAvL01vdmUgYmFjayB0byB3b3JsZCBzcGFjZSBmb3IgZGlzdGFuY2UgY2FsY3VsYXRpb25cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlclJheSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpbnRlcnNlY3RzLnB1c2goIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkaXN0YW5jZTogZGlzdGFuY2UsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gV2hhdCBkbyB3ZSB3YW50PyBpbnRlcnNlY3Rpb24gcG9pbnQgb24gdGhlIHJheSBvciBvbiB0aGUgc2VnbWVudD8/XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gcG9pbnQ6IHJheWNhc3Rlci5yYXkuYXQoIGRpc3RhbmNlICksXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cG9pbnQ6IGludGVyU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGluZGV4OiBpLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGZhY2U6IG51bGwsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZmFjZUluZGV4OiBudWxsLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdDogdGhpc1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIGdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIG5iVmVydGljZXMgPSB2ZXJ0aWNlcy5sZW5ndGg7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbmJWZXJ0aWNlcyAtIDE7IGkgKz0gc3RlcCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgZGlzdFNxID0gcmF5LmRpc3RhbmNlU3FUb1NlZ21lbnQoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzWyBpICsgMSBdLCBpbnRlclJheSwgaW50ZXJTZWdtZW50ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBkaXN0U3EgPiBwcmVjaXNpb25TcSApIGNvbnRpbnVlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGludGVyUmF5LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApOyAvL01vdmUgYmFjayB0byB3b3JsZCBzcGFjZSBmb3IgZGlzdGFuY2UgY2FsY3VsYXRpb25cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlclJheSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpbnRlcnNlY3RzLnB1c2goIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkaXN0YW5jZTogZGlzdGFuY2UsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gV2hhdCBkbyB3ZSB3YW50PyBpbnRlcnNlY3Rpb24gcG9pbnQgb24gdGhlIHJheSBvciBvbiB0aGUgc2VnbWVudD8/XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gcG9pbnQ6IHJheWNhc3Rlci5yYXkuYXQoIGRpc3RhbmNlICksXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cG9pbnQ6IGludGVyU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGluZGV4OiBpLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZhY2U6IG51bGwsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZmFjZUluZGV4OiBudWxsLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdDogdGhpc1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpICksXFxyXFxuXFxyXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwgKS5jb3B5KCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIExpbmVTZWdtZW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xcclxcblxcclxcblxcdFxcdExpbmUuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50eXBlID0gJ0xpbmVTZWdtZW50cyc7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdExpbmVTZWdtZW50cy5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMaW5lLnByb3RvdHlwZSApLCB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc3RydWN0b3I6IExpbmVTZWdtZW50cyxcXHJcXG5cXHJcXG5cXHRcXHRpc0xpbmVTZWdtZW50czogdHJ1ZVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIG1ncmV0ZXIgLyBodHRwOi8vZ2l0aHViLmNvbS9tZ3JldGVyXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gTGluZUxvb3AoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRMaW5lLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdMaW5lTG9vcCc7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdExpbmVMb29wLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExpbmUucHJvdG90eXBlICksIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zdHJ1Y3RvcjogTGluZUxvb3AsXFxyXFxuXFxyXFxuXFx0XFx0aXNMaW5lTG9vcDogdHJ1ZSxcXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcclxcblxcdCAqXFxyXFxuXFx0ICogcGFyYW1ldGVycyA9IHtcXHJcXG5cXHQgKiAgY29sb3I6IDxoZXg+LFxcclxcblxcdCAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxcclxcblxcdCAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiAgc2l6ZTogPGZsb2F0PixcXHJcXG5cXHQgKiAgc2l6ZUF0dGVudWF0aW9uOiA8Ym9vbD5cXHJcXG5cXHQgKiB9XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gUG9pbnRzTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0TWF0ZXJpYWwuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdQb2ludHNNYXRlcmlhbCc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm1hcCA9IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5zaXplID0gMTtcXHJcXG5cXHRcXHR0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5saWdodHMgPSBmYWxzZTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRQb2ludHNNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXRlcmlhbC5wcm90b3R5cGUgKTtcXHJcXG5cXHRQb2ludHNNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2ludHNNYXRlcmlhbDtcXHJcXG5cXHJcXG5cXHRQb2ludHNNYXRlcmlhbC5wcm90b3R5cGUuaXNQb2ludHNNYXRlcmlhbCA9IHRydWU7XFxyXFxuXFxyXFxuXFx0UG9pbnRzTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xcclxcblxcclxcblxcdFxcdHRoaXMubWFwID0gc291cmNlLm1hcDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnNpemUgPSBzb3VyY2Uuc2l6ZTtcXHJcXG5cXHRcXHR0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHNvdXJjZS5zaXplQXR0ZW51YXRpb247XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIFBvaW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xcclxcblxcclxcblxcdFxcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnUG9pbnRzJztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCA/IGdlb21ldHJ5IDogbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XFxyXFxuXFx0XFx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbCA6IG5ldyBQb2ludHNNYXRlcmlhbCggeyBjb2xvcjogTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmIH0gKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0UG9pbnRzLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc3RydWN0b3I6IFBvaW50cyxcXHJcXG5cXHJcXG5cXHRcXHRpc1BvaW50czogdHJ1ZSxcXHJcXG5cXHJcXG5cXHRcXHRyYXljYXN0OiAoIGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgaW52ZXJzZU1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XFxyXFxuXFx0XFx0XFx0dmFyIHJheSA9IG5ldyBSYXkoKTtcXHJcXG5cXHRcXHRcXHR2YXIgc3BoZXJlID0gbmV3IFNwaGVyZSgpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiByYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIG9iamVjdCA9IHRoaXM7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgbWF0cml4V29ybGQgPSB0aGlzLm1hdHJpeFdvcmxkO1xcclxcblxcdFxcdFxcdFxcdHZhciB0aHJlc2hvbGQgPSByYXljYXN0ZXIucGFyYW1zLlBvaW50cy50aHJlc2hvbGQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gQ2hlY2tpbmcgYm91bmRpbmdTcGhlcmUgZGlzdGFuY2UgdG8gcmF5XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHNwaGVyZS5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApO1xcclxcblxcdFxcdFxcdFxcdHNwaGVyZS5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XFxyXFxuXFx0XFx0XFx0XFx0c3BoZXJlLnJhZGl1cyArPSB0aHJlc2hvbGQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCByYXljYXN0ZXIucmF5LmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApID09PSBmYWxzZSApIHJldHVybjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvL1xcclxcblxcclxcblxcdFxcdFxcdFxcdGludmVyc2VNYXRyaXguZ2V0SW52ZXJzZSggbWF0cml4V29ybGQgKTtcXHJcXG5cXHRcXHRcXHRcXHRyYXkuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggaW52ZXJzZU1hdHJpeCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBsb2NhbFRocmVzaG9sZCA9IHRocmVzaG9sZCAvICggKCB0aGlzLnNjYWxlLnggKyB0aGlzLnNjYWxlLnkgKyB0aGlzLnNjYWxlLnogKSAvIDMgKTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgbG9jYWxUaHJlc2hvbGRTcSA9IGxvY2FsVGhyZXNob2xkICogbG9jYWxUaHJlc2hvbGQ7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIHBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiB0ZXN0UG9pbnQoIHBvaW50LCBpbmRleCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgcmF5UG9pbnREaXN0YW5jZVNxID0gcmF5LmRpc3RhbmNlU3FUb1BvaW50KCBwb2ludCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggcmF5UG9pbnREaXN0YW5jZVNxIDwgbG9jYWxUaHJlc2hvbGRTcSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgaW50ZXJzZWN0UG9pbnQgPSByYXkuY2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpbnRlcnNlY3RQb2ludC5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJzZWN0UG9pbnQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgcmV0dXJuO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGludGVyc2VjdHMucHVzaCgge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRpc3RhbmNlOiBkaXN0YW5jZSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkaXN0YW5jZVRvUmF5OiBNYXRoLnNxcnQoIHJheVBvaW50RGlzdGFuY2VTcSApLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHBvaW50OiBpbnRlcnNlY3RQb2ludC5jbG9uZSgpLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGluZGV4OiBpbmRleCxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmYWNlOiBudWxsLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdDogb2JqZWN0XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xcclxcblxcdFxcdFxcdFxcdFxcdHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBpbmRpY2VzID0gaW5kZXguYXJyYXk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGEgPSBpbmRpY2VzWyBpIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cG9zaXRpb24uZnJvbUFycmF5KCBwb3NpdGlvbnMsIGEgKiAzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGVzdFBvaW50KCBwb3NpdGlvbiwgYSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHBvc2l0aW9ucy5sZW5ndGggLyAzOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRwb3NpdGlvbi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSAqIDMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0ZXN0UG9pbnQoIHBvc2l0aW9uLCBpICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGVzdFBvaW50KCB2ZXJ0aWNlc1sgaSBdLCBpICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0oKSApLFxcclxcblxcclxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICkuY29weSggdGhpcyApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBHcm91cCgpIHtcXHJcXG5cXHJcXG5cXHRcXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50eXBlID0gJ0dyb3VwJztcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0R3JvdXAucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICksIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zdHJ1Y3RvcjogR3JvdXAsXFxyXFxuXFxyXFxuXFx0XFx0aXNHcm91cDogdHJ1ZVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIFZpZGVvVGV4dHVyZSggdmlkZW8sIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApIHtcXHJcXG5cXHJcXG5cXHRcXHRUZXh0dXJlLmNhbGwoIHRoaXMsIHZpZGVvLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdC8vIFNldCBuZWVkc1VwZGF0ZSB3aGVuIGZpcnN0IGZyYW1lIGlzIHJlYWR5XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHNjb3BlID0gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBvbkxvYWRlZCgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2aWRlby5yZW1vdmVFdmVudExpc3RlbmVyKCAnbG9hZGVkZGF0YScsIG9uTG9hZGVkLCBmYWxzZSApO1xcclxcblxcdFxcdFxcdHNjb3BlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0dmlkZW8uYWRkRXZlbnRMaXN0ZW5lciggJ2xvYWRlZGRhdGEnLCBvbkxvYWRlZCwgZmFsc2UgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0VmlkZW9UZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIFRleHR1cmUucHJvdG90eXBlICksIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zdHJ1Y3RvcjogVmlkZW9UZXh0dXJlLFxcclxcblxcclxcblxcdFxcdGlzVmlkZW9UZXh0dXJlOiB0cnVlLFxcclxcblxcclxcblxcdFxcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB2aWRlbyA9IHRoaXMuaW1hZ2U7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB2aWRlby5yZWFkeVN0YXRlID49IHZpZGVvLkhBVkVfQ1VSUkVOVF9EQVRBICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gQ29tcHJlc3NlZFRleHR1cmUoIG1pcG1hcHMsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgYW5pc290cm9weSwgZW5jb2RpbmcgKSB7XFxyXFxuXFxyXFxuXFx0XFx0VGV4dHVyZS5jYWxsKCB0aGlzLCBudWxsLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHksIGVuY29kaW5nICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5pbWFnZSA9IHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xcclxcblxcdFxcdHRoaXMubWlwbWFwcyA9IG1pcG1hcHM7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gbm8gZmxpcHBpbmcgZm9yIGN1YmUgdGV4dHVyZXNcXHJcXG5cXHRcXHQvLyAoYWxzbyBmbGlwcGluZyBkb2Vzbid0IHdvcmsgZm9yIGNvbXByZXNzZWQgdGV4dHVyZXMgKVxcclxcblxcclxcblxcdFxcdHRoaXMuZmxpcFkgPSBmYWxzZTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBjYW4ndCBnZW5lcmF0ZSBtaXBtYXBzIGZvciBjb21wcmVzc2VkIHRleHR1cmVzXFxyXFxuXFx0XFx0Ly8gbWlwcyBtdXN0IGJlIGVtYmVkZGVkIGluIEREUyBmaWxlc1xcclxcblxcclxcblxcdFxcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdENvbXByZXNzZWRUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRleHR1cmUucHJvdG90eXBlICk7XFxyXFxuXFx0Q29tcHJlc3NlZFRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29tcHJlc3NlZFRleHR1cmU7XFxyXFxuXFxyXFxuXFx0Q29tcHJlc3NlZFRleHR1cmUucHJvdG90eXBlLmlzQ29tcHJlc3NlZFRleHR1cmUgPSB0cnVlO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgTWF0dCBEZXNMYXVyaWVycyAvIEBtYXR0ZGVzbFxcclxcblxcdCAqIEBhdXRob3IgYXRpeCAvIGFydGh1cnNpbGJlci5kZVxcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIERlcHRoVGV4dHVyZSggd2lkdGgsIGhlaWdodCwgdHlwZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgYW5pc290cm9weSwgZm9ybWF0ICkge1xcclxcblxcclxcblxcdFxcdGZvcm1hdCA9IGZvcm1hdCAhPT0gdW5kZWZpbmVkID8gZm9ybWF0IDogRGVwdGhGb3JtYXQ7XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCBmb3JtYXQgIT09IERlcHRoRm9ybWF0ICYmIGZvcm1hdCAhPT0gRGVwdGhTdGVuY2lsRm9ybWF0ICkge1xcclxcblxcclxcblxcdFxcdFxcdHRocm93IG5ldyBFcnJvciggJ0RlcHRoVGV4dHVyZSBmb3JtYXQgbXVzdCBiZSBlaXRoZXIgVEhSRUUuRGVwdGhGb3JtYXQgb3IgVEhSRUUuRGVwdGhTdGVuY2lsRm9ybWF0JyApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRpZiAoIHR5cGUgPT09IHVuZGVmaW5lZCAmJiBmb3JtYXQgPT09IERlcHRoRm9ybWF0ICkgdHlwZSA9IFVuc2lnbmVkU2hvcnRUeXBlO1xcclxcblxcdFxcdGlmICggdHlwZSA9PT0gdW5kZWZpbmVkICYmIGZvcm1hdCA9PT0gRGVwdGhTdGVuY2lsRm9ybWF0ICkgdHlwZSA9IFVuc2lnbmVkSW50MjQ4VHlwZTtcXHJcXG5cXHJcXG5cXHRcXHRUZXh0dXJlLmNhbGwoIHRoaXMsIG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xcclxcblxcclxcblxcdFxcdHRoaXMuaW1hZ2UgPSB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWFnRmlsdGVyIDogTmVhcmVzdEZpbHRlcjtcXHJcXG5cXHRcXHR0aGlzLm1pbkZpbHRlciA9IG1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWluRmlsdGVyIDogTmVhcmVzdEZpbHRlcjtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmZsaXBZID0gZmFsc2U7XFxyXFxuXFx0XFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHNcXHQ9IGZhbHNlO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHREZXB0aFRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVGV4dHVyZS5wcm90b3R5cGUgKTtcXHJcXG5cXHREZXB0aFRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGVwdGhUZXh0dXJlO1xcclxcblxcdERlcHRoVGV4dHVyZS5wcm90b3R5cGUuaXNEZXB0aFRleHR1cmUgPSB0cnVlO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBXaXJlZnJhbWVHZW9tZXRyeSggZ2VvbWV0cnkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdXaXJlZnJhbWVHZW9tZXRyeSc7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gYnVmZmVyXFxyXFxuXFxyXFxuXFx0XFx0dmFyIHZlcnRpY2VzID0gW107XFxyXFxuXFxyXFxuXFx0XFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xcclxcblxcclxcblxcdFxcdHZhciBpLCBqLCBsLCBvLCBvbDtcXHJcXG5cXHRcXHR2YXIgZWRnZSA9IFsgMCwgMCBdLCBlZGdlcyA9IHt9LCBlLCBlZGdlMSwgZWRnZTI7XFxyXFxuXFx0XFx0dmFyIGtleSwga2V5cyA9IFsgJ2EnLCAnYicsICdjJyBdO1xcclxcblxcdFxcdHZhciB2ZXJ0ZXg7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gZGlmZmVyZW50IGxvZ2ljIGZvciBHZW9tZXRyeSBhbmQgQnVmZmVyR2VvbWV0cnlcXHJcXG5cXHJcXG5cXHRcXHRpZiAoIGdlb21ldHJ5ICYmIGdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gY3JlYXRlIGEgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBjb250YWlucyBhbGwgZWRnZXMgd2l0aG91dCBkdXBsaWNhdGVzXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCBqID0gMDsgaiA8IDM7IGogKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0ZWRnZTEgPSBmYWNlWyBrZXlzWyBqIF0gXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRlZGdlMiA9IGZhY2VbIGtleXNbICggaiArIDEgKSAlIDMgXSBdO1xcclxcblxcdFxcdFxcdFxcdFxcdGVkZ2VbIDAgXSA9IE1hdGgubWluKCBlZGdlMSwgZWRnZTIgKTsgLy8gc29ydGluZyBwcmV2ZW50cyBkdXBsaWNhdGVzXFxyXFxuXFx0XFx0XFx0XFx0XFx0ZWRnZVsgMSBdID0gTWF0aC5tYXgoIGVkZ2UxLCBlZGdlMiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGtleSA9IGVkZ2VbIDAgXSArICcsJyArIGVkZ2VbIDEgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGVkZ2VzWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGVkZ2VzWyBrZXkgXSA9IHsgaW5kZXgxOiBlZGdlWyAwIF0sIGluZGV4MjogZWRnZVsgMSBdIH07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gZ2VuZXJhdGUgdmVydGljZXNcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCBrZXkgaW4gZWRnZXMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZSA9IGVkZ2VzWyBrZXkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2ZXJ0ZXggPSBnZW9tZXRyeS52ZXJ0aWNlc1sgZS5pbmRleDEgXTtcXHJcXG5cXHRcXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmVydGV4ID0gZ2VvbWV0cnkudmVydGljZXNbIGUuaW5kZXgyIF07XFxyXFxuXFx0XFx0XFx0XFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9IGVsc2UgaWYgKCBnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBwb3NpdGlvbiwgaW5kaWNlcywgZ3JvdXBzO1xcclxcblxcdFxcdFxcdHZhciBncm91cCwgc3RhcnQsIGNvdW50O1xcclxcblxcdFxcdFxcdHZhciBpbmRleDEsIGluZGV4MjtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggZ2VvbWV0cnkuaW5kZXggIT09IG51bGwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gaW5kZXhlZCBCdWZmZXJHZW9tZXRyeVxcclxcblxcclxcblxcdFxcdFxcdFxcdHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcXHJcXG5cXHRcXHRcXHRcXHRpbmRpY2VzID0gZ2VvbWV0cnkuaW5kZXg7XFxyXFxuXFx0XFx0XFx0XFx0Z3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggZ3JvdXBzLmxlbmd0aCA9PT0gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRncm91cHMgPSBbIHsgc3RhcnQ6IDAsIGNvdW50OiBpbmRpY2VzLmNvdW50LCBtYXRlcmlhbEluZGV4OiAwIH0gXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gY3JlYXRlIGEgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBjb250YWlucyBhbGwgZWdlcyB3aXRob3V0IGR1cGxpY2F0ZXNcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCBvID0gMCwgb2wgPSBncm91cHMubGVuZ3RoOyBvIDwgb2w7ICsrIG8gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Z3JvdXAgPSBncm91cHNbIG8gXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRzdGFydCA9IGdyb3VwLnN0YXJ0O1xcclxcblxcdFxcdFxcdFxcdFxcdGNvdW50ID0gZ3JvdXAuY291bnQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggaSA9IHN0YXJ0LCBsID0gKCBzdGFydCArIGNvdW50ICk7IGkgPCBsOyBpICs9IDMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggaiA9IDA7IGogPCAzOyBqICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGVkZ2UxID0gaW5kaWNlcy5nZXRYKCBpICsgaiApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGVkZ2UyID0gaW5kaWNlcy5nZXRYKCBpICsgKCBqICsgMSApICUgMyApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGVkZ2VbIDAgXSA9IE1hdGgubWluKCBlZGdlMSwgZWRnZTIgKTsgLy8gc29ydGluZyBwcmV2ZW50cyBkdXBsaWNhdGVzXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZWRnZVsgMSBdID0gTWF0aC5tYXgoIGVkZ2UxLCBlZGdlMiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGtleSA9IGVkZ2VbIDAgXSArICcsJyArIGVkZ2VbIDEgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGVkZ2VzWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGVkZ2VzWyBrZXkgXSA9IHsgaW5kZXgxOiBlZGdlWyAwIF0sIGluZGV4MjogZWRnZVsgMSBdIH07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGdlbmVyYXRlIHZlcnRpY2VzXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICgga2V5IGluIGVkZ2VzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGUgPSBlZGdlc1sga2V5IF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmVydGV4LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBlLmluZGV4MSApO1xcclxcblxcdFxcdFxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0ZXguZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGUuaW5kZXgyICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIG5vbi1pbmRleGVkIEJ1ZmZlckdlb21ldHJ5XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIGkgPSAwLCBsID0gKCBwb3NpdGlvbi5jb3VudCAvIDMgKTsgaSA8IGw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggaiA9IDA7IGogPCAzOyBqICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHRocmVlIGVkZ2VzIHBlciB0cmlhbmdsZSwgYW4gZWRnZSBpcyByZXByZXNlbnRlZCBhcyAoaW5kZXgxLCBpbmRleDIpXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gZS5nLiB0aGUgZmlyc3QgdHJpYW5nbGUgaGFzIHRoZSBmb2xsb3dpbmcgZWRnZXM6ICgwLDEpLCgxLDIpLCgyLDApXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aW5kZXgxID0gMyAqIGkgKyBqO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHZlcnRleC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgaW5kZXgxICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGluZGV4MiA9IDMgKiBpICsgKCAoIGogKyAxICkgJSAzICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmVydGV4LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBpbmRleDIgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdC8vIGJ1aWxkIGdlb21ldHJ5XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdFdpcmVmcmFtZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xcclxcblxcdFdpcmVmcmFtZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFdpcmVmcmFtZUdlb21ldHJ5O1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3Igeno4NSAvIGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1XFxyXFxuXFx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcXHJcXG5cXHQgKlxcclxcblxcdCAqIFBhcmFtZXRyaWMgU3VyZmFjZXMgR2VvbWV0cnlcXHJcXG5cXHQgKiBiYXNlZCBvbiB0aGUgYnJpbGxpYW50IGFydGljbGUgYnkgQHByaWRlb3V0IGh0dHA6Ly9wcmlkZW91dC5uZXQvYmxvZy8/cD00NFxcclxcblxcdCAqL1xcclxcblxcclxcblxcdC8vIFBhcmFtZXRyaWNHZW9tZXRyeVxcclxcblxcclxcblxcdGZ1bmN0aW9uIFBhcmFtZXRyaWNHZW9tZXRyeSggZnVuYywgc2xpY2VzLCBzdGFja3MgKSB7XFxyXFxuXFxyXFxuXFx0XFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdQYXJhbWV0cmljR2VvbWV0cnknO1xcclxcblxcclxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXHJcXG5cXHRcXHRcXHRmdW5jOiBmdW5jLFxcclxcblxcdFxcdFxcdHNsaWNlczogc2xpY2VzLFxcclxcblxcdFxcdFxcdHN0YWNrczogc3RhY2tzXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IFBhcmFtZXRyaWNCdWZmZXJHZW9tZXRyeSggZnVuYywgc2xpY2VzLCBzdGFja3MgKSApO1xcclxcblxcdFxcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRQYXJhbWV0cmljR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XFxyXFxuXFx0UGFyYW1ldHJpY0dlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBhcmFtZXRyaWNHZW9tZXRyeTtcXHJcXG5cXHJcXG5cXHQvLyBQYXJhbWV0cmljQnVmZmVyR2VvbWV0cnlcXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBQYXJhbWV0cmljQnVmZmVyR2VvbWV0cnkoIGZ1bmMsIHNsaWNlcywgc3RhY2tzICkge1xcclxcblxcclxcblxcdFxcdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnUGFyYW1ldHJpY0J1ZmZlckdlb21ldHJ5JztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxyXFxuXFx0XFx0XFx0ZnVuYzogZnVuYyxcXHJcXG5cXHRcXHRcXHRzbGljZXM6IHNsaWNlcyxcXHJcXG5cXHRcXHRcXHRzdGFja3M6IHN0YWNrc1xcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0Ly8gYnVmZmVyc1xcclxcblxcclxcblxcdFxcdHZhciBpbmRpY2VzID0gW107XFxyXFxuXFx0XFx0dmFyIHZlcnRpY2VzID0gW107XFxyXFxuXFx0XFx0dmFyIG5vcm1hbHMgPSBbXTtcXHJcXG5cXHRcXHR2YXIgdXZzID0gW107XFxyXFxuXFxyXFxuXFx0XFx0dmFyIEVQUyA9IDAuMDAwMDE7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHAwID0gbmV3IFZlY3RvcjMoKSwgcDEgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdHZhciBwdSA9IG5ldyBWZWN0b3IzKCksIHB2ID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgaSwgajtcXHJcXG5cXHJcXG5cXHRcXHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXFxyXFxuXFxyXFxuXFx0XFx0dmFyIHNsaWNlQ291bnQgPSBzbGljZXMgKyAxO1xcclxcblxcclxcblxcdFxcdGZvciAoIGkgPSAwOyBpIDw9IHN0YWNrczsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdiA9IGkgLyBzdGFja3M7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggaiA9IDA7IGogPD0gc2xpY2VzOyBqICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciB1ID0gaiAvIHNsaWNlcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyB2ZXJ0ZXhcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRwMCA9IGZ1bmMoIHUsIHYsIHAwICk7XFxyXFxuXFx0XFx0XFx0XFx0dmVydGljZXMucHVzaCggcDAueCwgcDAueSwgcDAueiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIG5vcm1hbFxcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGFwcHJveGltYXRlIHRhbmdlbnQgdmVjdG9ycyB2aWEgZmluaXRlIGRpZmZlcmVuY2VzXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB1IC0gRVBTID49IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cDEgPSBmdW5jKCB1IC0gRVBTLCB2LCBwMSApO1xcclxcblxcdFxcdFxcdFxcdFxcdHB1LnN1YlZlY3RvcnMoIHAwLCBwMSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cDEgPSBmdW5jKCB1ICsgRVBTLCB2LCBwMSApO1xcclxcblxcdFxcdFxcdFxcdFxcdHB1LnN1YlZlY3RvcnMoIHAxLCBwMCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHYgLSBFUFMgPj0gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRwMSA9IGZ1bmMoIHUsIHYgLSBFUFMsIHAxICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0cHYuc3ViVmVjdG9ycyggcDAsIHAxICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRwMSA9IGZ1bmMoIHUsIHYgKyBFUFMsIHAxICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0cHYuc3ViVmVjdG9ycyggcDEsIHAwICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGNyb3NzIHByb2R1Y3Qgb2YgdGFuZ2VudCB2ZWN0b3JzIHJldHVybnMgc3VyZmFjZSBub3JtYWxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRub3JtYWwuY3Jvc3NWZWN0b3JzKCBwdSwgcHYgKS5ub3JtYWxpemUoKTtcXHJcXG5cXHRcXHRcXHRcXHRub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyB1dlxcclxcblxcclxcblxcdFxcdFxcdFxcdHV2cy5wdXNoKCB1LCB2ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHQvLyBnZW5lcmF0ZSBpbmRpY2VzXFxyXFxuXFxyXFxuXFx0XFx0Zm9yICggaSA9IDA7IGkgPCBzdGFja3M7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggaiA9IDA7IGogPCBzbGljZXM7IGogKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGEgPSBpICogc2xpY2VDb3VudCArIGo7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGIgPSBpICogc2xpY2VDb3VudCArIGogKyAxO1xcclxcblxcdFxcdFxcdFxcdHZhciBjID0gKCBpICsgMSApICogc2xpY2VDb3VudCArIGogKyAxO1xcclxcblxcdFxcdFxcdFxcdHZhciBkID0gKCBpICsgMSApICogc2xpY2VDb3VudCArIGo7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gZmFjZXMgb25lIGFuZCB0d29cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcXHJcXG5cXHRcXHRcXHRcXHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdC8vIGJ1aWxkIGdlb21ldHJ5XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xcclxcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xcclxcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xcclxcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0UGFyYW1ldHJpY0J1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xcclxcblxcdFBhcmFtZXRyaWNCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQYXJhbWV0cmljQnVmZmVyR2VvbWV0cnk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBjbG9ja3dvcmtnZWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL2Nsb2Nrd29ya2dlZWtcXHJcXG5cXHQgKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XFxyXFxuXFx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XFxyXFxuXFx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHQvLyBQb2x5aGVkcm9uR2VvbWV0cnlcXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBQb2x5aGVkcm9uR2VvbWV0cnkoIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50eXBlID0gJ1BvbHloZWRyb25HZW9tZXRyeSc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcclxcblxcdFxcdFxcdHZlcnRpY2VzOiB2ZXJ0aWNlcyxcXHJcXG5cXHRcXHRcXHRpbmRpY2VzOiBpbmRpY2VzLFxcclxcblxcdFxcdFxcdHJhZGl1czogcmFkaXVzLFxcclxcblxcdFxcdFxcdGRldGFpbDogZGV0YWlsXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeSggdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICkgKTtcXHJcXG5cXHRcXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0UG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xcclxcblxcdFBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2x5aGVkcm9uR2VvbWV0cnk7XFxyXFxuXFxyXFxuXFx0Ly8gUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5KCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnknO1xcclxcblxcclxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXHJcXG5cXHRcXHRcXHR2ZXJ0aWNlczogdmVydGljZXMsXFxyXFxuXFx0XFx0XFx0aW5kaWNlczogaW5kaWNlcyxcXHJcXG5cXHRcXHRcXHRyYWRpdXM6IHJhZGl1cyxcXHJcXG5cXHRcXHRcXHRkZXRhaWw6IGRldGFpbFxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0cmFkaXVzID0gcmFkaXVzIHx8IDE7XFxyXFxuXFx0XFx0ZGV0YWlsID0gZGV0YWlsIHx8IDA7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gZGVmYXVsdCBidWZmZXIgZGF0YVxcclxcblxcclxcblxcdFxcdHZhciB2ZXJ0ZXhCdWZmZXIgPSBbXTtcXHJcXG5cXHRcXHR2YXIgdXZCdWZmZXIgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHQvLyB0aGUgc3ViZGl2aXNpb24gY3JlYXRlcyB0aGUgdmVydGV4IGJ1ZmZlciBkYXRhXFxyXFxuXFxyXFxuXFx0XFx0c3ViZGl2aWRlKCBkZXRhaWwgKTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBhbGwgdmVydGljZXMgc2hvdWxkIGxpZSBvbiBhIGNvbmNlcHR1YWwgc3BoZXJlIHdpdGggYSBnaXZlbiByYWRpdXNcXHJcXG5cXHJcXG5cXHRcXHRhcHBwbHlSYWRpdXMoIHJhZGl1cyApO1xcclxcblxcclxcblxcdFxcdC8vIGZpbmFsbHksIGNyZWF0ZSB0aGUgdXYgZGF0YVxcclxcblxcclxcblxcdFxcdGdlbmVyYXRlVVZzKCk7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gYnVpbGQgbm9uLWluZGV4ZWQgZ2VvbWV0cnlcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRleEJ1ZmZlciwgMyApICk7XFxyXFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGV4QnVmZmVyLnNsaWNlKCksIDMgKSApO1xcclxcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZCdWZmZXIsIDIgKSApO1xcclxcblxcclxcblxcdFxcdGlmICggZGV0YWlsID09PSAwICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTsgLy8gZmxhdCBub3JtYWxzXFxyXFxuXFxyXFxuXFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm5vcm1hbGl6ZU5vcm1hbHMoKTsgLy8gc21vb3RoIG5vcm1hbHNcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0Ly8gaGVscGVyIGZ1bmN0aW9uc1xcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIHN1YmRpdmlkZSggZGV0YWlsICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBhID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHRcXHRcXHR2YXIgYiA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0XFx0dmFyIGMgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdFxcdFxcdC8vIGl0ZXJhdGUgb3ZlciBhbGwgZmFjZXMgYW5kIGFwcGx5IGEgc3ViZGl2aXNvbiB3aXRoIHRoZSBnaXZlbiBkZXRhaWwgdmFsdWVcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSArPSAzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGdldCB0aGUgdmVydGljZXMgb2YgdGhlIGZhY2VcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRnZXRWZXJ0ZXhCeUluZGV4KCBpbmRpY2VzWyBpICsgMCBdLCBhICk7XFxyXFxuXFx0XFx0XFx0XFx0Z2V0VmVydGV4QnlJbmRleCggaW5kaWNlc1sgaSArIDEgXSwgYiApO1xcclxcblxcdFxcdFxcdFxcdGdldFZlcnRleEJ5SW5kZXgoIGluZGljZXNbIGkgKyAyIF0sIGMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBwZXJmb3JtIHN1YmRpdmlzaW9uXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0c3ViZGl2aWRlRmFjZSggYSwgYiwgYywgZGV0YWlsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBzdWJkaXZpZGVGYWNlKCBhLCBiLCBjLCBkZXRhaWwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGNvbHMgPSBNYXRoLnBvdyggMiwgZGV0YWlsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gd2UgdXNlIHRoaXMgbXVsdGlkaW1lbnNpb25hbCBhcnJheSBhcyBhIGRhdGEgc3RydWN0dXJlIGZvciBjcmVhdGluZyB0aGUgc3ViZGl2aXNpb25cXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdiA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBpLCBqO1xcclxcblxcclxcblxcdFxcdFxcdC8vIGNvbnN0cnVjdCBhbGwgb2YgdGhlIHZlcnRpY2VzIGZvciB0aGlzIHN1YmRpdmlzaW9uXFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggaSA9IDA7IGkgPD0gY29sczsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2WyBpIF0gPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgYWogPSBhLmNsb25lKCkubGVycCggYywgaSAvIGNvbHMgKTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgYmogPSBiLmNsb25lKCkubGVycCggYywgaSAvIGNvbHMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgcm93cyA9IGNvbHMgLSBpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIGogPSAwOyBqIDw9IHJvd3M7IGogKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBqID09PSAwICYmIGkgPT09IGNvbHMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dlsgaSBdWyBqIF0gPSBhajtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHZbIGkgXVsgaiBdID0gYWouY2xvbmUoKS5sZXJwKCBiaiwgaiAvIHJvd3MgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBjb25zdHJ1Y3QgYWxsIG9mIHRoZSBmYWNlc1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDwgY29sczsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCBqID0gMDsgaiA8IDIgKiAoIGNvbHMgLSBpICkgLSAxOyBqICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBrID0gTWF0aC5mbG9vciggaiAvIDIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGogJSAyID09PSAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHB1c2hWZXJ0ZXgoIHZbIGkgXVsgayArIDEgXSApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHB1c2hWZXJ0ZXgoIHZbIGkgKyAxIF1bIGsgXSApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHB1c2hWZXJ0ZXgoIHZbIGkgXVsgayBdICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRwdXNoVmVydGV4KCB2WyBpIF1bIGsgKyAxIF0gKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRwdXNoVmVydGV4KCB2WyBpICsgMSBdWyBrICsgMSBdICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0cHVzaFZlcnRleCggdlsgaSArIDEgXVsgayBdICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIGFwcHBseVJhZGl1cyggcmFkaXVzICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdFxcdFxcdC8vIGl0ZXJhdGUgb3ZlciB0aGUgZW50aXJlIGJ1ZmZlciBhbmQgYXBwbHkgdGhlIHJhZGl1cyB0byBlYWNoIHZlcnRleFxcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IHZlcnRleEJ1ZmZlci5sZW5ndGg7IGkgKz0gMyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2ZXJ0ZXgueCA9IHZlcnRleEJ1ZmZlclsgaSArIDAgXTtcXHJcXG5cXHRcXHRcXHRcXHR2ZXJ0ZXgueSA9IHZlcnRleEJ1ZmZlclsgaSArIDEgXTtcXHJcXG5cXHRcXHRcXHRcXHR2ZXJ0ZXgueiA9IHZlcnRleEJ1ZmZlclsgaSArIDIgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2ZXJ0ZXgubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIHJhZGl1cyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZlcnRleEJ1ZmZlclsgaSArIDAgXSA9IHZlcnRleC54O1xcclxcblxcdFxcdFxcdFxcdHZlcnRleEJ1ZmZlclsgaSArIDEgXSA9IHZlcnRleC55O1xcclxcblxcdFxcdFxcdFxcdHZlcnRleEJ1ZmZlclsgaSArIDIgXSA9IHZlcnRleC56O1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gZ2VuZXJhdGVVVnMoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdmVydGV4QnVmZmVyLmxlbmd0aDsgaSArPSAzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZlcnRleC54ID0gdmVydGV4QnVmZmVyWyBpICsgMCBdO1xcclxcblxcdFxcdFxcdFxcdHZlcnRleC55ID0gdmVydGV4QnVmZmVyWyBpICsgMSBdO1xcclxcblxcdFxcdFxcdFxcdHZlcnRleC56ID0gdmVydGV4QnVmZmVyWyBpICsgMiBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciB1ID0gYXppbXV0aCggdmVydGV4ICkgLyAyIC8gTWF0aC5QSSArIDAuNTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgdiA9IGluY2xpbmF0aW9uKCB2ZXJ0ZXggKSAvIE1hdGguUEkgKyAwLjU7XFxyXFxuXFx0XFx0XFx0XFx0dXZCdWZmZXIucHVzaCggdSwgMSAtIHYgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29ycmVjdFVWcygpO1xcclxcblxcclxcblxcdFxcdFxcdGNvcnJlY3RTZWFtKCk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIGNvcnJlY3RTZWFtKCkge1xcclxcblxcclxcblxcdFxcdFxcdC8vIGhhbmRsZSBjYXNlIHdoZW4gZmFjZSBzdHJhZGRsZXMgdGhlIHNlYW0sIHNlZSAjMzI2OVxcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IHV2QnVmZmVyLmxlbmd0aDsgaSArPSA2ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIHV2IGRhdGEgb2YgYSBzaW5nbGUgZmFjZVxcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciB4MCA9IHV2QnVmZmVyWyBpICsgMCBdO1xcclxcblxcdFxcdFxcdFxcdHZhciB4MSA9IHV2QnVmZmVyWyBpICsgMiBdO1xcclxcblxcdFxcdFxcdFxcdHZhciB4MiA9IHV2QnVmZmVyWyBpICsgNCBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBtYXggPSBNYXRoLm1heCggeDAsIHgxLCB4MiApO1xcclxcblxcdFxcdFxcdFxcdHZhciBtaW4gPSBNYXRoLm1pbiggeDAsIHgxLCB4MiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIDAuOSBpcyBzb21ld2hhdCBhcmJpdHJhcnlcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIG1heCA+IDAuOSAmJiBtaW4gPCAwLjEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB4MCA8IDAuMiApIHV2QnVmZmVyWyBpICsgMCBdICs9IDE7XFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB4MSA8IDAuMiApIHV2QnVmZmVyWyBpICsgMiBdICs9IDE7XFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB4MiA8IDAuMiApIHV2QnVmZmVyWyBpICsgNCBdICs9IDE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gcHVzaFZlcnRleCggdmVydGV4ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZlcnRleEJ1ZmZlci5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIGdldFZlcnRleEJ5SW5kZXgoIGluZGV4LCB2ZXJ0ZXggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHN0cmlkZSA9IGluZGV4ICogMztcXHJcXG5cXHJcXG5cXHRcXHRcXHR2ZXJ0ZXgueCA9IHZlcnRpY2VzWyBzdHJpZGUgKyAwIF07XFxyXFxuXFx0XFx0XFx0dmVydGV4LnkgPSB2ZXJ0aWNlc1sgc3RyaWRlICsgMSBdO1xcclxcblxcdFxcdFxcdHZlcnRleC56ID0gdmVydGljZXNbIHN0cmlkZSArIDIgXTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gY29ycmVjdFVWcygpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgYSA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0XFx0dmFyIGIgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdFxcdHZhciBjID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgY2VudHJvaWQgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdFxcdFxcdHZhciB1dkEgPSBuZXcgVmVjdG9yMigpO1xcclxcblxcdFxcdFxcdHZhciB1dkIgPSBuZXcgVmVjdG9yMigpO1xcclxcblxcdFxcdFxcdHZhciB1dkMgPSBuZXcgVmVjdG9yMigpO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaiA9IDA7IGkgPCB2ZXJ0ZXhCdWZmZXIubGVuZ3RoOyBpICs9IDksIGogKz0gNiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRhLnNldCggdmVydGV4QnVmZmVyWyBpICsgMCBdLCB2ZXJ0ZXhCdWZmZXJbIGkgKyAxIF0sIHZlcnRleEJ1ZmZlclsgaSArIDIgXSApO1xcclxcblxcdFxcdFxcdFxcdGIuc2V0KCB2ZXJ0ZXhCdWZmZXJbIGkgKyAzIF0sIHZlcnRleEJ1ZmZlclsgaSArIDQgXSwgdmVydGV4QnVmZmVyWyBpICsgNSBdICk7XFxyXFxuXFx0XFx0XFx0XFx0Yy5zZXQoIHZlcnRleEJ1ZmZlclsgaSArIDYgXSwgdmVydGV4QnVmZmVyWyBpICsgNyBdLCB2ZXJ0ZXhCdWZmZXJbIGkgKyA4IF0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR1dkEuc2V0KCB1dkJ1ZmZlclsgaiArIDAgXSwgdXZCdWZmZXJbIGogKyAxIF0gKTtcXHJcXG5cXHRcXHRcXHRcXHR1dkIuc2V0KCB1dkJ1ZmZlclsgaiArIDIgXSwgdXZCdWZmZXJbIGogKyAzIF0gKTtcXHJcXG5cXHRcXHRcXHRcXHR1dkMuc2V0KCB1dkJ1ZmZlclsgaiArIDQgXSwgdXZCdWZmZXJbIGogKyA1IF0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjZW50cm9pZC5jb3B5KCBhICkuYWRkKCBiICkuYWRkKCBjICkuZGl2aWRlU2NhbGFyKCAzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGF6aSA9IGF6aW11dGgoIGNlbnRyb2lkICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29ycmVjdFVWKCB1dkEsIGogKyAwLCBhLCBhemkgKTtcXHJcXG5cXHRcXHRcXHRcXHRjb3JyZWN0VVYoIHV2QiwgaiArIDIsIGIsIGF6aSApO1xcclxcblxcdFxcdFxcdFxcdGNvcnJlY3RVViggdXZDLCBqICsgNCwgYywgYXppICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBjb3JyZWN0VVYoIHV2LCBzdHJpZGUsIHZlY3RvciwgYXppbXV0aCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoICggYXppbXV0aCA8IDAgKSAmJiAoIHV2LnggPT09IDEgKSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR1dkJ1ZmZlclsgc3RyaWRlIF0gPSB1di54IC0gMTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCAoIHZlY3Rvci54ID09PSAwICkgJiYgKCB2ZWN0b3IueiA9PT0gMCApICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHV2QnVmZmVyWyBzdHJpZGUgXSA9IGF6aW11dGggLyAyIC8gTWF0aC5QSSArIDAuNTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdC8vIEFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzLCBjb3VudGVyLWNsb2Nrd2lzZSB3aGVuIGxvb2tpbmcgZnJvbSBhYm92ZS5cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBhemltdXRoKCB2ZWN0b3IgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIE1hdGguYXRhbjIoIHZlY3Rvci56LCAtIHZlY3Rvci54ICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcclxcblxcdFxcdC8vIEFuZ2xlIGFib3ZlIHRoZSBYWiBwbGFuZS5cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBpbmNsaW5hdGlvbiggdmVjdG9yICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBNYXRoLmF0YW4yKCAtIHZlY3Rvci55LCBNYXRoLnNxcnQoICggdmVjdG9yLnggKiB2ZWN0b3IueCApICsgKCB2ZWN0b3IueiAqIHZlY3Rvci56ICkgKSApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0UG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xcclxcblxcdFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxcclxcblxcdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0Ly8gVGV0cmFoZWRyb25HZW9tZXRyeVxcclxcblxcclxcblxcdGZ1bmN0aW9uIFRldHJhaGVkcm9uR2VvbWV0cnkoIHJhZGl1cywgZGV0YWlsICkge1xcclxcblxcclxcblxcdFxcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnVGV0cmFoZWRyb25HZW9tZXRyeSc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcclxcblxcdFxcdFxcdHJhZGl1czogcmFkaXVzLFxcclxcblxcdFxcdFxcdGRldGFpbDogZGV0YWlsXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IFRldHJhaGVkcm9uQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgZGV0YWlsICkgKTtcXHJcXG5cXHRcXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0VGV0cmFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcXHJcXG5cXHRUZXRyYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRldHJhaGVkcm9uR2VvbWV0cnk7XFxyXFxuXFxyXFxuXFx0Ly8gVGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeVxcclxcblxcclxcblxcdGZ1bmN0aW9uIFRldHJhaGVkcm9uQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgZGV0YWlsICkge1xcclxcblxcclxcblxcdFxcdHZhciB2ZXJ0aWNlcyA9IFtcXHJcXG5cXHRcXHRcXHQxLCAxLCAxLCBcXHQtIDEsIC0gMSwgMSwgXFx0LSAxLCAxLCAtIDEsIFxcdDEsIC0gMSwgLSAxXFxyXFxuXFx0XFx0XTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgaW5kaWNlcyA9IFtcXHJcXG5cXHRcXHRcXHQyLCAxLCAwLCBcXHQwLCAzLCAyLFxcdDEsIDMsIDAsXFx0MiwgMywgMVxcclxcblxcdFxcdF07XFxyXFxuXFxyXFxuXFx0XFx0UG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdUZXRyYWhlZHJvbkJ1ZmZlckdlb21ldHJ5JztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxyXFxuXFx0XFx0XFx0cmFkaXVzOiByYWRpdXMsXFxyXFxuXFx0XFx0XFx0ZGV0YWlsOiBkZXRhaWxcXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRUZXRyYWhlZHJvbkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcXHJcXG5cXHRUZXRyYWhlZHJvbkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRldHJhaGVkcm9uQnVmZmVyR2VvbWV0cnk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxcclxcblxcdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0Ly8gT2N0YWhlZHJvbkdlb21ldHJ5XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gT2N0YWhlZHJvbkdlb21ldHJ5KCByYWRpdXMsIGRldGFpbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50eXBlID0gJ09jdGFoZWRyb25HZW9tZXRyeSc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcclxcblxcdFxcdFxcdHJhZGl1czogcmFkaXVzLFxcclxcblxcdFxcdFxcdGRldGFpbDogZGV0YWlsXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IE9jdGFoZWRyb25CdWZmZXJHZW9tZXRyeSggcmFkaXVzLCBkZXRhaWwgKSApO1xcclxcblxcdFxcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRPY3RhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XFxyXFxuXFx0T2N0YWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE9jdGFoZWRyb25HZW9tZXRyeTtcXHJcXG5cXHJcXG5cXHQvLyBPY3RhaGVkcm9uQnVmZmVyR2VvbWV0cnlcXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBPY3RhaGVkcm9uQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgZGV0YWlsICkge1xcclxcblxcclxcblxcdFxcdHZhciB2ZXJ0aWNlcyA9IFtcXHJcXG5cXHRcXHRcXHQxLCAwLCAwLCBcXHQtIDEsIDAsIDAsXFx0MCwgMSwgMCxcXHJcXG5cXHRcXHRcXHQwLCAtIDEsIDAsIFxcdDAsIDAsIDEsXFx0MCwgMCwgLSAxXFxyXFxuXFx0XFx0XTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgaW5kaWNlcyA9IFtcXHJcXG5cXHRcXHRcXHQwLCAyLCA0LFxcdDAsIDQsIDMsXFx0MCwgMywgNSxcXHJcXG5cXHRcXHRcXHQwLCA1LCAyLFxcdDEsIDIsIDUsXFx0MSwgNSwgMyxcXHJcXG5cXHRcXHRcXHQxLCAzLCA0LFxcdDEsIDQsIDJcXHJcXG5cXHRcXHRdO1xcclxcblxcclxcblxcdFxcdFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnT2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5JztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxyXFxuXFx0XFx0XFx0cmFkaXVzOiByYWRpdXMsXFxyXFxuXFx0XFx0XFx0ZGV0YWlsOiBkZXRhaWxcXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRPY3RhaGVkcm9uQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xcclxcblxcdE9jdGFoZWRyb25CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPY3RhaGVkcm9uQnVmZmVyR2VvbWV0cnk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxcclxcblxcdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0Ly8gSWNvc2FoZWRyb25HZW9tZXRyeVxcclxcblxcclxcblxcdGZ1bmN0aW9uIEljb3NhaGVkcm9uR2VvbWV0cnkoIHJhZGl1cywgZGV0YWlsICkge1xcclxcblxcclxcblxcdFxcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnSWNvc2FoZWRyb25HZW9tZXRyeSc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcclxcblxcdFxcdFxcdHJhZGl1czogcmFkaXVzLFxcclxcblxcdFxcdFxcdGRldGFpbDogZGV0YWlsXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IEljb3NhaGVkcm9uQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgZGV0YWlsICkgKTtcXHJcXG5cXHRcXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0SWNvc2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcXHJcXG5cXHRJY29zYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEljb3NhaGVkcm9uR2VvbWV0cnk7XFxyXFxuXFxyXFxuXFx0Ly8gSWNvc2FoZWRyb25CdWZmZXJHZW9tZXRyeVxcclxcblxcclxcblxcdGZ1bmN0aW9uIEljb3NhaGVkcm9uQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgZGV0YWlsICkge1xcclxcblxcclxcblxcdFxcdHZhciB0ID0gKCAxICsgTWF0aC5zcXJ0KCA1ICkgKSAvIDI7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHZlcnRpY2VzID0gW1xcclxcblxcdFxcdFxcdC0gMSwgdCwgMCwgXFx0MSwgdCwgMCwgXFx0LSAxLCAtIHQsIDAsIFxcdDEsIC0gdCwgMCxcXHJcXG5cXHRcXHRcXHQgMCwgLSAxLCB0LCBcXHQwLCAxLCB0LFxcdDAsIC0gMSwgLSB0LCBcXHQwLCAxLCAtIHQsXFxyXFxuXFx0XFx0XFx0IHQsIDAsIC0gMSwgXFx0dCwgMCwgMSwgXFx0LSB0LCAwLCAtIDEsIFxcdC0gdCwgMCwgMVxcclxcblxcdFxcdF07XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGluZGljZXMgPSBbXFxyXFxuXFx0XFx0XFx0IDAsIDExLCA1LCBcXHQwLCA1LCAxLCBcXHQwLCAxLCA3LCBcXHQwLCA3LCAxMCwgXFx0MCwgMTAsIDExLFxcclxcblxcdFxcdFxcdCAxLCA1LCA5LCBcXHQ1LCAxMSwgNCxcXHQxMSwgMTAsIDIsXFx0MTAsIDcsIDYsXFx0NywgMSwgOCxcXHJcXG5cXHRcXHRcXHQgMywgOSwgNCwgXFx0MywgNCwgMixcXHQzLCAyLCA2LFxcdDMsIDYsIDgsXFx0MywgOCwgOSxcXHJcXG5cXHRcXHRcXHQgNCwgOSwgNSwgXFx0MiwgNCwgMTEsXFx0NiwgMiwgMTAsXFx0OCwgNiwgNyxcXHQ5LCA4LCAxXFxyXFxuXFx0XFx0XTtcXHJcXG5cXHJcXG5cXHRcXHRQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcywgdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50eXBlID0gJ0ljb3NhaGVkcm9uQnVmZmVyR2VvbWV0cnknO1xcclxcblxcclxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXHJcXG5cXHRcXHRcXHRyYWRpdXM6IHJhZGl1cyxcXHJcXG5cXHRcXHRcXHRkZXRhaWw6IGRldGFpbFxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdEljb3NhaGVkcm9uQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xcclxcblxcdEljb3NhaGVkcm9uQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSWNvc2FoZWRyb25CdWZmZXJHZW9tZXRyeTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIEFiZSBQYXpvcyAvIGh0dHBzOi8vaGFtb2lkLmNvbVxcclxcblxcdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0Ly8gRG9kZWNhaGVkcm9uR2VvbWV0cnlcXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBEb2RlY2FoZWRyb25HZW9tZXRyeSggcmFkaXVzLCBkZXRhaWwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdEb2RlY2FoZWRyb25HZW9tZXRyeSc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcclxcblxcdFxcdFxcdHJhZGl1czogcmFkaXVzLFxcclxcblxcdFxcdFxcdGRldGFpbDogZGV0YWlsXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IERvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIGRldGFpbCApICk7XFxyXFxuXFx0XFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdERvZGVjYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xcclxcblxcdERvZGVjYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERvZGVjYWhlZHJvbkdlb21ldHJ5O1xcclxcblxcclxcblxcdC8vIERvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gRG9kZWNhaGVkcm9uQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgZGV0YWlsICkge1xcclxcblxcclxcblxcdFxcdHZhciB0ID0gKCAxICsgTWF0aC5zcXJ0KCA1ICkgKSAvIDI7XFxyXFxuXFx0XFx0dmFyIHIgPSAxIC8gdDtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgdmVydGljZXMgPSBbXFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gKMKxMSwgwrExLCDCsTEpXFxyXFxuXFx0XFx0XFx0LSAxLCAtIDEsIC0gMSxcXHQtIDEsIC0gMSwgMSxcXHJcXG5cXHRcXHRcXHQtIDEsIDEsIC0gMSwgLSAxLCAxLCAxLFxcclxcblxcdFxcdFxcdDEsIC0gMSwgLSAxLCAxLCAtIDEsIDEsXFxyXFxuXFx0XFx0XFx0MSwgMSwgLSAxLCAxLCAxLCAxLFxcclxcblxcclxcblxcdFxcdFxcdC8vICgwLCDCsTEvz4YsIMKxz4YpXFxyXFxuXFx0XFx0XFx0IDAsIC0gciwgLSB0LCAwLCAtIHIsIHQsXFxyXFxuXFx0XFx0XFx0IDAsIHIsIC0gdCwgMCwgciwgdCxcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyAowrExL8+GLCDCsc+GLCAwKVxcclxcblxcdFxcdFxcdC0gciwgLSB0LCAwLCAtIHIsIHQsIDAsXFxyXFxuXFx0XFx0XFx0IHIsIC0gdCwgMCwgciwgdCwgMCxcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyAowrHPhiwgMCwgwrExL8+GKVxcclxcblxcdFxcdFxcdC0gdCwgMCwgLSByLCB0LCAwLCAtIHIsXFxyXFxuXFx0XFx0XFx0LSB0LCAwLCByLCB0LCAwLCByXFxyXFxuXFx0XFx0XTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgaW5kaWNlcyA9IFtcXHJcXG5cXHRcXHRcXHQzLCAxMSwgNywgXFx0MywgNywgMTUsIFxcdDMsIDE1LCAxMyxcXHJcXG5cXHRcXHRcXHQ3LCAxOSwgMTcsIFxcdDcsIDE3LCA2LCBcXHQ3LCA2LCAxNSxcXHJcXG5cXHRcXHRcXHQxNywgNCwgOCwgXFx0MTcsIDgsIDEwLCBcXHQxNywgMTAsIDYsXFxyXFxuXFx0XFx0XFx0OCwgMCwgMTYsIFxcdDgsIDE2LCAyLCBcXHQ4LCAyLCAxMCxcXHJcXG5cXHRcXHRcXHQwLCAxMiwgMSwgXFx0MCwgMSwgMTgsIFxcdDAsIDE4LCAxNixcXHJcXG5cXHRcXHRcXHQ2LCAxMCwgMiwgXFx0NiwgMiwgMTMsIFxcdDYsIDEzLCAxNSxcXHJcXG5cXHRcXHRcXHQyLCAxNiwgMTgsIFxcdDIsIDE4LCAzLCBcXHQyLCAzLCAxMyxcXHJcXG5cXHRcXHRcXHQxOCwgMSwgOSwgXFx0MTgsIDksIDExLCBcXHQxOCwgMTEsIDMsXFxyXFxuXFx0XFx0XFx0NCwgMTQsIDEyLCBcXHQ0LCAxMiwgMCwgXFx0NCwgMCwgOCxcXHJcXG5cXHRcXHRcXHQxMSwgOSwgNSwgXFx0MTEsIDUsIDE5LCBcXHQxMSwgMTksIDcsXFxyXFxuXFx0XFx0XFx0MTksIDUsIDE0LCBcXHQxOSwgMTQsIDQsIFxcdDE5LCA0LCAxNyxcXHJcXG5cXHRcXHRcXHQxLCAxMiwgMTQsIFxcdDEsIDE0LCA1LCBcXHQxLCA1LCA5XFxyXFxuXFx0XFx0XTtcXHJcXG5cXHJcXG5cXHRcXHRQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcywgdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50eXBlID0gJ0RvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5JztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxyXFxuXFx0XFx0XFx0cmFkaXVzOiByYWRpdXMsXFxyXFxuXFx0XFx0XFx0ZGV0YWlsOiBkZXRhaWxcXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHREb2RlY2FoZWRyb25CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XFxyXFxuXFx0RG9kZWNhaGVkcm9uQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRG9kZWNhaGVkcm9uQnVmZmVyR2VvbWV0cnk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBvb3Ntb3hpZWNvZGUgLyBodHRwczovL2dpdGh1Yi5jb20vb29zbW94aWVjb2RlXFxyXFxuXFx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxcclxcblxcdCAqIEBhdXRob3Igeno4NSAvIGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1XFxyXFxuXFx0ICogQGF1dGhvciBtaW5pbmdvbGQgLyBodHRwczovL2dpdGh1Yi5jb20vbWluaW5nb2xkXFxyXFxuXFx0ICogQGF1dGhvciBqb25vYnIxIC8gaHR0cHM6Ly9naXRodWIuY29tL2pvbm9icjFcXHJcXG5cXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xcclxcblxcdCAqXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0Ly8gVHViZUdlb21ldHJ5XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gVHViZUdlb21ldHJ5KCBwYXRoLCB0dWJ1bGFyU2VnbWVudHMsIHJhZGl1cywgcmFkaWFsU2VnbWVudHMsIGNsb3NlZCwgdGFwZXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdUdWJlR2VvbWV0cnknO1xcclxcblxcclxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXHJcXG5cXHRcXHRcXHRwYXRoOiBwYXRoLFxcclxcblxcdFxcdFxcdHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxcclxcblxcdFxcdFxcdHJhZGl1czogcmFkaXVzLFxcclxcblxcdFxcdFxcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcXHJcXG5cXHRcXHRcXHRjbG9zZWQ6IGNsb3NlZFxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCB0YXBlciAhPT0gdW5kZWZpbmVkICkgY29uc29sZS53YXJuKCAnVEhSRUUuVHViZUdlb21ldHJ5OiB0YXBlciBoYXMgYmVlbiByZW1vdmVkLicgKTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgYnVmZmVyR2VvbWV0cnkgPSBuZXcgVHViZUJ1ZmZlckdlb21ldHJ5KCBwYXRoLCB0dWJ1bGFyU2VnbWVudHMsIHJhZGl1cywgcmFkaWFsU2VnbWVudHMsIGNsb3NlZCApO1xcclxcblxcclxcblxcdFxcdC8vIGV4cG9zZSBpbnRlcm5hbHNcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnRhbmdlbnRzID0gYnVmZmVyR2VvbWV0cnkudGFuZ2VudHM7XFxyXFxuXFx0XFx0dGhpcy5ub3JtYWxzID0gYnVmZmVyR2VvbWV0cnkubm9ybWFscztcXHJcXG5cXHRcXHR0aGlzLmJpbm9ybWFscyA9IGJ1ZmZlckdlb21ldHJ5LmJpbm9ybWFscztcXHJcXG5cXHJcXG5cXHRcXHQvLyBjcmVhdGUgZ2VvbWV0cnlcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggYnVmZmVyR2VvbWV0cnkgKTtcXHJcXG5cXHRcXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0VHViZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xcclxcblxcdFR1YmVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUdWJlR2VvbWV0cnk7XFxyXFxuXFxyXFxuXFx0Ly8gVHViZUJ1ZmZlckdlb21ldHJ5XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gVHViZUJ1ZmZlckdlb21ldHJ5KCBwYXRoLCB0dWJ1bGFyU2VnbWVudHMsIHJhZGl1cywgcmFkaWFsU2VnbWVudHMsIGNsb3NlZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50eXBlID0gJ1R1YmVCdWZmZXJHZW9tZXRyeSc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcclxcblxcdFxcdFxcdHBhdGg6IHBhdGgsXFxyXFxuXFx0XFx0XFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXFxyXFxuXFx0XFx0XFx0cmFkaXVzOiByYWRpdXMsXFxyXFxuXFx0XFx0XFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxcclxcblxcdFxcdFxcdGNsb3NlZDogY2xvc2VkXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0dWJ1bGFyU2VnbWVudHMgPSB0dWJ1bGFyU2VnbWVudHMgfHwgNjQ7XFxyXFxuXFx0XFx0cmFkaXVzID0gcmFkaXVzIHx8IDE7XFxyXFxuXFx0XFx0cmFkaWFsU2VnbWVudHMgPSByYWRpYWxTZWdtZW50cyB8fCA4O1xcclxcblxcdFxcdGNsb3NlZCA9IGNsb3NlZCB8fCBmYWxzZTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgZnJhbWVzID0gcGF0aC5jb21wdXRlRnJlbmV0RnJhbWVzKCB0dWJ1bGFyU2VnbWVudHMsIGNsb3NlZCApO1xcclxcblxcclxcblxcdFxcdC8vIGV4cG9zZSBpbnRlcm5hbHNcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnRhbmdlbnRzID0gZnJhbWVzLnRhbmdlbnRzO1xcclxcblxcdFxcdHRoaXMubm9ybWFscyA9IGZyYW1lcy5ub3JtYWxzO1xcclxcblxcdFxcdHRoaXMuYmlub3JtYWxzID0gZnJhbWVzLmJpbm9ybWFscztcXHJcXG5cXHJcXG5cXHRcXHQvLyBoZWxwZXIgdmFyaWFibGVzXFxyXFxuXFxyXFxuXFx0XFx0dmFyIHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0dmFyIG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0dmFyIHV2ID0gbmV3IFZlY3RvcjIoKTtcXHJcXG5cXHRcXHR2YXIgUCA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGksIGo7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gYnVmZmVyXFxyXFxuXFxyXFxuXFx0XFx0dmFyIHZlcnRpY2VzID0gW107XFxyXFxuXFx0XFx0dmFyIG5vcm1hbHMgPSBbXTtcXHJcXG5cXHRcXHR2YXIgdXZzID0gW107XFxyXFxuXFx0XFx0dmFyIGluZGljZXMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBjcmVhdGUgYnVmZmVyIGRhdGFcXHJcXG5cXHJcXG5cXHRcXHRnZW5lcmF0ZUJ1ZmZlckRhdGEoKTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBidWlsZCBnZW9tZXRyeVxcclxcblxcclxcblxcdFxcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcXHJcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcXHJcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcXHJcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gZnVuY3Rpb25zXFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gZ2VuZXJhdGVCdWZmZXJEYXRhKCkge1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDwgdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGdlbmVyYXRlU2VnbWVudCggaSApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBpZiB0aGUgZ2VvbWV0cnkgaXMgbm90IGNsb3NlZCwgZ2VuZXJhdGUgdGhlIGxhc3Qgcm93IG9mIHZlcnRpY2VzIGFuZCBub3JtYWxzXFxyXFxuXFx0XFx0XFx0Ly8gYXQgdGhlIHJlZ3VsYXIgcG9zaXRpb24gb24gdGhlIGdpdmVuIHBhdGhcXHJcXG5cXHRcXHRcXHQvL1xcclxcblxcdFxcdFxcdC8vIGlmIHRoZSBnZW9tZXRyeSBpcyBjbG9zZWQsIGR1cGxpY2F0ZSB0aGUgZmlyc3Qgcm93IG9mIHZlcnRpY2VzIGFuZCBub3JtYWxzICh1dnMgd2lsbCBkaWZmZXIpXFxyXFxuXFxyXFxuXFx0XFx0XFx0Z2VuZXJhdGVTZWdtZW50KCAoIGNsb3NlZCA9PT0gZmFsc2UgKSA/IHR1YnVsYXJTZWdtZW50cyA6IDAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyB1dnMgYXJlIGdlbmVyYXRlZCBpbiBhIHNlcGFyYXRlIGZ1bmN0aW9uLlxcclxcblxcdFxcdFxcdC8vIHRoaXMgbWFrZXMgaXQgZWFzeSBjb21wdXRlIGNvcnJlY3QgdmFsdWVzIGZvciBjbG9zZWQgZ2VvbWV0cmllc1xcclxcblxcclxcblxcdFxcdFxcdGdlbmVyYXRlVVZzKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gZmluYWxseSBjcmVhdGUgZmFjZXNcXHJcXG5cXHJcXG5cXHRcXHRcXHRnZW5lcmF0ZUluZGljZXMoKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gZ2VuZXJhdGVTZWdtZW50KCBpICkge1xcclxcblxcclxcblxcdFxcdFxcdC8vIHdlIHVzZSBnZXRQb2ludEF0IHRvIHNhbXBsZSBldmVubHkgZGlzdHJpYnV0ZWQgcG9pbnRzIGZyb20gdGhlIGdpdmVuIHBhdGhcXHJcXG5cXHJcXG5cXHRcXHRcXHRQID0gcGF0aC5nZXRQb2ludEF0KCBpIC8gdHVidWxhclNlZ21lbnRzLCBQICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gcmV0cmlldmUgY29ycmVzcG9uZGluZyBub3JtYWwgYW5kIGJpbm9ybWFsXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIE4gPSBmcmFtZXMubm9ybWFsc1sgaSBdO1xcclxcblxcdFxcdFxcdHZhciBCID0gZnJhbWVzLmJpbm9ybWFsc1sgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdC8vIGdlbmVyYXRlIG5vcm1hbHMgYW5kIHZlcnRpY2VzIGZvciB0aGUgY3VycmVudCBzZWdtZW50XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHYgPSBqIC8gcmFkaWFsU2VnbWVudHMgKiBNYXRoLlBJICogMjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgc2luID0gTWF0aC5zaW4oIHYgKTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgY29zID0gLSBNYXRoLmNvcyggdiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIG5vcm1hbFxcclxcblxcclxcblxcdFxcdFxcdFxcdG5vcm1hbC54ID0gKCBjb3MgKiBOLnggKyBzaW4gKiBCLnggKTtcXHJcXG5cXHRcXHRcXHRcXHRub3JtYWwueSA9ICggY29zICogTi55ICsgc2luICogQi55ICk7XFxyXFxuXFx0XFx0XFx0XFx0bm9ybWFsLnogPSAoIGNvcyAqIE4ueiArIHNpbiAqIEIueiApO1xcclxcblxcdFxcdFxcdFxcdG5vcm1hbC5ub3JtYWxpemUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyB2ZXJ0ZXhcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2ZXJ0ZXgueCA9IFAueCArIHJhZGl1cyAqIG5vcm1hbC54O1xcclxcblxcdFxcdFxcdFxcdHZlcnRleC55ID0gUC55ICsgcmFkaXVzICogbm9ybWFsLnk7XFxyXFxuXFx0XFx0XFx0XFx0dmVydGV4LnogPSBQLnogKyByYWRpdXMgKiBub3JtYWwuejtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBnZW5lcmF0ZUluZGljZXMoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggaiA9IDE7IGogPD0gdHVidWxhclNlZ21lbnRzOyBqICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIGkgPSAxOyBpIDw9IHJhZGlhbFNlZ21lbnRzOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBhID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArICggaSAtIDEgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgYiA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiBqICsgKCBpIC0gMSApO1xcclxcblxcdFxcdFxcdFxcdFxcdHZhciBjID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqIGogKyBpO1xcclxcblxcdFxcdFxcdFxcdFxcdHZhciBkID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArIGk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gZmFjZXNcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBnZW5lcmF0ZVVWcygpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCBpID0gMDsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dXYueCA9IGkgLyB0dWJ1bGFyU2VnbWVudHM7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dXYueSA9IGogLyByYWRpYWxTZWdtZW50cztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR1dnMucHVzaCggdXYueCwgdXYueSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRUdWJlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XFxyXFxuXFx0VHViZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFR1YmVCdWZmZXJHZW9tZXRyeTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIG9vc21veGllY29kZVxcclxcblxcdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBiYXNlZCBvbiBodHRwOi8vd3d3LmJsYWNrcGF3bi5jb20vdGV4dHMvcHF0b3J1cy9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHQvLyBUb3J1c0tub3RHZW9tZXRyeVxcclxcblxcclxcblxcdGZ1bmN0aW9uIFRvcnVzS25vdEdlb21ldHJ5KCByYWRpdXMsIHR1YmUsIHR1YnVsYXJTZWdtZW50cywgcmFkaWFsU2VnbWVudHMsIHAsIHEsIGhlaWdodFNjYWxlICkge1xcclxcblxcclxcblxcdFxcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnVG9ydXNLbm90R2VvbWV0cnknO1xcclxcblxcclxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXHJcXG5cXHRcXHRcXHRyYWRpdXM6IHJhZGl1cyxcXHJcXG5cXHRcXHRcXHR0dWJlOiB0dWJlLFxcclxcblxcdFxcdFxcdHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxcclxcblxcdFxcdFxcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcXHJcXG5cXHRcXHRcXHRwOiBwLFxcclxcblxcdFxcdFxcdHE6IHFcXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdFxcdGlmICggaGVpZ2h0U2NhbGUgIT09IHVuZGVmaW5lZCApIGNvbnNvbGUud2FybiggJ1RIUkVFLlRvcnVzS25vdEdlb21ldHJ5OiBoZWlnaHRTY2FsZSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLnNjYWxlKCB4LCB5LCB6ICkgaW5zdGVhZC4nICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBUb3J1c0tub3RCdWZmZXJHZW9tZXRyeSggcmFkaXVzLCB0dWJlLCB0dWJ1bGFyU2VnbWVudHMsIHJhZGlhbFNlZ21lbnRzLCBwLCBxICkgKTtcXHJcXG5cXHRcXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0VG9ydXNLbm90R2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XFxyXFxuXFx0VG9ydXNLbm90R2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVG9ydXNLbm90R2VvbWV0cnk7XFxyXFxuXFxyXFxuXFx0Ly8gVG9ydXNLbm90QnVmZmVyR2VvbWV0cnlcXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBUb3J1c0tub3RCdWZmZXJHZW9tZXRyeSggcmFkaXVzLCB0dWJlLCB0dWJ1bGFyU2VnbWVudHMsIHJhZGlhbFNlZ21lbnRzLCBwLCBxICkge1xcclxcblxcclxcblxcdFxcdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnVG9ydXNLbm90QnVmZmVyR2VvbWV0cnknO1xcclxcblxcclxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXHJcXG5cXHRcXHRcXHRyYWRpdXM6IHJhZGl1cyxcXHJcXG5cXHRcXHRcXHR0dWJlOiB0dWJlLFxcclxcblxcdFxcdFxcdHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxcclxcblxcdFxcdFxcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcXHJcXG5cXHRcXHRcXHRwOiBwLFxcclxcblxcdFxcdFxcdHE6IHFcXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdFxcdHJhZGl1cyA9IHJhZGl1cyB8fCAxO1xcclxcblxcdFxcdHR1YmUgPSB0dWJlIHx8IDAuNDtcXHJcXG5cXHRcXHR0dWJ1bGFyU2VnbWVudHMgPSBNYXRoLmZsb29yKCB0dWJ1bGFyU2VnbWVudHMgKSB8fCA2NDtcXHJcXG5cXHRcXHRyYWRpYWxTZWdtZW50cyA9IE1hdGguZmxvb3IoIHJhZGlhbFNlZ21lbnRzICkgfHwgODtcXHJcXG5cXHRcXHRwID0gcCB8fCAyO1xcclxcblxcdFxcdHEgPSBxIHx8IDM7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gYnVmZmVyc1xcclxcblxcclxcblxcdFxcdHZhciBpbmRpY2VzID0gW107XFxyXFxuXFx0XFx0dmFyIHZlcnRpY2VzID0gW107XFxyXFxuXFx0XFx0dmFyIG5vcm1hbHMgPSBbXTtcXHJcXG5cXHRcXHR2YXIgdXZzID0gW107XFxyXFxuXFxyXFxuXFx0XFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xcclxcblxcclxcblxcdFxcdHZhciBpLCBqO1xcclxcblxcclxcblxcdFxcdHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdHZhciBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdFxcdHZhciBQMSA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0dmFyIFAyID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgQiA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0dmFyIFQgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdHZhciBOID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXFxyXFxuXFxyXFxuXFx0XFx0Zm9yICggaSA9IDA7IGkgPD0gdHVidWxhclNlZ21lbnRzOyArKyBpICkge1xcclxcblxcclxcblxcdFxcdFxcdC8vIHRoZSByYWRpYW4gXFxcInVcXFwiIGlzIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBvbiB0aGUgdG9ydXMgY3VydmUgb2YgdGhlIGN1cnJlbnQgdHVidWxhciBzZWdlbWVudFxcclxcblxcclxcblxcdFxcdFxcdHZhciB1ID0gaSAvIHR1YnVsYXJTZWdtZW50cyAqIHAgKiBNYXRoLlBJICogMjtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBub3cgd2UgY2FsY3VsYXRlIHR3byBwb2ludHMuIFAxIGlzIG91ciBjdXJyZW50IHBvc2l0aW9uIG9uIHRoZSBjdXJ2ZSwgUDIgaXMgYSBsaXR0bGUgZmFydGhlciBhaGVhZC5cXHJcXG5cXHRcXHRcXHQvLyB0aGVzZSBwb2ludHMgYXJlIHVzZWQgdG8gY3JlYXRlIGEgc3BlY2lhbCBcXFwiY29vcmRpbmF0ZSBzcGFjZVxcXCIsIHdoaWNoIGlzIG5lY2Vzc2FyeSB0byBjYWxjdWxhdGUgdGhlIGNvcnJlY3QgdmVydGV4IHBvc2l0aW9uc1xcclxcblxcclxcblxcdFxcdFxcdGNhbGN1bGF0ZVBvc2l0aW9uT25DdXJ2ZSggdSwgcCwgcSwgcmFkaXVzLCBQMSApO1xcclxcblxcdFxcdFxcdGNhbGN1bGF0ZVBvc2l0aW9uT25DdXJ2ZSggdSArIDAuMDEsIHAsIHEsIHJhZGl1cywgUDIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBjYWxjdWxhdGUgb3J0aG9ub3JtYWwgYmFzaXNcXHJcXG5cXHJcXG5cXHRcXHRcXHRULnN1YlZlY3RvcnMoIFAyLCBQMSApO1xcclxcblxcdFxcdFxcdE4uYWRkVmVjdG9ycyggUDIsIFAxICk7XFxyXFxuXFx0XFx0XFx0Qi5jcm9zc1ZlY3RvcnMoIFQsIE4gKTtcXHJcXG5cXHRcXHRcXHROLmNyb3NzVmVjdG9ycyggQiwgVCApO1xcclxcblxcclxcblxcdFxcdFxcdC8vIG5vcm1hbGl6ZSBCLCBOLiBUIGNhbiBiZSBpZ25vcmVkLCB3ZSBkb24ndCB1c2UgaXRcXHJcXG5cXHJcXG5cXHRcXHRcXHRCLm5vcm1hbGl6ZSgpO1xcclxcblxcdFxcdFxcdE4ubm9ybWFsaXplKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7ICsrIGogKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gbm93IGNhbGN1bGF0ZSB0aGUgdmVydGljZXMuIHRoZXkgYXJlIG5vdGhpbmcgbW9yZSB0aGFuIGFuIGV4dHJ1c2lvbiBvZiB0aGUgdG9ydXMgY3VydmUuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gYmVjYXVzZSB3ZSBleHRydWRlIGEgc2hhcGUgaW4gdGhlIHh5LXBsYW5lLCB0aGVyZSBpcyBubyBuZWVkIHRvIGNhbGN1bGF0ZSBhIHotdmFsdWUuXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHYgPSBqIC8gcmFkaWFsU2VnbWVudHMgKiBNYXRoLlBJICogMjtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgY3ggPSAtIHR1YmUgKiBNYXRoLmNvcyggdiApO1xcclxcblxcdFxcdFxcdFxcdHZhciBjeSA9IHR1YmUgKiBNYXRoLnNpbiggdiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIG5vdyBjYWxjdWxhdGUgdGhlIGZpbmFsIHZlcnRleCBwb3NpdGlvbi5cXHJcXG5cXHRcXHRcXHRcXHQvLyBmaXJzdCB3ZSBvcmllbnQgdGhlIGV4dHJ1c2lvbiB3aXRoIG91ciBiYXNpcyB2ZWN0b3MsIHRoZW4gd2UgYWRkIGl0IHRvIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9uIHRoZSBjdXJ2ZVxcclxcblxcclxcblxcdFxcdFxcdFxcdHZlcnRleC54ID0gUDEueCArICggY3ggKiBOLnggKyBjeSAqIEIueCApO1xcclxcblxcdFxcdFxcdFxcdHZlcnRleC55ID0gUDEueSArICggY3ggKiBOLnkgKyBjeSAqIEIueSApO1xcclxcblxcdFxcdFxcdFxcdHZlcnRleC56ID0gUDEueiArICggY3ggKiBOLnogKyBjeSAqIEIueiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBub3JtYWwgKFAxIGlzIGFsd2F5cyB0aGUgY2VudGVyL29yaWdpbiBvZiB0aGUgZXh0cnVzaW9uLCB0aHVzIHdlIGNhbiB1c2UgaXQgdG8gY2FsY3VsYXRlIHRoZSBub3JtYWwpXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bm9ybWFsLnN1YlZlY3RvcnMoIHZlcnRleCwgUDEgKS5ub3JtYWxpemUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyB1dlxcclxcblxcclxcblxcdFxcdFxcdFxcdHV2cy5wdXNoKCBpIC8gdHVidWxhclNlZ21lbnRzICk7XFxyXFxuXFx0XFx0XFx0XFx0dXZzLnB1c2goIGogLyByYWRpYWxTZWdtZW50cyApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0Ly8gZ2VuZXJhdGUgaW5kaWNlc1xcclxcblxcclxcblxcdFxcdGZvciAoIGogPSAxOyBqIDw9IHR1YnVsYXJTZWdtZW50czsgaiArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCBpID0gMTsgaSA8PSByYWRpYWxTZWdtZW50czsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBpbmRpY2VzXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGEgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgKCBpIC0gMSApO1xcclxcblxcdFxcdFxcdFxcdHZhciBiID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqIGogKyAoIGkgLSAxICk7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGMgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogaiArIGk7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGQgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBmYWNlc1xcclxcblxcclxcblxcdFxcdFxcdFxcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xcclxcblxcdFxcdFxcdFxcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0Ly8gYnVpbGQgZ2VvbWV0cnlcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XFxyXFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XFxyXFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XFxyXFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xcclxcblxcclxcblxcdFxcdC8vIHRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgdG9ydXMgY3VydmVcXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBjYWxjdWxhdGVQb3NpdGlvbk9uQ3VydmUoIHUsIHAsIHEsIHJhZGl1cywgcG9zaXRpb24gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGN1ID0gTWF0aC5jb3MoIHUgKTtcXHJcXG5cXHRcXHRcXHR2YXIgc3UgPSBNYXRoLnNpbiggdSApO1xcclxcblxcdFxcdFxcdHZhciBxdU92ZXJQID0gcSAvIHAgKiB1O1xcclxcblxcdFxcdFxcdHZhciBjcyA9IE1hdGguY29zKCBxdU92ZXJQICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cG9zaXRpb24ueCA9IHJhZGl1cyAqICggMiArIGNzICkgKiAwLjUgKiBjdTtcXHJcXG5cXHRcXHRcXHRwb3NpdGlvbi55ID0gcmFkaXVzICogKCAyICsgY3MgKSAqIHN1ICogMC41O1xcclxcblxcdFxcdFxcdHBvc2l0aW9uLnogPSByYWRpdXMgKiBNYXRoLnNpbiggcXVPdmVyUCApICogMC41O1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0VG9ydXNLbm90QnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XFxyXFxuXFx0VG9ydXNLbm90QnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVG9ydXNLbm90QnVmZmVyR2VvbWV0cnk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBvb3Ntb3hpZWNvZGVcXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0Ly8gVG9ydXNHZW9tZXRyeVxcclxcblxcclxcblxcdGZ1bmN0aW9uIFRvcnVzR2VvbWV0cnkoIHJhZGl1cywgdHViZSwgcmFkaWFsU2VnbWVudHMsIHR1YnVsYXJTZWdtZW50cywgYXJjICkge1xcclxcblxcclxcblxcdFxcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnVG9ydXNHZW9tZXRyeSc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcclxcblxcdFxcdFxcdHJhZGl1czogcmFkaXVzLFxcclxcblxcdFxcdFxcdHR1YmU6IHR1YmUsXFxyXFxuXFx0XFx0XFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxcclxcblxcdFxcdFxcdHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxcclxcblxcdFxcdFxcdGFyYzogYXJjXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IFRvcnVzQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgdHViZSwgcmFkaWFsU2VnbWVudHMsIHR1YnVsYXJTZWdtZW50cywgYXJjICkgKTtcXHJcXG5cXHRcXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0VG9ydXNHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcXHJcXG5cXHRUb3J1c0dlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRvcnVzR2VvbWV0cnk7XFxyXFxuXFxyXFxuXFx0Ly8gVG9ydXNCdWZmZXJHZW9tZXRyeVxcclxcblxcclxcblxcdGZ1bmN0aW9uIFRvcnVzQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgdHViZSwgcmFkaWFsU2VnbWVudHMsIHR1YnVsYXJTZWdtZW50cywgYXJjICkge1xcclxcblxcclxcblxcdFxcdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnVG9ydXNCdWZmZXJHZW9tZXRyeSc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcclxcblxcdFxcdFxcdHJhZGl1czogcmFkaXVzLFxcclxcblxcdFxcdFxcdHR1YmU6IHR1YmUsXFxyXFxuXFx0XFx0XFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxcclxcblxcdFxcdFxcdHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxcclxcblxcdFxcdFxcdGFyYzogYXJjXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHRyYWRpdXMgPSByYWRpdXMgfHwgMTtcXHJcXG5cXHRcXHR0dWJlID0gdHViZSB8fCAwLjQ7XFxyXFxuXFx0XFx0cmFkaWFsU2VnbWVudHMgPSBNYXRoLmZsb29yKCByYWRpYWxTZWdtZW50cyApIHx8IDg7XFxyXFxuXFx0XFx0dHVidWxhclNlZ21lbnRzID0gTWF0aC5mbG9vciggdHVidWxhclNlZ21lbnRzICkgfHwgNjtcXHJcXG5cXHRcXHRhcmMgPSBhcmMgfHwgTWF0aC5QSSAqIDI7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gYnVmZmVyc1xcclxcblxcclxcblxcdFxcdHZhciBpbmRpY2VzID0gW107XFxyXFxuXFx0XFx0dmFyIHZlcnRpY2VzID0gW107XFxyXFxuXFx0XFx0dmFyIG5vcm1hbHMgPSBbXTtcXHJcXG5cXHRcXHR2YXIgdXZzID0gW107XFxyXFxuXFxyXFxuXFx0XFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xcclxcblxcclxcblxcdFxcdHZhciBjZW50ZXIgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdHZhciBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdFxcdHZhciBqLCBpO1xcclxcblxcclxcblxcdFxcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcXHJcXG5cXHJcXG5cXHRcXHRmb3IgKCBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgaiArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCBpID0gMDsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHUgPSBpIC8gdHVidWxhclNlZ21lbnRzICogYXJjO1xcclxcblxcdFxcdFxcdFxcdHZhciB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gdmVydGV4XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmVydGV4LnggPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLmNvcyggdSApO1xcclxcblxcdFxcdFxcdFxcdHZlcnRleC55ID0gKCByYWRpdXMgKyB0dWJlICogTWF0aC5jb3MoIHYgKSApICogTWF0aC5zaW4oIHUgKTtcXHJcXG5cXHRcXHRcXHRcXHR2ZXJ0ZXgueiA9IHR1YmUgKiBNYXRoLnNpbiggdiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBub3JtYWxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjZW50ZXIueCA9IHJhZGl1cyAqIE1hdGguY29zKCB1ICk7XFxyXFxuXFx0XFx0XFx0XFx0Y2VudGVyLnkgPSByYWRpdXMgKiBNYXRoLnNpbiggdSApO1xcclxcblxcdFxcdFxcdFxcdG5vcm1hbC5zdWJWZWN0b3JzKCB2ZXJ0ZXgsIGNlbnRlciApLm5vcm1hbGl6ZSgpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIHV2XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dXZzLnB1c2goIGkgLyB0dWJ1bGFyU2VnbWVudHMgKTtcXHJcXG5cXHRcXHRcXHRcXHR1dnMucHVzaCggaiAvIHJhZGlhbFNlZ21lbnRzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHQvLyBnZW5lcmF0ZSBpbmRpY2VzXFxyXFxuXFxyXFxuXFx0XFx0Zm9yICggaiA9IDE7IGogPD0gcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggaSA9IDE7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGluZGljZXNcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgYSA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogaiArIGkgLSAxO1xcclxcblxcdFxcdFxcdFxcdHZhciBiID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpIC0gMTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgYyA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgZCA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogaiArIGk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gZmFjZXNcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcXHJcXG5cXHRcXHRcXHRcXHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdC8vIGJ1aWxkIGdlb21ldHJ5XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xcclxcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xcclxcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xcclxcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0VG9ydXNCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcXHJcXG5cXHRUb3J1c0J1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRvcnVzQnVmZmVyR2VvbWV0cnk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcXHJcXG5cXHQgKiBQb3J0IGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9lYXJjdXQgKHYyLjEuMilcXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHR2YXIgRWFyY3V0ID0ge1xcclxcblxcclxcblxcdFxcdHRyaWFuZ3VsYXRlOiBmdW5jdGlvbiAoIGRhdGEsIGhvbGVJbmRpY2VzLCBkaW0gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZGltID0gZGltIHx8IDI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGhhc0hvbGVzID0gaG9sZUluZGljZXMgJiYgaG9sZUluZGljZXMubGVuZ3RoLFxcclxcblxcdFxcdFxcdFxcdG91dGVyTGVuID0gaGFzSG9sZXMgPyBob2xlSW5kaWNlc1sgMCBdICogZGltIDogZGF0YS5sZW5ndGgsXFxyXFxuXFx0XFx0XFx0XFx0b3V0ZXJOb2RlID0gbGlua2VkTGlzdCggZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSwgdHJ1ZSApLFxcclxcblxcdFxcdFxcdFxcdHRyaWFuZ2xlcyA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggISBvdXRlck5vZGUgKSByZXR1cm4gdHJpYW5nbGVzO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCB4LCB5LCBpbnZTaXplO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggaGFzSG9sZXMgKSBvdXRlck5vZGUgPSBlbGltaW5hdGVIb2xlcyggZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gaWYgdGhlIHNoYXBlIGlzIG5vdCB0b28gc2ltcGxlLCB3ZSdsbCB1c2Ugei1vcmRlciBjdXJ2ZSBoYXNoIGxhdGVyOyBjYWxjdWxhdGUgcG9seWdvbiBiYm94XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBkYXRhLmxlbmd0aCA+IDgwICogZGltICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdG1pblggPSBtYXhYID0gZGF0YVsgMCBdO1xcclxcblxcdFxcdFxcdFxcdG1pblkgPSBtYXhZID0gZGF0YVsgMSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gZGltOyBpIDwgb3V0ZXJMZW47IGkgKz0gZGltICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHggPSBkYXRhWyBpIF07XFxyXFxuXFx0XFx0XFx0XFx0XFx0eSA9IGRhdGFbIGkgKyAxIF07XFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB4IDwgbWluWCApIG1pblggPSB4O1xcclxcblxcdFxcdFxcdFxcdFxcdGlmICggeSA8IG1pblkgKSBtaW5ZID0geTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHggPiBtYXhYICkgbWF4WCA9IHg7XFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB5ID4gbWF4WSApIG1heFkgPSB5O1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBtaW5YLCBtaW5ZIGFuZCBpbnZTaXplIGFyZSBsYXRlciB1c2VkIHRvIHRyYW5zZm9ybSBjb29yZHMgaW50byBpbnRlZ2VycyBmb3Igei1vcmRlciBjYWxjdWxhdGlvblxcclxcblxcclxcblxcdFxcdFxcdFxcdGludlNpemUgPSBNYXRoLm1heCggbWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZICk7XFxyXFxuXFx0XFx0XFx0XFx0aW52U2l6ZSA9IGludlNpemUgIT09IDAgPyAxIC8gaW52U2l6ZSA6IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGVhcmN1dExpbmtlZCggb3V0ZXJOb2RlLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0cmlhbmdsZXM7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0Ly8gY3JlYXRlIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0IGZyb20gcG9seWdvbiBwb2ludHMgaW4gdGhlIHNwZWNpZmllZCB3aW5kaW5nIG9yZGVyXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gbGlua2VkTGlzdCggZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBjbG9ja3dpc2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGksIGxhc3Q7XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCBjbG9ja3dpc2UgPT09ICggc2lnbmVkQXJlYSggZGF0YSwgc3RhcnQsIGVuZCwgZGltICkgPiAwICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IGRpbSApIGxhc3QgPSBpbnNlcnROb2RlKCBpLCBkYXRhWyBpIF0sIGRhdGFbIGkgKyAxIF0sIGxhc3QgKTtcXHJcXG5cXHJcXG5cXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIGkgPSBlbmQgLSBkaW07IGkgPj0gc3RhcnQ7IGkgLT0gZGltICkgbGFzdCA9IGluc2VydE5vZGUoIGksIGRhdGFbIGkgXSwgZGF0YVsgaSArIDEgXSwgbGFzdCApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRpZiAoIGxhc3QgJiYgZXF1YWxzKCBsYXN0LCBsYXN0Lm5leHQgKSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZW1vdmVOb2RlKCBsYXN0ICk7XFxyXFxuXFx0XFx0XFx0bGFzdCA9IGxhc3QubmV4dDtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIGxhc3Q7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8vIGVsaW1pbmF0ZSBjb2xpbmVhciBvciBkdXBsaWNhdGUgcG9pbnRzXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gZmlsdGVyUG9pbnRzKCBzdGFydCwgZW5kICkge1xcclxcblxcclxcblxcdFxcdGlmICggISBzdGFydCApIHJldHVybiBzdGFydDtcXHJcXG5cXHRcXHRpZiAoICEgZW5kICkgZW5kID0gc3RhcnQ7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHAgPSBzdGFydCwgYWdhaW47XFxyXFxuXFxyXFxuXFx0XFx0ZG8ge1xcclxcblxcclxcblxcdFxcdFxcdGFnYWluID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCAhIHAuc3RlaW5lciAmJiAoIGVxdWFscyggcCwgcC5uZXh0ICkgfHwgYXJlYSggcC5wcmV2LCBwLCBwLm5leHQgKSA9PT0gMCApICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJlbW92ZU5vZGUoIHAgKTtcXHJcXG5cXHRcXHRcXHRcXHRwID0gZW5kID0gcC5wcmV2O1xcclxcblxcdFxcdFxcdFxcdGlmICggcCA9PT0gcC5uZXh0ICkgYnJlYWs7XFxyXFxuXFx0XFx0XFx0XFx0YWdhaW4gPSB0cnVlO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cCA9IHAubmV4dDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fSB3aGlsZSAoIGFnYWluIHx8IHAgIT09IGVuZCApO1xcclxcblxcclxcblxcdFxcdHJldHVybiBlbmQ7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8vIG1haW4gZWFyIHNsaWNpbmcgbG9vcCB3aGljaCB0cmlhbmd1bGF0ZXMgYSBwb2x5Z29uIChnaXZlbiBhcyBhIGxpbmtlZCBsaXN0KVxcclxcblxcclxcblxcdGZ1bmN0aW9uIGVhcmN1dExpbmtlZCggZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgcGFzcyApIHtcXHJcXG5cXHJcXG5cXHRcXHRpZiAoICEgZWFyICkgcmV0dXJuO1xcclxcblxcclxcblxcdFxcdC8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcXHJcXG5cXHJcXG5cXHRcXHRpZiAoICEgcGFzcyAmJiBpbnZTaXplICkgaW5kZXhDdXJ2ZSggZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplICk7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHN0b3AgPSBlYXIsIHByZXYsIG5leHQ7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gaXRlcmF0ZSB0aHJvdWdoIGVhcnMsIHNsaWNpbmcgdGhlbSBvbmUgYnkgb25lXFxyXFxuXFxyXFxuXFx0XFx0d2hpbGUgKCBlYXIucHJldiAhPT0gZWFyLm5leHQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cHJldiA9IGVhci5wcmV2O1xcclxcblxcdFxcdFxcdG5leHQgPSBlYXIubmV4dDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGludlNpemUgPyBpc0Vhckhhc2hlZCggZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplICkgOiBpc0VhciggZWFyICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gY3V0IG9mZiB0aGUgdHJpYW5nbGVcXHJcXG5cXHRcXHRcXHRcXHR0cmlhbmdsZXMucHVzaCggcHJldi5pIC8gZGltICk7XFxyXFxuXFx0XFx0XFx0XFx0dHJpYW5nbGVzLnB1c2goIGVhci5pIC8gZGltICk7XFxyXFxuXFx0XFx0XFx0XFx0dHJpYW5nbGVzLnB1c2goIG5leHQuaSAvIGRpbSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJlbW92ZU5vZGUoIGVhciApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIHNraXBwaW5nIHRoZSBuZXh0IHZlcnRpY2UgbGVhZHMgdG8gbGVzcyBzbGl2ZXIgdHJpYW5nbGVzXFxyXFxuXFx0XFx0XFx0XFx0ZWFyID0gbmV4dC5uZXh0O1xcclxcblxcdFxcdFxcdFxcdHN0b3AgPSBuZXh0Lm5leHQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29udGludWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGVhciA9IG5leHQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gaWYgd2UgbG9vcGVkIHRocm91Z2ggdGhlIHdob2xlIHJlbWFpbmluZyBwb2x5Z29uIGFuZCBjYW4ndCBmaW5kIGFueSBtb3JlIGVhcnNcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGVhciA9PT0gc3RvcCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyB0cnkgZmlsdGVyaW5nIHBvaW50cyBhbmQgc2xpY2luZyBhZ2FpblxcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggISBwYXNzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGVhcmN1dExpbmtlZCggZmlsdGVyUG9pbnRzKCBlYXIgKSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBpZiB0aGlzIGRpZG4ndCB3b3JrLCB0cnkgY3VyaW5nIGFsbCBzbWFsbCBzZWxmLWludGVyc2VjdGlvbnMgbG9jYWxseVxcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIHBhc3MgPT09IDEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0ZWFyID0gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyggZWFyLCB0cmlhbmdsZXMsIGRpbSApO1xcclxcblxcdFxcdFxcdFxcdFxcdGVhcmN1dExpbmtlZCggZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGFzIGEgbGFzdCByZXNvcnQsIHRyeSBzcGxpdHRpbmcgdGhlIHJlbWFpbmluZyBwb2x5Z29uIGludG8gdHdvXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggcGFzcyA9PT0gMiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRzcGxpdEVhcmN1dCggZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHQvLyBjaGVjayB3aGV0aGVyIGEgcG9seWdvbiBub2RlIGZvcm1zIGEgdmFsaWQgZWFyIHdpdGggYWRqYWNlbnQgbm9kZXNcXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBpc0VhciggZWFyICkge1xcclxcblxcclxcblxcdFxcdHZhciBhID0gZWFyLnByZXYsXFxyXFxuXFx0XFx0XFx0YiA9IGVhcixcXHJcXG5cXHRcXHRcXHRjID0gZWFyLm5leHQ7XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCBhcmVhKCBhLCBiLCBjICkgPj0gMCApIHJldHVybiBmYWxzZTsgLy8gcmVmbGV4LCBjYW4ndCBiZSBhbiBlYXJcXHJcXG5cXHJcXG5cXHRcXHQvLyBub3cgbWFrZSBzdXJlIHdlIGRvbid0IGhhdmUgb3RoZXIgcG9pbnRzIGluc2lkZSB0aGUgcG90ZW50aWFsIGVhclxcclxcblxcdFxcdHZhciBwID0gZWFyLm5leHQubmV4dDtcXHJcXG5cXHJcXG5cXHRcXHR3aGlsZSAoIHAgIT09IGVhci5wcmV2ICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggcG9pbnRJblRyaWFuZ2xlKCBhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSApICYmIGFyZWEoIHAucHJldiwgcCwgcC5uZXh0ICkgPj0gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHAgPSBwLm5leHQ7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHJldHVybiB0cnVlO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBpc0Vhckhhc2hlZCggZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplICkge1xcclxcblxcclxcblxcdFxcdHZhciBhID0gZWFyLnByZXYsXFxyXFxuXFx0XFx0XFx0YiA9IGVhcixcXHJcXG5cXHRcXHRcXHRjID0gZWFyLm5leHQ7XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCBhcmVhKCBhLCBiLCBjICkgPj0gMCApIHJldHVybiBmYWxzZTsgLy8gcmVmbGV4LCBjYW4ndCBiZSBhbiBlYXJcXHJcXG5cXHJcXG5cXHRcXHQvLyB0cmlhbmdsZSBiYm94OyBtaW4gJiBtYXggYXJlIGNhbGN1bGF0ZWQgbGlrZSB0aGlzIGZvciBzcGVlZFxcclxcblxcclxcblxcdFxcdHZhciBtaW5UWCA9IGEueCA8IGIueCA/ICggYS54IDwgYy54ID8gYS54IDogYy54ICkgOiAoIGIueCA8IGMueCA/IGIueCA6IGMueCApLFxcclxcblxcdFxcdFxcdG1pblRZID0gYS55IDwgYi55ID8gKCBhLnkgPCBjLnkgPyBhLnkgOiBjLnkgKSA6ICggYi55IDwgYy55ID8gYi55IDogYy55ICksXFxyXFxuXFx0XFx0XFx0bWF4VFggPSBhLnggPiBiLnggPyAoIGEueCA+IGMueCA/IGEueCA6IGMueCApIDogKCBiLnggPiBjLnggPyBiLnggOiBjLnggKSxcXHJcXG5cXHRcXHRcXHRtYXhUWSA9IGEueSA+IGIueSA/ICggYS55ID4gYy55ID8gYS55IDogYy55ICkgOiAoIGIueSA+IGMueSA/IGIueSA6IGMueSApO1xcclxcblxcclxcblxcdFxcdC8vIHotb3JkZXIgcmFuZ2UgZm9yIHRoZSBjdXJyZW50IHRyaWFuZ2xlIGJib3g7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIG1pblogPSB6T3JkZXIoIG1pblRYLCBtaW5UWSwgbWluWCwgbWluWSwgaW52U2l6ZSApLFxcclxcblxcdFxcdFxcdG1heFogPSB6T3JkZXIoIG1heFRYLCBtYXhUWSwgbWluWCwgbWluWSwgaW52U2l6ZSApO1xcclxcblxcclxcblxcdFxcdC8vIGZpcnN0IGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIGluIGluY3JlYXNpbmcgei1vcmRlclxcclxcblxcclxcblxcdFxcdHZhciBwID0gZWFyLm5leHRaO1xcclxcblxcclxcblxcdFxcdHdoaWxlICggcCAmJiBwLnogPD0gbWF4WiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHAgIT09IGVhci5wcmV2ICYmIHAgIT09IGVhci5uZXh0ICYmXFxyXFxuXFx0XFx0XFx0XFx0XFx0cG9pbnRJblRyaWFuZ2xlKCBhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSApICYmXFxyXFxuXFx0XFx0XFx0XFx0XFx0YXJlYSggcC5wcmV2LCBwLCBwLm5leHQgKSA+PSAwICkgcmV0dXJuIGZhbHNlO1xcclxcblxcdFxcdFxcdHAgPSBwLm5leHRaO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHQvLyB0aGVuIGxvb2sgZm9yIHBvaW50cyBpbiBkZWNyZWFzaW5nIHotb3JkZXJcXHJcXG5cXHJcXG5cXHRcXHRwID0gZWFyLnByZXZaO1xcclxcblxcclxcblxcdFxcdHdoaWxlICggcCAmJiBwLnogPj0gbWluWiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHAgIT09IGVhci5wcmV2ICYmIHAgIT09IGVhci5uZXh0ICYmXFxyXFxuXFx0XFx0XFx0XFx0XFx0cG9pbnRJblRyaWFuZ2xlKCBhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSApICYmXFxyXFxuXFx0XFx0XFx0XFx0XFx0YXJlYSggcC5wcmV2LCBwLCBwLm5leHQgKSA+PSAwICkgcmV0dXJuIGZhbHNlO1xcclxcblxcclxcblxcdFxcdFxcdHAgPSBwLnByZXZaO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gdHJ1ZTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0Ly8gZ28gdGhyb3VnaCBhbGwgcG9seWdvbiBub2RlcyBhbmQgY3VyZSBzbWFsbCBsb2NhbCBzZWxmLWludGVyc2VjdGlvbnNcXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKCBzdGFydCwgdHJpYW5nbGVzLCBkaW0gKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHAgPSBzdGFydDtcXHJcXG5cXHJcXG5cXHRcXHRkbyB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGEgPSBwLnByZXYsIGIgPSBwLm5leHQubmV4dDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoICEgZXF1YWxzKCBhLCBiICkgJiYgaW50ZXJzZWN0cyggYSwgcCwgcC5uZXh0LCBiICkgJiYgbG9jYWxseUluc2lkZSggYSwgYiApICYmIGxvY2FsbHlJbnNpZGUoIGIsIGEgKSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0cmlhbmdsZXMucHVzaCggYS5pIC8gZGltICk7XFxyXFxuXFx0XFx0XFx0XFx0dHJpYW5nbGVzLnB1c2goIHAuaSAvIGRpbSApO1xcclxcblxcdFxcdFxcdFxcdHRyaWFuZ2xlcy5wdXNoKCBiLmkgLyBkaW0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyByZW1vdmUgdHdvIG5vZGVzIGludm9sdmVkXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmVtb3ZlTm9kZSggcCApO1xcclxcblxcdFxcdFxcdFxcdHJlbW92ZU5vZGUoIHAubmV4dCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHAgPSBzdGFydCA9IGI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHAgPSBwLm5leHQ7XFxyXFxuXFxyXFxuXFx0XFx0fSB3aGlsZSAoIHAgIT09IHN0YXJ0ICk7XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHA7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8vIHRyeSBzcGxpdHRpbmcgcG9seWdvbiBpbnRvIHR3byBhbmQgdHJpYW5ndWxhdGUgdGhlbSBpbmRlcGVuZGVudGx5XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gc3BsaXRFYXJjdXQoIHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHQvLyBsb29rIGZvciBhIHZhbGlkIGRpYWdvbmFsIHRoYXQgZGl2aWRlcyB0aGUgcG9seWdvbiBpbnRvIHR3b1xcclxcblxcclxcblxcdFxcdHZhciBhID0gc3RhcnQ7XFxyXFxuXFxyXFxuXFx0XFx0ZG8ge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBiID0gYS5uZXh0Lm5leHQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0d2hpbGUgKCBiICE9PSBhLnByZXYgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBhLmkgIT09IGIuaSAmJiBpc1ZhbGlkRGlhZ29uYWwoIGEsIGIgKSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBzcGxpdCB0aGUgcG9seWdvbiBpbiB0d28gYnkgdGhlIGRpYWdvbmFsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGMgPSBzcGxpdFBvbHlnb24oIGEsIGIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBmaWx0ZXIgY29saW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGEgPSBmaWx0ZXJQb2ludHMoIGEsIGEubmV4dCApO1xcclxcblxcdFxcdFxcdFxcdFxcdGMgPSBmaWx0ZXJQb2ludHMoIGMsIGMubmV4dCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIHJ1biBlYXJjdXQgb24gZWFjaCBoYWxmXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0ZWFyY3V0TGlua2VkKCBhLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSApO1xcclxcblxcdFxcdFxcdFxcdFxcdGVhcmN1dExpbmtlZCggYywgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdGIgPSBiLm5leHQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGEgPSBhLm5leHQ7XFxyXFxuXFxyXFxuXFx0XFx0fSB3aGlsZSAoIGEgIT09IHN0YXJ0ICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8vIGxpbmsgZXZlcnkgaG9sZSBpbnRvIHRoZSBvdXRlciBsb29wLCBwcm9kdWNpbmcgYSBzaW5nbGUtcmluZyBwb2x5Z29uIHdpdGhvdXQgaG9sZXNcXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBlbGltaW5hdGVIb2xlcyggZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltICkge1xcclxcblxcclxcblxcdFxcdHZhciBxdWV1ZSA9IFtdLCBpLCBsZW4sIHN0YXJ0LCBlbmQsIGxpc3Q7XFxyXFxuXFxyXFxuXFx0XFx0Zm9yICggaSA9IDAsIGxlbiA9IGhvbGVJbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRzdGFydCA9IGhvbGVJbmRpY2VzWyBpIF0gKiBkaW07XFxyXFxuXFx0XFx0XFx0ZW5kID0gaSA8IGxlbiAtIDEgPyBob2xlSW5kaWNlc1sgaSArIDEgXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xcclxcblxcdFxcdFxcdGxpc3QgPSBsaW5rZWRMaXN0KCBkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGZhbHNlICk7XFxyXFxuXFx0XFx0XFx0aWYgKCBsaXN0ID09PSBsaXN0Lm5leHQgKSBsaXN0LnN0ZWluZXIgPSB0cnVlO1xcclxcblxcdFxcdFxcdHF1ZXVlLnB1c2goIGdldExlZnRtb3N0KCBsaXN0ICkgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0cXVldWUuc29ydCggY29tcGFyZVggKTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBwcm9jZXNzIGhvbGVzIGZyb20gbGVmdCB0byByaWdodFxcclxcblxcclxcblxcdFxcdGZvciAoIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdGVsaW1pbmF0ZUhvbGUoIHF1ZXVlWyBpIF0sIG91dGVyTm9kZSApO1xcclxcblxcdFxcdFxcdG91dGVyTm9kZSA9IGZpbHRlclBvaW50cyggb3V0ZXJOb2RlLCBvdXRlck5vZGUubmV4dCApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gb3V0ZXJOb2RlO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBjb21wYXJlWCggYSwgYiApIHtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gYS54IC0gYi54O1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHQvLyBmaW5kIGEgYnJpZGdlIGJldHdlZW4gdmVydGljZXMgdGhhdCBjb25uZWN0cyBob2xlIHdpdGggYW4gb3V0ZXIgcmluZyBhbmQgYW5kIGxpbmsgaXRcXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBlbGltaW5hdGVIb2xlKCBob2xlLCBvdXRlck5vZGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0b3V0ZXJOb2RlID0gZmluZEhvbGVCcmlkZ2UoIGhvbGUsIG91dGVyTm9kZSApO1xcclxcblxcclxcblxcdFxcdGlmICggb3V0ZXJOb2RlICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBiID0gc3BsaXRQb2x5Z29uKCBvdXRlck5vZGUsIGhvbGUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmaWx0ZXJQb2ludHMoIGIsIGIubmV4dCApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0Ly8gRGF2aWQgRWJlcmx5J3MgYWxnb3JpdGhtIGZvciBmaW5kaW5nIGEgYnJpZGdlIGJldHdlZW4gaG9sZSBhbmQgb3V0ZXIgcG9seWdvblxcclxcblxcclxcblxcdGZ1bmN0aW9uIGZpbmRIb2xlQnJpZGdlKCBob2xlLCBvdXRlck5vZGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHAgPSBvdXRlck5vZGUsXFxyXFxuXFx0XFx0XFx0aHggPSBob2xlLngsXFxyXFxuXFx0XFx0XFx0aHkgPSBob2xlLnksXFxyXFxuXFx0XFx0XFx0cXggPSAtIEluZmluaXR5LFxcclxcblxcdFxcdFxcdG07XFxyXFxuXFxyXFxuXFx0XFx0Ly8gZmluZCBhIHNlZ21lbnQgaW50ZXJzZWN0ZWQgYnkgYSByYXkgZnJvbSB0aGUgaG9sZSdzIGxlZnRtb3N0IHBvaW50IHRvIHRoZSBsZWZ0O1xcclxcblxcdFxcdC8vIHNlZ21lbnQncyBlbmRwb2ludCB3aXRoIGxlc3NlciB4IHdpbGwgYmUgcG90ZW50aWFsIGNvbm5lY3Rpb24gcG9pbnRcXHJcXG5cXHJcXG5cXHRcXHRkbyB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBoeSA8PSBwLnkgJiYgaHkgPj0gcC5uZXh0LnkgJiYgcC5uZXh0LnkgIT09IHAueSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgeCA9IHAueCArICggaHkgLSBwLnkgKSAqICggcC5uZXh0LnggLSBwLnggKSAvICggcC5uZXh0LnkgLSBwLnkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHggPD0gaHggJiYgeCA+IHF4ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHF4ID0geDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHggPT09IGh4ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggaHkgPT09IHAueSApIHJldHVybiBwO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggaHkgPT09IHAubmV4dC55ICkgcmV0dXJuIHAubmV4dDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0bSA9IHAueCA8IHAubmV4dC54ID8gcCA6IHAubmV4dDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHAgPSBwLm5leHQ7XFxyXFxuXFxyXFxuXFx0XFx0fSB3aGlsZSAoIHAgIT09IG91dGVyTm9kZSApO1xcclxcblxcclxcblxcdFxcdGlmICggISBtICkgcmV0dXJuIG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCBoeCA9PT0gcXggKSByZXR1cm4gbS5wcmV2OyAvLyBob2xlIHRvdWNoZXMgb3V0ZXIgc2VnbWVudDsgcGljayBsb3dlciBlbmRwb2ludFxcclxcblxcclxcblxcdFxcdC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIG9mIGhvbGUgcG9pbnQsIHNlZ21lbnQgaW50ZXJzZWN0aW9uIGFuZCBlbmRwb2ludDtcXHJcXG5cXHRcXHQvLyBpZiB0aGVyZSBhcmUgbm8gcG9pbnRzIGZvdW5kLCB3ZSBoYXZlIGEgdmFsaWQgY29ubmVjdGlvbjtcXHJcXG5cXHRcXHQvLyBvdGhlcndpc2UgY2hvb3NlIHRoZSBwb2ludCBvZiB0aGUgbWluaW11bSBhbmdsZSB3aXRoIHRoZSByYXkgYXMgY29ubmVjdGlvbiBwb2ludFxcclxcblxcclxcblxcdFxcdHZhciBzdG9wID0gbSxcXHJcXG5cXHRcXHRcXHRteCA9IG0ueCxcXHJcXG5cXHRcXHRcXHRteSA9IG0ueSxcXHJcXG5cXHRcXHRcXHR0YW5NaW4gPSBJbmZpbml0eSxcXHJcXG5cXHRcXHRcXHR0YW47XFxyXFxuXFxyXFxuXFx0XFx0cCA9IG0ubmV4dDtcXHJcXG5cXHJcXG5cXHRcXHR3aGlsZSAoIHAgIT09IHN0b3AgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBoeCA+PSBwLnggJiYgcC54ID49IG14ICYmIGh4ICE9PSBwLnggJiZcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRwb2ludEluVHJpYW5nbGUoIGh5IDwgbXkgPyBoeCA6IHF4LCBoeSwgbXgsIG15LCBoeSA8IG15ID8gcXggOiBoeCwgaHksIHAueCwgcC55ICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGFuID0gTWF0aC5hYnMoIGh5IC0gcC55ICkgLyAoIGh4IC0gcC54ICk7IC8vIHRhbmdlbnRpYWxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoICggdGFuIDwgdGFuTWluIHx8ICggdGFuID09PSB0YW5NaW4gJiYgcC54ID4gbS54ICkgKSAmJiBsb2NhbGx5SW5zaWRlKCBwLCBob2xlICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0bSA9IHA7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dGFuTWluID0gdGFuO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cCA9IHAubmV4dDtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIG07XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBpbmRleEN1cnZlKCBzdGFydCwgbWluWCwgbWluWSwgaW52U2l6ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgcCA9IHN0YXJ0O1xcclxcblxcclxcblxcdFxcdGRvIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHAueiA9PT0gbnVsbCApIHAueiA9IHpPcmRlciggcC54LCBwLnksIG1pblgsIG1pblksIGludlNpemUgKTtcXHJcXG5cXHRcXHRcXHRwLnByZXZaID0gcC5wcmV2O1xcclxcblxcdFxcdFxcdHAubmV4dFogPSBwLm5leHQ7XFxyXFxuXFx0XFx0XFx0cCA9IHAubmV4dDtcXHJcXG5cXHJcXG5cXHRcXHR9IHdoaWxlICggcCAhPT0gc3RhcnQgKTtcXHJcXG5cXHJcXG5cXHRcXHRwLnByZXZaLm5leHRaID0gbnVsbDtcXHJcXG5cXHRcXHRwLnByZXZaID0gbnVsbDtcXHJcXG5cXHJcXG5cXHRcXHRzb3J0TGlua2VkKCBwICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8vIFNpbW9uIFRhdGhhbSdzIGxpbmtlZCBsaXN0IG1lcmdlIHNvcnQgYWxnb3JpdGhtXFxyXFxuXFx0Ly8gaHR0cDovL3d3dy5jaGlhcmsuZ3JlZW5lbmQub3JnLnVrL35zZ3RhdGhhbS9hbGdvcml0aG1zL2xpc3Rzb3J0Lmh0bWxcXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBzb3J0TGlua2VkKCBsaXN0ICkge1xcclxcblxcclxcblxcdFxcdHZhciBpLCBwLCBxLCBlLCB0YWlsLCBudW1NZXJnZXMsIHBTaXplLCBxU2l6ZSwgaW5TaXplID0gMTtcXHJcXG5cXHJcXG5cXHRcXHRkbyB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cCA9IGxpc3Q7XFxyXFxuXFx0XFx0XFx0bGlzdCA9IG51bGw7XFxyXFxuXFx0XFx0XFx0dGFpbCA9IG51bGw7XFxyXFxuXFx0XFx0XFx0bnVtTWVyZ2VzID0gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR3aGlsZSAoIHAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bnVtTWVyZ2VzICsrO1xcclxcblxcdFxcdFxcdFxcdHEgPSBwO1xcclxcblxcdFxcdFxcdFxcdHBTaXplID0gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCBpID0gMDsgaSA8IGluU2l6ZTsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRwU2l6ZSArKztcXHJcXG5cXHRcXHRcXHRcXHRcXHRxID0gcS5uZXh0WjtcXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoICEgcSApIGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRxU2l6ZSA9IGluU2l6ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR3aGlsZSAoIHBTaXplID4gMCB8fCAoIHFTaXplID4gMCAmJiBxICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBwU2l6ZSAhPT0gMCAmJiAoIHFTaXplID09PSAwIHx8ICEgcSB8fCBwLnogPD0gcS56ICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZSA9IHA7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0cCA9IHAubmV4dFo7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0cFNpemUgLS07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRlID0gcTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRxID0gcS5uZXh0WjtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRxU2l6ZSAtLTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0YWlsICkgdGFpbC5uZXh0WiA9IGU7XFxyXFxuXFx0XFx0XFx0XFx0XFx0ZWxzZSBsaXN0ID0gZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRlLnByZXZaID0gdGFpbDtcXHJcXG5cXHRcXHRcXHRcXHRcXHR0YWlsID0gZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cCA9IHE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHRhaWwubmV4dFogPSBudWxsO1xcclxcblxcdFxcdFxcdGluU2l6ZSAqPSAyO1xcclxcblxcclxcblxcdFxcdH0gd2hpbGUgKCBudW1NZXJnZXMgPiAxICk7XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIGxpc3Q7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8vIHotb3JkZXIgb2YgYSBwb2ludCBnaXZlbiBjb29yZHMgYW5kIGludmVyc2Ugb2YgdGhlIGxvbmdlciBzaWRlIG9mIGRhdGEgYmJveFxcclxcblxcclxcblxcdGZ1bmN0aW9uIHpPcmRlciggeCwgeSwgbWluWCwgbWluWSwgaW52U2l6ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHQvLyBjb29yZHMgYXJlIHRyYW5zZm9ybWVkIGludG8gbm9uLW5lZ2F0aXZlIDE1LWJpdCBpbnRlZ2VyIHJhbmdlXFxyXFxuXFxyXFxuXFx0XFx0eCA9IDMyNzY3ICogKCB4IC0gbWluWCApICogaW52U2l6ZTtcXHJcXG5cXHRcXHR5ID0gMzI3NjcgKiAoIHkgLSBtaW5ZICkgKiBpbnZTaXplO1xcclxcblxcclxcblxcdFxcdHggPSAoIHggfCAoIHggPDwgOCApICkgJiAweDAwRkYwMEZGO1xcclxcblxcdFxcdHggPSAoIHggfCAoIHggPDwgNCApICkgJiAweDBGMEYwRjBGO1xcclxcblxcdFxcdHggPSAoIHggfCAoIHggPDwgMiApICkgJiAweDMzMzMzMzMzO1xcclxcblxcdFxcdHggPSAoIHggfCAoIHggPDwgMSApICkgJiAweDU1NTU1NTU1O1xcclxcblxcclxcblxcdFxcdHkgPSAoIHkgfCAoIHkgPDwgOCApICkgJiAweDAwRkYwMEZGO1xcclxcblxcdFxcdHkgPSAoIHkgfCAoIHkgPDwgNCApICkgJiAweDBGMEYwRjBGO1xcclxcblxcdFxcdHkgPSAoIHkgfCAoIHkgPDwgMiApICkgJiAweDMzMzMzMzMzO1xcclxcblxcdFxcdHkgPSAoIHkgfCAoIHkgPDwgMSApICkgJiAweDU1NTU1NTU1O1xcclxcblxcclxcblxcdFxcdHJldHVybiB4IHwgKCB5IDw8IDEgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0Ly8gZmluZCB0aGUgbGVmdG1vc3Qgbm9kZSBvZiBhIHBvbHlnb24gcmluZ1xcclxcblxcclxcblxcdGZ1bmN0aW9uIGdldExlZnRtb3N0KCBzdGFydCApIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgcCA9IHN0YXJ0LCBsZWZ0bW9zdCA9IHN0YXJ0O1xcclxcblxcclxcblxcdFxcdGRvIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHAueCA8IGxlZnRtb3N0LnggKSBsZWZ0bW9zdCA9IHA7XFxyXFxuXFx0XFx0XFx0cCA9IHAubmV4dDtcXHJcXG5cXHJcXG5cXHRcXHR9IHdoaWxlICggcCAhPT0gc3RhcnQgKTtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gbGVmdG1vc3Q7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8vIGNoZWNrIGlmIGEgcG9pbnQgbGllcyB3aXRoaW4gYSBjb252ZXggdHJpYW5nbGVcXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBwb2ludEluVHJpYW5nbGUoIGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHB4LCBweSApIHtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gKCBjeCAtIHB4ICkgKiAoIGF5IC0gcHkgKSAtICggYXggLSBweCApICogKCBjeSAtIHB5ICkgPj0gMCAmJlxcclxcblxcdFxcdCAoIGF4IC0gcHggKSAqICggYnkgLSBweSApIC0gKCBieCAtIHB4ICkgKiAoIGF5IC0gcHkgKSA+PSAwICYmXFxyXFxuXFx0XFx0ICggYnggLSBweCApICogKCBjeSAtIHB5ICkgLSAoIGN4IC0gcHggKSAqICggYnkgLSBweSApID49IDA7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8vIGNoZWNrIGlmIGEgZGlhZ29uYWwgYmV0d2VlbiB0d28gcG9seWdvbiBub2RlcyBpcyB2YWxpZCAobGllcyBpbiBwb2x5Z29uIGludGVyaW9yKVxcclxcblxcclxcblxcdGZ1bmN0aW9uIGlzVmFsaWREaWFnb25hbCggYSwgYiApIHtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gYS5uZXh0LmkgIT09IGIuaSAmJiBhLnByZXYuaSAhPT0gYi5pICYmICEgaW50ZXJzZWN0c1BvbHlnb24oIGEsIGIgKSAmJlxcclxcblxcdFxcdFxcdGxvY2FsbHlJbnNpZGUoIGEsIGIgKSAmJiBsb2NhbGx5SW5zaWRlKCBiLCBhICkgJiYgbWlkZGxlSW5zaWRlKCBhLCBiICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8vIHNpZ25lZCBhcmVhIG9mIGEgdHJpYW5nbGVcXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBhcmVhKCBwLCBxLCByICkge1xcclxcblxcclxcblxcdFxcdHJldHVybiAoIHEueSAtIHAueSApICogKCByLnggLSBxLnggKSAtICggcS54IC0gcC54ICkgKiAoIHIueSAtIHEueSApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHQvLyBjaGVjayBpZiB0d28gcG9pbnRzIGFyZSBlcXVhbFxcclxcblxcclxcblxcdGZ1bmN0aW9uIGVxdWFscyggcDEsIHAyICkge1xcclxcblxcclxcblxcdFxcdHJldHVybiBwMS54ID09PSBwMi54ICYmIHAxLnkgPT09IHAyLnk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8vIGNoZWNrIGlmIHR3byBzZWdtZW50cyBpbnRlcnNlY3RcXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBpbnRlcnNlY3RzKCBwMSwgcTEsIHAyLCBxMiApIHtcXHJcXG5cXHJcXG5cXHRcXHRpZiAoICggZXF1YWxzKCBwMSwgcTEgKSAmJiBlcXVhbHMoIHAyLCBxMiApICkgfHxcXHJcXG5cXHRcXHRcXHRcXHQoIGVxdWFscyggcDEsIHEyICkgJiYgZXF1YWxzKCBwMiwgcTEgKSApICkgcmV0dXJuIHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIGFyZWEoIHAxLCBxMSwgcDIgKSA+IDAgIT09IGFyZWEoIHAxLCBxMSwgcTIgKSA+IDAgJiZcXHJcXG5cXHRcXHRcXHRcXHRcXHQgYXJlYSggcDIsIHEyLCBwMSApID4gMCAhPT0gYXJlYSggcDIsIHEyLCBxMSApID4gMDtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0Ly8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGludGVyc2VjdHMgYW55IHBvbHlnb24gc2VnbWVudHNcXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBpbnRlcnNlY3RzUG9seWdvbiggYSwgYiApIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgcCA9IGE7XFxyXFxuXFxyXFxuXFx0XFx0ZG8ge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggcC5pICE9PSBhLmkgJiYgcC5uZXh0LmkgIT09IGEuaSAmJiBwLmkgIT09IGIuaSAmJiBwLm5leHQuaSAhPT0gYi5pICYmXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aW50ZXJzZWN0cyggcCwgcC5uZXh0LCBhLCBiICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHAgPSBwLm5leHQ7XFxyXFxuXFxyXFxuXFx0XFx0fSB3aGlsZSAoIHAgIT09IGEgKTtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gZmFsc2U7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpcyBsb2NhbGx5IGluc2lkZSB0aGUgcG9seWdvblxcclxcblxcclxcblxcdGZ1bmN0aW9uIGxvY2FsbHlJbnNpZGUoIGEsIGIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIGFyZWEoIGEucHJldiwgYSwgYS5uZXh0ICkgPCAwID9cXHJcXG5cXHRcXHRcXHRhcmVhKCBhLCBiLCBhLm5leHQgKSA+PSAwICYmIGFyZWEoIGEsIGEucHJldiwgYiApID49IDAgOlxcclxcblxcdFxcdFxcdGFyZWEoIGEsIGIsIGEucHJldiApIDwgMCB8fCBhcmVhKCBhLCBhLm5leHQsIGIgKSA8IDA7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8vIGNoZWNrIGlmIHRoZSBtaWRkbGUgcG9pbnQgb2YgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGluc2lkZSB0aGUgcG9seWdvblxcclxcblxcclxcblxcdGZ1bmN0aW9uIG1pZGRsZUluc2lkZSggYSwgYiApIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgcCA9IGEsXFxyXFxuXFx0XFx0XFx0aW5zaWRlID0gZmFsc2UsXFxyXFxuXFx0XFx0XFx0cHggPSAoIGEueCArIGIueCApIC8gMixcXHJcXG5cXHRcXHRcXHRweSA9ICggYS55ICsgYi55ICkgLyAyO1xcclxcblxcclxcblxcdFxcdGRvIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoICggKCBwLnkgPiBweSApICE9PSAoIHAubmV4dC55ID4gcHkgKSApICYmIHAubmV4dC55ICE9PSBwLnkgJiZcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQoIHB4IDwgKCBwLm5leHQueCAtIHAueCApICogKCBweSAtIHAueSApIC8gKCBwLm5leHQueSAtIHAueSApICsgcC54ICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aW5zaWRlID0gISBpbnNpZGU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHAgPSBwLm5leHQ7XFxyXFxuXFxyXFxuXFx0XFx0fSB3aGlsZSAoIHAgIT09IGEgKTtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gaW5zaWRlO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHQvLyBsaW5rIHR3byBwb2x5Z29uIHZlcnRpY2VzIHdpdGggYSBicmlkZ2U7IGlmIHRoZSB2ZXJ0aWNlcyBiZWxvbmcgdG8gdGhlIHNhbWUgcmluZywgaXQgc3BsaXRzIHBvbHlnb24gaW50byB0d287XFxyXFxuXFx0Ly8gaWYgb25lIGJlbG9uZ3MgdG8gdGhlIG91dGVyIHJpbmcgYW5kIGFub3RoZXIgdG8gYSBob2xlLCBpdCBtZXJnZXMgaXQgaW50byBhIHNpbmdsZSByaW5nXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gc3BsaXRQb2x5Z29uKCBhLCBiICkge1xcclxcblxcclxcblxcdFxcdHZhciBhMiA9IG5ldyBOb2RlKCBhLmksIGEueCwgYS55ICksXFxyXFxuXFx0XFx0XFx0YjIgPSBuZXcgTm9kZSggYi5pLCBiLngsIGIueSApLFxcclxcblxcdFxcdFxcdGFuID0gYS5uZXh0LFxcclxcblxcdFxcdFxcdGJwID0gYi5wcmV2O1xcclxcblxcclxcblxcdFxcdGEubmV4dCA9IGI7XFxyXFxuXFx0XFx0Yi5wcmV2ID0gYTtcXHJcXG5cXHJcXG5cXHRcXHRhMi5uZXh0ID0gYW47XFxyXFxuXFx0XFx0YW4ucHJldiA9IGEyO1xcclxcblxcclxcblxcdFxcdGIyLm5leHQgPSBhMjtcXHJcXG5cXHRcXHRhMi5wcmV2ID0gYjI7XFxyXFxuXFxyXFxuXFx0XFx0YnAubmV4dCA9IGIyO1xcclxcblxcdFxcdGIyLnByZXYgPSBicDtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gYjI7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8vIGNyZWF0ZSBhIG5vZGUgYW5kIG9wdGlvbmFsbHkgbGluayBpdCB3aXRoIHByZXZpb3VzIG9uZSAoaW4gYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QpXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gaW5zZXJ0Tm9kZSggaSwgeCwgeSwgbGFzdCApIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgcCA9IG5ldyBOb2RlKCBpLCB4LCB5ICk7XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCAhIGxhc3QgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cC5wcmV2ID0gcDtcXHJcXG5cXHRcXHRcXHRwLm5leHQgPSBwO1xcclxcblxcclxcblxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cC5uZXh0ID0gbGFzdC5uZXh0O1xcclxcblxcdFxcdFxcdHAucHJldiA9IGxhc3Q7XFxyXFxuXFx0XFx0XFx0bGFzdC5uZXh0LnByZXYgPSBwO1xcclxcblxcdFxcdFxcdGxhc3QubmV4dCA9IHA7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHJldHVybiBwO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiByZW1vdmVOb2RlKCBwICkge1xcclxcblxcclxcblxcdFxcdHAubmV4dC5wcmV2ID0gcC5wcmV2O1xcclxcblxcdFxcdHAucHJldi5uZXh0ID0gcC5uZXh0O1xcclxcblxcclxcblxcdFxcdGlmICggcC5wcmV2WiApIHAucHJldloubmV4dFogPSBwLm5leHRaO1xcclxcblxcdFxcdGlmICggcC5uZXh0WiApIHAubmV4dFoucHJldlogPSBwLnByZXZaO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBOb2RlKCBpLCB4LCB5ICkge1xcclxcblxcclxcblxcdFxcdC8vIHZlcnRpY2UgaW5kZXggaW4gY29vcmRpbmF0ZXMgYXJyYXlcXHJcXG5cXHRcXHR0aGlzLmkgPSBpO1xcclxcblxcclxcblxcdFxcdC8vIHZlcnRleCBjb29yZGluYXRlc1xcclxcblxcdFxcdHRoaXMueCA9IHg7XFxyXFxuXFx0XFx0dGhpcy55ID0geTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBwcmV2aW91cyBhbmQgbmV4dCB2ZXJ0aWNlIG5vZGVzIGluIGEgcG9seWdvbiByaW5nXFxyXFxuXFx0XFx0dGhpcy5wcmV2ID0gbnVsbDtcXHJcXG5cXHRcXHR0aGlzLm5leHQgPSBudWxsO1xcclxcblxcclxcblxcdFxcdC8vIHotb3JkZXIgY3VydmUgdmFsdWVcXHJcXG5cXHRcXHR0aGlzLnogPSBudWxsO1xcclxcblxcclxcblxcdFxcdC8vIHByZXZpb3VzIGFuZCBuZXh0IG5vZGVzIGluIHotb3JkZXJcXHJcXG5cXHRcXHR0aGlzLnByZXZaID0gbnVsbDtcXHJcXG5cXHRcXHR0aGlzLm5leHRaID0gbnVsbDtcXHJcXG5cXHJcXG5cXHRcXHQvLyBpbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIGEgc3RlaW5lciBwb2ludFxcclxcblxcdFxcdHRoaXMuc3RlaW5lciA9IGZhbHNlO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBzaWduZWRBcmVhKCBkYXRhLCBzdGFydCwgZW5kLCBkaW0gKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHN1bSA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0Zm9yICggdmFyIGkgPSBzdGFydCwgaiA9IGVuZCAtIGRpbTsgaSA8IGVuZDsgaSArPSBkaW0gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0c3VtICs9ICggZGF0YVsgaiBdIC0gZGF0YVsgaSBdICkgKiAoIGRhdGFbIGkgKyAxIF0gKyBkYXRhWyBqICsgMSBdICk7XFxyXFxuXFx0XFx0XFx0aiA9IGk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHJldHVybiBzdW07XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHR2YXIgU2hhcGVVdGlscyA9IHtcXHJcXG5cXHJcXG5cXHRcXHQvLyBjYWxjdWxhdGUgYXJlYSBvZiB0aGUgY29udG91ciBwb2x5Z29uXFxyXFxuXFxyXFxuXFx0XFx0YXJlYTogZnVuY3Rpb24gKCBjb250b3VyICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBuID0gY29udG91ci5sZW5ndGg7XFxyXFxuXFx0XFx0XFx0dmFyIGEgPSAwLjA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIHAgPSBuIC0gMSwgcSA9IDA7IHEgPCBuOyBwID0gcSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRhICs9IGNvbnRvdXJbIHAgXS54ICogY29udG91clsgcSBdLnkgLSBjb250b3VyWyBxIF0ueCAqIGNvbnRvdXJbIHAgXS55O1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gYSAqIDAuNTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGlzQ2xvY2tXaXNlOiBmdW5jdGlvbiAoIHB0cyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gU2hhcGVVdGlscy5hcmVhKCBwdHMgKSA8IDA7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHR0cmlhbmd1bGF0ZVNoYXBlOiBmdW5jdGlvbiAoIGNvbnRvdXIsIGhvbGVzICkge1xcclxcblxcclxcblxcdFxcdFxcdGZ1bmN0aW9uIHJlbW92ZUR1cEVuZFB0cyggcG9pbnRzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBsID0gcG9pbnRzLmxlbmd0aDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGwgPiAyICYmIHBvaW50c1sgbCAtIDEgXS5lcXVhbHMoIHBvaW50c1sgMCBdICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cG9pbnRzLnBvcCgpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZnVuY3Rpb24gYWRkQ29udG91ciggdmVydGljZXMsIGNvbnRvdXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgY29udG91ci5sZW5ndGg7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmVydGljZXMucHVzaCggY29udG91clsgaSBdLnggKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCBjb250b3VyWyBpIF0ueSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHZlcnRpY2VzID0gW107IC8vIGZsYXQgYXJyYXkgb2YgdmVydGljZXMgbGlrZSBbIHgwLHkwLCB4MSx5MSwgeDIseTIsIC4uLiBdXFxyXFxuXFx0XFx0XFx0dmFyIGhvbGVJbmRpY2VzID0gW107IC8vIGFycmF5IG9mIGhvbGUgaW5kaWNlc1xcclxcblxcdFxcdFxcdHZhciBmYWNlcyA9IFtdOyAvLyBmaW5hbCBhcnJheSBvZiB2ZXJ0ZXggaW5kaWNlcyBsaWtlIFsgWyBhLGIsZCBdLCBbIGIsYyxkIF0gXVxcclxcblxcclxcblxcdFxcdFxcdHJlbW92ZUR1cEVuZFB0cyggY29udG91ciApO1xcclxcblxcdFxcdFxcdGFkZENvbnRvdXIoIHZlcnRpY2VzLCBjb250b3VyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly9cXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgaG9sZUluZGV4ID0gY29udG91ci5sZW5ndGg7XFxyXFxuXFx0XFx0XFx0aG9sZXMuZm9yRWFjaCggcmVtb3ZlRHVwRW5kUHRzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggaSA9IDA7IGkgPCBob2xlcy5sZW5ndGg7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aG9sZUluZGljZXMucHVzaCggaG9sZUluZGV4ICk7XFxyXFxuXFx0XFx0XFx0XFx0aG9sZUluZGV4ICs9IGhvbGVzWyBpIF0ubGVuZ3RoO1xcclxcblxcdFxcdFxcdFxcdGFkZENvbnRvdXIoIHZlcnRpY2VzLCBob2xlc1sgaSBdICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdC8vXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHRyaWFuZ2xlcyA9IEVhcmN1dC50cmlhbmd1bGF0ZSggdmVydGljZXMsIGhvbGVJbmRpY2VzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly9cXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0cmlhbmdsZXMubGVuZ3RoOyBpICs9IDMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZmFjZXMucHVzaCggdHJpYW5nbGVzLnNsaWNlKCBpLCBpICsgMyApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBmYWNlcztcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBDcmVhdGVzIGV4dHJ1ZGVkIGdlb21ldHJ5IGZyb20gYSBwYXRoIHNoYXBlLlxcclxcblxcdCAqXFxyXFxuXFx0ICogcGFyYW1ldGVycyA9IHtcXHJcXG5cXHQgKlxcclxcblxcdCAqICBjdXJ2ZVNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmVzXFxyXFxuXFx0ICogIHN0ZXBzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBmb3Igei1zaWRlIGV4dHJ1c2lvbnMgLyB1c2VkIGZvciBzdWJkaXZpZGluZyBzZWdtZW50cyBvZiBleHRydWRlIHNwbGluZSB0b29cXHJcXG5cXHQgKiAgYW1vdW50OiA8aW50PiwgLy8gRGVwdGggdG8gZXh0cnVkZSB0aGUgc2hhcGVcXHJcXG5cXHQgKlxcclxcblxcdCAqICBiZXZlbEVuYWJsZWQ6IDxib29sPiwgLy8gdHVybiBvbiBiZXZlbFxcclxcblxcdCAqICBiZXZlbFRoaWNrbmVzczogPGZsb2F0PiwgLy8gaG93IGRlZXAgaW50byB0aGUgb3JpZ2luYWwgc2hhcGUgYmV2ZWwgZ29lc1xcclxcblxcdCAqICBiZXZlbFNpemU6IDxmbG9hdD4sIC8vIGhvdyBmYXIgZnJvbSBzaGFwZSBvdXRsaW5lIGlzIGJldmVsXFxyXFxuXFx0ICogIGJldmVsU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgYmV2ZWwgbGF5ZXJzXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiAgZXh0cnVkZVBhdGg6IDxUSFJFRS5DdXJ2ZT4gLy8gY3VydmUgdG8gZXh0cnVkZSBzaGFwZSBhbG9uZ1xcclxcblxcdCAqICBmcmFtZXM6IDxPYmplY3Q+IC8vIGNvbnRhaW5pbmcgYXJyYXlzIG9mIHRhbmdlbnRzLCBub3JtYWxzLCBiaW5vcm1hbHNcXHJcXG5cXHQgKlxcclxcblxcdCAqICBVVkdlbmVyYXRvcjogPE9iamVjdD4gLy8gb2JqZWN0IHRoYXQgcHJvdmlkZXMgVVYgZ2VuZXJhdG9yIGZ1bmN0aW9uc1xcclxcblxcdCAqXFxyXFxuXFx0ICogfVxcclxcblxcdCAqL1xcclxcblxcclxcblxcdC8vIEV4dHJ1ZGVHZW9tZXRyeVxcclxcblxcclxcblxcdGZ1bmN0aW9uIEV4dHJ1ZGVHZW9tZXRyeSggc2hhcGVzLCBvcHRpb25zICkge1xcclxcblxcclxcblxcdFxcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnRXh0cnVkZUdlb21ldHJ5JztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxyXFxuXFx0XFx0XFx0c2hhcGVzOiBzaGFwZXMsXFxyXFxuXFx0XFx0XFx0b3B0aW9uczogb3B0aW9uc1xcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBFeHRydWRlQnVmZmVyR2VvbWV0cnkoIHNoYXBlcywgb3B0aW9ucyApICk7XFxyXFxuXFx0XFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdEV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcXHJcXG5cXHRFeHRydWRlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXh0cnVkZUdlb21ldHJ5O1xcclxcblxcclxcblxcdC8vIEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeVxcclxcblxcclxcblxcdGZ1bmN0aW9uIEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeSggc2hhcGVzLCBvcHRpb25zICkge1xcclxcblxcclxcblxcdFxcdGlmICggdHlwZW9mICggc2hhcGVzICkgPT09IFxcXCJ1bmRlZmluZWRcXFwiICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybjtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdFeHRydWRlQnVmZmVyR2VvbWV0cnknO1xcclxcblxcclxcblxcdFxcdHNoYXBlcyA9IEFycmF5LmlzQXJyYXkoIHNoYXBlcyApID8gc2hhcGVzIDogWyBzaGFwZXMgXTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmFkZFNoYXBlTGlzdCggc2hhcGVzLCBvcHRpb25zICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xcclxcblxcclxcblxcdFxcdC8vIGNhbid0IHJlYWxseSB1c2UgYXV0b21hdGljIHZlcnRleCBub3JtYWxzXFxyXFxuXFx0XFx0Ly8gYXMgdGhlbiBmcm9udCBhbmQgYmFjayBzaWRlcyBnZXQgc21vb3RoZWQgdG9vXFxyXFxuXFx0XFx0Ly8gc2hvdWxkIGRvIHNlcGFyYXRlIHNtb290aGluZyBqdXN0IGZvciBzaWRlc1xcclxcblxcclxcblxcdFxcdC8vdGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xcclxcblxcclxcblxcdFxcdC8vY29uc29sZS5sb2coIFxcXCJ0b29rXFxcIiwgKCBEYXRlLm5vdygpIC0gc3RhcnRUaW1lICkgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0RXh0cnVkZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xcclxcblxcdEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFeHRydWRlQnVmZmVyR2VvbWV0cnk7XFxyXFxuXFxyXFxuXFx0RXh0cnVkZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5nZXRBcnJheXMgPSBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHBvc2l0aW9uQXR0cmlidXRlID0gdGhpcy5nZXRBdHRyaWJ1dGUoIFxcXCJwb3NpdGlvblxcXCIgKTtcXHJcXG5cXHRcXHR2YXIgdmVydGljZXNBcnJheSA9IHBvc2l0aW9uQXR0cmlidXRlID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIHBvc2l0aW9uQXR0cmlidXRlLmFycmF5ICkgOiBbXTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgdXZBdHRyaWJ1dGUgPSB0aGlzLmdldEF0dHJpYnV0ZSggXFxcInV2XFxcIiApO1xcclxcblxcdFxcdHZhciB1dkFycmF5ID0gdXZBdHRyaWJ1dGUgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggdXZBdHRyaWJ1dGUuYXJyYXkgKSA6IFtdO1xcclxcblxcclxcblxcdFxcdHZhciBJbmRleEF0dHJpYnV0ZSA9IHRoaXMuaW5kZXg7XFxyXFxuXFx0XFx0dmFyIGluZGljZXNBcnJheSA9IEluZGV4QXR0cmlidXRlID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIEluZGV4QXR0cmlidXRlLmFycmF5ICkgOiBbXTtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4ge1xcclxcblxcdFxcdFxcdHBvc2l0aW9uOiB2ZXJ0aWNlc0FycmF5LFxcclxcblxcdFxcdFxcdHV2OiB1dkFycmF5LFxcclxcblxcdFxcdFxcdGluZGV4OiBpbmRpY2VzQXJyYXlcXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0RXh0cnVkZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5hZGRTaGFwZUxpc3QgPSBmdW5jdGlvbiAoIHNoYXBlcywgb3B0aW9ucyApIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgc2wgPSBzaGFwZXMubGVuZ3RoO1xcclxcblxcdFxcdG9wdGlvbnMuYXJyYXlzID0gdGhpcy5nZXRBcnJheXMoKTtcXHJcXG5cXHJcXG5cXHRcXHRmb3IgKCB2YXIgcyA9IDA7IHMgPCBzbDsgcyArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgc2hhcGUgPSBzaGFwZXNbIHMgXTtcXHJcXG5cXHRcXHRcXHR0aGlzLmFkZFNoYXBlKCBzaGFwZSwgb3B0aW9ucyApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnNldEluZGV4KCBvcHRpb25zLmFycmF5cy5pbmRleCApO1xcclxcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggb3B0aW9ucy5hcnJheXMucG9zaXRpb24sIDMgKSApO1xcclxcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggb3B0aW9ucy5hcnJheXMudXYsIDIgKSApO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0RXh0cnVkZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uICggc2hhcGUsIG9wdGlvbnMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGFycmF5cyA9IG9wdGlvbnMuYXJyYXlzID8gb3B0aW9ucy5hcnJheXMgOiB0aGlzLmdldEFycmF5cygpO1xcclxcblxcdFxcdHZhciB2ZXJ0aWNlc0FycmF5ID0gYXJyYXlzLnBvc2l0aW9uO1xcclxcblxcdFxcdHZhciBpbmRpY2VzQXJyYXkgPSBhcnJheXMuaW5kZXg7XFxyXFxuXFx0XFx0dmFyIHV2QXJyYXkgPSBhcnJheXMudXY7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHBsYWNlaG9sZGVyID0gW107XFxyXFxuXFxyXFxuXFxyXFxuXFx0XFx0dmFyIGFtb3VudCA9IG9wdGlvbnMuYW1vdW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFtb3VudCA6IDEwMDtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgYmV2ZWxUaGlja25lc3MgPSBvcHRpb25zLmJldmVsVGhpY2tuZXNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsVGhpY2tuZXNzIDogNjsgLy8gMTBcXHJcXG5cXHRcXHR2YXIgYmV2ZWxTaXplID0gb3B0aW9ucy5iZXZlbFNpemUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxTaXplIDogYmV2ZWxUaGlja25lc3MgLSAyOyAvLyA4XFxyXFxuXFx0XFx0dmFyIGJldmVsU2VnbWVudHMgPSBvcHRpb25zLmJldmVsU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxTZWdtZW50cyA6IDM7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGJldmVsRW5hYmxlZCA9IG9wdGlvbnMuYmV2ZWxFbmFibGVkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsRW5hYmxlZCA6IHRydWU7IC8vIGZhbHNlXFxyXFxuXFxyXFxuXFx0XFx0dmFyIGN1cnZlU2VnbWVudHMgPSBvcHRpb25zLmN1cnZlU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3VydmVTZWdtZW50cyA6IDEyO1xcclxcblxcclxcblxcdFxcdHZhciBzdGVwcyA9IG9wdGlvbnMuc3RlcHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RlcHMgOiAxO1xcclxcblxcclxcblxcdFxcdHZhciBleHRydWRlUGF0aCA9IG9wdGlvbnMuZXh0cnVkZVBhdGg7XFxyXFxuXFx0XFx0dmFyIGV4dHJ1ZGVQdHMsIGV4dHJ1ZGVCeVBhdGggPSBmYWxzZTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBVc2UgZGVmYXVsdCBXb3JsZFVWR2VuZXJhdG9yIGlmIG5vIFVWIGdlbmVyYXRvcnMgYXJlIHNwZWNpZmllZC5cXHJcXG5cXHRcXHR2YXIgdXZnZW4gPSBvcHRpb25zLlVWR2VuZXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLlVWR2VuZXJhdG9yIDogRXh0cnVkZUdlb21ldHJ5LldvcmxkVVZHZW5lcmF0b3I7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHNwbGluZVR1YmUsIGJpbm9ybWFsLCBub3JtYWwsIHBvc2l0aW9uMjtcXHJcXG5cXHRcXHRpZiAoIGV4dHJ1ZGVQYXRoICkge1xcclxcblxcclxcblxcdFxcdFxcdGV4dHJ1ZGVQdHMgPSBleHRydWRlUGF0aC5nZXRTcGFjZWRQb2ludHMoIHN0ZXBzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZXh0cnVkZUJ5UGF0aCA9IHRydWU7XFxyXFxuXFx0XFx0XFx0YmV2ZWxFbmFibGVkID0gZmFsc2U7IC8vIGJldmVscyBub3Qgc3VwcG9ydGVkIGZvciBwYXRoIGV4dHJ1c2lvblxcclxcblxcclxcblxcdFxcdFxcdC8vIFNFVFVQIFROQiB2YXJpYWJsZXNcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBUT0RPMSAtIGhhdmUgYSAuaXNDbG9zZWQgaW4gc3BsaW5lP1xcclxcblxcclxcblxcdFxcdFxcdHNwbGluZVR1YmUgPSBvcHRpb25zLmZyYW1lcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5mcmFtZXMgOiBleHRydWRlUGF0aC5jb21wdXRlRnJlbmV0RnJhbWVzKCBzdGVwcywgZmFsc2UgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBjb25zb2xlLmxvZyhzcGxpbmVUdWJlLCAnc3BsaW5lVHViZScsIHNwbGluZVR1YmUubm9ybWFscy5sZW5ndGgsICdzdGVwcycsIHN0ZXBzLCAnZXh0cnVkZVB0cycsIGV4dHJ1ZGVQdHMubGVuZ3RoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRiaW5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0XFx0bm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHRcXHRcXHRwb3NpdGlvbjIgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHQvLyBTYWZlZ3VhcmRzIGlmIGJldmVscyBhcmUgbm90IGVuYWJsZWRcXHJcXG5cXHJcXG5cXHRcXHRpZiAoICEgYmV2ZWxFbmFibGVkICkge1xcclxcblxcclxcblxcdFxcdFxcdGJldmVsU2VnbWVudHMgPSAwO1xcclxcblxcdFxcdFxcdGJldmVsVGhpY2tuZXNzID0gMDtcXHJcXG5cXHRcXHRcXHRiZXZlbFNpemUgPSAwO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHQvLyBWYXJpYWJsZXMgaW5pdGlhbGl6YXRpb25cXHJcXG5cXHJcXG5cXHRcXHR2YXIgYWhvbGUsIGgsIGhsOyAvLyBsb29waW5nIG9mIGhvbGVzXFxyXFxuXFx0XFx0dmFyIHNjb3BlID0gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR2YXIgc2hhcGVQb2ludHMgPSBzaGFwZS5leHRyYWN0UG9pbnRzKCBjdXJ2ZVNlZ21lbnRzICk7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHZlcnRpY2VzID0gc2hhcGVQb2ludHMuc2hhcGU7XFxyXFxuXFx0XFx0dmFyIGhvbGVzID0gc2hhcGVQb2ludHMuaG9sZXM7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHJldmVyc2UgPSAhIFNoYXBlVXRpbHMuaXNDbG9ja1dpc2UoIHZlcnRpY2VzICk7XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCByZXZlcnNlICkge1xcclxcblxcclxcblxcdFxcdFxcdHZlcnRpY2VzID0gdmVydGljZXMucmV2ZXJzZSgpO1xcclxcblxcclxcblxcdFxcdFxcdC8vIE1heWJlIHdlIHNob3VsZCBhbHNvIGNoZWNrIGlmIGhvbGVzIGFyZSBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLCBqdXN0IHRvIGJlIHNhZmUgLi4uXFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YWhvbGUgPSBob2xlc1sgaCBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggYWhvbGUgKSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRob2xlc1sgaCBdID0gYWhvbGUucmV2ZXJzZSgpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcclxcblxcdFxcdHZhciBmYWNlcyA9IFNoYXBlVXRpbHMudHJpYW5ndWxhdGVTaGFwZSggdmVydGljZXMsIGhvbGVzICk7XFxyXFxuXFxyXFxuXFx0XFx0LyogVmVydGljZXMgKi9cXHJcXG5cXHJcXG5cXHRcXHR2YXIgY29udG91ciA9IHZlcnRpY2VzOyAvLyB2ZXJ0aWNlcyBoYXMgYWxsIHBvaW50cyBidXQgY29udG91ciBoYXMgb25seSBwb2ludHMgb2YgY2lyY3VtZmVyZW5jZVxcclxcblxcclxcblxcdFxcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdGFob2xlID0gaG9sZXNbIGggXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2ZXJ0aWNlcyA9IHZlcnRpY2VzLmNvbmNhdCggYWhvbGUgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gc2NhbGVQdDIoIHB0LCB2ZWMsIHNpemUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCAhIHZlYyApIGNvbnNvbGUuZXJyb3IoIFxcXCJUSFJFRS5FeHRydWRlR2VvbWV0cnk6IHZlYyBkb2VzIG5vdCBleGlzdFxcXCIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdmVjLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoIHNpemUgKS5hZGQoIHB0ICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHZhciBiLCBicywgdCwgeixcXHJcXG5cXHRcXHRcXHR2ZXJ0LCB2bGVuID0gdmVydGljZXMubGVuZ3RoLFxcclxcblxcdFxcdFxcdGZhY2UsIGZsZW4gPSBmYWNlcy5sZW5ndGg7XFxyXFxuXFxyXFxuXFxyXFxuXFx0XFx0Ly8gRmluZCBkaXJlY3Rpb25zIGZvciBwb2ludCBtb3ZlbWVudFxcclxcblxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIGdldEJldmVsVmVjKCBpblB0LCBpblByZXYsIGluTmV4dCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBjb21wdXRlcyBmb3IgaW5QdCB0aGUgY29ycmVzcG9uZGluZyBwb2ludCBpblB0JyBvbiBhIG5ldyBjb250b3VyXFxyXFxuXFx0XFx0XFx0Ly8gICBzaGlmdGVkIGJ5IDEgdW5pdCAobGVuZ3RoIG9mIG5vcm1hbGl6ZWQgdmVjdG9yKSB0byB0aGUgbGVmdFxcclxcblxcdFxcdFxcdC8vIGlmIHdlIHdhbGsgYWxvbmcgY29udG91ciBjbG9ja3dpc2UsIHRoaXMgbmV3IGNvbnRvdXIgaXMgb3V0c2lkZSB0aGUgb2xkIG9uZVxcclxcblxcdFxcdFxcdC8vXFxyXFxuXFx0XFx0XFx0Ly8gaW5QdCcgaXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIGxpbmVzIHBhcmFsbGVsIHRvIHRoZSB0d29cXHJcXG5cXHRcXHRcXHQvLyAgYWRqYWNlbnQgZWRnZXMgb2YgaW5QdCBhdCBhIGRpc3RhbmNlIG9mIDEgdW5pdCBvbiB0aGUgbGVmdCBzaWRlLlxcclxcblxcclxcblxcdFxcdFxcdHZhciB2X3RyYW5zX3gsIHZfdHJhbnNfeSwgc2hyaW5rX2J5OyAvLyByZXN1bHRpbmcgdHJhbnNsYXRpb24gdmVjdG9yIGZvciBpblB0XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gZ29vZCByZWFkaW5nIGZvciBnZW9tZXRyeSBhbGdvcml0aG1zIChoZXJlOiBsaW5lLWxpbmUgaW50ZXJzZWN0aW9uKVxcclxcblxcdFxcdFxcdC8vIGh0dHA6Ly9nZW9tYWxnb3JpdGhtcy5jb20vYTA1LV9pbnRlcnNlY3QtMS5odG1sXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHZfcHJldl94ID0gaW5QdC54IC0gaW5QcmV2LngsXFxyXFxuXFx0XFx0XFx0XFx0dl9wcmV2X3kgPSBpblB0LnkgLSBpblByZXYueTtcXHJcXG5cXHRcXHRcXHR2YXIgdl9uZXh0X3ggPSBpbk5leHQueCAtIGluUHQueCxcXHJcXG5cXHRcXHRcXHRcXHR2X25leHRfeSA9IGluTmV4dC55IC0gaW5QdC55O1xcclxcblxcclxcblxcdFxcdFxcdHZhciB2X3ByZXZfbGVuc3EgPSAoIHZfcHJldl94ICogdl9wcmV2X3ggKyB2X3ByZXZfeSAqIHZfcHJldl95ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gY2hlY2sgZm9yIGNvbGxpbmVhciBlZGdlc1xcclxcblxcdFxcdFxcdHZhciBjb2xsaW5lYXIwID0gKCB2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeCApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggTWF0aC5hYnMoIGNvbGxpbmVhcjAgKSA+IE51bWJlci5FUFNJTE9OICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIG5vdCBjb2xsaW5lYXJcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBsZW5ndGggb2YgdmVjdG9ycyBmb3Igbm9ybWFsaXppbmdcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgdl9wcmV2X2xlbiA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxICk7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIHZfbmV4dF9sZW4gPSBNYXRoLnNxcnQoIHZfbmV4dF94ICogdl9uZXh0X3ggKyB2X25leHRfeSAqIHZfbmV4dF95ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gc2hpZnQgYWRqYWNlbnQgcG9pbnRzIGJ5IHVuaXQgdmVjdG9ycyB0byB0aGUgbGVmdFxcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBwdFByZXZTaGlmdF94ID0gKCBpblByZXYueCAtIHZfcHJldl95IC8gdl9wcmV2X2xlbiApO1xcclxcblxcdFxcdFxcdFxcdHZhciBwdFByZXZTaGlmdF95ID0gKCBpblByZXYueSArIHZfcHJldl94IC8gdl9wcmV2X2xlbiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBwdE5leHRTaGlmdF94ID0gKCBpbk5leHQueCAtIHZfbmV4dF95IC8gdl9uZXh0X2xlbiApO1xcclxcblxcdFxcdFxcdFxcdHZhciBwdE5leHRTaGlmdF95ID0gKCBpbk5leHQueSArIHZfbmV4dF94IC8gdl9uZXh0X2xlbiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIHNjYWxpbmcgZmFjdG9yIGZvciB2X3ByZXYgdG8gaW50ZXJzZWN0aW9uIHBvaW50XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHNmID0gKCAoIHB0TmV4dFNoaWZ0X3ggLSBwdFByZXZTaGlmdF94ICkgKiB2X25leHRfeSAtXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0KCBwdE5leHRTaGlmdF95IC0gcHRQcmV2U2hpZnRfeSApICogdl9uZXh0X3ggKSAvXFxyXFxuXFx0XFx0XFx0XFx0XFx0KCB2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIHZlY3RvciBmcm9tIGluUHQgdG8gaW50ZXJzZWN0aW9uIHBvaW50XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dl90cmFuc194ID0gKCBwdFByZXZTaGlmdF94ICsgdl9wcmV2X3ggKiBzZiAtIGluUHQueCApO1xcclxcblxcdFxcdFxcdFxcdHZfdHJhbnNfeSA9ICggcHRQcmV2U2hpZnRfeSArIHZfcHJldl95ICogc2YgLSBpblB0LnkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBEb24ndCBub3JtYWxpemUhLCBvdGhlcndpc2Ugc2hhcnAgY29ybmVycyBiZWNvbWUgdWdseVxcclxcblxcdFxcdFxcdFxcdC8vICBidXQgcHJldmVudCBjcmF6eSBzcGlrZXNcXHJcXG5cXHRcXHRcXHRcXHR2YXIgdl90cmFuc19sZW5zcSA9ICggdl90cmFuc194ICogdl90cmFuc194ICsgdl90cmFuc195ICogdl90cmFuc195ICk7XFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB2X3RyYW5zX2xlbnNxIDw9IDIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIG5ldyBWZWN0b3IyKCB2X3RyYW5zX3gsIHZfdHJhbnNfeSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0c2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3RyYW5zX2xlbnNxIC8gMiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGhhbmRsZSBzcGVjaWFsIGNhc2Ugb2YgY29sbGluZWFyIGVkZ2VzXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGRpcmVjdGlvbl9lcSA9IGZhbHNlOyAvLyBhc3N1bWVzOiBvcHBvc2l0ZVxcclxcblxcdFxcdFxcdFxcdGlmICggdl9wcmV2X3ggPiBOdW1iZXIuRVBTSUxPTiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHZfbmV4dF94ID4gTnVtYmVyLkVQU0lMT04gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGlyZWN0aW9uX2VxID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHZfcHJldl94IDwgLSBOdW1iZXIuRVBTSUxPTiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHZfbmV4dF94IDwgLSBOdW1iZXIuRVBTSUxPTiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkaXJlY3Rpb25fZXEgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggTWF0aC5zaWduKCB2X3ByZXZfeSApID09PSBNYXRoLnNpZ24oIHZfbmV4dF95ICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGlyZWN0aW9uX2VxID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGRpcmVjdGlvbl9lcSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBjb25zb2xlLmxvZyhcXFwiV2FybmluZzogbGluZXMgYXJlIGEgc3RyYWlnaHQgc2VxdWVuY2VcXFwiKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2X3RyYW5zX3ggPSAtIHZfcHJldl95O1xcclxcblxcdFxcdFxcdFxcdFxcdHZfdHJhbnNfeSA9IHZfcHJldl94O1xcclxcblxcdFxcdFxcdFxcdFxcdHNocmlua19ieSA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBjb25zb2xlLmxvZyhcXFwiV2FybmluZzogbGluZXMgYXJlIGEgc3RyYWlnaHQgc3Bpa2VcXFwiKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2X3RyYW5zX3ggPSB2X3ByZXZfeDtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2X3RyYW5zX3kgPSB2X3ByZXZfeTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRzaHJpbmtfYnkgPSBNYXRoLnNxcnQoIHZfcHJldl9sZW5zcSAvIDIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBuZXcgVmVjdG9yMiggdl90cmFuc194IC8gc2hyaW5rX2J5LCB2X3RyYW5zX3kgLyBzaHJpbmtfYnkgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFxyXFxuXFx0XFx0dmFyIGNvbnRvdXJNb3ZlbWVudHMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGgsIGogPSBpbCAtIDEsIGsgPSBpICsgMTsgaSA8IGlsOyBpICsrLCBqICsrLCBrICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggaiA9PT0gaWwgKSBqID0gMDtcXHJcXG5cXHRcXHRcXHRpZiAoIGsgPT09IGlsICkgayA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gIChqKS0tLShpKS0tLShrKVxcclxcblxcdFxcdFxcdC8vIGNvbnNvbGUubG9nKCdpLGosaycsIGksIGogLCBrKVxcclxcblxcclxcblxcdFxcdFxcdGNvbnRvdXJNb3ZlbWVudHNbIGkgXSA9IGdldEJldmVsVmVjKCBjb250b3VyWyBpIF0sIGNvbnRvdXJbIGogXSwgY29udG91clsgayBdICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHZhciBob2xlc01vdmVtZW50cyA9IFtdLFxcclxcblxcdFxcdFxcdG9uZUhvbGVNb3ZlbWVudHMsIHZlcnRpY2VzTW92ZW1lbnRzID0gY29udG91ck1vdmVtZW50cy5jb25jYXQoKTtcXHJcXG5cXHJcXG5cXHRcXHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRhaG9sZSA9IGhvbGVzWyBoIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0b25lSG9sZU1vdmVtZW50cyA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aCwgaiA9IGlsIC0gMSwgayA9IGkgKyAxOyBpIDwgaWw7IGkgKyssIGogKyssIGsgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBqID09PSBpbCApIGogPSAwO1xcclxcblxcdFxcdFxcdFxcdGlmICggayA9PT0gaWwgKSBrID0gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyAgKGopLS0tKGkpLS0tKGspXFxyXFxuXFx0XFx0XFx0XFx0b25lSG9sZU1vdmVtZW50c1sgaSBdID0gZ2V0QmV2ZWxWZWMoIGFob2xlWyBpIF0sIGFob2xlWyBqIF0sIGFob2xlWyBrIF0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aG9sZXNNb3ZlbWVudHMucHVzaCggb25lSG9sZU1vdmVtZW50cyApO1xcclxcblxcdFxcdFxcdHZlcnRpY2VzTW92ZW1lbnRzID0gdmVydGljZXNNb3ZlbWVudHMuY29uY2F0KCBvbmVIb2xlTW92ZW1lbnRzICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcclxcblxcdFxcdC8vIExvb3AgYmV2ZWxTZWdtZW50cywgMSBmb3IgdGhlIGZyb250LCAxIGZvciB0aGUgYmFja1xcclxcblxcclxcblxcdFxcdGZvciAoIGIgPSAwOyBiIDwgYmV2ZWxTZWdtZW50czsgYiArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvL2ZvciAoIGIgPSBiZXZlbFNlZ21lbnRzOyBiID4gMDsgYiAtLSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0ID0gYiAvIGJldmVsU2VnbWVudHM7XFxyXFxuXFx0XFx0XFx0eiA9IGJldmVsVGhpY2tuZXNzICogTWF0aC5jb3MoIHQgKiBNYXRoLlBJIC8gMiApO1xcclxcblxcdFxcdFxcdGJzID0gYmV2ZWxTaXplICogTWF0aC5zaW4oIHQgKiBNYXRoLlBJIC8gMiApO1xcclxcblxcclxcblxcdFxcdFxcdC8vIGNvbnRyYWN0IHNoYXBlXFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2ZXJ0ID0gc2NhbGVQdDIoIGNvbnRvdXJbIGkgXSwgY29udG91ck1vdmVtZW50c1sgaSBdLCBicyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHYoIHZlcnQueCwgdmVydC55LCAtIHogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gZXhwYW5kIGhvbGVzXFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YWhvbGUgPSBob2xlc1sgaCBdO1xcclxcblxcdFxcdFxcdFxcdG9uZUhvbGVNb3ZlbWVudHMgPSBob2xlc01vdmVtZW50c1sgaCBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZlcnQgPSBzY2FsZVB0MiggYWhvbGVbIGkgXSwgb25lSG9sZU1vdmVtZW50c1sgaSBdLCBicyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHYoIHZlcnQueCwgdmVydC55LCAtIHogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRicyA9IGJldmVsU2l6ZTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBCYWNrIGZhY2luZyB2ZXJ0aWNlc1xcclxcblxcclxcblxcdFxcdGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2ZXJ0ID0gYmV2ZWxFbmFibGVkID8gc2NhbGVQdDIoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzTW92ZW1lbnRzWyBpIF0sIGJzICkgOiB2ZXJ0aWNlc1sgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggISBleHRydWRlQnlQYXRoICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHYoIHZlcnQueCwgdmVydC55LCAwICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIDAgXS55LCBleHRydWRlUHRzWyAwIF0ueCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdG5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLm5vcm1hbHNbIDAgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnggKTtcXHJcXG5cXHRcXHRcXHRcXHRiaW5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLmJpbm9ybWFsc1sgMCBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHBvc2l0aW9uMi5jb3B5KCBleHRydWRlUHRzWyAwIF0gKS5hZGQoIG5vcm1hbCApLmFkZCggYmlub3JtYWwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2KCBwb3NpdGlvbjIueCwgcG9zaXRpb24yLnksIHBvc2l0aW9uMi56ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHQvLyBBZGQgc3RlcHBlZCB2ZXJ0aWNlcy4uLlxcclxcblxcdFxcdC8vIEluY2x1ZGluZyBmcm9udCBmYWNpbmcgdmVydGljZXNcXHJcXG5cXHJcXG5cXHRcXHR2YXIgcztcXHJcXG5cXHJcXG5cXHRcXHRmb3IgKCBzID0gMTsgcyA8PSBzdGVwczsgcyArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCBpID0gMDsgaSA8IHZsZW47IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmVydCA9IGJldmVsRW5hYmxlZCA/IHNjYWxlUHQyKCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc01vdmVtZW50c1sgaSBdLCBicyApIDogdmVydGljZXNbIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2KCB2ZXJ0LngsIHZlcnQueSwgYW1vdW50IC8gc3RlcHMgKiBzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueSwgZXh0cnVkZVB0c1sgcyAtIDEgXS54ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0bm9ybWFsLmNvcHkoIHNwbGluZVR1YmUubm9ybWFsc1sgcyBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueCApO1xcclxcblxcdFxcdFxcdFxcdFxcdGJpbm9ybWFsLmNvcHkoIHNwbGluZVR1YmUuYmlub3JtYWxzWyBzIF0gKS5tdWx0aXBseVNjYWxhciggdmVydC55ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cG9zaXRpb24yLmNvcHkoIGV4dHJ1ZGVQdHNbIHMgXSApLmFkZCggbm9ybWFsICkuYWRkKCBiaW5vcm1hbCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHYoIHBvc2l0aW9uMi54LCBwb3NpdGlvbjIueSwgcG9zaXRpb24yLnogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHJcXG5cXHRcXHQvLyBBZGQgYmV2ZWwgc2VnbWVudHMgcGxhbmVzXFxyXFxuXFxyXFxuXFx0XFx0Ly9mb3IgKCBiID0gMTsgYiA8PSBiZXZlbFNlZ21lbnRzOyBiICsrICkge1xcclxcblxcdFxcdGZvciAoIGIgPSBiZXZlbFNlZ21lbnRzIC0gMTsgYiA+PSAwOyBiIC0tICkge1xcclxcblxcclxcblxcdFxcdFxcdHQgPSBiIC8gYmV2ZWxTZWdtZW50cztcXHJcXG5cXHRcXHRcXHR6ID0gYmV2ZWxUaGlja25lc3MgKiBNYXRoLmNvcyggdCAqIE1hdGguUEkgLyAyICk7XFxyXFxuXFx0XFx0XFx0YnMgPSBiZXZlbFNpemUgKiBNYXRoLnNpbiggdCAqIE1hdGguUEkgLyAyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gY29udHJhY3Qgc2hhcGVcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZlcnQgPSBzY2FsZVB0MiggY29udG91clsgaSBdLCBjb250b3VyTW92ZW1lbnRzWyBpIF0sIGJzICk7XFxyXFxuXFx0XFx0XFx0XFx0diggdmVydC54LCB2ZXJ0LnksIGFtb3VudCArIHogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gZXhwYW5kIGhvbGVzXFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YWhvbGUgPSBob2xlc1sgaCBdO1xcclxcblxcdFxcdFxcdFxcdG9uZUhvbGVNb3ZlbWVudHMgPSBob2xlc01vdmVtZW50c1sgaCBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZlcnQgPSBzY2FsZVB0MiggYWhvbGVbIGkgXSwgb25lSG9sZU1vdmVtZW50c1sgaSBdLCBicyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggISBleHRydWRlQnlQYXRoICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHYoIHZlcnQueCwgdmVydC55LCBhbW91bnQgKyB6ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHN0ZXBzIC0gMSBdLnksIGV4dHJ1ZGVQdHNbIHN0ZXBzIC0gMSBdLnggKyB6ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdC8qIEZhY2VzICovXFxyXFxuXFxyXFxuXFx0XFx0Ly8gVG9wIGFuZCBib3R0b20gZmFjZXNcXHJcXG5cXHJcXG5cXHRcXHRidWlsZExpZEZhY2VzKCk7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gU2lkZXMgZmFjZXNcXHJcXG5cXHJcXG5cXHRcXHRidWlsZFNpZGVGYWNlcygpO1xcclxcblxcclxcblxcclxcblxcdFxcdC8vLy8vICBJbnRlcm5hbCBmdW5jdGlvbnNcXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBidWlsZExpZEZhY2VzKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBzdGFydCA9IHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMztcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGJldmVsRW5hYmxlZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgbGF5ZXIgPSAwOyAvLyBzdGVwcyArIDFcXHJcXG5cXHRcXHRcXHRcXHR2YXIgb2Zmc2V0ID0gdmxlbiAqIGxheWVyO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIEJvdHRvbSBmYWNlc1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmYWNlID0gZmFjZXNbIGkgXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRmMyggZmFjZVsgMiBdICsgb2Zmc2V0LCBmYWNlWyAxIF0gKyBvZmZzZXQsIGZhY2VbIDAgXSArIG9mZnNldCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRsYXllciA9IHN0ZXBzICsgYmV2ZWxTZWdtZW50cyAqIDI7XFxyXFxuXFx0XFx0XFx0XFx0b2Zmc2V0ID0gdmxlbiAqIGxheWVyO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIFRvcCBmYWNlc1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmYWNlID0gZmFjZXNbIGkgXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRmMyggZmFjZVsgMCBdICsgb2Zmc2V0LCBmYWNlWyAxIF0gKyBvZmZzZXQsIGZhY2VbIDIgXSArIG9mZnNldCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIEJvdHRvbSBmYWNlc1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmYWNlID0gZmFjZXNbIGkgXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRmMyggZmFjZVsgMiBdLCBmYWNlWyAxIF0sIGZhY2VbIDAgXSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBUb3AgZmFjZXNcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0ZmFjZSA9IGZhY2VzWyBpIF07XFxyXFxuXFx0XFx0XFx0XFx0XFx0ZjMoIGZhY2VbIDAgXSArIHZsZW4gKiBzdGVwcywgZmFjZVsgMSBdICsgdmxlbiAqIHN0ZXBzLCBmYWNlWyAyIF0gKyB2bGVuICogc3RlcHMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHNjb3BlLmFkZEdyb3VwKCBzdGFydCwgdmVydGljZXNBcnJheS5sZW5ndGggLyAzIC0gc3RhcnQsIG9wdGlvbnMubWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWF0ZXJpYWwgOiAwICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdC8vIENyZWF0ZSBmYWNlcyBmb3IgdGhlIHotc2lkZXMgb2YgdGhlIHNoYXBlXFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gYnVpbGRTaWRlRmFjZXMoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHN0YXJ0ID0gdmVydGljZXNBcnJheS5sZW5ndGggLyAzO1xcclxcblxcdFxcdFxcdHZhciBsYXllcm9mZnNldCA9IDA7XFxyXFxuXFx0XFx0XFx0c2lkZXdhbGxzKCBjb250b3VyLCBsYXllcm9mZnNldCApO1xcclxcblxcdFxcdFxcdGxheWVyb2Zmc2V0ICs9IGNvbnRvdXIubGVuZ3RoO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGFob2xlID0gaG9sZXNbIGggXTtcXHJcXG5cXHRcXHRcXHRcXHRzaWRld2FsbHMoIGFob2xlLCBsYXllcm9mZnNldCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vLCB0cnVlXFxyXFxuXFx0XFx0XFx0XFx0bGF5ZXJvZmZzZXQgKz0gYWhvbGUubGVuZ3RoO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHJcXG5cXHRcXHRcXHRzY29wZS5hZGRHcm91cCggc3RhcnQsIHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMyAtIHN0YXJ0LCBvcHRpb25zLmV4dHJ1ZGVNYXRlcmlhbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5leHRydWRlTWF0ZXJpYWwgOiAxICk7XFxyXFxuXFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZ1bmN0aW9uIHNpZGV3YWxscyggY29udG91ciwgbGF5ZXJvZmZzZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGosIGs7XFxyXFxuXFx0XFx0XFx0aSA9IGNvbnRvdXIubGVuZ3RoO1xcclxcblxcclxcblxcdFxcdFxcdHdoaWxlICggLS0gaSA+PSAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGogPSBpO1xcclxcblxcdFxcdFxcdFxcdGsgPSBpIC0gMTtcXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGsgPCAwICkgayA9IGNvbnRvdXIubGVuZ3RoIC0gMTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvL2NvbnNvbGUubG9nKCdiJywgaSxqLCBpLTEsIGssdmVydGljZXMubGVuZ3RoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgcyA9IDAsXFxyXFxuXFx0XFx0XFx0XFx0XFx0c2wgPSBzdGVwcyArIGJldmVsU2VnbWVudHMgKiAyO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIHMgPSAwOyBzIDwgc2w7IHMgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHNsZW4xID0gdmxlbiAqIHM7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHNsZW4yID0gdmxlbiAqICggcyArIDEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgYSA9IGxheWVyb2Zmc2V0ICsgaiArIHNsZW4xLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGIgPSBsYXllcm9mZnNldCArIGsgKyBzbGVuMSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjID0gbGF5ZXJvZmZzZXQgKyBrICsgc2xlbjIsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZCA9IGxheWVyb2Zmc2V0ICsgaiArIHNsZW4yO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGY0KCBhLCBiLCBjLCBkICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gdiggeCwgeSwgeiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRwbGFjZWhvbGRlci5wdXNoKCB4ICk7XFxyXFxuXFx0XFx0XFx0cGxhY2Vob2xkZXIucHVzaCggeSApO1xcclxcblxcdFxcdFxcdHBsYWNlaG9sZGVyLnB1c2goIHogKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gZjMoIGEsIGIsIGMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0YWRkVmVydGV4KCBhICk7XFxyXFxuXFx0XFx0XFx0YWRkVmVydGV4KCBiICk7XFxyXFxuXFx0XFx0XFx0YWRkVmVydGV4KCBjICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG5leHRJbmRleCA9IHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMztcXHJcXG5cXHRcXHRcXHR2YXIgdXZzID0gdXZnZW4uZ2VuZXJhdGVUb3BVViggc2NvcGUsIHZlcnRpY2VzQXJyYXksIG5leHRJbmRleCAtIDMsIG5leHRJbmRleCAtIDIsIG5leHRJbmRleCAtIDEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRhZGRVViggdXZzWyAwIF0gKTtcXHJcXG5cXHRcXHRcXHRhZGRVViggdXZzWyAxIF0gKTtcXHJcXG5cXHRcXHRcXHRhZGRVViggdXZzWyAyIF0gKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gZjQoIGEsIGIsIGMsIGQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0YWRkVmVydGV4KCBhICk7XFxyXFxuXFx0XFx0XFx0YWRkVmVydGV4KCBiICk7XFxyXFxuXFx0XFx0XFx0YWRkVmVydGV4KCBkICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0YWRkVmVydGV4KCBiICk7XFxyXFxuXFx0XFx0XFx0YWRkVmVydGV4KCBjICk7XFxyXFxuXFx0XFx0XFx0YWRkVmVydGV4KCBkICk7XFxyXFxuXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG5leHRJbmRleCA9IHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMztcXHJcXG5cXHRcXHRcXHR2YXIgdXZzID0gdXZnZW4uZ2VuZXJhdGVTaWRlV2FsbFVWKCBzY29wZSwgdmVydGljZXNBcnJheSwgbmV4dEluZGV4IC0gNiwgbmV4dEluZGV4IC0gMywgbmV4dEluZGV4IC0gMiwgbmV4dEluZGV4IC0gMSApO1xcclxcblxcclxcblxcdFxcdFxcdGFkZFVWKCB1dnNbIDAgXSApO1xcclxcblxcdFxcdFxcdGFkZFVWKCB1dnNbIDEgXSApO1xcclxcblxcdFxcdFxcdGFkZFVWKCB1dnNbIDMgXSApO1xcclxcblxcclxcblxcdFxcdFxcdGFkZFVWKCB1dnNbIDEgXSApO1xcclxcblxcdFxcdFxcdGFkZFVWKCB1dnNbIDIgXSApO1xcclxcblxcdFxcdFxcdGFkZFVWKCB1dnNbIDMgXSApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBhZGRWZXJ0ZXgoIGluZGV4ICkge1xcclxcblxcclxcblxcdFxcdFxcdGluZGljZXNBcnJheS5wdXNoKCB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDMgKTtcXHJcXG5cXHRcXHRcXHR2ZXJ0aWNlc0FycmF5LnB1c2goIHBsYWNlaG9sZGVyWyBpbmRleCAqIDMgKyAwIF0gKTtcXHJcXG5cXHRcXHRcXHR2ZXJ0aWNlc0FycmF5LnB1c2goIHBsYWNlaG9sZGVyWyBpbmRleCAqIDMgKyAxIF0gKTtcXHJcXG5cXHRcXHRcXHR2ZXJ0aWNlc0FycmF5LnB1c2goIHBsYWNlaG9sZGVyWyBpbmRleCAqIDMgKyAyIF0gKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gYWRkVVYoIHZlY3RvcjIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dXZBcnJheS5wdXNoKCB2ZWN0b3IyLnggKTtcXHJcXG5cXHRcXHRcXHR1dkFycmF5LnB1c2goIHZlY3RvcjIueSApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRpZiAoICEgb3B0aW9ucy5hcnJheXMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5zZXRJbmRleCggaW5kaWNlc0FycmF5ICk7XFxyXFxuXFx0XFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlc0FycmF5LCAzICkgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2QXJyYXksIDIgKSApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9O1xcclxcblxcclxcblxcdEV4dHJ1ZGVHZW9tZXRyeS5Xb3JsZFVWR2VuZXJhdG9yID0ge1xcclxcblxcclxcblxcdFxcdGdlbmVyYXRlVG9wVVY6IGZ1bmN0aW9uICggZ2VvbWV0cnksIHZlcnRpY2VzLCBpbmRleEEsIGluZGV4QiwgaW5kZXhDICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBhX3ggPSB2ZXJ0aWNlc1sgaW5kZXhBICogMyBdO1xcclxcblxcdFxcdFxcdHZhciBhX3kgPSB2ZXJ0aWNlc1sgaW5kZXhBICogMyArIDEgXTtcXHJcXG5cXHRcXHRcXHR2YXIgYl94ID0gdmVydGljZXNbIGluZGV4QiAqIDMgXTtcXHJcXG5cXHRcXHRcXHR2YXIgYl95ID0gdmVydGljZXNbIGluZGV4QiAqIDMgKyAxIF07XFxyXFxuXFx0XFx0XFx0dmFyIGNfeCA9IHZlcnRpY2VzWyBpbmRleEMgKiAzIF07XFxyXFxuXFx0XFx0XFx0dmFyIGNfeSA9IHZlcnRpY2VzWyBpbmRleEMgKiAzICsgMSBdO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBbXFxyXFxuXFx0XFx0XFx0XFx0bmV3IFZlY3RvcjIoIGFfeCwgYV95ICksXFxyXFxuXFx0XFx0XFx0XFx0bmV3IFZlY3RvcjIoIGJfeCwgYl95ICksXFxyXFxuXFx0XFx0XFx0XFx0bmV3IFZlY3RvcjIoIGNfeCwgY195IClcXHJcXG5cXHRcXHRcXHRdO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Z2VuZXJhdGVTaWRlV2FsbFVWOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCB2ZXJ0aWNlcywgaW5kZXhBLCBpbmRleEIsIGluZGV4QywgaW5kZXhEICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBhX3ggPSB2ZXJ0aWNlc1sgaW5kZXhBICogMyBdO1xcclxcblxcdFxcdFxcdHZhciBhX3kgPSB2ZXJ0aWNlc1sgaW5kZXhBICogMyArIDEgXTtcXHJcXG5cXHRcXHRcXHR2YXIgYV96ID0gdmVydGljZXNbIGluZGV4QSAqIDMgKyAyIF07XFxyXFxuXFx0XFx0XFx0dmFyIGJfeCA9IHZlcnRpY2VzWyBpbmRleEIgKiAzIF07XFxyXFxuXFx0XFx0XFx0dmFyIGJfeSA9IHZlcnRpY2VzWyBpbmRleEIgKiAzICsgMSBdO1xcclxcblxcdFxcdFxcdHZhciBiX3ogPSB2ZXJ0aWNlc1sgaW5kZXhCICogMyArIDIgXTtcXHJcXG5cXHRcXHRcXHR2YXIgY194ID0gdmVydGljZXNbIGluZGV4QyAqIDMgXTtcXHJcXG5cXHRcXHRcXHR2YXIgY195ID0gdmVydGljZXNbIGluZGV4QyAqIDMgKyAxIF07XFxyXFxuXFx0XFx0XFx0dmFyIGNfeiA9IHZlcnRpY2VzWyBpbmRleEMgKiAzICsgMiBdO1xcclxcblxcdFxcdFxcdHZhciBkX3ggPSB2ZXJ0aWNlc1sgaW5kZXhEICogMyBdO1xcclxcblxcdFxcdFxcdHZhciBkX3kgPSB2ZXJ0aWNlc1sgaW5kZXhEICogMyArIDEgXTtcXHJcXG5cXHRcXHRcXHR2YXIgZF96ID0gdmVydGljZXNbIGluZGV4RCAqIDMgKyAyIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBNYXRoLmFicyggYV95IC0gYl95ICkgPCAwLjAxICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiBbXFxyXFxuXFx0XFx0XFx0XFx0XFx0bmV3IFZlY3RvcjIoIGFfeCwgMSAtIGFfeiApLFxcclxcblxcdFxcdFxcdFxcdFxcdG5ldyBWZWN0b3IyKCBiX3gsIDEgLSBiX3ogKSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRuZXcgVmVjdG9yMiggY194LCAxIC0gY196ICksXFxyXFxuXFx0XFx0XFx0XFx0XFx0bmV3IFZlY3RvcjIoIGRfeCwgMSAtIGRfeiApXFxyXFxuXFx0XFx0XFx0XFx0XTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiBbXFxyXFxuXFx0XFx0XFx0XFx0XFx0bmV3IFZlY3RvcjIoIGFfeSwgMSAtIGFfeiApLFxcclxcblxcdFxcdFxcdFxcdFxcdG5ldyBWZWN0b3IyKCBiX3ksIDEgLSBiX3ogKSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRuZXcgVmVjdG9yMiggY195LCAxIC0gY196ICksXFxyXFxuXFx0XFx0XFx0XFx0XFx0bmV3IFZlY3RvcjIoIGRfeSwgMSAtIGRfeiApXFxyXFxuXFx0XFx0XFx0XFx0XTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xcclxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBUZXh0ID0gM0QgVGV4dFxcclxcblxcdCAqXFxyXFxuXFx0ICogcGFyYW1ldGVycyA9IHtcXHJcXG5cXHQgKiAgZm9udDogPFRIUkVFLkZvbnQ+LCAvLyBmb250XFxyXFxuXFx0ICpcXHJcXG5cXHQgKiAgc2l6ZTogPGZsb2F0PiwgLy8gc2l6ZSBvZiB0aGUgdGV4dFxcclxcblxcdCAqICBoZWlnaHQ6IDxmbG9hdD4sIC8vIHRoaWNrbmVzcyB0byBleHRydWRlIHRleHRcXHJcXG5cXHQgKiAgY3VydmVTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgb24gdGhlIGN1cnZlc1xcclxcblxcdCAqXFxyXFxuXFx0ICogIGJldmVsRW5hYmxlZDogPGJvb2w+LCAvLyB0dXJuIG9uIGJldmVsXFxyXFxuXFx0ICogIGJldmVsVGhpY2tuZXNzOiA8ZmxvYXQ+LCAvLyBob3cgZGVlcCBpbnRvIHRleHQgYmV2ZWwgZ29lc1xcclxcblxcdCAqICBiZXZlbFNpemU6IDxmbG9hdD4gLy8gaG93IGZhciBmcm9tIHRleHQgb3V0bGluZSBpcyBiZXZlbFxcclxcblxcdCAqIH1cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHQvLyBUZXh0R2VvbWV0cnlcXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBUZXh0R2VvbWV0cnkoIHRleHQsIHBhcmFtZXRlcnMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdUZXh0R2VvbWV0cnknO1xcclxcblxcclxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXHJcXG5cXHRcXHRcXHR0ZXh0OiB0ZXh0LFxcclxcblxcdFxcdFxcdHBhcmFtZXRlcnM6IHBhcmFtZXRlcnNcXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdFxcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgVGV4dEJ1ZmZlckdlb21ldHJ5KCB0ZXh0LCBwYXJhbWV0ZXJzICkgKTtcXHJcXG5cXHRcXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0VGV4dEdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xcclxcblxcdFRleHRHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUZXh0R2VvbWV0cnk7XFxyXFxuXFxyXFxuXFx0Ly8gVGV4dEJ1ZmZlckdlb21ldHJ5XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gVGV4dEJ1ZmZlckdlb21ldHJ5KCB0ZXh0LCBwYXJhbWV0ZXJzICkge1xcclxcblxcclxcblxcdFxcdHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xcclxcblxcclxcblxcdFxcdHZhciBmb250ID0gcGFyYW1ldGVycy5mb250O1xcclxcblxcclxcblxcdFxcdGlmICggISAoIGZvbnQgJiYgZm9udC5pc0ZvbnQgKSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVGV4dEdlb21ldHJ5OiBmb250IHBhcmFtZXRlciBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuRm9udC4nICk7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyBHZW9tZXRyeSgpO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR2YXIgc2hhcGVzID0gZm9udC5nZW5lcmF0ZVNoYXBlcyggdGV4dCwgcGFyYW1ldGVycy5zaXplLCBwYXJhbWV0ZXJzLmN1cnZlU2VnbWVudHMgKTtcXHJcXG5cXHJcXG5cXHRcXHQvLyB0cmFuc2xhdGUgcGFyYW1ldGVycyB0byBFeHRydWRlR2VvbWV0cnkgQVBJXFxyXFxuXFxyXFxuXFx0XFx0cGFyYW1ldGVycy5hbW91bnQgPSBwYXJhbWV0ZXJzLmhlaWdodCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5oZWlnaHQgOiA1MDtcXHJcXG5cXHJcXG5cXHRcXHQvLyBkZWZhdWx0c1xcclxcblxcclxcblxcdFxcdGlmICggcGFyYW1ldGVycy5iZXZlbFRoaWNrbmVzcyA9PT0gdW5kZWZpbmVkICkgcGFyYW1ldGVycy5iZXZlbFRoaWNrbmVzcyA9IDEwO1xcclxcblxcdFxcdGlmICggcGFyYW1ldGVycy5iZXZlbFNpemUgPT09IHVuZGVmaW5lZCApIHBhcmFtZXRlcnMuYmV2ZWxTaXplID0gODtcXHJcXG5cXHRcXHRpZiAoIHBhcmFtZXRlcnMuYmV2ZWxFbmFibGVkID09PSB1bmRlZmluZWQgKSBwYXJhbWV0ZXJzLmJldmVsRW5hYmxlZCA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzLCBzaGFwZXMsIHBhcmFtZXRlcnMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnVGV4dEJ1ZmZlckdlb21ldHJ5JztcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0VGV4dEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcXHJcXG5cXHRUZXh0QnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dEJ1ZmZlckdlb21ldHJ5O1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXFxyXFxuXFx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHQvLyBTcGhlcmVHZW9tZXRyeVxcclxcblxcclxcblxcdGZ1bmN0aW9uIFNwaGVyZUdlb21ldHJ5KCByYWRpdXMsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcXHJcXG5cXHJcXG5cXHRcXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50eXBlID0gJ1NwaGVyZUdlb21ldHJ5JztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxyXFxuXFx0XFx0XFx0cmFkaXVzOiByYWRpdXMsXFxyXFxuXFx0XFx0XFx0d2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcXHJcXG5cXHRcXHRcXHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXFxyXFxuXFx0XFx0XFx0cGhpU3RhcnQ6IHBoaVN0YXJ0LFxcclxcblxcdFxcdFxcdHBoaUxlbmd0aDogcGhpTGVuZ3RoLFxcclxcblxcdFxcdFxcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXFxyXFxuXFx0XFx0XFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IFNwaGVyZUJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApICk7XFxyXFxuXFx0XFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdFNwaGVyZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xcclxcblxcdFNwaGVyZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNwaGVyZUdlb21ldHJ5O1xcclxcblxcclxcblxcdC8vIFNwaGVyZUJ1ZmZlckdlb21ldHJ5XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gU3BoZXJlQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGgsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xcclxcblxcclxcblxcdFxcdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnU3BoZXJlQnVmZmVyR2VvbWV0cnknO1xcclxcblxcclxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXHJcXG5cXHRcXHRcXHRyYWRpdXM6IHJhZGl1cyxcXHJcXG5cXHRcXHRcXHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxcclxcblxcdFxcdFxcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcXHJcXG5cXHRcXHRcXHRwaGlTdGFydDogcGhpU3RhcnQsXFxyXFxuXFx0XFx0XFx0cGhpTGVuZ3RoOiBwaGlMZW5ndGgsXFxyXFxuXFx0XFx0XFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcXHJcXG5cXHRcXHRcXHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdFxcdHJhZGl1cyA9IHJhZGl1cyB8fCAxO1xcclxcblxcclxcblxcdFxcdHdpZHRoU2VnbWVudHMgPSBNYXRoLm1heCggMywgTWF0aC5mbG9vciggd2lkdGhTZWdtZW50cyApIHx8IDggKTtcXHJcXG5cXHRcXHRoZWlnaHRTZWdtZW50cyA9IE1hdGgubWF4KCAyLCBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApIHx8IDYgKTtcXHJcXG5cXHJcXG5cXHRcXHRwaGlTdGFydCA9IHBoaVN0YXJ0ICE9PSB1bmRlZmluZWQgPyBwaGlTdGFydCA6IDA7XFxyXFxuXFx0XFx0cGhpTGVuZ3RoID0gcGhpTGVuZ3RoICE9PSB1bmRlZmluZWQgPyBwaGlMZW5ndGggOiBNYXRoLlBJICogMjtcXHJcXG5cXHJcXG5cXHRcXHR0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDA7XFxyXFxuXFx0XFx0dGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiBNYXRoLlBJO1xcclxcblxcclxcblxcdFxcdHZhciB0aGV0YUVuZCA9IHRoZXRhU3RhcnQgKyB0aGV0YUxlbmd0aDtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgaXgsIGl5O1xcclxcblxcclxcblxcdFxcdHZhciBpbmRleCA9IDA7XFxyXFxuXFx0XFx0dmFyIGdyaWQgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHRcXHR2YXIgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBidWZmZXJzXFxyXFxuXFxyXFxuXFx0XFx0dmFyIGluZGljZXMgPSBbXTtcXHJcXG5cXHRcXHR2YXIgdmVydGljZXMgPSBbXTtcXHJcXG5cXHRcXHR2YXIgbm9ybWFscyA9IFtdO1xcclxcblxcdFxcdHZhciB1dnMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXFxyXFxuXFxyXFxuXFx0XFx0Zm9yICggaXkgPSAwOyBpeSA8PSBoZWlnaHRTZWdtZW50czsgaXkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHZlcnRpY2VzUm93ID0gW107XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHYgPSBpeSAvIGhlaWdodFNlZ21lbnRzO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIGl4ID0gMDsgaXggPD0gd2lkdGhTZWdtZW50czsgaXggKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHUgPSBpeCAvIHdpZHRoU2VnbWVudHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gdmVydGV4XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmVydGV4LnggPSAtIHJhZGl1cyAqIE1hdGguY29zKCBwaGlTdGFydCArIHUgKiBwaGlMZW5ndGggKSAqIE1hdGguc2luKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XFxyXFxuXFx0XFx0XFx0XFx0dmVydGV4LnkgPSByYWRpdXMgKiBNYXRoLmNvcyggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xcclxcblxcdFxcdFxcdFxcdHZlcnRleC56ID0gcmFkaXVzICogTWF0aC5zaW4oIHBoaVN0YXJ0ICsgdSAqIHBoaUxlbmd0aCApICogTWF0aC5zaW4oIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gbm9ybWFsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bm9ybWFsLnNldCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApLm5vcm1hbGl6ZSgpO1xcclxcblxcdFxcdFxcdFxcdG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIHV2XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dXZzLnB1c2goIHUsIDEgLSB2ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmVydGljZXNSb3cucHVzaCggaW5kZXggKysgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Z3JpZC5wdXNoKCB2ZXJ0aWNlc1JvdyApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHQvLyBpbmRpY2VzXFxyXFxuXFxyXFxuXFx0XFx0Zm9yICggaXkgPSAwOyBpeSA8IGhlaWdodFNlZ21lbnRzOyBpeSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCBpeCA9IDA7IGl4IDwgd2lkdGhTZWdtZW50czsgaXggKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGEgPSBncmlkWyBpeSBdWyBpeCArIDEgXTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgYiA9IGdyaWRbIGl5IF1bIGl4IF07XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGMgPSBncmlkWyBpeSArIDEgXVsgaXggXTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgZCA9IGdyaWRbIGl5ICsgMSBdWyBpeCArIDEgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGl5ICE9PSAwIHx8IHRoZXRhU3RhcnQgPiAwICkgaW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBpeSAhPT0gaGVpZ2h0U2VnbWVudHMgLSAxIHx8IHRoZXRhRW5kIDwgTWF0aC5QSSApIGluZGljZXMucHVzaCggYiwgYywgZCApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0Ly8gYnVpbGQgZ2VvbWV0cnlcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XFxyXFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XFxyXFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XFxyXFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRTcGhlcmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcXHJcXG5cXHRTcGhlcmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcGhlcmVCdWZmZXJHZW9tZXRyeTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIEthbGViIE11cnBoeVxcclxcblxcdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0Ly8gUmluZ0dlb21ldHJ5XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gUmluZ0dlb21ldHJ5KCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIHRoZXRhU2VnbWVudHMsIHBoaVNlZ21lbnRzLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcXHJcXG5cXHJcXG5cXHRcXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50eXBlID0gJ1JpbmdHZW9tZXRyeSc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcclxcblxcdFxcdFxcdGlubmVyUmFkaXVzOiBpbm5lclJhZGl1cyxcXHJcXG5cXHRcXHRcXHRvdXRlclJhZGl1czogb3V0ZXJSYWRpdXMsXFxyXFxuXFx0XFx0XFx0dGhldGFTZWdtZW50czogdGhldGFTZWdtZW50cyxcXHJcXG5cXHRcXHRcXHRwaGlTZWdtZW50czogcGhpU2VnbWVudHMsXFxyXFxuXFx0XFx0XFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcXHJcXG5cXHRcXHRcXHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdFxcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgUmluZ0J1ZmZlckdlb21ldHJ5KCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIHRoZXRhU2VnbWVudHMsIHBoaVNlZ21lbnRzLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApICk7XFxyXFxuXFx0XFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdFJpbmdHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcXHJcXG5cXHRSaW5nR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmluZ0dlb21ldHJ5O1xcclxcblxcclxcblxcdC8vIFJpbmdCdWZmZXJHZW9tZXRyeVxcclxcblxcclxcblxcdGZ1bmN0aW9uIFJpbmdCdWZmZXJHZW9tZXRyeSggaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCB0aGV0YVNlZ21lbnRzLCBwaGlTZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XFxyXFxuXFxyXFxuXFx0XFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdSaW5nQnVmZmVyR2VvbWV0cnknO1xcclxcblxcclxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXHJcXG5cXHRcXHRcXHRpbm5lclJhZGl1czogaW5uZXJSYWRpdXMsXFxyXFxuXFx0XFx0XFx0b3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzLFxcclxcblxcdFxcdFxcdHRoZXRhU2VnbWVudHM6IHRoZXRhU2VnbWVudHMsXFxyXFxuXFx0XFx0XFx0cGhpU2VnbWVudHM6IHBoaVNlZ21lbnRzLFxcclxcblxcdFxcdFxcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXFxyXFxuXFx0XFx0XFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHRpbm5lclJhZGl1cyA9IGlubmVyUmFkaXVzIHx8IDAuNTtcXHJcXG5cXHRcXHRvdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzIHx8IDE7XFxyXFxuXFxyXFxuXFx0XFx0dGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xcclxcblxcdFxcdHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogTWF0aC5QSSAqIDI7XFxyXFxuXFxyXFxuXFx0XFx0dGhldGFTZWdtZW50cyA9IHRoZXRhU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IE1hdGgubWF4KCAzLCB0aGV0YVNlZ21lbnRzICkgOiA4O1xcclxcblxcdFxcdHBoaVNlZ21lbnRzID0gcGhpU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IE1hdGgubWF4KCAxLCBwaGlTZWdtZW50cyApIDogMTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBidWZmZXJzXFxyXFxuXFxyXFxuXFx0XFx0dmFyIGluZGljZXMgPSBbXTtcXHJcXG5cXHRcXHR2YXIgdmVydGljZXMgPSBbXTtcXHJcXG5cXHRcXHR2YXIgbm9ybWFscyA9IFtdO1xcclxcblxcdFxcdHZhciB1dnMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBzb21lIGhlbHBlciB2YXJpYWJsZXNcXHJcXG5cXHJcXG5cXHRcXHR2YXIgc2VnbWVudDtcXHJcXG5cXHRcXHR2YXIgcmFkaXVzID0gaW5uZXJSYWRpdXM7XFxyXFxuXFx0XFx0dmFyIHJhZGl1c1N0ZXAgPSAoICggb3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cyApIC8gcGhpU2VnbWVudHMgKTtcXHJcXG5cXHRcXHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHRcXHR2YXIgdXYgPSBuZXcgVmVjdG9yMigpO1xcclxcblxcdFxcdHZhciBqLCBpO1xcclxcblxcclxcblxcdFxcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcXHJcXG5cXHJcXG5cXHRcXHRmb3IgKCBqID0gMDsgaiA8PSBwaGlTZWdtZW50czsgaiArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCBpID0gMDsgaSA8PSB0aGV0YVNlZ21lbnRzOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIHZhbHVlcyBhcmUgZ2VuZXJhdGUgZnJvbSB0aGUgaW5zaWRlIG9mIHRoZSByaW5nIHRvIHRoZSBvdXRzaWRlXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0c2VnbWVudCA9IHRoZXRhU3RhcnQgKyBpIC8gdGhldGFTZWdtZW50cyAqIHRoZXRhTGVuZ3RoO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIHZlcnRleFxcclxcblxcclxcblxcdFxcdFxcdFxcdHZlcnRleC54ID0gcmFkaXVzICogTWF0aC5jb3MoIHNlZ21lbnQgKTtcXHJcXG5cXHRcXHRcXHRcXHR2ZXJ0ZXgueSA9IHJhZGl1cyAqIE1hdGguc2luKCBzZWdtZW50ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIG5vcm1hbFxcclxcblxcclxcblxcdFxcdFxcdFxcdG5vcm1hbHMucHVzaCggMCwgMCwgMSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIHV2XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dXYueCA9ICggdmVydGV4LnggLyBvdXRlclJhZGl1cyArIDEgKSAvIDI7XFxyXFxuXFx0XFx0XFx0XFx0dXYueSA9ICggdmVydGV4LnkgLyBvdXRlclJhZGl1cyArIDEgKSAvIDI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dXZzLnB1c2goIHV2LngsIHV2LnkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gaW5jcmVhc2UgdGhlIHJhZGl1cyBmb3IgbmV4dCByb3cgb2YgdmVydGljZXNcXHJcXG5cXHJcXG5cXHRcXHRcXHRyYWRpdXMgKz0gcmFkaXVzU3RlcDtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0Ly8gaW5kaWNlc1xcclxcblxcclxcblxcdFxcdGZvciAoIGogPSAwOyBqIDwgcGhpU2VnbWVudHM7IGogKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHRoZXRhU2VnbWVudExldmVsID0gaiAqICggdGhldGFTZWdtZW50cyArIDEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCBpID0gMDsgaSA8IHRoZXRhU2VnbWVudHM7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0c2VnbWVudCA9IGkgKyB0aGV0YVNlZ21lbnRMZXZlbDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgYSA9IHNlZ21lbnQ7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGIgPSBzZWdtZW50ICsgdGhldGFTZWdtZW50cyArIDE7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGMgPSBzZWdtZW50ICsgdGhldGFTZWdtZW50cyArIDI7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGQgPSBzZWdtZW50ICsgMTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBmYWNlc1xcclxcblxcclxcblxcdFxcdFxcdFxcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xcclxcblxcdFxcdFxcdFxcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0Ly8gYnVpbGQgZ2VvbWV0cnlcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XFxyXFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XFxyXFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XFxyXFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRSaW5nQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XFxyXFxuXFx0UmluZ0J1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJpbmdCdWZmZXJHZW9tZXRyeTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIGFzdHJvZHVkIC8gaHR0cDovL2FzdHJvZHVkLmlzZ3JlYXQub3JnL1xcclxcblxcdCAqIEBhdXRob3Igeno4NSAvIGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1XFxyXFxuXFx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xcclxcblxcdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0Ly8gTGF0aGVHZW9tZXRyeVxcclxcblxcclxcblxcdGZ1bmN0aW9uIExhdGhlR2VvbWV0cnkoIHBvaW50cywgc2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGggKSB7XFxyXFxuXFxyXFxuXFx0XFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdMYXRoZUdlb21ldHJ5JztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxyXFxuXFx0XFx0XFx0cG9pbnRzOiBwb2ludHMsXFxyXFxuXFx0XFx0XFx0c2VnbWVudHM6IHNlZ21lbnRzLFxcclxcblxcdFxcdFxcdHBoaVN0YXJ0OiBwaGlTdGFydCxcXHJcXG5cXHRcXHRcXHRwaGlMZW5ndGg6IHBoaUxlbmd0aFxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBMYXRoZUJ1ZmZlckdlb21ldHJ5KCBwb2ludHMsIHNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoICkgKTtcXHJcXG5cXHRcXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0TGF0aGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcXHJcXG5cXHRMYXRoZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExhdGhlR2VvbWV0cnk7XFxyXFxuXFxyXFxuXFx0Ly8gTGF0aGVCdWZmZXJHZW9tZXRyeVxcclxcblxcclxcblxcdGZ1bmN0aW9uIExhdGhlQnVmZmVyR2VvbWV0cnkoIHBvaW50cywgc2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGggKSB7XFxyXFxuXFxyXFxuXFx0XFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdMYXRoZUJ1ZmZlckdlb21ldHJ5JztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxyXFxuXFx0XFx0XFx0cG9pbnRzOiBwb2ludHMsXFxyXFxuXFx0XFx0XFx0c2VnbWVudHM6IHNlZ21lbnRzLFxcclxcblxcdFxcdFxcdHBoaVN0YXJ0OiBwaGlTdGFydCxcXHJcXG5cXHRcXHRcXHRwaGlMZW5ndGg6IHBoaUxlbmd0aFxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0c2VnbWVudHMgPSBNYXRoLmZsb29yKCBzZWdtZW50cyApIHx8IDEyO1xcclxcblxcdFxcdHBoaVN0YXJ0ID0gcGhpU3RhcnQgfHwgMDtcXHJcXG5cXHRcXHRwaGlMZW5ndGggPSBwaGlMZW5ndGggfHwgTWF0aC5QSSAqIDI7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gY2xhbXAgcGhpTGVuZ3RoIHNvIGl0J3MgaW4gcmFuZ2Ugb2YgWyAwLCAyUEkgXVxcclxcblxcclxcblxcdFxcdHBoaUxlbmd0aCA9IF9NYXRoLmNsYW1wKCBwaGlMZW5ndGgsIDAsIE1hdGguUEkgKiAyICk7XFxyXFxuXFxyXFxuXFxyXFxuXFx0XFx0Ly8gYnVmZmVyc1xcclxcblxcclxcblxcdFxcdHZhciBpbmRpY2VzID0gW107XFxyXFxuXFx0XFx0dmFyIHZlcnRpY2VzID0gW107XFxyXFxuXFx0XFx0dmFyIHV2cyA9IFtdO1xcclxcblxcclxcblxcdFxcdC8vIGhlbHBlciB2YXJpYWJsZXNcXHJcXG5cXHJcXG5cXHRcXHR2YXIgYmFzZTtcXHJcXG5cXHRcXHR2YXIgaW52ZXJzZVNlZ21lbnRzID0gMS4wIC8gc2VnbWVudHM7XFxyXFxuXFx0XFx0dmFyIHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0dmFyIHV2ID0gbmV3IFZlY3RvcjIoKTtcXHJcXG5cXHRcXHR2YXIgaSwgajtcXHJcXG5cXHJcXG5cXHRcXHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcyBhbmQgdXZzXFxyXFxuXFxyXFxuXFx0XFx0Zm9yICggaSA9IDA7IGkgPD0gc2VnbWVudHM7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHBoaSA9IHBoaVN0YXJ0ICsgaSAqIGludmVyc2VTZWdtZW50cyAqIHBoaUxlbmd0aDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgc2luID0gTWF0aC5zaW4oIHBoaSApO1xcclxcblxcdFxcdFxcdHZhciBjb3MgPSBNYXRoLmNvcyggcGhpICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggaiA9IDA7IGogPD0gKCBwb2ludHMubGVuZ3RoIC0gMSApOyBqICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIHZlcnRleFxcclxcblxcclxcblxcdFxcdFxcdFxcdHZlcnRleC54ID0gcG9pbnRzWyBqIF0ueCAqIHNpbjtcXHJcXG5cXHRcXHRcXHRcXHR2ZXJ0ZXgueSA9IHBvaW50c1sgaiBdLnk7XFxyXFxuXFx0XFx0XFx0XFx0dmVydGV4LnogPSBwb2ludHNbIGogXS54ICogY29zO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyB1dlxcclxcblxcclxcblxcdFxcdFxcdFxcdHV2LnggPSBpIC8gc2VnbWVudHM7XFxyXFxuXFx0XFx0XFx0XFx0dXYueSA9IGogLyAoIHBvaW50cy5sZW5ndGggLSAxICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dXZzLnB1c2goIHV2LngsIHV2LnkgKTtcXHJcXG5cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdC8vIGluZGljZXNcXHJcXG5cXHJcXG5cXHRcXHRmb3IgKCBpID0gMDsgaSA8IHNlZ21lbnRzOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIGogPSAwOyBqIDwgKCBwb2ludHMubGVuZ3RoIC0gMSApOyBqICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGJhc2UgPSBqICsgaSAqIHBvaW50cy5sZW5ndGg7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGEgPSBiYXNlO1xcclxcblxcdFxcdFxcdFxcdHZhciBiID0gYmFzZSArIHBvaW50cy5sZW5ndGg7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGMgPSBiYXNlICsgcG9pbnRzLmxlbmd0aCArIDE7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGQgPSBiYXNlICsgMTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBmYWNlc1xcclxcblxcclxcblxcdFxcdFxcdFxcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xcclxcblxcdFxcdFxcdFxcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0Ly8gYnVpbGQgZ2VvbWV0cnlcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XFxyXFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XFxyXFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xcclxcblxcclxcblxcdFxcdC8vIGdlbmVyYXRlIG5vcm1hbHNcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gaWYgdGhlIGdlb21ldHJ5IGlzIGNsb3NlZCwgd2UgbmVlZCB0byBhdmVyYWdlIHRoZSBub3JtYWxzIGFsb25nIHRoZSBzZWFtLlxcclxcblxcdFxcdC8vIGJlY2F1c2UgdGhlIGNvcnJlc3BvbmRpbmcgdmVydGljZXMgYXJlIGlkZW50aWNhbCAoYnV0IHN0aWxsIGhhdmUgZGlmZmVyZW50IFVWcykuXFxyXFxuXFxyXFxuXFx0XFx0aWYgKCBwaGlMZW5ndGggPT09IE1hdGguUEkgKiAyICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBub3JtYWxzID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcXHJcXG5cXHRcXHRcXHR2YXIgbjEgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdFxcdHZhciBuMiA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0XFx0dmFyIG4gPSBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdFxcdFxcdC8vIHRoaXMgaXMgdGhlIGJ1ZmZlciBvZmZzZXQgZm9yIHRoZSBsYXN0IGxpbmUgb2YgdmVydGljZXNcXHJcXG5cXHJcXG5cXHRcXHRcXHRiYXNlID0gc2VnbWVudHMgKiBwb2ludHMubGVuZ3RoICogMztcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCBpID0gMCwgaiA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpICsrLCBqICs9IDMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gc2VsZWN0IHRoZSBub3JtYWwgb2YgdGhlIHZlcnRleCBpbiB0aGUgZmlyc3QgbGluZVxcclxcblxcclxcblxcdFxcdFxcdFxcdG4xLnggPSBub3JtYWxzWyBqICsgMCBdO1xcclxcblxcdFxcdFxcdFxcdG4xLnkgPSBub3JtYWxzWyBqICsgMSBdO1xcclxcblxcdFxcdFxcdFxcdG4xLnogPSBub3JtYWxzWyBqICsgMiBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIHNlbGVjdCB0aGUgbm9ybWFsIG9mIHRoZSB2ZXJ0ZXggaW4gdGhlIGxhc3QgbGluZVxcclxcblxcclxcblxcdFxcdFxcdFxcdG4yLnggPSBub3JtYWxzWyBiYXNlICsgaiArIDAgXTtcXHJcXG5cXHRcXHRcXHRcXHRuMi55ID0gbm9ybWFsc1sgYmFzZSArIGogKyAxIF07XFxyXFxuXFx0XFx0XFx0XFx0bjIueiA9IG5vcm1hbHNbIGJhc2UgKyBqICsgMiBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGF2ZXJhZ2Ugbm9ybWFsc1xcclxcblxcclxcblxcdFxcdFxcdFxcdG4uYWRkVmVjdG9ycyggbjEsIG4yICkubm9ybWFsaXplKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gYXNzaWduIHRoZSBuZXcgdmFsdWVzIHRvIGJvdGggbm9ybWFsc1xcclxcblxcclxcblxcdFxcdFxcdFxcdG5vcm1hbHNbIGogKyAwIF0gPSBub3JtYWxzWyBiYXNlICsgaiArIDAgXSA9IG4ueDtcXHJcXG5cXHRcXHRcXHRcXHRub3JtYWxzWyBqICsgMSBdID0gbm9ybWFsc1sgYmFzZSArIGogKyAxIF0gPSBuLnk7XFxyXFxuXFx0XFx0XFx0XFx0bm9ybWFsc1sgaiArIDIgXSA9IG5vcm1hbHNbIGJhc2UgKyBqICsgMiBdID0gbi56O1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdExhdGhlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XFxyXFxuXFx0TGF0aGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMYXRoZUJ1ZmZlckdlb21ldHJ5O1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3Igam9ub2JyMSAvIGh0dHA6Ly9qb25vYnIxLmNvbVxcclxcblxcdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0Ly8gU2hhcGVHZW9tZXRyeVxcclxcblxcclxcblxcdGZ1bmN0aW9uIFNoYXBlR2VvbWV0cnkoIHNoYXBlcywgY3VydmVTZWdtZW50cyApIHtcXHJcXG5cXHJcXG5cXHRcXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50eXBlID0gJ1NoYXBlR2VvbWV0cnknO1xcclxcblxcclxcblxcdFxcdGlmICggdHlwZW9mIGN1cnZlU2VnbWVudHMgPT09ICdvYmplY3QnICkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNoYXBlR2VvbWV0cnk6IE9wdGlvbnMgcGFyYW1ldGVyIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcclxcblxcclxcblxcdFxcdFxcdGN1cnZlU2VnbWVudHMgPSBjdXJ2ZVNlZ21lbnRzLmN1cnZlU2VnbWVudHM7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXHJcXG5cXHRcXHRcXHRzaGFwZXM6IHNoYXBlcyxcXHJcXG5cXHRcXHRcXHRjdXJ2ZVNlZ21lbnRzOiBjdXJ2ZVNlZ21lbnRzXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IFNoYXBlQnVmZmVyR2VvbWV0cnkoIHNoYXBlcywgY3VydmVTZWdtZW50cyApICk7XFxyXFxuXFx0XFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdFNoYXBlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XFxyXFxuXFx0U2hhcGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTaGFwZUdlb21ldHJ5O1xcclxcblxcclxcblxcdFNoYXBlR2VvbWV0cnkucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgZGF0YSA9IEdlb21ldHJ5LnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHZhciBzaGFwZXMgPSB0aGlzLnBhcmFtZXRlcnMuc2hhcGVzO1xcclxcblxcclxcblxcdFxcdHJldHVybiB0b0pTT04oIHNoYXBlcywgZGF0YSApO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0Ly8gU2hhcGVCdWZmZXJHZW9tZXRyeVxcclxcblxcclxcblxcdGZ1bmN0aW9uIFNoYXBlQnVmZmVyR2VvbWV0cnkoIHNoYXBlcywgY3VydmVTZWdtZW50cyApIHtcXHJcXG5cXHJcXG5cXHRcXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50eXBlID0gJ1NoYXBlQnVmZmVyR2VvbWV0cnknO1xcclxcblxcclxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXHJcXG5cXHRcXHRcXHRzaGFwZXM6IHNoYXBlcyxcXHJcXG5cXHRcXHRcXHRjdXJ2ZVNlZ21lbnRzOiBjdXJ2ZVNlZ21lbnRzXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHRjdXJ2ZVNlZ21lbnRzID0gY3VydmVTZWdtZW50cyB8fCAxMjtcXHJcXG5cXHJcXG5cXHRcXHQvLyBidWZmZXJzXFxyXFxuXFxyXFxuXFx0XFx0dmFyIGluZGljZXMgPSBbXTtcXHJcXG5cXHRcXHR2YXIgdmVydGljZXMgPSBbXTtcXHJcXG5cXHRcXHR2YXIgbm9ybWFscyA9IFtdO1xcclxcblxcdFxcdHZhciB1dnMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBoZWxwZXIgdmFyaWFibGVzXFxyXFxuXFxyXFxuXFx0XFx0dmFyIGdyb3VwU3RhcnQgPSAwO1xcclxcblxcdFxcdHZhciBncm91cENvdW50ID0gMDtcXHJcXG5cXHJcXG5cXHRcXHQvLyBhbGxvdyBzaW5nbGUgYW5kIGFycmF5IHZhbHVlcyBmb3IgXFxcInNoYXBlc1xcXCIgcGFyYW1ldGVyXFxyXFxuXFxyXFxuXFx0XFx0aWYgKCBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSA9PT0gZmFsc2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0YWRkU2hhcGUoIHNoYXBlcyApO1xcclxcblxcclxcblxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgc2hhcGVzLmxlbmd0aDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRhZGRTaGFwZSggc2hhcGVzWyBpIF0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmFkZEdyb3VwKCBncm91cFN0YXJ0LCBncm91cENvdW50LCBpICk7IC8vIGVuYWJsZXMgTXVsdGlNYXRlcmlhbCBzdXBwb3J0XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Z3JvdXBTdGFydCArPSBncm91cENvdW50O1xcclxcblxcdFxcdFxcdFxcdGdyb3VwQ291bnQgPSAwO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0Ly8gYnVpbGQgZ2VvbWV0cnlcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XFxyXFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XFxyXFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XFxyXFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xcclxcblxcclxcblxcclxcblxcdFxcdC8vIGhlbHBlciBmdW5jdGlvbnNcXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBhZGRTaGFwZSggc2hhcGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGksIGwsIHNoYXBlSG9sZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgaW5kZXhPZmZzZXQgPSB2ZXJ0aWNlcy5sZW5ndGggLyAzO1xcclxcblxcdFxcdFxcdHZhciBwb2ludHMgPSBzaGFwZS5leHRyYWN0UG9pbnRzKCBjdXJ2ZVNlZ21lbnRzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHNoYXBlVmVydGljZXMgPSBwb2ludHMuc2hhcGU7XFxyXFxuXFx0XFx0XFx0dmFyIHNoYXBlSG9sZXMgPSBwb2ludHMuaG9sZXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gY2hlY2sgZGlyZWN0aW9uIG9mIHZlcnRpY2VzXFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKCBzaGFwZVZlcnRpY2VzICkgPT09IGZhbHNlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHNoYXBlVmVydGljZXMgPSBzaGFwZVZlcnRpY2VzLnJldmVyc2UoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBhbHNvIGNoZWNrIGlmIGhvbGVzIGFyZSBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggaSA9IDAsIGwgPSBzaGFwZUhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0c2hhcGVIb2xlID0gc2hhcGVIb2xlc1sgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggc2hhcGVIb2xlICkgPT09IHRydWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0c2hhcGVIb2xlc1sgaSBdID0gc2hhcGVIb2xlLnJldmVyc2UoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgZmFjZXMgPSBTaGFwZVV0aWxzLnRyaWFuZ3VsYXRlU2hhcGUoIHNoYXBlVmVydGljZXMsIHNoYXBlSG9sZXMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBqb2luIHZlcnRpY2VzIG9mIGlubmVyIGFuZCBvdXRlciBwYXRocyB0byBhIHNpbmdsZSBhcnJheVxcclxcblxcclxcblxcdFxcdFxcdGZvciAoIGkgPSAwLCBsID0gc2hhcGVIb2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHNoYXBlSG9sZSA9IHNoYXBlSG9sZXNbIGkgXTtcXHJcXG5cXHRcXHRcXHRcXHRzaGFwZVZlcnRpY2VzID0gc2hhcGVWZXJ0aWNlcy5jb25jYXQoIHNoYXBlSG9sZSApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyB2ZXJ0aWNlcywgbm9ybWFscywgdXZzXFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggaSA9IDAsIGwgPSBzaGFwZVZlcnRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHZlcnRleCA9IHNoYXBlVmVydGljZXNbIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIDAgKTtcXHJcXG5cXHRcXHRcXHRcXHRub3JtYWxzLnB1c2goIDAsIDAsIDEgKTtcXHJcXG5cXHRcXHRcXHRcXHR1dnMucHVzaCggdmVydGV4LngsIHZlcnRleC55ICk7IC8vIHdvcmxkIHV2c1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBpbmNpZGVzXFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgYSA9IGZhY2VbIDAgXSArIGluZGV4T2Zmc2V0O1xcclxcblxcdFxcdFxcdFxcdHZhciBiID0gZmFjZVsgMSBdICsgaW5kZXhPZmZzZXQ7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGMgPSBmYWNlWyAyIF0gKyBpbmRleE9mZnNldDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpbmRpY2VzLnB1c2goIGEsIGIsIGMgKTtcXHJcXG5cXHRcXHRcXHRcXHRncm91cENvdW50ICs9IDM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0U2hhcGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcXHJcXG5cXHRTaGFwZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNoYXBlQnVmZmVyR2VvbWV0cnk7XFxyXFxuXFxyXFxuXFx0U2hhcGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdHZhciBkYXRhID0gQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHNoYXBlcyA9IHRoaXMucGFyYW1ldGVycy5zaGFwZXM7XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHRvSlNPTiggc2hhcGVzLCBkYXRhICk7XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHQvL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIHRvSlNPTiggc2hhcGVzLCBkYXRhICkge1xcclxcblxcclxcblxcdFxcdGRhdGEuc2hhcGVzID0gW107XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzaGFwZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgc2hhcGUgPSBzaGFwZXNbIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRkYXRhLnNoYXBlcy5wdXNoKCBzaGFwZS51dWlkICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZGF0YS5zaGFwZXMucHVzaCggc2hhcGVzLnV1aWQgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIGRhdGE7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxcclxcblxcdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gRWRnZXNHZW9tZXRyeSggZ2VvbWV0cnksIHRocmVzaG9sZEFuZ2xlICkge1xcclxcblxcclxcblxcdFxcdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnRWRnZXNHZW9tZXRyeSc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcclxcblxcdFxcdFxcdHRocmVzaG9sZEFuZ2xlOiB0aHJlc2hvbGRBbmdsZVxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0dGhyZXNob2xkQW5nbGUgPSAoIHRocmVzaG9sZEFuZ2xlICE9PSB1bmRlZmluZWQgKSA/IHRocmVzaG9sZEFuZ2xlIDogMTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBidWZmZXJcXHJcXG5cXHJcXG5cXHRcXHR2YXIgdmVydGljZXMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBoZWxwZXIgdmFyaWFibGVzXFxyXFxuXFxyXFxuXFx0XFx0dmFyIHRocmVzaG9sZERvdCA9IE1hdGguY29zKCBfTWF0aC5ERUcyUkFEICogdGhyZXNob2xkQW5nbGUgKTtcXHJcXG5cXHRcXHR2YXIgZWRnZSA9IFsgMCwgMCBdLCBlZGdlcyA9IHt9LCBlZGdlMSwgZWRnZTI7XFxyXFxuXFx0XFx0dmFyIGtleSwga2V5cyA9IFsgJ2EnLCAnYicsICdjJyBdO1xcclxcblxcclxcblxcdFxcdC8vIHByZXBhcmUgc291cmNlIGdlb21ldHJ5XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGdlb21ldHJ5MjtcXHJcXG5cXHJcXG5cXHRcXHRpZiAoIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Z2VvbWV0cnkyID0gbmV3IEdlb21ldHJ5KCk7XFxyXFxuXFx0XFx0XFx0Z2VvbWV0cnkyLmZyb21CdWZmZXJHZW9tZXRyeSggZ2VvbWV0cnkgKTtcXHJcXG5cXHJcXG5cXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdGdlb21ldHJ5MiA9IGdlb21ldHJ5LmNsb25lKCk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGdlb21ldHJ5Mi5tZXJnZVZlcnRpY2VzKCk7XFxyXFxuXFx0XFx0Z2VvbWV0cnkyLmNvbXB1dGVGYWNlTm9ybWFscygpO1xcclxcblxcclxcblxcdFxcdHZhciBzb3VyY2VWZXJ0aWNlcyA9IGdlb21ldHJ5Mi52ZXJ0aWNlcztcXHJcXG5cXHRcXHR2YXIgZmFjZXMgPSBnZW9tZXRyeTIuZmFjZXM7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gbm93IGNyZWF0ZSBhIGRhdGEgc3RydWN0dXJlIHdoZXJlIGVhY2ggZW50cnkgcmVwcmVzZW50cyBhbiBlZGdlIHdpdGggaXRzIGFkam9pbmluZyBmYWNlc1xcclxcblxcclxcblxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBqID0gMDsgaiA8IDM7IGogKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZWRnZTEgPSBmYWNlWyBrZXlzWyBqIF0gXTtcXHJcXG5cXHRcXHRcXHRcXHRlZGdlMiA9IGZhY2VbIGtleXNbICggaiArIDEgKSAlIDMgXSBdO1xcclxcblxcdFxcdFxcdFxcdGVkZ2VbIDAgXSA9IE1hdGgubWluKCBlZGdlMSwgZWRnZTIgKTtcXHJcXG5cXHRcXHRcXHRcXHRlZGdlWyAxIF0gPSBNYXRoLm1heCggZWRnZTEsIGVkZ2UyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0a2V5ID0gZWRnZVsgMCBdICsgJywnICsgZWRnZVsgMSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggZWRnZXNbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0ZWRnZXNbIGtleSBdID0geyBpbmRleDE6IGVkZ2VbIDAgXSwgaW5kZXgyOiBlZGdlWyAxIF0sIGZhY2UxOiBpLCBmYWNlMjogdW5kZWZpbmVkIH07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRlZGdlc1sga2V5IF0uZmFjZTIgPSBpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdC8vIGdlbmVyYXRlIHZlcnRpY2VzXFxyXFxuXFxyXFxuXFx0XFx0Zm9yICgga2V5IGluIGVkZ2VzICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBlID0gZWRnZXNbIGtleSBdO1xcclxcblxcclxcblxcdFxcdFxcdC8vIGFuIGVkZ2UgaXMgb25seSByZW5kZXJlZCBpZiB0aGUgYW5nbGUgKGluIGRlZ3JlZXMpIGJldHdlZW4gdGhlIGZhY2Ugbm9ybWFscyBvZiB0aGUgYWRqb2luaW5nIGZhY2VzIGV4Y2VlZHMgdGhpcyB2YWx1ZS4gZGVmYXVsdCA9IDEgZGVncmVlLlxcclxcblxcclxcblxcdFxcdFxcdGlmICggZS5mYWNlMiA9PT0gdW5kZWZpbmVkIHx8IGZhY2VzWyBlLmZhY2UxIF0ubm9ybWFsLmRvdCggZmFjZXNbIGUuZmFjZTIgXS5ub3JtYWwgKSA8PSB0aHJlc2hvbGREb3QgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHZlcnRleCA9IHNvdXJjZVZlcnRpY2VzWyBlLmluZGV4MSBdO1xcclxcblxcdFxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2ZXJ0ZXggPSBzb3VyY2VWZXJ0aWNlc1sgZS5pbmRleDIgXTtcXHJcXG5cXHRcXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHQvLyBidWlsZCBnZW9tZXRyeVxcclxcblxcclxcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRFZGdlc0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xcclxcblxcdEVkZ2VzR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRWRnZXNHZW9tZXRyeTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0Ly8gQ3lsaW5kZXJHZW9tZXRyeVxcclxcblxcclxcblxcdGZ1bmN0aW9uIEN5bGluZGVyR2VvbWV0cnkoIHJhZGl1c1RvcCwgcmFkaXVzQm90dG9tLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcXHJcXG5cXHJcXG5cXHRcXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50eXBlID0gJ0N5bGluZGVyR2VvbWV0cnknO1xcclxcblxcclxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXHJcXG5cXHRcXHRcXHRyYWRpdXNUb3A6IHJhZGl1c1RvcCxcXHJcXG5cXHRcXHRcXHRyYWRpdXNCb3R0b206IHJhZGl1c0JvdHRvbSxcXHJcXG5cXHRcXHRcXHRoZWlnaHQ6IGhlaWdodCxcXHJcXG5cXHRcXHRcXHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXFxyXFxuXFx0XFx0XFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxcclxcblxcdFxcdFxcdG9wZW5FbmRlZDogb3BlbkVuZGVkLFxcclxcblxcdFxcdFxcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXFxyXFxuXFx0XFx0XFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IEN5bGluZGVyQnVmZmVyR2VvbWV0cnkoIHJhZGl1c1RvcCwgcmFkaXVzQm90dG9tLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApICk7XFxyXFxuXFx0XFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdEN5bGluZGVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XFxyXFxuXFx0Q3lsaW5kZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDeWxpbmRlckdlb21ldHJ5O1xcclxcblxcclxcblxcdC8vIEN5bGluZGVyQnVmZmVyR2VvbWV0cnlcXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBDeWxpbmRlckJ1ZmZlckdlb21ldHJ5KCByYWRpdXNUb3AsIHJhZGl1c0JvdHRvbSwgaGVpZ2h0LCByYWRpYWxTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIG9wZW5FbmRlZCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XFxyXFxuXFxyXFxuXFx0XFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdDeWxpbmRlckJ1ZmZlckdlb21ldHJ5JztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxyXFxuXFx0XFx0XFx0cmFkaXVzVG9wOiByYWRpdXNUb3AsXFxyXFxuXFx0XFx0XFx0cmFkaXVzQm90dG9tOiByYWRpdXNCb3R0b20sXFxyXFxuXFx0XFx0XFx0aGVpZ2h0OiBoZWlnaHQsXFxyXFxuXFx0XFx0XFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxcclxcblxcdFxcdFxcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcXHJcXG5cXHRcXHRcXHRvcGVuRW5kZWQ6IG9wZW5FbmRlZCxcXHJcXG5cXHRcXHRcXHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxcclxcblxcdFxcdFxcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHNjb3BlID0gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHRyYWRpdXNUb3AgPSByYWRpdXNUb3AgIT09IHVuZGVmaW5lZCA/IHJhZGl1c1RvcCA6IDE7XFxyXFxuXFx0XFx0cmFkaXVzQm90dG9tID0gcmFkaXVzQm90dG9tICE9PSB1bmRlZmluZWQgPyByYWRpdXNCb3R0b20gOiAxO1xcclxcblxcdFxcdGhlaWdodCA9IGhlaWdodCB8fCAxO1xcclxcblxcclxcblxcdFxcdHJhZGlhbFNlZ21lbnRzID0gTWF0aC5mbG9vciggcmFkaWFsU2VnbWVudHMgKSB8fCA4O1xcclxcblxcdFxcdGhlaWdodFNlZ21lbnRzID0gTWF0aC5mbG9vciggaGVpZ2h0U2VnbWVudHMgKSB8fCAxO1xcclxcblxcclxcblxcdFxcdG9wZW5FbmRlZCA9IG9wZW5FbmRlZCAhPT0gdW5kZWZpbmVkID8gb3BlbkVuZGVkIDogZmFsc2U7XFxyXFxuXFx0XFx0dGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwLjA7XFxyXFxuXFx0XFx0dGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiBNYXRoLlBJICogMjtcXHJcXG5cXHJcXG5cXHRcXHQvLyBidWZmZXJzXFxyXFxuXFxyXFxuXFx0XFx0dmFyIGluZGljZXMgPSBbXTtcXHJcXG5cXHRcXHR2YXIgdmVydGljZXMgPSBbXTtcXHJcXG5cXHRcXHR2YXIgbm9ybWFscyA9IFtdO1xcclxcblxcdFxcdHZhciB1dnMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBoZWxwZXIgdmFyaWFibGVzXFxyXFxuXFxyXFxuXFx0XFx0dmFyIGluZGV4ID0gMDtcXHJcXG5cXHRcXHR2YXIgaW5kZXhBcnJheSA9IFtdO1xcclxcblxcdFxcdHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcXHJcXG5cXHRcXHR2YXIgZ3JvdXBTdGFydCA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gZ2VuZXJhdGUgZ2VvbWV0cnlcXHJcXG5cXHJcXG5cXHRcXHRnZW5lcmF0ZVRvcnNvKCk7XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCBvcGVuRW5kZWQgPT09IGZhbHNlICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggcmFkaXVzVG9wID4gMCApIGdlbmVyYXRlQ2FwKCB0cnVlICk7XFxyXFxuXFx0XFx0XFx0aWYgKCByYWRpdXNCb3R0b20gPiAwICkgZ2VuZXJhdGVDYXAoIGZhbHNlICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdC8vIGJ1aWxkIGdlb21ldHJ5XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xcclxcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xcclxcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xcclxcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBnZW5lcmF0ZVRvcnNvKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB4LCB5O1xcclxcblxcdFxcdFxcdHZhciBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdFxcdHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBncm91cENvdW50ID0gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyB0aGlzIHdpbGwgYmUgdXNlZCB0byBjYWxjdWxhdGUgdGhlIG5vcm1hbFxcclxcblxcdFxcdFxcdHZhciBzbG9wZSA9ICggcmFkaXVzQm90dG9tIC0gcmFkaXVzVG9wICkgLyBoZWlnaHQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHkgPSAwOyB5IDw9IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBpbmRleFJvdyA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciB2ID0geSAvIGhlaWdodFNlZ21lbnRzO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGNhbGN1bGF0ZSB0aGUgcmFkaXVzIG9mIHRoZSBjdXJyZW50IHJvd1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciByYWRpdXMgPSB2ICogKCByYWRpdXNCb3R0b20gLSByYWRpdXNUb3AgKSArIHJhZGl1c1RvcDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB4ID0gMDsgeCA8PSByYWRpYWxTZWdtZW50czsgeCArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdSA9IHggLyByYWRpYWxTZWdtZW50cztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdGhldGEgPSB1ICogdGhldGFMZW5ndGggKyB0aGV0YVN0YXJ0O1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBzaW5UaGV0YSA9IE1hdGguc2luKCB0aGV0YSApO1xcclxcblxcdFxcdFxcdFxcdFxcdHZhciBjb3NUaGV0YSA9IE1hdGguY29zKCB0aGV0YSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIHZlcnRleFxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZlcnRleC54ID0gcmFkaXVzICogc2luVGhldGE7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmVydGV4LnkgPSAtIHYgKiBoZWlnaHQgKyBoYWxmSGVpZ2h0O1xcclxcblxcdFxcdFxcdFxcdFxcdHZlcnRleC56ID0gcmFkaXVzICogY29zVGhldGE7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIG5vcm1hbFxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdG5vcm1hbC5zZXQoIHNpblRoZXRhLCBzbG9wZSwgY29zVGhldGEgKS5ub3JtYWxpemUoKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyB1dlxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHV2cy5wdXNoKCB1LCAxIC0gdiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIHNhdmUgaW5kZXggb2YgdmVydGV4IGluIHJlc3BlY3RpdmUgcm93XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aW5kZXhSb3cucHVzaCggaW5kZXggKysgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gbm93IHNhdmUgdmVydGljZXMgb2YgdGhlIHJvdyBpbiBvdXIgaW5kZXggYXJyYXlcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpbmRleEFycmF5LnB1c2goIGluZGV4Um93ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdC8vIGdlbmVyYXRlIGluZGljZXNcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB4ID0gMDsgeCA8IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIHkgPSAwOyB5IDwgaGVpZ2h0U2VnbWVudHM7IHkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gd2UgdXNlIHRoZSBpbmRleCBhcnJheSB0byBhY2Nlc3MgdGhlIGNvcnJlY3QgaW5kaWNlc1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBhID0gaW5kZXhBcnJheVsgeSBdWyB4IF07XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGIgPSBpbmRleEFycmF5WyB5ICsgMSBdWyB4IF07XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGMgPSBpbmRleEFycmF5WyB5ICsgMSBdWyB4ICsgMSBdO1xcclxcblxcdFxcdFxcdFxcdFxcdHZhciBkID0gaW5kZXhBcnJheVsgeSBdWyB4ICsgMSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIGZhY2VzXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0aW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdXBkYXRlIGdyb3VwIGNvdW50ZXJcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRncm91cENvdW50ICs9IDY7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBhZGQgYSBncm91cCB0byB0aGUgZ2VvbWV0cnkuIHRoaXMgd2lsbCBlbnN1cmUgbXVsdGkgbWF0ZXJpYWwgc3VwcG9ydFxcclxcblxcclxcblxcdFxcdFxcdHNjb3BlLmFkZEdyb3VwKCBncm91cFN0YXJ0LCBncm91cENvdW50LCAwICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gY2FsY3VsYXRlIG5ldyBzdGFydCB2YWx1ZSBmb3IgZ3JvdXBzXFxyXFxuXFxyXFxuXFx0XFx0XFx0Z3JvdXBTdGFydCArPSBncm91cENvdW50O1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBnZW5lcmF0ZUNhcCggdG9wICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB4LCBjZW50ZXJJbmRleFN0YXJ0LCBjZW50ZXJJbmRleEVuZDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdXYgPSBuZXcgVmVjdG9yMigpO1xcclxcblxcdFxcdFxcdHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBncm91cENvdW50ID0gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcmFkaXVzID0gKCB0b3AgPT09IHRydWUgKSA/IHJhZGl1c1RvcCA6IHJhZGl1c0JvdHRvbTtcXHJcXG5cXHRcXHRcXHR2YXIgc2lnbiA9ICggdG9wID09PSB0cnVlICkgPyAxIDogLSAxO1xcclxcblxcclxcblxcdFxcdFxcdC8vIHNhdmUgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjZW50ZXIgdmVydGV4XFxyXFxuXFx0XFx0XFx0Y2VudGVySW5kZXhTdGFydCA9IGluZGV4O1xcclxcblxcclxcblxcdFxcdFxcdC8vIGZpcnN0IHdlIGdlbmVyYXRlIHRoZSBjZW50ZXIgdmVydGV4IGRhdGEgb2YgdGhlIGNhcC5cXHJcXG5cXHRcXHRcXHQvLyBiZWNhdXNlIHRoZSBnZW9tZXRyeSBuZWVkcyBvbmUgc2V0IG9mIHV2cyBwZXIgZmFjZSxcXHJcXG5cXHRcXHRcXHQvLyB3ZSBtdXN0IGdlbmVyYXRlIGEgY2VudGVyIHZlcnRleCBwZXIgZmFjZS9zZWdtZW50XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggeCA9IDE7IHggPD0gcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gdmVydGV4XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmVydGljZXMucHVzaCggMCwgaGFsZkhlaWdodCAqIHNpZ24sIDAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBub3JtYWxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRub3JtYWxzLnB1c2goIDAsIHNpZ24sIDAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyB1dlxcclxcblxcclxcblxcdFxcdFxcdFxcdHV2cy5wdXNoKCAwLjUsIDAuNSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGluY3JlYXNlIGluZGV4XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aW5kZXggKys7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdC8vIHNhdmUgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGNlbnRlciB2ZXJ0ZXhcXHJcXG5cXHJcXG5cXHRcXHRcXHRjZW50ZXJJbmRleEVuZCA9IGluZGV4O1xcclxcblxcclxcblxcdFxcdFxcdC8vIG5vdyB3ZSBnZW5lcmF0ZSB0aGUgc3Vycm91bmRpbmcgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHggPSAwOyB4IDw9IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciB1ID0geCAvIHJhZGlhbFNlZ21lbnRzO1xcclxcblxcdFxcdFxcdFxcdHZhciB0aGV0YSA9IHUgKiB0aGV0YUxlbmd0aCArIHRoZXRhU3RhcnQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGNvc1RoZXRhID0gTWF0aC5jb3MoIHRoZXRhICk7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIHNpblRoZXRhID0gTWF0aC5zaW4oIHRoZXRhICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gdmVydGV4XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmVydGV4LnggPSByYWRpdXMgKiBzaW5UaGV0YTtcXHJcXG5cXHRcXHRcXHRcXHR2ZXJ0ZXgueSA9IGhhbGZIZWlnaHQgKiBzaWduO1xcclxcblxcdFxcdFxcdFxcdHZlcnRleC56ID0gcmFkaXVzICogY29zVGhldGE7XFxyXFxuXFx0XFx0XFx0XFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIG5vcm1hbFxcclxcblxcclxcblxcdFxcdFxcdFxcdG5vcm1hbHMucHVzaCggMCwgc2lnbiwgMCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIHV2XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dXYueCA9ICggY29zVGhldGEgKiAwLjUgKSArIDAuNTtcXHJcXG5cXHRcXHRcXHRcXHR1di55ID0gKCBzaW5UaGV0YSAqIDAuNSAqIHNpZ24gKSArIDAuNTtcXHJcXG5cXHRcXHRcXHRcXHR1dnMucHVzaCggdXYueCwgdXYueSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGluY3JlYXNlIGluZGV4XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aW5kZXggKys7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdC8vIGdlbmVyYXRlIGluZGljZXNcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB4ID0gMDsgeCA8IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBjID0gY2VudGVySW5kZXhTdGFydCArIHg7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGkgPSBjZW50ZXJJbmRleEVuZCArIHg7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB0b3AgPT09IHRydWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gZmFjZSB0b3BcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpbmRpY2VzLnB1c2goIGksIGkgKyAxLCBjICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBmYWNlIGJvdHRvbVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGluZGljZXMucHVzaCggaSArIDEsIGksIGMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Z3JvdXBDb3VudCArPSAzO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBhZGQgYSBncm91cCB0byB0aGUgZ2VvbWV0cnkuIHRoaXMgd2lsbCBlbnN1cmUgbXVsdGkgbWF0ZXJpYWwgc3VwcG9ydFxcclxcblxcclxcblxcdFxcdFxcdHNjb3BlLmFkZEdyb3VwKCBncm91cFN0YXJ0LCBncm91cENvdW50LCB0b3AgPT09IHRydWUgPyAxIDogMiApO1xcclxcblxcclxcblxcdFxcdFxcdC8vIGNhbGN1bGF0ZSBuZXcgc3RhcnQgdmFsdWUgZm9yIGdyb3Vwc1xcclxcblxcclxcblxcdFxcdFxcdGdyb3VwU3RhcnQgKz0gZ3JvdXBDb3VudDtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdEN5bGluZGVyQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XFxyXFxuXFx0Q3lsaW5kZXJCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDeWxpbmRlckJ1ZmZlckdlb21ldHJ5O1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgYWJlbG5hdGlvbiAvIGh0dHA6Ly9naXRodWIuY29tL2FiZWxuYXRpb25cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHQvLyBDb25lR2VvbWV0cnlcXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBDb25lR2VvbWV0cnkoIHJhZGl1cywgaGVpZ2h0LCByYWRpYWxTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIG9wZW5FbmRlZCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XFxyXFxuXFxyXFxuXFx0XFx0Q3lsaW5kZXJHZW9tZXRyeS5jYWxsKCB0aGlzLCAwLCByYWRpdXMsIGhlaWdodCwgcmFkaWFsU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBvcGVuRW5kZWQsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50eXBlID0gJ0NvbmVHZW9tZXRyeSc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcclxcblxcdFxcdFxcdHJhZGl1czogcmFkaXVzLFxcclxcblxcdFxcdFxcdGhlaWdodDogaGVpZ2h0LFxcclxcblxcdFxcdFxcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcXHJcXG5cXHRcXHRcXHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXFxyXFxuXFx0XFx0XFx0b3BlbkVuZGVkOiBvcGVuRW5kZWQsXFxyXFxuXFx0XFx0XFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcXHJcXG5cXHRcXHRcXHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRDb25lR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3lsaW5kZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcXHJcXG5cXHRDb25lR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uZUdlb21ldHJ5O1xcclxcblxcclxcblxcdC8vIENvbmVCdWZmZXJHZW9tZXRyeVxcclxcblxcclxcblxcdGZ1bmN0aW9uIENvbmVCdWZmZXJHZW9tZXRyeSggcmFkaXVzLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcXHJcXG5cXHJcXG5cXHRcXHRDeWxpbmRlckJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMsIDAsIHJhZGl1cywgaGVpZ2h0LCByYWRpYWxTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIG9wZW5FbmRlZCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnQ29uZUJ1ZmZlckdlb21ldHJ5JztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxyXFxuXFx0XFx0XFx0cmFkaXVzOiByYWRpdXMsXFxyXFxuXFx0XFx0XFx0aGVpZ2h0OiBoZWlnaHQsXFxyXFxuXFx0XFx0XFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxcclxcblxcdFxcdFxcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcXHJcXG5cXHRcXHRcXHRvcGVuRW5kZWQ6IG9wZW5FbmRlZCxcXHJcXG5cXHRcXHRcXHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxcclxcblxcdFxcdFxcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdENvbmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDeWxpbmRlckJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xcclxcblxcdENvbmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25lQnVmZmVyR2VvbWV0cnk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXFxyXFxuXFx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcXHJcXG5cXHQgKiBAYXV0aG9yIGh1Z2hlc1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdC8vIENpcmNsZUdlb21ldHJ5XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gQ2lyY2xlR2VvbWV0cnkoIHJhZGl1cywgc2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xcclxcblxcclxcblxcdFxcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnQ2lyY2xlR2VvbWV0cnknO1xcclxcblxcclxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXHJcXG5cXHRcXHRcXHRyYWRpdXM6IHJhZGl1cyxcXHJcXG5cXHRcXHRcXHRzZWdtZW50czogc2VnbWVudHMsXFxyXFxuXFx0XFx0XFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcXHJcXG5cXHRcXHRcXHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdFxcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgQ2lyY2xlQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgc2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkgKTtcXHJcXG5cXHRcXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0Q2lyY2xlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XFxyXFxuXFx0Q2lyY2xlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2lyY2xlR2VvbWV0cnk7XFxyXFxuXFxyXFxuXFx0Ly8gQ2lyY2xlQnVmZmVyR2VvbWV0cnlcXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBDaXJjbGVCdWZmZXJHZW9tZXRyeSggcmFkaXVzLCBzZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XFxyXFxuXFxyXFxuXFx0XFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdDaXJjbGVCdWZmZXJHZW9tZXRyeSc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcclxcblxcdFxcdFxcdHJhZGl1czogcmFkaXVzLFxcclxcblxcdFxcdFxcdHNlZ21lbnRzOiBzZWdtZW50cyxcXHJcXG5cXHRcXHRcXHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxcclxcblxcdFxcdFxcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0cmFkaXVzID0gcmFkaXVzIHx8IDE7XFxyXFxuXFx0XFx0c2VnbWVudHMgPSBzZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gTWF0aC5tYXgoIDMsIHNlZ21lbnRzICkgOiA4O1xcclxcblxcclxcblxcdFxcdHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcXHJcXG5cXHRcXHR0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEkgKiAyO1xcclxcblxcclxcblxcdFxcdC8vIGJ1ZmZlcnNcXHJcXG5cXHJcXG5cXHRcXHR2YXIgaW5kaWNlcyA9IFtdO1xcclxcblxcdFxcdHZhciB2ZXJ0aWNlcyA9IFtdO1xcclxcblxcdFxcdHZhciBub3JtYWxzID0gW107XFxyXFxuXFx0XFx0dmFyIHV2cyA9IFtdO1xcclxcblxcclxcblxcdFxcdC8vIGhlbHBlciB2YXJpYWJsZXNcXHJcXG5cXHJcXG5cXHRcXHR2YXIgaSwgcztcXHJcXG5cXHRcXHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHRcXHR2YXIgdXYgPSBuZXcgVmVjdG9yMigpO1xcclxcblxcclxcblxcdFxcdC8vIGNlbnRlciBwb2ludFxcclxcblxcclxcblxcdFxcdHZlcnRpY2VzLnB1c2goIDAsIDAsIDAgKTtcXHJcXG5cXHRcXHRub3JtYWxzLnB1c2goIDAsIDAsIDEgKTtcXHJcXG5cXHRcXHR1dnMucHVzaCggMC41LCAwLjUgKTtcXHJcXG5cXHJcXG5cXHRcXHRmb3IgKCBzID0gMCwgaSA9IDM7IHMgPD0gc2VnbWVudHM7IHMgKyssIGkgKz0gMyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgc2VnbWVudCA9IHRoZXRhU3RhcnQgKyBzIC8gc2VnbWVudHMgKiB0aGV0YUxlbmd0aDtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyB2ZXJ0ZXhcXHJcXG5cXHJcXG5cXHRcXHRcXHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIE1hdGguY29zKCBzZWdtZW50ICk7XFxyXFxuXFx0XFx0XFx0dmVydGV4LnkgPSByYWRpdXMgKiBNYXRoLnNpbiggc2VnbWVudCApO1xcclxcblxcclxcblxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBub3JtYWxcXHJcXG5cXHJcXG5cXHRcXHRcXHRub3JtYWxzLnB1c2goIDAsIDAsIDEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyB1dnNcXHJcXG5cXHJcXG5cXHRcXHRcXHR1di54ID0gKCB2ZXJ0aWNlc1sgaSBdIC8gcmFkaXVzICsgMSApIC8gMjtcXHJcXG5cXHRcXHRcXHR1di55ID0gKCB2ZXJ0aWNlc1sgaSArIDEgXSAvIHJhZGl1cyArIDEgKSAvIDI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dXZzLnB1c2goIHV2LngsIHV2LnkgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0Ly8gaW5kaWNlc1xcclxcblxcclxcblxcdFxcdGZvciAoIGkgPSAxOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdGluZGljZXMucHVzaCggaSwgaSArIDEsIDAgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0Ly8gYnVpbGQgZ2VvbWV0cnlcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XFxyXFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XFxyXFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XFxyXFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRDaXJjbGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcXHJcXG5cXHRDaXJjbGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDaXJjbGVCdWZmZXJHZW9tZXRyeTtcXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5cXHR2YXIgR2VvbWV0cmllcyA9IE9iamVjdC5mcmVlemUoe1xcclxcblxcdFxcdFdpcmVmcmFtZUdlb21ldHJ5OiBXaXJlZnJhbWVHZW9tZXRyeSxcXHJcXG5cXHRcXHRQYXJhbWV0cmljR2VvbWV0cnk6IFBhcmFtZXRyaWNHZW9tZXRyeSxcXHJcXG5cXHRcXHRQYXJhbWV0cmljQnVmZmVyR2VvbWV0cnk6IFBhcmFtZXRyaWNCdWZmZXJHZW9tZXRyeSxcXHJcXG5cXHRcXHRUZXRyYWhlZHJvbkdlb21ldHJ5OiBUZXRyYWhlZHJvbkdlb21ldHJ5LFxcclxcblxcdFxcdFRldHJhaGVkcm9uQnVmZmVyR2VvbWV0cnk6IFRldHJhaGVkcm9uQnVmZmVyR2VvbWV0cnksXFxyXFxuXFx0XFx0T2N0YWhlZHJvbkdlb21ldHJ5OiBPY3RhaGVkcm9uR2VvbWV0cnksXFxyXFxuXFx0XFx0T2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5OiBPY3RhaGVkcm9uQnVmZmVyR2VvbWV0cnksXFxyXFxuXFx0XFx0SWNvc2FoZWRyb25HZW9tZXRyeTogSWNvc2FoZWRyb25HZW9tZXRyeSxcXHJcXG5cXHRcXHRJY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5OiBJY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5LFxcclxcblxcdFxcdERvZGVjYWhlZHJvbkdlb21ldHJ5OiBEb2RlY2FoZWRyb25HZW9tZXRyeSxcXHJcXG5cXHRcXHREb2RlY2FoZWRyb25CdWZmZXJHZW9tZXRyeTogRG9kZWNhaGVkcm9uQnVmZmVyR2VvbWV0cnksXFxyXFxuXFx0XFx0UG9seWhlZHJvbkdlb21ldHJ5OiBQb2x5aGVkcm9uR2VvbWV0cnksXFxyXFxuXFx0XFx0UG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5OiBQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnksXFxyXFxuXFx0XFx0VHViZUdlb21ldHJ5OiBUdWJlR2VvbWV0cnksXFxyXFxuXFx0XFx0VHViZUJ1ZmZlckdlb21ldHJ5OiBUdWJlQnVmZmVyR2VvbWV0cnksXFxyXFxuXFx0XFx0VG9ydXNLbm90R2VvbWV0cnk6IFRvcnVzS25vdEdlb21ldHJ5LFxcclxcblxcdFxcdFRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5OiBUb3J1c0tub3RCdWZmZXJHZW9tZXRyeSxcXHJcXG5cXHRcXHRUb3J1c0dlb21ldHJ5OiBUb3J1c0dlb21ldHJ5LFxcclxcblxcdFxcdFRvcnVzQnVmZmVyR2VvbWV0cnk6IFRvcnVzQnVmZmVyR2VvbWV0cnksXFxyXFxuXFx0XFx0VGV4dEdlb21ldHJ5OiBUZXh0R2VvbWV0cnksXFxyXFxuXFx0XFx0VGV4dEJ1ZmZlckdlb21ldHJ5OiBUZXh0QnVmZmVyR2VvbWV0cnksXFxyXFxuXFx0XFx0U3BoZXJlR2VvbWV0cnk6IFNwaGVyZUdlb21ldHJ5LFxcclxcblxcdFxcdFNwaGVyZUJ1ZmZlckdlb21ldHJ5OiBTcGhlcmVCdWZmZXJHZW9tZXRyeSxcXHJcXG5cXHRcXHRSaW5nR2VvbWV0cnk6IFJpbmdHZW9tZXRyeSxcXHJcXG5cXHRcXHRSaW5nQnVmZmVyR2VvbWV0cnk6IFJpbmdCdWZmZXJHZW9tZXRyeSxcXHJcXG5cXHRcXHRQbGFuZUdlb21ldHJ5OiBQbGFuZUdlb21ldHJ5LFxcclxcblxcdFxcdFBsYW5lQnVmZmVyR2VvbWV0cnk6IFBsYW5lQnVmZmVyR2VvbWV0cnksXFxyXFxuXFx0XFx0TGF0aGVHZW9tZXRyeTogTGF0aGVHZW9tZXRyeSxcXHJcXG5cXHRcXHRMYXRoZUJ1ZmZlckdlb21ldHJ5OiBMYXRoZUJ1ZmZlckdlb21ldHJ5LFxcclxcblxcdFxcdFNoYXBlR2VvbWV0cnk6IFNoYXBlR2VvbWV0cnksXFxyXFxuXFx0XFx0U2hhcGVCdWZmZXJHZW9tZXRyeTogU2hhcGVCdWZmZXJHZW9tZXRyeSxcXHJcXG5cXHRcXHRFeHRydWRlR2VvbWV0cnk6IEV4dHJ1ZGVHZW9tZXRyeSxcXHJcXG5cXHRcXHRFeHRydWRlQnVmZmVyR2VvbWV0cnk6IEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeSxcXHJcXG5cXHRcXHRFZGdlc0dlb21ldHJ5OiBFZGdlc0dlb21ldHJ5LFxcclxcblxcdFxcdENvbmVHZW9tZXRyeTogQ29uZUdlb21ldHJ5LFxcclxcblxcdFxcdENvbmVCdWZmZXJHZW9tZXRyeTogQ29uZUJ1ZmZlckdlb21ldHJ5LFxcclxcblxcdFxcdEN5bGluZGVyR2VvbWV0cnk6IEN5bGluZGVyR2VvbWV0cnksXFxyXFxuXFx0XFx0Q3lsaW5kZXJCdWZmZXJHZW9tZXRyeTogQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeSxcXHJcXG5cXHRcXHRDaXJjbGVHZW9tZXRyeTogQ2lyY2xlR2VvbWV0cnksXFxyXFxuXFx0XFx0Q2lyY2xlQnVmZmVyR2VvbWV0cnk6IENpcmNsZUJ1ZmZlckdlb21ldHJ5LFxcclxcblxcdFxcdEJveEdlb21ldHJ5OiBCb3hHZW9tZXRyeSxcXHJcXG5cXHRcXHRCb3hCdWZmZXJHZW9tZXRyeTogQm94QnVmZmVyR2VvbWV0cnlcXHJcXG5cXHR9KTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqXFxyXFxuXFx0ICogcGFyYW1ldGVycyA9IHtcXHJcXG5cXHQgKiAgY29sb3I6IDxUSFJFRS5Db2xvcj4sXFxyXFxuXFx0ICogIG9wYWNpdHk6IDxmbG9hdD5cXHJcXG5cXHQgKiB9XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gU2hhZG93TWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0TWF0ZXJpYWwuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdTaGFkb3dNYXRlcmlhbCc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHgwMDAwMDAgKTtcXHJcXG5cXHRcXHR0aGlzLm9wYWNpdHkgPSAxLjA7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5saWdodHMgPSB0cnVlO1xcclxcblxcdFxcdHRoaXMudHJhbnNwYXJlbnQgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdFNoYWRvd01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hdGVyaWFsLnByb3RvdHlwZSApO1xcclxcblxcdFNoYWRvd01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNoYWRvd01hdGVyaWFsO1xcclxcblxcclxcblxcdFNoYWRvd01hdGVyaWFsLnByb3RvdHlwZS5pc1NoYWRvd01hdGVyaWFsID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIFJhd1NoYWRlck1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xcclxcblxcclxcblxcdFxcdFNoYWRlck1hdGVyaWFsLmNhbGwoIHRoaXMsIHBhcmFtZXRlcnMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnUmF3U2hhZGVyTWF0ZXJpYWwnO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRSYXdTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUgKTtcXHJcXG5cXHRSYXdTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSYXdTaGFkZXJNYXRlcmlhbDtcXHJcXG5cXHJcXG5cXHRSYXdTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuaXNSYXdTaGFkZXJNYXRlcmlhbCA9IHRydWU7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBwYXJhbWV0ZXJzID0ge1xcclxcblxcdCAqICBjb2xvcjogPGhleD4sXFxyXFxuXFx0ICogIHJvdWdobmVzczogPGZsb2F0PixcXHJcXG5cXHQgKiAgbWV0YWxuZXNzOiA8ZmxvYXQ+LFxcclxcblxcdCAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxcclxcblxcdCAqXFxyXFxuXFx0ICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXHJcXG5cXHQgKlxcclxcblxcdCAqICBsaWdodE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXHJcXG5cXHQgKiAgbGlnaHRNYXBJbnRlbnNpdHk6IDxmbG9hdD5cXHJcXG5cXHQgKlxcclxcblxcdCAqICBhb01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXHJcXG5cXHQgKiAgYW9NYXBJbnRlbnNpdHk6IDxmbG9hdD5cXHJcXG5cXHQgKlxcclxcblxcdCAqICBlbWlzc2l2ZTogPGhleD4sXFxyXFxuXFx0ICogIGVtaXNzaXZlSW50ZW5zaXR5OiA8ZmxvYXQ+XFxyXFxuXFx0ICogIGVtaXNzaXZlTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcclxcblxcdCAqXFxyXFxuXFx0ICogIGJ1bXBNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxyXFxuXFx0ICogIGJ1bXBTY2FsZTogPGZsb2F0PixcXHJcXG5cXHQgKlxcclxcblxcdCAqICBub3JtYWxNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxyXFxuXFx0ICogIG5vcm1hbFNjYWxlOiA8VmVjdG9yMj4sXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiAgZGlzcGxhY2VtZW50TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcclxcblxcdCAqICBkaXNwbGFjZW1lbnRTY2FsZTogPGZsb2F0PixcXHJcXG5cXHQgKiAgZGlzcGxhY2VtZW50QmlhczogPGZsb2F0PixcXHJcXG5cXHQgKlxcclxcblxcdCAqICByb3VnaG5lc3NNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiAgbWV0YWxuZXNzTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcclxcblxcdCAqXFxyXFxuXFx0ICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcclxcblxcdCAqXFxyXFxuXFx0ICogIGVudk1hcDogbmV3IFRIUkVFLkN1YmVUZXh0dXJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcXHJcXG5cXHQgKiAgZW52TWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XFxyXFxuXFx0ICpcXHJcXG5cXHQgKiAgcmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxcclxcblxcdCAqXFxyXFxuXFx0ICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxcclxcblxcdCAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiAgc2tpbm5pbmc6IDxib29sPixcXHJcXG5cXHQgKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXFxyXFxuXFx0ICogIG1vcnBoTm9ybWFsczogPGJvb2w+XFxyXFxuXFx0ICogfVxcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIE1lc2hTdGFuZGFyZE1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xcclxcblxcclxcblxcdFxcdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmRlZmluZXMgPSB7ICdTVEFOREFSRCc6ICcnIH07XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50eXBlID0gJ01lc2hTdGFuZGFyZE1hdGVyaWFsJztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApOyAvLyBkaWZmdXNlXFxyXFxuXFx0XFx0dGhpcy5yb3VnaG5lc3MgPSAwLjU7XFxyXFxuXFx0XFx0dGhpcy5tZXRhbG5lc3MgPSAwLjU7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5tYXAgPSBudWxsO1xcclxcblxcclxcblxcdFxcdHRoaXMubGlnaHRNYXAgPSBudWxsO1xcclxcblxcdFxcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5hb01hcCA9IG51bGw7XFxyXFxuXFx0XFx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmVtaXNzaXZlID0gbmV3IENvbG9yKCAweDAwMDAwMCApO1xcclxcblxcdFxcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSAxLjA7XFxyXFxuXFx0XFx0dGhpcy5lbWlzc2l2ZU1hcCA9IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5idW1wTWFwID0gbnVsbDtcXHJcXG5cXHRcXHR0aGlzLmJ1bXBTY2FsZSA9IDE7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5ub3JtYWxNYXAgPSBudWxsO1xcclxcblxcdFxcdHRoaXMubm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMiggMSwgMSApO1xcclxcblxcclxcblxcdFxcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcXHJcXG5cXHRcXHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcXHJcXG5cXHRcXHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xcclxcblxcclxcblxcdFxcdHRoaXMucm91Z2huZXNzTWFwID0gbnVsbDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm1ldGFsbmVzc01hcCA9IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5lbnZNYXAgPSBudWxsO1xcclxcblxcdFxcdHRoaXMuZW52TWFwSW50ZW5zaXR5ID0gMS4wO1xcclxcblxcclxcblxcdFxcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xcclxcblxcdFxcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcXHJcXG5cXHRcXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xcclxcblxcdFxcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xcclxcblxcclxcblxcdFxcdHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcXHJcXG5cXHRcXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xcclxcblxcdFxcdHRoaXMubW9ycGhOb3JtYWxzID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0TWVzaFN0YW5kYXJkTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XFxyXFxuXFx0TWVzaFN0YW5kYXJkTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWVzaFN0YW5kYXJkTWF0ZXJpYWw7XFxyXFxuXFxyXFxuXFx0TWVzaFN0YW5kYXJkTWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPSB0cnVlO1xcclxcblxcclxcblxcdE1lc2hTdGFuZGFyZE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5kZWZpbmVzID0geyAnU1RBTkRBUkQnOiAnJyB9O1xcclxcblxcclxcblxcdFxcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XFxyXFxuXFx0XFx0dGhpcy5yb3VnaG5lc3MgPSBzb3VyY2Uucm91Z2huZXNzO1xcclxcblxcdFxcdHRoaXMubWV0YWxuZXNzID0gc291cmNlLm1ldGFsbmVzcztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5saWdodE1hcCA9IHNvdXJjZS5saWdodE1hcDtcXHJcXG5cXHRcXHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xcclxcblxcclxcblxcdFxcdHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XFxyXFxuXFx0XFx0dGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmVtaXNzaXZlLmNvcHkoIHNvdXJjZS5lbWlzc2l2ZSApO1xcclxcblxcdFxcdHRoaXMuZW1pc3NpdmVNYXAgPSBzb3VyY2UuZW1pc3NpdmVNYXA7XFxyXFxuXFx0XFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IHNvdXJjZS5lbWlzc2l2ZUludGVuc2l0eTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmJ1bXBNYXAgPSBzb3VyY2UuYnVtcE1hcDtcXHJcXG5cXHRcXHR0aGlzLmJ1bXBTY2FsZSA9IHNvdXJjZS5idW1wU2NhbGU7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5ub3JtYWxNYXAgPSBzb3VyY2Uubm9ybWFsTWFwO1xcclxcblxcdFxcdHRoaXMubm9ybWFsU2NhbGUuY29weSggc291cmNlLm5vcm1hbFNjYWxlICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xcclxcblxcdFxcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XFxyXFxuXFx0XFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5yb3VnaG5lc3NNYXAgPSBzb3VyY2Uucm91Z2huZXNzTWFwO1xcclxcblxcclxcblxcdFxcdHRoaXMubWV0YWxuZXNzTWFwID0gc291cmNlLm1ldGFsbmVzc01hcDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xcclxcblxcclxcblxcdFxcdHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcXHJcXG5cXHRcXHR0aGlzLmVudk1hcEludGVuc2l0eSA9IHNvdXJjZS5lbnZNYXBJbnRlbnNpdHk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xcclxcblxcclxcblxcdFxcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcXHJcXG5cXHRcXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XFxyXFxuXFx0XFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XFxyXFxuXFx0XFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xcclxcblxcdFxcdHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcXHJcXG5cXHRcXHR0aGlzLm1vcnBoTm9ybWFscyA9IHNvdXJjZS5tb3JwaE5vcm1hbHM7XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcXHJcXG5cXHQgKlxcclxcblxcdCAqIHBhcmFtZXRlcnMgPSB7XFxyXFxuXFx0ICogIHJlZmxlY3Rpdml0eTogPGZsb2F0PlxcclxcblxcdCAqIH1cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBNZXNoUGh5c2ljYWxNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcXHJcXG5cXHJcXG5cXHRcXHRNZXNoU3RhbmRhcmRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5kZWZpbmVzID0geyAnUEhZU0lDQUwnOiAnJyB9O1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdNZXNoUGh5c2ljYWxNYXRlcmlhbCc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5yZWZsZWN0aXZpdHkgPSAwLjU7IC8vIG1hcHMgdG8gRjAgPSAwLjA0XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5jbGVhckNvYXQgPSAwLjA7XFxyXFxuXFx0XFx0dGhpcy5jbGVhckNvYXRSb3VnaG5lc3MgPSAwLjA7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0TWVzaFBoeXNpY2FsTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWVzaFN0YW5kYXJkTWF0ZXJpYWwucHJvdG90eXBlICk7XFxyXFxuXFx0TWVzaFBoeXNpY2FsTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XFxyXFxuXFxyXFxuXFx0TWVzaFBoeXNpY2FsTWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaFBoeXNpY2FsTWF0ZXJpYWwgPSB0cnVlO1xcclxcblxcclxcblxcdE1lc2hQaHlzaWNhbE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0TWVzaFN0YW5kYXJkTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5kZWZpbmVzID0geyAnUEhZU0lDQUwnOiAnJyB9O1xcclxcblxcclxcblxcdFxcdHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmNsZWFyQ29hdCA9IHNvdXJjZS5jbGVhckNvYXQ7XFxyXFxuXFx0XFx0dGhpcy5jbGVhckNvYXRSb3VnaG5lc3MgPSBzb3VyY2UuY2xlYXJDb2F0Um91Z2huZXNzO1xcclxcblxcclxcblxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcclxcblxcdCAqXFxyXFxuXFx0ICogcGFyYW1ldGVycyA9IHtcXHJcXG5cXHQgKiAgY29sb3I6IDxoZXg+LFxcclxcblxcdCAqICBzcGVjdWxhcjogPGhleD4sXFxyXFxuXFx0ICogIHNoaW5pbmVzczogPGZsb2F0PixcXHJcXG5cXHQgKiAgb3BhY2l0eTogPGZsb2F0PixcXHJcXG5cXHQgKlxcclxcblxcdCAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiAgbGlnaHRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxyXFxuXFx0ICogIGxpZ2h0TWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XFxyXFxuXFx0ICpcXHJcXG5cXHQgKiAgYW9NYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxyXFxuXFx0ICogIGFvTWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XFxyXFxuXFx0ICpcXHJcXG5cXHQgKiAgZW1pc3NpdmU6IDxoZXg+LFxcclxcblxcdCAqICBlbWlzc2l2ZUludGVuc2l0eTogPGZsb2F0PlxcclxcblxcdCAqICBlbWlzc2l2ZU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXHJcXG5cXHQgKlxcclxcblxcdCAqICBidW1wTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcclxcblxcdCAqICBidW1wU2NhbGU6IDxmbG9hdD4sXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiAgbm9ybWFsTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcclxcblxcdCAqICBub3JtYWxTY2FsZTogPFZlY3RvcjI+LFxcclxcblxcdCAqXFxyXFxuXFx0ICogIGRpc3BsYWNlbWVudE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXHJcXG5cXHQgKiAgZGlzcGxhY2VtZW50U2NhbGU6IDxmbG9hdD4sXFxyXFxuXFx0ICogIGRpc3BsYWNlbWVudEJpYXM6IDxmbG9hdD4sXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiAgc3BlY3VsYXJNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiAgYWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxcclxcblxcdCAqICBjb21iaW5lOiBUSFJFRS5NdWx0aXBseSxcXHJcXG5cXHQgKiAgcmVmbGVjdGl2aXR5OiA8ZmxvYXQ+LFxcclxcblxcdCAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXFxyXFxuXFx0ICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcXHJcXG5cXHQgKlxcclxcblxcdCAqICBza2lubmluZzogPGJvb2w+LFxcclxcblxcdCAqICBtb3JwaFRhcmdldHM6IDxib29sPixcXHJcXG5cXHQgKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD5cXHJcXG5cXHQgKiB9XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gTWVzaFBob25nTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0TWF0ZXJpYWwuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdNZXNoUGhvbmdNYXRlcmlhbCc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxcclxcblxcdFxcdHRoaXMuc3BlY3VsYXIgPSBuZXcgQ29sb3IoIDB4MTExMTExICk7XFxyXFxuXFx0XFx0dGhpcy5zaGluaW5lc3MgPSAzMDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm1hcCA9IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5saWdodE1hcCA9IG51bGw7XFxyXFxuXFx0XFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmFvTWFwID0gbnVsbDtcXHJcXG5cXHRcXHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gMS4wO1xcclxcblxcclxcblxcdFxcdHRoaXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoIDB4MDAwMDAwICk7XFxyXFxuXFx0XFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IDEuMDtcXHJcXG5cXHRcXHR0aGlzLmVtaXNzaXZlTWFwID0gbnVsbDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmJ1bXBNYXAgPSBudWxsO1xcclxcblxcdFxcdHRoaXMuYnVtcFNjYWxlID0gMTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm5vcm1hbE1hcCA9IG51bGw7XFxyXFxuXFx0XFx0dGhpcy5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKCAxLCAxICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xcclxcblxcdFxcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xcclxcblxcdFxcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5lbnZNYXAgPSBudWxsO1xcclxcblxcdFxcdHRoaXMuY29tYmluZSA9IE11bHRpcGx5T3BlcmF0aW9uO1xcclxcblxcdFxcdHRoaXMucmVmbGVjdGl2aXR5ID0gMTtcXHJcXG5cXHRcXHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcXHJcXG5cXHRcXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XFxyXFxuXFx0XFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcXHJcXG5cXHRcXHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7XFxyXFxuXFx0XFx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcXHJcXG5cXHRcXHR0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdE1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hdGVyaWFsLnByb3RvdHlwZSApO1xcclxcblxcdE1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1lc2hQaG9uZ01hdGVyaWFsO1xcclxcblxcclxcblxcdE1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZS5pc01lc2hQaG9uZ01hdGVyaWFsID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRNZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xcclxcblxcclxcblxcdFxcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcclxcblxcclxcblxcdFxcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XFxyXFxuXFx0XFx0dGhpcy5zcGVjdWxhci5jb3B5KCBzb3VyY2Uuc3BlY3VsYXIgKTtcXHJcXG5cXHRcXHR0aGlzLnNoaW5pbmVzcyA9IHNvdXJjZS5zaGluaW5lc3M7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xcclxcblxcclxcblxcdFxcdHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XFxyXFxuXFx0XFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmFvTWFwID0gc291cmNlLmFvTWFwO1xcclxcblxcdFxcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5lbWlzc2l2ZS5jb3B5KCBzb3VyY2UuZW1pc3NpdmUgKTtcXHJcXG5cXHRcXHR0aGlzLmVtaXNzaXZlTWFwID0gc291cmNlLmVtaXNzaXZlTWFwO1xcclxcblxcdFxcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSBzb3VyY2UuZW1pc3NpdmVJbnRlbnNpdHk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XFxyXFxuXFx0XFx0dGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xcclxcblxcclxcblxcdFxcdHRoaXMubm9ybWFsTWFwID0gc291cmNlLm5vcm1hbE1hcDtcXHJcXG5cXHRcXHR0aGlzLm5vcm1hbFNjYWxlLmNvcHkoIHNvdXJjZS5ub3JtYWxTY2FsZSApO1xcclxcblxcclxcblxcdFxcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcXHJcXG5cXHRcXHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xcclxcblxcdFxcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xcclxcblxcclxcblxcdFxcdHRoaXMuc3BlY3VsYXJNYXAgPSBzb3VyY2Uuc3BlY3VsYXJNYXA7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XFxyXFxuXFx0XFx0dGhpcy5jb21iaW5lID0gc291cmNlLmNvbWJpbmU7XFxyXFxuXFx0XFx0dGhpcy5yZWZsZWN0aXZpdHkgPSBzb3VyY2UucmVmbGVjdGl2aXR5O1xcclxcblxcdFxcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gc291cmNlLnJlZnJhY3Rpb25SYXRpbztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XFxyXFxuXFx0XFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xcclxcblxcdFxcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xcclxcblxcdFxcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcXHJcXG5cXHRcXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XFxyXFxuXFx0XFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xcclxcblxcclxcblxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciB0YWthaGlyb3ggLyBodHRwOi8vZ2l0aHViLmNvbS90YWthaGlyb3hcXHJcXG5cXHQgKlxcclxcblxcdCAqIHBhcmFtZXRlcnMgPSB7XFxyXFxuXFx0ICogIGdyYWRpZW50TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApXFxyXFxuXFx0ICogfVxcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIE1lc2hUb29uTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0TWVzaFBob25nTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMuZGVmaW5lcyA9IHsgJ1RPT04nOiAnJyB9O1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdNZXNoVG9vbk1hdGVyaWFsJztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmdyYWRpZW50TWFwID0gbnVsbDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRNZXNoVG9vbk1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZSApO1xcclxcblxcdE1lc2hUb29uTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWVzaFRvb25NYXRlcmlhbDtcXHJcXG5cXHJcXG5cXHRNZXNoVG9vbk1hdGVyaWFsLnByb3RvdHlwZS5pc01lc2hUb29uTWF0ZXJpYWwgPSB0cnVlO1xcclxcblxcclxcblxcdE1lc2hUb29uTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRNZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmdyYWRpZW50TWFwID0gc291cmNlLmdyYWRpZW50TWFwO1xcclxcblxcclxcblxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcXHJcXG5cXHQgKlxcclxcblxcdCAqIHBhcmFtZXRlcnMgPSB7XFxyXFxuXFx0ICogIG9wYWNpdHk6IDxmbG9hdD4sXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiAgYnVtcE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXHJcXG5cXHQgKiAgYnVtcFNjYWxlOiA8ZmxvYXQ+LFxcclxcblxcdCAqXFxyXFxuXFx0ICogIG5vcm1hbE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXHJcXG5cXHQgKiAgbm9ybWFsU2NhbGU6IDxWZWN0b3IyPixcXHJcXG5cXHQgKlxcclxcblxcdCAqICBkaXNwbGFjZW1lbnRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxyXFxuXFx0ICogIGRpc3BsYWNlbWVudFNjYWxlOiA8ZmxvYXQ+LFxcclxcblxcdCAqICBkaXNwbGFjZW1lbnRCaWFzOiA8ZmxvYXQ+LFxcclxcblxcdCAqXFxyXFxuXFx0ICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxcclxcblxcdCAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD5cXHJcXG5cXHQgKlxcclxcblxcdCAqICBza2lubmluZzogPGJvb2w+LFxcclxcblxcdCAqICBtb3JwaFRhcmdldHM6IDxib29sPixcXHJcXG5cXHQgKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD5cXHJcXG5cXHQgKiB9XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gTWVzaE5vcm1hbE1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xcclxcblxcclxcblxcdFxcdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnTWVzaE5vcm1hbE1hdGVyaWFsJztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmJ1bXBNYXAgPSBudWxsO1xcclxcblxcdFxcdHRoaXMuYnVtcFNjYWxlID0gMTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm5vcm1hbE1hcCA9IG51bGw7XFxyXFxuXFx0XFx0dGhpcy5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKCAxLCAxICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xcclxcblxcdFxcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xcclxcblxcdFxcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcXHJcXG5cXHRcXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5mb2cgPSBmYWxzZTtcXHJcXG5cXHRcXHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcXHJcXG5cXHRcXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xcclxcblxcdFxcdHRoaXMubW9ycGhOb3JtYWxzID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0TWVzaE5vcm1hbE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hdGVyaWFsLnByb3RvdHlwZSApO1xcclxcblxcdE1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNZXNoTm9ybWFsTWF0ZXJpYWw7XFxyXFxuXFxyXFxuXFx0TWVzaE5vcm1hbE1hdGVyaWFsLnByb3RvdHlwZS5pc01lc2hOb3JtYWxNYXRlcmlhbCA9IHRydWU7XFxyXFxuXFxyXFxuXFx0TWVzaE5vcm1hbE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XFxyXFxuXFx0XFx0dGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xcclxcblxcclxcblxcdFxcdHRoaXMubm9ybWFsTWFwID0gc291cmNlLm5vcm1hbE1hcDtcXHJcXG5cXHRcXHR0aGlzLm5vcm1hbFNjYWxlLmNvcHkoIHNvdXJjZS5ub3JtYWxTY2FsZSApO1xcclxcblxcclxcblxcdFxcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcXHJcXG5cXHRcXHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xcclxcblxcdFxcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xcclxcblxcclxcblxcdFxcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcXHJcXG5cXHRcXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcXHJcXG5cXHRcXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XFxyXFxuXFx0XFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xcclxcblxcclxcblxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcclxcblxcdCAqXFxyXFxuXFx0ICogcGFyYW1ldGVycyA9IHtcXHJcXG5cXHQgKiAgY29sb3I6IDxoZXg+LFxcclxcblxcdCAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxcclxcblxcdCAqXFxyXFxuXFx0ICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXHJcXG5cXHQgKlxcclxcblxcdCAqICBsaWdodE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXHJcXG5cXHQgKiAgbGlnaHRNYXBJbnRlbnNpdHk6IDxmbG9hdD5cXHJcXG5cXHQgKlxcclxcblxcdCAqICBhb01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXHJcXG5cXHQgKiAgYW9NYXBJbnRlbnNpdHk6IDxmbG9hdD5cXHJcXG5cXHQgKlxcclxcblxcdCAqICBlbWlzc2l2ZTogPGhleD4sXFxyXFxuXFx0ICogIGVtaXNzaXZlSW50ZW5zaXR5OiA8ZmxvYXQ+XFxyXFxuXFx0ICogIGVtaXNzaXZlTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcclxcblxcdCAqXFxyXFxuXFx0ICogIHNwZWN1bGFyTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcclxcblxcdCAqXFxyXFxuXFx0ICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcclxcblxcdCAqXFxyXFxuXFx0ICogIGVudk1hcDogbmV3IFRIUkVFLlRleHR1cmVDdWJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcXHJcXG5cXHQgKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXFxyXFxuXFx0ICogIHJlZmxlY3Rpdml0eTogPGZsb2F0PixcXHJcXG5cXHQgKiAgcmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxcclxcblxcdCAqXFxyXFxuXFx0ICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxcclxcblxcdCAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiAgc2tpbm5pbmc6IDxib29sPixcXHJcXG5cXHQgKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXFxyXFxuXFx0ICogIG1vcnBoTm9ybWFsczogPGJvb2w+XFxyXFxuXFx0ICogfVxcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIE1lc2hMYW1iZXJ0TWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0TWF0ZXJpYWwuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdNZXNoTGFtYmVydE1hdGVyaWFsJztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApOyAvLyBkaWZmdXNlXFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5tYXAgPSBudWxsO1xcclxcblxcclxcblxcdFxcdHRoaXMubGlnaHRNYXAgPSBudWxsO1xcclxcblxcdFxcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5hb01hcCA9IG51bGw7XFxyXFxuXFx0XFx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmVtaXNzaXZlID0gbmV3IENvbG9yKCAweDAwMDAwMCApO1xcclxcblxcdFxcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSAxLjA7XFxyXFxuXFx0XFx0dGhpcy5lbWlzc2l2ZU1hcCA9IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5lbnZNYXAgPSBudWxsO1xcclxcblxcdFxcdHRoaXMuY29tYmluZSA9IE11bHRpcGx5T3BlcmF0aW9uO1xcclxcblxcdFxcdHRoaXMucmVmbGVjdGl2aXR5ID0gMTtcXHJcXG5cXHRcXHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcXHJcXG5cXHRcXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XFxyXFxuXFx0XFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcXHJcXG5cXHRcXHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7XFxyXFxuXFx0XFx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcXHJcXG5cXHRcXHR0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdE1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XFxyXFxuXFx0TWVzaExhbWJlcnRNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNZXNoTGFtYmVydE1hdGVyaWFsO1xcclxcblxcclxcblxcdE1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaExhbWJlcnRNYXRlcmlhbCA9IHRydWU7XFxyXFxuXFxyXFxuXFx0TWVzaExhbWJlcnRNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xcclxcblxcclxcblxcdFxcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcclxcblxcclxcblxcdFxcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xcclxcblxcclxcblxcdFxcdHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XFxyXFxuXFx0XFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmFvTWFwID0gc291cmNlLmFvTWFwO1xcclxcblxcdFxcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5lbWlzc2l2ZS5jb3B5KCBzb3VyY2UuZW1pc3NpdmUgKTtcXHJcXG5cXHRcXHR0aGlzLmVtaXNzaXZlTWFwID0gc291cmNlLmVtaXNzaXZlTWFwO1xcclxcblxcdFxcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSBzb3VyY2UuZW1pc3NpdmVJbnRlbnNpdHk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xcclxcblxcclxcblxcdFxcdHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcXHJcXG5cXHRcXHR0aGlzLmNvbWJpbmUgPSBzb3VyY2UuY29tYmluZTtcXHJcXG5cXHRcXHR0aGlzLnJlZmxlY3Rpdml0eSA9IHNvdXJjZS5yZWZsZWN0aXZpdHk7XFxyXFxuXFx0XFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xcclxcblxcclxcblxcdFxcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcXHJcXG5cXHRcXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XFxyXFxuXFx0XFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XFxyXFxuXFx0XFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xcclxcblxcdFxcdHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcXHJcXG5cXHRcXHR0aGlzLm1vcnBoTm9ybWFscyA9IHNvdXJjZS5tb3JwaE5vcm1hbHM7XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcclxcblxcdCAqXFxyXFxuXFx0ICogcGFyYW1ldGVycyA9IHtcXHJcXG5cXHQgKiAgY29sb3I6IDxoZXg+LFxcclxcblxcdCAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxcclxcblxcdCAqXFxyXFxuXFx0ICogIGxpbmV3aWR0aDogPGZsb2F0PixcXHJcXG5cXHQgKlxcclxcblxcdCAqICBzY2FsZTogPGZsb2F0PixcXHJcXG5cXHQgKiAgZGFzaFNpemU6IDxmbG9hdD4sXFxyXFxuXFx0ICogIGdhcFNpemU6IDxmbG9hdD5cXHJcXG5cXHQgKiB9XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gTGluZURhc2hlZE1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xcclxcblxcclxcblxcdFxcdExpbmVCYXNpY01hdGVyaWFsLmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnTGluZURhc2hlZE1hdGVyaWFsJztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnNjYWxlID0gMTtcXHJcXG5cXHRcXHR0aGlzLmRhc2hTaXplID0gMztcXHJcXG5cXHRcXHR0aGlzLmdhcFNpemUgPSAxO1xcclxcblxcclxcblxcdFxcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdExpbmVEYXNoZWRNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMaW5lQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUgKTtcXHJcXG5cXHRMaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGluZURhc2hlZE1hdGVyaWFsO1xcclxcblxcclxcblxcdExpbmVEYXNoZWRNYXRlcmlhbC5wcm90b3R5cGUuaXNMaW5lRGFzaGVkTWF0ZXJpYWwgPSB0cnVlO1xcclxcblxcclxcblxcdExpbmVEYXNoZWRNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xcclxcblxcclxcblxcdFxcdExpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcclxcblxcclxcblxcdFxcdHRoaXMuc2NhbGUgPSBzb3VyY2Uuc2NhbGU7XFxyXFxuXFx0XFx0dGhpcy5kYXNoU2l6ZSA9IHNvdXJjZS5kYXNoU2l6ZTtcXHJcXG5cXHRcXHR0aGlzLmdhcFNpemUgPSBzb3VyY2UuZ2FwU2l6ZTtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHR9O1xcclxcblxcclxcblxcclxcblxcclxcblxcdHZhciBNYXRlcmlhbHMgPSBPYmplY3QuZnJlZXplKHtcXHJcXG5cXHRcXHRTaGFkb3dNYXRlcmlhbDogU2hhZG93TWF0ZXJpYWwsXFxyXFxuXFx0XFx0U3ByaXRlTWF0ZXJpYWw6IFNwcml0ZU1hdGVyaWFsLFxcclxcblxcdFxcdFJhd1NoYWRlck1hdGVyaWFsOiBSYXdTaGFkZXJNYXRlcmlhbCxcXHJcXG5cXHRcXHRTaGFkZXJNYXRlcmlhbDogU2hhZGVyTWF0ZXJpYWwsXFxyXFxuXFx0XFx0UG9pbnRzTWF0ZXJpYWw6IFBvaW50c01hdGVyaWFsLFxcclxcblxcdFxcdE1lc2hQaHlzaWNhbE1hdGVyaWFsOiBNZXNoUGh5c2ljYWxNYXRlcmlhbCxcXHJcXG5cXHRcXHRNZXNoU3RhbmRhcmRNYXRlcmlhbDogTWVzaFN0YW5kYXJkTWF0ZXJpYWwsXFxyXFxuXFx0XFx0TWVzaFBob25nTWF0ZXJpYWw6IE1lc2hQaG9uZ01hdGVyaWFsLFxcclxcblxcdFxcdE1lc2hUb29uTWF0ZXJpYWw6IE1lc2hUb29uTWF0ZXJpYWwsXFxyXFxuXFx0XFx0TWVzaE5vcm1hbE1hdGVyaWFsOiBNZXNoTm9ybWFsTWF0ZXJpYWwsXFxyXFxuXFx0XFx0TWVzaExhbWJlcnRNYXRlcmlhbDogTWVzaExhbWJlcnRNYXRlcmlhbCxcXHJcXG5cXHRcXHRNZXNoRGVwdGhNYXRlcmlhbDogTWVzaERlcHRoTWF0ZXJpYWwsXFxyXFxuXFx0XFx0TWVzaERpc3RhbmNlTWF0ZXJpYWw6IE1lc2hEaXN0YW5jZU1hdGVyaWFsLFxcclxcblxcdFxcdE1lc2hCYXNpY01hdGVyaWFsOiBNZXNoQmFzaWNNYXRlcmlhbCxcXHJcXG5cXHRcXHRMaW5lRGFzaGVkTWF0ZXJpYWw6IExpbmVEYXNoZWRNYXRlcmlhbCxcXHJcXG5cXHRcXHRMaW5lQmFzaWNNYXRlcmlhbDogTGluZUJhc2ljTWF0ZXJpYWwsXFxyXFxuXFx0XFx0TWF0ZXJpYWw6IE1hdGVyaWFsXFxyXFxuXFx0fSk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHR2YXIgQ2FjaGUgPSB7XFxyXFxuXFxyXFxuXFx0XFx0ZW5hYmxlZDogZmFsc2UsXFxyXFxuXFxyXFxuXFx0XFx0ZmlsZXM6IHt9LFxcclxcblxcclxcblxcdFxcdGFkZDogZnVuY3Rpb24gKCBrZXksIGZpbGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xcclxcblxcclxcblxcdFxcdFxcdC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuQ2FjaGUnLCAnQWRkaW5nIGtleTonLCBrZXkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmZpbGVzWyBrZXkgXSA9IGZpbGU7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRnZXQ6IGZ1bmN0aW9uICgga2V5ICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBjb25zb2xlLmxvZyggJ1RIUkVFLkNhY2hlJywgJ0NoZWNraW5nIGtleTonLCBrZXkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5maWxlc1sga2V5IF07XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRyZW1vdmU6IGZ1bmN0aW9uICgga2V5ICkge1xcclxcblxcclxcblxcdFxcdFxcdGRlbGV0ZSB0aGlzLmZpbGVzWyBrZXkgXTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNsZWFyOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5maWxlcyA9IHt9O1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9O1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gTG9hZGluZ01hbmFnZXIoIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgc2NvcGUgPSB0aGlzO1xcclxcblxcclxcblxcdFxcdHZhciBpc0xvYWRpbmcgPSBmYWxzZTtcXHJcXG5cXHRcXHR2YXIgaXRlbXNMb2FkZWQgPSAwO1xcclxcblxcdFxcdHZhciBpdGVtc1RvdGFsID0gMDtcXHJcXG5cXHRcXHR2YXIgdXJsTW9kaWZpZXIgPSB1bmRlZmluZWQ7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5vblN0YXJ0ID0gdW5kZWZpbmVkO1xcclxcblxcdFxcdHRoaXMub25Mb2FkID0gb25Mb2FkO1xcclxcblxcdFxcdHRoaXMub25Qcm9ncmVzcyA9IG9uUHJvZ3Jlc3M7XFxyXFxuXFx0XFx0dGhpcy5vbkVycm9yID0gb25FcnJvcjtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLml0ZW1TdGFydCA9IGZ1bmN0aW9uICggdXJsICkge1xcclxcblxcclxcblxcdFxcdFxcdGl0ZW1zVG90YWwgKys7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBpc0xvYWRpbmcgPT09IGZhbHNlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggc2NvcGUub25TdGFydCAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHNjb3BlLm9uU3RhcnQoIHVybCwgaXRlbXNMb2FkZWQsIGl0ZW1zVG90YWwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlzTG9hZGluZyA9IHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLml0ZW1FbmQgPSBmdW5jdGlvbiAoIHVybCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpdGVtc0xvYWRlZCArKztcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHNjb3BlLm9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzY29wZS5vblByb2dyZXNzKCB1cmwsIGl0ZW1zTG9hZGVkLCBpdGVtc1RvdGFsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggaXRlbXNMb2FkZWQgPT09IGl0ZW1zVG90YWwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aXNMb2FkaW5nID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBzY29wZS5vbkxvYWQgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRzY29wZS5vbkxvYWQoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5pdGVtRXJyb3IgPSBmdW5jdGlvbiAoIHVybCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHNjb3BlLm9uRXJyb3IgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzY29wZS5vbkVycm9yKCB1cmwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnJlc29sdmVVUkwgPSBmdW5jdGlvbiAoIHVybCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHVybE1vZGlmaWVyICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB1cmxNb2RpZmllciggdXJsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB1cmw7XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnNldFVSTE1vZGlmaWVyID0gZnVuY3Rpb24gKCB0cmFuc2Zvcm0gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dXJsTW9kaWZpZXIgPSB0cmFuc2Zvcm07XFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0dmFyIERlZmF1bHRMb2FkaW5nTWFuYWdlciA9IG5ldyBMb2FkaW5nTWFuYWdlcigpO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0dmFyIGxvYWRpbmcgPSB7fTtcXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBGaWxlTG9hZGVyKCBtYW5hZ2VyICkge1xcclxcblxcclxcblxcdFxcdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRPYmplY3QuYXNzaWduKCBGaWxlTG9hZGVyLnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB1cmwgPT09IHVuZGVmaW5lZCApIHVybCA9ICcnO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5wYXRoICE9PSB1bmRlZmluZWQgKSB1cmwgPSB0aGlzLnBhdGggKyB1cmw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dXJsID0gdGhpcy5tYW5hZ2VyLnJlc29sdmVVUkwoIHVybCApO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBzY29wZSA9IHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGNhY2hlZCA9IENhY2hlLmdldCggdXJsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBjYWNoZWQgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0c2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggb25Mb2FkICkgb25Mb2FkKCBjYWNoZWQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0sIDAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gY2FjaGVkO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBDaGVjayBpZiByZXF1ZXN0IGlzIGR1cGxpY2F0ZVxcclxcblxcclxcblxcdFxcdFxcdGlmICggbG9hZGluZ1sgdXJsIF0gIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRsb2FkaW5nWyB1cmwgXS5wdXNoKCB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0b25Mb2FkOiBvbkxvYWQsXFxyXFxuXFx0XFx0XFx0XFx0XFx0b25Qcm9ncmVzczogb25Qcm9ncmVzcyxcXHJcXG5cXHRcXHRcXHRcXHRcXHRvbkVycm9yOiBvbkVycm9yXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybjtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gQ2hlY2sgZm9yIGRhdGE6IFVSSVxcclxcblxcdFxcdFxcdHZhciBkYXRhVXJpUmVnZXggPSAvXmRhdGE6KC4qPykoO2Jhc2U2NCk/LCguKikkLztcXHJcXG5cXHRcXHRcXHR2YXIgZGF0YVVyaVJlZ2V4UmVzdWx0ID0gdXJsLm1hdGNoKCBkYXRhVXJpUmVnZXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBTYWZhcmkgY2FuIG5vdCBoYW5kbGUgRGF0YSBVUklzIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Qgc28gcHJvY2VzcyBtYW51YWxseVxcclxcblxcdFxcdFxcdGlmICggZGF0YVVyaVJlZ2V4UmVzdWx0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBtaW1lVHlwZSA9IGRhdGFVcmlSZWdleFJlc3VsdFsgMSBdO1xcclxcblxcdFxcdFxcdFxcdHZhciBpc0Jhc2U2NCA9ICEhIGRhdGFVcmlSZWdleFJlc3VsdFsgMiBdO1xcclxcblxcdFxcdFxcdFxcdHZhciBkYXRhID0gZGF0YVVyaVJlZ2V4UmVzdWx0WyAzIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZGF0YSA9IHdpbmRvdy5kZWNvZGVVUklDb21wb25lbnQoIGRhdGEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGlzQmFzZTY0ICkgZGF0YSA9IHdpbmRvdy5hdG9iKCBkYXRhICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dHJ5IHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgcmVzcG9uc2U7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHJlc3BvbnNlVHlwZSA9ICggdGhpcy5yZXNwb25zZVR5cGUgfHwgJycgKS50b0xvd2VyQ2FzZSgpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHN3aXRjaCAoIHJlc3BvbnNlVHlwZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdhcnJheWJ1ZmZlcic6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnYmxvYic6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIHZpZXcgPSBuZXcgVWludDhBcnJheSggZGF0YS5sZW5ndGggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR2aWV3WyBpIF0gPSBkYXRhLmNoYXJDb2RlQXQoIGkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCByZXNwb25zZVR5cGUgPT09ICdibG9iJyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXNwb25zZSA9IG5ldyBCbG9iKCBbIHZpZXcuYnVmZmVyIF0sIHsgdHlwZTogbWltZVR5cGUgfSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzcG9uc2UgPSB2aWV3LmJ1ZmZlcjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnZG9jdW1lbnQnOlxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzcG9uc2UgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBtaW1lVHlwZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ2pzb24nOlxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc3BvbnNlID0gSlNPTi5wYXJzZSggZGF0YSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGRlZmF1bHQ6IC8vICd0ZXh0JyBvciBvdGhlclxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc3BvbnNlID0gZGF0YTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gV2FpdCBmb3IgbmV4dCBicm93c2VyIHRpY2sgbGlrZSBzdGFuZGFyZCBYTUxIdHRwUmVxdWVzdCBldmVudCBkaXNwYXRjaGluZyBkb2VzXFxyXFxuXFx0XFx0XFx0XFx0XFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG9uTG9hZCApIG9uTG9hZCggcmVzcG9uc2UgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH0sIDAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9IGNhdGNoICggZXJyb3IgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gV2FpdCBmb3IgbmV4dCBicm93c2VyIHRpY2sgbGlrZSBzdGFuZGFyZCBYTUxIdHRwUmVxdWVzdCBldmVudCBkaXNwYXRjaGluZyBkb2VzXFxyXFxuXFx0XFx0XFx0XFx0XFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG9uRXJyb3IgKSBvbkVycm9yKCBlcnJvciApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH0sIDAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBJbml0aWFsaXNlIGFycmF5IGZvciBkdXBsaWNhdGUgcmVxdWVzdHNcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRsb2FkaW5nWyB1cmwgXSA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGxvYWRpbmdbIHVybCBdLnB1c2goIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRvbkxvYWQ6IG9uTG9hZCxcXHJcXG5cXHRcXHRcXHRcXHRcXHRvblByb2dyZXNzOiBvblByb2dyZXNzLFxcclxcblxcdFxcdFxcdFxcdFxcdG9uRXJyb3I6IG9uRXJyb3JcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXF1ZXN0Lm9wZW4oICdHRVQnLCB1cmwsIHRydWUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgZnVuY3Rpb24gKCBldmVudCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgcmVzcG9uc2UgPSB0aGlzLnJlc3BvbnNlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdENhY2hlLmFkZCggdXJsLCByZXNwb25zZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBjYWxsYmFja3MgPSBsb2FkaW5nWyB1cmwgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRkZWxldGUgbG9hZGluZ1sgdXJsIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0aGlzLnN0YXR1cyA9PT0gMjAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGNhbGxiYWNrID0gY2FsbGJhY2tzWyBpIF07XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBjYWxsYmFjay5vbkxvYWQgKSBjYWxsYmFjay5vbkxvYWQoIHJlc3BvbnNlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICggdGhpcy5zdGF0dXMgPT09IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gU29tZSBicm93c2VycyByZXR1cm4gSFRUUCBTdGF0dXMgMCB3aGVuIHVzaW5nIG5vbi1odHRwIHByb3RvY29sXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gZS5nLiAnZmlsZTovLycgb3IgJ2RhdGE6Ly8nLiBIYW5kbGUgYXMgc3VjY2Vzcy5cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5GaWxlTG9hZGVyOiBIVFRQIFN0YXR1cyAwIHJlY2VpdmVkLicgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBjYWxsYmFjayA9IGNhbGxiYWNrc1sgaSBdO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggY2FsbGJhY2sub25Mb2FkICkgY2FsbGJhY2sub25Mb2FkKCByZXNwb25zZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgY2FsbGJhY2sgPSBjYWxsYmFja3NbIGkgXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGNhbGxiYWNrLm9uRXJyb3IgKSBjYWxsYmFjay5vbkVycm9yKCBldmVudCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSwgZmFsc2UgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoICdwcm9ncmVzcycsIGZ1bmN0aW9uICggZXZlbnQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGNhbGxiYWNrcyA9IGxvYWRpbmdbIHVybCBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGNhbGxiYWNrID0gY2FsbGJhY2tzWyBpIF07XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBjYWxsYmFjay5vblByb2dyZXNzICkgY2FsbGJhY2sub25Qcm9ncmVzcyggZXZlbnQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSwgZmFsc2UgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoICdlcnJvcicsIGZ1bmN0aW9uICggZXZlbnQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGNhbGxiYWNrcyA9IGxvYWRpbmdbIHVybCBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGRlbGV0ZSBsb2FkaW5nWyB1cmwgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBjYWxsYmFjayA9IGNhbGxiYWNrc1sgaSBdO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggY2FsbGJhY2sub25FcnJvciApIGNhbGxiYWNrLm9uRXJyb3IoIGV2ZW50ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0sIGZhbHNlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB0aGlzLnJlc3BvbnNlVHlwZSAhPT0gdW5kZWZpbmVkICkgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSB0aGlzLnJlc3BvbnNlVHlwZTtcXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHRoaXMud2l0aENyZWRlbnRpYWxzICE9PSB1bmRlZmluZWQgKSByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggcmVxdWVzdC5vdmVycmlkZU1pbWVUeXBlICkgcmVxdWVzdC5vdmVycmlkZU1pbWVUeXBlKCB0aGlzLm1pbWVUeXBlICE9PSB1bmRlZmluZWQgPyB0aGlzLm1pbWVUeXBlIDogJ3RleHQvcGxhaW4nICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGhlYWRlciBpbiB0aGlzLnJlcXVlc3RIZWFkZXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKCBoZWFkZXIsIHRoaXMucmVxdWVzdEhlYWRlclsgaGVhZGVyIF0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmVxdWVzdC5zZW5kKCBudWxsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gcmVxdWVzdDtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldFBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5wYXRoID0gdmFsdWU7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRSZXNwb25zZVR5cGU6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5yZXNwb25zZVR5cGUgPSB2YWx1ZTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldFdpdGhDcmVkZW50aWFsczogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLndpdGhDcmVkZW50aWFscyA9IHZhbHVlO1xcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0TWltZVR5cGU6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5taW1lVHlwZSA9IHZhbHVlO1xcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnJlcXVlc3RIZWFkZXIgPSB2YWx1ZTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBBYnN0cmFjdCBCYXNlIGNsYXNzIHRvIGJsb2NrIGJhc2VkIHRleHR1cmVzIGxvYWRlciAoZGRzLCBwdnIsIC4uLilcXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBDb21wcmVzc2VkVGV4dHVyZUxvYWRlciggbWFuYWdlciApIHtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcXHJcXG5cXHJcXG5cXHRcXHQvLyBvdmVycmlkZSBpbiBzdWIgY2xhc3Nlc1xcclxcblxcdFxcdHRoaXMuX3BhcnNlciA9IG51bGw7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIENvbXByZXNzZWRUZXh0dXJlTG9hZGVyLnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHNjb3BlID0gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgaW1hZ2VzID0gW107XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHRleHR1cmUgPSBuZXcgQ29tcHJlc3NlZFRleHR1cmUoKTtcXHJcXG5cXHRcXHRcXHR0ZXh0dXJlLmltYWdlID0gaW1hZ2VzO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XFxyXFxuXFx0XFx0XFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xcclxcblxcdFxcdFxcdGxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdhcnJheWJ1ZmZlcicgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmdW5jdGlvbiBsb2FkVGV4dHVyZSggaSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRsb2FkZXIubG9hZCggdXJsWyBpIF0sIGZ1bmN0aW9uICggYnVmZmVyICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciB0ZXhEYXRhcyA9IHNjb3BlLl9wYXJzZXIoIGJ1ZmZlciwgdHJ1ZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGltYWdlc1sgaSBdID0ge1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHdpZHRoOiB0ZXhEYXRhcy53aWR0aCxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRoZWlnaHQ6IHRleERhdGFzLmhlaWdodCxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3JtYXQ6IHRleERhdGFzLmZvcm1hdCxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRtaXBtYXBzOiB0ZXhEYXRhcy5taXBtYXBzXFxyXFxuXFx0XFx0XFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRsb2FkZWQgKz0gMTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGxvYWRlZCA9PT0gNiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHRleERhdGFzLm1pcG1hcENvdW50ID09PSAxIClcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggQXJyYXkuaXNBcnJheSggdXJsICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGxvYWRlZCA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHVybC5sZW5ndGg7IGkgPCBpbDsgKysgaSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRsb2FkVGV4dHVyZSggaSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGNvbXByZXNzZWQgY3ViZW1hcCB0ZXh0dXJlIHN0b3JlZCBpbiBhIHNpbmdsZSBERFMgZmlsZVxcclxcblxcclxcblxcdFxcdFxcdFxcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggYnVmZmVyICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciB0ZXhEYXRhcyA9IHNjb3BlLl9wYXJzZXIoIGJ1ZmZlciwgdHJ1ZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggdGV4RGF0YXMuaXNDdWJlbWFwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBmYWNlcyA9IHRleERhdGFzLm1pcG1hcHMubGVuZ3RoIC8gdGV4RGF0YXMubWlwbWFwQ291bnQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGYgPSAwOyBmIDwgZmFjZXM7IGYgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aW1hZ2VzWyBmIF0gPSB7IG1pcG1hcHM6IFtdIH07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGV4RGF0YXMubWlwbWFwQ291bnQ7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aW1hZ2VzWyBmIF0ubWlwbWFwcy5wdXNoKCB0ZXhEYXRhcy5taXBtYXBzWyBmICogdGV4RGF0YXMubWlwbWFwQ291bnQgKyBpIF0gKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpbWFnZXNbIGYgXS5mb3JtYXQgPSB0ZXhEYXRhcy5mb3JtYXQ7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aW1hZ2VzWyBmIF0ud2lkdGggPSB0ZXhEYXRhcy53aWR0aDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpbWFnZXNbIGYgXS5oZWlnaHQgPSB0ZXhEYXRhcy5oZWlnaHQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHRleHR1cmUuaW1hZ2Uud2lkdGggPSB0ZXhEYXRhcy53aWR0aDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLmltYWdlLmhlaWdodCA9IHRleERhdGFzLmhlaWdodDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLm1pcG1hcHMgPSB0ZXhEYXRhcy5taXBtYXBzO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHRleERhdGFzLm1pcG1hcENvdW50ID09PSAxICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcXHJcXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRleHR1cmU7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMucGF0aCA9IHZhbHVlO1xcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBOaWtvcyBNLiAvIGh0dHBzOi8vZ2l0aHViLmNvbS9mb28xMjMvXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBBYnN0cmFjdCBCYXNlIGNsYXNzIHRvIGxvYWQgZ2VuZXJpYyBiaW5hcnkgdGV4dHVyZXMgZm9ybWF0cyAocmdiZSwgaGRyLCAuLi4pXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gRGF0YVRleHR1cmVMb2FkZXIoIG1hbmFnZXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gb3ZlcnJpZGUgaW4gc3ViIGNsYXNzZXNcXHJcXG5cXHRcXHR0aGlzLl9wYXJzZXIgPSBudWxsO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRPYmplY3QuYXNzaWduKCBEYXRhVGV4dHVyZUxvYWRlci5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBzY29wZSA9IHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHRleHR1cmUgPSBuZXcgRGF0YVRleHR1cmUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xcclxcblxcdFxcdFxcdGxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdhcnJheWJ1ZmZlcicgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgdGV4RGF0YSA9IHNjb3BlLl9wYXJzZXIoIGJ1ZmZlciApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggISB0ZXhEYXRhICkgcmV0dXJuO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmltYWdlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHRleHR1cmUuaW1hZ2UgPSB0ZXhEYXRhLmltYWdlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5kYXRhICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHRleHR1cmUuaW1hZ2Uud2lkdGggPSB0ZXhEYXRhLndpZHRoO1xcclxcblxcdFxcdFxcdFxcdFxcdHRleHR1cmUuaW1hZ2UuaGVpZ2h0ID0gdGV4RGF0YS5oZWlnaHQ7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dGV4dHVyZS5pbWFnZS5kYXRhID0gdGV4RGF0YS5kYXRhO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlLndyYXBTID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLndyYXBTID8gdGV4RGF0YS53cmFwUyA6IENsYW1wVG9FZGdlV3JhcHBpbmc7XFxyXFxuXFx0XFx0XFx0XFx0dGV4dHVyZS53cmFwVCA9IHVuZGVmaW5lZCAhPT0gdGV4RGF0YS53cmFwVCA/IHRleERhdGEud3JhcFQgOiBDbGFtcFRvRWRnZVdyYXBwaW5nO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRleHR1cmUubWFnRmlsdGVyID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLm1hZ0ZpbHRlciA/IHRleERhdGEubWFnRmlsdGVyIDogTGluZWFyRmlsdGVyO1xcclxcblxcdFxcdFxcdFxcdHRleHR1cmUubWluRmlsdGVyID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLm1pbkZpbHRlciA/IHRleERhdGEubWluRmlsdGVyIDogTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRleHR1cmUuYW5pc290cm9weSA9IHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5hbmlzb3Ryb3B5ID8gdGV4RGF0YS5hbmlzb3Ryb3B5IDogMTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5mb3JtYXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhLmZvcm1hdDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEudHlwZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLnR5cGUgPSB0ZXhEYXRhLnR5cGU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLm1pcG1hcHMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGV4dHVyZS5taXBtYXBzID0gdGV4RGF0YS5taXBtYXBzO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIDEgPT09IHRleERhdGEubWlwbWFwQ291bnQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlLCB0ZXhEYXRhICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xcclxcblxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0ZXh0dXJlO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBJbWFnZUxvYWRlciggbWFuYWdlciApIHtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0T2JqZWN0LmFzc2lnbiggSW1hZ2VMb2FkZXIucHJvdG90eXBlLCB7XFxyXFxuXFxyXFxuXFx0XFx0Y3Jvc3NPcmlnaW46ICdBbm9ueW1vdXMnLFxcclxcblxcclxcblxcdFxcdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB1cmwgPT09IHVuZGVmaW5lZCApIHVybCA9ICcnO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5wYXRoICE9PSB1bmRlZmluZWQgKSB1cmwgPSB0aGlzLnBhdGggKyB1cmw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dXJsID0gdGhpcy5tYW5hZ2VyLnJlc29sdmVVUkwoIHVybCApO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBzY29wZSA9IHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGNhY2hlZCA9IENhY2hlLmdldCggdXJsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBjYWNoZWQgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0c2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggb25Mb2FkICkgb25Mb2FkKCBjYWNoZWQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0sIDAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gY2FjaGVkO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJywgJ2ltZycgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpbWFnZS5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRDYWNoZS5hZGQoIHVybCwgdGhpcyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggb25Mb2FkICkgb25Mb2FkKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9LCBmYWxzZSApO1xcclxcblxcclxcblxcdFxcdFxcdC8qXFxyXFxuXFx0XFx0XFx0aW1hZ2UuYWRkRXZlbnRMaXN0ZW5lciggJ3Byb2dyZXNzJywgZnVuY3Rpb24gKCBldmVudCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIG9uUHJvZ3Jlc3MgKSBvblByb2dyZXNzKCBldmVudCApO1xcclxcblxcclxcblxcdFxcdFxcdH0sIGZhbHNlICk7XFxyXFxuXFx0XFx0XFx0Ki9cXHJcXG5cXHJcXG5cXHRcXHRcXHRpbWFnZS5hZGRFdmVudExpc3RlbmVyKCAnZXJyb3InLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggb25FcnJvciApIG9uRXJyb3IoIGV2ZW50ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcXHJcXG5cXHRcXHRcXHRcXHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSwgZmFsc2UgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHVybC5zdWJzdHIoIDAsIDUgKSAhPT0gJ2RhdGE6JyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHRoaXMuY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCApIGltYWdlLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xcclxcblxcclxcblxcdFxcdFxcdGltYWdlLnNyYyA9IHVybDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gaW1hZ2U7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMucGF0aCA9IHZhbHVlO1xcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBDdWJlVGV4dHVyZUxvYWRlciggbWFuYWdlciApIHtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0T2JqZWN0LmFzc2lnbiggQ3ViZVRleHR1cmVMb2FkZXIucHJvdG90eXBlLCB7XFxyXFxuXFxyXFxuXFx0XFx0Y3Jvc3NPcmlnaW46ICdBbm9ueW1vdXMnLFxcclxcblxcclxcblxcdFxcdGxvYWQ6IGZ1bmN0aW9uICggdXJscywgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB0ZXh0dXJlID0gbmV3IEN1YmVUZXh0dXJlKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGxvYWRlciA9IG5ldyBJbWFnZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XFxyXFxuXFx0XFx0XFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XFxyXFxuXFx0XFx0XFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBsb2FkZWQgPSAwO1xcclxcblxcclxcblxcdFxcdFxcdGZ1bmN0aW9uIGxvYWRUZXh0dXJlKCBpICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGxvYWRlci5sb2FkKCB1cmxzWyBpIF0sIGZ1bmN0aW9uICggaW1hZ2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGV4dHVyZS5pbWFnZXNbIGkgXSA9IGltYWdlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGxvYWRlZCArKztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGxvYWRlZCA9PT0gNiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9LCB1bmRlZmluZWQsIG9uRXJyb3IgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdXJscy5sZW5ndGg7ICsrIGkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bG9hZFRleHR1cmUoIGkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRleHR1cmU7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMucGF0aCA9IHZhbHVlO1xcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBUZXh0dXJlTG9hZGVyKCBtYW5hZ2VyICkge1xcclxcblxcclxcblxcdFxcdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRPYmplY3QuYXNzaWduKCBUZXh0dXJlTG9hZGVyLnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdGNyb3NzT3JpZ2luOiAnQW5vbnltb3VzJyxcXHJcXG5cXHJcXG5cXHRcXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB0ZXh0dXJlID0gbmV3IFRleHR1cmUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbG9hZGVyID0gbmV3IEltYWdlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcXHJcXG5cXHRcXHRcXHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcXHJcXG5cXHRcXHRcXHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBpbWFnZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlLmltYWdlID0gaW1hZ2U7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gSlBFR3MgY2FuJ3QgaGF2ZSBhbiBhbHBoYSBjaGFubmVsLCBzbyBtZW1vcnkgY2FuIGJlIHNhdmVkIGJ5IHN0b3JpbmcgdGhlbSBhcyBSR0IuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGlzSlBFRyA9IHVybC5zZWFyY2goIC9cXFxcLihqcGd8anBlZykkLyApID4gMCB8fCB1cmwuc2VhcmNoKCAvXmRhdGFcXFxcOmltYWdlXFxcXC9qcGVnLyApID09PSAwO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRleHR1cmUuZm9ybWF0ID0gaXNKUEVHID8gUkdCRm9ybWF0IDogUkdCQUZvcm1hdDtcXHJcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdG9uTG9hZCggdGV4dHVyZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRleHR1cmU7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMucGF0aCA9IHZhbHVlO1xcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xcclxcblxcdCAqIEV4dGVuc2libGUgY3VydmUgb2JqZWN0XFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBTb21lIGNvbW1vbiBvZiBjdXJ2ZSBtZXRob2RzOlxcclxcblxcdCAqIC5nZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgKSwgLmdldFRhbmdlbnQoIHQgKVxcclxcblxcdCAqIC5nZXRQb2ludEF0KCB1LCBvcHRpb25hbFRhcmdldCApLCAuZ2V0VGFuZ2VudEF0KCB1IClcXHJcXG5cXHQgKiAuZ2V0UG9pbnRzKCksIC5nZXRTcGFjZWRQb2ludHMoKVxcclxcblxcdCAqIC5nZXRMZW5ndGgoKVxcclxcblxcdCAqIC51cGRhdGVBcmNMZW5ndGhzKClcXHJcXG5cXHQgKlxcclxcblxcdCAqIFRoaXMgZm9sbG93aW5nIGN1cnZlcyBpbmhlcml0IGZyb20gVEhSRUUuQ3VydmU6XFxyXFxuXFx0ICpcXHJcXG5cXHQgKiAtLSAyRCBjdXJ2ZXMgLS1cXHJcXG5cXHQgKiBUSFJFRS5BcmNDdXJ2ZVxcclxcblxcdCAqIFRIUkVFLkN1YmljQmV6aWVyQ3VydmVcXHJcXG5cXHQgKiBUSFJFRS5FbGxpcHNlQ3VydmVcXHJcXG5cXHQgKiBUSFJFRS5MaW5lQ3VydmVcXHJcXG5cXHQgKiBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZVxcclxcblxcdCAqIFRIUkVFLlNwbGluZUN1cnZlXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiAtLSAzRCBjdXJ2ZXMgLS1cXHJcXG5cXHQgKiBUSFJFRS5DYXRtdWxsUm9tQ3VydmUzXFxyXFxuXFx0ICogVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZTNcXHJcXG5cXHQgKiBUSFJFRS5MaW5lQ3VydmUzXFxyXFxuXFx0ICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUzXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBBIHNlcmllcyBvZiBjdXJ2ZXMgY2FuIGJlIHJlcHJlc2VudGVkIGFzIGEgVEhSRUUuQ3VydmVQYXRoLlxcclxcblxcdCAqXFxyXFxuXFx0ICoqL1xcclxcblxcclxcblxcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcclxcblxcdCAqXFx0QWJzdHJhY3QgQ3VydmUgYmFzZSBjbGFzc1xcclxcblxcdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBDdXJ2ZSgpIHtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnQ3VydmUnO1xcclxcblxcclxcblxcdFxcdHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zID0gMjAwO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRPYmplY3QuYXNzaWduKCBDdXJ2ZS5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHQvLyBWaXJ0dWFsIGJhc2UgY2xhc3MgbWV0aG9kIHRvIG92ZXJ3cml0ZSBhbmQgaW1wbGVtZW50IGluIHN1YmNsYXNzZXNcXHJcXG5cXHRcXHQvL1xcdC0gdCBbMCAuLiAxXVxcclxcblxcclxcblxcdFxcdGdldFBvaW50OiBmdW5jdGlvbiAoIC8qIHQsIG9wdGlvbmFsVGFyZ2V0ICovICkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkN1cnZlOiAuZ2V0UG9pbnQoKSBub3QgaW1wbGVtZW50ZWQuJyApO1xcclxcblxcdFxcdFxcdHJldHVybiBudWxsO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Ly8gR2V0IHBvaW50IGF0IHJlbGF0aXZlIHBvc2l0aW9uIGluIGN1cnZlIGFjY29yZGluZyB0byBhcmMgbGVuZ3RoXFxyXFxuXFx0XFx0Ly8gLSB1IFswIC4uIDFdXFxyXFxuXFxyXFxuXFx0XFx0Z2V0UG9pbnRBdDogZnVuY3Rpb24gKCB1LCBvcHRpb25hbFRhcmdldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdCA9IHRoaXMuZ2V0VXRvVG1hcHBpbmcoIHUgKTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5nZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdC8vIEdldCBzZXF1ZW5jZSBvZiBwb2ludHMgdXNpbmcgZ2V0UG9pbnQoIHQgKVxcclxcblxcclxcblxcdFxcdGdldFBvaW50czogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCApIGRpdmlzaW9ucyA9IDU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHBvaW50cyA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBkID0gMDsgZCA8PSBkaXZpc2lvbnM7IGQgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cG9pbnRzLnB1c2goIHRoaXMuZ2V0UG9pbnQoIGQgLyBkaXZpc2lvbnMgKSApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gcG9pbnRzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Ly8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludEF0KCB1IClcXHJcXG5cXHJcXG5cXHRcXHRnZXRTcGFjZWRQb2ludHM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggZGl2aXNpb25zID09PSB1bmRlZmluZWQgKSBkaXZpc2lvbnMgPSA1O1xcclxcblxcclxcblxcdFxcdFxcdHZhciBwb2ludHMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHBvaW50cy5wdXNoKCB0aGlzLmdldFBvaW50QXQoIGQgLyBkaXZpc2lvbnMgKSApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gcG9pbnRzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Ly8gR2V0IHRvdGFsIGN1cnZlIGFyYyBsZW5ndGhcXHJcXG5cXHJcXG5cXHRcXHRnZXRMZW5ndGg6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbGVuZ3RocyA9IHRoaXMuZ2V0TGVuZ3RocygpO1xcclxcblxcdFxcdFxcdHJldHVybiBsZW5ndGhzWyBsZW5ndGhzLmxlbmd0aCAtIDEgXTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdC8vIEdldCBsaXN0IG9mIGN1bXVsYXRpdmUgc2VnbWVudCBsZW5ndGhzXFxyXFxuXFxyXFxuXFx0XFx0Z2V0TGVuZ3RoczogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCApIGRpdmlzaW9ucyA9IHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5jYWNoZUFyY0xlbmd0aHMgJiZcXHJcXG5cXHRcXHRcXHRcXHQoIHRoaXMuY2FjaGVBcmNMZW5ndGhzLmxlbmd0aCA9PT0gZGl2aXNpb25zICsgMSApICYmXFxyXFxuXFx0XFx0XFx0XFx0ISB0aGlzLm5lZWRzVXBkYXRlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmNhY2hlQXJjTGVuZ3RocztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBjYWNoZSA9IFtdO1xcclxcblxcdFxcdFxcdHZhciBjdXJyZW50LCBsYXN0ID0gdGhpcy5nZXRQb2ludCggMCApO1xcclxcblxcdFxcdFxcdHZhciBwLCBzdW0gPSAwO1xcclxcblxcclxcblxcdFxcdFxcdGNhY2hlLnB1c2goIDAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCBwID0gMTsgcCA8PSBkaXZpc2lvbnM7IHAgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y3VycmVudCA9IHRoaXMuZ2V0UG9pbnQoIHAgLyBkaXZpc2lvbnMgKTtcXHJcXG5cXHRcXHRcXHRcXHRzdW0gKz0gY3VycmVudC5kaXN0YW5jZVRvKCBsYXN0ICk7XFxyXFxuXFx0XFx0XFx0XFx0Y2FjaGUucHVzaCggc3VtICk7XFxyXFxuXFx0XFx0XFx0XFx0bGFzdCA9IGN1cnJlbnQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHRoaXMuY2FjaGVBcmNMZW5ndGhzID0gY2FjaGU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGNhY2hlOyAvLyB7IHN1bXM6IGNhY2hlLCBzdW06IHN1bSB9OyBTdW0gaXMgaW4gdGhlIGxhc3QgZWxlbWVudC5cXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHVwZGF0ZUFyY0xlbmd0aHM6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXHJcXG5cXHRcXHRcXHR0aGlzLmdldExlbmd0aHMoKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdC8vIEdpdmVuIHUgKCAwIC4uIDEgKSwgZ2V0IGEgdCB0byBmaW5kIHAuIFRoaXMgZ2l2ZXMgeW91IHBvaW50cyB3aGljaCBhcmUgZXF1aWRpc3RhbnRcXHJcXG5cXHJcXG5cXHRcXHRnZXRVdG9UbWFwcGluZzogZnVuY3Rpb24gKCB1LCBkaXN0YW5jZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgYXJjTGVuZ3RocyA9IHRoaXMuZ2V0TGVuZ3RocygpO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBpID0gMCwgaWwgPSBhcmNMZW5ndGhzLmxlbmd0aDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdGFyZ2V0QXJjTGVuZ3RoOyAvLyBUaGUgdGFyZ2V0ZWQgdSBkaXN0YW5jZSB2YWx1ZSB0byBnZXRcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGRpc3RhbmNlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRhcmdldEFyY0xlbmd0aCA9IGRpc3RhbmNlO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGFyZ2V0QXJjTGVuZ3RoID0gdSAqIGFyY0xlbmd0aHNbIGlsIC0gMSBdO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBiaW5hcnkgc2VhcmNoIGZvciB0aGUgaW5kZXggd2l0aCBsYXJnZXN0IHZhbHVlIHNtYWxsZXIgdGhhbiB0YXJnZXQgdSBkaXN0YW5jZVxcclxcblxcclxcblxcdFxcdFxcdHZhciBsb3cgPSAwLCBoaWdoID0gaWwgLSAxLCBjb21wYXJpc29uO1xcclxcblxcclxcblxcdFxcdFxcdHdoaWxlICggbG93IDw9IGhpZ2ggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aSA9IE1hdGguZmxvb3IoIGxvdyArICggaGlnaCAtIGxvdyApIC8gMiApOyAvLyBsZXNzIGxpa2VseSB0byBvdmVyZmxvdywgdGhvdWdoIHByb2JhYmx5IG5vdCBpc3N1ZSBoZXJlLCBKUyBkb2Vzbid0IHJlYWxseSBoYXZlIGludGVnZXJzLCBhbGwgbnVtYmVycyBhcmUgZmxvYXRzXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29tcGFyaXNvbiA9IGFyY0xlbmd0aHNbIGkgXSAtIHRhcmdldEFyY0xlbmd0aDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGNvbXBhcmlzb24gPCAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGxvdyA9IGkgKyAxO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIGNvbXBhcmlzb24gPiAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGhpZ2ggPSBpIC0gMTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGhpZ2ggPSBpO1xcclxcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIERPTkVcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGkgPSBoaWdoO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggYXJjTGVuZ3Roc1sgaSBdID09PSB0YXJnZXRBcmNMZW5ndGggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGkgLyAoIGlsIC0gMSApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyB3ZSBjb3VsZCBnZXQgZmluZXIgZ3JhaW4gYXQgbGVuZ3Rocywgb3IgdXNlIHNpbXBsZSBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHBvaW50c1xcclxcblxcclxcblxcdFxcdFxcdHZhciBsZW5ndGhCZWZvcmUgPSBhcmNMZW5ndGhzWyBpIF07XFxyXFxuXFx0XFx0XFx0dmFyIGxlbmd0aEFmdGVyID0gYXJjTGVuZ3Roc1sgaSArIDEgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgc2VnbWVudExlbmd0aCA9IGxlbmd0aEFmdGVyIC0gbGVuZ3RoQmVmb3JlO1xcclxcblxcclxcblxcdFxcdFxcdC8vIGRldGVybWluZSB3aGVyZSB3ZSBhcmUgYmV0d2VlbiB0aGUgJ2JlZm9yZScgYW5kICdhZnRlcicgcG9pbnRzXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHNlZ21lbnRGcmFjdGlvbiA9ICggdGFyZ2V0QXJjTGVuZ3RoIC0gbGVuZ3RoQmVmb3JlICkgLyBzZWdtZW50TGVuZ3RoO1xcclxcblxcclxcblxcdFxcdFxcdC8vIGFkZCB0aGF0IGZyYWN0aW9uYWwgYW1vdW50IHRvIHRcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdCA9ICggaSArIHNlZ21lbnRGcmFjdGlvbiApIC8gKCBpbCAtIDEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdDtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdC8vIFJldHVybnMgYSB1bml0IHZlY3RvciB0YW5nZW50IGF0IHRcXHJcXG5cXHRcXHQvLyBJbiBjYXNlIGFueSBzdWIgY3VydmUgZG9lcyBub3QgaW1wbGVtZW50IGl0cyB0YW5nZW50IGRlcml2YXRpb24sXFxyXFxuXFx0XFx0Ly8gMiBwb2ludHMgYSBzbWFsbCBkZWx0YSBhcGFydCB3aWxsIGJlIHVzZWQgdG8gZmluZCBpdHMgZ3JhZGllbnRcXHJcXG5cXHRcXHQvLyB3aGljaCBzZWVtcyB0byBnaXZlIGEgcmVhc29uYWJsZSBhcHByb3hpbWF0aW9uXFxyXFxuXFxyXFxuXFx0XFx0Z2V0VGFuZ2VudDogZnVuY3Rpb24gKCB0ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBkZWx0YSA9IDAuMDAwMTtcXHJcXG5cXHRcXHRcXHR2YXIgdDEgPSB0IC0gZGVsdGE7XFxyXFxuXFx0XFx0XFx0dmFyIHQyID0gdCArIGRlbHRhO1xcclxcblxcclxcblxcdFxcdFxcdC8vIENhcHBpbmcgaW4gY2FzZSBvZiBkYW5nZXJcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHQxIDwgMCApIHQxID0gMDtcXHJcXG5cXHRcXHRcXHRpZiAoIHQyID4gMSApIHQyID0gMTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcHQxID0gdGhpcy5nZXRQb2ludCggdDEgKTtcXHJcXG5cXHRcXHRcXHR2YXIgcHQyID0gdGhpcy5nZXRQb2ludCggdDIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdmVjID0gcHQyLmNsb25lKCkuc3ViKCBwdDEgKTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gdmVjLm5vcm1hbGl6ZSgpO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Z2V0VGFuZ2VudEF0OiBmdW5jdGlvbiAoIHUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHQgPSB0aGlzLmdldFV0b1RtYXBwaW5nKCB1ICk7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2V0VGFuZ2VudCggdCApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y29tcHV0ZUZyZW5ldEZyYW1lczogZnVuY3Rpb24gKCBzZWdtZW50cywgY2xvc2VkICkge1xcclxcblxcclxcblxcdFxcdFxcdC8vIHNlZSBodHRwOi8vd3d3LmNzLmluZGlhbmEuZWR1L3B1Yi90ZWNocmVwb3J0cy9UUjQyNS5wZGZcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdGFuZ2VudHMgPSBbXTtcXHJcXG5cXHRcXHRcXHR2YXIgbm9ybWFscyA9IFtdO1xcclxcblxcdFxcdFxcdHZhciBiaW5vcm1hbHMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdmVjID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHRcXHRcXHR2YXIgbWF0ID0gbmV3IE1hdHJpeDQoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgaSwgdSwgdGhldGE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gY29tcHV0ZSB0aGUgdGFuZ2VudCB2ZWN0b3JzIGZvciBlYWNoIHNlZ21lbnQgb24gdGhlIGN1cnZlXFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggaSA9IDA7IGkgPD0gc2VnbWVudHM7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dSA9IGkgLyBzZWdtZW50cztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0YW5nZW50c1sgaSBdID0gdGhpcy5nZXRUYW5nZW50QXQoIHUgKTtcXHJcXG5cXHRcXHRcXHRcXHR0YW5nZW50c1sgaSBdLm5vcm1hbGl6ZSgpO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBzZWxlY3QgYW4gaW5pdGlhbCBub3JtYWwgdmVjdG9yIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGZpcnN0IHRhbmdlbnQgdmVjdG9yLFxcclxcblxcdFxcdFxcdC8vIGFuZCBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBtaW5pbXVtIHRhbmdlbnQgeHl6IGNvbXBvbmVudFxcclxcblxcclxcblxcdFxcdFxcdG5vcm1hbHNbIDAgXSA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0XFx0Ymlub3JtYWxzWyAwIF0gPSBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdFxcdHZhciBtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xcclxcblxcdFxcdFxcdHZhciB0eCA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnggKTtcXHJcXG5cXHRcXHRcXHR2YXIgdHkgPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS55ICk7XFxyXFxuXFx0XFx0XFx0dmFyIHR6ID0gTWF0aC5hYnMoIHRhbmdlbnRzWyAwIF0ueiApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdHggPD0gbWluICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdG1pbiA9IHR4O1xcclxcblxcdFxcdFxcdFxcdG5vcm1hbC5zZXQoIDEsIDAsIDAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0eSA8PSBtaW4gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bWluID0gdHk7XFxyXFxuXFx0XFx0XFx0XFx0bm9ybWFsLnNldCggMCwgMSwgMCApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHR6IDw9IG1pbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRub3JtYWwuc2V0KCAwLCAwLCAxICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHZlYy5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbCApLm5vcm1hbGl6ZSgpO1xcclxcblxcclxcblxcdFxcdFxcdG5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIHZlYyApO1xcclxcblxcdFxcdFxcdGJpbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICk7XFxyXFxuXFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gY29tcHV0ZSB0aGUgc2xvd2x5LXZhcnlpbmcgbm9ybWFsIGFuZCBiaW5vcm1hbCB2ZWN0b3JzIGZvciBlYWNoIHNlZ21lbnQgb24gdGhlIGN1cnZlXFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggaSA9IDE7IGkgPD0gc2VnbWVudHM7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bm9ybWFsc1sgaSBdID0gbm9ybWFsc1sgaSAtIDEgXS5jbG9uZSgpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGJpbm9ybWFsc1sgaSBdID0gYmlub3JtYWxzWyBpIC0gMSBdLmNsb25lKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmVjLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgLSAxIF0sIHRhbmdlbnRzWyBpIF0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHZlYy5sZW5ndGgoKSA+IE51bWJlci5FUFNJTE9OICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZlYy5ub3JtYWxpemUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGV0YSA9IE1hdGguYWNvcyggX01hdGguY2xhbXAoIHRhbmdlbnRzWyBpIC0gMSBdLmRvdCggdGFuZ2VudHNbIGkgXSApLCAtIDEsIDEgKSApOyAvLyBjbGFtcCBmb3IgZmxvYXRpbmcgcHQgZXJyb3JzXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgaSBdLmFwcGx5TWF0cml4NCggbWF0Lm1ha2VSb3RhdGlvbkF4aXMoIHZlYywgdGhldGEgKSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRiaW5vcm1hbHNbIGkgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIF0sIG5vcm1hbHNbIGkgXSApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBpZiB0aGUgY3VydmUgaXMgY2xvc2VkLCBwb3N0cHJvY2VzcyB0aGUgdmVjdG9ycyBzbyB0aGUgZmlyc3QgYW5kIGxhc3Qgbm9ybWFsIHZlY3RvcnMgYXJlIHRoZSBzYW1lXFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBjbG9zZWQgPT09IHRydWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhldGEgPSBNYXRoLmFjb3MoIF9NYXRoLmNsYW1wKCBub3JtYWxzWyAwIF0uZG90KCBub3JtYWxzWyBzZWdtZW50cyBdICksIC0gMSwgMSApICk7XFxyXFxuXFx0XFx0XFx0XFx0dGhldGEgLz0gc2VnbWVudHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB0YW5nZW50c1sgMCBdLmRvdCggdmVjLmNyb3NzVmVjdG9ycyggbm9ybWFsc1sgMCBdLCBub3JtYWxzWyBzZWdtZW50cyBdICkgKSA+IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhldGEgPSAtIHRoZXRhO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCBpID0gMTsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyB0d2lzdCBhIGxpdHRsZS4uLlxcclxcblxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIGkgXS5hcHBseU1hdHJpeDQoIG1hdC5tYWtlUm90YXRpb25BeGlzKCB0YW5nZW50c1sgaSBdLCB0aGV0YSAqIGkgKSApO1xcclxcblxcdFxcdFxcdFxcdFxcdGJpbm9ybWFsc1sgaSBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgXSwgbm9ybWFsc1sgaSBdICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4ge1xcclxcblxcdFxcdFxcdFxcdHRhbmdlbnRzOiB0YW5nZW50cyxcXHJcXG5cXHRcXHRcXHRcXHRub3JtYWxzOiBub3JtYWxzLFxcclxcblxcdFxcdFxcdFxcdGJpbm9ybWFsczogYmlub3JtYWxzXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5hcmNMZW5ndGhEaXZpc2lvbnMgPSBzb3VyY2UuYXJjTGVuZ3RoRGl2aXNpb25zO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGRhdGEgPSB7XFxyXFxuXFx0XFx0XFx0XFx0bWV0YWRhdGE6IHtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2ZXJzaW9uOiA0LjUsXFxyXFxuXFx0XFx0XFx0XFx0XFx0dHlwZTogJ0N1cnZlJyxcXHJcXG5cXHRcXHRcXHRcXHRcXHRnZW5lcmF0b3I6ICdDdXJ2ZS50b0pTT04nXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZGF0YS5hcmNMZW5ndGhEaXZpc2lvbnMgPSB0aGlzLmFyY0xlbmd0aERpdmlzaW9ucztcXHJcXG5cXHRcXHRcXHRkYXRhLnR5cGUgPSB0aGlzLnR5cGU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGRhdGE7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRmcm9tSlNPTjogZnVuY3Rpb24gKCBqc29uICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zID0ganNvbi5hcmNMZW5ndGhEaXZpc2lvbnM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBFbGxpcHNlQ3VydmUoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICkge1xcclxcblxcclxcblxcdFxcdEN1cnZlLmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnRWxsaXBzZUN1cnZlJztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmFYID0gYVggfHwgMDtcXHJcXG5cXHRcXHR0aGlzLmFZID0gYVkgfHwgMDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnhSYWRpdXMgPSB4UmFkaXVzIHx8IDE7XFxyXFxuXFx0XFx0dGhpcy55UmFkaXVzID0geVJhZGl1cyB8fCAxO1xcclxcblxcclxcblxcdFxcdHRoaXMuYVN0YXJ0QW5nbGUgPSBhU3RhcnRBbmdsZSB8fCAwO1xcclxcblxcdFxcdHRoaXMuYUVuZEFuZ2xlID0gYUVuZEFuZ2xlIHx8IDIgKiBNYXRoLlBJO1xcclxcblxcclxcblxcdFxcdHRoaXMuYUNsb2Nrd2lzZSA9IGFDbG9ja3dpc2UgfHwgZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5hUm90YXRpb24gPSBhUm90YXRpb24gfHwgMDtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0RWxsaXBzZUN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN1cnZlLnByb3RvdHlwZSApO1xcclxcblxcdEVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFbGxpcHNlQ3VydmU7XFxyXFxuXFxyXFxuXFx0RWxsaXBzZUN1cnZlLnByb3RvdHlwZS5pc0VsbGlwc2VDdXJ2ZSA9IHRydWU7XFxyXFxuXFxyXFxuXFx0RWxsaXBzZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHBvaW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjIoKTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgdHdvUGkgPSBNYXRoLlBJICogMjtcXHJcXG5cXHRcXHR2YXIgZGVsdGFBbmdsZSA9IHRoaXMuYUVuZEFuZ2xlIC0gdGhpcy5hU3RhcnRBbmdsZTtcXHJcXG5cXHRcXHR2YXIgc2FtZVBvaW50cyA9IE1hdGguYWJzKCBkZWx0YUFuZ2xlICkgPCBOdW1iZXIuRVBTSUxPTjtcXHJcXG5cXHJcXG5cXHRcXHQvLyBlbnN1cmVzIHRoYXQgZGVsdGFBbmdsZSBpcyAwIC4uIDIgUElcXHJcXG5cXHRcXHR3aGlsZSAoIGRlbHRhQW5nbGUgPCAwICkgZGVsdGFBbmdsZSArPSB0d29QaTtcXHJcXG5cXHRcXHR3aGlsZSAoIGRlbHRhQW5nbGUgPiB0d29QaSApIGRlbHRhQW5nbGUgLT0gdHdvUGk7XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCBkZWx0YUFuZ2xlIDwgTnVtYmVyLkVQU0lMT04gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBzYW1lUG9pbnRzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGRlbHRhQW5nbGUgPSAwO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZGVsdGFBbmdsZSA9IHR3b1BpO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCB0aGlzLmFDbG9ja3dpc2UgPT09IHRydWUgJiYgISBzYW1lUG9pbnRzICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggZGVsdGFBbmdsZSA9PT0gdHdvUGkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZGVsdGFBbmdsZSA9IC0gdHdvUGk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRkZWx0YUFuZ2xlID0gZGVsdGFBbmdsZSAtIHR3b1BpO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGFuZ2xlID0gdGhpcy5hU3RhcnRBbmdsZSArIHQgKiBkZWx0YUFuZ2xlO1xcclxcblxcdFxcdHZhciB4ID0gdGhpcy5hWCArIHRoaXMueFJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xcclxcblxcdFxcdHZhciB5ID0gdGhpcy5hWSArIHRoaXMueVJhZGl1cyAqIE1hdGguc2luKCBhbmdsZSApO1xcclxcblxcclxcblxcdFxcdGlmICggdGhpcy5hUm90YXRpb24gIT09IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGNvcyA9IE1hdGguY29zKCB0aGlzLmFSb3RhdGlvbiApO1xcclxcblxcdFxcdFxcdHZhciBzaW4gPSBNYXRoLnNpbiggdGhpcy5hUm90YXRpb24gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdHggPSB4IC0gdGhpcy5hWDtcXHJcXG5cXHRcXHRcXHR2YXIgdHkgPSB5IC0gdGhpcy5hWTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBSb3RhdGUgdGhlIHBvaW50IGFib3V0IHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2UuXFxyXFxuXFx0XFx0XFx0eCA9IHR4ICogY29zIC0gdHkgKiBzaW4gKyB0aGlzLmFYO1xcclxcblxcdFxcdFxcdHkgPSB0eCAqIHNpbiArIHR5ICogY29zICsgdGhpcy5hWTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHBvaW50LnNldCggeCwgeSApO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0RWxsaXBzZUN1cnZlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Q3VydmUucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5hWCA9IHNvdXJjZS5hWDtcXHJcXG5cXHRcXHR0aGlzLmFZID0gc291cmNlLmFZO1xcclxcblxcclxcblxcdFxcdHRoaXMueFJhZGl1cyA9IHNvdXJjZS54UmFkaXVzO1xcclxcblxcdFxcdHRoaXMueVJhZGl1cyA9IHNvdXJjZS55UmFkaXVzO1xcclxcblxcclxcblxcdFxcdHRoaXMuYVN0YXJ0QW5nbGUgPSBzb3VyY2UuYVN0YXJ0QW5nbGU7XFxyXFxuXFx0XFx0dGhpcy5hRW5kQW5nbGUgPSBzb3VyY2UuYUVuZEFuZ2xlO1xcclxcblxcclxcblxcdFxcdHRoaXMuYUNsb2Nrd2lzZSA9IHNvdXJjZS5hQ2xvY2t3aXNlO1xcclxcblxcclxcblxcdFxcdHRoaXMuYVJvdGF0aW9uID0gc291cmNlLmFSb3RhdGlvbjtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHR9O1xcclxcblxcclxcblxcclxcblxcdEVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdHZhciBkYXRhID0gQ3VydmUucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0ZGF0YS5hWCA9IHRoaXMuYVg7XFxyXFxuXFx0XFx0ZGF0YS5hWSA9IHRoaXMuYVk7XFxyXFxuXFxyXFxuXFx0XFx0ZGF0YS54UmFkaXVzID0gdGhpcy54UmFkaXVzO1xcclxcblxcdFxcdGRhdGEueVJhZGl1cyA9IHRoaXMueVJhZGl1cztcXHJcXG5cXHJcXG5cXHRcXHRkYXRhLmFTdGFydEFuZ2xlID0gdGhpcy5hU3RhcnRBbmdsZTtcXHJcXG5cXHRcXHRkYXRhLmFFbmRBbmdsZSA9IHRoaXMuYUVuZEFuZ2xlO1xcclxcblxcclxcblxcdFxcdGRhdGEuYUNsb2Nrd2lzZSA9IHRoaXMuYUNsb2Nrd2lzZTtcXHJcXG5cXHJcXG5cXHRcXHRkYXRhLmFSb3RhdGlvbiA9IHRoaXMuYVJvdGF0aW9uO1xcclxcblxcclxcblxcdFxcdHJldHVybiBkYXRhO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0RWxsaXBzZUN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uICgganNvbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04uY2FsbCggdGhpcywganNvbiApO1xcclxcblxcclxcblxcdFxcdHRoaXMuYVggPSBqc29uLmFYO1xcclxcblxcdFxcdHRoaXMuYVkgPSBqc29uLmFZO1xcclxcblxcclxcblxcdFxcdHRoaXMueFJhZGl1cyA9IGpzb24ueFJhZGl1cztcXHJcXG5cXHRcXHR0aGlzLnlSYWRpdXMgPSBqc29uLnlSYWRpdXM7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5hU3RhcnRBbmdsZSA9IGpzb24uYVN0YXJ0QW5nbGU7XFxyXFxuXFx0XFx0dGhpcy5hRW5kQW5nbGUgPSBqc29uLmFFbmRBbmdsZTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmFDbG9ja3dpc2UgPSBqc29uLmFDbG9ja3dpc2U7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5hUm90YXRpb24gPSBqc29uLmFSb3RhdGlvbjtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHR9O1xcclxcblxcclxcblxcdGZ1bmN0aW9uIEFyY0N1cnZlKCBhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0RWxsaXBzZUN1cnZlLmNhbGwoIHRoaXMsIGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdBcmNDdXJ2ZSc7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdEFyY0N1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUgKTtcXHJcXG5cXHRBcmNDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBcmNDdXJ2ZTtcXHJcXG5cXHJcXG5cXHRBcmNDdXJ2ZS5wcm90b3R5cGUuaXNBcmNDdXJ2ZSA9IHRydWU7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciB6ejg1IGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1XFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBDZW50cmlwZXRhbCBDYXRtdWxsUm9tIEN1cnZlIC0gd2hpY2ggaXMgdXNlZnVsIGZvciBhdm9pZGluZ1xcclxcblxcdCAqIGN1c3BzIGFuZCBzZWxmLWludGVyc2VjdGlvbnMgaW4gbm9uLXVuaWZvcm0gY2F0bXVsbCByb20gY3VydmVzLlxcclxcblxcdCAqIGh0dHA6Ly93d3cuY2VteXVrc2VsLmNvbS9yZXNlYXJjaC9jYXRtdWxscm9tX3BhcmFtL2NhdG11bGxyb20ucGRmXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBjdXJ2ZS50eXBlIGFjY2VwdHMgY2VudHJpcGV0YWwoZGVmYXVsdCksIGNob3JkYWwgYW5kIGNhdG11bGxyb21cXHJcXG5cXHQgKiBjdXJ2ZS50ZW5zaW9uIGlzIHVzZWQgZm9yIGNhdG11bGxyb20gd2hpY2ggZGVmYXVsdHMgdG8gMC41XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFxyXFxuXFx0LypcXHJcXG5cXHRCYXNlZCBvbiBhbiBvcHRpbWl6ZWQgYysrIHNvbHV0aW9uIGluXFxyXFxuXFx0IC0gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy85NDg5NzM2L2NhdG11bGwtcm9tLWN1cnZlLXdpdGgtbm8tY3VzcHMtYW5kLW5vLXNlbGYtaW50ZXJzZWN0aW9ucy9cXHJcXG5cXHQgLSBodHRwOi8vaWRlb25lLmNvbS9Ob0ViVk1cXHJcXG5cXHJcXG5cXHRUaGlzIEN1YmljUG9seSBjbGFzcyBjb3VsZCBiZSB1c2VkIGZvciByZXVzaW5nIHNvbWUgdmFyaWFibGVzIGFuZCBjYWxjdWxhdGlvbnMsXFxyXFxuXFx0YnV0IGZvciB0aHJlZS5qcyBjdXJ2ZSB1c2UsIGl0IGNvdWxkIGJlIHBvc3NpYmxlIGlubGluZWQgYW5kIGZsYXR0ZW4gaW50byBhIHNpbmdsZSBmdW5jdGlvbiBjYWxsXFxyXFxuXFx0d2hpY2ggY2FuIGJlIHBsYWNlZCBpbiBDdXJ2ZVV0aWxzLlxcclxcblxcdCovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gQ3ViaWNQb2x5KCkge1xcclxcblxcclxcblxcdFxcdHZhciBjMCA9IDAsIGMxID0gMCwgYzIgPSAwLCBjMyA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0LypcXHJcXG5cXHRcXHQgKiBDb21wdXRlIGNvZWZmaWNpZW50cyBmb3IgYSBjdWJpYyBwb2x5bm9taWFsXFxyXFxuXFx0XFx0ICogICBwKHMpID0gYzAgKyBjMSpzICsgYzIqc14yICsgYzMqc14zXFxyXFxuXFx0XFx0ICogc3VjaCB0aGF0XFxyXFxuXFx0XFx0ICogICBwKDApID0geDAsIHAoMSkgPSB4MVxcclxcblxcdFxcdCAqICBhbmRcXHJcXG5cXHRcXHQgKiAgIHAnKDApID0gdDAsIHAnKDEpID0gdDEuXFxyXFxuXFx0XFx0ICovXFxyXFxuXFx0XFx0ZnVuY3Rpb24gaW5pdCggeDAsIHgxLCB0MCwgdDEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0YzAgPSB4MDtcXHJcXG5cXHRcXHRcXHRjMSA9IHQwO1xcclxcblxcdFxcdFxcdGMyID0gLSAzICogeDAgKyAzICogeDEgLSAyICogdDAgLSB0MTtcXHJcXG5cXHRcXHRcXHRjMyA9IDIgKiB4MCAtIDIgKiB4MSArIHQwICsgdDE7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHJldHVybiB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aW5pdENhdG11bGxSb206IGZ1bmN0aW9uICggeDAsIHgxLCB4MiwgeDMsIHRlbnNpb24gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aW5pdCggeDEsIHgyLCB0ZW5zaW9uICogKCB4MiAtIHgwICksIHRlbnNpb24gKiAoIHgzIC0geDEgKSApO1xcclxcblxcclxcblxcdFxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0XFx0aW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tOiBmdW5jdGlvbiAoIHgwLCB4MSwgeDIsIHgzLCBkdDAsIGR0MSwgZHQyICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGNvbXB1dGUgdGFuZ2VudHMgd2hlbiBwYXJhbWV0ZXJpemVkIGluIFt0MSx0Ml1cXHJcXG5cXHRcXHRcXHRcXHR2YXIgdDEgPSAoIHgxIC0geDAgKSAvIGR0MCAtICggeDIgLSB4MCApIC8gKCBkdDAgKyBkdDEgKSArICggeDIgLSB4MSApIC8gZHQxO1xcclxcblxcdFxcdFxcdFxcdHZhciB0MiA9ICggeDIgLSB4MSApIC8gZHQxIC0gKCB4MyAtIHgxICkgLyAoIGR0MSArIGR0MiApICsgKCB4MyAtIHgyICkgLyBkdDI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gcmVzY2FsZSB0YW5nZW50cyBmb3IgcGFyYW1ldHJpemF0aW9uIGluIFswLDFdXFxyXFxuXFx0XFx0XFx0XFx0dDEgKj0gZHQxO1xcclxcblxcdFxcdFxcdFxcdHQyICo9IGR0MTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpbml0KCB4MSwgeDIsIHQxLCB0MiApO1xcclxcblxcclxcblxcdFxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0XFx0Y2FsYzogZnVuY3Rpb24gKCB0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciB0MiA9IHQgKiB0O1xcclxcblxcdFxcdFxcdFxcdHZhciB0MyA9IHQyICogdDtcXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gYzAgKyBjMSAqIHQgKyBjMiAqIHQyICsgYzMgKiB0MztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0Ly9cXHJcXG5cXHJcXG5cXHR2YXIgdG1wID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHR2YXIgcHggPSBuZXcgQ3ViaWNQb2x5KCk7XFxyXFxuXFx0dmFyIHB5ID0gbmV3IEN1YmljUG9seSgpO1xcclxcblxcdHZhciBweiA9IG5ldyBDdWJpY1BvbHkoKTtcXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBDYXRtdWxsUm9tQ3VydmUzKCBwb2ludHMsIGNsb3NlZCwgY3VydmVUeXBlLCB0ZW5zaW9uICkge1xcclxcblxcclxcblxcdFxcdEN1cnZlLmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnQ2F0bXVsbFJvbUN1cnZlMyc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5wb2ludHMgPSBwb2ludHMgfHwgW107XFxyXFxuXFx0XFx0dGhpcy5jbG9zZWQgPSBjbG9zZWQgfHwgZmFsc2U7XFxyXFxuXFx0XFx0dGhpcy5jdXJ2ZVR5cGUgPSBjdXJ2ZVR5cGUgfHwgJ2NlbnRyaXBldGFsJztcXHJcXG5cXHRcXHR0aGlzLnRlbnNpb24gPSB0ZW5zaW9uIHx8IDAuNTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0Q2F0bXVsbFJvbUN1cnZlMy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKTtcXHJcXG5cXHRDYXRtdWxsUm9tQ3VydmUzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhdG11bGxSb21DdXJ2ZTM7XFxyXFxuXFxyXFxuXFx0Q2F0bXVsbFJvbUN1cnZlMy5wcm90b3R5cGUuaXNDYXRtdWxsUm9tQ3VydmUzID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRDYXRtdWxsUm9tQ3VydmUzLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHBvaW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XFxyXFxuXFx0XFx0dmFyIGwgPSBwb2ludHMubGVuZ3RoO1xcclxcblxcclxcblxcdFxcdHZhciBwID0gKCBsIC0gKCB0aGlzLmNsb3NlZCA/IDAgOiAxICkgKSAqIHQ7XFxyXFxuXFx0XFx0dmFyIGludFBvaW50ID0gTWF0aC5mbG9vciggcCApO1xcclxcblxcdFxcdHZhciB3ZWlnaHQgPSBwIC0gaW50UG9pbnQ7XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCB0aGlzLmNsb3NlZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpbnRQb2ludCArPSBpbnRQb2ludCA+IDAgPyAwIDogKCBNYXRoLmZsb29yKCBNYXRoLmFicyggaW50UG9pbnQgKSAvIHBvaW50cy5sZW5ndGggKSArIDEgKSAqIHBvaW50cy5sZW5ndGg7XFxyXFxuXFxyXFxuXFx0XFx0fSBlbHNlIGlmICggd2VpZ2h0ID09PSAwICYmIGludFBvaW50ID09PSBsIC0gMSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpbnRQb2ludCA9IGwgLSAyO1xcclxcblxcdFxcdFxcdHdlaWdodCA9IDE7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHZhciBwMCwgcDEsIHAyLCBwMzsgLy8gNCBwb2ludHNcXHJcXG5cXHJcXG5cXHRcXHRpZiAoIHRoaXMuY2xvc2VkIHx8IGludFBvaW50ID4gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRwMCA9IHBvaW50c1sgKCBpbnRQb2ludCAtIDEgKSAlIGwgXTtcXHJcXG5cXHJcXG5cXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdC8vIGV4dHJhcG9sYXRlIGZpcnN0IHBvaW50XFxyXFxuXFx0XFx0XFx0dG1wLnN1YlZlY3RvcnMoIHBvaW50c1sgMCBdLCBwb2ludHNbIDEgXSApLmFkZCggcG9pbnRzWyAwIF0gKTtcXHJcXG5cXHRcXHRcXHRwMCA9IHRtcDtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0cDEgPSBwb2ludHNbIGludFBvaW50ICUgbCBdO1xcclxcblxcdFxcdHAyID0gcG9pbnRzWyAoIGludFBvaW50ICsgMSApICUgbCBdO1xcclxcblxcclxcblxcdFxcdGlmICggdGhpcy5jbG9zZWQgfHwgaW50UG9pbnQgKyAyIDwgbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRwMyA9IHBvaW50c1sgKCBpbnRQb2ludCArIDIgKSAlIGwgXTtcXHJcXG5cXHJcXG5cXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdC8vIGV4dHJhcG9sYXRlIGxhc3QgcG9pbnRcXHJcXG5cXHRcXHRcXHR0bXAuc3ViVmVjdG9ycyggcG9pbnRzWyBsIC0gMSBdLCBwb2ludHNbIGwgLSAyIF0gKS5hZGQoIHBvaW50c1sgbCAtIDEgXSApO1xcclxcblxcdFxcdFxcdHAzID0gdG1wO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRpZiAoIHRoaXMuY3VydmVUeXBlID09PSAnY2VudHJpcGV0YWwnIHx8IHRoaXMuY3VydmVUeXBlID09PSAnY2hvcmRhbCcgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gaW5pdCBDZW50cmlwZXRhbCAvIENob3JkYWwgQ2F0bXVsbC1Sb21cXHJcXG5cXHRcXHRcXHR2YXIgcG93ID0gdGhpcy5jdXJ2ZVR5cGUgPT09ICdjaG9yZGFsJyA/IDAuNSA6IDAuMjU7XFxyXFxuXFx0XFx0XFx0dmFyIGR0MCA9IE1hdGgucG93KCBwMC5kaXN0YW5jZVRvU3F1YXJlZCggcDEgKSwgcG93ICk7XFxyXFxuXFx0XFx0XFx0dmFyIGR0MSA9IE1hdGgucG93KCBwMS5kaXN0YW5jZVRvU3F1YXJlZCggcDIgKSwgcG93ICk7XFxyXFxuXFx0XFx0XFx0dmFyIGR0MiA9IE1hdGgucG93KCBwMi5kaXN0YW5jZVRvU3F1YXJlZCggcDMgKSwgcG93ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gc2FmZXR5IGNoZWNrIGZvciByZXBlYXRlZCBwb2ludHNcXHJcXG5cXHRcXHRcXHRpZiAoIGR0MSA8IDFlLTQgKSBkdDEgPSAxLjA7XFxyXFxuXFx0XFx0XFx0aWYgKCBkdDAgPCAxZS00ICkgZHQwID0gZHQxO1xcclxcblxcdFxcdFxcdGlmICggZHQyIDwgMWUtNCApIGR0MiA9IGR0MTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRweC5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oIHAwLngsIHAxLngsIHAyLngsIHAzLngsIGR0MCwgZHQxLCBkdDIgKTtcXHJcXG5cXHRcXHRcXHRweS5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oIHAwLnksIHAxLnksIHAyLnksIHAzLnksIGR0MCwgZHQxLCBkdDIgKTtcXHJcXG5cXHRcXHRcXHRwei5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oIHAwLnosIHAxLnosIHAyLnosIHAzLnosIGR0MCwgZHQxLCBkdDIgKTtcXHJcXG5cXHJcXG5cXHRcXHR9IGVsc2UgaWYgKCB0aGlzLmN1cnZlVHlwZSA9PT0gJ2NhdG11bGxyb20nICkge1xcclxcblxcclxcblxcdFxcdFxcdHB4LmluaXRDYXRtdWxsUm9tKCBwMC54LCBwMS54LCBwMi54LCBwMy54LCB0aGlzLnRlbnNpb24gKTtcXHJcXG5cXHRcXHRcXHRweS5pbml0Q2F0bXVsbFJvbSggcDAueSwgcDEueSwgcDIueSwgcDMueSwgdGhpcy50ZW5zaW9uICk7XFxyXFxuXFx0XFx0XFx0cHouaW5pdENhdG11bGxSb20oIHAwLnosIHAxLnosIHAyLnosIHAzLnosIHRoaXMudGVuc2lvbiApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRwb2ludC5zZXQoXFxyXFxuXFx0XFx0XFx0cHguY2FsYyggd2VpZ2h0ICksXFxyXFxuXFx0XFx0XFx0cHkuY2FsYyggd2VpZ2h0ICksXFxyXFxuXFx0XFx0XFx0cHouY2FsYyggd2VpZ2h0IClcXHJcXG5cXHRcXHQpO1xcclxcblxcclxcblxcdFxcdHJldHVybiBwb2ludDtcXHJcXG5cXHJcXG5cXHR9O1xcclxcblxcclxcblxcdENhdG11bGxSb21DdXJ2ZTMucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRDdXJ2ZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnBvaW50cyA9IFtdO1xcclxcblxcclxcblxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHNvdXJjZS5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcG9pbnQgPSBzb3VyY2UucG9pbnRzWyBpIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5wb2ludHMucHVzaCggcG9pbnQuY2xvbmUoKSApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmNsb3NlZCA9IHNvdXJjZS5jbG9zZWQ7XFxyXFxuXFx0XFx0dGhpcy5jdXJ2ZVR5cGUgPSBzb3VyY2UuY3VydmVUeXBlO1xcclxcblxcdFxcdHRoaXMudGVuc2lvbiA9IHNvdXJjZS50ZW5zaW9uO1xcclxcblxcclxcblxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0Q2F0bXVsbFJvbUN1cnZlMy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdHZhciBkYXRhID0gQ3VydmUucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0ZGF0YS5wb2ludHMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLnBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBwb2ludCA9IHRoaXMucG9pbnRzWyBpIF07XFxyXFxuXFx0XFx0XFx0ZGF0YS5wb2ludHMucHVzaCggcG9pbnQudG9BcnJheSgpICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGRhdGEuY2xvc2VkID0gdGhpcy5jbG9zZWQ7XFxyXFxuXFx0XFx0ZGF0YS5jdXJ2ZVR5cGUgPSB0aGlzLmN1cnZlVHlwZTtcXHJcXG5cXHRcXHRkYXRhLnRlbnNpb24gPSB0aGlzLnRlbnNpb247XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIGRhdGE7XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHRDYXRtdWxsUm9tQ3VydmUzLnByb3RvdHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uICgganNvbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04uY2FsbCggdGhpcywganNvbiApO1xcclxcblxcclxcblxcdFxcdHRoaXMucG9pbnRzID0gW107XFxyXFxuXFxyXFxuXFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcG9pbnQgPSBqc29uLnBvaW50c1sgaSBdO1xcclxcblxcdFxcdFxcdHRoaXMucG9pbnRzLnB1c2goIG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KCBwb2ludCApICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHRoaXMuY2xvc2VkID0ganNvbi5jbG9zZWQ7XFxyXFxuXFx0XFx0dGhpcy5jdXJ2ZVR5cGUgPSBqc29uLmN1cnZlVHlwZTtcXHJcXG5cXHRcXHR0aGlzLnRlbnNpb24gPSBqc29uLnRlbnNpb247XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBCZXppZXIgQ3VydmVzIGZvcm11bGFzIG9idGFpbmVkIGZyb21cXHJcXG5cXHQgKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0LDqXppZXJfY3VydmVcXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBDYXRtdWxsUm9tKCB0LCBwMCwgcDEsIHAyLCBwMyApIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgdjAgPSAoIHAyIC0gcDAgKSAqIDAuNTtcXHJcXG5cXHRcXHR2YXIgdjEgPSAoIHAzIC0gcDEgKSAqIDAuNTtcXHJcXG5cXHRcXHR2YXIgdDIgPSB0ICogdDtcXHJcXG5cXHRcXHR2YXIgdDMgPSB0ICogdDI7XFxyXFxuXFx0XFx0cmV0dXJuICggMiAqIHAxIC0gMiAqIHAyICsgdjAgKyB2MSApICogdDMgKyAoIC0gMyAqIHAxICsgMyAqIHAyIC0gMiAqIHYwIC0gdjEgKSAqIHQyICsgdjAgKiB0ICsgcDE7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8vXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyUDAoIHQsIHAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGsgPSAxIC0gdDtcXHJcXG5cXHRcXHRyZXR1cm4gayAqIGsgKiBwO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBRdWFkcmF0aWNCZXppZXJQMSggdCwgcCApIHtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gMiAqICggMSAtIHQgKSAqIHQgKiBwO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBRdWFkcmF0aWNCZXppZXJQMiggdCwgcCApIHtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gdCAqIHQgKiBwO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBRdWFkcmF0aWNCZXppZXIoIHQsIHAwLCBwMSwgcDIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIFF1YWRyYXRpY0JlemllclAwKCB0LCBwMCApICsgUXVhZHJhdGljQmV6aWVyUDEoIHQsIHAxICkgK1xcclxcblxcdFxcdFxcdFF1YWRyYXRpY0JlemllclAyKCB0LCBwMiApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHQvL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIEN1YmljQmV6aWVyUDAoIHQsIHAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGsgPSAxIC0gdDtcXHJcXG5cXHRcXHRyZXR1cm4gayAqIGsgKiBrICogcDtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gQ3ViaWNCZXppZXJQMSggdCwgcCApIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgayA9IDEgLSB0O1xcclxcblxcdFxcdHJldHVybiAzICogayAqIGsgKiB0ICogcDtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gQ3ViaWNCZXppZXJQMiggdCwgcCApIHtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gMyAqICggMSAtIHQgKSAqIHQgKiB0ICogcDtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gQ3ViaWNCZXppZXJQMyggdCwgcCApIHtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gdCAqIHQgKiB0ICogcDtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gQ3ViaWNCZXppZXIoIHQsIHAwLCBwMSwgcDIsIHAzICkge1xcclxcblxcclxcblxcdFxcdHJldHVybiBDdWJpY0JlemllclAwKCB0LCBwMCApICsgQ3ViaWNCZXppZXJQMSggdCwgcDEgKSArIEN1YmljQmV6aWVyUDIoIHQsIHAyICkgK1xcclxcblxcdFxcdFxcdEN1YmljQmV6aWVyUDMoIHQsIHAzICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdGZ1bmN0aW9uIEN1YmljQmV6aWVyQ3VydmUoIHYwLCB2MSwgdjIsIHYzICkge1xcclxcblxcclxcblxcdFxcdEN1cnZlLmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnQ3ViaWNCZXppZXJDdXJ2ZSc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy52MCA9IHYwIHx8IG5ldyBWZWN0b3IyKCk7XFxyXFxuXFx0XFx0dGhpcy52MSA9IHYxIHx8IG5ldyBWZWN0b3IyKCk7XFxyXFxuXFx0XFx0dGhpcy52MiA9IHYyIHx8IG5ldyBWZWN0b3IyKCk7XFxyXFxuXFx0XFx0dGhpcy52MyA9IHYzIHx8IG5ldyBWZWN0b3IyKCk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdEN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XFxyXFxuXFx0Q3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDdWJpY0JlemllckN1cnZlO1xcclxcblxcclxcblxcdEN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmlzQ3ViaWNCZXppZXJDdXJ2ZSA9IHRydWU7XFxyXFxuXFxyXFxuXFx0Q3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xcclxcblxcclxcblxcdFxcdHZhciBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IyKCk7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHYwID0gdGhpcy52MCwgdjEgPSB0aGlzLnYxLCB2MiA9IHRoaXMudjIsIHYzID0gdGhpcy52MztcXHJcXG5cXHJcXG5cXHRcXHRwb2ludC5zZXQoXFxyXFxuXFx0XFx0XFx0Q3ViaWNCZXppZXIoIHQsIHYwLngsIHYxLngsIHYyLngsIHYzLnggKSxcXHJcXG5cXHRcXHRcXHRDdWJpY0JlemllciggdCwgdjAueSwgdjEueSwgdjIueSwgdjMueSApXFxyXFxuXFx0XFx0KTtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gcG9pbnQ7XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHRDdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Q3VydmUucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy52MC5jb3B5KCBzb3VyY2UudjAgKTtcXHJcXG5cXHRcXHR0aGlzLnYxLmNvcHkoIHNvdXJjZS52MSApO1xcclxcblxcdFxcdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XFxyXFxuXFx0XFx0dGhpcy52My5jb3B5KCBzb3VyY2UudjMgKTtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHR9O1xcclxcblxcclxcblxcdEN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgZGF0YSA9IEN1cnZlLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdGRhdGEudjAgPSB0aGlzLnYwLnRvQXJyYXkoKTtcXHJcXG5cXHRcXHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XFxyXFxuXFx0XFx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xcclxcblxcdFxcdGRhdGEudjMgPSB0aGlzLnYzLnRvQXJyYXkoKTtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gZGF0YTtcXHJcXG5cXHJcXG5cXHR9O1xcclxcblxcclxcblxcdEN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24gKCBqc29uICkge1xcclxcblxcclxcblxcdFxcdEN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTi5jYWxsKCB0aGlzLCBqc29uICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy52MC5mcm9tQXJyYXkoIGpzb24udjAgKTtcXHJcXG5cXHRcXHR0aGlzLnYxLmZyb21BcnJheSgganNvbi52MSApO1xcclxcblxcdFxcdHRoaXMudjIuZnJvbUFycmF5KCBqc29uLnYyICk7XFxyXFxuXFx0XFx0dGhpcy52My5mcm9tQXJyYXkoIGpzb24udjMgKTtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHR9O1xcclxcblxcclxcblxcdGZ1bmN0aW9uIEN1YmljQmV6aWVyQ3VydmUzKCB2MCwgdjEsIHYyLCB2MyApIHtcXHJcXG5cXHJcXG5cXHRcXHRDdXJ2ZS5jYWxsKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50eXBlID0gJ0N1YmljQmV6aWVyQ3VydmUzJztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnYwID0gdjAgfHwgbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHRcXHR0aGlzLnYxID0gdjEgfHwgbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHRcXHR0aGlzLnYyID0gdjIgfHwgbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHRcXHR0aGlzLnYzID0gdjMgfHwgbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0Q3ViaWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XFxyXFxuXFx0Q3ViaWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ3ViaWNCZXppZXJDdXJ2ZTM7XFxyXFxuXFxyXFxuXFx0Q3ViaWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlLmlzQ3ViaWNCZXppZXJDdXJ2ZTMgPSB0cnVlO1xcclxcblxcclxcblxcdEN1YmljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHBvaW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgdjAgPSB0aGlzLnYwLCB2MSA9IHRoaXMudjEsIHYyID0gdGhpcy52MiwgdjMgPSB0aGlzLnYzO1xcclxcblxcclxcblxcdFxcdHBvaW50LnNldChcXHJcXG5cXHRcXHRcXHRDdWJpY0JlemllciggdCwgdjAueCwgdjEueCwgdjIueCwgdjMueCApLFxcclxcblxcdFxcdFxcdEN1YmljQmV6aWVyKCB0LCB2MC55LCB2MS55LCB2Mi55LCB2My55ICksXFxyXFxuXFx0XFx0XFx0Q3ViaWNCZXppZXIoIHQsIHYwLnosIHYxLnosIHYyLnosIHYzLnogKVxcclxcblxcdFxcdCk7XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHBvaW50O1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0Q3ViaWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRDdXJ2ZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnYwLmNvcHkoIHNvdXJjZS52MCApO1xcclxcblxcdFxcdHRoaXMudjEuY29weSggc291cmNlLnYxICk7XFxyXFxuXFx0XFx0dGhpcy52Mi5jb3B5KCBzb3VyY2UudjIgKTtcXHJcXG5cXHRcXHR0aGlzLnYzLmNvcHkoIHNvdXJjZS52MyApO1xcclxcblxcclxcblxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0Q3ViaWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgZGF0YSA9IEN1cnZlLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdGRhdGEudjAgPSB0aGlzLnYwLnRvQXJyYXkoKTtcXHJcXG5cXHRcXHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XFxyXFxuXFx0XFx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xcclxcblxcdFxcdGRhdGEudjMgPSB0aGlzLnYzLnRvQXJyYXkoKTtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gZGF0YTtcXHJcXG5cXHJcXG5cXHR9O1xcclxcblxcclxcblxcdEN1YmljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uICgganNvbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04uY2FsbCggdGhpcywganNvbiApO1xcclxcblxcclxcblxcdFxcdHRoaXMudjAuZnJvbUFycmF5KCBqc29uLnYwICk7XFxyXFxuXFx0XFx0dGhpcy52MS5mcm9tQXJyYXkoIGpzb24udjEgKTtcXHJcXG5cXHRcXHR0aGlzLnYyLmZyb21BcnJheSgganNvbi52MiApO1xcclxcblxcdFxcdHRoaXMudjMuZnJvbUFycmF5KCBqc29uLnYzICk7XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBMaW5lQ3VydmUoIHYxLCB2MiApIHtcXHJcXG5cXHJcXG5cXHRcXHRDdXJ2ZS5jYWxsKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50eXBlID0gJ0xpbmVDdXJ2ZSc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy52MSA9IHYxIHx8IG5ldyBWZWN0b3IyKCk7XFxyXFxuXFx0XFx0dGhpcy52MiA9IHYyIHx8IG5ldyBWZWN0b3IyKCk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdExpbmVDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKTtcXHJcXG5cXHRMaW5lQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGluZUN1cnZlO1xcclxcblxcclxcblxcdExpbmVDdXJ2ZS5wcm90b3R5cGUuaXNMaW5lQ3VydmUgPSB0cnVlO1xcclxcblxcclxcblxcdExpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xcclxcblxcclxcblxcdFxcdHZhciBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IyKCk7XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCB0ID09PSAxICkge1xcclxcblxcclxcblxcdFxcdFxcdHBvaW50LmNvcHkoIHRoaXMudjIgKTtcXHJcXG5cXHJcXG5cXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdHBvaW50LmNvcHkoIHRoaXMudjIgKS5zdWIoIHRoaXMudjEgKTtcXHJcXG5cXHRcXHRcXHRwb2ludC5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy52MSApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gcG9pbnQ7XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHQvLyBMaW5lIGN1cnZlIGlzIGxpbmVhciwgc28gd2UgY2FuIG92ZXJ3cml0ZSBkZWZhdWx0IGdldFBvaW50QXRcXHJcXG5cXHJcXG5cXHRMaW5lQ3VydmUucHJvdG90eXBlLmdldFBvaW50QXQgPSBmdW5jdGlvbiAoIHUsIG9wdGlvbmFsVGFyZ2V0ICkge1xcclxcblxcclxcblxcdFxcdHJldHVybiB0aGlzLmdldFBvaW50KCB1LCBvcHRpb25hbFRhcmdldCApO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0TGluZUN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24gKCAvKiB0ICovICkge1xcclxcblxcclxcblxcdFxcdHZhciB0YW5nZW50ID0gdGhpcy52Mi5jbG9uZSgpLnN1YiggdGhpcy52MSApO1xcclxcblxcclxcblxcdFxcdHJldHVybiB0YW5nZW50Lm5vcm1hbGl6ZSgpO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0TGluZUN1cnZlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Q3VydmUucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy52MS5jb3B5KCBzb3VyY2UudjEgKTtcXHJcXG5cXHRcXHR0aGlzLnYyLmNvcHkoIHNvdXJjZS52MiApO1xcclxcblxcclxcblxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0TGluZUN1cnZlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGRhdGEgPSBDdXJ2ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XFxyXFxuXFx0XFx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xcclxcblxcclxcblxcdFxcdHJldHVybiBkYXRhO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0TGluZUN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uICgganNvbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04uY2FsbCggdGhpcywganNvbiApO1xcclxcblxcclxcblxcdFxcdHRoaXMudjEuZnJvbUFycmF5KCBqc29uLnYxICk7XFxyXFxuXFx0XFx0dGhpcy52Mi5mcm9tQXJyYXkoIGpzb24udjIgKTtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHR9O1xcclxcblxcclxcblxcdGZ1bmN0aW9uIExpbmVDdXJ2ZTMoIHYxLCB2MiApIHtcXHJcXG5cXHJcXG5cXHRcXHRDdXJ2ZS5jYWxsKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50eXBlID0gJ0xpbmVDdXJ2ZTMnO1xcclxcblxcclxcblxcdFxcdHRoaXMudjEgPSB2MSB8fCBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdHRoaXMudjIgPSB2MiB8fCBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRMaW5lQ3VydmUzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN1cnZlLnByb3RvdHlwZSApO1xcclxcblxcdExpbmVDdXJ2ZTMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGluZUN1cnZlMztcXHJcXG5cXHJcXG5cXHRMaW5lQ3VydmUzLnByb3RvdHlwZS5pc0xpbmVDdXJ2ZTMgPSB0cnVlO1xcclxcblxcclxcblxcdExpbmVDdXJ2ZTMucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgcG9pbnQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdFxcdGlmICggdCA9PT0gMSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRwb2ludC5jb3B5KCB0aGlzLnYyICk7XFxyXFxuXFxyXFxuXFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRwb2ludC5jb3B5KCB0aGlzLnYyICkuc3ViKCB0aGlzLnYxICk7XFxyXFxuXFx0XFx0XFx0cG9pbnQubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMudjEgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHBvaW50O1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0Ly8gTGluZSBjdXJ2ZSBpcyBsaW5lYXIsIHNvIHdlIGNhbiBvdmVyd3JpdGUgZGVmYXVsdCBnZXRQb2ludEF0XFxyXFxuXFxyXFxuXFx0TGluZUN1cnZlMy5wcm90b3R5cGUuZ2V0UG9pbnRBdCA9IGZ1bmN0aW9uICggdSwgb3B0aW9uYWxUYXJnZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnQoIHUsIG9wdGlvbmFsVGFyZ2V0ICk7XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHRMaW5lQ3VydmUzLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Q3VydmUucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy52MS5jb3B5KCBzb3VyY2UudjEgKTtcXHJcXG5cXHRcXHR0aGlzLnYyLmNvcHkoIHNvdXJjZS52MiApO1xcclxcblxcclxcblxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0TGluZUN1cnZlMy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdHZhciBkYXRhID0gQ3VydmUucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xcclxcblxcdFxcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gZGF0YTtcXHJcXG5cXHJcXG5cXHR9O1xcclxcblxcclxcblxcdExpbmVDdXJ2ZTMucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24gKCBqc29uICkge1xcclxcblxcclxcblxcdFxcdEN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTi5jYWxsKCB0aGlzLCBqc29uICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy52MS5mcm9tQXJyYXkoIGpzb24udjEgKTtcXHJcXG5cXHRcXHR0aGlzLnYyLmZyb21BcnJheSgganNvbi52MiApO1xcclxcblxcclxcblxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyQ3VydmUoIHYwLCB2MSwgdjIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Q3VydmUuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdRdWFkcmF0aWNCZXppZXJDdXJ2ZSc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy52MCA9IHYwIHx8IG5ldyBWZWN0b3IyKCk7XFxyXFxuXFx0XFx0dGhpcy52MSA9IHYxIHx8IG5ldyBWZWN0b3IyKCk7XFxyXFxuXFx0XFx0dGhpcy52MiA9IHYyIHx8IG5ldyBWZWN0b3IyKCk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdFF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN1cnZlLnByb3RvdHlwZSApO1xcclxcblxcdFF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFF1YWRyYXRpY0JlemllckN1cnZlO1xcclxcblxcclxcblxcdFF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5pc1F1YWRyYXRpY0JlemllckN1cnZlID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRRdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xcclxcblxcclxcblxcdFxcdHZhciBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IyKCk7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHYwID0gdGhpcy52MCwgdjEgPSB0aGlzLnYxLCB2MiA9IHRoaXMudjI7XFxyXFxuXFxyXFxuXFx0XFx0cG9pbnQuc2V0KFxcclxcblxcdFxcdFxcdFF1YWRyYXRpY0JlemllciggdCwgdjAueCwgdjEueCwgdjIueCApLFxcclxcblxcdFxcdFxcdFF1YWRyYXRpY0JlemllciggdCwgdjAueSwgdjEueSwgdjIueSApXFxyXFxuXFx0XFx0KTtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gcG9pbnQ7XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHRRdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xcclxcblxcclxcblxcdFxcdEN1cnZlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcclxcblxcclxcblxcdFxcdHRoaXMudjAuY29weSggc291cmNlLnYwICk7XFxyXFxuXFx0XFx0dGhpcy52MS5jb3B5KCBzb3VyY2UudjEgKTtcXHJcXG5cXHRcXHR0aGlzLnYyLmNvcHkoIHNvdXJjZS52MiApO1xcclxcblxcclxcblxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0UXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgZGF0YSA9IEN1cnZlLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdGRhdGEudjAgPSB0aGlzLnYwLnRvQXJyYXkoKTtcXHJcXG5cXHRcXHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XFxyXFxuXFx0XFx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xcclxcblxcclxcblxcdFxcdHJldHVybiBkYXRhO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0UXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24gKCBqc29uICkge1xcclxcblxcclxcblxcdFxcdEN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTi5jYWxsKCB0aGlzLCBqc29uICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy52MC5mcm9tQXJyYXkoIGpzb24udjAgKTtcXHJcXG5cXHRcXHR0aGlzLnYxLmZyb21BcnJheSgganNvbi52MSApO1xcclxcblxcdFxcdHRoaXMudjIuZnJvbUFycmF5KCBqc29uLnYyICk7XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBRdWFkcmF0aWNCZXppZXJDdXJ2ZTMoIHYwLCB2MSwgdjIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Q3VydmUuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdRdWFkcmF0aWNCZXppZXJDdXJ2ZTMnO1xcclxcblxcclxcblxcdFxcdHRoaXMudjAgPSB2MCB8fCBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdHRoaXMudjEgPSB2MSB8fCBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdHRoaXMudjIgPSB2MiB8fCBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRRdWFkcmF0aWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XFxyXFxuXFx0UXVhZHJhdGljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFF1YWRyYXRpY0JlemllckN1cnZlMztcXHJcXG5cXHJcXG5cXHRRdWFkcmF0aWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlLmlzUXVhZHJhdGljQmV6aWVyQ3VydmUzID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRRdWFkcmF0aWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgcG9pbnQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdFxcdHZhciB2MCA9IHRoaXMudjAsIHYxID0gdGhpcy52MSwgdjIgPSB0aGlzLnYyO1xcclxcblxcclxcblxcdFxcdHBvaW50LnNldChcXHJcXG5cXHRcXHRcXHRRdWFkcmF0aWNCZXppZXIoIHQsIHYwLngsIHYxLngsIHYyLnggKSxcXHJcXG5cXHRcXHRcXHRRdWFkcmF0aWNCZXppZXIoIHQsIHYwLnksIHYxLnksIHYyLnkgKSxcXHJcXG5cXHRcXHRcXHRRdWFkcmF0aWNCZXppZXIoIHQsIHYwLnosIHYxLnosIHYyLnogKVxcclxcblxcdFxcdCk7XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHBvaW50O1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0UXVhZHJhdGljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Q3VydmUucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy52MC5jb3B5KCBzb3VyY2UudjAgKTtcXHJcXG5cXHRcXHR0aGlzLnYxLmNvcHkoIHNvdXJjZS52MSApO1xcclxcblxcdFxcdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHRRdWFkcmF0aWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgZGF0YSA9IEN1cnZlLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdGRhdGEudjAgPSB0aGlzLnYwLnRvQXJyYXkoKTtcXHJcXG5cXHRcXHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XFxyXFxuXFx0XFx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xcclxcblxcclxcblxcdFxcdHJldHVybiBkYXRhO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0UXVhZHJhdGljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uICgganNvbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04uY2FsbCggdGhpcywganNvbiApO1xcclxcblxcclxcblxcdFxcdHRoaXMudjAuZnJvbUFycmF5KCBqc29uLnYwICk7XFxyXFxuXFx0XFx0dGhpcy52MS5mcm9tQXJyYXkoIGpzb24udjEgKTtcXHJcXG5cXHRcXHR0aGlzLnYyLmZyb21BcnJheSgganNvbi52MiApO1xcclxcblxcclxcblxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gU3BsaW5lQ3VydmUoIHBvaW50cyAvKiBhcnJheSBvZiBWZWN0b3IyICovICkge1xcclxcblxcclxcblxcdFxcdEN1cnZlLmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnU3BsaW5lQ3VydmUnO1xcclxcblxcclxcblxcdFxcdHRoaXMucG9pbnRzID0gcG9pbnRzIHx8IFtdO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRTcGxpbmVDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKTtcXHJcXG5cXHRTcGxpbmVDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcGxpbmVDdXJ2ZTtcXHJcXG5cXHJcXG5cXHRTcGxpbmVDdXJ2ZS5wcm90b3R5cGUuaXNTcGxpbmVDdXJ2ZSA9IHRydWU7XFxyXFxuXFxyXFxuXFx0U3BsaW5lQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgcG9pbnQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMigpO1xcclxcblxcclxcblxcdFxcdHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcXHJcXG5cXHRcXHR2YXIgcCA9ICggcG9pbnRzLmxlbmd0aCAtIDEgKSAqIHQ7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGludFBvaW50ID0gTWF0aC5mbG9vciggcCApO1xcclxcblxcdFxcdHZhciB3ZWlnaHQgPSBwIC0gaW50UG9pbnQ7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHAwID0gcG9pbnRzWyBpbnRQb2ludCA9PT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxIF07XFxyXFxuXFx0XFx0dmFyIHAxID0gcG9pbnRzWyBpbnRQb2ludCBdO1xcclxcblxcdFxcdHZhciBwMiA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxIF07XFxyXFxuXFx0XFx0dmFyIHAzID0gcG9pbnRzWyBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAzID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDIgXTtcXHJcXG5cXHJcXG5cXHRcXHRwb2ludC5zZXQoXFxyXFxuXFx0XFx0XFx0Q2F0bXVsbFJvbSggd2VpZ2h0LCBwMC54LCBwMS54LCBwMi54LCBwMy54ICksXFxyXFxuXFx0XFx0XFx0Q2F0bXVsbFJvbSggd2VpZ2h0LCBwMC55LCBwMS55LCBwMi55LCBwMy55IClcXHJcXG5cXHRcXHQpO1xcclxcblxcclxcblxcdFxcdHJldHVybiBwb2ludDtcXHJcXG5cXHJcXG5cXHR9O1xcclxcblxcclxcblxcdFNwbGluZUN1cnZlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Q3VydmUucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5wb2ludHMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzb3VyY2UucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHBvaW50ID0gc291cmNlLnBvaW50c1sgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMucG9pbnRzLnB1c2goIHBvaW50LmNsb25lKCkgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHRTcGxpbmVDdXJ2ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdHZhciBkYXRhID0gQ3VydmUucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0ZGF0YS5wb2ludHMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLnBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBwb2ludCA9IHRoaXMucG9pbnRzWyBpIF07XFxyXFxuXFx0XFx0XFx0ZGF0YS5wb2ludHMucHVzaCggcG9pbnQudG9BcnJheSgpICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHJldHVybiBkYXRhO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0U3BsaW5lQ3VydmUucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24gKCBqc29uICkge1xcclxcblxcclxcblxcdFxcdEN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTi5jYWxsKCB0aGlzLCBqc29uICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5wb2ludHMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLnBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBwb2ludCA9IGpzb24ucG9pbnRzWyBpIF07XFxyXFxuXFx0XFx0XFx0dGhpcy5wb2ludHMucHVzaCggbmV3IFZlY3RvcjIoKS5mcm9tQXJyYXkoIHBvaW50ICkgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5cXHR2YXIgQ3VydmVzID0gT2JqZWN0LmZyZWV6ZSh7XFxyXFxuXFx0XFx0QXJjQ3VydmU6IEFyY0N1cnZlLFxcclxcblxcdFxcdENhdG11bGxSb21DdXJ2ZTM6IENhdG11bGxSb21DdXJ2ZTMsXFxyXFxuXFx0XFx0Q3ViaWNCZXppZXJDdXJ2ZTogQ3ViaWNCZXppZXJDdXJ2ZSxcXHJcXG5cXHRcXHRDdWJpY0JlemllckN1cnZlMzogQ3ViaWNCZXppZXJDdXJ2ZTMsXFxyXFxuXFx0XFx0RWxsaXBzZUN1cnZlOiBFbGxpcHNlQ3VydmUsXFxyXFxuXFx0XFx0TGluZUN1cnZlOiBMaW5lQ3VydmUsXFxyXFxuXFx0XFx0TGluZUN1cnZlMzogTGluZUN1cnZlMyxcXHJcXG5cXHRcXHRRdWFkcmF0aWNCZXppZXJDdXJ2ZTogUXVhZHJhdGljQmV6aWVyQ3VydmUsXFxyXFxuXFx0XFx0UXVhZHJhdGljQmV6aWVyQ3VydmUzOiBRdWFkcmF0aWNCZXppZXJDdXJ2ZTMsXFxyXFxuXFx0XFx0U3BsaW5lQ3VydmU6IFNwbGluZUN1cnZlXFxyXFxuXFx0fSk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xcclxcblxcdCAqXFxyXFxuXFx0ICoqL1xcclxcblxcclxcblxcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcclxcblxcdCAqXFx0Q3VydmVkIFBhdGggLSBhIGN1cnZlIHBhdGggaXMgc2ltcGx5IGEgYXJyYXkgb2YgY29ubmVjdGVkXFxyXFxuXFx0ICogIGN1cnZlcywgYnV0IHJldGFpbnMgdGhlIGFwaSBvZiBhIGN1cnZlXFxyXFxuXFx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIEN1cnZlUGF0aCgpIHtcXHJcXG5cXHJcXG5cXHRcXHRDdXJ2ZS5jYWxsKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50eXBlID0gJ0N1cnZlUGF0aCc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5jdXJ2ZXMgPSBbXTtcXHJcXG5cXHRcXHR0aGlzLmF1dG9DbG9zZSA9IGZhbHNlOyAvLyBBdXRvbWF0aWNhbGx5IGNsb3NlcyB0aGUgcGF0aFxcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRDdXJ2ZVBhdGgucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICksIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zdHJ1Y3RvcjogQ3VydmVQYXRoLFxcclxcblxcclxcblxcdFxcdGFkZDogZnVuY3Rpb24gKCBjdXJ2ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y2xvc2VQYXRoOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gQWRkIGEgbGluZSBjdXJ2ZSBpZiBzdGFydCBhbmQgZW5kIG9mIGxpbmVzIGFyZSBub3QgY29ubmVjdGVkXFxyXFxuXFx0XFx0XFx0dmFyIHN0YXJ0UG9pbnQgPSB0aGlzLmN1cnZlc1sgMCBdLmdldFBvaW50KCAwICk7XFxyXFxuXFx0XFx0XFx0dmFyIGVuZFBvaW50ID0gdGhpcy5jdXJ2ZXNbIHRoaXMuY3VydmVzLmxlbmd0aCAtIDEgXS5nZXRQb2ludCggMSApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggISBzdGFydFBvaW50LmVxdWFscyggZW5kUG9pbnQgKSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmN1cnZlcy5wdXNoKCBuZXcgTGluZUN1cnZlKCBlbmRQb2ludCwgc3RhcnRQb2ludCApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Ly8gVG8gZ2V0IGFjY3VyYXRlIHBvaW50IHdpdGggcmVmZXJlbmNlIHRvXFxyXFxuXFx0XFx0Ly8gZW50aXJlIHBhdGggZGlzdGFuY2UgYXQgdGltZSB0LFxcclxcblxcdFxcdC8vIGZvbGxvd2luZyBoYXMgdG8gYmUgZG9uZTpcXHJcXG5cXHJcXG5cXHRcXHQvLyAxLiBMZW5ndGggb2YgZWFjaCBzdWIgcGF0aCBoYXZlIHRvIGJlIGtub3duXFxyXFxuXFx0XFx0Ly8gMi4gTG9jYXRlIGFuZCBpZGVudGlmeSB0eXBlIG9mIGN1cnZlXFxyXFxuXFx0XFx0Ly8gMy4gR2V0IHQgZm9yIHRoZSBjdXJ2ZVxcclxcblxcdFxcdC8vIDQuIFJldHVybiBjdXJ2ZS5nZXRQb2ludEF0KHQnKVxcclxcblxcclxcblxcdFxcdGdldFBvaW50OiBmdW5jdGlvbiAoIHQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGQgPSB0ICogdGhpcy5nZXRMZW5ndGgoKTtcXHJcXG5cXHRcXHRcXHR2YXIgY3VydmVMZW5ndGhzID0gdGhpcy5nZXRDdXJ2ZUxlbmd0aHMoKTtcXHJcXG5cXHRcXHRcXHR2YXIgaSA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gVG8gdGhpbmsgYWJvdXQgYm91bmRhcmllcyBwb2ludHMuXFxyXFxuXFxyXFxuXFx0XFx0XFx0d2hpbGUgKCBpIDwgY3VydmVMZW5ndGhzLmxlbmd0aCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGN1cnZlTGVuZ3Roc1sgaSBdID49IGQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGRpZmYgPSBjdXJ2ZUxlbmd0aHNbIGkgXSAtIGQ7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGN1cnZlID0gdGhpcy5jdXJ2ZXNbIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgc2VnbWVudExlbmd0aCA9IGN1cnZlLmdldExlbmd0aCgpO1xcclxcblxcdFxcdFxcdFxcdFxcdHZhciB1ID0gc2VnbWVudExlbmd0aCA9PT0gMCA/IDAgOiAxIC0gZGlmZiAvIHNlZ21lbnRMZW5ndGg7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGN1cnZlLmdldFBvaW50QXQoIHUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aSArKztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gbG9vcCB3aGVyZSBzdW0gIT0gMCwgc3VtID4gZCAsIHN1bSsxIDxkXFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHQvLyBXZSBjYW5ub3QgdXNlIHRoZSBkZWZhdWx0IFRIUkVFLkN1cnZlIGdldFBvaW50KCkgd2l0aCBnZXRMZW5ndGgoKSBiZWNhdXNlIGluXFxyXFxuXFx0XFx0Ly8gVEhSRUUuQ3VydmUsIGdldExlbmd0aCgpIGRlcGVuZHMgb24gZ2V0UG9pbnQoKSBidXQgaW4gVEhSRUUuQ3VydmVQYXRoXFxyXFxuXFx0XFx0Ly8gZ2V0UG9pbnQoKSBkZXBlbmRzIG9uIGdldExlbmd0aFxcclxcblxcclxcblxcdFxcdGdldExlbmd0aDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBsZW5zID0gdGhpcy5nZXRDdXJ2ZUxlbmd0aHMoKTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gbGVuc1sgbGVucy5sZW5ndGggLSAxIF07XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHQvLyBjYWNoZUxlbmd0aHMgbXVzdCBiZSByZWNhbGN1bGF0ZWQuXFxyXFxuXFx0XFx0dXBkYXRlQXJjTGVuZ3RoczogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xcclxcblxcdFxcdFxcdHRoaXMuY2FjaGVMZW5ndGhzID0gbnVsbDtcXHJcXG5cXHRcXHRcXHR0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Ly8gQ29tcHV0ZSBsZW5ndGhzIGFuZCBjYWNoZSB0aGVtXFxyXFxuXFx0XFx0Ly8gV2UgY2Fubm90IG92ZXJ3cml0ZSBnZXRMZW5ndGhzKCkgYmVjYXVzZSBVdG9UIG1hcHBpbmcgdXNlcyBpdC5cXHJcXG5cXHJcXG5cXHRcXHRnZXRDdXJ2ZUxlbmd0aHM6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBXZSB1c2UgY2FjaGUgdmFsdWVzIGlmIGN1cnZlcyBhbmQgY2FjaGUgYXJyYXkgYXJlIHNhbWUgbGVuZ3RoXFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmNhY2hlTGVuZ3RocyAmJiB0aGlzLmNhY2hlTGVuZ3Rocy5sZW5ndGggPT09IHRoaXMuY3VydmVzLmxlbmd0aCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5jYWNoZUxlbmd0aHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdC8vIEdldCBsZW5ndGggb2Ygc3ViLWN1cnZlXFxyXFxuXFx0XFx0XFx0Ly8gUHVzaCBzdW1zIGludG8gY2FjaGVkIGFycmF5XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGxlbmd0aHMgPSBbXSwgc3VtcyA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzdW1zICs9IHRoaXMuY3VydmVzWyBpIF0uZ2V0TGVuZ3RoKCk7XFxyXFxuXFx0XFx0XFx0XFx0bGVuZ3Rocy5wdXNoKCBzdW1zICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHRoaXMuY2FjaGVMZW5ndGhzID0gbGVuZ3RocztcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gbGVuZ3RocztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGdldFNwYWNlZFBvaW50czogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCApIGRpdmlzaW9ucyA9IDQwO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBwb2ludHMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPD0gZGl2aXNpb25zOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHBvaW50cy5wdXNoKCB0aGlzLmdldFBvaW50KCBpIC8gZGl2aXNpb25zICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmF1dG9DbG9zZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRwb2ludHMucHVzaCggcG9pbnRzWyAwIF0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHBvaW50cztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGdldFBvaW50czogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZGl2aXNpb25zID0gZGl2aXNpb25zIHx8IDEyO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBwb2ludHMgPSBbXSwgbGFzdDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGN1cnZlcyA9IHRoaXMuY3VydmVzOyBpIDwgY3VydmVzLmxlbmd0aDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgY3VydmUgPSBjdXJ2ZXNbIGkgXTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgcmVzb2x1dGlvbiA9ICggY3VydmUgJiYgY3VydmUuaXNFbGxpcHNlQ3VydmUgKSA/IGRpdmlzaW9ucyAqIDJcXHJcXG5cXHRcXHRcXHRcXHRcXHQ6ICggY3VydmUgJiYgY3VydmUuaXNMaW5lQ3VydmUgKSA/IDFcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQ6ICggY3VydmUgJiYgY3VydmUuaXNTcGxpbmVDdXJ2ZSApID8gZGl2aXNpb25zICogY3VydmUucG9pbnRzLmxlbmd0aFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDogZGl2aXNpb25zO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBwdHMgPSBjdXJ2ZS5nZXRQb2ludHMoIHJlc29sdXRpb24gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaiA9IDA7IGogPCBwdHMubGVuZ3RoOyBqICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBwb2ludCA9IHB0c1sgaiBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggbGFzdCAmJiBsYXN0LmVxdWFscyggcG9pbnQgKSApIGNvbnRpbnVlOyAvLyBlbnN1cmVzIG5vIGNvbnNlY3V0aXZlIHBvaW50cyBhcmUgZHVwbGljYXRlc1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHBvaW50cy5wdXNoKCBwb2ludCApO1xcclxcblxcdFxcdFxcdFxcdFxcdGxhc3QgPSBwb2ludDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5hdXRvQ2xvc2UgJiYgcG9pbnRzLmxlbmd0aCA+IDEgJiYgISBwb2ludHNbIHBvaW50cy5sZW5ndGggLSAxIF0uZXF1YWxzKCBwb2ludHNbIDAgXSApICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHBvaW50cy5wdXNoKCBwb2ludHNbIDAgXSApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gcG9pbnRzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Q3VydmUucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5jdXJ2ZXMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzb3VyY2UuY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGN1cnZlID0gc291cmNlLmN1cnZlc1sgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlLmNsb25lKCkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5hdXRvQ2xvc2UgPSBzb3VyY2UuYXV0b0Nsb3NlO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGRhdGEgPSBDdXJ2ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRkYXRhLmF1dG9DbG9zZSA9IHRoaXMuYXV0b0Nsb3NlO1xcclxcblxcdFxcdFxcdGRhdGEuY3VydmVzID0gW107XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgY3VydmUgPSB0aGlzLmN1cnZlc1sgaSBdO1xcclxcblxcdFxcdFxcdFxcdGRhdGEuY3VydmVzLnB1c2goIGN1cnZlLnRvSlNPTigpICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBkYXRhO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0ZnJvbUpTT046IGZ1bmN0aW9uICgganNvbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04uY2FsbCggdGhpcywganNvbiApO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuYXV0b0Nsb3NlID0ganNvbi5hdXRvQ2xvc2U7XFxyXFxuXFx0XFx0XFx0dGhpcy5jdXJ2ZXMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBjdXJ2ZSA9IGpzb24uY3VydmVzWyBpIF07XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5jdXJ2ZXMucHVzaCggbmV3IEN1cnZlc1sgY3VydmUudHlwZSBdKCkuZnJvbUpTT04oIGN1cnZlICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXFxyXFxuXFx0ICogQ3JlYXRlcyBmcmVlIGZvcm0gMmQgcGF0aCB1c2luZyBzZXJpZXMgb2YgcG9pbnRzLCBsaW5lcyBvciBjdXJ2ZXMuXFxyXFxuXFx0ICoqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIFBhdGgoIHBvaW50cyApIHtcXHJcXG5cXHJcXG5cXHRcXHRDdXJ2ZVBhdGguY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdQYXRoJztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmN1cnJlbnRQb2ludCA9IG5ldyBWZWN0b3IyKCk7XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCBwb2ludHMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdFBhdGgucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggQ3VydmVQYXRoLnByb3RvdHlwZSApLCB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc3RydWN0b3I6IFBhdGgsXFxyXFxuXFxyXFxuXFx0XFx0c2V0RnJvbVBvaW50czogZnVuY3Rpb24gKCBwb2ludHMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5tb3ZlVG8oIHBvaW50c1sgMCBdLngsIHBvaW50c1sgMCBdLnkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDEsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmxpbmVUbyggcG9pbnRzWyBpIF0ueCwgcG9pbnRzWyBpIF0ueSApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdG1vdmVUbzogZnVuY3Rpb24gKCB4LCB5ICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuY3VycmVudFBvaW50LnNldCggeCwgeSApOyAvLyBUT0RPIGNvbnNpZGVyIHJlZmVyZW5jaW5nIHZlY3RvcnMgaW5zdGVhZCBvZiBjb3B5aW5nP1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0bGluZVRvOiBmdW5jdGlvbiAoIHgsIHkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGN1cnZlID0gbmV3IExpbmVDdXJ2ZSggdGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKSwgbmV3IFZlY3RvcjIoIHgsIHkgKSApO1xcclxcblxcdFxcdFxcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5jdXJyZW50UG9pbnQuc2V0KCB4LCB5ICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbiAoIGFDUHgsIGFDUHksIGFYLCBhWSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgY3VydmUgPSBuZXcgUXVhZHJhdGljQmV6aWVyQ3VydmUoXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKSxcXHJcXG5cXHRcXHRcXHRcXHRuZXcgVmVjdG9yMiggYUNQeCwgYUNQeSApLFxcclxcblxcdFxcdFxcdFxcdG5ldyBWZWN0b3IyKCBhWCwgYVkgKVxcclxcblxcdFxcdFxcdCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmN1cnJlbnRQb2ludC5zZXQoIGFYLCBhWSApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0YmV6aWVyQ3VydmVUbzogZnVuY3Rpb24gKCBhQ1AxeCwgYUNQMXksIGFDUDJ4LCBhQ1AyeSwgYVgsIGFZICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBjdXJ2ZSA9IG5ldyBDdWJpY0JlemllckN1cnZlKFxcclxcblxcdFxcdFxcdFxcdHRoaXMuY3VycmVudFBvaW50LmNsb25lKCksXFxyXFxuXFx0XFx0XFx0XFx0bmV3IFZlY3RvcjIoIGFDUDF4LCBhQ1AxeSApLFxcclxcblxcdFxcdFxcdFxcdG5ldyBWZWN0b3IyKCBhQ1AyeCwgYUNQMnkgKSxcXHJcXG5cXHRcXHRcXHRcXHRuZXcgVmVjdG9yMiggYVgsIGFZIClcXHJcXG5cXHRcXHRcXHQpO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5jdXJyZW50UG9pbnQuc2V0KCBhWCwgYVkgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNwbGluZVRocnU6IGZ1bmN0aW9uICggcHRzIC8qQXJyYXkgb2YgVmVjdG9yKi8gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG5wdHMgPSBbIHRoaXMuY3VycmVudFBvaW50LmNsb25lKCkgXS5jb25jYXQoIHB0cyApO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBjdXJ2ZSA9IG5ldyBTcGxpbmVDdXJ2ZSggbnB0cyApO1xcclxcblxcdFxcdFxcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5jdXJyZW50UG9pbnQuY29weSggcHRzWyBwdHMubGVuZ3RoIC0gMSBdICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRhcmM6IGZ1bmN0aW9uICggYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB4MCA9IHRoaXMuY3VycmVudFBvaW50Lng7XFxyXFxuXFx0XFx0XFx0dmFyIHkwID0gdGhpcy5jdXJyZW50UG9pbnQueTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmFic2FyYyggYVggKyB4MCwgYVkgKyB5MCwgYVJhZGl1cyxcXHJcXG5cXHRcXHRcXHRcXHRhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRhYnNhcmM6IGZ1bmN0aW9uICggYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuYWJzZWxsaXBzZSggYVgsIGFZLCBhUmFkaXVzLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRlbGxpcHNlOiBmdW5jdGlvbiAoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB4MCA9IHRoaXMuY3VycmVudFBvaW50Lng7XFxyXFxuXFx0XFx0XFx0dmFyIHkwID0gdGhpcy5jdXJyZW50UG9pbnQueTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmFic2VsbGlwc2UoIGFYICsgeDAsIGFZICsgeTAsIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0YWJzZWxsaXBzZTogZnVuY3Rpb24gKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgY3VydmUgPSBuZXcgRWxsaXBzZUN1cnZlKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5jdXJ2ZXMubGVuZ3RoID4gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBpZiBhIHByZXZpb3VzIGN1cnZlIGlzIHByZXNlbnQsIGF0dGVtcHQgdG8gam9pblxcclxcblxcdFxcdFxcdFxcdHZhciBmaXJzdFBvaW50ID0gY3VydmUuZ2V0UG9pbnQoIDAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoICEgZmlyc3RQb2ludC5lcXVhbHMoIHRoaXMuY3VycmVudFBvaW50ICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5saW5lVG8oIGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBsYXN0UG9pbnQgPSBjdXJ2ZS5nZXRQb2ludCggMSApO1xcclxcblxcdFxcdFxcdHRoaXMuY3VycmVudFBvaW50LmNvcHkoIGxhc3RQb2ludCApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Q3VydmVQYXRoLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuY3VycmVudFBvaW50LmNvcHkoIHNvdXJjZS5jdXJyZW50UG9pbnQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHRvSlNPTjogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBkYXRhID0gQ3VydmVQYXRoLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdFxcdGRhdGEuY3VycmVudFBvaW50ID0gdGhpcy5jdXJyZW50UG9pbnQudG9BcnJheSgpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBkYXRhO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0ZnJvbUpTT046IGZ1bmN0aW9uICgganNvbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRDdXJ2ZVBhdGgucHJvdG90eXBlLmZyb21KU09OLmNhbGwoIHRoaXMsIGpzb24gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmN1cnJlbnRQb2ludC5mcm9tQXJyYXkoIGpzb24uY3VycmVudFBvaW50ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXFxyXFxuXFx0ICogRGVmaW5lcyBhIDJkIHNoYXBlIHBsYW5lIHVzaW5nIHBhdGhzLlxcclxcblxcdCAqKi9cXHJcXG5cXHJcXG5cXHQvLyBTVEVQIDEgQ3JlYXRlIGEgcGF0aC5cXHJcXG5cXHQvLyBTVEVQIDIgVHVybiBwYXRoIGludG8gc2hhcGUuXFxyXFxuXFx0Ly8gU1RFUCAzIEV4dHJ1ZGVHZW9tZXRyeSB0YWtlcyBpbiBTaGFwZS9TaGFwZXNcXHJcXG5cXHQvLyBTVEVQIDNhIC0gRXh0cmFjdCBwb2ludHMgZnJvbSBlYWNoIHNoYXBlLCB0dXJuIHRvIHZlcnRpY2VzXFxyXFxuXFx0Ly8gU1RFUCAzYiAtIFRyaWFuZ3VsYXRlIGVhY2ggc2hhcGUsIGFkZCBmYWNlcy5cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBTaGFwZSggcG9pbnRzICkge1xcclxcblxcclxcblxcdFxcdFBhdGguY2FsbCggdGhpcywgcG9pbnRzICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy51dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50eXBlID0gJ1NoYXBlJztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmhvbGVzID0gW107XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdFNoYXBlLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIFBhdGgucHJvdG90eXBlICksIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zdHJ1Y3RvcjogU2hhcGUsXFxyXFxuXFxyXFxuXFx0XFx0Z2V0UG9pbnRzSG9sZXM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBob2xlc1B0cyA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRob2xlc1B0c1sgaSBdID0gdGhpcy5ob2xlc1sgaSBdLmdldFBvaW50cyggZGl2aXNpb25zICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBob2xlc1B0cztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdC8vIGdldCBwb2ludHMgb2Ygc2hhcGUgYW5kIGhvbGVzIChrZXlwb2ludHMgYmFzZWQgb24gc2VnbWVudHMgcGFyYW1ldGVyKVxcclxcblxcclxcblxcdFxcdGV4dHJhY3RQb2ludHM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0c2hhcGU6IHRoaXMuZ2V0UG9pbnRzKCBkaXZpc2lvbnMgKSxcXHJcXG5cXHRcXHRcXHRcXHRob2xlczogdGhpcy5nZXRQb2ludHNIb2xlcyggZGl2aXNpb25zIClcXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0UGF0aC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmhvbGVzID0gW107XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gc291cmNlLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGhvbGUgPSBzb3VyY2UuaG9sZXNbIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmhvbGVzLnB1c2goIGhvbGUuY2xvbmUoKSApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHRvSlNPTjogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBkYXRhID0gUGF0aC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRkYXRhLnV1aWQgPSB0aGlzLnV1aWQ7XFxyXFxuXFx0XFx0XFx0ZGF0YS5ob2xlcyA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgaG9sZSA9IHRoaXMuaG9sZXNbIGkgXTtcXHJcXG5cXHRcXHRcXHRcXHRkYXRhLmhvbGVzLnB1c2goIGhvbGUudG9KU09OKCkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGRhdGE7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRmcm9tSlNPTjogZnVuY3Rpb24gKCBqc29uICkge1xcclxcblxcclxcblxcdFxcdFxcdFBhdGgucHJvdG90eXBlLmZyb21KU09OLmNhbGwoIHRoaXMsIGpzb24gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnV1aWQgPSBqc29uLnV1aWQ7XFxyXFxuXFx0XFx0XFx0dGhpcy5ob2xlcyA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24uaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgaG9sZSA9IGpzb24uaG9sZXNbIGkgXTtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmhvbGVzLnB1c2goIG5ldyBQYXRoKCkuZnJvbUpTT04oIGhvbGUgKSApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBMaWdodCggY29sb3IsIGludGVuc2l0eSApIHtcXHJcXG5cXHJcXG5cXHRcXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50eXBlID0gJ0xpZ2h0JztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCBjb2xvciApO1xcclxcblxcdFxcdHRoaXMuaW50ZW5zaXR5ID0gaW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgPyBpbnRlbnNpdHkgOiAxO1xcclxcblxcclxcblxcdFxcdHRoaXMucmVjZWl2ZVNoYWRvdyA9IHVuZGVmaW5lZDtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0TGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICksIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zdHJ1Y3RvcjogTGlnaHQsXFxyXFxuXFxyXFxuXFx0XFx0aXNMaWdodDogdHJ1ZSxcXHJcXG5cXHJcXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRPYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xcclxcblxcdFxcdFxcdHRoaXMuaW50ZW5zaXR5ID0gc291cmNlLmludGVuc2l0eTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBkYXRhID0gT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZGF0YS5vYmplY3QuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xcclxcblxcdFxcdFxcdGRhdGEub2JqZWN0LmludGVuc2l0eSA9IHRoaXMuaW50ZW5zaXR5O1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5ncm91bmRDb2xvciAhPT0gdW5kZWZpbmVkICkgZGF0YS5vYmplY3QuZ3JvdW5kQ29sb3IgPSB0aGlzLmdyb3VuZENvbG9yLmdldEhleCgpO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5kaXN0YW5jZSAhPT0gdW5kZWZpbmVkICkgZGF0YS5vYmplY3QuZGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlO1xcclxcblxcdFxcdFxcdGlmICggdGhpcy5hbmdsZSAhPT0gdW5kZWZpbmVkICkgZGF0YS5vYmplY3QuYW5nbGUgPSB0aGlzLmFuZ2xlO1xcclxcblxcdFxcdFxcdGlmICggdGhpcy5kZWNheSAhPT0gdW5kZWZpbmVkICkgZGF0YS5vYmplY3QuZGVjYXkgPSB0aGlzLmRlY2F5O1xcclxcblxcdFxcdFxcdGlmICggdGhpcy5wZW51bWJyYSAhPT0gdW5kZWZpbmVkICkgZGF0YS5vYmplY3QucGVudW1icmEgPSB0aGlzLnBlbnVtYnJhO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5zaGFkb3cgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LnNoYWRvdyA9IHRoaXMuc2hhZG93LnRvSlNPTigpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBkYXRhO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBIZW1pc3BoZXJlTGlnaHQoIHNreUNvbG9yLCBncm91bmRDb2xvciwgaW50ZW5zaXR5ICkge1xcclxcblxcclxcblxcdFxcdExpZ2h0LmNhbGwoIHRoaXMsIHNreUNvbG9yLCBpbnRlbnNpdHkgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnSGVtaXNwaGVyZUxpZ2h0JztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmNhc3RTaGFkb3cgPSB1bmRlZmluZWQ7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5wb3NpdGlvbi5jb3B5KCBPYmplY3QzRC5EZWZhdWx0VXAgKTtcXHJcXG5cXHRcXHR0aGlzLnVwZGF0ZU1hdHJpeCgpO1xcclxcblxcclxcblxcdFxcdHRoaXMuZ3JvdW5kQ29sb3IgPSBuZXcgQ29sb3IoIGdyb3VuZENvbG9yICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdEhlbWlzcGhlcmVMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMaWdodC5wcm90b3R5cGUgKSwge1xcclxcblxcclxcblxcdFxcdGNvbnN0cnVjdG9yOiBIZW1pc3BoZXJlTGlnaHQsXFxyXFxuXFxyXFxuXFx0XFx0aXNIZW1pc3BoZXJlTGlnaHQ6IHRydWUsXFxyXFxuXFxyXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0TGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5ncm91bmRDb2xvci5jb3B5KCBzb3VyY2UuZ3JvdW5kQ29sb3IgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gTGlnaHRTaGFkb3coIGNhbWVyYSApIHtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmNhbWVyYSA9IGNhbWVyYTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmJpYXMgPSAwO1xcclxcblxcdFxcdHRoaXMucmFkaXVzID0gMTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm1hcFNpemUgPSBuZXcgVmVjdG9yMiggNTEyLCA1MTIgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm1hcCA9IG51bGw7XFxyXFxuXFx0XFx0dGhpcy5tYXRyaXggPSBuZXcgTWF0cml4NCgpO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRPYmplY3QuYXNzaWduKCBMaWdodFNoYWRvdy5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmNhbWVyYSA9IHNvdXJjZS5jYW1lcmEuY2xvbmUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmJpYXMgPSBzb3VyY2UuYmlhcztcXHJcXG5cXHRcXHRcXHR0aGlzLnJhZGl1cyA9IHNvdXJjZS5yYWRpdXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5tYXBTaXplLmNvcHkoIHNvdXJjZS5tYXBTaXplICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHRvSlNPTjogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBvYmplY3QgPSB7fTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMuYmlhcyAhPT0gMCApIG9iamVjdC5iaWFzID0gdGhpcy5iaWFzO1xcclxcblxcdFxcdFxcdGlmICggdGhpcy5yYWRpdXMgIT09IDEgKSBvYmplY3QucmFkaXVzID0gdGhpcy5yYWRpdXM7XFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLm1hcFNpemUueCAhPT0gNTEyIHx8IHRoaXMubWFwU2l6ZS55ICE9PSA1MTIgKSBvYmplY3QubWFwU2l6ZSA9IHRoaXMubWFwU2l6ZS50b0FycmF5KCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0b2JqZWN0LmNhbWVyYSA9IHRoaXMuY2FtZXJhLnRvSlNPTiggZmFsc2UgKS5vYmplY3Q7XFxyXFxuXFx0XFx0XFx0ZGVsZXRlIG9iamVjdC5jYW1lcmEubWF0cml4O1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBvYmplY3Q7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIFNwb3RMaWdodFNoYWRvdygpIHtcXHJcXG5cXHJcXG5cXHRcXHRMaWdodFNoYWRvdy5jYWxsKCB0aGlzLCBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIDUwLCAxLCAwLjUsIDUwMCApICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdFNwb3RMaWdodFNoYWRvdy5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMaWdodFNoYWRvdy5wcm90b3R5cGUgKSwge1xcclxcblxcclxcblxcdFxcdGNvbnN0cnVjdG9yOiBTcG90TGlnaHRTaGFkb3csXFxyXFxuXFxyXFxuXFx0XFx0aXNTcG90TGlnaHRTaGFkb3c6IHRydWUsXFxyXFxuXFxyXFxuXFx0XFx0dXBkYXRlOiBmdW5jdGlvbiAoIGxpZ2h0ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgZm92ID0gX01hdGguUkFEMkRFRyAqIDIgKiBsaWdodC5hbmdsZTtcXHJcXG5cXHRcXHRcXHR2YXIgYXNwZWN0ID0gdGhpcy5tYXBTaXplLndpZHRoIC8gdGhpcy5tYXBTaXplLmhlaWdodDtcXHJcXG5cXHRcXHRcXHR2YXIgZmFyID0gbGlnaHQuZGlzdGFuY2UgfHwgY2FtZXJhLmZhcjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGZvdiAhPT0gY2FtZXJhLmZvdiB8fCBhc3BlY3QgIT09IGNhbWVyYS5hc3BlY3QgfHwgZmFyICE9PSBjYW1lcmEuZmFyICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNhbWVyYS5mb3YgPSBmb3Y7XFxyXFxuXFx0XFx0XFx0XFx0Y2FtZXJhLmFzcGVjdCA9IGFzcGVjdDtcXHJcXG5cXHRcXHRcXHRcXHRjYW1lcmEuZmFyID0gZmFyO1xcclxcblxcdFxcdFxcdFxcdGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBTcG90TGlnaHQoIGNvbG9yLCBpbnRlbnNpdHksIGRpc3RhbmNlLCBhbmdsZSwgcGVudW1icmEsIGRlY2F5ICkge1xcclxcblxcclxcblxcdFxcdExpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yLCBpbnRlbnNpdHkgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnU3BvdExpZ2h0JztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnBvc2l0aW9uLmNvcHkoIE9iamVjdDNELkRlZmF1bHRVcCApO1xcclxcblxcdFxcdHRoaXMudXBkYXRlTWF0cml4KCk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50YXJnZXQgPSBuZXcgT2JqZWN0M0QoKTtcXHJcXG5cXHJcXG5cXHRcXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdwb3dlcicsIHtcXHJcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBpbnRlbnNpdHkgPSBwb3dlciBwZXIgc29saWQgYW5nbGUuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gcmVmOiBlcXVhdGlvbiAoMTcpIGZyb20gaHR0cDovL3d3dy5mcm9zdGJpdGUuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE0LzExL2NvdXJzZV9ub3Rlc19tb3ZpbmdfZnJvc3RiaXRlX3RvX3Bici5wZGZcXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5pbnRlbnNpdHkgKiBNYXRoLlBJO1xcclxcblxcclxcblxcdFxcdFxcdH0sXFxyXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHBvd2VyICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGludGVuc2l0eSA9IHBvd2VyIHBlciBzb2xpZCBhbmdsZS5cXHJcXG5cXHRcXHRcXHRcXHQvLyByZWY6IGVxdWF0aW9uICgxNykgZnJvbSBodHRwOi8vd3d3LmZyb3N0Yml0ZS5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTQvMTEvY291cnNlX25vdGVzX21vdmluZ19mcm9zdGJpdGVfdG9fcGJyLnBkZlxcclxcblxcdFxcdFxcdFxcdHRoaXMuaW50ZW5zaXR5ID0gcG93ZXIgLyBNYXRoLlBJO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHRcXHR9ICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5kaXN0YW5jZSA9ICggZGlzdGFuY2UgIT09IHVuZGVmaW5lZCApID8gZGlzdGFuY2UgOiAwO1xcclxcblxcdFxcdHRoaXMuYW5nbGUgPSAoIGFuZ2xlICE9PSB1bmRlZmluZWQgKSA/IGFuZ2xlIDogTWF0aC5QSSAvIDM7XFxyXFxuXFx0XFx0dGhpcy5wZW51bWJyYSA9ICggcGVudW1icmEgIT09IHVuZGVmaW5lZCApID8gcGVudW1icmEgOiAwO1xcclxcblxcdFxcdHRoaXMuZGVjYXkgPSAoIGRlY2F5ICE9PSB1bmRlZmluZWQgKSA/IGRlY2F5IDogMTtcXHQvLyBmb3IgcGh5c2ljYWxseSBjb3JyZWN0IGxpZ2h0cywgc2hvdWxkIGJlIDIuXFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5zaGFkb3cgPSBuZXcgU3BvdExpZ2h0U2hhZG93KCk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdFNwb3RMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMaWdodC5wcm90b3R5cGUgKSwge1xcclxcblxcclxcblxcdFxcdGNvbnN0cnVjdG9yOiBTcG90TGlnaHQsXFxyXFxuXFxyXFxuXFx0XFx0aXNTcG90TGlnaHQ6IHRydWUsXFxyXFxuXFxyXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0TGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5kaXN0YW5jZSA9IHNvdXJjZS5kaXN0YW5jZTtcXHJcXG5cXHRcXHRcXHR0aGlzLmFuZ2xlID0gc291cmNlLmFuZ2xlO1xcclxcblxcdFxcdFxcdHRoaXMucGVudW1icmEgPSBzb3VyY2UucGVudW1icmE7XFxyXFxuXFx0XFx0XFx0dGhpcy5kZWNheSA9IHNvdXJjZS5kZWNheTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnRhcmdldCA9IHNvdXJjZS50YXJnZXQuY2xvbmUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnNoYWRvdyA9IHNvdXJjZS5zaGFkb3cuY2xvbmUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gUG9pbnRMaWdodCggY29sb3IsIGludGVuc2l0eSwgZGlzdGFuY2UsIGRlY2F5ICkge1xcclxcblxcclxcblxcdFxcdExpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yLCBpbnRlbnNpdHkgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnUG9pbnRMaWdodCc7XFxyXFxuXFxyXFxuXFx0XFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAncG93ZXInLCB7XFxyXFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gaW50ZW5zaXR5ID0gcG93ZXIgcGVyIHNvbGlkIGFuZ2xlLlxcclxcblxcdFxcdFxcdFxcdC8vIHJlZjogZXF1YXRpb24gKDE1KSBmcm9tIGh0dHA6Ly93d3cuZnJvc3RiaXRlLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxNC8xMS9jb3Vyc2Vfbm90ZXNfbW92aW5nX2Zyb3N0Yml0ZV90b19wYnIucGRmXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuaW50ZW5zaXR5ICogNCAqIE1hdGguUEk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSxcXHJcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggcG93ZXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gaW50ZW5zaXR5ID0gcG93ZXIgcGVyIHNvbGlkIGFuZ2xlLlxcclxcblxcdFxcdFxcdFxcdC8vIHJlZjogZXF1YXRpb24gKDE1KSBmcm9tIGh0dHA6Ly93d3cuZnJvc3RiaXRlLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxNC8xMS9jb3Vyc2Vfbm90ZXNfbW92aW5nX2Zyb3N0Yml0ZV90b19wYnIucGRmXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5pbnRlbnNpdHkgPSBwb3dlciAvICggNCAqIE1hdGguUEkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFx0XFx0fSApO1xcclxcblxcclxcblxcdFxcdHRoaXMuZGlzdGFuY2UgPSAoIGRpc3RhbmNlICE9PSB1bmRlZmluZWQgKSA/IGRpc3RhbmNlIDogMDtcXHJcXG5cXHRcXHR0aGlzLmRlY2F5ID0gKCBkZWNheSAhPT0gdW5kZWZpbmVkICkgPyBkZWNheSA6IDE7XFx0Ly8gZm9yIHBoeXNpY2FsbHkgY29ycmVjdCBsaWdodHMsIHNob3VsZCBiZSAyLlxcclxcblxcclxcblxcdFxcdHRoaXMuc2hhZG93ID0gbmV3IExpZ2h0U2hhZG93KCBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIDkwLCAxLCAwLjUsIDUwMCApICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdFBvaW50TGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTGlnaHQucHJvdG90eXBlICksIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zdHJ1Y3RvcjogUG9pbnRMaWdodCxcXHJcXG5cXHJcXG5cXHRcXHRpc1BvaW50TGlnaHQ6IHRydWUsXFxyXFxuXFxyXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0TGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5kaXN0YW5jZSA9IHNvdXJjZS5kaXN0YW5jZTtcXHJcXG5cXHRcXHRcXHR0aGlzLmRlY2F5ID0gc291cmNlLmRlY2F5O1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuc2hhZG93ID0gc291cmNlLnNoYWRvdy5jbG9uZSgpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBEaXJlY3Rpb25hbExpZ2h0U2hhZG93KCApIHtcXHJcXG5cXHJcXG5cXHRcXHRMaWdodFNoYWRvdy5jYWxsKCB0aGlzLCBuZXcgT3J0aG9ncmFwaGljQ2FtZXJhKCAtIDUsIDUsIDUsIC0gNSwgMC41LCA1MDAgKSApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHREaXJlY3Rpb25hbExpZ2h0U2hhZG93LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExpZ2h0U2hhZG93LnByb3RvdHlwZSApLCB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc3RydWN0b3I6IERpcmVjdGlvbmFsTGlnaHRTaGFkb3dcXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIERpcmVjdGlvbmFsTGlnaHQoIGNvbG9yLCBpbnRlbnNpdHkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0TGlnaHQuY2FsbCggdGhpcywgY29sb3IsIGludGVuc2l0eSApO1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdEaXJlY3Rpb25hbExpZ2h0JztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnBvc2l0aW9uLmNvcHkoIE9iamVjdDNELkRlZmF1bHRVcCApO1xcclxcblxcdFxcdHRoaXMudXBkYXRlTWF0cml4KCk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50YXJnZXQgPSBuZXcgT2JqZWN0M0QoKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnNoYWRvdyA9IG5ldyBEaXJlY3Rpb25hbExpZ2h0U2hhZG93KCk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdERpcmVjdGlvbmFsTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTGlnaHQucHJvdG90eXBlICksIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zdHJ1Y3RvcjogRGlyZWN0aW9uYWxMaWdodCxcXHJcXG5cXHJcXG5cXHRcXHRpc0RpcmVjdGlvbmFsTGlnaHQ6IHRydWUsXFxyXFxuXFxyXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0TGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy50YXJnZXQgPSBzb3VyY2UudGFyZ2V0LmNsb25lKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5zaGFkb3cgPSBzb3VyY2Uuc2hhZG93LmNsb25lKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIEFtYmllbnRMaWdodCggY29sb3IsIGludGVuc2l0eSApIHtcXHJcXG5cXHJcXG5cXHRcXHRMaWdodC5jYWxsKCB0aGlzLCBjb2xvciwgaW50ZW5zaXR5ICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50eXBlID0gJ0FtYmllbnRMaWdodCc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5jYXN0U2hhZG93ID0gdW5kZWZpbmVkO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRBbWJpZW50TGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTGlnaHQucHJvdG90eXBlICksIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zdHJ1Y3RvcjogQW1iaWVudExpZ2h0LFxcclxcblxcclxcblxcdFxcdGlzQW1iaWVudExpZ2h0OiB0cnVlXFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgYWJlbG5hdGlvbiAvIGh0dHA6Ly9naXRodWIuY29tL2FiZWxuYXRpb25cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBSZWN0QXJlYUxpZ2h0KCBjb2xvciwgaW50ZW5zaXR5LCB3aWR0aCwgaGVpZ2h0ICkge1xcclxcblxcclxcblxcdFxcdExpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yLCBpbnRlbnNpdHkgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnUmVjdEFyZWFMaWdodCc7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5wb3NpdGlvbi5zZXQoIDAsIDEsIDAgKTtcXHJcXG5cXHRcXHR0aGlzLnVwZGF0ZU1hdHJpeCgpO1xcclxcblxcclxcblxcdFxcdHRoaXMud2lkdGggPSAoIHdpZHRoICE9PSB1bmRlZmluZWQgKSA/IHdpZHRoIDogMTA7XFxyXFxuXFx0XFx0dGhpcy5oZWlnaHQgPSAoIGhlaWdodCAhPT0gdW5kZWZpbmVkICkgPyBoZWlnaHQgOiAxMDtcXHJcXG5cXHJcXG5cXHRcXHQvLyBUT0RPIChhYmVsbmF0aW9uKTogZGlzdGFuY2UvZGVjYXlcXHJcXG5cXHJcXG5cXHRcXHQvLyBUT0RPIChhYmVsbmF0aW9uKTogdXBkYXRlIG1ldGhvZCBmb3IgUmVjdEFyZWFMaWdodCB0byB1cGRhdGUgdHJhbnNmb3JtIHRvIGxvb2thdCB0YXJnZXRcXHJcXG5cXHJcXG5cXHRcXHQvLyBUT0RPIChhYmVsbmF0aW9uKTogc2hhZG93c1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHQvLyBUT0RPIChhYmVsbmF0aW9uKTogUmVjdEFyZWFMaWdodCB1cGRhdGUgd2hlbiBsaWdodCBzaGFwZSBpcyBjaGFuZ2VkXFxyXFxuXFx0UmVjdEFyZWFMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMaWdodC5wcm90b3R5cGUgKSwge1xcclxcblxcclxcblxcdFxcdGNvbnN0cnVjdG9yOiBSZWN0QXJlYUxpZ2h0LFxcclxcblxcclxcblxcdFxcdGlzUmVjdEFyZWFMaWdodDogdHJ1ZSxcXHJcXG5cXHJcXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRMaWdodC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLndpZHRoID0gc291cmNlLndpZHRoO1xcclxcblxcdFxcdFxcdHRoaXMuaGVpZ2h0ID0gc291cmNlLmhlaWdodDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBkYXRhID0gTGlnaHQucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZGF0YS5vYmplY3Qud2lkdGggPSB0aGlzLndpZHRoO1xcclxcblxcdFxcdFxcdGRhdGEub2JqZWN0LmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBkYXRhO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBBIFRyYWNrIHRoYXQgaW50ZXJwb2xhdGVzIFN0cmluZ3NcXHJcXG5cXHQgKlxcclxcblxcdCAqXFxyXFxuXFx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cXHJcXG5cXHQgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cXHJcXG5cXHQgKiBAYXV0aG9yIHRzY2h3XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gU3RyaW5nS2V5ZnJhbWVUcmFjayggbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRLZXlmcmFtZVRyYWNrLmNhbGwoIHRoaXMsIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0U3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBLZXlmcmFtZVRyYWNrLnByb3RvdHlwZSApLCB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc3RydWN0b3I6IFN0cmluZ0tleWZyYW1lVHJhY2ssXFxyXFxuXFxyXFxuXFx0XFx0VmFsdWVUeXBlTmFtZTogJ3N0cmluZycsXFxyXFxuXFx0XFx0VmFsdWVCdWZmZXJUeXBlOiBBcnJheSxcXHJcXG5cXHJcXG5cXHRcXHREZWZhdWx0SW50ZXJwb2xhdGlvbjogSW50ZXJwb2xhdGVEaXNjcmV0ZSxcXHJcXG5cXHJcXG5cXHRcXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXI6IHVuZGVmaW5lZCxcXHJcXG5cXHJcXG5cXHRcXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg6IHVuZGVmaW5lZFxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKlxcclxcblxcdCAqIEEgVHJhY2sgb2YgQm9vbGVhbiBrZXlmcmFtZSB2YWx1ZXMuXFxyXFxuXFx0ICpcXHJcXG5cXHQgKlxcclxcblxcdCAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXFxyXFxuXFx0ICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXFxyXFxuXFx0ICogQGF1dGhvciB0c2Nod1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIEJvb2xlYW5LZXlmcmFtZVRyYWNrKCBuYW1lLCB0aW1lcywgdmFsdWVzICkge1xcclxcblxcclxcblxcdFxcdEtleWZyYW1lVHJhY2suY2FsbCggdGhpcywgbmFtZSwgdGltZXMsIHZhbHVlcyApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRCb29sZWFuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBLZXlmcmFtZVRyYWNrLnByb3RvdHlwZSApLCB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc3RydWN0b3I6IEJvb2xlYW5LZXlmcmFtZVRyYWNrLFxcclxcblxcclxcblxcdFxcdFZhbHVlVHlwZU5hbWU6ICdib29sJyxcXHJcXG5cXHRcXHRWYWx1ZUJ1ZmZlclR5cGU6IEFycmF5LFxcclxcblxcclxcblxcdFxcdERlZmF1bHRJbnRlcnBvbGF0aW9uOiBJbnRlcnBvbGF0ZURpc2NyZXRlLFxcclxcblxcclxcblxcdFxcdEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjogdW5kZWZpbmVkLFxcclxcblxcdFxcdEludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aDogdW5kZWZpbmVkXFxyXFxuXFxyXFxuXFx0XFx0Ly8gTm90ZTogQWN0dWFsbHkgdGhpcyB0cmFjayBjb3VsZCBoYXZlIGEgb3B0aW1pemVkIC8gY29tcHJlc3NlZFxcclxcblxcdFxcdC8vIHJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIHZhbHVlIGFuZCBhIGN1c3RvbSBpbnRlcnBvbGFudCB0aGF0XFxyXFxuXFx0XFx0Ly8gY29tcHV0ZXMgXFxcImZpcnN0VmFsdWUgXiBpc09kZCggaW5kZXggKVxcXCIuXFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEFic3RyYWN0IGJhc2UgY2xhc3Mgb2YgaW50ZXJwb2xhbnRzIG92ZXIgcGFyYW1ldHJpYyBzYW1wbGVzLlxcclxcblxcdCAqXFxyXFxuXFx0ICogVGhlIHBhcmFtZXRlciBkb21haW4gaXMgb25lIGRpbWVuc2lvbmFsLCB0eXBpY2FsbHkgdGhlIHRpbWUgb3IgYSBwYXRoXFxyXFxuXFx0ICogYWxvbmcgYSBjdXJ2ZSBkZWZpbmVkIGJ5IHRoZSBkYXRhLlxcclxcblxcdCAqXFxyXFxuXFx0ICogVGhlIHNhbXBsZSB2YWx1ZXMgY2FuIGhhdmUgYW55IGRpbWVuc2lvbmFsaXR5IGFuZCBkZXJpdmVkIGNsYXNzZXMgbWF5XFxyXFxuXFx0ICogYXBwbHkgc3BlY2lhbCBpbnRlcnByZXRhdGlvbnMgdG8gdGhlIGRhdGEuXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBUaGlzIGNsYXNzIHByb3ZpZGVzIHRoZSBpbnRlcnZhbCBzZWVrIGluIGEgVGVtcGxhdGUgTWV0aG9kLCBkZWZlcnJpbmdcXHJcXG5cXHQgKiB0aGUgYWN0dWFsIGludGVycG9sYXRpb24gdG8gZGVyaXZlZCBjbGFzc2VzLlxcclxcblxcdCAqXFxyXFxuXFx0ICogVGltZSBjb21wbGV4aXR5IGlzIE8oMSkgZm9yIGxpbmVhciBhY2Nlc3MgY3Jvc3NpbmcgYXQgbW9zdCB0d28gcG9pbnRzXFxyXFxuXFx0ICogYW5kIE8obG9nIE4pIGZvciByYW5kb20gYWNjZXNzLCB3aGVyZSBOIGlzIHRoZSBudW1iZXIgb2YgcG9zaXRpb25zLlxcclxcblxcdCAqXFxyXFxuXFx0ICogUmVmZXJlbmNlczpcXHJcXG5cXHQgKlxcclxcblxcdCAqIFxcdFxcdGh0dHA6Ly93d3cub29kZXNpZ24uY29tL3RlbXBsYXRlLW1ldGhvZC1wYXR0ZXJuLmh0bWxcXHJcXG5cXHQgKlxcclxcblxcdCAqIEBhdXRob3IgdHNjaHdcXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBJbnRlcnBvbGFudCggcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApIHtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnBhcmFtZXRlclBvc2l0aW9ucyA9IHBhcmFtZXRlclBvc2l0aW9ucztcXHJcXG5cXHRcXHR0aGlzLl9jYWNoZWRJbmRleCA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5yZXN1bHRCdWZmZXIgPSByZXN1bHRCdWZmZXIgIT09IHVuZGVmaW5lZCA/XFxyXFxuXFx0XFx0XFx0cmVzdWx0QnVmZmVyIDogbmV3IHNhbXBsZVZhbHVlcy5jb25zdHJ1Y3Rvciggc2FtcGxlU2l6ZSApO1xcclxcblxcdFxcdHRoaXMuc2FtcGxlVmFsdWVzID0gc2FtcGxlVmFsdWVzO1xcclxcblxcdFxcdHRoaXMudmFsdWVTaXplID0gc2FtcGxlU2l6ZTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0T2JqZWN0LmFzc2lnbiggSW50ZXJwb2xhbnQucHJvdG90eXBlLCB7XFxyXFxuXFxyXFxuXFx0XFx0ZXZhbHVhdGU6IGZ1bmN0aW9uICggdCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcHAgPSB0aGlzLnBhcmFtZXRlclBvc2l0aW9ucyxcXHJcXG5cXHRcXHRcXHRcXHRpMSA9IHRoaXMuX2NhY2hlZEluZGV4LFxcclxcblxcclxcblxcdFxcdFxcdFxcdHQxID0gcHBbIGkxIF0sXFxyXFxuXFx0XFx0XFx0XFx0dDAgPSBwcFsgaTEgLSAxIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFsaWRhdGVfaW50ZXJ2YWw6IHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzZWVrOiB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHJpZ2h0O1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGxpbmVhcl9zY2FuOiB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8tIFNlZSBodHRwOi8vanNwZXJmLmNvbS9jb21wYXJpc29uLXRvLXVuZGVmaW5lZC8zXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8tIHNsb3dlciBjb2RlOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdC8vLVxcclxcblxcdFxcdFxcdFxcdFxcdFxcdC8vLSBcXHRcXHRcXHRcXHRpZiAoIHQgPj0gdDEgfHwgdDEgPT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3J3YXJkX3NjYW46IGlmICggISAoIHQgPCB0MSApICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBnaXZlVXBBdCA9IGkxICsgMjsgOyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHQxID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB0IDwgdDAgKSBicmVhayBmb3J3YXJkX3NjYW47XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gYWZ0ZXIgZW5kXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aTEgPSBwcC5sZW5ndGg7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fY2FjaGVkSW5kZXggPSBpMTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5hZnRlckVuZF8oIGkxIC0gMSwgdCwgdDAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBpMSA9PT0gZ2l2ZVVwQXQgKSBicmVhazsgLy8gdGhpcyBsb29wXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dDAgPSB0MTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0MSA9IHBwWyArKyBpMSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggdCA8IHQxICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHdlIGhhdmUgYXJyaXZlZCBhdCB0aGUgc291Z2h0IGludGVydmFsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWsgc2VlaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHByZXBhcmUgYmluYXJ5IHNlYXJjaCBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgaW5kZXhcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyaWdodCA9IHBwLmxlbmd0aDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhayBsaW5lYXJfc2NhbjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8tIHNsb3dlciBjb2RlOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdC8vLVxcdFxcdFxcdFxcdFxcdGlmICggdCA8IHQwIHx8IHQwID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCAhICggdCA+PSB0MCApICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGxvb3Bpbmc/XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIHQxZ2xvYmFsID0gcHBbIDEgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHQgPCB0MWdsb2JhbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpMSA9IDI7IC8vICsgMSwgdXNpbmcgdGhlIHNjYW4gZm9yIHRoZSBkZXRhaWxzXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dDAgPSB0MWdsb2JhbDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gbGluZWFyIHJldmVyc2Ugc2NhblxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBnaXZlVXBBdCA9IGkxIC0gMjsgOyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHQwID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gYmVmb3JlIHN0YXJ0XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fY2FjaGVkSW5kZXggPSAwO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmJlZm9yZVN0YXJ0XyggMCwgdCwgdDEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBpMSA9PT0gZ2l2ZVVwQXQgKSBicmVhazsgLy8gdGhpcyBsb29wXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dDEgPSB0MDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0MCA9IHBwWyAtLSBpMSAtIDEgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHQgPj0gdDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gd2UgaGF2ZSBhcnJpdmVkIGF0IHRoZSBzb3VnaHQgaW50ZXJ2YWxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhayBzZWVrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gcHJlcGFyZSBiaW5hcnkgc2VhcmNoIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGluZGV4XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmlnaHQgPSBpMTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpMSA9IDA7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWsgbGluZWFyX3NjYW47XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHRoZSBpbnRlcnZhbCBpcyB2YWxpZFxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrIHZhbGlkYXRlX2ludGVydmFsO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH0gLy8gbGluZWFyIHNjYW5cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBiaW5hcnkgc2VhcmNoXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKCBpMSA8IHJpZ2h0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBtaWQgPSAoIGkxICsgcmlnaHQgKSA+Pj4gMTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHQgPCBwcFsgbWlkIF0gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmlnaHQgPSBtaWQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpMSA9IG1pZCArIDE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0MSA9IHBwWyBpMSBdO1xcclxcblxcdFxcdFxcdFxcdFxcdHQwID0gcHBbIGkxIC0gMSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIGNoZWNrIGJvdW5kYXJ5IGNhc2VzLCBhZ2FpblxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggdDAgPT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9jYWNoZWRJbmRleCA9IDA7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuYmVmb3JlU3RhcnRfKCAwLCB0LCB0MSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHQxID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aTEgPSBwcC5sZW5ndGg7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fY2FjaGVkSW5kZXggPSBpMTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5hZnRlckVuZF8oIGkxIC0gMSwgdDAsIHQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSAvLyBzZWVrXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5fY2FjaGVkSW5kZXggPSBpMTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmludGVydmFsQ2hhbmdlZF8oIGkxLCB0MCwgdDEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IC8vIHZhbGlkYXRlX2ludGVydmFsXFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuaW50ZXJwb2xhdGVfKCBpMSwgdDAsIHQsIHQxICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXR0aW5nczogbnVsbCwgLy8gb3B0aW9uYWwsIHN1YmNsYXNzLXNwZWNpZmljIHNldHRpbmdzIHN0cnVjdHVyZVxcclxcblxcdFxcdC8vIE5vdGU6IFRoZSBpbmRpcmVjdGlvbiBhbGxvd3MgY2VudHJhbCBjb250cm9sIG9mIG1hbnkgaW50ZXJwb2xhbnRzLlxcclxcblxcclxcblxcdFxcdC8vIC0tLSBQcm90ZWN0ZWQgaW50ZXJmYWNlXFxyXFxuXFxyXFxuXFx0XFx0RGVmYXVsdFNldHRpbmdzXzoge30sXFxyXFxuXFxyXFxuXFx0XFx0Z2V0U2V0dGluZ3NfOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuc2V0dGluZ3MgfHwgdGhpcy5EZWZhdWx0U2V0dGluZ3NfO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y29weVNhbXBsZVZhbHVlXzogZnVuY3Rpb24gKCBpbmRleCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBjb3BpZXMgYSBzYW1wbGUgdmFsdWUgdG8gdGhlIHJlc3VsdCBidWZmZXJcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsXFxyXFxuXFx0XFx0XFx0XFx0dmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXMsXFxyXFxuXFx0XFx0XFx0XFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXFxyXFxuXFx0XFx0XFx0XFx0b2Zmc2V0ID0gaW5kZXggKiBzdHJpZGU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmVzdWx0WyBpIF0gPSB2YWx1ZXNbIG9mZnNldCArIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHJlc3VsdDtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdC8vIFRlbXBsYXRlIG1ldGhvZHMgZm9yIGRlcml2ZWQgY2xhc3NlczpcXHJcXG5cXHJcXG5cXHRcXHRpbnRlcnBvbGF0ZV86IGZ1bmN0aW9uICggLyogaTEsIHQwLCB0LCB0MSAqLyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoICdjYWxsIHRvIGFic3RyYWN0IG1ldGhvZCcgKTtcXHJcXG5cXHRcXHRcXHQvLyBpbXBsZW1lbnRhdGlvbnMgc2hhbGwgcmV0dXJuIHRoaXMucmVzdWx0QnVmZmVyXFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRpbnRlcnZhbENoYW5nZWRfOiBmdW5jdGlvbiAoIC8qIGkxLCB0MCwgdDEgKi8gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gZW1wdHlcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8vIVxcXFwgREVDTEFSRSBBTElBUyBBRlRFUiBhc3NpZ24gcHJvdG90eXBlICFcXHJcXG5cXHRPYmplY3QuYXNzaWduKCBJbnRlcnBvbGFudC5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHQvLyggMCwgdCwgdDAgKSwgcmV0dXJucyB0aGlzLnJlc3VsdEJ1ZmZlclxcclxcblxcdFxcdGJlZm9yZVN0YXJ0XzogSW50ZXJwb2xhbnQucHJvdG90eXBlLmNvcHlTYW1wbGVWYWx1ZV8sXFxyXFxuXFxyXFxuXFx0XFx0Ly8oIE4tMSwgdE4tMSwgdCApLCByZXR1cm5zIHRoaXMucmVzdWx0QnVmZmVyXFxyXFxuXFx0XFx0YWZ0ZXJFbmRfOiBJbnRlcnBvbGFudC5wcm90b3R5cGUuY29weVNhbXBsZVZhbHVlXyxcXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogU3BoZXJpY2FsIGxpbmVhciB1bml0IHF1YXRlcm5pb24gaW50ZXJwb2xhbnQuXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBAYXV0aG9yIHRzY2h3XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50KCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xcclxcblxcclxcblxcdFxcdEludGVycG9sYW50LmNhbGwoIHRoaXMsIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0UXVhdGVybmlvbkxpbmVhckludGVycG9sYW50LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEludGVycG9sYW50LnByb3RvdHlwZSApLCB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc3RydWN0b3I6IFF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudCxcXHJcXG5cXHJcXG5cXHRcXHRpbnRlcnBvbGF0ZV86IGZ1bmN0aW9uICggaTEsIHQwLCB0LCB0MSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsXFxyXFxuXFx0XFx0XFx0XFx0dmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXMsXFxyXFxuXFx0XFx0XFx0XFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0b2Zmc2V0ID0gaTEgKiBzdHJpZGUsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YWxwaGEgPSAoIHQgLSB0MCApIC8gKCB0MSAtIHQwICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGVuZCA9IG9mZnNldCArIHN0cmlkZTsgb2Zmc2V0ICE9PSBlbmQ7IG9mZnNldCArPSA0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFF1YXRlcm5pb24uc2xlcnBGbGF0KCByZXN1bHQsIDAsIHZhbHVlcywgb2Zmc2V0IC0gc3RyaWRlLCB2YWx1ZXMsIG9mZnNldCwgYWxwaGEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHJlc3VsdDtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqXFxyXFxuXFx0ICogQSBUcmFjayBvZiBxdWF0ZXJuaW9uIGtleWZyYW1lIHZhbHVlcy5cXHJcXG5cXHQgKlxcclxcblxcdCAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXFxyXFxuXFx0ICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXFxyXFxuXFx0ICogQGF1dGhvciB0c2Nod1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrKCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICkge1xcclxcblxcclxcblxcdFxcdEtleWZyYW1lVHJhY2suY2FsbCggdGhpcywgbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBLZXlmcmFtZVRyYWNrLnByb3RvdHlwZSApLCB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc3RydWN0b3I6IFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLFxcclxcblxcclxcblxcdFxcdFZhbHVlVHlwZU5hbWU6ICdxdWF0ZXJuaW9uJyxcXHJcXG5cXHJcXG5cXHRcXHQvLyBWYWx1ZUJ1ZmZlclR5cGUgaXMgaW5oZXJpdGVkXFxyXFxuXFxyXFxuXFx0XFx0RGVmYXVsdEludGVycG9sYXRpb246IEludGVycG9sYXRlTGluZWFyLFxcclxcblxcclxcblxcdFxcdEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjogZnVuY3Rpb24gKCByZXN1bHQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyBRdWF0ZXJuaW9uTGluZWFySW50ZXJwb2xhbnQoIHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpLCByZXN1bHQgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdEludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aDogdW5kZWZpbmVkIC8vIG5vdCB5ZXQgaW1wbGVtZW50ZWRcXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBBIFRyYWNrIG9mIGtleWZyYW1lIHZhbHVlcyB0aGF0IHJlcHJlc2VudCBjb2xvci5cXHJcXG5cXHQgKlxcclxcblxcdCAqXFxyXFxuXFx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cXHJcXG5cXHQgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cXHJcXG5cXHQgKiBAYXV0aG9yIHRzY2h3XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gQ29sb3JLZXlmcmFtZVRyYWNrKCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICkge1xcclxcblxcclxcblxcdFxcdEtleWZyYW1lVHJhY2suY2FsbCggdGhpcywgbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRDb2xvcktleWZyYW1lVHJhY2sucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgKSwge1xcclxcblxcclxcblxcdFxcdGNvbnN0cnVjdG9yOiBDb2xvcktleWZyYW1lVHJhY2ssXFxyXFxuXFxyXFxuXFx0XFx0VmFsdWVUeXBlTmFtZTogJ2NvbG9yJ1xcclxcblxcclxcblxcdFxcdC8vIFZhbHVlQnVmZmVyVHlwZSBpcyBpbmhlcml0ZWRcXHJcXG5cXHJcXG5cXHRcXHQvLyBEZWZhdWx0SW50ZXJwb2xhdGlvbiBpcyBpbmhlcml0ZWRcXHJcXG5cXHJcXG5cXHRcXHQvLyBOb3RlOiBWZXJ5IGJhc2ljIGltcGxlbWVudGF0aW9uIGFuZCBub3RoaW5nIHNwZWNpYWwgeWV0LlxcclxcblxcdFxcdC8vIEhvd2V2ZXIsIHRoaXMgaXMgdGhlIHBsYWNlIGZvciBjb2xvciBzcGFjZSBwYXJhbWV0ZXJpemF0aW9uLlxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKlxcclxcblxcdCAqIEEgVHJhY2sgb2YgbnVtZXJpYyBrZXlmcmFtZSB2YWx1ZXMuXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xcclxcblxcdCAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xcclxcblxcdCAqIEBhdXRob3IgdHNjaHdcXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBOdW1iZXJLZXlmcmFtZVRyYWNrKCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICkge1xcclxcblxcclxcblxcdFxcdEtleWZyYW1lVHJhY2suY2FsbCggdGhpcywgbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHROdW1iZXJLZXlmcmFtZVRyYWNrLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEtleWZyYW1lVHJhY2sucHJvdG90eXBlICksIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zdHJ1Y3RvcjogTnVtYmVyS2V5ZnJhbWVUcmFjayxcXHJcXG5cXHJcXG5cXHRcXHRWYWx1ZVR5cGVOYW1lOiAnbnVtYmVyJ1xcclxcblxcclxcblxcdFxcdC8vIFZhbHVlQnVmZmVyVHlwZSBpcyBpbmhlcml0ZWRcXHJcXG5cXHJcXG5cXHRcXHQvLyBEZWZhdWx0SW50ZXJwb2xhdGlvbiBpcyBpbmhlcml0ZWRcXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogRmFzdCBhbmQgc2ltcGxlIGN1YmljIHNwbGluZSBpbnRlcnBvbGFudC5cXHJcXG5cXHQgKlxcclxcblxcdCAqIEl0IHdhcyBkZXJpdmVkIGZyb20gYSBIZXJtaXRpYW4gY29uc3RydWN0aW9uIHNldHRpbmcgdGhlIGZpcnN0IGRlcml2YXRpdmVcXHJcXG5cXHQgKiBhdCBlYWNoIHNhbXBsZSBwb3NpdGlvbiB0byB0aGUgbGluZWFyIHNsb3BlIGJldHdlZW4gbmVpZ2hib3JpbmcgcG9zaXRpb25zXFxyXFxuXFx0ICogb3ZlciB0aGVpciBwYXJhbWV0ZXIgaW50ZXJ2YWwuXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBAYXV0aG9yIHRzY2h3XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gQ3ViaWNJbnRlcnBvbGFudCggcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApIHtcXHJcXG5cXHJcXG5cXHRcXHRJbnRlcnBvbGFudC5jYWxsKCB0aGlzLCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5fd2VpZ2h0UHJldiA9IC0gMDtcXHJcXG5cXHRcXHR0aGlzLl9vZmZzZXRQcmV2ID0gLSAwO1xcclxcblxcdFxcdHRoaXMuX3dlaWdodE5leHQgPSAtIDA7XFxyXFxuXFx0XFx0dGhpcy5fb2Zmc2V0TmV4dCA9IC0gMDtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0Q3ViaWNJbnRlcnBvbGFudC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBJbnRlcnBvbGFudC5wcm90b3R5cGUgKSwge1xcclxcblxcclxcblxcdFxcdGNvbnN0cnVjdG9yOiBDdWJpY0ludGVycG9sYW50LFxcclxcblxcclxcblxcdFxcdERlZmF1bHRTZXR0aW5nc186IHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRlbmRpbmdTdGFydDogWmVyb0N1cnZhdHVyZUVuZGluZyxcXHJcXG5cXHRcXHRcXHRlbmRpbmdFbmQ6IFplcm9DdXJ2YXR1cmVFbmRpbmdcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGludGVydmFsQ2hhbmdlZF86IGZ1bmN0aW9uICggaTEsIHQwLCB0MSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcHAgPSB0aGlzLnBhcmFtZXRlclBvc2l0aW9ucyxcXHJcXG5cXHRcXHRcXHRcXHRpUHJldiA9IGkxIC0gMixcXHJcXG5cXHRcXHRcXHRcXHRpTmV4dCA9IGkxICsgMSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0UHJldiA9IHBwWyBpUHJldiBdLFxcclxcblxcdFxcdFxcdFxcdHROZXh0ID0gcHBbIGlOZXh0IF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0UHJldiA9PT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHN3aXRjaCAoIHRoaXMuZ2V0U2V0dGluZ3NfKCkuZW5kaW5nU3RhcnQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSBaZXJvU2xvcGVFbmRpbmc6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gZicodDApID0gMFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlQcmV2ID0gaTE7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dFByZXYgPSAyICogdDAgLSB0MTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRjYXNlIFdyYXBBcm91bmRFbmRpbmc6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gdXNlIHRoZSBvdGhlciBlbmQgb2YgdGhlIGN1cnZlXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aVByZXYgPSBwcC5sZW5ndGggLSAyO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHRQcmV2ID0gdDAgKyBwcFsgaVByZXYgXSAtIHBwWyBpUHJldiArIDEgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRkZWZhdWx0OiAvLyBaZXJvQ3VydmF0dXJlRW5kaW5nXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gZicnKHQwKSA9IDAgYS5rLmEuIE5hdHVyYWwgU3BsaW5lXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aVByZXYgPSBpMTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR0UHJldiA9IHQxO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0TmV4dCA9PT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHN3aXRjaCAoIHRoaXMuZ2V0U2V0dGluZ3NfKCkuZW5kaW5nRW5kICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNhc2UgWmVyb1Nsb3BlRW5kaW5nOlxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGYnKHROKSA9IDBcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpTmV4dCA9IGkxO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHROZXh0ID0gMiAqIHQxIC0gdDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSBXcmFwQXJvdW5kRW5kaW5nOlxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHVzZSB0aGUgb3RoZXIgZW5kIG9mIHRoZSBjdXJ2ZVxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlOZXh0ID0gMTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR0TmV4dCA9IHQxICsgcHBbIDEgXSAtIHBwWyAwIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0ZGVmYXVsdDogLy8gWmVyb0N1cnZhdHVyZUVuZGluZ1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGYnJyh0TikgPSAwLCBhLmsuYS4gTmF0dXJhbCBTcGxpbmVcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpTmV4dCA9IGkxIC0gMTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR0TmV4dCA9IHQwO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGhhbGZEdCA9ICggdDEgLSB0MCApICogMC41LFxcclxcblxcdFxcdFxcdFxcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuX3dlaWdodFByZXYgPSBoYWxmRHQgLyAoIHQwIC0gdFByZXYgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLl93ZWlnaHROZXh0ID0gaGFsZkR0IC8gKCB0TmV4dCAtIHQxICk7XFxyXFxuXFx0XFx0XFx0dGhpcy5fb2Zmc2V0UHJldiA9IGlQcmV2ICogc3RyaWRlO1xcclxcblxcdFxcdFxcdHRoaXMuX29mZnNldE5leHQgPSBpTmV4dCAqIHN0cmlkZTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGludGVycG9sYXRlXzogZnVuY3Rpb24gKCBpMSwgdDAsIHQsIHQxICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcixcXHJcXG5cXHRcXHRcXHRcXHR2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcyxcXHJcXG5cXHRcXHRcXHRcXHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRvMSA9IGkxICogc3RyaWRlLFxcdFxcdG8wID0gbzEgLSBzdHJpZGUsXFxyXFxuXFx0XFx0XFx0XFx0b1AgPSB0aGlzLl9vZmZzZXRQcmV2LCBcXHRvTiA9IHRoaXMuX29mZnNldE5leHQsXFxyXFxuXFx0XFx0XFx0XFx0d1AgPSB0aGlzLl93ZWlnaHRQcmV2LFxcdHdOID0gdGhpcy5fd2VpZ2h0TmV4dCxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRwID0gKCB0IC0gdDAgKSAvICggdDEgLSB0MCApLFxcclxcblxcdFxcdFxcdFxcdHBwID0gcCAqIHAsXFxyXFxuXFx0XFx0XFx0XFx0cHBwID0gcHAgKiBwO1xcclxcblxcclxcblxcdFxcdFxcdC8vIGV2YWx1YXRlIHBvbHlub21pYWxzXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHNQID0gLSB3UCAqIHBwcCArIDIgKiB3UCAqIHBwIC0gd1AgKiBwO1xcclxcblxcdFxcdFxcdHZhciBzMCA9ICggMSArIHdQICkgKiBwcHAgKyAoIC0gMS41IC0gMiAqIHdQICkgKiBwcCArICggLSAwLjUgKyB3UCApICogcCArIDE7XFxyXFxuXFx0XFx0XFx0dmFyIHMxID0gKCAtIDEgLSB3TiApICogcHBwICsgKCAxLjUgKyB3TiApICogcHAgKyAwLjUgKiBwO1xcclxcblxcdFxcdFxcdHZhciBzTiA9IHdOICogcHBwIC0gd04gKiBwcDtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBjb21iaW5lIGRhdGEgbGluZWFybHlcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IHN0cmlkZTsgKysgaSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXN1bHRbIGkgXSA9XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0c1AgKiB2YWx1ZXNbIG9QICsgaSBdICtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRzMCAqIHZhbHVlc1sgbzAgKyBpIF0gK1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHMxICogdmFsdWVzWyBvMSArIGkgXSArXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0c04gKiB2YWx1ZXNbIG9OICsgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0O1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciB0c2Nod1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIExpbmVhckludGVycG9sYW50KCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xcclxcblxcclxcblxcdFxcdEludGVycG9sYW50LmNhbGwoIHRoaXMsIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0TGluZWFySW50ZXJwb2xhbnQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggSW50ZXJwb2xhbnQucHJvdG90eXBlICksIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zdHJ1Y3RvcjogTGluZWFySW50ZXJwb2xhbnQsXFxyXFxuXFxyXFxuXFx0XFx0aW50ZXJwb2xhdGVfOiBmdW5jdGlvbiAoIGkxLCB0MCwgdCwgdDEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyLFxcclxcblxcdFxcdFxcdFxcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxcclxcblxcdFxcdFxcdFxcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxcclxcblxcclxcblxcdFxcdFxcdFxcdG9mZnNldDEgPSBpMSAqIHN0cmlkZSxcXHJcXG5cXHRcXHRcXHRcXHRvZmZzZXQwID0gb2Zmc2V0MSAtIHN0cmlkZSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR3ZWlnaHQxID0gKCB0IC0gdDAgKSAvICggdDEgLSB0MCApLFxcclxcblxcdFxcdFxcdFxcdHdlaWdodDAgPSAxIC0gd2VpZ2h0MTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IHN0cmlkZTsgKysgaSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXN1bHRbIGkgXSA9XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFsdWVzWyBvZmZzZXQwICsgaSBdICogd2VpZ2h0MCArXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFsdWVzWyBvZmZzZXQxICsgaSBdICogd2VpZ2h0MTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHJlc3VsdDtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqXFxyXFxuXFx0ICogSW50ZXJwb2xhbnQgdGhhdCBldmFsdWF0ZXMgdG8gdGhlIHNhbXBsZSB2YWx1ZSBhdCB0aGUgcG9zaXRpb24gcHJlY2VlZGluZ1xcclxcblxcdCAqIHRoZSBwYXJhbWV0ZXIuXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBAYXV0aG9yIHRzY2h3XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gRGlzY3JldGVJbnRlcnBvbGFudCggcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApIHtcXHJcXG5cXHJcXG5cXHRcXHRJbnRlcnBvbGFudC5jYWxsKCB0aGlzLCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdERpc2NyZXRlSW50ZXJwb2xhbnQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggSW50ZXJwb2xhbnQucHJvdG90eXBlICksIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zdHJ1Y3RvcjogRGlzY3JldGVJbnRlcnBvbGFudCxcXHJcXG5cXHJcXG5cXHRcXHRpbnRlcnBvbGF0ZV86IGZ1bmN0aW9uICggaTEgLyosIHQwLCB0LCB0MSAqLyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5jb3B5U2FtcGxlVmFsdWVfKCBpMSAtIDEgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgdHNjaHdcXHJcXG5cXHQgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xcclxcblxcdCAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdHZhciBBbmltYXRpb25VdGlscyA9IHtcXHJcXG5cXHJcXG5cXHRcXHQvLyBzYW1lIGFzIEFycmF5LnByb3RvdHlwZS5zbGljZSwgYnV0IGFsc28gd29ya3Mgb24gdHlwZWQgYXJyYXlzXFxyXFxuXFx0XFx0YXJyYXlTbGljZTogZnVuY3Rpb24gKCBhcnJheSwgZnJvbSwgdG8gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBBbmltYXRpb25VdGlscy5pc1R5cGVkQXJyYXkoIGFycmF5ICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gaW4gaW9zOSBhcnJheS5zdWJhcnJheShmcm9tLCB1bmRlZmluZWQpIHdpbGwgcmV0dXJuIGVtcHR5IGFycmF5XFxyXFxuXFx0XFx0XFx0XFx0Ly8gYnV0IGFycmF5LnN1YmFycmF5KGZyb20pIG9yIGFycmF5LnN1YmFycmF5KGZyb20sIGxlbikgaXMgY29ycmVjdFxcclxcblxcdFxcdFxcdFxcdHJldHVybiBuZXcgYXJyYXkuY29uc3RydWN0b3IoIGFycmF5LnN1YmFycmF5KCBmcm9tLCB0byAhPT0gdW5kZWZpbmVkID8gdG8gOiBhcnJheS5sZW5ndGggKSApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gYXJyYXkuc2xpY2UoIGZyb20sIHRvICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHQvLyBjb252ZXJ0cyBhbiBhcnJheSB0byBhIHNwZWNpZmljIHR5cGVcXHJcXG5cXHRcXHRjb252ZXJ0QXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIHR5cGUsIGZvcmNlQ2xvbmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCAhIGFycmF5IHx8IC8vIGxldCAndW5kZWZpbmVkJyBhbmQgJ251bGwnIHBhc3NcXHJcXG5cXHRcXHRcXHRcXHRcXHQhIGZvcmNlQ2xvbmUgJiYgYXJyYXkuY29uc3RydWN0b3IgPT09IHR5cGUgKSByZXR1cm4gYXJyYXk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0eXBlb2YgdHlwZS5CWVRFU19QRVJfRUxFTUVOVCA9PT0gJ251bWJlcicgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIG5ldyB0eXBlKCBhcnJheSApOyAvLyBjcmVhdGUgdHlwZWQgYXJyYXlcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcnJheSApOyAvLyBjcmVhdGUgQXJyYXlcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGlzVHlwZWRBcnJheTogZnVuY3Rpb24gKCBvYmplY3QgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyggb2JqZWN0ICkgJiZcXHJcXG5cXHRcXHRcXHRcXHRcXHQhICggb2JqZWN0IGluc3RhbmNlb2YgRGF0YVZpZXcgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdC8vIHJldHVybnMgYW4gYXJyYXkgYnkgd2hpY2ggdGltZXMgYW5kIHZhbHVlcyBjYW4gYmUgc29ydGVkXFxyXFxuXFx0XFx0Z2V0S2V5ZnJhbWVPcmRlcjogZnVuY3Rpb24gKCB0aW1lcyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmdW5jdGlvbiBjb21wYXJlVGltZSggaSwgaiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGltZXNbIGkgXSAtIHRpbWVzWyBqIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHZhciBuID0gdGltZXMubGVuZ3RoO1xcclxcblxcdFxcdFxcdHZhciByZXN1bHQgPSBuZXcgQXJyYXkoIG4gKTtcXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG47ICsrIGkgKSByZXN1bHRbIGkgXSA9IGk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmVzdWx0LnNvcnQoIGNvbXBhcmVUaW1lICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHJlc3VsdDtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdC8vIHVzZXMgdGhlIGFycmF5IHByZXZpb3VzbHkgcmV0dXJuZWQgYnkgJ2dldEtleWZyYW1lT3JkZXInIHRvIHNvcnQgZGF0YVxcclxcblxcdFxcdHNvcnRlZEFycmF5OiBmdW5jdGlvbiAoIHZhbHVlcywgc3RyaWRlLCBvcmRlciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgblZhbHVlcyA9IHZhbHVlcy5sZW5ndGg7XFxyXFxuXFx0XFx0XFx0dmFyIHJlc3VsdCA9IG5ldyB2YWx1ZXMuY29uc3RydWN0b3IoIG5WYWx1ZXMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGRzdE9mZnNldCA9IDA7IGRzdE9mZnNldCAhPT0gblZhbHVlczsgKysgaSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgc3JjT2Zmc2V0ID0gb3JkZXJbIGkgXSAqIHN0cmlkZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaiA9IDA7IGogIT09IHN0cmlkZTsgKysgaiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRyZXN1bHRbIGRzdE9mZnNldCArKyBdID0gdmFsdWVzWyBzcmNPZmZzZXQgKyBqIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0O1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Ly8gZnVuY3Rpb24gZm9yIHBhcnNpbmcgQU9TIGtleWZyYW1lIGZvcm1hdHNcXHJcXG5cXHRcXHRmbGF0dGVuSlNPTjogZnVuY3Rpb24gKCBqc29uS2V5cywgdGltZXMsIHZhbHVlcywgdmFsdWVQcm9wZXJ0eU5hbWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGkgPSAxLCBrZXkgPSBqc29uS2V5c1sgMCBdO1xcclxcblxcclxcblxcdFxcdFxcdHdoaWxlICgga2V5ICE9PSB1bmRlZmluZWQgJiYga2V5WyB2YWx1ZVByb3BlcnR5TmFtZSBdID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0a2V5ID0ganNvbktleXNbIGkgKysgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHJldHVybjsgLy8gbm8gZGF0YVxcclxcblxcclxcblxcdFxcdFxcdHZhciB2YWx1ZSA9IGtleVsgdmFsdWVQcm9wZXJ0eU5hbWUgXTtcXHJcXG5cXHRcXHRcXHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSByZXR1cm47IC8vIG5vIGRhdGFcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZG8ge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhbHVlID0ga2V5WyB2YWx1ZVByb3BlcnR5TmFtZSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aW1lcy5wdXNoKCBrZXkudGltZSApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHZhbHVlcy5wdXNoLmFwcGx5KCB2YWx1ZXMsIHZhbHVlICk7IC8vIHB1c2ggYWxsIGVsZW1lbnRzXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGtleSA9IGpzb25LZXlzWyBpICsrIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSB3aGlsZSAoIGtleSAhPT0gdW5kZWZpbmVkICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggdmFsdWUudG9BcnJheSAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIC4uLmFzc3VtZSBUSFJFRS5NYXRoLWlzaFxcclxcblxcclxcblxcdFxcdFxcdFxcdGRvIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YWx1ZSA9IGtleVsgdmFsdWVQcm9wZXJ0eU5hbWUgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGltZXMucHVzaCgga2V5LnRpbWUgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWx1ZS50b0FycmF5KCB2YWx1ZXMsIHZhbHVlcy5sZW5ndGggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0a2V5ID0ganNvbktleXNbIGkgKysgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9IHdoaWxlICgga2V5ICE9PSB1bmRlZmluZWQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIG90aGVyd2lzZSBwdXNoIGFzLWlzXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZG8ge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhbHVlID0ga2V5WyB2YWx1ZVByb3BlcnR5TmFtZSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aW1lcy5wdXNoKCBrZXkudGltZSApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRrZXkgPSBqc29uS2V5c1sgaSArKyBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gd2hpbGUgKCBrZXkgIT09IHVuZGVmaW5lZCApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKlxcclxcblxcdCAqIEEgdGltZWQgc2VxdWVuY2Ugb2Yga2V5ZnJhbWVzIGZvciBhIHNwZWNpZmljIHByb3BlcnR5LlxcclxcblxcdCAqXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xcclxcblxcdCAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xcclxcblxcdCAqIEBhdXRob3IgdHNjaHdcXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBLZXlmcmFtZVRyYWNrKCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICkge1xcclxcblxcclxcblxcdFxcdGlmICggbmFtZSA9PT0gdW5kZWZpbmVkICkgdGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazogdHJhY2sgbmFtZSBpcyB1bmRlZmluZWQnICk7XFxyXFxuXFx0XFx0aWYgKCB0aW1lcyA9PT0gdW5kZWZpbmVkIHx8IHRpbWVzLmxlbmd0aCA9PT0gMCApIHRocm93IG5ldyBFcnJvciggJ1RIUkVFLktleWZyYW1lVHJhY2s6IG5vIGtleWZyYW1lcyBpbiB0cmFjayBuYW1lZCAnICsgbmFtZSApO1xcclxcblxcclxcblxcdFxcdHRoaXMubmFtZSA9IG5hbWU7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50aW1lcyA9IEFuaW1hdGlvblV0aWxzLmNvbnZlcnRBcnJheSggdGltZXMsIHRoaXMuVGltZUJ1ZmZlclR5cGUgKTtcXHJcXG5cXHRcXHR0aGlzLnZhbHVlcyA9IEFuaW1hdGlvblV0aWxzLmNvbnZlcnRBcnJheSggdmFsdWVzLCB0aGlzLlZhbHVlQnVmZmVyVHlwZSApO1xcclxcblxcclxcblxcdFxcdHRoaXMuc2V0SW50ZXJwb2xhdGlvbiggaW50ZXJwb2xhdGlvbiB8fCB0aGlzLkRlZmF1bHRJbnRlcnBvbGF0aW9uICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy52YWxpZGF0ZSgpO1xcclxcblxcdFxcdHRoaXMub3B0aW1pemUoKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0Ly8gU3RhdGljIG1ldGhvZHM6XFxyXFxuXFxyXFxuXFx0T2JqZWN0LmFzc2lnbiggS2V5ZnJhbWVUcmFjaywge1xcclxcblxcclxcblxcdFxcdC8vIFNlcmlhbGl6YXRpb24gKGluIHN0YXRpYyBjb250ZXh0LCBiZWNhdXNlIG9mIGNvbnN0cnVjdG9yIGludm9jYXRpb25cXHJcXG5cXHRcXHQvLyBhbmQgYXV0b21hdGljIGludm9jYXRpb24gb2YgLnRvSlNPTik6XFxyXFxuXFxyXFxuXFx0XFx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGpzb24udHlwZSA9PT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLktleWZyYW1lVHJhY2s6IHRyYWNrIHR5cGUgdW5kZWZpbmVkLCBjYW4gbm90IHBhcnNlJyApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdHJhY2tUeXBlID0gS2V5ZnJhbWVUcmFjay5fZ2V0VHJhY2tUeXBlRm9yVmFsdWVUeXBlTmFtZSgganNvbi50eXBlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBqc29uLnRpbWVzID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHRpbWVzID0gW10sIHZhbHVlcyA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdEFuaW1hdGlvblV0aWxzLmZsYXR0ZW5KU09OKCBqc29uLmtleXMsIHRpbWVzLCB2YWx1ZXMsICd2YWx1ZScgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRqc29uLnRpbWVzID0gdGltZXM7XFxyXFxuXFx0XFx0XFx0XFx0anNvbi52YWx1ZXMgPSB2YWx1ZXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdC8vIGRlcml2ZWQgY2xhc3NlcyBjYW4gZGVmaW5lIGEgc3RhdGljIHBhcnNlIG1ldGhvZFxcclxcblxcdFxcdFxcdGlmICggdHJhY2tUeXBlLnBhcnNlICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRyYWNrVHlwZS5wYXJzZSgganNvbiApO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gYnkgZGVmYXVsdCwgd2UgYXNzdW1lIGEgY29uc3RydWN0b3IgY29tcGF0aWJsZSB3aXRoIHRoZSBiYXNlXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIG5ldyB0cmFja1R5cGUoIGpzb24ubmFtZSwganNvbi50aW1lcywganNvbi52YWx1ZXMsIGpzb24uaW50ZXJwb2xhdGlvbiApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHRvSlNPTjogZnVuY3Rpb24gKCB0cmFjayApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdHJhY2tUeXBlID0gdHJhY2suY29uc3RydWN0b3I7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGpzb247XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gZGVyaXZlZCBjbGFzc2VzIGNhbiBkZWZpbmUgYSBzdGF0aWMgdG9KU09OIG1ldGhvZFxcclxcblxcdFxcdFxcdGlmICggdHJhY2tUeXBlLnRvSlNPTiAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGpzb24gPSB0cmFja1R5cGUudG9KU09OKCB0cmFjayApO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gYnkgZGVmYXVsdCwgd2UgYXNzdW1lIHRoZSBkYXRhIGNhbiBiZSBzZXJpYWxpemVkIGFzLWlzXFxyXFxuXFx0XFx0XFx0XFx0anNvbiA9IHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQnbmFtZSc6IHRyYWNrLm5hbWUsXFxyXFxuXFx0XFx0XFx0XFx0XFx0J3RpbWVzJzogQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KCB0cmFjay50aW1lcywgQXJyYXkgKSxcXHJcXG5cXHRcXHRcXHRcXHRcXHQndmFsdWVzJzogQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KCB0cmFjay52YWx1ZXMsIEFycmF5IClcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBpbnRlcnBvbGF0aW9uID0gdHJhY2suZ2V0SW50ZXJwb2xhdGlvbigpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggaW50ZXJwb2xhdGlvbiAhPT0gdHJhY2suRGVmYXVsdEludGVycG9sYXRpb24gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0anNvbi5pbnRlcnBvbGF0aW9uID0gaW50ZXJwb2xhdGlvbjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGpzb24udHlwZSA9IHRyYWNrLlZhbHVlVHlwZU5hbWU7IC8vIG1hbmRhdG9yeVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBqc29uO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0X2dldFRyYWNrVHlwZUZvclZhbHVlVHlwZU5hbWU6IGZ1bmN0aW9uICggdHlwZU5hbWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0c3dpdGNoICggdHlwZU5hbWUudG9Mb3dlckNhc2UoKSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjYXNlICdzY2FsYXInOlxcclxcblxcdFxcdFxcdFxcdGNhc2UgJ2RvdWJsZSc6XFxyXFxuXFx0XFx0XFx0XFx0Y2FzZSAnZmxvYXQnOlxcclxcblxcdFxcdFxcdFxcdGNhc2UgJ251bWJlcic6XFxyXFxuXFx0XFx0XFx0XFx0Y2FzZSAnaW50ZWdlcic6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIE51bWJlcktleWZyYW1lVHJhY2s7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y2FzZSAndmVjdG9yJzpcXHJcXG5cXHRcXHRcXHRcXHRjYXNlICd2ZWN0b3IyJzpcXHJcXG5cXHRcXHRcXHRcXHRjYXNlICd2ZWN0b3IzJzpcXHJcXG5cXHRcXHRcXHRcXHRjYXNlICd2ZWN0b3I0JzpcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gVmVjdG9yS2V5ZnJhbWVUcmFjaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjYXNlICdjb2xvcic6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIENvbG9yS2V5ZnJhbWVUcmFjaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjYXNlICdxdWF0ZXJuaW9uJzpcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gUXVhdGVybmlvbktleWZyYW1lVHJhY2s7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y2FzZSAnYm9vbCc6XFxyXFxuXFx0XFx0XFx0XFx0Y2FzZSAnYm9vbGVhbic6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIEJvb2xlYW5LZXlmcmFtZVRyYWNrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNhc2UgJ3N0cmluZyc6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIFN0cmluZ0tleWZyYW1lVHJhY2s7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLktleWZyYW1lVHJhY2s6IFVuc3VwcG9ydGVkIHR5cGVOYW1lOiAnICsgdHlwZU5hbWUgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIEtleWZyYW1lVHJhY2sucHJvdG90eXBlLCB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc3RydWN0b3I6IEtleWZyYW1lVHJhY2ssXFxyXFxuXFxyXFxuXFx0XFx0VGltZUJ1ZmZlclR5cGU6IEZsb2F0MzJBcnJheSxcXHJcXG5cXHJcXG5cXHRcXHRWYWx1ZUJ1ZmZlclR5cGU6IEZsb2F0MzJBcnJheSxcXHJcXG5cXHJcXG5cXHRcXHREZWZhdWx0SW50ZXJwb2xhdGlvbjogSW50ZXJwb2xhdGVMaW5lYXIsXFxyXFxuXFxyXFxuXFx0XFx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kRGlzY3JldGU6IGZ1bmN0aW9uICggcmVzdWx0ICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBuZXcgRGlzY3JldGVJbnRlcnBvbGFudCggdGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCksIHJlc3VsdCApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyOiBmdW5jdGlvbiAoIHJlc3VsdCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gbmV3IExpbmVhckludGVycG9sYW50KCB0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSwgcmVzdWx0ICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg6IGZ1bmN0aW9uICggcmVzdWx0ICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBuZXcgQ3ViaWNJbnRlcnBvbGFudCggdGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCksIHJlc3VsdCApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0SW50ZXJwb2xhdGlvbjogZnVuY3Rpb24gKCBpbnRlcnBvbGF0aW9uICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBmYWN0b3J5TWV0aG9kO1xcclxcblxcclxcblxcdFxcdFxcdHN3aXRjaCAoIGludGVycG9sYXRpb24gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y2FzZSBJbnRlcnBvbGF0ZURpc2NyZXRlOlxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGZhY3RvcnlNZXRob2QgPSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZERpc2NyZXRlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNhc2UgSW50ZXJwb2xhdGVMaW5lYXI6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0ZmFjdG9yeU1ldGhvZCA9IHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNhc2UgSW50ZXJwb2xhdGVTbW9vdGg6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0ZmFjdG9yeU1ldGhvZCA9IHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGZhY3RvcnlNZXRob2QgPT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgbWVzc2FnZSA9IFxcXCJ1bnN1cHBvcnRlZCBpbnRlcnBvbGF0aW9uIGZvciBcXFwiICtcXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLlZhbHVlVHlwZU5hbWUgKyBcXFwiIGtleWZyYW1lIHRyYWNrIG5hbWVkIFxcXCIgKyB0aGlzLm5hbWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB0aGlzLmNyZWF0ZUludGVycG9sYW50ID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gZmFsbCBiYWNrIHRvIGRlZmF1bHQsIHVubGVzcyB0aGUgZGVmYXVsdCBpdHNlbGYgaXMgbWVzc2VkIHVwXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBpbnRlcnBvbGF0aW9uICE9PSB0aGlzLkRlZmF1bHRJbnRlcnBvbGF0aW9uICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuc2V0SW50ZXJwb2xhdGlvbiggdGhpcy5EZWZhdWx0SW50ZXJwb2xhdGlvbiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhyb3cgbmV3IEVycm9yKCBtZXNzYWdlICk7IC8vIGZhdGFsLCBpbiB0aGlzIGNhc2VcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLktleWZyYW1lVHJhY2s6JywgbWVzc2FnZSApO1xcclxcblxcdFxcdFxcdFxcdHJldHVybjtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5jcmVhdGVJbnRlcnBvbGFudCA9IGZhY3RvcnlNZXRob2Q7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRnZXRJbnRlcnBvbGF0aW9uOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0c3dpdGNoICggdGhpcy5jcmVhdGVJbnRlcnBvbGFudCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjYXNlIHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kRGlzY3JldGU6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIEludGVycG9sYXRlRGlzY3JldGU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y2FzZSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjpcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gSW50ZXJwb2xhdGVMaW5lYXI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y2FzZSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aDpcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gSW50ZXJwb2xhdGVTbW9vdGg7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Z2V0VmFsdWVTaXplOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMudmFsdWVzLmxlbmd0aCAvIHRoaXMudGltZXMubGVuZ3RoO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Ly8gbW92ZSBhbGwga2V5ZnJhbWVzIGVpdGhlciBmb3J3YXJkcyBvciBiYWNrd2FyZHMgaW4gdGltZVxcclxcblxcdFxcdHNoaWZ0OiBmdW5jdGlvbiAoIHRpbWVPZmZzZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aW1lT2Zmc2V0ICE9PSAwLjAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHRpbWVzID0gdGhpcy50aW1lcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIG4gPSB0aW1lcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGltZXNbIGkgXSArPSB0aW1lT2Zmc2V0O1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHQvLyBzY2FsZSBhbGwga2V5ZnJhbWUgdGltZXMgYnkgYSBmYWN0b3IgKHVzZWZ1bCBmb3IgZnJhbWUgPC0+IHNlY29uZHMgY29udmVyc2lvbnMpXFxyXFxuXFx0XFx0c2NhbGU6IGZ1bmN0aW9uICggdGltZVNjYWxlICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGltZVNjYWxlICE9PSAxLjAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHRpbWVzID0gdGhpcy50aW1lcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIG4gPSB0aW1lcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGltZXNbIGkgXSAqPSB0aW1lU2NhbGU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdC8vIHJlbW92ZXMga2V5ZnJhbWVzIGJlZm9yZSBhbmQgYWZ0ZXIgYW5pbWF0aW9uIHdpdGhvdXQgY2hhbmdpbmcgYW55IHZhbHVlcyB3aXRoaW4gdGhlIHJhbmdlIFtzdGFydFRpbWUsIGVuZFRpbWVdLlxcclxcblxcdFxcdC8vIElNUE9SVEFOVDogV2UgZG8gbm90IHNoaWZ0IGFyb3VuZCBrZXlzIHRvIHRoZSBzdGFydCBvZiB0aGUgdHJhY2sgdGltZSwgYmVjYXVzZSBmb3IgaW50ZXJwb2xhdGVkIGtleXMgdGhpcyB3aWxsIGNoYW5nZSB0aGVpciB2YWx1ZXNcXHJcXG5cXHRcXHR0cmltOiBmdW5jdGlvbiAoIHN0YXJ0VGltZSwgZW5kVGltZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdGltZXMgPSB0aGlzLnRpbWVzLFxcclxcblxcdFxcdFxcdFxcdG5LZXlzID0gdGltZXMubGVuZ3RoLFxcclxcblxcdFxcdFxcdFxcdGZyb20gPSAwLFxcclxcblxcdFxcdFxcdFxcdHRvID0gbktleXMgLSAxO1xcclxcblxcclxcblxcdFxcdFxcdHdoaWxlICggZnJvbSAhPT0gbktleXMgJiYgdGltZXNbIGZyb20gXSA8IHN0YXJ0VGltZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQrKyBmcm9tO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR3aGlsZSAoIHRvICE9PSAtIDEgJiYgdGltZXNbIHRvIF0gPiBlbmRUaW1lICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC0tIHRvO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQrKyB0bzsgLy8gaW5jbHVzaXZlIC0+IGV4Y2x1c2l2ZSBib3VuZFxcclxcblxcclxcblxcdFxcdFxcdGlmICggZnJvbSAhPT0gMCB8fCB0byAhPT0gbktleXMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gZW1wdHkgdHJhY2tzIGFyZSBmb3JiaWRkZW4sIHNvIGtlZXAgYXQgbGVhc3Qgb25lIGtleWZyYW1lXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBmcm9tID49IHRvICkgdG8gPSBNYXRoLm1heCggdG8sIDEgKSwgZnJvbSA9IHRvIC0gMTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgc3RyaWRlID0gdGhpcy5nZXRWYWx1ZVNpemUoKTtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnRpbWVzID0gQW5pbWF0aW9uVXRpbHMuYXJyYXlTbGljZSggdGltZXMsIGZyb20sIHRvICk7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy52YWx1ZXMgPSBBbmltYXRpb25VdGlscy5hcnJheVNsaWNlKCB0aGlzLnZhbHVlcywgZnJvbSAqIHN0cmlkZSwgdG8gKiBzdHJpZGUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHQvLyBlbnN1cmUgd2UgZG8gbm90IGdldCBhIEdhcmJhZ2VJbkdhcmJhZ2VPdXQgc2l0dWF0aW9uLCBtYWtlIHN1cmUgdHJhY2tzIGFyZSBhdCBsZWFzdCBtaW5pbWFsbHkgdmlhYmxlXFxyXFxuXFx0XFx0dmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdmFsaWQgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdFxcdHZhciB2YWx1ZVNpemUgPSB0aGlzLmdldFZhbHVlU2l6ZSgpO1xcclxcblxcdFxcdFxcdGlmICggdmFsdWVTaXplIC0gTWF0aC5mbG9vciggdmFsdWVTaXplICkgIT09IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLktleWZyYW1lVHJhY2s6IEludmFsaWQgdmFsdWUgc2l6ZSBpbiB0cmFjay4nLCB0aGlzICk7XFxyXFxuXFx0XFx0XFx0XFx0dmFsaWQgPSBmYWxzZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHRpbWVzID0gdGhpcy50aW1lcyxcXHJcXG5cXHRcXHRcXHRcXHR2YWx1ZXMgPSB0aGlzLnZhbHVlcyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRuS2V5cyA9IHRpbWVzLmxlbmd0aDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIG5LZXlzID09PSAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5LZXlmcmFtZVRyYWNrOiBUcmFjayBpcyBlbXB0eS4nLCB0aGlzICk7XFxyXFxuXFx0XFx0XFx0XFx0dmFsaWQgPSBmYWxzZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHByZXZUaW1lID0gbnVsbDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG5LZXlzOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBjdXJyVGltZSA9IHRpbWVzWyBpIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB0eXBlb2YgY3VyclRpbWUgPT09ICdudW1iZXInICYmIGlzTmFOKCBjdXJyVGltZSApICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5LZXlmcmFtZVRyYWNrOiBUaW1lIGlzIG5vdCBhIHZhbGlkIG51bWJlci4nLCB0aGlzLCBpLCBjdXJyVGltZSApO1xcclxcblxcdFxcdFxcdFxcdFxcdHZhbGlkID0gZmFsc2U7XFxyXFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggcHJldlRpbWUgIT09IG51bGwgJiYgcHJldlRpbWUgPiBjdXJyVGltZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazogT3V0IG9mIG9yZGVyIGtleXMuJywgdGhpcywgaSwgY3VyclRpbWUsIHByZXZUaW1lICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFsaWQgPSBmYWxzZTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cHJldlRpbWUgPSBjdXJyVGltZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB2YWx1ZXMgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIEFuaW1hdGlvblV0aWxzLmlzVHlwZWRBcnJheSggdmFsdWVzICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBuID0gdmFsdWVzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgdmFsdWUgPSB2YWx1ZXNbIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGlzTmFOKCB2YWx1ZSApICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5LZXlmcmFtZVRyYWNrOiBWYWx1ZSBpcyBub3QgYSB2YWxpZCBudW1iZXIuJywgdGhpcywgaSwgdmFsdWUgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YWxpZCA9IGZhbHNlO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdmFsaWQ7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHQvLyByZW1vdmVzIGVxdWl2YWxlbnQgc2VxdWVudGlhbCBrZXlzIGFzIGNvbW1vbiBpbiBtb3JwaCB0YXJnZXQgc2VxdWVuY2VzXFxyXFxuXFx0XFx0Ly8gKDAsMCwwLDAsMSwxLDEsMCwwLDAsMCwwLDAsMCkgLS0+ICgwLDAsMSwxLDAsMClcXHJcXG5cXHRcXHRvcHRpbWl6ZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB0aW1lcyA9IHRoaXMudGltZXMsXFxyXFxuXFx0XFx0XFx0XFx0dmFsdWVzID0gdGhpcy52YWx1ZXMsXFxyXFxuXFx0XFx0XFx0XFx0c3RyaWRlID0gdGhpcy5nZXRWYWx1ZVNpemUoKSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzbW9vdGhJbnRlcnBvbGF0aW9uID0gdGhpcy5nZXRJbnRlcnBvbGF0aW9uKCkgPT09IEludGVycG9sYXRlU21vb3RoLFxcclxcblxcclxcblxcdFxcdFxcdFxcdHdyaXRlSW5kZXggPSAxLFxcclxcblxcdFxcdFxcdFxcdGxhc3RJbmRleCA9IHRpbWVzLmxlbmd0aCAtIDE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAxOyBpIDwgbGFzdEluZGV4OyArKyBpICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBrZWVwID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHRpbWUgPSB0aW1lc1sgaSBdO1xcclxcblxcdFxcdFxcdFxcdHZhciB0aW1lTmV4dCA9IHRpbWVzWyBpICsgMSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIHJlbW92ZSBhZGphY2VudCBrZXlmcmFtZXMgc2NoZWR1bGVkIGF0IHRoZSBzYW1lIHRpbWVcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHRpbWUgIT09IHRpbWVOZXh0ICYmICggaSAhPT0gMSB8fCB0aW1lICE9PSB0aW1lWyAwIF0gKSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoICEgc21vb3RoSW50ZXJwb2xhdGlvbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyByZW1vdmUgdW5uZWNlc3Nhcnkga2V5ZnJhbWVzIHNhbWUgYXMgdGhlaXIgbmVpZ2hib3JzXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIG9mZnNldCA9IGkgKiBzdHJpZGUsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0b2Zmc2V0UCA9IG9mZnNldCAtIHN0cmlkZSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRvZmZzZXROID0gb2Zmc2V0ICsgc3RyaWRlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBqID0gMDsgaiAhPT0gc3RyaWRlOyArKyBqICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciB2YWx1ZSA9IHZhbHVlc1sgb2Zmc2V0ICsgaiBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggdmFsdWUgIT09IHZhbHVlc1sgb2Zmc2V0UCArIGogXSB8fFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhbHVlICE9PSB2YWx1ZXNbIG9mZnNldE4gKyBqIF0gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0a2VlcCA9IHRydWU7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGtlZXAgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gaW4tcGxhY2UgY29tcGFjdGlvblxcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICgga2VlcCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGkgIT09IHdyaXRlSW5kZXggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGltZXNbIHdyaXRlSW5kZXggXSA9IHRpbWVzWyBpIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHJlYWRPZmZzZXQgPSBpICogc3RyaWRlLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHdyaXRlT2Zmc2V0ID0gd3JpdGVJbmRleCAqIHN0cmlkZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaiA9IDA7IGogIT09IHN0cmlkZTsgKysgaiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YWx1ZXNbIHdyaXRlT2Zmc2V0ICsgaiBdID0gdmFsdWVzWyByZWFkT2Zmc2V0ICsgaiBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Kysgd3JpdGVJbmRleDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdC8vIGZsdXNoIGxhc3Qga2V5ZnJhbWUgKGNvbXBhY3Rpb24gbG9va3MgYWhlYWQpXFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBsYXN0SW5kZXggPiAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRpbWVzWyB3cml0ZUluZGV4IF0gPSB0aW1lc1sgbGFzdEluZGV4IF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIHJlYWRPZmZzZXQgPSBsYXN0SW5kZXggKiBzdHJpZGUsIHdyaXRlT2Zmc2V0ID0gd3JpdGVJbmRleCAqIHN0cmlkZSwgaiA9IDA7IGogIT09IHN0cmlkZTsgKysgaiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YWx1ZXNbIHdyaXRlT2Zmc2V0ICsgaiBdID0gdmFsdWVzWyByZWFkT2Zmc2V0ICsgaiBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQrKyB3cml0ZUluZGV4O1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHdyaXRlSW5kZXggIT09IHRpbWVzLmxlbmd0aCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnRpbWVzID0gQW5pbWF0aW9uVXRpbHMuYXJyYXlTbGljZSggdGltZXMsIDAsIHdyaXRlSW5kZXggKTtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnZhbHVlcyA9IEFuaW1hdGlvblV0aWxzLmFycmF5U2xpY2UoIHZhbHVlcywgMCwgd3JpdGVJbmRleCAqIHN0cmlkZSApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqXFxyXFxuXFx0ICogQSBUcmFjayBvZiB2ZWN0b3JlZCBrZXlmcmFtZSB2YWx1ZXMuXFxyXFxuXFx0ICpcXHJcXG5cXHQgKlxcclxcblxcdCAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXFxyXFxuXFx0ICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXFxyXFxuXFx0ICogQGF1dGhvciB0c2Nod1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIFZlY3RvcktleWZyYW1lVHJhY2soIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKSB7XFxyXFxuXFxyXFxuXFx0XFx0S2V5ZnJhbWVUcmFjay5jYWxsKCB0aGlzLCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdFZlY3RvcktleWZyYW1lVHJhY2sucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgKSwge1xcclxcblxcclxcblxcdFxcdGNvbnN0cnVjdG9yOiBWZWN0b3JLZXlmcmFtZVRyYWNrLFxcclxcblxcclxcblxcdFxcdFZhbHVlVHlwZU5hbWU6ICd2ZWN0b3InXFxyXFxuXFxyXFxuXFx0XFx0Ly8gVmFsdWVCdWZmZXJUeXBlIGlzIGluaGVyaXRlZFxcclxcblxcclxcblxcdFxcdC8vIERlZmF1bHRJbnRlcnBvbGF0aW9uIGlzIGluaGVyaXRlZFxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKlxcclxcblxcdCAqIFJldXNhYmxlIHNldCBvZiBUcmFja3MgdGhhdCByZXByZXNlbnQgYW4gYW5pbWF0aW9uLlxcclxcblxcdCAqXFxyXFxuXFx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cXHJcXG5cXHQgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBBbmltYXRpb25DbGlwKCBuYW1lLCBkdXJhdGlvbiwgdHJhY2tzICkge1xcclxcblxcclxcblxcdFxcdHRoaXMubmFtZSA9IG5hbWU7XFxyXFxuXFx0XFx0dGhpcy50cmFja3MgPSB0cmFja3M7XFxyXFxuXFx0XFx0dGhpcy5kdXJhdGlvbiA9ICggZHVyYXRpb24gIT09IHVuZGVmaW5lZCApID8gZHVyYXRpb24gOiAtIDE7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy51dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gdGhpcyBtZWFucyBpdCBzaG91bGQgZmlndXJlIG91dCBpdHMgZHVyYXRpb24gYnkgc2Nhbm5pbmcgdGhlIHRyYWNrc1xcclxcblxcdFxcdGlmICggdGhpcy5kdXJhdGlvbiA8IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5yZXNldER1cmF0aW9uKCk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHRoaXMub3B0aW1pemUoKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0T2JqZWN0LmFzc2lnbiggQW5pbWF0aW9uQ2xpcCwge1xcclxcblxcclxcblxcdFxcdHBhcnNlOiBmdW5jdGlvbiAoIGpzb24gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHRyYWNrcyA9IFtdLFxcclxcblxcdFxcdFxcdFxcdGpzb25UcmFja3MgPSBqc29uLnRyYWNrcyxcXHJcXG5cXHRcXHRcXHRcXHRmcmFtZVRpbWUgPSAxLjAgLyAoIGpzb24uZnBzIHx8IDEuMCApO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbiA9IGpzb25UcmFja3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRyYWNrcy5wdXNoKCBLZXlmcmFtZVRyYWNrLnBhcnNlKCBqc29uVHJhY2tzWyBpIF0gKS5zY2FsZSggZnJhbWVUaW1lICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyBBbmltYXRpb25DbGlwKCBqc29uLm5hbWUsIGpzb24uZHVyYXRpb24sIHRyYWNrcyApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0dG9KU09OOiBmdW5jdGlvbiAoIGNsaXAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHRyYWNrcyA9IFtdLFxcclxcblxcdFxcdFxcdFxcdGNsaXBUcmFja3MgPSBjbGlwLnRyYWNrcztcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIganNvbiA9IHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQnbmFtZSc6IGNsaXAubmFtZSxcXHJcXG5cXHRcXHRcXHRcXHQnZHVyYXRpb24nOiBjbGlwLmR1cmF0aW9uLFxcclxcblxcdFxcdFxcdFxcdCd0cmFja3MnOiB0cmFja3NcXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbiA9IGNsaXBUcmFja3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRyYWNrcy5wdXNoKCBLZXlmcmFtZVRyYWNrLnRvSlNPTiggY2xpcFRyYWNrc1sgaSBdICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGpzb247XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRDcmVhdGVGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZTogZnVuY3Rpb24gKCBuYW1lLCBtb3JwaFRhcmdldFNlcXVlbmNlLCBmcHMsIG5vTG9vcCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbnVtTW9ycGhUYXJnZXRzID0gbW9ycGhUYXJnZXRTZXF1ZW5jZS5sZW5ndGg7XFxyXFxuXFx0XFx0XFx0dmFyIHRyYWNrcyA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IG51bU1vcnBoVGFyZ2V0czsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgdGltZXMgPSBbXTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgdmFsdWVzID0gW107XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGltZXMucHVzaChcXHJcXG5cXHRcXHRcXHRcXHRcXHQoIGkgKyBudW1Nb3JwaFRhcmdldHMgLSAxICkgJSBudW1Nb3JwaFRhcmdldHMsXFxyXFxuXFx0XFx0XFx0XFx0XFx0aSxcXHJcXG5cXHRcXHRcXHRcXHRcXHQoIGkgKyAxICkgJSBudW1Nb3JwaFRhcmdldHMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YWx1ZXMucHVzaCggMCwgMSwgMCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBvcmRlciA9IEFuaW1hdGlvblV0aWxzLmdldEtleWZyYW1lT3JkZXIoIHRpbWVzICk7XFxyXFxuXFx0XFx0XFx0XFx0dGltZXMgPSBBbmltYXRpb25VdGlscy5zb3J0ZWRBcnJheSggdGltZXMsIDEsIG9yZGVyICk7XFxyXFxuXFx0XFx0XFx0XFx0dmFsdWVzID0gQW5pbWF0aW9uVXRpbHMuc29ydGVkQXJyYXkoIHZhbHVlcywgMSwgb3JkZXIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBpZiB0aGVyZSBpcyBhIGtleSBhdCB0aGUgZmlyc3QgZnJhbWUsIGR1cGxpY2F0ZSBpdCBhcyB0aGVcXHJcXG5cXHRcXHRcXHRcXHQvLyBsYXN0IGZyYW1lIGFzIHdlbGwgZm9yIHBlcmZlY3QgbG9vcC5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoICEgbm9Mb29wICYmIHRpbWVzWyAwIF0gPT09IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGltZXMucHVzaCggbnVtTW9ycGhUYXJnZXRzICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFsdWVzLnB1c2goIHZhbHVlc1sgMCBdICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHRyYWNrcy5wdXNoKFxcclxcblxcdFxcdFxcdFxcdFxcdG5ldyBOdW1iZXJLZXlmcmFtZVRyYWNrKFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdCcubW9ycGhUYXJnZXRJbmZsdWVuY2VzWycgKyBtb3JwaFRhcmdldFNlcXVlbmNlWyBpIF0ubmFtZSArICddJyxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aW1lcywgdmFsdWVzXFxyXFxuXFx0XFx0XFx0XFx0XFx0KS5zY2FsZSggMS4wIC8gZnBzICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyBBbmltYXRpb25DbGlwKCBuYW1lLCAtIDEsIHRyYWNrcyApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0ZmluZEJ5TmFtZTogZnVuY3Rpb24gKCBvYmplY3RPckNsaXBBcnJheSwgbmFtZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgY2xpcEFycmF5ID0gb2JqZWN0T3JDbGlwQXJyYXk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCAhIEFycmF5LmlzQXJyYXkoIG9iamVjdE9yQ2xpcEFycmF5ICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIG8gPSBvYmplY3RPckNsaXBBcnJheTtcXHJcXG5cXHRcXHRcXHRcXHRjbGlwQXJyYXkgPSBvLmdlb21ldHJ5ICYmIG8uZ2VvbWV0cnkuYW5pbWF0aW9ucyB8fCBvLmFuaW1hdGlvbnM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IGNsaXBBcnJheS5sZW5ndGg7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBjbGlwQXJyYXlbIGkgXS5uYW1lID09PSBuYW1lICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBjbGlwQXJyYXlbIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBudWxsO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Q3JlYXRlQ2xpcHNGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZXM6IGZ1bmN0aW9uICggbW9ycGhUYXJnZXRzLCBmcHMsIG5vTG9vcCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgYW5pbWF0aW9uVG9Nb3JwaFRhcmdldHMgPSB7fTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyB0ZXN0ZWQgd2l0aCBodHRwczovL3JlZ2V4MTAxLmNvbS8gb24gdHJpY2sgc2VxdWVuY2VzXFxyXFxuXFx0XFx0XFx0Ly8gc3VjaCBmbGFtaW5nb19mbHlBXzAwMywgZmxhbWluZ29fcnVuMV8wMDMsIGNyZGVhdGgwMDU5XFxyXFxuXFx0XFx0XFx0dmFyIHBhdHRlcm4gPSAvXihbXFxcXHctXSo/KShbXFxcXGRdKykkLztcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBzb3J0IG1vcnBoIHRhcmdldCBuYW1lcyBpbnRvIGFuaW1hdGlvbiBncm91cHMgYmFzZWRcXHJcXG5cXHRcXHRcXHQvLyBwYXR0ZXJucyBsaWtlIFdhbGtfMDAxLCBXYWxrXzAwMiwgUnVuXzAwMSwgUnVuXzAwMlxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSBtb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIG1vcnBoVGFyZ2V0ID0gbW9ycGhUYXJnZXRzWyBpIF07XFxyXFxuXFx0XFx0XFx0XFx0dmFyIHBhcnRzID0gbW9ycGhUYXJnZXQubmFtZS5tYXRjaCggcGF0dGVybiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggcGFydHMgJiYgcGFydHMubGVuZ3RoID4gMSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgbmFtZSA9IHBhcnRzWyAxIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGFuaW1hdGlvbk1vcnBoVGFyZ2V0cyA9IGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzWyBuYW1lIF07XFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAhIGFuaW1hdGlvbk1vcnBoVGFyZ2V0cyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRhbmltYXRpb25Ub01vcnBoVGFyZ2V0c1sgbmFtZSBdID0gYW5pbWF0aW9uTW9ycGhUYXJnZXRzID0gW107XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGFuaW1hdGlvbk1vcnBoVGFyZ2V0cy5wdXNoKCBtb3JwaFRhcmdldCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGNsaXBzID0gW107XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIG5hbWUgaW4gYW5pbWF0aW9uVG9Nb3JwaFRhcmdldHMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y2xpcHMucHVzaCggQW5pbWF0aW9uQ2xpcC5DcmVhdGVGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZSggbmFtZSwgYW5pbWF0aW9uVG9Nb3JwaFRhcmdldHNbIG5hbWUgXSwgZnBzLCBub0xvb3AgKSApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gY2xpcHM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHQvLyBwYXJzZSB0aGUgYW5pbWF0aW9uLmhpZXJhcmNoeSBmb3JtYXRcXHJcXG5cXHRcXHRwYXJzZUFuaW1hdGlvbjogZnVuY3Rpb24gKCBhbmltYXRpb24sIGJvbmVzICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggISBhbmltYXRpb24gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkFuaW1hdGlvbkNsaXA6IE5vIGFuaW1hdGlvbiBpbiBKU09OTG9hZGVyIGRhdGEuJyApO1xcclxcblxcdFxcdFxcdFxcdHJldHVybiBudWxsO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgYWRkTm9uZW1wdHlUcmFjayA9IGZ1bmN0aW9uICggdHJhY2tUeXBlLCB0cmFja05hbWUsIGFuaW1hdGlvbktleXMsIHByb3BlcnR5TmFtZSwgZGVzdFRyYWNrcyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBvbmx5IHJldHVybiB0cmFjayBpZiB0aGVyZSBhcmUgYWN0dWFsbHkga2V5cy5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGFuaW1hdGlvbktleXMubGVuZ3RoICE9PSAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciB0aW1lcyA9IFtdO1xcclxcblxcdFxcdFxcdFxcdFxcdHZhciB2YWx1ZXMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRBbmltYXRpb25VdGlscy5mbGF0dGVuSlNPTiggYW5pbWF0aW9uS2V5cywgdGltZXMsIHZhbHVlcywgcHJvcGVydHlOYW1lICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gZW1wdHkga2V5cyBhcmUgZmlsdGVyZWQgb3V0LCBzbyBjaGVjayBhZ2FpblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggdGltZXMubGVuZ3RoICE9PSAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGRlc3RUcmFja3MucHVzaCggbmV3IHRyYWNrVHlwZSggdHJhY2tOYW1lLCB0aW1lcywgdmFsdWVzICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHRyYWNrcyA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBjbGlwTmFtZSA9IGFuaW1hdGlvbi5uYW1lIHx8ICdkZWZhdWx0JztcXHJcXG5cXHRcXHRcXHQvLyBhdXRvbWF0aWMgbGVuZ3RoIGRldGVybWluYXRpb24gaW4gQW5pbWF0aW9uQ2xpcC5cXHJcXG5cXHRcXHRcXHR2YXIgZHVyYXRpb24gPSBhbmltYXRpb24ubGVuZ3RoIHx8IC0gMTtcXHJcXG5cXHRcXHRcXHR2YXIgZnBzID0gYW5pbWF0aW9uLmZwcyB8fCAzMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgaGllcmFyY2h5VHJhY2tzID0gYW5pbWF0aW9uLmhpZXJhcmNoeSB8fCBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaCA9IDA7IGggPCBoaWVyYXJjaHlUcmFja3MubGVuZ3RoOyBoICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBhbmltYXRpb25LZXlzID0gaGllcmFyY2h5VHJhY2tzWyBoIF0ua2V5cztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBza2lwIGVtcHR5IHRyYWNrc1xcclxcblxcdFxcdFxcdFxcdGlmICggISBhbmltYXRpb25LZXlzIHx8IGFuaW1hdGlvbktleXMubGVuZ3RoID09PSAwICkgY29udGludWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gcHJvY2VzcyBtb3JwaCB0YXJnZXRzXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBhbmltYXRpb25LZXlzWyAwIF0ubW9ycGhUYXJnZXRzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIGZpZ3VyZSBvdXQgYWxsIG1vcnBoIHRhcmdldHMgdXNlZCBpbiB0aGlzIHRyYWNrXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIG1vcnBoVGFyZ2V0TmFtZXMgPSB7fTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgayA9IDA7IGsgPCBhbmltYXRpb25LZXlzLmxlbmd0aDsgayArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGFuaW1hdGlvbktleXNbIGsgXS5tb3JwaFRhcmdldHMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIG0gPSAwOyBtIDwgYW5pbWF0aW9uS2V5c1sgayBdLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bW9ycGhUYXJnZXROYW1lc1sgYW5pbWF0aW9uS2V5c1sgayBdLm1vcnBoVGFyZ2V0c1sgbSBdIF0gPSAtIDE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gY3JlYXRlIGEgdHJhY2sgZm9yIGVhY2ggbW9ycGggdGFyZ2V0IHdpdGggYWxsIHplcm9cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBtb3JwaFRhcmdldEluZmx1ZW5jZXMgZXhjZXB0IGZvciB0aGUga2V5cyBpbiB3aGljaFxcclxcblxcdFxcdFxcdFxcdFxcdC8vIHRoZSBtb3JwaFRhcmdldCBpcyBuYW1lZC5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgbW9ycGhUYXJnZXROYW1lIGluIG1vcnBoVGFyZ2V0TmFtZXMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHRpbWVzID0gW107XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHZhbHVlcyA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBtID0gMDsgbSAhPT0gYW5pbWF0aW9uS2V5c1sgayBdLm1vcnBoVGFyZ2V0cy5sZW5ndGg7ICsrIG0gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGFuaW1hdGlvbktleSA9IGFuaW1hdGlvbktleXNbIGsgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aW1lcy5wdXNoKCBhbmltYXRpb25LZXkudGltZSApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhbHVlcy5wdXNoKCAoIGFuaW1hdGlvbktleS5tb3JwaFRhcmdldCA9PT0gbW9ycGhUYXJnZXROYW1lICkgPyAxIDogMCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR0cmFja3MucHVzaCggbmV3IE51bWJlcktleWZyYW1lVHJhY2soICcubW9ycGhUYXJnZXRJbmZsdWVuY2VbJyArIG1vcnBoVGFyZ2V0TmFtZSArICddJywgdGltZXMsIHZhbHVlcyApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGR1cmF0aW9uID0gbW9ycGhUYXJnZXROYW1lcy5sZW5ndGggKiAoIGZwcyB8fCAxLjAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIC4uLmFzc3VtZSBza2VsZXRhbCBhbmltYXRpb25cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgYm9uZU5hbWUgPSAnLmJvbmVzWycgKyBib25lc1sgaCBdLm5hbWUgKyAnXSc7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0YWRkTm9uZW1wdHlUcmFjayhcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRWZWN0b3JLZXlmcmFtZVRyYWNrLCBib25lTmFtZSArICcucG9zaXRpb24nLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGFuaW1hdGlvbktleXMsICdwb3MnLCB0cmFja3MgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRhZGROb25lbXB0eVRyYWNrKFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLCBib25lTmFtZSArICcucXVhdGVybmlvbicsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0YW5pbWF0aW9uS2V5cywgJ3JvdCcsIHRyYWNrcyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGFkZE5vbmVtcHR5VHJhY2soXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0VmVjdG9yS2V5ZnJhbWVUcmFjaywgYm9uZU5hbWUgKyAnLnNjYWxlJyxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRhbmltYXRpb25LZXlzLCAnc2NsJywgdHJhY2tzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRyYWNrcy5sZW5ndGggPT09IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHZhciBjbGlwID0gbmV3IEFuaW1hdGlvbkNsaXAoIGNsaXBOYW1lLCBkdXJhdGlvbiwgdHJhY2tzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGNsaXA7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHRPYmplY3QuYXNzaWduKCBBbmltYXRpb25DbGlwLnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdHJlc2V0RHVyYXRpb246IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdHJhY2tzID0gdGhpcy50cmFja3MsIGR1cmF0aW9uID0gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIG4gPSB0cmFja3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciB0cmFjayA9IHRoaXMudHJhY2tzWyBpIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZHVyYXRpb24gPSBNYXRoLm1heCggZHVyYXRpb24sIHRyYWNrLnRpbWVzWyB0cmFjay50aW1lcy5sZW5ndGggLSAxIF0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0dHJpbTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnRyYWNrc1sgaSBdLnRyaW0oIDAsIHRoaXMuZHVyYXRpb24gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRvcHRpbWl6ZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnRyYWNrc1sgaSBdLm9wdGltaXplKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBNYXRlcmlhbExvYWRlciggbWFuYWdlciApIHtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcXHJcXG5cXHRcXHR0aGlzLnRleHR1cmVzID0ge307XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIE1hdGVyaWFsTG9hZGVyLnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHNjb3BlID0gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcXHJcXG5cXHRcXHRcXHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0b25Mb2FkKCBzY29wZS5wYXJzZSggSlNPTi5wYXJzZSggdGV4dCApICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRUZXh0dXJlczogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnRleHR1cmVzID0gdmFsdWU7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRwYXJzZTogZnVuY3Rpb24gKCBqc29uICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB0ZXh0dXJlcyA9IHRoaXMudGV4dHVyZXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZnVuY3Rpb24gZ2V0VGV4dHVyZSggbmFtZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHRleHR1cmVzWyBuYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRlcmlhbExvYWRlcjogVW5kZWZpbmVkIHRleHR1cmUnLCBuYW1lICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0ZXh0dXJlc1sgbmFtZSBdO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbWF0ZXJpYWwgPSBuZXcgTWF0ZXJpYWxzWyBqc29uLnR5cGUgXSgpO1xcclxcblxcclxcblxcdFxcdFxcdGlmICgganNvbi51dWlkICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC51dWlkID0ganNvbi51dWlkO1xcclxcblxcdFxcdFxcdGlmICgganNvbi5uYW1lICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5uYW1lID0ganNvbi5uYW1lO1xcclxcblxcdFxcdFxcdGlmICgganNvbi5jb2xvciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY29sb3Iuc2V0SGV4KCBqc29uLmNvbG9yICk7XFxyXFxuXFx0XFx0XFx0aWYgKCBqc29uLnJvdWdobmVzcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwucm91Z2huZXNzID0ganNvbi5yb3VnaG5lc3M7XFxyXFxuXFx0XFx0XFx0aWYgKCBqc29uLm1ldGFsbmVzcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubWV0YWxuZXNzID0ganNvbi5tZXRhbG5lc3M7XFxyXFxuXFx0XFx0XFx0aWYgKCBqc29uLmVtaXNzaXZlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5lbWlzc2l2ZS5zZXRIZXgoIGpzb24uZW1pc3NpdmUgKTtcXHJcXG5cXHRcXHRcXHRpZiAoIGpzb24uc3BlY3VsYXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNwZWN1bGFyLnNldEhleCgganNvbi5zcGVjdWxhciApO1xcclxcblxcdFxcdFxcdGlmICgganNvbi5zaGluaW5lc3MgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNoaW5pbmVzcyA9IGpzb24uc2hpbmluZXNzO1xcclxcblxcdFxcdFxcdGlmICgganNvbi5jbGVhckNvYXQgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmNsZWFyQ29hdCA9IGpzb24uY2xlYXJDb2F0O1xcclxcblxcdFxcdFxcdGlmICgganNvbi5jbGVhckNvYXRSb3VnaG5lc3MgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmNsZWFyQ29hdFJvdWdobmVzcyA9IGpzb24uY2xlYXJDb2F0Um91Z2huZXNzO1xcclxcblxcdFxcdFxcdGlmICgganNvbi51bmlmb3JtcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudW5pZm9ybXMgPSBqc29uLnVuaWZvcm1zO1xcclxcblxcdFxcdFxcdGlmICgganNvbi52ZXJ0ZXhTaGFkZXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnZlcnRleFNoYWRlciA9IGpzb24udmVydGV4U2hhZGVyO1xcclxcblxcdFxcdFxcdGlmICgganNvbi5mcmFnbWVudFNoYWRlciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXIgPSBqc29uLmZyYWdtZW50U2hhZGVyO1xcclxcblxcdFxcdFxcdGlmICgganNvbi52ZXJ0ZXhDb2xvcnMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnZlcnRleENvbG9ycyA9IGpzb24udmVydGV4Q29sb3JzO1xcclxcblxcdFxcdFxcdGlmICgganNvbi5mb2cgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmZvZyA9IGpzb24uZm9nO1xcclxcblxcdFxcdFxcdGlmICgganNvbi5mbGF0U2hhZGluZyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZmxhdFNoYWRpbmcgPSBqc29uLmZsYXRTaGFkaW5nO1xcclxcblxcdFxcdFxcdGlmICgganNvbi5ibGVuZGluZyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYmxlbmRpbmcgPSBqc29uLmJsZW5kaW5nO1xcclxcblxcdFxcdFxcdGlmICgganNvbi5zaWRlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaWRlID0ganNvbi5zaWRlO1xcclxcblxcdFxcdFxcdGlmICgganNvbi5vcGFjaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5vcGFjaXR5ID0ganNvbi5vcGFjaXR5O1xcclxcblxcdFxcdFxcdGlmICgganNvbi50cmFuc3BhcmVudCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudHJhbnNwYXJlbnQgPSBqc29uLnRyYW5zcGFyZW50O1xcclxcblxcdFxcdFxcdGlmICgganNvbi5hbHBoYVRlc3QgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmFscGhhVGVzdCA9IGpzb24uYWxwaGFUZXN0O1xcclxcblxcdFxcdFxcdGlmICgganNvbi5kZXB0aFRlc3QgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRlcHRoVGVzdCA9IGpzb24uZGVwdGhUZXN0O1xcclxcblxcdFxcdFxcdGlmICgganNvbi5kZXB0aFdyaXRlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kZXB0aFdyaXRlID0ganNvbi5kZXB0aFdyaXRlO1xcclxcblxcdFxcdFxcdGlmICgganNvbi5jb2xvcldyaXRlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5jb2xvcldyaXRlID0ganNvbi5jb2xvcldyaXRlO1xcclxcblxcdFxcdFxcdGlmICgganNvbi53aXJlZnJhbWUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLndpcmVmcmFtZSA9IGpzb24ud2lyZWZyYW1lO1xcclxcblxcdFxcdFxcdGlmICgganNvbi53aXJlZnJhbWVMaW5ld2lkdGggIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCA9IGpzb24ud2lyZWZyYW1lTGluZXdpZHRoO1xcclxcblxcdFxcdFxcdGlmICgganNvbi53aXJlZnJhbWVMaW5lY2FwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC53aXJlZnJhbWVMaW5lY2FwID0ganNvbi53aXJlZnJhbWVMaW5lY2FwO1xcclxcblxcdFxcdFxcdGlmICgganNvbi53aXJlZnJhbWVMaW5lam9pbiAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWpvaW4gPSBqc29uLndpcmVmcmFtZUxpbmVqb2luO1xcclxcblxcclxcblxcdFxcdFxcdGlmICgganNvbi5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwucm90YXRpb24gPSBqc29uLnJvdGF0aW9uO1xcclxcblxcclxcblxcdFxcdFxcdGlmICgganNvbi5saW5ld2lkdGggIT09IDEgKSBtYXRlcmlhbC5saW5ld2lkdGggPSBqc29uLmxpbmV3aWR0aDtcXHJcXG5cXHRcXHRcXHRpZiAoIGpzb24uZGFzaFNpemUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRhc2hTaXplID0ganNvbi5kYXNoU2l6ZTtcXHJcXG5cXHRcXHRcXHRpZiAoIGpzb24uZ2FwU2l6ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZ2FwU2l6ZSA9IGpzb24uZ2FwU2l6ZTtcXHJcXG5cXHRcXHRcXHRpZiAoIGpzb24uc2NhbGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNjYWxlID0ganNvbi5zY2FsZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGpzb24uc2tpbm5pbmcgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNraW5uaW5nID0ganNvbi5za2lubmluZztcXHJcXG5cXHRcXHRcXHRpZiAoIGpzb24ubW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5tb3JwaFRhcmdldHMgPSBqc29uLm1vcnBoVGFyZ2V0cztcXHJcXG5cXHRcXHRcXHRpZiAoIGpzb24uZGl0aGVyaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kaXRoZXJpbmcgPSBqc29uLmRpdGhlcmluZztcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGpzb24udmlzaWJsZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudmlzaWJsZSA9IGpzb24udmlzaWJsZTtcXHJcXG5cXHRcXHRcXHRpZiAoIGpzb24udXNlckRhdGEgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnVzZXJEYXRhID0ganNvbi51c2VyRGF0YTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBEZXByZWNhdGVkXFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBqc29uLnNoYWRpbmcgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmZsYXRTaGFkaW5nID0ganNvbi5zaGFkaW5nID09PSAxOyAvLyBUSFJFRS5GbGF0U2hhZGluZ1xcclxcblxcclxcblxcdFxcdFxcdC8vIGZvciBQb2ludHNNYXRlcmlhbFxcclxcblxcclxcblxcdFxcdFxcdGlmICgganNvbi5zaXplICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaXplID0ganNvbi5zaXplO1xcclxcblxcdFxcdFxcdGlmICgganNvbi5zaXplQXR0ZW51YXRpb24gIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNpemVBdHRlbnVhdGlvbiA9IGpzb24uc2l6ZUF0dGVudWF0aW9uO1xcclxcblxcclxcblxcdFxcdFxcdC8vIG1hcHNcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGpzb24ubWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5tYXAgPSBnZXRUZXh0dXJlKCBqc29uLm1hcCApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICgganNvbi5hbHBoYU1hcCAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdG1hdGVyaWFsLmFscGhhTWFwID0gZ2V0VGV4dHVyZSgganNvbi5hbHBoYU1hcCApO1xcclxcblxcdFxcdFxcdFxcdG1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBqc29uLmJ1bXBNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJ1bXBNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmJ1bXBNYXAgKTtcXHJcXG5cXHRcXHRcXHRpZiAoIGpzb24uYnVtcFNjYWxlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5idW1wU2NhbGUgPSBqc29uLmJ1bXBTY2FsZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGpzb24ubm9ybWFsTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ub3JtYWxNYXAgPSBnZXRUZXh0dXJlKCBqc29uLm5vcm1hbE1hcCApO1xcclxcblxcdFxcdFxcdGlmICgganNvbi5ub3JtYWxTY2FsZSAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBub3JtYWxTY2FsZSA9IGpzb24ubm9ybWFsU2NhbGU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBBcnJheS5pc0FycmF5KCBub3JtYWxTY2FsZSApID09PSBmYWxzZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBCbGVuZGVyIGV4cG9ydGVyIHVzZWQgdG8gZXhwb3J0IGEgc2NhbGFyLiBTZWUgIzc0NTlcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRub3JtYWxTY2FsZSA9IFsgbm9ybWFsU2NhbGUsIG5vcm1hbFNjYWxlIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdG1hdGVyaWFsLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoKS5mcm9tQXJyYXkoIG5vcm1hbFNjYWxlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICgganNvbi5kaXNwbGFjZW1lbnRNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCA9IGdldFRleHR1cmUoIGpzb24uZGlzcGxhY2VtZW50TWFwICk7XFxyXFxuXFx0XFx0XFx0aWYgKCBqc29uLmRpc3BsYWNlbWVudFNjYWxlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZSA9IGpzb24uZGlzcGxhY2VtZW50U2NhbGU7XFxyXFxuXFx0XFx0XFx0aWYgKCBqc29uLmRpc3BsYWNlbWVudEJpYXMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXMgPSBqc29uLmRpc3BsYWNlbWVudEJpYXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBqc29uLnJvdWdobmVzc01hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwucm91Z2huZXNzTWFwID0gZ2V0VGV4dHVyZSgganNvbi5yb3VnaG5lc3NNYXAgKTtcXHJcXG5cXHRcXHRcXHRpZiAoIGpzb24ubWV0YWxuZXNzTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5tZXRhbG5lc3NNYXAgPSBnZXRUZXh0dXJlKCBqc29uLm1ldGFsbmVzc01hcCApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICgganNvbi5lbWlzc2l2ZU1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZW1pc3NpdmVNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmVtaXNzaXZlTWFwICk7XFxyXFxuXFx0XFx0XFx0aWYgKCBqc29uLmVtaXNzaXZlSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5lbWlzc2l2ZUludGVuc2l0eSA9IGpzb24uZW1pc3NpdmVJbnRlbnNpdHk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBqc29uLnNwZWN1bGFyTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zcGVjdWxhck1hcCA9IGdldFRleHR1cmUoIGpzb24uc3BlY3VsYXJNYXAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGpzb24uZW52TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5lbnZNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmVudk1hcCApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICgganNvbi5yZWZsZWN0aXZpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnJlZmxlY3Rpdml0eSA9IGpzb24ucmVmbGVjdGl2aXR5O1xcclxcblxcclxcblxcdFxcdFxcdGlmICgganNvbi5saWdodE1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubGlnaHRNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmxpZ2h0TWFwICk7XFxyXFxuXFx0XFx0XFx0aWYgKCBqc29uLmxpZ2h0TWFwSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5saWdodE1hcEludGVuc2l0eSA9IGpzb24ubGlnaHRNYXBJbnRlbnNpdHk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBqc29uLmFvTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hb01hcCA9IGdldFRleHR1cmUoIGpzb24uYW9NYXAgKTtcXHJcXG5cXHRcXHRcXHRpZiAoIGpzb24uYW9NYXBJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmFvTWFwSW50ZW5zaXR5ID0ganNvbi5hb01hcEludGVuc2l0eTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGpzb24uZ3JhZGllbnRNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmdyYWRpZW50TWFwID0gZ2V0VGV4dHVyZSgganNvbi5ncmFkaWVudE1hcCApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBtYXRlcmlhbDtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gQnVmZmVyR2VvbWV0cnlMb2FkZXIoIG1hbmFnZXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIEJ1ZmZlckdlb21ldHJ5TG9hZGVyLnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHNjb3BlID0gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcXHJcXG5cXHRcXHRcXHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0b25Mb2FkKCBzY29wZS5wYXJzZSggSlNPTi5wYXJzZSggdGV4dCApICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRwYXJzZTogZnVuY3Rpb24gKCBqc29uICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBpbmRleCA9IGpzb24uZGF0YS5pbmRleDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHR5cGVkQXJyYXkgPSBuZXcgVFlQRURfQVJSQVlTWyBpbmRleC50eXBlIF0oIGluZGV4LmFycmF5ICk7XFxyXFxuXFx0XFx0XFx0XFx0Z2VvbWV0cnkuc2V0SW5kZXgoIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHR5cGVkQXJyYXksIDEgKSApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgYXR0cmlidXRlcyA9IGpzb24uZGF0YS5hdHRyaWJ1dGVzO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBrZXkgaW4gYXR0cmlidXRlcyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sga2V5IF07XFxyXFxuXFx0XFx0XFx0XFx0dmFyIHR5cGVkQXJyYXkgPSBuZXcgVFlQRURfQVJSQVlTWyBhdHRyaWJ1dGUudHlwZSBdKCBhdHRyaWJ1dGUuYXJyYXkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoIGtleSwgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggdHlwZWRBcnJheSwgYXR0cmlidXRlLml0ZW1TaXplLCBhdHRyaWJ1dGUubm9ybWFsaXplZCApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHZhciBncm91cHMgPSBqc29uLmRhdGEuZ3JvdXBzIHx8IGpzb24uZGF0YS5kcmF3Y2FsbHMgfHwganNvbi5kYXRhLm9mZnNldHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBncm91cHMgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBncm91cHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5LmFkZEdyb3VwKCBncm91cC5zdGFydCwgZ3JvdXAuY291bnQsIGdyb3VwLm1hdGVyaWFsSW5kZXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHZhciBib3VuZGluZ1NwaGVyZSA9IGpzb24uZGF0YS5ib3VuZGluZ1NwaGVyZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGNlbnRlciA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBib3VuZGluZ1NwaGVyZS5jZW50ZXIgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRjZW50ZXIuZnJvbUFycmF5KCBib3VuZGluZ1NwaGVyZS5jZW50ZXIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Z2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCBjZW50ZXIsIGJvdW5kaW5nU3BoZXJlLnJhZGl1cyApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZ2VvbWV0cnk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHR2YXIgVFlQRURfQVJSQVlTID0ge1xcclxcblxcdFxcdEludDhBcnJheTogSW50OEFycmF5LFxcclxcblxcdFxcdFVpbnQ4QXJyYXk6IFVpbnQ4QXJyYXksXFxyXFxuXFx0XFx0Ly8gV29ya2Fyb3VuZCBmb3IgSUUxMSBwcmUgS0IyOTI5NDM3LiBTZWUgIzExNDQwXFxyXFxuXFx0XFx0VWludDhDbGFtcGVkQXJyYXk6IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OENsYW1wZWRBcnJheSA6IFVpbnQ4QXJyYXksXFxyXFxuXFx0XFx0SW50MTZBcnJheTogSW50MTZBcnJheSxcXHJcXG5cXHRcXHRVaW50MTZBcnJheTogVWludDE2QXJyYXksXFxyXFxuXFx0XFx0SW50MzJBcnJheTogSW50MzJBcnJheSxcXHJcXG5cXHRcXHRVaW50MzJBcnJheTogVWludDMyQXJyYXksXFxyXFxuXFx0XFx0RmxvYXQzMkFycmF5OiBGbG9hdDMyQXJyYXksXFxyXFxuXFx0XFx0RmxvYXQ2NEFycmF5OiBGbG9hdDY0QXJyYXlcXHJcXG5cXHR9O1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gTG9hZGVyKCkge1xcclxcblxcclxcblxcdFxcdHRoaXMub25Mb2FkU3RhcnQgPSBmdW5jdGlvbiAoKSB7fTtcXHJcXG5cXHRcXHR0aGlzLm9uTG9hZFByb2dyZXNzID0gZnVuY3Rpb24gKCkge307XFxyXFxuXFx0XFx0dGhpcy5vbkxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHt9O1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRMb2FkZXIuSGFuZGxlcnMgPSB7XFxyXFxuXFxyXFxuXFx0XFx0aGFuZGxlcnM6IFtdLFxcclxcblxcclxcblxcdFxcdGFkZDogZnVuY3Rpb24gKCByZWdleCwgbG9hZGVyICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuaGFuZGxlcnMucHVzaCggcmVnZXgsIGxvYWRlciApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Z2V0OiBmdW5jdGlvbiAoIGZpbGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBsOyBpICs9IDIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHJlZ2V4ID0gaGFuZGxlcnNbIGkgXTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgbG9hZGVyID0gaGFuZGxlcnNbIGkgKyAxIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCByZWdleC50ZXN0KCBmaWxlICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGxvYWRlcjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBudWxsO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9O1xcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIExvYWRlci5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHRjcm9zc09yaWdpbjogdW5kZWZpbmVkLFxcclxcblxcclxcblxcdFxcdGluaXRNYXRlcmlhbHM6IGZ1bmN0aW9uICggbWF0ZXJpYWxzLCB0ZXh0dXJlUGF0aCwgY3Jvc3NPcmlnaW4gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGFycmF5ID0gW107XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbWF0ZXJpYWxzLmxlbmd0aDsgKysgaSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRhcnJheVsgaSBdID0gdGhpcy5jcmVhdGVNYXRlcmlhbCggbWF0ZXJpYWxzWyBpIF0sIHRleHR1cmVQYXRoLCBjcm9zc09yaWdpbiApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gYXJyYXk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjcmVhdGVNYXRlcmlhbDogKCBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIEJsZW5kaW5nTW9kZSA9IHtcXHJcXG5cXHRcXHRcXHRcXHROb0JsZW5kaW5nOiBOb0JsZW5kaW5nLFxcclxcblxcdFxcdFxcdFxcdE5vcm1hbEJsZW5kaW5nOiBOb3JtYWxCbGVuZGluZyxcXHJcXG5cXHRcXHRcXHRcXHRBZGRpdGl2ZUJsZW5kaW5nOiBBZGRpdGl2ZUJsZW5kaW5nLFxcclxcblxcdFxcdFxcdFxcdFN1YnRyYWN0aXZlQmxlbmRpbmc6IFN1YnRyYWN0aXZlQmxlbmRpbmcsXFxyXFxuXFx0XFx0XFx0XFx0TXVsdGlwbHlCbGVuZGluZzogTXVsdGlwbHlCbGVuZGluZyxcXHJcXG5cXHRcXHRcXHRcXHRDdXN0b21CbGVuZGluZzogQ3VzdG9tQmxlbmRpbmdcXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdFxcdHZhciBjb2xvciA9IG5ldyBDb2xvcigpO1xcclxcblxcdFxcdFxcdHZhciB0ZXh0dXJlTG9hZGVyID0gbmV3IFRleHR1cmVMb2FkZXIoKTtcXHJcXG5cXHRcXHRcXHR2YXIgbWF0ZXJpYWxMb2FkZXIgPSBuZXcgTWF0ZXJpYWxMb2FkZXIoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gY3JlYXRlTWF0ZXJpYWwoIG0sIHRleHR1cmVQYXRoLCBjcm9zc09yaWdpbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBjb252ZXJ0IGZyb20gb2xkIG1hdGVyaWFsIGZvcm1hdFxcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciB0ZXh0dXJlcyA9IHt9O1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uIGxvYWRUZXh0dXJlKCBwYXRoLCByZXBlYXQsIG9mZnNldCwgd3JhcCwgYW5pc290cm9weSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgZnVsbFBhdGggPSB0ZXh0dXJlUGF0aCArIHBhdGg7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGxvYWRlciA9IExvYWRlci5IYW5kbGVycy5nZXQoIGZ1bGxQYXRoICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHRleHR1cmU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBsb2FkZXIgIT09IG51bGwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGV4dHVyZSA9IGxvYWRlci5sb2FkKCBmdWxsUGF0aCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGV4dHVyZUxvYWRlci5zZXRDcm9zc09yaWdpbiggY3Jvc3NPcmlnaW4gKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR0ZXh0dXJlID0gdGV4dHVyZUxvYWRlci5sb2FkKCBmdWxsUGF0aCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHJlcGVhdCAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHRleHR1cmUucmVwZWF0LmZyb21BcnJheSggcmVwZWF0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCByZXBlYXRbIDAgXSAhPT0gMSApIHRleHR1cmUud3JhcFMgPSBSZXBlYXRXcmFwcGluZztcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHJlcGVhdFsgMSBdICE9PSAxICkgdGV4dHVyZS53cmFwVCA9IFJlcGVhdFdyYXBwaW5nO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG9mZnNldCAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHRleHR1cmUub2Zmc2V0LmZyb21BcnJheSggb2Zmc2V0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggd3JhcCAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggd3JhcFsgMCBdID09PSAncmVwZWF0JyApIHRleHR1cmUud3JhcFMgPSBSZXBlYXRXcmFwcGluZztcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHdyYXBbIDAgXSA9PT0gJ21pcnJvcicgKSB0ZXh0dXJlLndyYXBTID0gTWlycm9yZWRSZXBlYXRXcmFwcGluZztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHdyYXBbIDEgXSA9PT0gJ3JlcGVhdCcgKSB0ZXh0dXJlLndyYXBUID0gUmVwZWF0V3JhcHBpbmc7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB3cmFwWyAxIF0gPT09ICdtaXJyb3InICkgdGV4dHVyZS53cmFwVCA9IE1pcnJvcmVkUmVwZWF0V3JhcHBpbmc7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggYW5pc290cm9weSAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHRleHR1cmUuYW5pc290cm9weSA9IGFuaXNvdHJvcHk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciB1dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGV4dHVyZXNbIHV1aWQgXSA9IHRleHR1cmU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHV1aWQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdC8vXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGpzb24gPSB7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dXVpZDogX01hdGguZ2VuZXJhdGVVVUlEKCksXFxyXFxuXFx0XFx0XFx0XFx0XFx0dHlwZTogJ01lc2hMYW1iZXJ0TWF0ZXJpYWwnXFxyXFxuXFx0XFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgbmFtZSBpbiBtICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciB2YWx1ZSA9IG1bIG5hbWUgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRzd2l0Y2ggKCBuYW1lICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ0RiZ0NvbG9yJzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdEYmdJbmRleCc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnb3B0aWNhbERlbnNpdHknOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ2lsbHVtaW5hdGlvbic6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnRGJnTmFtZSc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0anNvbi5uYW1lID0gdmFsdWU7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnYmxlbmRpbmcnOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGpzb24uYmxlbmRpbmcgPSBCbGVuZGluZ01vZGVbIHZhbHVlIF07XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnY29sb3JBbWJpZW50JzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBBbWJpZW50JzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5Mb2FkZXIuY3JlYXRlTWF0ZXJpYWw6JywgbmFtZSwgJ2lzIG5vIGxvbmdlciBzdXBwb3J0ZWQuJyApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ2NvbG9yRGlmZnVzZSc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0anNvbi5jb2xvciA9IGNvbG9yLmZyb21BcnJheSggdmFsdWUgKS5nZXRIZXgoKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdjb2xvclNwZWN1bGFyJzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqc29uLnNwZWN1bGFyID0gY29sb3IuZnJvbUFycmF5KCB2YWx1ZSApLmdldEhleCgpO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ2NvbG9yRW1pc3NpdmUnOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGpzb24uZW1pc3NpdmUgPSBjb2xvci5mcm9tQXJyYXkoIHZhbHVlICkuZ2V0SGV4KCk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnc3BlY3VsYXJDb2VmJzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqc29uLnNoaW5pbmVzcyA9IHZhbHVlO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ3NoYWRpbmcnOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ2Jhc2ljJyApIGpzb24udHlwZSA9ICdNZXNoQmFzaWNNYXRlcmlhbCc7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAncGhvbmcnICkganNvbi50eXBlID0gJ01lc2hQaG9uZ01hdGVyaWFsJztcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICdzdGFuZGFyZCcgKSBqc29uLnR5cGUgPSAnTWVzaFN0YW5kYXJkTWF0ZXJpYWwnO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcERpZmZ1c2UnOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGpzb24ubWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcERpZmZ1c2VSZXBlYXQsIG0ubWFwRGlmZnVzZU9mZnNldCwgbS5tYXBEaWZmdXNlV3JhcCwgbS5tYXBEaWZmdXNlQW5pc290cm9weSApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcERpZmZ1c2VSZXBlYXQnOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcERpZmZ1c2VPZmZzZXQnOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcERpZmZ1c2VXcmFwJzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBEaWZmdXNlQW5pc290cm9weSc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwRW1pc3NpdmUnOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGpzb24uZW1pc3NpdmVNYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwRW1pc3NpdmVSZXBlYXQsIG0ubWFwRW1pc3NpdmVPZmZzZXQsIG0ubWFwRW1pc3NpdmVXcmFwLCBtLm1hcEVtaXNzaXZlQW5pc290cm9weSApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcEVtaXNzaXZlUmVwZWF0JzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBFbWlzc2l2ZU9mZnNldCc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwRW1pc3NpdmVXcmFwJzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBFbWlzc2l2ZUFuaXNvdHJvcHknOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcExpZ2h0JzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqc29uLmxpZ2h0TWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcExpZ2h0UmVwZWF0LCBtLm1hcExpZ2h0T2Zmc2V0LCBtLm1hcExpZ2h0V3JhcCwgbS5tYXBMaWdodEFuaXNvdHJvcHkgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBMaWdodFJlcGVhdCc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwTGlnaHRPZmZzZXQnOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcExpZ2h0V3JhcCc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwTGlnaHRBbmlzb3Ryb3B5JzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBBTyc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0anNvbi5hb01hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBBT1JlcGVhdCwgbS5tYXBBT09mZnNldCwgbS5tYXBBT1dyYXAsIG0ubWFwQU9Bbmlzb3Ryb3B5ICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwQU9SZXBlYXQnOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcEFPT2Zmc2V0JzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBBT1dyYXAnOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcEFPQW5pc290cm9weSc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwQnVtcCc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0anNvbi5idW1wTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcEJ1bXBSZXBlYXQsIG0ubWFwQnVtcE9mZnNldCwgbS5tYXBCdW1wV3JhcCwgbS5tYXBCdW1wQW5pc290cm9weSApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcEJ1bXBTY2FsZSc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0anNvbi5idW1wU2NhbGUgPSB2YWx1ZTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBCdW1wUmVwZWF0JzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBCdW1wT2Zmc2V0JzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBCdW1wV3JhcCc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwQnVtcEFuaXNvdHJvcHknOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcE5vcm1hbCc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0anNvbi5ub3JtYWxNYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwTm9ybWFsUmVwZWF0LCBtLm1hcE5vcm1hbE9mZnNldCwgbS5tYXBOb3JtYWxXcmFwLCBtLm1hcE5vcm1hbEFuaXNvdHJvcHkgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBOb3JtYWxGYWN0b3InOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGpzb24ubm9ybWFsU2NhbGUgPSBbIHZhbHVlLCB2YWx1ZSBdO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcE5vcm1hbFJlcGVhdCc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwTm9ybWFsT2Zmc2V0JzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBOb3JtYWxXcmFwJzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBOb3JtYWxBbmlzb3Ryb3B5JzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBTcGVjdWxhcic6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0anNvbi5zcGVjdWxhck1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBTcGVjdWxhclJlcGVhdCwgbS5tYXBTcGVjdWxhck9mZnNldCwgbS5tYXBTcGVjdWxhcldyYXAsIG0ubWFwU3BlY3VsYXJBbmlzb3Ryb3B5ICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwU3BlY3VsYXJSZXBlYXQnOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcFNwZWN1bGFyT2Zmc2V0JzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBTcGVjdWxhcldyYXAnOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcFNwZWN1bGFyQW5pc290cm9weSc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwTWV0YWxuZXNzJzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqc29uLm1ldGFsbmVzc01hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBNZXRhbG5lc3NSZXBlYXQsIG0ubWFwTWV0YWxuZXNzT2Zmc2V0LCBtLm1hcE1ldGFsbmVzc1dyYXAsIG0ubWFwTWV0YWxuZXNzQW5pc290cm9weSApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcE1ldGFsbmVzc1JlcGVhdCc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwTWV0YWxuZXNzT2Zmc2V0JzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBNZXRhbG5lc3NXcmFwJzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBNZXRhbG5lc3NBbmlzb3Ryb3B5JzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBSb3VnaG5lc3MnOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGpzb24ucm91Z2huZXNzTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcFJvdWdobmVzc1JlcGVhdCwgbS5tYXBSb3VnaG5lc3NPZmZzZXQsIG0ubWFwUm91Z2huZXNzV3JhcCwgbS5tYXBSb3VnaG5lc3NBbmlzb3Ryb3B5ICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwUm91Z2huZXNzUmVwZWF0JzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBSb3VnaG5lc3NPZmZzZXQnOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcFJvdWdobmVzc1dyYXAnOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcFJvdWdobmVzc0FuaXNvdHJvcHknOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcEFscGhhJzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqc29uLmFscGhhTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcEFscGhhUmVwZWF0LCBtLm1hcEFscGhhT2Zmc2V0LCBtLm1hcEFscGhhV3JhcCwgbS5tYXBBbHBoYUFuaXNvdHJvcHkgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBBbHBoYVJlcGVhdCc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwQWxwaGFPZmZzZXQnOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcEFscGhhV3JhcCc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwQWxwaGFBbmlzb3Ryb3B5JzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdmbGlwU2lkZWQnOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGpzb24uc2lkZSA9IEJhY2tTaWRlO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ2RvdWJsZVNpZGVkJzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqc29uLnNpZGUgPSBEb3VibGVTaWRlO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ3RyYW5zcGFyZW5jeSc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTG9hZGVyLmNyZWF0ZU1hdGVyaWFsOiB0cmFuc3BhcmVuY3kgaGFzIGJlZW4gcmVuYW1lZCB0byBvcGFjaXR5JyApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGpzb24ub3BhY2l0eSA9IHZhbHVlO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ2RlcHRoVGVzdCc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnZGVwdGhXcml0ZSc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnY29sb3JXcml0ZSc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnb3BhY2l0eSc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAncmVmbGVjdGl2aXR5JzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICd0cmFuc3BhcmVudCc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAndmlzaWJsZSc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnd2lyZWZyYW1lJzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqc29uWyBuYW1lIF0gPSB2YWx1ZTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICd2ZXJ0ZXhDb2xvcnMnOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggdmFsdWUgPT09IHRydWUgKSBqc29uLnZlcnRleENvbG9ycyA9IFZlcnRleENvbG9ycztcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHZhbHVlID09PSAnZmFjZScgKSBqc29uLnZlcnRleENvbG9ycyA9IEZhY2VDb2xvcnM7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGVmYXVsdDpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTG9hZGVyLmNyZWF0ZU1hdGVyaWFsOiBVbnN1cHBvcnRlZCcsIG5hbWUsIHZhbHVlICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGpzb24udHlwZSA9PT0gJ01lc2hCYXNpY01hdGVyaWFsJyApIGRlbGV0ZSBqc29uLmVtaXNzaXZlO1xcclxcblxcdFxcdFxcdFxcdGlmICgganNvbi50eXBlICE9PSAnTWVzaFBob25nTWF0ZXJpYWwnICkgZGVsZXRlIGpzb24uc3BlY3VsYXI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBqc29uLm9wYWNpdHkgPCAxICkganNvbi50cmFuc3BhcmVudCA9IHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bWF0ZXJpYWxMb2FkZXIuc2V0VGV4dHVyZXMoIHRleHR1cmVzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIG1hdGVyaWFsTG9hZGVyLnBhcnNlKCBqc29uICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR9ICkoKVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIERvbiBNY0N1cmR5IC8gaHR0cHM6Ly93d3cuZG9ubWNjdXJkeS5jb21cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHR2YXIgTG9hZGVyVXRpbHMgPSB7XFxyXFxuXFxyXFxuXFx0XFx0ZGVjb2RlVGV4dDogZnVuY3Rpb24gKCBhcnJheSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gJ3VuZGVmaW5lZCcgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZSggYXJyYXkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gQXZvaWQgdGhlIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyYXkpIHNob3J0Y3V0LCB3aGljaFxcclxcblxcdFxcdFxcdC8vIHRocm93cyBhIFxcXCJtYXhpbXVtIGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFxcXCIgZXJyb3IgZm9yIGxhcmdlIGFycmF5cy5cXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcyA9ICcnO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSBhcnJheS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBJbXBsaWNpdGx5IGFzc3VtZXMgbGl0dGxlLWVuZGlhbi5cXHJcXG5cXHRcXHRcXHRcXHRzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoIGFycmF5WyBpIF0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRleHRyYWN0VXJsQmFzZTogZnVuY3Rpb24gKCB1cmwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHBhcnRzID0gdXJsLnNwbGl0KCAnLycgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHBhcnRzLmxlbmd0aCA9PT0gMSApIHJldHVybiAnLi8nO1xcclxcblxcclxcblxcdFxcdFxcdHBhcnRzLnBvcCgpO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBwYXJ0cy5qb2luKCAnLycgKSArICcvJztcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gSlNPTkxvYWRlciggbWFuYWdlciApIHtcXHJcXG5cXHJcXG5cXHRcXHRpZiAoIHR5cGVvZiBtYW5hZ2VyID09PSAnYm9vbGVhbicgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSlNPTkxvYWRlcjogc2hvd1N0YXR1cyBwYXJhbWV0ZXIgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIGNvbnN0cnVjdG9yLicgKTtcXHJcXG5cXHRcXHRcXHRtYW5hZ2VyID0gdW5kZWZpbmVkO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLndpdGhDcmVkZW50aWFscyA9IGZhbHNlO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRPYmplY3QuYXNzaWduKCBKU09OTG9hZGVyLnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHNjb3BlID0gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdGV4dHVyZVBhdGggPSB0aGlzLnRleHR1cmVQYXRoICYmICggdHlwZW9mIHRoaXMudGV4dHVyZVBhdGggPT09ICdzdHJpbmcnICkgPyB0aGlzLnRleHR1cmVQYXRoIDogTG9hZGVyVXRpbHMuZXh0cmFjdFVybEJhc2UoIHVybCApO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XFxyXFxuXFx0XFx0XFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdGhpcy53aXRoQ3JlZGVudGlhbHMgKTtcXHJcXG5cXHRcXHRcXHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGpzb24gPSBKU09OLnBhcnNlKCB0ZXh0ICk7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIG1ldGFkYXRhID0ganNvbi5tZXRhZGF0YTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIG1ldGFkYXRhICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHR5cGUgPSBtZXRhZGF0YS50eXBlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggdHlwZSAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggdHlwZS50b0xvd2VyQ2FzZSgpID09PSAnb2JqZWN0JyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuSlNPTkxvYWRlcjogJyArIHVybCArICcgc2hvdWxkIGJlIGxvYWRlZCB3aXRoIFRIUkVFLk9iamVjdExvYWRlciBpbnN0ZWFkLicgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggdHlwZS50b0xvd2VyQ2FzZSgpID09PSAnc2NlbmUnICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5KU09OTG9hZGVyOiAnICsgdXJsICsgJyBzaG91bGQgYmUgbG9hZGVkIHdpdGggVEhSRUUuU2NlbmVMb2FkZXIgaW5zdGVhZC4nICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBvYmplY3QgPSBzY29wZS5wYXJzZSgganNvbiwgdGV4dHVyZVBhdGggKTtcXHJcXG5cXHRcXHRcXHRcXHRvbkxvYWQoIG9iamVjdC5nZW9tZXRyeSwgb2JqZWN0Lm1hdGVyaWFscyApO1xcclxcblxcclxcblxcdFxcdFxcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldFRleHR1cmVQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMudGV4dHVyZVBhdGggPSB2YWx1ZTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHBhcnNlOiAoIGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmdW5jdGlvbiBwYXJzZU1vZGVsKCBqc29uLCBnZW9tZXRyeSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiBpc0JpdFNldCggdmFsdWUsIHBvc2l0aW9uICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB2YWx1ZSAmICggMSA8PCBwb3NpdGlvbiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgaSwgaiwgZmksXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0b2Zmc2V0LCB6TGVuZ3RoLFxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNvbG9ySW5kZXgsIG5vcm1hbEluZGV4LCB1dkluZGV4LCBtYXRlcmlhbEluZGV4LFxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHR5cGUsXFxyXFxuXFx0XFx0XFx0XFx0XFx0aXNRdWFkLFxcclxcblxcdFxcdFxcdFxcdFxcdGhhc01hdGVyaWFsLFxcclxcblxcdFxcdFxcdFxcdFxcdGhhc0ZhY2VWZXJ0ZXhVdixcXHJcXG5cXHRcXHRcXHRcXHRcXHRoYXNGYWNlTm9ybWFsLCBoYXNGYWNlVmVydGV4Tm9ybWFsLFxcclxcblxcdFxcdFxcdFxcdFxcdGhhc0ZhY2VDb2xvciwgaGFzRmFjZVZlcnRleENvbG9yLFxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZlcnRleCwgZmFjZSwgZmFjZUEsIGZhY2VCLCBoZXgsIG5vcm1hbCxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR1dkxheWVyLCB1diwgdSwgdixcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmYWNlcyA9IGpzb24uZmFjZXMsXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmVydGljZXMgPSBqc29uLnZlcnRpY2VzLFxcclxcblxcdFxcdFxcdFxcdFxcdG5vcm1hbHMgPSBqc29uLm5vcm1hbHMsXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y29sb3JzID0ganNvbi5jb2xvcnMsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0c2NhbGUgPSBqc29uLnNjYWxlLFxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdG5VdkxheWVycyA9IDA7XFxyXFxuXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBqc29uLnV2cyAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIGRpc3JlZ2FyZCBlbXB0eSBhcnJheXNcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCBpID0gMDsgaSA8IGpzb24udXZzLmxlbmd0aDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGpzb24udXZzWyBpIF0ubGVuZ3RoICkgblV2TGF5ZXJzICsrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF0gPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdG9mZnNldCA9IDA7XFxyXFxuXFx0XFx0XFx0XFx0ekxlbmd0aCA9IHZlcnRpY2VzLmxlbmd0aDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR3aGlsZSAoIG9mZnNldCA8IHpMZW5ndGggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0ZXgueCA9IHZlcnRpY2VzWyBvZmZzZXQgKysgXSAqIHNjYWxlO1xcclxcblxcdFxcdFxcdFxcdFxcdHZlcnRleC55ID0gdmVydGljZXNbIG9mZnNldCArKyBdICogc2NhbGU7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmVydGV4LnogPSB2ZXJ0aWNlc1sgb2Zmc2V0ICsrIF0gKiBzY2FsZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0b2Zmc2V0ID0gMDtcXHJcXG5cXHRcXHRcXHRcXHR6TGVuZ3RoID0gZmFjZXMubGVuZ3RoO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHdoaWxlICggb2Zmc2V0IDwgekxlbmd0aCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0eXBlID0gZmFjZXNbIG9mZnNldCArKyBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlzUXVhZCA9IGlzQml0U2V0KCB0eXBlLCAwICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0aGFzTWF0ZXJpYWwgPSBpc0JpdFNldCggdHlwZSwgMSApO1xcclxcblxcdFxcdFxcdFxcdFxcdGhhc0ZhY2VWZXJ0ZXhVdiA9IGlzQml0U2V0KCB0eXBlLCAzICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0aGFzRmFjZU5vcm1hbCA9IGlzQml0U2V0KCB0eXBlLCA0ICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0aGFzRmFjZVZlcnRleE5vcm1hbCA9IGlzQml0U2V0KCB0eXBlLCA1ICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0aGFzRmFjZUNvbG9yID0gaXNCaXRTZXQoIHR5cGUsIDYgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRoYXNGYWNlVmVydGV4Q29sb3IgPSBpc0JpdFNldCggdHlwZSwgNyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIGNvbnNvbGUubG9nKFxcXCJ0eXBlXFxcIiwgdHlwZSwgXFxcImJpdHNcXFwiLCBpc1F1YWQsIGhhc01hdGVyaWFsLCBoYXNGYWNlVmVydGV4VXYsIGhhc0ZhY2VOb3JtYWwsIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwsIGhhc0ZhY2VDb2xvciwgaGFzRmFjZVZlcnRleENvbG9yKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGlzUXVhZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRmYWNlQSA9IG5ldyBGYWNlMygpO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGZhY2VBLmEgPSBmYWNlc1sgb2Zmc2V0IF07XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmFjZUEuYiA9IGZhY2VzWyBvZmZzZXQgKyAxIF07XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmFjZUEuYyA9IGZhY2VzWyBvZmZzZXQgKyAzIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmFjZUIgPSBuZXcgRmFjZTMoKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRmYWNlQi5hID0gZmFjZXNbIG9mZnNldCArIDEgXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRmYWNlQi5iID0gZmFjZXNbIG9mZnNldCArIDIgXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRmYWNlQi5jID0gZmFjZXNbIG9mZnNldCArIDMgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRvZmZzZXQgKz0gNDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGhhc01hdGVyaWFsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZmFjZUEubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZmFjZUIubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHRvIGdldCBmYWNlIDw9PiB1diBpbmRleCBjb3JyZXNwb25kZW5jZVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGZpID0gZ2VvbWV0cnkuZmFjZXMubGVuZ3RoO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggaGFzRmFjZVZlcnRleFV2ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDwgblV2TGF5ZXJzOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHV2TGF5ZXIgPSBqc29uLnV2c1sgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXSA9IFtdO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgKyAxIF0gPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCBqID0gMDsgaiA8IDQ7IGogKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dXZJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR1ID0gdXZMYXllclsgdXZJbmRleCAqIDIgXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR2ID0gdXZMYXllclsgdXZJbmRleCAqIDIgKyAxIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dXYgPSBuZXcgVmVjdG9yMiggdSwgdiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggaiAhPT0gMiApIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXS5wdXNoKCB1diApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggaiAhPT0gMCApIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgKyAxIF0ucHVzaCggdXYgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGhhc0ZhY2VOb3JtYWwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZhY2VBLm5vcm1hbC5zZXQoXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZhY2VCLm5vcm1hbC5jb3B5KCBmYWNlQS5ub3JtYWwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBoYXNGYWNlVmVydGV4Tm9ybWFsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDwgNDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXSAqIDM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsID0gbmV3IFZlY3RvcjMoXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQpO1xcclxcblxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggaSAhPT0gMiApIGZhY2VBLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBpICE9PSAwICkgZmFjZUIudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggaGFzRmFjZUNvbG9yICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aGV4ID0gY29sb3JzWyBjb2xvckluZGV4IF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZmFjZUEuY29sb3Iuc2V0SGV4KCBoZXggKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmYWNlQi5jb2xvci5zZXRIZXgoIGhleCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGhhc0ZhY2VWZXJ0ZXhDb2xvciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCBpID0gMDsgaSA8IDQ7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRoZXggPSBjb2xvcnNbIGNvbG9ySW5kZXggXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGkgIT09IDIgKSBmYWNlQS52ZXJ0ZXhDb2xvcnMucHVzaCggbmV3IENvbG9yKCBoZXggKSApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggaSAhPT0gMCApIGZhY2VCLnZlcnRleENvbG9ycy5wdXNoKCBuZXcgQ29sb3IoIGhleCApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeS5mYWNlcy5wdXNoKCBmYWNlQSApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5LmZhY2VzLnB1c2goIGZhY2VCICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRmYWNlID0gbmV3IEZhY2UzKCk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmFjZS5hID0gZmFjZXNbIG9mZnNldCArKyBdO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGZhY2UuYiA9IGZhY2VzWyBvZmZzZXQgKysgXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRmYWNlLmMgPSBmYWNlc1sgb2Zmc2V0ICsrIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBoYXNNYXRlcmlhbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRtYXRlcmlhbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZhY2UubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHRvIGdldCBmYWNlIDw9PiB1diBpbmRleCBjb3JyZXNwb25kZW5jZVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGZpID0gZ2VvbWV0cnkuZmFjZXMubGVuZ3RoO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggaGFzRmFjZVZlcnRleFV2ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDwgblV2TGF5ZXJzOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHV2TGF5ZXIgPSBqc29uLnV2c1sgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXSA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIGogPSAwOyBqIDwgMzsgaiArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR1dkluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHUgPSB1dkxheWVyWyB1dkluZGV4ICogMiBdO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHYgPSB1dkxheWVyWyB1dkluZGV4ICogMiArIDEgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR1diA9IG5ldyBWZWN0b3IyKCB1LCB2ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdLnB1c2goIHV2ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBoYXNGYWNlTm9ybWFsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmYWNlLm5vcm1hbC5zZXQoXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggaSA9IDA7IGkgPCAzOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRub3JtYWwgPSBuZXcgVmVjdG9yMyhcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggXVxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBoYXNGYWNlQ29sb3IgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmYWNlLmNvbG9yLnNldEhleCggY29sb3JzWyBjb2xvckluZGV4IF0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBoYXNGYWNlVmVydGV4Q29sb3IgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggaSA9IDA7IGkgPCAzOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZmFjZS52ZXJ0ZXhDb2xvcnMucHVzaCggbmV3IENvbG9yKCBjb2xvcnNbIGNvbG9ySW5kZXggXSApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeS5mYWNlcy5wdXNoKCBmYWNlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZnVuY3Rpb24gcGFyc2VTa2luKCBqc29uLCBnZW9tZXRyeSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgaW5mbHVlbmNlc1BlclZlcnRleCA9ICgganNvbi5pbmZsdWVuY2VzUGVyVmVydGV4ICE9PSB1bmRlZmluZWQgKSA/IGpzb24uaW5mbHVlbmNlc1BlclZlcnRleCA6IDI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBqc29uLnNraW5XZWlnaHRzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24uc2tpbldlaWdodHMubGVuZ3RoOyBpIDwgbDsgaSArPSBpbmZsdWVuY2VzUGVyVmVydGV4ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciB4ID0ganNvbi5za2luV2VpZ2h0c1sgaSBdO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciB5ID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMSApID8ganNvbi5za2luV2VpZ2h0c1sgaSArIDEgXSA6IDA7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHogPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAyICkgPyBqc29uLnNraW5XZWlnaHRzWyBpICsgMiBdIDogMDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgdyA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDMgKSA/IGpzb24uc2tpbldlaWdodHNbIGkgKyAzIF0gOiAwO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5LnNraW5XZWlnaHRzLnB1c2goIG5ldyBWZWN0b3I0KCB4LCB5LCB6LCB3ICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICgganNvbi5za2luSW5kaWNlcyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLnNraW5JbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gaW5mbHVlbmNlc1BlclZlcnRleCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgYSA9IGpzb24uc2tpbkluZGljZXNbIGkgXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgYiA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDEgKSA/IGpzb24uc2tpbkluZGljZXNbIGkgKyAxIF0gOiAwO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBjID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMiApID8ganNvbi5za2luSW5kaWNlc1sgaSArIDIgXSA6IDA7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGQgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAzICkgPyBqc29uLnNraW5JbmRpY2VzWyBpICsgMyBdIDogMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeS5za2luSW5kaWNlcy5wdXNoKCBuZXcgVmVjdG9yNCggYSwgYiwgYywgZCApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRnZW9tZXRyeS5ib25lcyA9IGpzb24uYm9uZXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5ib25lcyAmJiBnZW9tZXRyeS5ib25lcy5sZW5ndGggPiAwICYmICggZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoICE9PSBnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggfHwgZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoICE9PSBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdXaGVuIHNraW5uaW5nLCBudW1iZXIgb2YgdmVydGljZXMgKCcgKyBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKyAnKSwgc2tpbkluZGljZXMgKCcgK1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCArICcpLCBhbmQgc2tpbldlaWdodHMgKCcgKyBnZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggKyAnKSBzaG91bGQgbWF0Y2guJyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZnVuY3Rpb24gcGFyc2VNb3JwaGluZygganNvbiwgZ2VvbWV0cnkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHNjYWxlID0ganNvbi5zY2FsZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGpzb24ubW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5tb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXSA9IHt9O1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdLm5hbWUgPSBqc29uLm1vcnBoVGFyZ2V0c1sgaSBdLm5hbWU7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgZHN0VmVydGljZXMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcztcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgc3JjVmVydGljZXMgPSBqc29uLm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciB2ID0gMCwgdmwgPSBzcmNWZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArPSAzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZlcnRleC54ID0gc3JjVmVydGljZXNbIHYgXSAqIHNjYWxlO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZlcnRleC55ID0gc3JjVmVydGljZXNbIHYgKyAxIF0gKiBzY2FsZTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2ZXJ0ZXgueiA9IHNyY1ZlcnRpY2VzWyB2ICsgMiBdICogc2NhbGU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZHN0VmVydGljZXMucHVzaCggdmVydGV4ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBqc29uLm1vcnBoQ29sb3JzICE9PSB1bmRlZmluZWQgJiYganNvbi5tb3JwaENvbG9ycy5sZW5ndGggPiAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkpTT05Mb2FkZXI6IFxcXCJtb3JwaENvbG9yc1xcXCIgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gVXNpbmcgdGhlbSBhcyBmYWNlIGNvbG9ycy4nICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIG1vcnBoQ29sb3JzID0ganNvbi5tb3JwaENvbG9yc1sgMCBdLmNvbG9ycztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGZhY2VzWyBpIF0uY29sb3IuZnJvbUFycmF5KCBtb3JwaENvbG9ycywgaSAqIDMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRmdW5jdGlvbiBwYXJzZUFuaW1hdGlvbnMoIGpzb24sIGdlb21ldHJ5ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBvdXRwdXRBbmltYXRpb25zID0gW107XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gcGFyc2Ugb2xkIHN0eWxlIEJvbmUvSGllcmFyY2h5IGFuaW1hdGlvbnNcXHJcXG5cXHRcXHRcXHRcXHR2YXIgYW5pbWF0aW9ucyA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICgganNvbi5hbmltYXRpb24gIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRhbmltYXRpb25zLnB1c2goIGpzb24uYW5pbWF0aW9uICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICgganNvbi5hbmltYXRpb25zICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBqc29uLmFuaW1hdGlvbnMubGVuZ3RoICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGFuaW1hdGlvbnMgPSBhbmltYXRpb25zLmNvbmNhdCgganNvbi5hbmltYXRpb25zICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRhbmltYXRpb25zLnB1c2goIGpzb24uYW5pbWF0aW9ucyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYW5pbWF0aW9ucy5sZW5ndGg7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGNsaXAgPSBBbmltYXRpb25DbGlwLnBhcnNlQW5pbWF0aW9uKCBhbmltYXRpb25zWyBpIF0sIGdlb21ldHJ5LmJvbmVzICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBjbGlwICkgb3V0cHV0QW5pbWF0aW9ucy5wdXNoKCBjbGlwICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIHBhcnNlIGltcGxpY2l0IG1vcnBoIGFuaW1hdGlvbnNcXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBUT0RPOiBGaWd1cmUgb3V0IHdoYXQgYW4gYXBwcm9wcmFpdGUgRlBTIGlzIGZvciBtb3JwaCB0YXJnZXQgYW5pbWF0aW9ucyAtLSBkZWZhdWx0aW5nIHRvIDEwLCBidXQgcmVhbGx5IGl0IGlzIGNvbXBsZXRlbHkgYXJiaXRyYXJ5LlxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBtb3JwaEFuaW1hdGlvbkNsaXBzID0gQW5pbWF0aW9uQ2xpcC5DcmVhdGVDbGlwc0Zyb21Nb3JwaFRhcmdldFNlcXVlbmNlcyggZ2VvbWV0cnkubW9ycGhUYXJnZXRzLCAxMCApO1xcclxcblxcdFxcdFxcdFxcdFxcdG91dHB1dEFuaW1hdGlvbnMgPSBvdXRwdXRBbmltYXRpb25zLmNvbmNhdCggbW9ycGhBbmltYXRpb25DbGlwcyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIG91dHB1dEFuaW1hdGlvbnMubGVuZ3RoID4gMCApIGdlb21ldHJ5LmFuaW1hdGlvbnMgPSBvdXRwdXRBbmltYXRpb25zO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gKCBqc29uLCB0ZXh0dXJlUGF0aCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGpzb24uZGF0YSAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIEdlb21ldHJ5IDQuMCBzcGVjXFxyXFxuXFx0XFx0XFx0XFx0XFx0anNvbiA9IGpzb24uZGF0YTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBqc29uLnNjYWxlICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0anNvbi5zY2FsZSA9IDEuMCAvIGpzb24uc2NhbGU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRqc29uLnNjYWxlID0gMS4wO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgZ2VvbWV0cnkgPSBuZXcgR2VvbWV0cnkoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRwYXJzZU1vZGVsKCBqc29uLCBnZW9tZXRyeSApO1xcclxcblxcdFxcdFxcdFxcdHBhcnNlU2tpbigganNvbiwgZ2VvbWV0cnkgKTtcXHJcXG5cXHRcXHRcXHRcXHRwYXJzZU1vcnBoaW5nKCBqc29uLCBnZW9tZXRyeSApO1xcclxcblxcdFxcdFxcdFxcdHBhcnNlQW5pbWF0aW9ucygganNvbiwgZ2VvbWV0cnkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRnZW9tZXRyeS5jb21wdXRlRmFjZU5vcm1hbHMoKTtcXHJcXG5cXHRcXHRcXHRcXHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGpzb24ubWF0ZXJpYWxzID09PSB1bmRlZmluZWQgfHwganNvbi5tYXRlcmlhbHMubGVuZ3RoID09PSAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB7IGdlb21ldHJ5OiBnZW9tZXRyeSB9O1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIG1hdGVyaWFscyA9IExvYWRlci5wcm90b3R5cGUuaW5pdE1hdGVyaWFscygganNvbi5tYXRlcmlhbHMsIHRleHR1cmVQYXRoLCB0aGlzLmNyb3NzT3JpZ2luICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHsgZ2VvbWV0cnk6IGdlb21ldHJ5LCBtYXRlcmlhbHM6IG1hdGVyaWFscyB9O1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0gKSgpXFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gT2JqZWN0TG9hZGVyKCBtYW5hZ2VyICkge1xcclxcblxcclxcblxcdFxcdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xcclxcblxcdFxcdHRoaXMudGV4dHVyZVBhdGggPSAnJztcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0T2JqZWN0LmFzc2lnbiggT2JqZWN0TG9hZGVyLnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLnRleHR1cmVQYXRoID09PSAnJyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnRleHR1cmVQYXRoID0gdXJsLnN1YnN0cmluZyggMCwgdXJsLmxhc3RJbmRleE9mKCAnLycgKSArIDEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHNjb3BlID0gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcXHJcXG5cXHRcXHRcXHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGpzb24gPSBudWxsO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRyeSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0anNvbiA9IEpTT04ucGFyc2UoIHRleHQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9IGNhdGNoICggZXJyb3IgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBvbkVycm9yICE9PSB1bmRlZmluZWQgKSBvbkVycm9yKCBlcnJvciApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRTpPYmplY3RMb2FkZXI6IENhblxcXFwndCBwYXJzZSAnICsgdXJsICsgJy4nLCBlcnJvci5tZXNzYWdlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgbWV0YWRhdGEgPSBqc29uLm1ldGFkYXRhO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggbWV0YWRhdGEgPT09IHVuZGVmaW5lZCB8fCBtZXRhZGF0YS50eXBlID09PSB1bmRlZmluZWQgfHwgbWV0YWRhdGEudHlwZS50b0xvd2VyQ2FzZSgpID09PSAnZ2VvbWV0cnknICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5PYmplY3RMb2FkZXI6IENhblxcXFwndCBsb2FkICcgKyB1cmwgKyAnLiBVc2UgVEhSRUUuSlNPTkxvYWRlciBpbnN0ZWFkLicgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHNjb3BlLnBhcnNlKCBqc29uLCBvbkxvYWQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRUZXh0dXJlUGF0aDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnRleHR1cmVQYXRoID0gdmFsdWU7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRwYXJzZTogZnVuY3Rpb24gKCBqc29uLCBvbkxvYWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHNoYXBlcyA9IHRoaXMucGFyc2VTaGFwZSgganNvbi5zaGFwZXMgKTtcXHJcXG5cXHRcXHRcXHR2YXIgZ2VvbWV0cmllcyA9IHRoaXMucGFyc2VHZW9tZXRyaWVzKCBqc29uLmdlb21ldHJpZXMsIHNoYXBlcyApO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBpbWFnZXMgPSB0aGlzLnBhcnNlSW1hZ2VzKCBqc29uLmltYWdlcywgZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggb25Mb2FkICE9PSB1bmRlZmluZWQgKSBvbkxvYWQoIG9iamVjdCApO1xcclxcblxcclxcblxcdFxcdFxcdH0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdGV4dHVyZXMgPSB0aGlzLnBhcnNlVGV4dHVyZXMoIGpzb24udGV4dHVyZXMsIGltYWdlcyApO1xcclxcblxcdFxcdFxcdHZhciBtYXRlcmlhbHMgPSB0aGlzLnBhcnNlTWF0ZXJpYWxzKCBqc29uLm1hdGVyaWFscywgdGV4dHVyZXMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgb2JqZWN0ID0gdGhpcy5wYXJzZU9iamVjdCgganNvbi5vYmplY3QsIGdlb21ldHJpZXMsIG1hdGVyaWFscyApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICgganNvbi5hbmltYXRpb25zICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdG9iamVjdC5hbmltYXRpb25zID0gdGhpcy5wYXJzZUFuaW1hdGlvbnMoIGpzb24uYW5pbWF0aW9ucyApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGpzb24uaW1hZ2VzID09PSB1bmRlZmluZWQgfHwganNvbi5pbWFnZXMubGVuZ3RoID09PSAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggb25Mb2FkICE9PSB1bmRlZmluZWQgKSBvbkxvYWQoIG9iamVjdCApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gb2JqZWN0O1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0cGFyc2VTaGFwZTogZnVuY3Rpb24gKCBqc29uICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBzaGFwZXMgPSB7fTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHNoYXBlID0gbmV3IFNoYXBlKCkuZnJvbUpTT04oIGpzb25bIGkgXSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHNoYXBlc1sgc2hhcGUudXVpZCBdID0gc2hhcGU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gc2hhcGVzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0cGFyc2VHZW9tZXRyaWVzOiBmdW5jdGlvbiAoIGpzb24sIHNoYXBlcyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgZ2VvbWV0cmllcyA9IHt9O1xcclxcblxcclxcblxcdFxcdFxcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBnZW9tZXRyeUxvYWRlciA9IG5ldyBKU09OTG9hZGVyKCk7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGJ1ZmZlckdlb21ldHJ5TG9hZGVyID0gbmV3IEJ1ZmZlckdlb21ldHJ5TG9hZGVyKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBnZW9tZXRyeTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgZGF0YSA9IGpzb25bIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRzd2l0Y2ggKCBkYXRhLnR5cGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnUGxhbmVHZW9tZXRyeSc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnUGxhbmVCdWZmZXJHZW9tZXRyeSc6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS53aWR0aCxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLmhlaWdodCxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLndpZHRoU2VnbWVudHMsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5oZWlnaHRTZWdtZW50c1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnQm94R2VvbWV0cnknOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ0JveEJ1ZmZlckdlb21ldHJ5JzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdDdWJlR2VvbWV0cnknOiAvLyBiYWNrd2FyZHMgY29tcGF0aWJsZVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEud2lkdGgsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5oZWlnaHQsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5kZXB0aCxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLndpZHRoU2VnbWVudHMsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5oZWlnaHRTZWdtZW50cyxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLmRlcHRoU2VnbWVudHNcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ0NpcmNsZUdlb21ldHJ5JzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdDaXJjbGVCdWZmZXJHZW9tZXRyeSc6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5yYWRpdXMsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5zZWdtZW50cyxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnRoZXRhU3RhcnQsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS50aGV0YUxlbmd0aFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnQ3lsaW5kZXJHZW9tZXRyeSc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeSc6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5yYWRpdXNUb3AsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5yYWRpdXNCb3R0b20sXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5oZWlnaHQsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5yYWRpYWxTZWdtZW50cyxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLmhlaWdodFNlZ21lbnRzLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEub3BlbkVuZGVkLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEudGhldGFTdGFydCxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnRoZXRhTGVuZ3RoXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0KTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdDb25lR2VvbWV0cnknOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ0NvbmVCdWZmZXJHZW9tZXRyeSc6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5yYWRpdXMsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5oZWlnaHQsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5yYWRpYWxTZWdtZW50cyxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLmhlaWdodFNlZ21lbnRzLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEub3BlbkVuZGVkLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEudGhldGFTdGFydCxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnRoZXRhTGVuZ3RoXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0KTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdTcGhlcmVHZW9tZXRyeSc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnU3BoZXJlQnVmZmVyR2VvbWV0cnknOlxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEucmFkaXVzLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEud2lkdGhTZWdtZW50cyxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLmhlaWdodFNlZ21lbnRzLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEucGhpU3RhcnQsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5waGlMZW5ndGgsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS50aGV0YVN0YXJ0LFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEudGhldGFMZW5ndGhcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ0RvZGVjYWhlZHJvbkdlb21ldHJ5JzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdEb2RlY2FoZWRyb25CdWZmZXJHZW9tZXRyeSc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnSWNvc2FoZWRyb25HZW9tZXRyeSc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnSWNvc2FoZWRyb25CdWZmZXJHZW9tZXRyeSc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnT2N0YWhlZHJvbkdlb21ldHJ5JzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdPY3RhaGVkcm9uQnVmZmVyR2VvbWV0cnknOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ1RldHJhaGVkcm9uR2VvbWV0cnknOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ1RldHJhaGVkcm9uQnVmZmVyR2VvbWV0cnknOlxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEucmFkaXVzLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEuZGV0YWlsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0KTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdSaW5nR2VvbWV0cnknOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ1JpbmdCdWZmZXJHZW9tZXRyeSc6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5pbm5lclJhZGl1cyxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLm91dGVyUmFkaXVzLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEudGhldGFTZWdtZW50cyxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnBoaVNlZ21lbnRzLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEudGhldGFTdGFydCxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnRoZXRhTGVuZ3RoXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0KTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdUb3J1c0dlb21ldHJ5JzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdUb3J1c0J1ZmZlckdlb21ldHJ5JzpcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnJhZGl1cyxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnR1YmUsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5yYWRpYWxTZWdtZW50cyxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnR1YnVsYXJTZWdtZW50cyxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLmFyY1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnVG9ydXNLbm90R2VvbWV0cnknOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ1RvcnVzS25vdEJ1ZmZlckdlb21ldHJ5JzpcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnJhZGl1cyxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnR1YmUsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS50dWJ1bGFyU2VnbWVudHMsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5yYWRpYWxTZWdtZW50cyxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnAsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5xXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0KTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdMYXRoZUdlb21ldHJ5JzpcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdMYXRoZUJ1ZmZlckdlb21ldHJ5JzpcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnBvaW50cyxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnNlZ21lbnRzLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEucGhpU3RhcnQsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5waGlMZW5ndGhcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ1BvbHloZWRyb25HZW9tZXRyeSc6XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5JzpcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnZlcnRpY2VzLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEuaW5kaWNlcyxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnJhZGl1cyxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLmRldGFpbHNcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ1NoYXBlR2VvbWV0cnknOlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ1NoYXBlQnVmZmVyR2VvbWV0cnknOlxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBnZW9tZXRyeVNoYXBlcyA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGRhdGEuc2hhcGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIHNoYXBlID0gc2hhcGVzWyBkYXRhLnNoYXBlc1sgaSBdIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnlTaGFwZXMucHVzaCggc2hhcGUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnlTaGFwZXMsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5jdXJ2ZVNlZ21lbnRzXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0KTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdCdWZmZXJHZW9tZXRyeSc6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkgPSBidWZmZXJHZW9tZXRyeUxvYWRlci5wYXJzZSggZGF0YSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ0dlb21ldHJ5JzpcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeSA9IGdlb21ldHJ5TG9hZGVyLnBhcnNlKCBkYXRhLCB0aGlzLnRleHR1cmVQYXRoICkuZ2VvbWV0cnk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGVmYXVsdDpcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuc3VwcG9ydGVkIGdlb21ldHJ5IHR5cGUgXFxcIicgKyBkYXRhLnR5cGUgKyAnXFxcIicgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb250aW51ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkudXVpZCA9IGRhdGEudXVpZDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkICkgZ2VvbWV0cnkubmFtZSA9IGRhdGEubmFtZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRnZW9tZXRyaWVzWyBkYXRhLnV1aWQgXSA9IGdlb21ldHJ5O1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGdlb21ldHJpZXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRwYXJzZU1hdGVyaWFsczogZnVuY3Rpb24gKCBqc29uLCB0ZXh0dXJlcyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbWF0ZXJpYWxzID0ge307XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGxvYWRlciA9IG5ldyBNYXRlcmlhbExvYWRlcigpO1xcclxcblxcdFxcdFxcdFxcdGxvYWRlci5zZXRUZXh0dXJlcyggdGV4dHVyZXMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGRhdGEgPSBqc29uWyBpIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLnR5cGUgPT09ICdNdWx0aU1hdGVyaWFsJyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBEZXByZWNhdGVkXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGFycmF5ID0gW107XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGogPSAwOyBqIDwgZGF0YS5tYXRlcmlhbHMubGVuZ3RoOyBqICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGFycmF5LnB1c2goIGxvYWRlci5wYXJzZSggZGF0YS5tYXRlcmlhbHNbIGogXSApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsc1sgZGF0YS51dWlkIF0gPSBhcnJheTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsc1sgZGF0YS51dWlkIF0gPSBsb2FkZXIucGFyc2UoIGRhdGEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gbWF0ZXJpYWxzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0cGFyc2VBbmltYXRpb25zOiBmdW5jdGlvbiAoIGpzb24gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGFuaW1hdGlvbnMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBqc29uLmxlbmd0aDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgY2xpcCA9IEFuaW1hdGlvbkNsaXAucGFyc2UoIGpzb25bIGkgXSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGFuaW1hdGlvbnMucHVzaCggY2xpcCApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gYW5pbWF0aW9ucztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHBhcnNlSW1hZ2VzOiBmdW5jdGlvbiAoIGpzb24sIG9uTG9hZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgc2NvcGUgPSB0aGlzO1xcclxcblxcdFxcdFxcdHZhciBpbWFnZXMgPSB7fTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmdW5jdGlvbiBsb2FkSW1hZ2UoIHVybCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0sIHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgJiYganNvbi5sZW5ndGggPiAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBtYW5hZ2VyID0gbmV3IExvYWRpbmdNYW5hZ2VyKCBvbkxvYWQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgbG9hZGVyID0gbmV3IEltYWdlTG9hZGVyKCBtYW5hZ2VyICk7XFxyXFxuXFx0XFx0XFx0XFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBpbWFnZSA9IGpzb25bIGkgXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgcGF0aCA9IC9eKFxcXFwvXFxcXC8pfChbYS16XSs6KFxcXFwvXFxcXC8pPykvaS50ZXN0KCBpbWFnZS51cmwgKSA/IGltYWdlLnVybCA6IHNjb3BlLnRleHR1cmVQYXRoICsgaW1hZ2UudXJsO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGltYWdlc1sgaW1hZ2UudXVpZCBdID0gbG9hZEltYWdlKCBwYXRoICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gaW1hZ2VzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0cGFyc2VUZXh0dXJlczogZnVuY3Rpb24gKCBqc29uLCBpbWFnZXMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZnVuY3Rpb24gcGFyc2VDb25zdGFudCggdmFsdWUsIHR5cGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICkgcmV0dXJuIHZhbHVlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlci5wYXJzZVRleHR1cmU6IENvbnN0YW50IHNob3VsZCBiZSBpbiBudW1lcmljIGZvcm0uJywgdmFsdWUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHlwZVsgdmFsdWUgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHRleHR1cmVzID0ge307XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBkYXRhID0ganNvblsgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS5pbWFnZSA9PT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogTm8gXFxcImltYWdlXFxcIiBzcGVjaWZpZWQgZm9yJywgZGF0YS51dWlkICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggaW1hZ2VzWyBkYXRhLmltYWdlIF0gPT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBpbWFnZScsIGRhdGEuaW1hZ2UgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHRleHR1cmUgPSBuZXcgVGV4dHVyZSggaW1hZ2VzWyBkYXRhLmltYWdlIF0gKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLnV1aWQgPSBkYXRhLnV1aWQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLm5hbWUgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubmFtZSA9IGRhdGEubmFtZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEubWFwcGluZyAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5tYXBwaW5nID0gcGFyc2VDb25zdGFudCggZGF0YS5tYXBwaW5nLCBURVhUVVJFX01BUFBJTkcgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEub2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm9mZnNldC5mcm9tQXJyYXkoIGRhdGEub2Zmc2V0ICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLnJlcGVhdCAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5yZXBlYXQuZnJvbUFycmF5KCBkYXRhLnJlcGVhdCApO1xcclxcblxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS5jZW50ZXIgIT09IHVuZGVmaW5lZCApIHRleHR1cmUuY2VudGVyLmZyb21BcnJheSggZGF0YS5jZW50ZXIgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEucm90YXRpb24gIT09IHVuZGVmaW5lZCApIHRleHR1cmUucm90YXRpb24gPSBkYXRhLnJvdGF0aW9uO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS53cmFwICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGV4dHVyZS53cmFwUyA9IHBhcnNlQ29uc3RhbnQoIGRhdGEud3JhcFsgMCBdLCBURVhUVVJFX1dSQVBQSU5HICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGV4dHVyZS53cmFwVCA9IHBhcnNlQ29uc3RhbnQoIGRhdGEud3JhcFsgMSBdLCBURVhUVVJFX1dSQVBQSU5HICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS5taW5GaWx0ZXIgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubWluRmlsdGVyID0gcGFyc2VDb25zdGFudCggZGF0YS5taW5GaWx0ZXIsIFRFWFRVUkVfRklMVEVSICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLm1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5tYWdGaWx0ZXIgPSBwYXJzZUNvbnN0YW50KCBkYXRhLm1hZ0ZpbHRlciwgVEVYVFVSRV9GSUxURVIgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEuYW5pc290cm9weSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5hbmlzb3Ryb3B5ID0gZGF0YS5hbmlzb3Ryb3B5O1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS5mbGlwWSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5mbGlwWSA9IGRhdGEuZmxpcFk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGV4dHVyZXNbIGRhdGEudXVpZCBdID0gdGV4dHVyZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0ZXh0dXJlcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHBhcnNlT2JqZWN0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHBhcnNlT2JqZWN0KCBkYXRhLCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIG9iamVjdDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiBnZXRHZW9tZXRyeSggbmFtZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGdlb21ldHJpZXNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIGdlb21ldHJ5JywgbmFtZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZ2VvbWV0cmllc1sgbmFtZSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiBnZXRNYXRlcmlhbCggbmFtZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG5hbWUgPT09IHVuZGVmaW5lZCApIHJldHVybiB1bmRlZmluZWQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBBcnJheS5pc0FycmF5KCBuYW1lICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGFycmF5ID0gW107XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbmFtZS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciB1dWlkID0gbmFtZVsgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggbWF0ZXJpYWxzWyB1dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBtYXRlcmlhbCcsIHV1aWQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YXJyYXkucHVzaCggbWF0ZXJpYWxzWyB1dWlkIF0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGFycmF5O1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG1hdGVyaWFsc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgbWF0ZXJpYWwnLCBuYW1lICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBtYXRlcmlhbHNbIG5hbWUgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0c3dpdGNoICggZGF0YS50eXBlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ1NjZW5lJzpcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRvYmplY3QgPSBuZXcgU2NlbmUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEuYmFja2dyb3VuZCAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggTnVtYmVyLmlzSW50ZWdlciggZGF0YS5iYWNrZ3JvdW5kICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0LmJhY2tncm91bmQgPSBuZXcgQ29sb3IoIGRhdGEuYmFja2dyb3VuZCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLmZvZyAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS5mb2cudHlwZSA9PT0gJ0ZvZycgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0LmZvZyA9IG5ldyBGb2coIGRhdGEuZm9nLmNvbG9yLCBkYXRhLmZvZy5uZWFyLCBkYXRhLmZvZy5mYXIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBkYXRhLmZvZy50eXBlID09PSAnRm9nRXhwMicgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0LmZvZyA9IG5ldyBGb2dFeHAyKCBkYXRhLmZvZy5jb2xvciwgZGF0YS5mb2cuZGVuc2l0eSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnUGVyc3BlY3RpdmVDYW1lcmEnOlxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdCA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZGF0YS5mb3YsIGRhdGEuYXNwZWN0LCBkYXRhLm5lYXIsIGRhdGEuZmFyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLmZvY3VzICE9PSB1bmRlZmluZWQgKSBvYmplY3QuZm9jdXMgPSBkYXRhLmZvY3VzO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS56b29tICE9PSB1bmRlZmluZWQgKSBvYmplY3Quem9vbSA9IGRhdGEuem9vbTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEuZmlsbUdhdWdlICE9PSB1bmRlZmluZWQgKSBvYmplY3QuZmlsbUdhdWdlID0gZGF0YS5maWxtR2F1Z2U7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLmZpbG1PZmZzZXQgIT09IHVuZGVmaW5lZCApIG9iamVjdC5maWxtT2Zmc2V0ID0gZGF0YS5maWxtT2Zmc2V0O1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS52aWV3ICE9PSB1bmRlZmluZWQgKSBvYmplY3QudmlldyA9IE9iamVjdC5hc3NpZ24oIHt9LCBkYXRhLnZpZXcgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdPcnRob2dyYXBoaWNDYW1lcmEnOlxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdCA9IG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoIGRhdGEubGVmdCwgZGF0YS5yaWdodCwgZGF0YS50b3AsIGRhdGEuYm90dG9tLCBkYXRhLm5lYXIsIGRhdGEuZmFyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnQW1iaWVudExpZ2h0JzpcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRvYmplY3QgPSBuZXcgQW1iaWVudExpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ0RpcmVjdGlvbmFsTGlnaHQnOlxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdCA9IG5ldyBEaXJlY3Rpb25hbExpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ1BvaW50TGlnaHQnOlxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdCA9IG5ldyBQb2ludExpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSwgZGF0YS5kaXN0YW5jZSwgZGF0YS5kZWNheSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ1JlY3RBcmVhTGlnaHQnOlxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdCA9IG5ldyBSZWN0QXJlYUxpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSwgZGF0YS53aWR0aCwgZGF0YS5oZWlnaHQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdTcG90TGlnaHQnOlxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdCA9IG5ldyBTcG90TGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLmRpc3RhbmNlLCBkYXRhLmFuZ2xlLCBkYXRhLnBlbnVtYnJhLCBkYXRhLmRlY2F5ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnSGVtaXNwaGVyZUxpZ2h0JzpcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRvYmplY3QgPSBuZXcgSGVtaXNwaGVyZUxpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmdyb3VuZENvbG9yLCBkYXRhLmludGVuc2l0eSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ1NraW5uZWRNZXNoJzpcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXIucGFyc2VPYmplY3QoKSBkb2VzIG5vdCBzdXBwb3J0IFNraW5uZWRNZXNoIHlldC4nICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnTWVzaCc6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGdlb21ldHJ5ID0gZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgbWF0ZXJpYWwgPSBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggZ2VvbWV0cnkuYm9uZXMgJiYgZ2VvbWV0cnkuYm9uZXMubGVuZ3RoID4gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRvYmplY3QgPSBuZXcgU2tpbm5lZE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0ID0gbmV3IE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdMT0QnOlxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdCA9IG5ldyBMT0QoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdMaW5lJzpcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRvYmplY3QgPSBuZXcgTGluZSggZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKSwgZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSwgZGF0YS5tb2RlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnTGluZUxvb3AnOlxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdCA9IG5ldyBMaW5lTG9vcCggZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKSwgZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ0xpbmVTZWdtZW50cyc6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0ID0gbmV3IExpbmVTZWdtZW50cyggZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKSwgZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ1BvaW50Q2xvdWQnOlxcclxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ1BvaW50cyc6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0ID0gbmV3IFBvaW50cyggZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKSwgZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ1Nwcml0ZSc6XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0ID0gbmV3IFNwcml0ZSggZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ0dyb3VwJzpcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRvYmplY3QgPSBuZXcgR3JvdXAoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRkZWZhdWx0OlxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdCA9IG5ldyBPYmplY3QzRCgpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRvYmplY3QudXVpZCA9IGRhdGEudXVpZDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0Lm5hbWUgPSBkYXRhLm5hbWU7XFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBkYXRhLm1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdG1hdHJpeC5mcm9tQXJyYXkoIGRhdGEubWF0cml4ICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0bWF0cml4LmRlY29tcG9zZSggb2JqZWN0LnBvc2l0aW9uLCBvYmplY3QucXVhdGVybmlvbiwgb2JqZWN0LnNjYWxlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEucG9zaXRpb24gIT09IHVuZGVmaW5lZCApIG9iamVjdC5wb3NpdGlvbi5mcm9tQXJyYXkoIGRhdGEucG9zaXRpb24gKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEucm90YXRpb24gIT09IHVuZGVmaW5lZCApIG9iamVjdC5yb3RhdGlvbi5mcm9tQXJyYXkoIGRhdGEucm90YXRpb24gKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEucXVhdGVybmlvbiAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnF1YXRlcm5pb24uZnJvbUFycmF5KCBkYXRhLnF1YXRlcm5pb24gKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEuc2NhbGUgIT09IHVuZGVmaW5lZCApIG9iamVjdC5zY2FsZS5mcm9tQXJyYXkoIGRhdGEuc2NhbGUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBkYXRhLmNhc3RTaGFkb3cgIT09IHVuZGVmaW5lZCApIG9iamVjdC5jYXN0U2hhZG93ID0gZGF0YS5jYXN0U2hhZG93O1xcclxcblxcdFxcdFxcdFxcdGlmICggZGF0YS5yZWNlaXZlU2hhZG93ICE9PSB1bmRlZmluZWQgKSBvYmplY3QucmVjZWl2ZVNoYWRvdyA9IGRhdGEucmVjZWl2ZVNoYWRvdztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGRhdGEuc2hhZG93ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS5zaGFkb3cuYmlhcyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnNoYWRvdy5iaWFzID0gZGF0YS5zaGFkb3cuYmlhcztcXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEuc2hhZG93LnJhZGl1cyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnNoYWRvdy5yYWRpdXMgPSBkYXRhLnNoYWRvdy5yYWRpdXM7XFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLnNoYWRvdy5tYXBTaXplICE9PSB1bmRlZmluZWQgKSBvYmplY3Quc2hhZG93Lm1hcFNpemUuZnJvbUFycmF5KCBkYXRhLnNoYWRvdy5tYXBTaXplICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLnNoYWRvdy5jYW1lcmEgIT09IHVuZGVmaW5lZCApIG9iamVjdC5zaGFkb3cuY2FtZXJhID0gdGhpcy5wYXJzZU9iamVjdCggZGF0YS5zaGFkb3cuY2FtZXJhICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggZGF0YS52aXNpYmxlICE9PSB1bmRlZmluZWQgKSBvYmplY3QudmlzaWJsZSA9IGRhdGEudmlzaWJsZTtcXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGRhdGEudXNlckRhdGEgIT09IHVuZGVmaW5lZCApIG9iamVjdC51c2VyRGF0YSA9IGRhdGEudXNlckRhdGE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBkYXRhLmNoaWxkcmVuICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGNoaWxkcmVuID0gZGF0YS5jaGlsZHJlbjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0LmFkZCggdGhpcy5wYXJzZU9iamVjdCggY2hpbGRyZW5bIGkgXSwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggZGF0YS50eXBlID09PSAnTE9EJyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgbGV2ZWxzID0gZGF0YS5sZXZlbHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGwgPSAwOyBsIDwgbGV2ZWxzLmxlbmd0aDsgbCArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgbGV2ZWwgPSBsZXZlbHNbIGwgXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgY2hpbGQgPSBvYmplY3QuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ3V1aWQnLCBsZXZlbC5vYmplY3QgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGNoaWxkICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0LmFkZExldmVsKCBjaGlsZCwgbGV2ZWwuZGlzdGFuY2UgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gb2JqZWN0O1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpXFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdHZhciBURVhUVVJFX01BUFBJTkcgPSB7XFxyXFxuXFx0XFx0VVZNYXBwaW5nOiBVVk1hcHBpbmcsXFxyXFxuXFx0XFx0Q3ViZVJlZmxlY3Rpb25NYXBwaW5nOiBDdWJlUmVmbGVjdGlvbk1hcHBpbmcsXFxyXFxuXFx0XFx0Q3ViZVJlZnJhY3Rpb25NYXBwaW5nOiBDdWJlUmVmcmFjdGlvbk1hcHBpbmcsXFxyXFxuXFx0XFx0RXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmc6IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nLFxcclxcblxcdFxcdEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nOiBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZyxcXHJcXG5cXHRcXHRTcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZzogU3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmcsXFxyXFxuXFx0XFx0Q3ViZVVWUmVmbGVjdGlvbk1hcHBpbmc6IEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nLFxcclxcblxcdFxcdEN1YmVVVlJlZnJhY3Rpb25NYXBwaW5nOiBDdWJlVVZSZWZyYWN0aW9uTWFwcGluZ1xcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0dmFyIFRFWFRVUkVfV1JBUFBJTkcgPSB7XFxyXFxuXFx0XFx0UmVwZWF0V3JhcHBpbmc6IFJlcGVhdFdyYXBwaW5nLFxcclxcblxcdFxcdENsYW1wVG9FZGdlV3JhcHBpbmc6IENsYW1wVG9FZGdlV3JhcHBpbmcsXFxyXFxuXFx0XFx0TWlycm9yZWRSZXBlYXRXcmFwcGluZzogTWlycm9yZWRSZXBlYXRXcmFwcGluZ1xcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0dmFyIFRFWFRVUkVfRklMVEVSID0ge1xcclxcblxcdFxcdE5lYXJlc3RGaWx0ZXI6IE5lYXJlc3RGaWx0ZXIsXFxyXFxuXFx0XFx0TmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXI6IE5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyLFxcclxcblxcdFxcdE5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXI6IE5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIsXFxyXFxuXFx0XFx0TGluZWFyRmlsdGVyOiBMaW5lYXJGaWx0ZXIsXFxyXFxuXFx0XFx0TGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlcjogTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlcixcXHJcXG5cXHRcXHRMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI6IExpbmVhck1pcE1hcExpbmVhckZpbHRlclxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciB0aGVzcGl0ZSAvIGh0dHA6Ly9jbGlja3RvcmVsZWFzZS5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gSW1hZ2VCaXRtYXBMb2FkZXIoIG1hbmFnZXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCB0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXAgPT09ICd1bmRlZmluZWQnICkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkltYWdlQml0bWFwTG9hZGVyOiBjcmVhdGVJbWFnZUJpdG1hcCgpIG5vdCBzdXBwb3J0ZWQuJyApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRpZiAoIHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW1hZ2VCaXRtYXBMb2FkZXI6IGZldGNoKCkgbm90IHN1cHBvcnRlZC4nICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHRoaXMubWFuYWdlciA9IG1hbmFnZXIgIT09IHVuZGVmaW5lZCA/IG1hbmFnZXIgOiBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XFxyXFxuXFx0XFx0dGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRJbWFnZUJpdG1hcExvYWRlci5wcm90b3R5cGUgPSB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc3RydWN0b3I6IEltYWdlQml0bWFwTG9hZGVyLFxcclxcblxcclxcblxcdFxcdHNldE9wdGlvbnM6IGZ1bmN0aW9uIHNldE9wdGlvbnMoIG9wdGlvbnMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGxvYWQ6IGZ1bmN0aW9uIGxvYWQoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdXJsID09PSB1bmRlZmluZWQgKSB1cmwgPSAnJztcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMucGF0aCAhPT0gdW5kZWZpbmVkICkgdXJsID0gdGhpcy5wYXRoICsgdXJsO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBzY29wZSA9IHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGNhY2hlZCA9IENhY2hlLmdldCggdXJsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBjYWNoZWQgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0c2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggb25Mb2FkICkgb25Mb2FkKCBjYWNoZWQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0sIDAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gY2FjaGVkO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRmZXRjaCggdXJsICkudGhlbiggZnVuY3Rpb24gKCByZXMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJlcy5ibG9iKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSApLnRoZW4oIGZ1bmN0aW9uICggYmxvYiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gY3JlYXRlSW1hZ2VCaXRtYXAoIGJsb2IsIHNjb3BlLm9wdGlvbnMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9ICkudGhlbiggZnVuY3Rpb24gKCBpbWFnZUJpdG1hcCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRDYWNoZS5hZGQoIHVybCwgaW1hZ2VCaXRtYXAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIG9uTG9hZCApIG9uTG9hZCggaW1hZ2VCaXRtYXAgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xcclxcblxcclxcblxcdFxcdFxcdH0gKS5jYXRjaCggZnVuY3Rpb24gKCBlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggb25FcnJvciApIG9uRXJyb3IoIGUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xcclxcblxcdFxcdFxcdFxcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9ICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCAvKiB2YWx1ZSAqLyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldFBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5wYXRoID0gdmFsdWU7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xcclxcblxcdCAqIG1pbmltYWwgY2xhc3MgZm9yIHByb3hpbmcgZnVuY3Rpb25zIHRvIFBhdGguIFJlcGxhY2VzIG9sZCBcXFwiZXh0cmFjdFN1YnBhdGhzKClcXFwiXFxyXFxuXFx0ICoqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIFNoYXBlUGF0aCgpIHtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnU2hhcGVQYXRoJztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnN1YlBhdGhzID0gW107XFxyXFxuXFx0XFx0dGhpcy5jdXJyZW50UGF0aCA9IG51bGw7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIFNoYXBlUGF0aC5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHRtb3ZlVG86IGZ1bmN0aW9uICggeCwgeSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmN1cnJlbnRQYXRoID0gbmV3IFBhdGgoKTtcXHJcXG5cXHRcXHRcXHR0aGlzLnN1YlBhdGhzLnB1c2goIHRoaXMuY3VycmVudFBhdGggKTtcXHJcXG5cXHRcXHRcXHR0aGlzLmN1cnJlbnRQYXRoLm1vdmVUbyggeCwgeSApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0bGluZVRvOiBmdW5jdGlvbiAoIHgsIHkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5jdXJyZW50UGF0aC5saW5lVG8oIHgsIHkgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uICggYUNQeCwgYUNQeSwgYVgsIGFZICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuY3VycmVudFBhdGgucXVhZHJhdGljQ3VydmVUbyggYUNQeCwgYUNQeSwgYVgsIGFZICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRiZXppZXJDdXJ2ZVRvOiBmdW5jdGlvbiAoIGFDUDF4LCBhQ1AxeSwgYUNQMngsIGFDUDJ5LCBhWCwgYVkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5jdXJyZW50UGF0aC5iZXppZXJDdXJ2ZVRvKCBhQ1AxeCwgYUNQMXksIGFDUDJ4LCBhQ1AyeSwgYVgsIGFZICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzcGxpbmVUaHJ1OiBmdW5jdGlvbiAoIHB0cyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmN1cnJlbnRQYXRoLnNwbGluZVRocnUoIHB0cyApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0dG9TaGFwZXM6IGZ1bmN0aW9uICggaXNDQ1csIG5vSG9sZXMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZnVuY3Rpb24gdG9TaGFwZXNOb0hvbGVzKCBpblN1YnBhdGhzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBzaGFwZXMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpblN1YnBhdGhzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHRtcFBhdGggPSBpblN1YnBhdGhzWyBpIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHRtcFNoYXBlID0gbmV3IFNoYXBlKCk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dG1wU2hhcGUuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0c2hhcGVzLnB1c2goIHRtcFNoYXBlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiBzaGFwZXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGZ1bmN0aW9uIGlzUG9pbnRJbnNpZGVQb2x5Z29uKCBpblB0LCBpblBvbHlnb24gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHBvbHlMZW4gPSBpblBvbHlnb24ubGVuZ3RoO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGluUHQgb24gcG9seWdvbiBjb250b3VyID0+IGltbWVkaWF0ZSBzdWNjZXNzICAgIG9yXFxyXFxuXFx0XFx0XFx0XFx0Ly8gdG9nZ2xpbmcgb2YgaW5zaWRlL291dHNpZGUgYXQgZXZlcnkgc2luZ2xlISBpbnRlcnNlY3Rpb24gcG9pbnQgb2YgYW4gZWRnZVxcclxcblxcdFxcdFxcdFxcdC8vICB3aXRoIHRoZSBob3Jpem9udGFsIGxpbmUgdGhyb3VnaCBpblB0LCBsZWZ0IG9mIGluUHRcXHJcXG5cXHRcXHRcXHRcXHQvLyAgbm90IGNvdW50aW5nIGxvd2VyWSBlbmRwb2ludHMgb2YgZWRnZXMgYW5kIHdob2xlIGVkZ2VzIG9uIHRoYXQgbGluZVxcclxcblxcdFxcdFxcdFxcdHZhciBpbnNpZGUgPSBmYWxzZTtcXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgcCA9IHBvbHlMZW4gLSAxLCBxID0gMDsgcSA8IHBvbHlMZW47IHAgPSBxICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBlZGdlTG93UHQgPSBpblBvbHlnb25bIHAgXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgZWRnZUhpZ2hQdCA9IGluUG9seWdvblsgcSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBlZGdlRHggPSBlZGdlSGlnaFB0LnggLSBlZGdlTG93UHQueDtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgZWRnZUR5ID0gZWRnZUhpZ2hQdC55IC0gZWRnZUxvd1B0Lnk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBNYXRoLmFicyggZWRnZUR5ICkgPiBOdW1iZXIuRVBTSUxPTiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBub3QgcGFyYWxsZWxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGVkZ2VEeSA8IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZWRnZUxvd1B0ID0gaW5Qb2x5Z29uWyBxIF07IGVkZ2VEeCA9IC0gZWRnZUR4O1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGVkZ2VIaWdoUHQgPSBpblBvbHlnb25bIHAgXTsgZWRnZUR5ID0gLSBlZGdlRHk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggKCBpblB0LnkgPCBlZGdlTG93UHQueSApIHx8ICggaW5QdC55ID4gZWRnZUhpZ2hQdC55ICkgKSBcXHRcXHRjb250aW51ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGluUHQueSA9PT0gZWRnZUxvd1B0LnkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBpblB0LnggPT09IGVkZ2VMb3dQdC54IClcXHRcXHRyZXR1cm5cXHR0cnVlO1xcdFxcdC8vIGluUHQgaXMgb24gY29udG91ciA/XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gY29udGludWU7XFx0XFx0XFx0XFx0Ly8gbm8gaW50ZXJzZWN0aW9uIG9yIGVkZ2VMb3dQdCA9PiBkb2Vzbid0IGNvdW50ICEhIVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIHBlcnBFZGdlID0gZWRnZUR5ICogKCBpblB0LnggLSBlZGdlTG93UHQueCApIC0gZWRnZUR4ICogKCBpblB0LnkgLSBlZGdlTG93UHQueSApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggcGVycEVkZ2UgPT09IDAgKVxcdFxcdFxcdFxcdHJldHVyblxcdHRydWU7XFx0XFx0Ly8gaW5QdCBpcyBvbiBjb250b3VyID9cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHBlcnBFZGdlIDwgMCApIFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGluc2lkZSA9ICEgaW5zaWRlO1xcdFxcdC8vIHRydWUgaW50ZXJzZWN0aW9uIGxlZnQgb2YgaW5QdFxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHBhcmFsbGVsIG9yIGNvbGxpbmVhclxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggaW5QdC55ICE9PSBlZGdlTG93UHQueSApIFxcdFxcdGNvbnRpbnVlO1xcdFxcdFxcdC8vIHBhcmFsbGVsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gZWRnZSBsaWVzIG9uIHRoZSBzYW1lIGhvcml6b250YWwgbGluZSBhcyBpblB0XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCAoICggZWRnZUhpZ2hQdC54IDw9IGluUHQueCApICYmICggaW5QdC54IDw9IGVkZ2VMb3dQdC54ICkgKSB8fFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCAoICggZWRnZUxvd1B0LnggPD0gaW5QdC54ICkgJiYgKCBpblB0LnggPD0gZWRnZUhpZ2hQdC54ICkgKSApXFx0XFx0cmV0dXJuXFx0dHJ1ZTtcXHQvLyBpblB0OiBQb2ludCBvbiBjb250b3VyICFcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBjb250aW51ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVyblxcdGluc2lkZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGlzQ2xvY2tXaXNlID0gU2hhcGVVdGlscy5pc0Nsb2NrV2lzZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgc3ViUGF0aHMgPSB0aGlzLnN1YlBhdGhzO1xcclxcblxcdFxcdFxcdGlmICggc3ViUGF0aHMubGVuZ3RoID09PSAwICkgcmV0dXJuIFtdO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggbm9Ib2xlcyA9PT0gdHJ1ZSApXFx0cmV0dXJuXFx0dG9TaGFwZXNOb0hvbGVzKCBzdWJQYXRocyApO1xcclxcblxcclxcblxcclxcblxcdFxcdFxcdHZhciBzb2xpZCwgdG1wUGF0aCwgdG1wU2hhcGUsIHNoYXBlcyA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggc3ViUGF0aHMubGVuZ3RoID09PSAxICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRtcFBhdGggPSBzdWJQYXRoc1sgMCBdO1xcclxcblxcdFxcdFxcdFxcdHRtcFNoYXBlID0gbmV3IFNoYXBlKCk7XFxyXFxuXFx0XFx0XFx0XFx0dG1wU2hhcGUuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XFxyXFxuXFx0XFx0XFx0XFx0c2hhcGVzLnB1c2goIHRtcFNoYXBlICk7XFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHNoYXBlcztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGhvbGVzRmlyc3QgPSAhIGlzQ2xvY2tXaXNlKCBzdWJQYXRoc1sgMCBdLmdldFBvaW50cygpICk7XFxyXFxuXFx0XFx0XFx0aG9sZXNGaXJzdCA9IGlzQ0NXID8gISBob2xlc0ZpcnN0IDogaG9sZXNGaXJzdDtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBjb25zb2xlLmxvZyhcXFwiSG9sZXMgZmlyc3RcXFwiLCBob2xlc0ZpcnN0KTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgYmV0dGVyU2hhcGVIb2xlcyA9IFtdO1xcclxcblxcdFxcdFxcdHZhciBuZXdTaGFwZXMgPSBbXTtcXHJcXG5cXHRcXHRcXHR2YXIgbmV3U2hhcGVIb2xlcyA9IFtdO1xcclxcblxcdFxcdFxcdHZhciBtYWluSWR4ID0gMDtcXHJcXG5cXHRcXHRcXHR2YXIgdG1wUG9pbnRzO1xcclxcblxcclxcblxcdFxcdFxcdG5ld1NoYXBlc1sgbWFpbklkeCBdID0gdW5kZWZpbmVkO1xcclxcblxcdFxcdFxcdG5ld1NoYXBlSG9sZXNbIG1haW5JZHggXSA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHN1YlBhdGhzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dG1wUGF0aCA9IHN1YlBhdGhzWyBpIF07XFxyXFxuXFx0XFx0XFx0XFx0dG1wUG9pbnRzID0gdG1wUGF0aC5nZXRQb2ludHMoKTtcXHJcXG5cXHRcXHRcXHRcXHRzb2xpZCA9IGlzQ2xvY2tXaXNlKCB0bXBQb2ludHMgKTtcXHJcXG5cXHRcXHRcXHRcXHRzb2xpZCA9IGlzQ0NXID8gISBzb2xpZCA6IHNvbGlkO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggc29saWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAoICEgaG9sZXNGaXJzdCApICYmICggbmV3U2hhcGVzWyBtYWluSWR4IF0gKSApXFx0bWFpbklkeCArKztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRuZXdTaGFwZXNbIG1haW5JZHggXSA9IHsgczogbmV3IFNoYXBlKCksIHA6IHRtcFBvaW50cyB9O1xcclxcblxcdFxcdFxcdFxcdFxcdG5ld1NoYXBlc1sgbWFpbklkeCBdLnMuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBob2xlc0ZpcnN0IClcXHRtYWluSWR4ICsrO1xcclxcblxcdFxcdFxcdFxcdFxcdG5ld1NoYXBlSG9sZXNbIG1haW5JZHggXSA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vY29uc29sZS5sb2coJ2N3JywgaSk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRuZXdTaGFwZUhvbGVzWyBtYWluSWR4IF0ucHVzaCggeyBoOiB0bXBQYXRoLCBwOiB0bXBQb2ludHNbIDAgXSB9ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly9jb25zb2xlLmxvZygnY2N3JywgaSk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBvbmx5IEhvbGVzPyAtPiBwcm9iYWJseSBhbGwgU2hhcGVzIHdpdGggd3Jvbmcgb3JpZW50YXRpb25cXHJcXG5cXHRcXHRcXHRpZiAoICEgbmV3U2hhcGVzWyAwIF0gKVxcdHJldHVyblxcdHRvU2hhcGVzTm9Ib2xlcyggc3ViUGF0aHMgKTtcXHJcXG5cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIG5ld1NoYXBlcy5sZW5ndGggPiAxICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBhbWJpZ3VvdXMgPSBmYWxzZTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgdG9DaGFuZ2UgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgc0lkeCA9IDAsIHNMZW4gPSBuZXdTaGFwZXMubGVuZ3RoOyBzSWR4IDwgc0xlbjsgc0lkeCArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRiZXR0ZXJTaGFwZUhvbGVzWyBzSWR4IF0gPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIHNJZHggPSAwLCBzTGVuID0gbmV3U2hhcGVzLmxlbmd0aDsgc0lkeCA8IHNMZW47IHNJZHggKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHNobyA9IG5ld1NoYXBlSG9sZXNbIHNJZHggXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaElkeCA9IDA7IGhJZHggPCBzaG8ubGVuZ3RoOyBoSWR4ICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBobyA9IHNob1sgaElkeCBdO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBob2xlX3VuYXNzaWduZWQgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBzMklkeCA9IDA7IHMySWR4IDwgbmV3U2hhcGVzLmxlbmd0aDsgczJJZHggKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBpc1BvaW50SW5zaWRlUG9seWdvbiggaG8ucCwgbmV3U2hhcGVzWyBzMklkeCBdLnAgKSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHNJZHggIT09IHMySWR4IClcXHR0b0NoYW5nZS5wdXNoKCB7IGZyb21zOiBzSWR4LCB0b3M6IHMySWR4LCBob2xlOiBoSWR4IH0gKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGhvbGVfdW5hc3NpZ25lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRob2xlX3VuYXNzaWduZWQgPSBmYWxzZTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRiZXR0ZXJTaGFwZUhvbGVzWyBzMklkeCBdLnB1c2goIGhvICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRhbWJpZ3VvdXMgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggaG9sZV91bmFzc2lnbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJldHRlclNoYXBlSG9sZXNbIHNJZHggXS5wdXNoKCBobyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcdFxcdFxcdFxcdC8vIGNvbnNvbGUubG9nKFxcXCJhbWJpZ3VvdXM6IFxcXCIsIGFtYmlndW91cyk7XFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB0b0NoYW5nZS5sZW5ndGggPiAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIGNvbnNvbGUubG9nKFxcXCJ0byBjaGFuZ2U6IFxcXCIsIHRvQ2hhbmdlKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoICEgYW1iaWd1b3VzIClcXHRuZXdTaGFwZUhvbGVzID0gYmV0dGVyU2hhcGVIb2xlcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHZhciB0bXBIb2xlcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbmV3U2hhcGVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRtcFNoYXBlID0gbmV3U2hhcGVzWyBpIF0ucztcXHJcXG5cXHRcXHRcXHRcXHRzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcXHJcXG5cXHRcXHRcXHRcXHR0bXBIb2xlcyA9IG5ld1NoYXBlSG9sZXNbIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gdG1wSG9sZXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dG1wU2hhcGUuaG9sZXMucHVzaCggdG1wSG9sZXNbIGogXS5oICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvL2NvbnNvbGUubG9nKFxcXCJzaGFwZVxcXCIsIHNoYXBlcyk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHNoYXBlcztcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIEZvbnQoIGRhdGEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50eXBlID0gJ0ZvbnQnO1xcclxcblxcclxcblxcdFxcdHRoaXMuZGF0YSA9IGRhdGE7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIEZvbnQucHJvdG90eXBlLCB7XFxyXFxuXFxyXFxuXFx0XFx0aXNGb250OiB0cnVlLFxcclxcblxcclxcblxcdFxcdGdlbmVyYXRlU2hhcGVzOiBmdW5jdGlvbiAoIHRleHQsIHNpemUsIGRpdmlzaW9ucyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmdW5jdGlvbiBjcmVhdGVQYXRocyggdGV4dCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgY2hhcnMgPSBTdHJpbmcoIHRleHQgKS5zcGxpdCggJycgKTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgc2NhbGUgPSBzaXplIC8gZGF0YS5yZXNvbHV0aW9uO1xcclxcblxcdFxcdFxcdFxcdHZhciBsaW5lX2hlaWdodCA9ICggZGF0YS5ib3VuZGluZ0JveC55TWF4IC0gZGF0YS5ib3VuZGluZ0JveC55TWluICsgZGF0YS51bmRlcmxpbmVUaGlja25lc3MgKSAqIHNjYWxlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBvZmZzZXRYID0gMCwgb2Zmc2V0WSA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHBhdGhzID0gW107XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBjaGFyID0gY2hhcnNbIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGNoYXIgPT09ICdcXFxcbicgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0b2Zmc2V0WCA9IDA7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0b2Zmc2V0WSAtPSBsaW5lX2hlaWdodDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciByZXQgPSBjcmVhdGVQYXRoKCBjaGFyLCBzY2FsZSwgb2Zmc2V0WCwgb2Zmc2V0WSApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdG9mZnNldFggKz0gcmV0Lm9mZnNldFg7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0cGF0aHMucHVzaCggcmV0LnBhdGggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiBwYXRocztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZnVuY3Rpb24gY3JlYXRlUGF0aCggYywgc2NhbGUsIG9mZnNldFgsIG9mZnNldFkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGdseXBoID0gZGF0YS5nbHlwaHNbIGMgXSB8fCBkYXRhLmdseXBoc1sgJz8nIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCAhIGdseXBoICkgcmV0dXJuO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBwYXRoID0gbmV3IFNoYXBlUGF0aCgpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBwdHMgPSBbXTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgeCwgeSwgY3B4LCBjcHksIGNweDAsIGNweTAsIGNweDEsIGNweTEsIGNweDIsIGNweTIsIGxhc3RlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggZ2x5cGgubyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgb3V0bGluZSA9IGdseXBoLl9jYWNoZWRPdXRsaW5lIHx8ICggZ2x5cGguX2NhY2hlZE91dGxpbmUgPSBnbHlwaC5vLnNwbGl0KCAnICcgKSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IG91dGxpbmUubGVuZ3RoOyBpIDwgbDsgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGFjdGlvbiA9IG91dGxpbmVbIGkgKysgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRzd2l0Y2ggKCBhY3Rpb24gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbSc6IC8vIG1vdmVUb1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHggPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldFg7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0eSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0WTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwYXRoLm1vdmVUbyggeCwgeSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ2wnOiAvLyBsaW5lVG9cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR4ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRYO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHkgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldFk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cGF0aC5saW5lVG8oIHgsIHkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdxJzogLy8gcXVhZHJhdGljQ3VydmVUb1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNweCA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0WDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjcHkgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldFk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y3B4MSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0WDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjcHkxID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRZO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHBhdGgucXVhZHJhdGljQ3VydmVUbyggY3B4MSwgY3B5MSwgY3B4LCBjcHkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRsYXN0ZSA9IHB0c1sgcHRzLmxlbmd0aCAtIDEgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGxhc3RlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNweDAgPSBsYXN0ZS54O1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNweTAgPSBsYXN0ZS55O1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdiJzogLy8gYmV6aWVyQ3VydmVUb1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNweCA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0WDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjcHkgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldFk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y3B4MSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0WDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjcHkxID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRZO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNweDIgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldFg7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y3B5MiA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0WTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwYXRoLmJlemllckN1cnZlVG8oIGNweDEsIGNweTEsIGNweDIsIGNweTIsIGNweCwgY3B5ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bGFzdGUgPSBwdHNbIHB0cy5sZW5ndGggLSAxIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBsYXN0ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjcHgwID0gbGFzdGUueDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjcHkwID0gbGFzdGUueTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHsgb2Zmc2V0WDogZ2x5cGguaGEgKiBzY2FsZSwgcGF0aDogcGF0aCB9O1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvL1xcclxcblxcclxcblxcdFxcdFxcdGlmICggc2l6ZSA9PT0gdW5kZWZpbmVkICkgc2l6ZSA9IDEwMDtcXHJcXG5cXHRcXHRcXHRpZiAoIGRpdmlzaW9ucyA9PT0gdW5kZWZpbmVkICkgZGl2aXNpb25zID0gNDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgZGF0YSA9IHRoaXMuZGF0YTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcGF0aHMgPSBjcmVhdGVQYXRocyggdGV4dCApO1xcclxcblxcdFxcdFxcdHZhciBzaGFwZXMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgcCA9IDAsIHBsID0gcGF0aHMubGVuZ3RoOyBwIDwgcGw7IHAgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoIHNoYXBlcywgcGF0aHNbIHAgXS50b1NoYXBlcygpICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBzaGFwZXM7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIEZvbnRMb2FkZXIoIG1hbmFnZXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIEZvbnRMb2FkZXIucHJvdG90eXBlLCB7XFxyXFxuXFxyXFxuXFx0XFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgc2NvcGUgPSB0aGlzO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XFxyXFxuXFx0XFx0XFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xcclxcblxcdFxcdFxcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIganNvbjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0cnkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGpzb24gPSBKU09OLnBhcnNlKCB0ZXh0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSBjYXRjaCAoIGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRm9udExvYWRlcjogdHlwZWZhY2UuanMgc3VwcG9ydCBpcyBiZWluZyBkZXByZWNhdGVkLiBVc2UgdHlwZWZhY2UuanNvbiBpbnN0ZWFkLicgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRqc29uID0gSlNPTi5wYXJzZSggdGV4dC5zdWJzdHJpbmcoIDY1LCB0ZXh0Lmxlbmd0aCAtIDIgKSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgZm9udCA9IHNjb3BlLnBhcnNlKCBqc29uICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIGZvbnQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRwYXJzZTogZnVuY3Rpb24gKCBqc29uICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBuZXcgRm9udCgganNvbiApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0UGF0aDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnBhdGggPSB2YWx1ZTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0dmFyIGNvbnRleHQ7XFxyXFxuXFxyXFxuXFx0dmFyIEF1ZGlvQ29udGV4dCA9IHtcXHJcXG5cXHJcXG5cXHRcXHRnZXRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBjb250ZXh0ID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29udGV4dCA9IG5ldyAoIHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCApKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBjb250ZXh0O1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0Q29udGV4dDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb250ZXh0ID0gdmFsdWU7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBSZWVjZSBBYXJvbiBMZWNyaXZhaW4gLyBodHRwOi8vcmVlY2Vub3Rlcy5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gQXVkaW9Mb2FkZXIoIG1hbmFnZXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIEF1ZGlvTG9hZGVyLnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcXHJcXG5cXHRcXHRcXHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XFxyXFxuXFx0XFx0XFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGNvbnRleHQgPSBBdWRpb0NvbnRleHQuZ2V0Q29udGV4dCgpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnRleHQuZGVjb2RlQXVkaW9EYXRhKCBidWZmZXIsIGZ1bmN0aW9uICggYXVkaW9CdWZmZXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0b25Mb2FkKCBhdWRpb0J1ZmZlciApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIFN0ZXJlb0NhbWVyYSgpIHtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnU3RlcmVvQ2FtZXJhJztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmFzcGVjdCA9IDE7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5leWVTZXAgPSAwLjA2NDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmNhbWVyYUwgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKTtcXHJcXG5cXHRcXHR0aGlzLmNhbWVyYUwubGF5ZXJzLmVuYWJsZSggMSApO1xcclxcblxcdFxcdHRoaXMuY2FtZXJhTC5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5jYW1lcmFSID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCk7XFxyXFxuXFx0XFx0dGhpcy5jYW1lcmFSLmxheWVycy5lbmFibGUoIDIgKTtcXHJcXG5cXHRcXHR0aGlzLmNhbWVyYVIubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRPYmplY3QuYXNzaWduKCBTdGVyZW9DYW1lcmEucHJvdG90eXBlLCB7XFxyXFxuXFxyXFxuXFx0XFx0dXBkYXRlOiAoIGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgaW5zdGFuY2UsIGZvY3VzLCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyLCB6b29tLCBleWVTZXA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGV5ZVJpZ2h0ID0gbmV3IE1hdHJpeDQoKTtcXHJcXG5cXHRcXHRcXHR2YXIgZXllTGVmdCA9IG5ldyBNYXRyaXg0KCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSggY2FtZXJhICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBuZWVkc1VwZGF0ZSA9IGluc3RhbmNlICE9PSB0aGlzIHx8IGZvY3VzICE9PSBjYW1lcmEuZm9jdXMgfHwgZm92ICE9PSBjYW1lcmEuZm92IHx8XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YXNwZWN0ICE9PSBjYW1lcmEuYXNwZWN0ICogdGhpcy5hc3BlY3QgfHwgbmVhciAhPT0gY2FtZXJhLm5lYXIgfHxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRmYXIgIT09IGNhbWVyYS5mYXIgfHwgem9vbSAhPT0gY2FtZXJhLnpvb20gfHwgZXllU2VwICE9PSB0aGlzLmV5ZVNlcDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIG5lZWRzVXBkYXRlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGluc3RhbmNlID0gdGhpcztcXHJcXG5cXHRcXHRcXHRcXHRcXHRmb2N1cyA9IGNhbWVyYS5mb2N1cztcXHJcXG5cXHRcXHRcXHRcXHRcXHRmb3YgPSBjYW1lcmEuZm92O1xcclxcblxcdFxcdFxcdFxcdFxcdGFzcGVjdCA9IGNhbWVyYS5hc3BlY3QgKiB0aGlzLmFzcGVjdDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRuZWFyID0gY2FtZXJhLm5lYXI7XFxyXFxuXFx0XFx0XFx0XFx0XFx0ZmFyID0gY2FtZXJhLmZhcjtcXHJcXG5cXHRcXHRcXHRcXHRcXHR6b29tID0gY2FtZXJhLnpvb207XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gT2ZmLWF4aXMgc3RlcmVvc2NvcGljIGVmZmVjdCBiYXNlZCBvblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIGh0dHA6Ly9wYXVsYm91cmtlLm5ldC9zdGVyZW9ncmFwaGljcy9zdGVyZW9yZW5kZXIvXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHByb2plY3Rpb25NYXRyaXggPSBjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5jbG9uZSgpO1xcclxcblxcdFxcdFxcdFxcdFxcdGV5ZVNlcCA9IHRoaXMuZXllU2VwIC8gMjtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgZXllU2VwT25Qcm9qZWN0aW9uID0gZXllU2VwICogbmVhciAvIGZvY3VzO1xcclxcblxcdFxcdFxcdFxcdFxcdHZhciB5bWF4ID0gKCBuZWFyICogTWF0aC50YW4oIF9NYXRoLkRFRzJSQUQgKiBmb3YgKiAwLjUgKSApIC8gem9vbTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgeG1pbiwgeG1heDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyB0cmFuc2xhdGUgeE9mZnNldFxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGV5ZUxlZnQuZWxlbWVudHNbIDEyIF0gPSAtIGV5ZVNlcDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRleWVSaWdodC5lbGVtZW50c1sgMTIgXSA9IGV5ZVNlcDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBmb3IgbGVmdCBleWVcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR4bWluID0gLSB5bWF4ICogYXNwZWN0ICsgZXllU2VwT25Qcm9qZWN0aW9uO1xcclxcblxcdFxcdFxcdFxcdFxcdHhtYXggPSB5bWF4ICogYXNwZWN0ICsgZXllU2VwT25Qcm9qZWN0aW9uO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDAgXSA9IDIgKiBuZWFyIC8gKCB4bWF4IC0geG1pbiApO1xcclxcblxcdFxcdFxcdFxcdFxcdHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDggXSA9ICggeG1heCArIHhtaW4gKSAvICggeG1heCAtIHhtaW4gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmNhbWVyYUwucHJvamVjdGlvbk1hdHJpeC5jb3B5KCBwcm9qZWN0aW9uTWF0cml4ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gZm9yIHJpZ2h0IGV5ZVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHhtaW4gPSAtIHltYXggKiBhc3BlY3QgLSBleWVTZXBPblByb2plY3Rpb247XFxyXFxuXFx0XFx0XFx0XFx0XFx0eG1heCA9IHltYXggKiBhc3BlY3QgLSBleWVTZXBPblByb2plY3Rpb247XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgMCBdID0gMiAqIG5lYXIgLyAoIHhtYXggLSB4bWluICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0cHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgOCBdID0gKCB4bWF4ICsgeG1pbiApIC8gKCB4bWF4IC0geG1pbiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMuY2FtZXJhUi5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIHByb2plY3Rpb25NYXRyaXggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5jYW1lcmFMLm1hdHJpeFdvcmxkLmNvcHkoIGNhbWVyYS5tYXRyaXhXb3JsZCApLm11bHRpcGx5KCBleWVMZWZ0ICk7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5jYW1lcmFSLm1hdHJpeFdvcmxkLmNvcHkoIGNhbWVyYS5tYXRyaXhXb3JsZCApLm11bHRpcGx5KCBleWVSaWdodCApO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSApKClcXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQ2FtZXJhIGZvciByZW5kZXJpbmcgY3ViZSBtYXBzXFxyXFxuXFx0ICpcXHQtIHJlbmRlcnMgc2NlbmUgaW50byBheGlzLWFsaWduZWQgY3ViZVxcclxcblxcdCAqXFxyXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBDdWJlQ2FtZXJhKCBuZWFyLCBmYXIsIGN1YmVSZXNvbHV0aW9uICkge1xcclxcblxcclxcblxcdFxcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnQ3ViZUNhbWVyYSc7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGZvdiA9IDkwLCBhc3BlY3QgPSAxO1xcclxcblxcclxcblxcdFxcdHZhciBjYW1lcmFQWCA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xcclxcblxcdFxcdGNhbWVyYVBYLnVwLnNldCggMCwgLSAxLCAwICk7XFxyXFxuXFx0XFx0Y2FtZXJhUFgubG9va0F0KCBuZXcgVmVjdG9yMyggMSwgMCwgMCApICk7XFxyXFxuXFx0XFx0dGhpcy5hZGQoIGNhbWVyYVBYICk7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGNhbWVyYU5YID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XFxyXFxuXFx0XFx0Y2FtZXJhTlgudXAuc2V0KCAwLCAtIDEsIDAgKTtcXHJcXG5cXHRcXHRjYW1lcmFOWC5sb29rQXQoIG5ldyBWZWN0b3IzKCAtIDEsIDAsIDAgKSApO1xcclxcblxcdFxcdHRoaXMuYWRkKCBjYW1lcmFOWCApO1xcclxcblxcclxcblxcdFxcdHZhciBjYW1lcmFQWSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xcclxcblxcdFxcdGNhbWVyYVBZLnVwLnNldCggMCwgMCwgMSApO1xcclxcblxcdFxcdGNhbWVyYVBZLmxvb2tBdCggbmV3IFZlY3RvcjMoIDAsIDEsIDAgKSApO1xcclxcblxcdFxcdHRoaXMuYWRkKCBjYW1lcmFQWSApO1xcclxcblxcclxcblxcdFxcdHZhciBjYW1lcmFOWSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xcclxcblxcdFxcdGNhbWVyYU5ZLnVwLnNldCggMCwgMCwgLSAxICk7XFxyXFxuXFx0XFx0Y2FtZXJhTlkubG9va0F0KCBuZXcgVmVjdG9yMyggMCwgLSAxLCAwICkgKTtcXHJcXG5cXHRcXHR0aGlzLmFkZCggY2FtZXJhTlkgKTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgY2FtZXJhUFogPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcXHJcXG5cXHRcXHRjYW1lcmFQWi51cC5zZXQoIDAsIC0gMSwgMCApO1xcclxcblxcdFxcdGNhbWVyYVBaLmxvb2tBdCggbmV3IFZlY3RvcjMoIDAsIDAsIDEgKSApO1xcclxcblxcdFxcdHRoaXMuYWRkKCBjYW1lcmFQWiApO1xcclxcblxcclxcblxcdFxcdHZhciBjYW1lcmFOWiA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xcclxcblxcdFxcdGNhbWVyYU5aLnVwLnNldCggMCwgLSAxLCAwICk7XFxyXFxuXFx0XFx0Y2FtZXJhTloubG9va0F0KCBuZXcgVmVjdG9yMyggMCwgMCwgLSAxICkgKTtcXHJcXG5cXHRcXHR0aGlzLmFkZCggY2FtZXJhTlogKTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgb3B0aW9ucyA9IHsgZm9ybWF0OiBSR0JGb3JtYXQsIG1hZ0ZpbHRlcjogTGluZWFyRmlsdGVyLCBtaW5GaWx0ZXI6IExpbmVhckZpbHRlciB9O1xcclxcblxcclxcblxcdFxcdHRoaXMucmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZSggY3ViZVJlc29sdXRpb24sIGN1YmVSZXNvbHV0aW9uLCBvcHRpb25zICk7XFxyXFxuXFx0XFx0dGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS5uYW1lID0gXFxcIkN1YmVDYW1lcmFcXFwiO1xcclxcblxcclxcblxcdFxcdHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKCByZW5kZXJlciwgc2NlbmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLnBhcmVudCA9PT0gbnVsbCApIHRoaXMudXBkYXRlTWF0cml4V29ybGQoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJUYXJnZXQ7XFxyXFxuXFx0XFx0XFx0dmFyIGdlbmVyYXRlTWlwbWFwcyA9IHJlbmRlclRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAwO1xcclxcblxcdFxcdFxcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBYLCByZW5kZXJUYXJnZXQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAxO1xcclxcblxcdFxcdFxcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5YLCByZW5kZXJUYXJnZXQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAyO1xcclxcblxcdFxcdFxcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBZLCByZW5kZXJUYXJnZXQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAzO1xcclxcblxcdFxcdFxcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5ZLCByZW5kZXJUYXJnZXQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSA0O1xcclxcblxcdFxcdFxcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBaLCByZW5kZXJUYXJnZXQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBnZW5lcmF0ZU1pcG1hcHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gNTtcXHJcXG5cXHRcXHRcXHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWiwgcmVuZGVyVGFyZ2V0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBudWxsICk7XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmNsZWFyID0gZnVuY3Rpb24gKCByZW5kZXJlciwgY29sb3IsIGRlcHRoLCBzdGVuY2lsICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlclRhcmdldDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IGk7XFxyXFxuXFx0XFx0XFx0XFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZW5kZXJlci5jbGVhciggY29sb3IsIGRlcHRoLCBzdGVuY2lsICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggbnVsbCApO1xcclxcblxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdEN1YmVDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICk7XFxyXFxuXFx0Q3ViZUNhbWVyYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDdWJlQ2FtZXJhO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gQXVkaW9MaXN0ZW5lcigpIHtcXHJcXG5cXHJcXG5cXHRcXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50eXBlID0gJ0F1ZGlvTGlzdGVuZXInO1xcclxcblxcclxcblxcdFxcdHRoaXMuY29udGV4dCA9IEF1ZGlvQ29udGV4dC5nZXRDb250ZXh0KCk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5nYWluID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcXHJcXG5cXHRcXHR0aGlzLmdhaW4uY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5maWx0ZXIgPSBudWxsO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRBdWRpb0xpc3RlbmVyLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc3RydWN0b3I6IEF1ZGlvTGlzdGVuZXIsXFxyXFxuXFxyXFxuXFx0XFx0Z2V0SW5wdXQ6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5nYWluO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0cmVtb3ZlRmlsdGVyOiBmdW5jdGlvbiAoICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5maWx0ZXIgIT09IG51bGwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5nYWluLmRpc2Nvbm5lY3QoIHRoaXMuZmlsdGVyICk7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5maWx0ZXIuZGlzY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5nYWluLmNvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xcclxcblxcdFxcdFxcdFxcdHRoaXMuZmlsdGVyID0gbnVsbDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRnZXRGaWx0ZXI6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5maWx0ZXI7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRGaWx0ZXI6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmZpbHRlciAhPT0gbnVsbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmdhaW4uZGlzY29ubmVjdCggdGhpcy5maWx0ZXIgKTtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmZpbHRlci5kaXNjb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuZ2Fpbi5kaXNjb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5maWx0ZXIgPSB2YWx1ZTtcXHJcXG5cXHRcXHRcXHR0aGlzLmdhaW4uY29ubmVjdCggdGhpcy5maWx0ZXIgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLmZpbHRlci5jb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGdldE1hc3RlclZvbHVtZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmdhaW4uZ2Fpbi52YWx1ZTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldE1hc3RlclZvbHVtZTogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmdhaW4uZ2Fpbi52YWx1ZSA9IHZhbHVlO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0dXBkYXRlTWF0cml4V29ybGQ6ICggZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0XFx0dmFyIHF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xcclxcblxcdFxcdFxcdHZhciBzY2FsZSA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG9yaWVudGF0aW9uID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdE9iamVjdDNELnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKCB0aGlzLCBmb3JjZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBsaXN0ZW5lciA9IHRoaXMuY29udGV4dC5saXN0ZW5lcjtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgdXAgPSB0aGlzLnVwO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRvcmllbnRhdGlvbi5zZXQoIDAsIDAsIC0gMSApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggbGlzdGVuZXIucG9zaXRpb25YICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGxpc3RlbmVyLnBvc2l0aW9uWC5zZXRWYWx1ZUF0VGltZSggcG9zaXRpb24ueCwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0bGlzdGVuZXIucG9zaXRpb25ZLnNldFZhbHVlQXRUaW1lKCBwb3NpdGlvbi55LCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRsaXN0ZW5lci5wb3NpdGlvblouc2V0VmFsdWVBdFRpbWUoIHBvc2l0aW9uLnosIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSApO1xcclxcblxcdFxcdFxcdFxcdFxcdGxpc3RlbmVyLmZvcndhcmRYLnNldFZhbHVlQXRUaW1lKCBvcmllbnRhdGlvbi54LCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRsaXN0ZW5lci5mb3J3YXJkWS5zZXRWYWx1ZUF0VGltZSggb3JpZW50YXRpb24ueSwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0bGlzdGVuZXIuZm9yd2FyZFouc2V0VmFsdWVBdFRpbWUoIG9yaWVudGF0aW9uLnosIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSApO1xcclxcblxcdFxcdFxcdFxcdFxcdGxpc3RlbmVyLnVwWC5zZXRWYWx1ZUF0VGltZSggdXAueCwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0bGlzdGVuZXIudXBZLnNldFZhbHVlQXRUaW1lKCB1cC55LCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRsaXN0ZW5lci51cFouc2V0VmFsdWVBdFRpbWUoIHVwLnosIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0bGlzdGVuZXIuc2V0UG9zaXRpb24oIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnogKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRsaXN0ZW5lci5zZXRPcmllbnRhdGlvbiggb3JpZW50YXRpb24ueCwgb3JpZW50YXRpb24ueSwgb3JpZW50YXRpb24ueiwgdXAueCwgdXAueSwgdXAueiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0gKSgpXFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICogQGF1dGhvciBSZWVjZSBBYXJvbiBMZWNyaXZhaW4gLyBodHRwOi8vcmVlY2Vub3Rlcy5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gQXVkaW8oIGxpc3RlbmVyICkge1xcclxcblxcclxcblxcdFxcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnR5cGUgPSAnQXVkaW8nO1xcclxcblxcclxcblxcdFxcdHRoaXMuY29udGV4dCA9IGxpc3RlbmVyLmNvbnRleHQ7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5nYWluID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcXHJcXG5cXHRcXHR0aGlzLmdhaW4uY29ubmVjdCggbGlzdGVuZXIuZ2V0SW5wdXQoKSApO1xcclxcblxcclxcblxcdFxcdHRoaXMuYXV0b3BsYXkgPSBmYWxzZTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmJ1ZmZlciA9IG51bGw7XFxyXFxuXFx0XFx0dGhpcy5sb29wID0gZmFsc2U7XFxyXFxuXFx0XFx0dGhpcy5zdGFydFRpbWUgPSAwO1xcclxcblxcdFxcdHRoaXMub2Zmc2V0ID0gMDtcXHJcXG5cXHRcXHR0aGlzLnBsYXliYWNrUmF0ZSA9IDE7XFxyXFxuXFx0XFx0dGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcXHJcXG5cXHRcXHR0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9IHRydWU7XFxyXFxuXFx0XFx0dGhpcy5zb3VyY2VUeXBlID0gJ2VtcHR5JztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmZpbHRlcnMgPSBbXTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0QXVkaW8ucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICksIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zdHJ1Y3RvcjogQXVkaW8sXFxyXFxuXFxyXFxuXFx0XFx0Z2V0T3V0cHV0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2FpbjtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldE5vZGVTb3VyY2U6IGZ1bmN0aW9uICggYXVkaW9Ob2RlICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuaGFzUGxheWJhY2tDb250cm9sID0gZmFsc2U7XFxyXFxuXFx0XFx0XFx0dGhpcy5zb3VyY2VUeXBlID0gJ2F1ZGlvTm9kZSc7XFxyXFxuXFx0XFx0XFx0dGhpcy5zb3VyY2UgPSBhdWRpb05vZGU7XFxyXFxuXFx0XFx0XFx0dGhpcy5jb25uZWN0KCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRCdWZmZXI6IGZ1bmN0aW9uICggYXVkaW9CdWZmZXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5idWZmZXIgPSBhdWRpb0J1ZmZlcjtcXHJcXG5cXHRcXHRcXHR0aGlzLnNvdXJjZVR5cGUgPSAnYnVmZmVyJztcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMuYXV0b3BsYXkgKSB0aGlzLnBsYXkoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHBsYXk6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiBBdWRpbyBpcyBhbHJlYWR5IHBsYXlpbmcuJyApO1xcclxcblxcdFxcdFxcdFxcdHJldHVybjtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyApO1xcclxcblxcdFxcdFxcdFxcdHJldHVybjtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHNvdXJjZSA9IHRoaXMuY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRzb3VyY2UuYnVmZmVyID0gdGhpcy5idWZmZXI7XFxyXFxuXFx0XFx0XFx0c291cmNlLmxvb3AgPSB0aGlzLmxvb3A7XFxyXFxuXFx0XFx0XFx0c291cmNlLm9uZW5kZWQgPSB0aGlzLm9uRW5kZWQuYmluZCggdGhpcyApO1xcclxcblxcdFxcdFxcdHNvdXJjZS5wbGF5YmFja1JhdGUuc2V0VmFsdWVBdFRpbWUoIHRoaXMucGxheWJhY2tSYXRlLCB0aGlzLnN0YXJ0VGltZSApO1xcclxcblxcdFxcdFxcdHRoaXMuc3RhcnRUaW1lID0gdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lO1xcclxcblxcdFxcdFxcdHNvdXJjZS5zdGFydCggdGhpcy5zdGFydFRpbWUsIHRoaXMub2Zmc2V0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuc291cmNlID0gc291cmNlO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmNvbm5lY3QoKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHBhdXNlOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyApO1xcclxcblxcdFxcdFxcdFxcdHJldHVybjtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnNvdXJjZS5zdG9wKCk7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5vZmZzZXQgKz0gKCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgLSB0aGlzLnN0YXJ0VGltZSApICogdGhpcy5wbGF5YmFja1JhdGU7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzdG9wOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyApO1xcclxcblxcdFxcdFxcdFxcdHJldHVybjtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5zb3VyY2Uuc3RvcCgpO1xcclxcblxcdFxcdFxcdHRoaXMub2Zmc2V0ID0gMDtcXHJcXG5cXHRcXHRcXHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y29ubmVjdDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5maWx0ZXJzLmxlbmd0aCA+IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5zb3VyY2UuY29ubmVjdCggdGhpcy5maWx0ZXJzWyAwIF0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDEsIGwgPSB0aGlzLmZpbHRlcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmZpbHRlcnNbIGkgLSAxIF0uY29ubmVjdCggdGhpcy5maWx0ZXJzWyBpIF0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5maWx0ZXJzWyB0aGlzLmZpbHRlcnMubGVuZ3RoIC0gMSBdLmNvbm5lY3QoIHRoaXMuZ2V0T3V0cHV0KCkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuc291cmNlLmNvbm5lY3QoIHRoaXMuZ2V0T3V0cHV0KCkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRkaXNjb25uZWN0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmZpbHRlcnMubGVuZ3RoID4gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnNvdXJjZS5kaXNjb25uZWN0KCB0aGlzLmZpbHRlcnNbIDAgXSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMSwgbCA9IHRoaXMuZmlsdGVycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMuZmlsdGVyc1sgaSAtIDEgXS5kaXNjb25uZWN0KCB0aGlzLmZpbHRlcnNbIGkgXSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmZpbHRlcnNbIHRoaXMuZmlsdGVycy5sZW5ndGggLSAxIF0uZGlzY29ubmVjdCggdGhpcy5nZXRPdXRwdXQoKSApO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5zb3VyY2UuZGlzY29ubmVjdCggdGhpcy5nZXRPdXRwdXQoKSApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGdldEZpbHRlcnM6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5maWx0ZXJzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0RmlsdGVyczogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoICEgdmFsdWUgKSB2YWx1ZSA9IFtdO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5pc1BsYXlpbmcgPT09IHRydWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5kaXNjb25uZWN0KCk7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5maWx0ZXJzID0gdmFsdWU7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5jb25uZWN0KCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLmZpbHRlcnMgPSB2YWx1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRnZXRGaWx0ZXI6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5nZXRGaWx0ZXJzKClbIDAgXTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldEZpbHRlcjogZnVuY3Rpb24gKCBmaWx0ZXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuc2V0RmlsdGVycyggZmlsdGVyID8gWyBmaWx0ZXIgXSA6IFtdICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRQbGF5YmFja1JhdGU6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyApO1xcclxcblxcdFxcdFxcdFxcdHJldHVybjtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5wbGF5YmFja1JhdGUgPSB2YWx1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuc291cmNlLnBsYXliYWNrUmF0ZS5zZXRWYWx1ZUF0VGltZSggdGhpcy5wbGF5YmFja1JhdGUsIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGdldFBsYXliYWNrUmF0ZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLnBsYXliYWNrUmF0ZTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdG9uRW5kZWQ6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Z2V0TG9vcDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmxvb3A7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRMb29wOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHRoaXMubG9vcCA9IHZhbHVlO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5pc1BsYXlpbmcgPT09IHRydWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5zb3VyY2UubG9vcCA9IHRoaXMubG9vcDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRnZXRWb2x1bWU6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5nYWluLmdhaW4udmFsdWU7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRWb2x1bWU6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5nYWluLmdhaW4udmFsdWUgPSB2YWx1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gUG9zaXRpb25hbEF1ZGlvKCBsaXN0ZW5lciApIHtcXHJcXG5cXHJcXG5cXHRcXHRBdWRpby5jYWxsKCB0aGlzLCBsaXN0ZW5lciApO1xcclxcblxcclxcblxcdFxcdHRoaXMucGFubmVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZVBhbm5lcigpO1xcclxcblxcdFxcdHRoaXMucGFubmVyLmNvbm5lY3QoIHRoaXMuZ2FpbiApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRQb3NpdGlvbmFsQXVkaW8ucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggQXVkaW8ucHJvdG90eXBlICksIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zdHJ1Y3RvcjogUG9zaXRpb25hbEF1ZGlvLFxcclxcblxcclxcblxcdFxcdGdldE91dHB1dDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLnBhbm5lcjtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGdldFJlZkRpc3RhbmNlOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMucGFubmVyLnJlZkRpc3RhbmNlO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0UmVmRGlzdGFuY2U6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5wYW5uZXIucmVmRGlzdGFuY2UgPSB2YWx1ZTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGdldFJvbGxvZmZGYWN0b3I6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5wYW5uZXIucm9sbG9mZkZhY3RvcjtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldFJvbGxvZmZGYWN0b3I6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5wYW5uZXIucm9sbG9mZkZhY3RvciA9IHZhbHVlO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Z2V0RGlzdGFuY2VNb2RlbDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLnBhbm5lci5kaXN0YW5jZU1vZGVsO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0RGlzdGFuY2VNb2RlbDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnBhbm5lci5kaXN0YW5jZU1vZGVsID0gdmFsdWU7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRnZXRNYXhEaXN0YW5jZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLnBhbm5lci5tYXhEaXN0YW5jZTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldE1heERpc3RhbmNlOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMucGFubmVyLm1heERpc3RhbmNlID0gdmFsdWU7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHR1cGRhdGVNYXRyaXhXb3JsZDogKCBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdE9iamVjdDNELnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKCB0aGlzLCBmb3JjZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMucGFubmVyLnNldFBvc2l0aW9uKCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR9ICkoKVxcclxcblxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIEF1ZGlvQW5hbHlzZXIoIGF1ZGlvLCBmZnRTaXplICkge1xcclxcblxcclxcblxcdFxcdHRoaXMuYW5hbHlzZXIgPSBhdWRpby5jb250ZXh0LmNyZWF0ZUFuYWx5c2VyKCk7XFxyXFxuXFx0XFx0dGhpcy5hbmFseXNlci5mZnRTaXplID0gZmZ0U2l6ZSAhPT0gdW5kZWZpbmVkID8gZmZ0U2l6ZSA6IDIwNDg7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkoIHRoaXMuYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQgKTtcXHJcXG5cXHJcXG5cXHRcXHRhdWRpby5nZXRPdXRwdXQoKS5jb25uZWN0KCB0aGlzLmFuYWx5c2VyICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIEF1ZGlvQW5hbHlzZXIucHJvdG90eXBlLCB7XFxyXFxuXFxyXFxuXFx0XFx0Z2V0RnJlcXVlbmN5RGF0YTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuYW5hbHlzZXIuZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEoIHRoaXMuZGF0YSApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmRhdGE7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRnZXRBdmVyYWdlRnJlcXVlbmN5OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHZhbHVlID0gMCwgZGF0YSA9IHRoaXMuZ2V0RnJlcXVlbmN5RGF0YSgpO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhbHVlICs9IGRhdGFbIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHZhbHVlIC8gZGF0YS5sZW5ndGg7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKlxcclxcblxcdCAqIEJ1ZmZlcmVkIHNjZW5lIGdyYXBoIHByb3BlcnR5IHRoYXQgYWxsb3dzIHdlaWdodGVkIGFjY3VtdWxhdGlvbi5cXHJcXG5cXHQgKlxcclxcblxcdCAqXFxyXFxuXFx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cXHJcXG5cXHQgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cXHJcXG5cXHQgKiBAYXV0aG9yIHRzY2h3XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gUHJvcGVydHlNaXhlciggYmluZGluZywgdHlwZU5hbWUsIHZhbHVlU2l6ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmJpbmRpbmcgPSBiaW5kaW5nO1xcclxcblxcdFxcdHRoaXMudmFsdWVTaXplID0gdmFsdWVTaXplO1xcclxcblxcclxcblxcdFxcdHZhciBidWZmZXJUeXBlID0gRmxvYXQ2NEFycmF5LFxcclxcblxcdFxcdFxcdG1peEZ1bmN0aW9uO1xcclxcblxcclxcblxcdFxcdHN3aXRjaCAoIHR5cGVOYW1lICkge1xcclxcblxcclxcblxcdFxcdFxcdGNhc2UgJ3F1YXRlcm5pb24nOlxcclxcblxcdFxcdFxcdFxcdG1peEZ1bmN0aW9uID0gdGhpcy5fc2xlcnA7XFxyXFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y2FzZSAnc3RyaW5nJzpcXHJcXG5cXHRcXHRcXHRjYXNlICdib29sJzpcXHJcXG5cXHRcXHRcXHRcXHRidWZmZXJUeXBlID0gQXJyYXk7XFxyXFxuXFx0XFx0XFx0XFx0bWl4RnVuY3Rpb24gPSB0aGlzLl9zZWxlY3Q7XFxyXFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZGVmYXVsdDpcXHJcXG5cXHRcXHRcXHRcXHRtaXhGdW5jdGlvbiA9IHRoaXMuX2xlcnA7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHRoaXMuYnVmZmVyID0gbmV3IGJ1ZmZlclR5cGUoIHZhbHVlU2l6ZSAqIDQgKTtcXHJcXG5cXHRcXHQvLyBsYXlvdXQ6IFsgaW5jb21pbmcgfCBhY2N1MCB8IGFjY3UxIHwgb3JpZyBdXFxyXFxuXFx0XFx0Ly9cXHJcXG5cXHRcXHQvLyBpbnRlcnBvbGF0b3JzIGNhbiB1c2UgLmJ1ZmZlciBhcyB0aGVpciAucmVzdWx0XFxyXFxuXFx0XFx0Ly8gdGhlIGRhdGEgdGhlbiBnb2VzIHRvICdpbmNvbWluZydcXHJcXG5cXHRcXHQvL1xcclxcblxcdFxcdC8vICdhY2N1MCcgYW5kICdhY2N1MScgYXJlIHVzZWQgZnJhbWUtaW50ZXJsZWF2ZWQgZm9yXFxyXFxuXFx0XFx0Ly8gdGhlIGN1bXVsYXRpdmUgcmVzdWx0IGFuZCBhcmUgY29tcGFyZWQgdG8gZGV0ZWN0XFxyXFxuXFx0XFx0Ly8gY2hhbmdlc1xcclxcblxcdFxcdC8vXFxyXFxuXFx0XFx0Ly8gJ29yaWcnIHN0b3JlcyB0aGUgb3JpZ2luYWwgc3RhdGUgb2YgdGhlIHByb3BlcnR5XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5fbWl4QnVmZmVyUmVnaW9uID0gbWl4RnVuY3Rpb247XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gMDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnVzZUNvdW50ID0gMDtcXHJcXG5cXHRcXHR0aGlzLnJlZmVyZW5jZUNvdW50ID0gMDtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0T2JqZWN0LmFzc2lnbiggUHJvcGVydHlNaXhlci5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHQvLyBhY2N1bXVsYXRlIGRhdGEgaW4gdGhlICdpbmNvbWluZycgcmVnaW9uIGludG8gJ2FjY3U8aT4nXFxyXFxuXFx0XFx0YWNjdW11bGF0ZTogZnVuY3Rpb24gKCBhY2N1SW5kZXgsIHdlaWdodCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBub3RlOiBoYXBwaWx5IGFjY3VtdWxhdGluZyBub3RoaW5nIHdoZW4gd2VpZ2h0ID0gMCwgdGhlIGNhbGxlciBrbm93c1xcclxcblxcdFxcdFxcdC8vIHRoZSB3ZWlnaHQgYW5kIHNob3VsZG4ndCBoYXZlIG1hZGUgdGhlIGNhbGwgaW4gdGhlIGZpcnN0IHBsYWNlXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyLFxcclxcblxcdFxcdFxcdFxcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxcclxcblxcdFxcdFxcdFxcdG9mZnNldCA9IGFjY3VJbmRleCAqIHN0cmlkZSArIHN0cmlkZSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjdXJyZW50V2VpZ2h0ID0gdGhpcy5jdW11bGF0aXZlV2VpZ2h0O1xcclxcblxcclxcblxcdFxcdFxcdGlmICggY3VycmVudFdlaWdodCA9PT0gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBhY2N1TiA6PSBpbmNvbWluZyAqIHdlaWdodFxcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGJ1ZmZlclsgb2Zmc2V0ICsgaSBdID0gYnVmZmVyWyBpIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdGN1cnJlbnRXZWlnaHQgPSB3ZWlnaHQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBhY2N1TiA6PSBhY2N1TiArIGluY29taW5nICogd2VpZ2h0XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y3VycmVudFdlaWdodCArPSB3ZWlnaHQ7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIG1peCA9IHdlaWdodCAvIGN1cnJlbnRXZWlnaHQ7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5fbWl4QnVmZmVyUmVnaW9uKCBidWZmZXIsIG9mZnNldCwgMCwgbWl4LCBzdHJpZGUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gY3VycmVudFdlaWdodDtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdC8vIGFwcGx5IHRoZSBzdGF0ZSBvZiAnYWNjdTxpPicgdG8gdGhlIGJpbmRpbmcgd2hlbiBhY2N1cyBkaWZmZXJcXHJcXG5cXHRcXHRhcHBseTogZnVuY3Rpb24gKCBhY2N1SW5kZXggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxcclxcblxcdFxcdFxcdFxcdGJ1ZmZlciA9IHRoaXMuYnVmZmVyLFxcclxcblxcdFxcdFxcdFxcdG9mZnNldCA9IGFjY3VJbmRleCAqIHN0cmlkZSArIHN0cmlkZSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR3ZWlnaHQgPSB0aGlzLmN1bXVsYXRpdmVXZWlnaHQsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YmluZGluZyA9IHRoaXMuYmluZGluZztcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSAwO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggd2VpZ2h0IDwgMSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBhY2N1TiA6PSBhY2N1TiArIG9yaWdpbmFsICogKCAxIC0gY3VtdWxhdGl2ZVdlaWdodCApXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIG9yaWdpbmFsVmFsdWVPZmZzZXQgPSBzdHJpZGUgKiAzO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuX21peEJ1ZmZlclJlZ2lvbihcXHJcXG5cXHRcXHRcXHRcXHRcXHRidWZmZXIsIG9mZnNldCwgb3JpZ2luYWxWYWx1ZU9mZnNldCwgMSAtIHdlaWdodCwgc3RyaWRlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gc3RyaWRlLCBlID0gc3RyaWRlICsgc3RyaWRlOyBpICE9PSBlOyArKyBpICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggYnVmZmVyWyBpIF0gIT09IGJ1ZmZlclsgaSArIHN0cmlkZSBdICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIHZhbHVlIGhhcyBjaGFuZ2VkIC0+IHVwZGF0ZSBzY2VuZSBncmFwaFxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGJpbmRpbmcuc2V0VmFsdWUoIGJ1ZmZlciwgb2Zmc2V0ICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdC8vIHJlbWVtYmVyIHRoZSBzdGF0ZSBvZiB0aGUgYm91bmQgcHJvcGVydHkgYW5kIGNvcHkgaXQgdG8gYm90aCBhY2N1c1xcclxcblxcdFxcdHNhdmVPcmlnaW5hbFN0YXRlOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGJpbmRpbmcgPSB0aGlzLmJpbmRpbmc7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyLFxcclxcblxcdFxcdFxcdFxcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxcclxcblxcclxcblxcdFxcdFxcdFxcdG9yaWdpbmFsVmFsdWVPZmZzZXQgPSBzdHJpZGUgKiAzO1xcclxcblxcclxcblxcdFxcdFxcdGJpbmRpbmcuZ2V0VmFsdWUoIGJ1ZmZlciwgb3JpZ2luYWxWYWx1ZU9mZnNldCApO1xcclxcblxcclxcblxcdFxcdFxcdC8vIGFjY3VbMC4uMV0gOj0gb3JpZyAtLSBpbml0aWFsbHkgZGV0ZWN0IGNoYW5nZXMgYWdhaW5zdCB0aGUgb3JpZ2luYWxcXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IHN0cmlkZSwgZSA9IG9yaWdpbmFsVmFsdWVPZmZzZXQ7IGkgIT09IGU7ICsrIGkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YnVmZmVyWyBpIF0gPSBidWZmZXJbIG9yaWdpbmFsVmFsdWVPZmZzZXQgKyAoIGkgJSBzdHJpZGUgKSBdO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSAwO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Ly8gYXBwbHkgdGhlIHN0YXRlIHByZXZpb3VzbHkgdGFrZW4gdmlhICdzYXZlT3JpZ2luYWxTdGF0ZScgdG8gdGhlIGJpbmRpbmdcXHJcXG5cXHRcXHRyZXN0b3JlT3JpZ2luYWxTdGF0ZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBvcmlnaW5hbFZhbHVlT2Zmc2V0ID0gdGhpcy52YWx1ZVNpemUgKiAzO1xcclxcblxcdFxcdFxcdHRoaXMuYmluZGluZy5zZXRWYWx1ZSggdGhpcy5idWZmZXIsIG9yaWdpbmFsVmFsdWVPZmZzZXQgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcclxcblxcdFxcdC8vIG1peCBmdW5jdGlvbnNcXHJcXG5cXHJcXG5cXHRcXHRfc2VsZWN0OiBmdW5jdGlvbiAoIGJ1ZmZlciwgZHN0T2Zmc2V0LCBzcmNPZmZzZXQsIHQsIHN0cmlkZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHQgPj0gMC41ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGJ1ZmZlclsgZHN0T2Zmc2V0ICsgaSBdID0gYnVmZmVyWyBzcmNPZmZzZXQgKyBpIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdF9zbGVycDogZnVuY3Rpb24gKCBidWZmZXIsIGRzdE9mZnNldCwgc3JjT2Zmc2V0LCB0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFF1YXRlcm5pb24uc2xlcnBGbGF0KCBidWZmZXIsIGRzdE9mZnNldCwgYnVmZmVyLCBkc3RPZmZzZXQsIGJ1ZmZlciwgc3JjT2Zmc2V0LCB0ICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRfbGVycDogZnVuY3Rpb24gKCBidWZmZXIsIGRzdE9mZnNldCwgc3JjT2Zmc2V0LCB0LCBzdHJpZGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHMgPSAxIC0gdDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IHN0cmlkZTsgKysgaSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgaiA9IGRzdE9mZnNldCArIGk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YnVmZmVyWyBqIF0gPSBidWZmZXJbIGogXSAqIHMgKyBidWZmZXJbIHNyY09mZnNldCArIGkgXSAqIHQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBBIHJlZmVyZW5jZSB0byBhIHJlYWwgcHJvcGVydHkgaW4gdGhlIHNjZW5lIGdyYXBoLlxcclxcblxcdCAqXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xcclxcblxcdCAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xcclxcblxcdCAqIEBhdXRob3IgdHNjaHdcXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBDb21wb3NpdGUoIHRhcmdldEdyb3VwLCBwYXRoLCBvcHRpb25hbFBhcnNlZFBhdGggKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHBhcnNlZFBhdGggPSBvcHRpb25hbFBhcnNlZFBhdGggfHwgUHJvcGVydHlCaW5kaW5nLnBhcnNlVHJhY2tOYW1lKCBwYXRoICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5fdGFyZ2V0R3JvdXAgPSB0YXJnZXRHcm91cDtcXHJcXG5cXHRcXHR0aGlzLl9iaW5kaW5ncyA9IHRhcmdldEdyb3VwLnN1YnNjcmliZV8oIHBhdGgsIHBhcnNlZFBhdGggKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0T2JqZWN0LmFzc2lnbiggQ29tcG9zaXRlLnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdGdldFZhbHVlOiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5iaW5kKCk7IC8vIGJpbmQgYWxsIGJpbmRpbmdcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgZmlyc3RWYWxpZEluZGV4ID0gdGhpcy5fdGFyZ2V0R3JvdXAubkNhY2hlZE9iamVjdHNfLFxcclxcblxcdFxcdFxcdFxcdGJpbmRpbmcgPSB0aGlzLl9iaW5kaW5nc1sgZmlyc3RWYWxpZEluZGV4IF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gYW5kIG9ubHkgY2FsbCAuZ2V0VmFsdWUgb24gdGhlIGZpcnN0XFxyXFxuXFx0XFx0XFx0aWYgKCBiaW5kaW5nICE9PSB1bmRlZmluZWQgKSBiaW5kaW5nLmdldFZhbHVlKCBhcnJheSwgb2Zmc2V0ICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRWYWx1ZTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gdGhpcy5fdGFyZ2V0R3JvdXAubkNhY2hlZE9iamVjdHNfLFxcclxcblxcdFxcdFxcdFxcdFxcdCAgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRiaW5kaW5nc1sgaSBdLnNldFZhbHVlKCBhcnJheSwgb2Zmc2V0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0YmluZDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gdGhpcy5fdGFyZ2V0R3JvdXAubkNhY2hlZE9iamVjdHNfLFxcclxcblxcdFxcdFxcdFxcdFxcdCAgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRiaW5kaW5nc1sgaSBdLmJpbmQoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IHRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXyxcXHJcXG5cXHRcXHRcXHRcXHRcXHQgIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YmluZGluZ3NbIGkgXS51bmJpbmQoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBQcm9wZXJ0eUJpbmRpbmcoIHJvb3ROb2RlLCBwYXRoLCBwYXJzZWRQYXRoICkge1xcclxcblxcclxcblxcdFxcdHRoaXMucGF0aCA9IHBhdGg7XFxyXFxuXFx0XFx0dGhpcy5wYXJzZWRQYXRoID0gcGFyc2VkUGF0aCB8fCBQcm9wZXJ0eUJpbmRpbmcucGFyc2VUcmFja05hbWUoIHBhdGggKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm5vZGUgPSBQcm9wZXJ0eUJpbmRpbmcuZmluZE5vZGUoIHJvb3ROb2RlLCB0aGlzLnBhcnNlZFBhdGgubm9kZU5hbWUgKSB8fCByb290Tm9kZTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnJvb3ROb2RlID0gcm9vdE5vZGU7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIFByb3BlcnR5QmluZGluZywge1xcclxcblxcclxcblxcdFxcdENvbXBvc2l0ZTogQ29tcG9zaXRlLFxcclxcblxcclxcblxcdFxcdGNyZWF0ZTogZnVuY3Rpb24gKCByb290LCBwYXRoLCBwYXJzZWRQYXRoICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggISAoIHJvb3QgJiYgcm9vdC5pc0FuaW1hdGlvbk9iamVjdEdyb3VwICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIG5ldyBQcm9wZXJ0eUJpbmRpbmcoIHJvb3QsIHBhdGgsIHBhcnNlZFBhdGggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiBuZXcgUHJvcGVydHlCaW5kaW5nLkNvbXBvc2l0ZSggcm9vdCwgcGF0aCwgcGFyc2VkUGF0aCApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdC8qKlxcclxcblxcdFxcdCAqIFJlcGxhY2VzIHNwYWNlcyB3aXRoIHVuZGVyc2NvcmVzIGFuZCByZW1vdmVzIHVuc3VwcG9ydGVkIGNoYXJhY3RlcnMgZnJvbVxcclxcblxcdFxcdCAqIG5vZGUgbmFtZXMsIHRvIGVuc3VyZSBjb21wYXRpYmlsaXR5IHdpdGggcGFyc2VUcmFja05hbWUoKS5cXHJcXG5cXHRcXHQgKlxcclxcblxcdFxcdCAqIEBwYXJhbSAge3N0cmluZ30gbmFtZSBOb2RlIG5hbWUgdG8gYmUgc2FuaXRpemVkLlxcclxcblxcdFxcdCAqIEByZXR1cm4ge3N0cmluZ31cXHJcXG5cXHRcXHQgKi9cXHJcXG5cXHRcXHRzYW5pdGl6ZU5vZGVOYW1lOiBmdW5jdGlvbiAoIG5hbWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIG5hbWUucmVwbGFjZSggL1xcXFxzL2csICdfJyApLnJlcGxhY2UoIC9bXlxcXFx3LV0vZywgJycgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHBhcnNlVHJhY2tOYW1lOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gUGFyZW50IGRpcmVjdG9yaWVzLCBkZWxpbWl0ZWQgYnkgJy8nIG9yICc6Jy4gQ3VycmVudGx5IHVudXNlZCwgYnV0IG11c3RcXHJcXG5cXHRcXHRcXHQvLyBiZSBtYXRjaGVkIHRvIHBhcnNlIHRoZSByZXN0IG9mIHRoZSB0cmFjayBuYW1lLlxcclxcblxcdFxcdFxcdHZhciBkaXJlY3RvcnlSZSA9IC8oKD86W1xcXFx3LV0rW1xcXFwvOl0pKikvO1xcclxcblxcclxcblxcdFxcdFxcdC8vIFRhcmdldCBub2RlLiBNYXkgY29udGFpbiB3b3JkIGNoYXJhY3RlcnMgKGEtekEtWjAtOV8pIGFuZCAnLicgb3IgJy0nLlxcclxcblxcdFxcdFxcdHZhciBub2RlUmUgPSAvKFtcXFxcdy1cXFxcLl0rKT8vO1xcclxcblxcclxcblxcdFxcdFxcdC8vIE9iamVjdCBvbiB0YXJnZXQgbm9kZSwgYW5kIGFjY2Vzc29yLiBOYW1lIG1heSBjb250YWluIG9ubHkgd29yZFxcclxcblxcdFxcdFxcdC8vIGNoYXJhY3RlcnMuIEFjY2Vzc29yIG1heSBjb250YWluIGFueSBjaGFyYWN0ZXIgZXhjZXB0IGNsb3NpbmcgYnJhY2tldC5cXHJcXG5cXHRcXHRcXHR2YXIgb2JqZWN0UmUgPSAvKD86XFxcXC4oW1xcXFx3LV0rKSg/OlxcXFxbKC4rKVxcXFxdKT8pPy87XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gUHJvcGVydHkgYW5kIGFjY2Vzc29yLiBNYXkgY29udGFpbiBvbmx5IHdvcmQgY2hhcmFjdGVycy4gQWNjZXNzb3IgbWF5XFxyXFxuXFx0XFx0XFx0Ly8gY29udGFpbiBhbnkgbm9uLWJyYWNrZXQgY2hhcmFjdGVycy5cXHJcXG5cXHRcXHRcXHR2YXIgcHJvcGVydHlSZSA9IC9cXFxcLihbXFxcXHctXSspKD86XFxcXFsoLispXFxcXF0pPy87XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHRyYWNrUmUgPSBuZXcgUmVnRXhwKCAnJ1xcclxcblxcdFxcdFxcdFxcdCsgJ14nXFxyXFxuXFx0XFx0XFx0XFx0KyBkaXJlY3RvcnlSZS5zb3VyY2VcXHJcXG5cXHRcXHRcXHRcXHQrIG5vZGVSZS5zb3VyY2VcXHJcXG5cXHRcXHRcXHRcXHQrIG9iamVjdFJlLnNvdXJjZVxcclxcblxcdFxcdFxcdFxcdCsgcHJvcGVydHlSZS5zb3VyY2VcXHJcXG5cXHRcXHRcXHRcXHQrICckJ1xcclxcblxcdFxcdFxcdCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHN1cHBvcnRlZE9iamVjdE5hbWVzID0gWyAnbWF0ZXJpYWwnLCAnbWF0ZXJpYWxzJywgJ2JvbmVzJyBdO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiAoIHRyYWNrTmFtZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgbWF0Y2hlcyA9IHRyYWNrUmUuZXhlYyggdHJhY2tOYW1lICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCAhIG1hdGNoZXMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhyb3cgbmV3IEVycm9yKCAnUHJvcGVydHlCaW5kaW5nOiBDYW5ub3QgcGFyc2UgdHJhY2tOYW1lOiAnICsgdHJhY2tOYW1lICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciByZXN1bHRzID0ge1xcclxcblxcdFxcdFxcdFxcdFxcdC8vIGRpcmVjdG9yeU5hbWU6IG1hdGNoZXNbIDEgXSwgLy8gKHRzY2h3KSBjdXJyZW50bHkgdW51c2VkXFxyXFxuXFx0XFx0XFx0XFx0XFx0bm9kZU5hbWU6IG1hdGNoZXNbIDIgXSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRvYmplY3ROYW1lOiBtYXRjaGVzWyAzIF0sXFxyXFxuXFx0XFx0XFx0XFx0XFx0b2JqZWN0SW5kZXg6IG1hdGNoZXNbIDQgXSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRwcm9wZXJ0eU5hbWU6IG1hdGNoZXNbIDUgXSwgLy8gcmVxdWlyZWRcXHJcXG5cXHRcXHRcXHRcXHRcXHRwcm9wZXJ0eUluZGV4OiBtYXRjaGVzWyA2IF1cXHJcXG5cXHRcXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBsYXN0RG90ID0gcmVzdWx0cy5ub2RlTmFtZSAmJiByZXN1bHRzLm5vZGVOYW1lLmxhc3RJbmRleE9mKCAnLicgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGxhc3REb3QgIT09IHVuZGVmaW5lZCAmJiBsYXN0RG90ICE9PSAtIDEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIG9iamVjdE5hbWUgPSByZXN1bHRzLm5vZGVOYW1lLnN1YnN0cmluZyggbGFzdERvdCArIDEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBPYmplY3QgbmFtZXMgbXVzdCBiZSBjaGVja2VkIGFnYWluc3QgYSB3aGl0ZWxpc3QuIE90aGVyd2lzZSwgdGhlcmVcXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBpcyBubyB3YXkgdG8gcGFyc2UgJ2Zvby5iYXIuYmF6JzogJ2JheicgbXVzdCBiZSBhIHByb3BlcnR5LCBidXRcXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyAnYmFyJyBjb3VsZCBiZSB0aGUgb2JqZWN0TmFtZSwgb3IgcGFydCBvZiBhIG5vZGVOYW1lICh3aGljaCBjYW5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBpbmNsdWRlICcuJyBjaGFyYWN0ZXJzKS5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHN1cHBvcnRlZE9iamVjdE5hbWVzLmluZGV4T2YoIG9iamVjdE5hbWUgKSAhPT0gLSAxICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHJlc3VsdHMubm9kZU5hbWUgPSByZXN1bHRzLm5vZGVOYW1lLnN1YnN0cmluZyggMCwgbGFzdERvdCApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHJlc3VsdHMub2JqZWN0TmFtZSA9IG9iamVjdE5hbWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHJlc3VsdHMucHJvcGVydHlOYW1lID09PSBudWxsIHx8IHJlc3VsdHMucHJvcGVydHlOYW1lLmxlbmd0aCA9PT0gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoICdQcm9wZXJ0eUJpbmRpbmc6IGNhbiBub3QgcGFyc2UgcHJvcGVydHlOYW1lIGZyb20gdHJhY2tOYW1lOiAnICsgdHJhY2tOYW1lICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiByZXN1bHRzO1xcclxcblxcclxcblxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0fSgpLFxcclxcblxcclxcblxcdFxcdGZpbmROb2RlOiBmdW5jdGlvbiAoIHJvb3QsIG5vZGVOYW1lICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggISBub2RlTmFtZSB8fCBub2RlTmFtZSA9PT0gXFxcIlxcXCIgfHwgbm9kZU5hbWUgPT09IFxcXCJyb290XFxcIiB8fCBub2RlTmFtZSA9PT0gXFxcIi5cXFwiIHx8IG5vZGVOYW1lID09PSAtIDEgfHwgbm9kZU5hbWUgPT09IHJvb3QubmFtZSB8fCBub2RlTmFtZSA9PT0gcm9vdC51dWlkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiByb290O1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBzZWFyY2ggaW50byBza2VsZXRvbiBib25lcy5cXHJcXG5cXHRcXHRcXHRpZiAoIHJvb3Quc2tlbGV0b24gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHNlYXJjaFNrZWxldG9uID0gZnVuY3Rpb24gKCBza2VsZXRvbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBza2VsZXRvbi5ib25lcy5sZW5ndGg7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGJvbmUgPSBza2VsZXRvbi5ib25lc1sgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggYm9uZS5uYW1lID09PSBub2RlTmFtZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gYm9uZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBudWxsO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGJvbmUgPSBzZWFyY2hTa2VsZXRvbiggcm9vdC5za2VsZXRvbiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggYm9uZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gYm9uZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdC8vIHNlYXJjaCBpbnRvIG5vZGUgc3VidHJlZS5cXHJcXG5cXHRcXHRcXHRpZiAoIHJvb3QuY2hpbGRyZW4gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHNlYXJjaE5vZGVTdWJ0cmVlID0gZnVuY3Rpb24gKCBjaGlsZHJlbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGNoaWxkTm9kZSA9IGNoaWxkcmVuWyBpIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBjaGlsZE5vZGUubmFtZSA9PT0gbm9kZU5hbWUgfHwgY2hpbGROb2RlLnV1aWQgPT09IG5vZGVOYW1lICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBjaGlsZE5vZGU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciByZXN1bHQgPSBzZWFyY2hOb2RlU3VidHJlZSggY2hpbGROb2RlLmNoaWxkcmVuICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCByZXN1bHQgKSByZXR1cm4gcmVzdWx0O1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gbnVsbDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBzdWJUcmVlTm9kZSA9IHNlYXJjaE5vZGVTdWJ0cmVlKCByb290LmNoaWxkcmVuICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBzdWJUcmVlTm9kZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gc3ViVHJlZU5vZGU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gbnVsbDtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUsIHsgLy8gcHJvdG90eXBlLCBjb250aW51ZWRcXHJcXG5cXHJcXG5cXHRcXHQvLyB0aGVzZSBhcmUgdXNlZCB0byBcXFwiYmluZFxcXCIgYSBub25leGlzdGVudCBwcm9wZXJ0eVxcclxcblxcdFxcdF9nZXRWYWx1ZV91bmF2YWlsYWJsZTogZnVuY3Rpb24gKCkge30sXFxyXFxuXFx0XFx0X3NldFZhbHVlX3VuYXZhaWxhYmxlOiBmdW5jdGlvbiAoKSB7fSxcXHJcXG5cXHJcXG5cXHRcXHRCaW5kaW5nVHlwZToge1xcclxcblxcdFxcdFxcdERpcmVjdDogMCxcXHJcXG5cXHRcXHRcXHRFbnRpcmVBcnJheTogMSxcXHJcXG5cXHRcXHRcXHRBcnJheUVsZW1lbnQ6IDIsXFxyXFxuXFx0XFx0XFx0SGFzRnJvbVRvQXJyYXk6IDNcXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdFZlcnNpb25pbmc6IHtcXHJcXG5cXHRcXHRcXHROb25lOiAwLFxcclxcblxcdFxcdFxcdE5lZWRzVXBkYXRlOiAxLFxcclxcblxcdFxcdFxcdE1hdHJpeFdvcmxkTmVlZHNVcGRhdGU6IDJcXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdEdldHRlckJ5QmluZGluZ1R5cGU6IFtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmdW5jdGlvbiBnZXRWYWx1ZV9kaXJlY3QoIGJ1ZmZlciwgb2Zmc2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGJ1ZmZlclsgb2Zmc2V0IF0gPSB0aGlzLm5vZGVbIHRoaXMucHJvcGVydHlOYW1lIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRmdW5jdGlvbiBnZXRWYWx1ZV9hcnJheSggYnVmZmVyLCBvZmZzZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIHNvdXJjZSA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBzb3VyY2UubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGJ1ZmZlclsgb2Zmc2V0ICsrIF0gPSBzb3VyY2VbIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRmdW5jdGlvbiBnZXRWYWx1ZV9hcnJheUVsZW1lbnQoIGJ1ZmZlciwgb2Zmc2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGJ1ZmZlclsgb2Zmc2V0IF0gPSB0aGlzLnJlc29sdmVkUHJvcGVydHlbIHRoaXMucHJvcGVydHlJbmRleCBdO1xcclxcblxcclxcblxcdFxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0XFx0ZnVuY3Rpb24gZ2V0VmFsdWVfdG9BcnJheSggYnVmZmVyLCBvZmZzZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5LnRvQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdF0sXFxyXFxuXFxyXFxuXFx0XFx0U2V0dGVyQnlCaW5kaW5nVHlwZUFuZFZlcnNpb25pbmc6IFtcXHJcXG5cXHJcXG5cXHRcXHRcXHRbXFxyXFxuXFx0XFx0XFx0XFx0Ly8gRGlyZWN0XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24gc2V0VmFsdWVfZGlyZWN0KCBidWZmZXIsIG9mZnNldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnRhcmdldE9iamVjdFsgdGhpcy5wcm9wZXJ0eU5hbWUgXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiBzZXRWYWx1ZV9kaXJlY3Rfc2V0TmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMudGFyZ2V0T2JqZWN0WyB0aGlzLnByb3BlcnR5TmFtZSBdID0gYnVmZmVyWyBvZmZzZXQgXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiBzZXRWYWx1ZV9kaXJlY3Rfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZSggYnVmZmVyLCBvZmZzZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy50YXJnZXRPYmplY3RbIHRoaXMucHJvcGVydHlOYW1lIF0gPSBidWZmZXJbIG9mZnNldCBdO1xcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRdLCBbXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gRW50aXJlQXJyYXlcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiBzZXRWYWx1ZV9hcnJheSggYnVmZmVyLCBvZmZzZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGRlc3QgPSB0aGlzLnJlc29sdmVkUHJvcGVydHk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBuID0gZGVzdC5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGVzdFsgaSBdID0gYnVmZmVyWyBvZmZzZXQgKysgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiBzZXRWYWx1ZV9hcnJheV9zZXROZWVkc1VwZGF0ZSggYnVmZmVyLCBvZmZzZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGRlc3QgPSB0aGlzLnJlc29sdmVkUHJvcGVydHk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBuID0gZGVzdC5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGVzdFsgaSBdID0gYnVmZmVyWyBvZmZzZXQgKysgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy50YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24gc2V0VmFsdWVfYXJyYXlfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZSggYnVmZmVyLCBvZmZzZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGRlc3QgPSB0aGlzLnJlc29sdmVkUHJvcGVydHk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBuID0gZGVzdC5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGVzdFsgaSBdID0gYnVmZmVyWyBvZmZzZXQgKysgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy50YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdF0sIFtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBBcnJheUVsZW1lbnRcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiBzZXRWYWx1ZV9hcnJheUVsZW1lbnQoIGJ1ZmZlciwgb2Zmc2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eVsgdGhpcy5wcm9wZXJ0eUluZGV4IF0gPSBidWZmZXJbIG9mZnNldCBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24gc2V0VmFsdWVfYXJyYXlFbGVtZW50X3NldE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnJlc29sdmVkUHJvcGVydHlbIHRoaXMucHJvcGVydHlJbmRleCBdID0gYnVmZmVyWyBvZmZzZXQgXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiBzZXRWYWx1ZV9hcnJheUVsZW1lbnRfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZSggYnVmZmVyLCBvZmZzZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy50YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdF0sIFtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBIYXNUb0Zyb21BcnJheVxcclxcblxcclxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uIHNldFZhbHVlX2Zyb21BcnJheSggYnVmZmVyLCBvZmZzZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5LmZyb21BcnJheSggYnVmZmVyLCBvZmZzZXQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9LFxcclxcblxcclxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uIHNldFZhbHVlX2Zyb21BcnJheV9zZXROZWVkc1VwZGF0ZSggYnVmZmVyLCBvZmZzZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5LmZyb21BcnJheSggYnVmZmVyLCBvZmZzZXQgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiBzZXRWYWx1ZV9mcm9tQXJyYXlfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZSggYnVmZmVyLCBvZmZzZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5LmZyb21BcnJheSggYnVmZmVyLCBvZmZzZXQgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XVxcclxcblxcclxcblxcdFxcdF0sXFxyXFxuXFxyXFxuXFx0XFx0Z2V0VmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlX3VuYm91bmQoIHRhcmdldEFycmF5LCBvZmZzZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5iaW5kKCk7XFxyXFxuXFx0XFx0XFx0dGhpcy5nZXRWYWx1ZSggdGFyZ2V0QXJyYXksIG9mZnNldCApO1xcclxcblxcclxcblxcdFxcdFxcdC8vIE5vdGU6IFRoaXMgY2xhc3MgdXNlcyBhIFN0YXRlIHBhdHRlcm4gb24gYSBwZXItbWV0aG9kIGJhc2lzOlxcclxcblxcdFxcdFxcdC8vICdiaW5kJyBzZXRzICd0aGlzLmdldFZhbHVlJyAvICdzZXRWYWx1ZScgYW5kIHNoYWRvd3MgdGhlXFxyXFxuXFx0XFx0XFx0Ly8gcHJvdG90eXBlIHZlcnNpb24gb2YgdGhlc2UgbWV0aG9kcyB3aXRoIG9uZSB0aGF0IHJlcHJlc2VudHNcXHJcXG5cXHRcXHRcXHQvLyB0aGUgYm91bmQgc3RhdGUuIFdoZW4gdGhlIHByb3BlcnR5IGlzIG5vdCBmb3VuZCwgdGhlIG1ldGhvZHNcXHJcXG5cXHRcXHRcXHQvLyBiZWNvbWUgbm8tb3BzLlxcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0VmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlX3VuYm91bmQoIHNvdXJjZUFycmF5LCBvZmZzZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5iaW5kKCk7XFxyXFxuXFx0XFx0XFx0dGhpcy5zZXRWYWx1ZSggc291cmNlQXJyYXksIG9mZnNldCApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Ly8gY3JlYXRlIGdldHRlciAvIHNldHRlciBwYWlyIGZvciBhIHByb3BlcnR5IGluIHRoZSBzY2VuZSBncmFwaFxcclxcblxcdFxcdGJpbmQ6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdGFyZ2V0T2JqZWN0ID0gdGhpcy5ub2RlLFxcclxcblxcdFxcdFxcdFxcdHBhcnNlZFBhdGggPSB0aGlzLnBhcnNlZFBhdGgsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0b2JqZWN0TmFtZSA9IHBhcnNlZFBhdGgub2JqZWN0TmFtZSxcXHJcXG5cXHRcXHRcXHRcXHRwcm9wZXJ0eU5hbWUgPSBwYXJzZWRQYXRoLnByb3BlcnR5TmFtZSxcXHJcXG5cXHRcXHRcXHRcXHRwcm9wZXJ0eUluZGV4ID0gcGFyc2VkUGF0aC5wcm9wZXJ0eUluZGV4O1xcclxcblxcclxcblxcdFxcdFxcdGlmICggISB0YXJnZXRPYmplY3QgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGFyZ2V0T2JqZWN0ID0gUHJvcGVydHlCaW5kaW5nLmZpbmROb2RlKCB0aGlzLnJvb3ROb2RlLCBwYXJzZWRQYXRoLm5vZGVOYW1lICkgfHwgdGhpcy5yb290Tm9kZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLm5vZGUgPSB0YXJnZXRPYmplY3Q7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdC8vIHNldCBmYWlsIHN0YXRlIHNvIHdlIGNhbiBqdXN0ICdyZXR1cm4nIG9uIGVycm9yXFxyXFxuXFx0XFx0XFx0dGhpcy5nZXRWYWx1ZSA9IHRoaXMuX2dldFZhbHVlX3VuYXZhaWxhYmxlO1xcclxcblxcdFxcdFxcdHRoaXMuc2V0VmFsdWUgPSB0aGlzLl9zZXRWYWx1ZV91bmF2YWlsYWJsZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBlbnN1cmUgdGhlcmUgaXMgYSB2YWx1ZSBub2RlXFxyXFxuXFx0XFx0XFx0aWYgKCAhIHRhcmdldE9iamVjdCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBUcnlpbmcgdG8gdXBkYXRlIG5vZGUgZm9yIHRyYWNrOiAnICsgdGhpcy5wYXRoICsgJyBidXQgaXQgd2FzblxcXFwndCBmb3VuZC4nICk7XFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIG9iamVjdE5hbWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIG9iamVjdEluZGV4ID0gcGFyc2VkUGF0aC5vYmplY3RJbmRleDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBzcGVjaWFsIGNhc2VzIHdlcmUgd2UgbmVlZCB0byByZWFjaCBkZWVwZXIgaW50byB0aGUgaGllcmFyY2h5IHRvIGdldCB0aGUgZmFjZSBtYXRlcmlhbHMuLi4uXFxyXFxuXFx0XFx0XFx0XFx0c3dpdGNoICggb2JqZWN0TmFtZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdtYXRlcmlhbHMnOlxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggISB0YXJnZXRPYmplY3QubWF0ZXJpYWwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb3BlcnR5QmluZGluZzogQ2FuIG5vdCBiaW5kIHRvIG1hdGVyaWFsIGFzIG5vZGUgZG9lcyBub3QgaGF2ZSBhIG1hdGVyaWFsLicsIHRoaXMgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggISB0YXJnZXRPYmplY3QubWF0ZXJpYWwubWF0ZXJpYWxzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBtYXRlcmlhbC5tYXRlcmlhbHMgYXMgbm9kZS5tYXRlcmlhbCBkb2VzIG5vdCBoYXZlIGEgbWF0ZXJpYWxzIGFycmF5LicsIHRoaXMgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdC5tYXRlcmlhbC5tYXRlcmlhbHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnYm9uZXMnOlxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggISB0YXJnZXRPYmplY3Quc2tlbGV0b24gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb3BlcnR5QmluZGluZzogQ2FuIG5vdCBiaW5kIHRvIGJvbmVzIGFzIG5vZGUgZG9lcyBub3QgaGF2ZSBhIHNrZWxldG9uLicsIHRoaXMgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHBvdGVudGlhbCBmdXR1cmUgb3B0aW1pemF0aW9uOiBza2lwIHRoaXMgaWYgcHJvcGVydHlJbmRleCBpcyBhbHJlYWR5IGFuIGludGVnZXJcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBhbmQgY29udmVydCB0aGUgaW50ZWdlciBzdHJpbmcgdG8gYSB0cnVlIGludGVnZXIuXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0LnNrZWxldG9uLmJvbmVzO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHN1cHBvcnQgcmVzb2x2aW5nIG1vcnBoVGFyZ2V0IG5hbWVzIGludG8gaW5kaWNlcy5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0YXJnZXRPYmplY3QubGVuZ3RoOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggdGFyZ2V0T2JqZWN0WyBpIF0ubmFtZSA9PT0gb2JqZWN0SW5kZXggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0SW5kZXggPSBpO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0ZGVmYXVsdDpcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHRhcmdldE9iamVjdFsgb2JqZWN0TmFtZSBdID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb3BlcnR5QmluZGluZzogQ2FuIG5vdCBiaW5kIHRvIG9iamVjdE5hbWUgb2Ygbm9kZSB1bmRlZmluZWQuJywgdGhpcyApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0WyBvYmplY3ROYW1lIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggb2JqZWN0SW5kZXggIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHRhcmdldE9iamVjdFsgb2JqZWN0SW5kZXggXSA9PT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IFRyeWluZyB0byBiaW5kIHRvIG9iamVjdEluZGV4IG9mIG9iamVjdE5hbWUsIGJ1dCBpcyB1bmRlZmluZWQuJywgdGhpcywgdGFyZ2V0T2JqZWN0ICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3RbIG9iamVjdEluZGV4IF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyByZXNvbHZlIHByb3BlcnR5XFxyXFxuXFx0XFx0XFx0dmFyIG5vZGVQcm9wZXJ0eSA9IHRhcmdldE9iamVjdFsgcHJvcGVydHlOYW1lIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBub2RlUHJvcGVydHkgPT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgbm9kZU5hbWUgPSBwYXJzZWRQYXRoLm5vZGVOYW1lO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IFRyeWluZyB0byB1cGRhdGUgcHJvcGVydHkgZm9yIHRyYWNrOiAnICsgbm9kZU5hbWUgK1xcclxcblxcdFxcdFxcdFxcdFxcdCcuJyArIHByb3BlcnR5TmFtZSArICcgYnV0IGl0IHdhc25cXFxcJ3QgZm91bmQuJywgdGFyZ2V0T2JqZWN0ICk7XFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBkZXRlcm1pbmUgdmVyc2lvbmluZyBzY2hlbWVcXHJcXG5cXHRcXHRcXHR2YXIgdmVyc2lvbmluZyA9IHRoaXMuVmVyc2lvbmluZy5Ob25lO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGFyZ2V0T2JqZWN0Lm5lZWRzVXBkYXRlICE9PSB1bmRlZmluZWQgKSB7IC8vIG1hdGVyaWFsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmVyc2lvbmluZyA9IHRoaXMuVmVyc2lvbmluZy5OZWVkc1VwZGF0ZTtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCB0YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSAhPT0gdW5kZWZpbmVkICkgeyAvLyBub2RlIHRyYW5zZm9ybVxcclxcblxcclxcblxcdFxcdFxcdFxcdHZlcnNpb25pbmcgPSB0aGlzLlZlcnNpb25pbmcuTWF0cml4V29ybGROZWVkc1VwZGF0ZTtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gZGV0ZXJtaW5lIGhvdyB0aGUgcHJvcGVydHkgZ2V0cyBib3VuZFxcclxcblxcdFxcdFxcdHZhciBiaW5kaW5nVHlwZSA9IHRoaXMuQmluZGluZ1R5cGUuRGlyZWN0O1xcclxcblxcclxcblxcdFxcdFxcdGlmICggcHJvcGVydHlJbmRleCAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGFjY2VzcyBhIHN1YiBlbGVtZW50IG9mIHRoZSBwcm9wZXJ0eSBhcnJheSAob25seSBwcmltaXRpdmVzIGFyZSBzdXBwb3J0ZWQgcmlnaHQgbm93KVxcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggcHJvcGVydHlOYW1lID09PSBcXFwibW9ycGhUYXJnZXRJbmZsdWVuY2VzXFxcIiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBwb3RlbnRpYWwgb3B0aW1pemF0aW9uLCBza2lwIHRoaXMgaWYgcHJvcGVydHlJbmRleCBpcyBhbHJlYWR5IGFuIGludGVnZXIsIGFuZCBjb252ZXJ0IHRoZSBpbnRlZ2VyIHN0cmluZyB0byBhIHRydWUgaW50ZWdlci5cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBzdXBwb3J0IHJlc29sdmluZyBtb3JwaFRhcmdldCBuYW1lcyBpbnRvIGluZGljZXMuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAhIHRhcmdldE9iamVjdC5nZW9tZXRyeSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gbW9ycGhUYXJnZXRJbmZsdWVuY2VzIGJlY2F1c2Ugbm9kZSBkb2VzIG5vdCBoYXZlIGEgZ2VvbWV0cnkuJywgdGhpcyApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0YXJnZXRPYmplY3QuZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoICEgdGFyZ2V0T2JqZWN0Lmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gbW9ycGhUYXJnZXRJbmZsdWVuY2VzIGJlY2F1c2Ugbm9kZSBkb2VzIG5vdCBoYXZlIGEgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLicsIHRoaXMgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMubm9kZS5nZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24ubGVuZ3RoOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggdGFyZ2V0T2JqZWN0Lmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvblsgaSBdLm5hbWUgPT09IHByb3BlcnR5SW5kZXggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cHJvcGVydHlJbmRleCA9IGk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggISB0YXJnZXRPYmplY3QuZ2VvbWV0cnkubW9ycGhUYXJnZXRzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBtb3JwaFRhcmdldEluZmx1ZW5jZXMgYmVjYXVzZSBub2RlIGRvZXMgbm90IGhhdmUgYSBnZW9tZXRyeS5tb3JwaFRhcmdldHMuJywgdGhpcyApO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5ub2RlLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB0YXJnZXRPYmplY3QuZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0ubmFtZSA9PT0gcHJvcGVydHlJbmRleCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwcm9wZXJ0eUluZGV4ID0gaTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YmluZGluZ1R5cGUgPSB0aGlzLkJpbmRpbmdUeXBlLkFycmF5RWxlbWVudDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnJlc29sdmVkUHJvcGVydHkgPSBub2RlUHJvcGVydHk7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5wcm9wZXJ0eUluZGV4ID0gcHJvcGVydHlJbmRleDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBub2RlUHJvcGVydHkuZnJvbUFycmF5ICE9PSB1bmRlZmluZWQgJiYgbm9kZVByb3BlcnR5LnRvQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBtdXN0IHVzZSBjb3B5IGZvciBPYmplY3QzRC5FdWxlci9RdWF0ZXJuaW9uXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YmluZGluZ1R5cGUgPSB0aGlzLkJpbmRpbmdUeXBlLkhhc0Zyb21Ub0FycmF5O1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eSA9IG5vZGVQcm9wZXJ0eTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCBub2RlUHJvcGVydHkgKSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRiaW5kaW5nVHlwZSA9IHRoaXMuQmluZGluZ1R5cGUuRW50aXJlQXJyYXk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5ID0gbm9kZVByb3BlcnR5O1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdC8vIHNlbGVjdCBnZXR0ZXIgLyBzZXR0ZXJcXHJcXG5cXHRcXHRcXHR0aGlzLmdldFZhbHVlID0gdGhpcy5HZXR0ZXJCeUJpbmRpbmdUeXBlWyBiaW5kaW5nVHlwZSBdO1xcclxcblxcdFxcdFxcdHRoaXMuc2V0VmFsdWUgPSB0aGlzLlNldHRlckJ5QmluZGluZ1R5cGVBbmRWZXJzaW9uaW5nWyBiaW5kaW5nVHlwZSBdWyB2ZXJzaW9uaW5nIF07XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm5vZGUgPSBudWxsO1xcclxcblxcclxcblxcdFxcdFxcdC8vIGJhY2sgdG8gdGhlIHByb3RvdHlwZSB2ZXJzaW9uIG9mIGdldFZhbHVlIC8gc2V0VmFsdWVcXHJcXG5cXHRcXHRcXHQvLyBub3RlOiBhdm9pZGluZyB0byBtdXRhdGUgdGhlIHNoYXBlIG9mICd0aGlzJyB2aWEgJ2RlbGV0ZSdcXHJcXG5cXHRcXHRcXHR0aGlzLmdldFZhbHVlID0gdGhpcy5fZ2V0VmFsdWVfdW5ib3VuZDtcXHJcXG5cXHRcXHRcXHR0aGlzLnNldFZhbHVlID0gdGhpcy5fc2V0VmFsdWVfdW5ib3VuZDtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8vIVxcXFwgREVDTEFSRSBBTElBUyBBRlRFUiBhc3NpZ24gcHJvdG90eXBlICFcXHJcXG5cXHRPYmplY3QuYXNzaWduKCBQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLCB7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gaW5pdGlhbCBzdGF0ZSBvZiB0aGVzZSBtZXRob2RzIHRoYXQgY2FsbHMgJ2JpbmQnXFxyXFxuXFx0XFx0X2dldFZhbHVlX3VuYm91bmQ6IFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuZ2V0VmFsdWUsXFxyXFxuXFx0XFx0X3NldFZhbHVlX3VuYm91bmQ6IFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuc2V0VmFsdWUsXFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqXFxyXFxuXFx0ICogQSBncm91cCBvZiBvYmplY3RzIHRoYXQgcmVjZWl2ZXMgYSBzaGFyZWQgYW5pbWF0aW9uIHN0YXRlLlxcclxcblxcdCAqXFxyXFxuXFx0ICogVXNhZ2U6XFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBcXHQtXFx0QWRkIG9iamVjdHMgeW91IHdvdWxkIG90aGVyd2lzZSBwYXNzIGFzICdyb290JyB0byB0aGVcXHJcXG5cXHQgKiBcXHRcXHRjb25zdHJ1Y3RvciBvciB0aGUgLmNsaXBBY3Rpb24gbWV0aG9kIG9mIEFuaW1hdGlvbk1peGVyLlxcclxcblxcdCAqXFxyXFxuXFx0ICogXFx0LVxcdEluc3RlYWQgcGFzcyB0aGlzIG9iamVjdCBhcyAncm9vdCcuXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBcXHQtXFx0WW91IGNhbiBhbHNvIGFkZCBhbmQgcmVtb3ZlIG9iamVjdHMgbGF0ZXIgd2hlbiB0aGUgbWl4ZXJcXHJcXG5cXHQgKiBcXHRcXHRpcyBydW5uaW5nLlxcclxcblxcdCAqXFxyXFxuXFx0ICogTm90ZTpcXHJcXG5cXHQgKlxcclxcblxcdCAqICBcXHRPYmplY3RzIG9mIHRoaXMgY2xhc3MgYXBwZWFyIGFzIG9uZSBvYmplY3QgdG8gdGhlIG1peGVyLFxcclxcblxcdCAqICBcXHRzbyBjYWNoZSBjb250cm9sIG9mIHRoZSBpbmRpdmlkdWFsIG9iamVjdHMgbXVzdCBiZSBkb25lXFxyXFxuXFx0ICogIFxcdG9uIHRoZSBncm91cC5cXHJcXG5cXHQgKlxcclxcblxcdCAqIExpbWl0YXRpb246XFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBcXHQtIFxcdFRoZSBhbmltYXRlZCBwcm9wZXJ0aWVzIG11c3QgYmUgY29tcGF0aWJsZSBhbW9uZyB0aGVcXHJcXG5cXHQgKiBcXHRcXHRhbGwgb2JqZWN0cyBpbiB0aGUgZ3JvdXAuXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiAgLVxcdEEgc2luZ2xlIHByb3BlcnR5IGNhbiBlaXRoZXIgYmUgY29udHJvbGxlZCB0aHJvdWdoIGFcXHJcXG5cXHQgKiAgXFx0dGFyZ2V0IGdyb3VwIG9yIGRpcmVjdGx5LCBidXQgbm90IGJvdGguXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBAYXV0aG9yIHRzY2h3XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gQW5pbWF0aW9uT2JqZWN0R3JvdXAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy51dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gY2FjaGVkIG9iamVjdHMgZm9sbG93ZWQgYnkgdGhlIGFjdGl2ZSBvbmVzXFxyXFxuXFx0XFx0dGhpcy5fb2JqZWN0cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm5DYWNoZWRPYmplY3RzXyA9IDA7XFx0XFx0XFx0Ly8gdGhyZXNob2xkXFxyXFxuXFx0XFx0Ly8gbm90ZTogcmVhZCBieSBQcm9wZXJ0eUJpbmRpbmcuQ29tcG9zaXRlXFxyXFxuXFxyXFxuXFx0XFx0dmFyIGluZGljZXMgPSB7fTtcXHJcXG5cXHRcXHR0aGlzLl9pbmRpY2VzQnlVVUlEID0gaW5kaWNlcztcXHRcXHQvLyBmb3IgYm9va2tlZXBpbmdcXHJcXG5cXHJcXG5cXHRcXHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xcclxcblxcclxcblxcdFxcdFxcdGluZGljZXNbIGFyZ3VtZW50c1sgaSBdLnV1aWQgXSA9IGk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHRoaXMuX3BhdGhzID0gW107XFx0XFx0XFx0XFx0XFx0Ly8gaW5zaWRlOiBzdHJpbmdcXHJcXG5cXHRcXHR0aGlzLl9wYXJzZWRQYXRocyA9IFtdO1xcdFxcdFxcdFxcdC8vIGluc2lkZTogeyB3ZSBkb24ndCBjYXJlLCBoZXJlIH1cXHJcXG5cXHRcXHR0aGlzLl9iaW5kaW5ncyA9IFtdOyBcXHRcXHRcXHRcXHQvLyBpbnNpZGU6IEFycmF5PCBQcm9wZXJ0eUJpbmRpbmcgPlxcclxcblxcdFxcdHRoaXMuX2JpbmRpbmdzSW5kaWNlc0J5UGF0aCA9IHt9OyBcXHQvLyBpbnNpZGU6IGluZGljZXMgaW4gdGhlc2UgYXJyYXlzXFxyXFxuXFxyXFxuXFx0XFx0dmFyIHNjb3BlID0gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnN0YXRzID0ge1xcclxcblxcclxcblxcdFxcdFxcdG9iamVjdHM6IHtcXHJcXG5cXHRcXHRcXHRcXHRnZXQgdG90YWwoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHNjb3BlLl9vYmplY3RzLmxlbmd0aDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9LFxcclxcblxcdFxcdFxcdFxcdGdldCBpblVzZSgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy50b3RhbCAtIHNjb3BlLm5DYWNoZWRPYmplY3RzXztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFx0XFx0XFx0fSxcXHJcXG5cXHRcXHRcXHRnZXQgYmluZGluZ3NQZXJPYmplY3QoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHNjb3BlLl9iaW5kaW5ncy5sZW5ndGg7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIEFuaW1hdGlvbk9iamVjdEdyb3VwLnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdGlzQW5pbWF0aW9uT2JqZWN0R3JvdXA6IHRydWUsXFxyXFxuXFxyXFxuXFx0XFx0YWRkOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLFxcclxcblxcdFxcdFxcdFxcdG5PYmplY3RzID0gb2JqZWN0cy5sZW5ndGgsXFxyXFxuXFx0XFx0XFx0XFx0bkNhY2hlZE9iamVjdHMgPSB0aGlzLm5DYWNoZWRPYmplY3RzXyxcXHJcXG5cXHRcXHRcXHRcXHRpbmRpY2VzQnlVVUlEID0gdGhpcy5faW5kaWNlc0J5VVVJRCxcXHJcXG5cXHRcXHRcXHRcXHRwYXRocyA9IHRoaXMuX3BhdGhzLFxcclxcblxcdFxcdFxcdFxcdHBhcnNlZFBhdGhzID0gdGhpcy5fcGFyc2VkUGF0aHMsXFxyXFxuXFx0XFx0XFx0XFx0YmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcXHJcXG5cXHRcXHRcXHRcXHRuQmluZGluZ3MgPSBiaW5kaW5ncy5sZW5ndGg7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgb2JqZWN0ID0gYXJndW1lbnRzWyBpIF0sXFxyXFxuXFx0XFx0XFx0XFx0XFx0dXVpZCA9IG9iamVjdC51dWlkLFxcclxcblxcdFxcdFxcdFxcdFxcdGluZGV4ID0gaW5kaWNlc0J5VVVJRFsgdXVpZCBdLFxcclxcblxcdFxcdFxcdFxcdFxcdGtub3duT2JqZWN0ID0gdW5kZWZpbmVkO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggaW5kZXggPT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyB1bmtub3duIG9iamVjdCAtPiBhZGQgaXQgdG8gdGhlIEFDVElWRSByZWdpb25cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpbmRleCA9IG5PYmplY3RzICsrO1xcclxcblxcdFxcdFxcdFxcdFxcdGluZGljZXNCeVVVSURbIHV1aWQgXSA9IGluZGV4O1xcclxcblxcdFxcdFxcdFxcdFxcdG9iamVjdHMucHVzaCggb2JqZWN0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBqID0gMCwgbSA9IG5CaW5kaW5nczsgaiAhPT0gbTsgKysgaiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRiaW5kaW5nc1sgaiBdLnB1c2goIG5ldyBQcm9wZXJ0eUJpbmRpbmcoIG9iamVjdCwgcGF0aHNbIGogXSwgcGFyc2VkUGF0aHNbIGogXSApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIGluZGV4IDwgbkNhY2hlZE9iamVjdHMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0a25vd25PYmplY3QgPSBvYmplY3RzWyBpbmRleCBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIG1vdmUgZXhpc3Rpbmcgb2JqZWN0IHRvIHRoZSBBQ1RJVkUgcmVnaW9uXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGZpcnN0QWN0aXZlSW5kZXggPSAtLSBuQ2FjaGVkT2JqZWN0cyxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRsYXN0Q2FjaGVkT2JqZWN0ID0gb2JqZWN0c1sgZmlyc3RBY3RpdmVJbmRleCBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGluZGljZXNCeVVVSURbIGxhc3RDYWNoZWRPYmplY3QudXVpZCBdID0gaW5kZXg7XFxyXFxuXFx0XFx0XFx0XFx0XFx0b2JqZWN0c1sgaW5kZXggXSA9IGxhc3RDYWNoZWRPYmplY3Q7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aW5kaWNlc0J5VVVJRFsgdXVpZCBdID0gZmlyc3RBY3RpdmVJbmRleDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRvYmplY3RzWyBmaXJzdEFjdGl2ZUluZGV4IF0gPSBvYmplY3Q7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBqID0gMCwgbSA9IG5CaW5kaW5nczsgaiAhPT0gbTsgKysgaiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgYmluZGluZ3NGb3JQYXRoID0gYmluZGluZ3NbIGogXSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRsYXN0Q2FjaGVkID0gYmluZGluZ3NGb3JQYXRoWyBmaXJzdEFjdGl2ZUluZGV4IF0sXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YmluZGluZyA9IGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRiaW5kaW5nc0ZvclBhdGhbIGluZGV4IF0gPSBsYXN0Q2FjaGVkO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggYmluZGluZyA9PT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHNpbmNlIHdlIGRvIG5vdCBib3RoZXIgdG8gY3JlYXRlIG5ldyBiaW5kaW5nc1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGZvciBvYmplY3RzIHRoYXQgYXJlIGNhY2hlZCwgdGhlIGJpbmRpbmcgbWF5XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gb3IgbWF5IG5vdCBleGlzdFxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJpbmRpbmcgPSBuZXcgUHJvcGVydHlCaW5kaW5nKCBvYmplY3QsIHBhdGhzWyBqIF0sIHBhcnNlZFBhdGhzWyBqIF0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0YmluZGluZ3NGb3JQYXRoWyBmaXJzdEFjdGl2ZUluZGV4IF0gPSBiaW5kaW5nO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBvYmplY3RzWyBpbmRleCBdICE9PSBrbm93bk9iamVjdCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQW5pbWF0aW9uT2JqZWN0R3JvdXA6IERpZmZlcmVudCBvYmplY3RzIHdpdGggdGhlIHNhbWUgVVVJRCAnICtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQnZGV0ZWN0ZWQuIENsZWFuIHRoZSBjYWNoZXMgb3IgcmVjcmVhdGUgeW91ciBpbmZyYXN0cnVjdHVyZSB3aGVuIHJlbG9hZGluZyBzY2VuZXMuJyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gLy8gZWxzZSB0aGUgb2JqZWN0IGlzIGFscmVhZHkgd2hlcmUgd2Ugd2FudCBpdCB0byBiZVxcclxcblxcclxcblxcdFxcdFxcdH0gLy8gZm9yIGFyZ3VtZW50c1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMubkNhY2hlZE9iamVjdHNfID0gbkNhY2hlZE9iamVjdHM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXFxyXFxuXFx0XFx0XFx0XFx0bkNhY2hlZE9iamVjdHMgPSB0aGlzLm5DYWNoZWRPYmplY3RzXyxcXHJcXG5cXHRcXHRcXHRcXHRpbmRpY2VzQnlVVUlEID0gdGhpcy5faW5kaWNlc0J5VVVJRCxcXHJcXG5cXHRcXHRcXHRcXHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxcclxcblxcdFxcdFxcdFxcdG5CaW5kaW5ncyA9IGJpbmRpbmdzLmxlbmd0aDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBvYmplY3QgPSBhcmd1bWVudHNbIGkgXSxcXHJcXG5cXHRcXHRcXHRcXHRcXHR1dWlkID0gb2JqZWN0LnV1aWQsXFxyXFxuXFx0XFx0XFx0XFx0XFx0aW5kZXggPSBpbmRpY2VzQnlVVUlEWyB1dWlkIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICYmIGluZGV4ID49IG5DYWNoZWRPYmplY3RzICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIG1vdmUgZXhpc3Rpbmcgb2JqZWN0IGludG8gdGhlIENBQ0hFRCByZWdpb25cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgbGFzdENhY2hlZEluZGV4ID0gbkNhY2hlZE9iamVjdHMgKyssXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zmlyc3RBY3RpdmVPYmplY3QgPSBvYmplY3RzWyBsYXN0Q2FjaGVkSW5kZXggXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpbmRpY2VzQnlVVUlEWyBmaXJzdEFjdGl2ZU9iamVjdC51dWlkIF0gPSBpbmRleDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRvYmplY3RzWyBpbmRleCBdID0gZmlyc3RBY3RpdmVPYmplY3Q7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aW5kaWNlc0J5VVVJRFsgdXVpZCBdID0gbGFzdENhY2hlZEluZGV4O1xcclxcblxcdFxcdFxcdFxcdFxcdG9iamVjdHNbIGxhc3RDYWNoZWRJbmRleCBdID0gb2JqZWN0O1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsrIGogKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzWyBqIF0sXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Zmlyc3RBY3RpdmUgPSBiaW5kaW5nc0ZvclBhdGhbIGxhc3RDYWNoZWRJbmRleCBdLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJpbmRpbmcgPSBiaW5kaW5nc0ZvclBhdGhbIGluZGV4IF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0YmluZGluZ3NGb3JQYXRoWyBpbmRleCBdID0gZmlyc3RBY3RpdmU7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0YmluZGluZ3NGb3JQYXRoWyBsYXN0Q2FjaGVkSW5kZXggXSA9IGJpbmRpbmc7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9IC8vIGZvciBhcmd1bWVudHNcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm5DYWNoZWRPYmplY3RzXyA9IG5DYWNoZWRPYmplY3RzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Ly8gcmVtb3ZlICYgZm9yZ2V0XFxyXFxuXFx0XFx0dW5jYWNoZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBvYmplY3RzID0gdGhpcy5fb2JqZWN0cyxcXHJcXG5cXHRcXHRcXHRcXHRuT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoLFxcclxcblxcdFxcdFxcdFxcdG5DYWNoZWRPYmplY3RzID0gdGhpcy5uQ2FjaGVkT2JqZWN0c18sXFxyXFxuXFx0XFx0XFx0XFx0aW5kaWNlc0J5VVVJRCA9IHRoaXMuX2luZGljZXNCeVVVSUQsXFxyXFxuXFx0XFx0XFx0XFx0YmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcXHJcXG5cXHRcXHRcXHRcXHRuQmluZGluZ3MgPSBiaW5kaW5ncy5sZW5ndGg7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgb2JqZWN0ID0gYXJndW1lbnRzWyBpIF0sXFxyXFxuXFx0XFx0XFx0XFx0XFx0dXVpZCA9IG9iamVjdC51dWlkLFxcclxcblxcdFxcdFxcdFxcdFxcdGluZGV4ID0gaW5kaWNlc0J5VVVJRFsgdXVpZCBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggaW5kZXggIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRkZWxldGUgaW5kaWNlc0J5VVVJRFsgdXVpZCBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggaW5kZXggPCBuQ2FjaGVkT2JqZWN0cyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBvYmplY3QgaXMgY2FjaGVkLCBzaHJpbmsgdGhlIENBQ0hFRCByZWdpb25cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgZmlyc3RBY3RpdmVJbmRleCA9IC0tIG5DYWNoZWRPYmplY3RzLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGxhc3RDYWNoZWRPYmplY3QgPSBvYmplY3RzWyBmaXJzdEFjdGl2ZUluZGV4IF0sXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bGFzdEluZGV4ID0gLS0gbk9iamVjdHMsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bGFzdE9iamVjdCA9IG9iamVjdHNbIGxhc3RJbmRleCBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGxhc3QgY2FjaGVkIG9iamVjdCB0YWtlcyB0aGlzIG9iamVjdCdzIHBsYWNlXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aW5kaWNlc0J5VVVJRFsgbGFzdENhY2hlZE9iamVjdC51dWlkIF0gPSBpbmRleDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRvYmplY3RzWyBpbmRleCBdID0gbGFzdENhY2hlZE9iamVjdDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBsYXN0IG9iamVjdCBnb2VzIHRvIHRoZSBhY3RpdmF0ZWQgc2xvdCBhbmQgcG9wXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aW5kaWNlc0J5VVVJRFsgbGFzdE9iamVjdC51dWlkIF0gPSBmaXJzdEFjdGl2ZUluZGV4O1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdHNbIGZpcnN0QWN0aXZlSW5kZXggXSA9IGxhc3RPYmplY3Q7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0cy5wb3AoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBhY2NvdW50aW5nIGlzIGRvbmUsIG5vdyBkbyB0aGUgc2FtZSBmb3IgYWxsIGJpbmRpbmdzXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGogPSAwLCBtID0gbkJpbmRpbmdzOyBqICE9PSBtOyArKyBqICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBiaW5kaW5nc0ZvclBhdGggPSBiaW5kaW5nc1sgaiBdLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGxhc3RDYWNoZWQgPSBiaW5kaW5nc0ZvclBhdGhbIGZpcnN0QWN0aXZlSW5kZXggXSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRsYXN0ID0gYmluZGluZ3NGb3JQYXRoWyBsYXN0SW5kZXggXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRiaW5kaW5nc0ZvclBhdGhbIGluZGV4IF0gPSBsYXN0Q2FjaGVkO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJpbmRpbmdzRm9yUGF0aFsgZmlyc3RBY3RpdmVJbmRleCBdID0gbGFzdDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRiaW5kaW5nc0ZvclBhdGgucG9wKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gb2JqZWN0IGlzIGFjdGl2ZSwganVzdCBzd2FwIHdpdGggdGhlIGxhc3QgYW5kIHBvcFxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBsYXN0SW5kZXggPSAtLSBuT2JqZWN0cyxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRsYXN0T2JqZWN0ID0gb2JqZWN0c1sgbGFzdEluZGV4IF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aW5kaWNlc0J5VVVJRFsgbGFzdE9iamVjdC51dWlkIF0gPSBpbmRleDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRvYmplY3RzWyBpbmRleCBdID0gbGFzdE9iamVjdDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRvYmplY3RzLnBvcCgpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsrIGogKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzWyBqIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YmluZGluZ3NGb3JQYXRoWyBpbmRleCBdID0gYmluZGluZ3NGb3JQYXRoWyBsYXN0SW5kZXggXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRiaW5kaW5nc0ZvclBhdGgucG9wKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH0gLy8gY2FjaGVkIG9yIGFjdGl2ZVxcclxcblxcclxcblxcdFxcdFxcdFxcdH0gLy8gaWYgb2JqZWN0IGlzIGtub3duXFxyXFxuXFxyXFxuXFx0XFx0XFx0fSAvLyBmb3IgYXJndW1lbnRzXFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5uQ2FjaGVkT2JqZWN0c18gPSBuQ2FjaGVkT2JqZWN0cztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdC8vIEludGVybmFsIGludGVyZmFjZSB1c2VkIGJ5IGJlZnJpZW5kZWQgUHJvcGVydHlCaW5kaW5nLkNvbXBvc2l0ZTpcXHJcXG5cXHJcXG5cXHRcXHRzdWJzY3JpYmVfOiBmdW5jdGlvbiAoIHBhdGgsIHBhcnNlZFBhdGggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gcmV0dXJucyBhbiBhcnJheSBvZiBiaW5kaW5ncyBmb3IgdGhlIGdpdmVuIHBhdGggdGhhdCBpcyBjaGFuZ2VkXFxyXFxuXFx0XFx0XFx0Ly8gYWNjb3JkaW5nIHRvIHRoZSBjb250YWluZWQgb2JqZWN0cyBpbiB0aGUgZ3JvdXBcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgaW5kaWNlc0J5UGF0aCA9IHRoaXMuX2JpbmRpbmdzSW5kaWNlc0J5UGF0aCxcXHJcXG5cXHRcXHRcXHRcXHRpbmRleCA9IGluZGljZXNCeVBhdGhbIHBhdGggXSxcXHJcXG5cXHRcXHRcXHRcXHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggaW5kZXggIT09IHVuZGVmaW5lZCApIHJldHVybiBiaW5kaW5nc1sgaW5kZXggXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcGF0aHMgPSB0aGlzLl9wYXRocyxcXHJcXG5cXHRcXHRcXHRcXHRwYXJzZWRQYXRocyA9IHRoaXMuX3BhcnNlZFBhdGhzLFxcclxcblxcdFxcdFxcdFxcdG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLFxcclxcblxcdFxcdFxcdFxcdG5PYmplY3RzID0gb2JqZWN0cy5sZW5ndGgsXFxyXFxuXFx0XFx0XFx0XFx0bkNhY2hlZE9iamVjdHMgPSB0aGlzLm5DYWNoZWRPYmplY3RzXyxcXHJcXG5cXHRcXHRcXHRcXHRiaW5kaW5nc0ZvclBhdGggPSBuZXcgQXJyYXkoIG5PYmplY3RzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aW5kZXggPSBiaW5kaW5ncy5sZW5ndGg7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aW5kaWNlc0J5UGF0aFsgcGF0aCBdID0gaW5kZXg7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cGF0aHMucHVzaCggcGF0aCApO1xcclxcblxcdFxcdFxcdHBhcnNlZFBhdGhzLnB1c2goIHBhcnNlZFBhdGggKTtcXHJcXG5cXHRcXHRcXHRiaW5kaW5ncy5wdXNoKCBiaW5kaW5nc0ZvclBhdGggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IG5DYWNoZWRPYmplY3RzLCBuID0gb2JqZWN0cy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIG9iamVjdCA9IG9iamVjdHNbIGkgXTtcXHJcXG5cXHRcXHRcXHRcXHRiaW5kaW5nc0ZvclBhdGhbIGkgXSA9IG5ldyBQcm9wZXJ0eUJpbmRpbmcoIG9iamVjdCwgcGF0aCwgcGFyc2VkUGF0aCApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gYmluZGluZ3NGb3JQYXRoO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0dW5zdWJzY3JpYmVfOiBmdW5jdGlvbiAoIHBhdGggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gdGVsbHMgdGhlIGdyb3VwIHRvIGZvcmdldCBhYm91dCBhIHByb3BlcnR5IHBhdGggYW5kIG5vIGxvbmdlclxcclxcblxcdFxcdFxcdC8vIHVwZGF0ZSB0aGUgYXJyYXkgcHJldmlvdXNseSBvYnRhaW5lZCB3aXRoICdzdWJzY3JpYmVfJ1xcclxcblxcclxcblxcdFxcdFxcdHZhciBpbmRpY2VzQnlQYXRoID0gdGhpcy5fYmluZGluZ3NJbmRpY2VzQnlQYXRoLFxcclxcblxcdFxcdFxcdFxcdGluZGV4ID0gaW5kaWNlc0J5UGF0aFsgcGF0aCBdO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggaW5kZXggIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgcGF0aHMgPSB0aGlzLl9wYXRocyxcXHJcXG5cXHRcXHRcXHRcXHRcXHRwYXJzZWRQYXRocyA9IHRoaXMuX3BhcnNlZFBhdGhzLFxcclxcblxcdFxcdFxcdFxcdFxcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXFxyXFxuXFx0XFx0XFx0XFx0XFx0bGFzdEJpbmRpbmdzSW5kZXggPSBiaW5kaW5ncy5sZW5ndGggLSAxLFxcclxcblxcdFxcdFxcdFxcdFxcdGxhc3RCaW5kaW5ncyA9IGJpbmRpbmdzWyBsYXN0QmluZGluZ3NJbmRleCBdLFxcclxcblxcdFxcdFxcdFxcdFxcdGxhc3RCaW5kaW5nc1BhdGggPSBwYXRoWyBsYXN0QmluZGluZ3NJbmRleCBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGluZGljZXNCeVBhdGhbIGxhc3RCaW5kaW5nc1BhdGggXSA9IGluZGV4O1xcclxcblxcclxcblxcdFxcdFxcdFxcdGJpbmRpbmdzWyBpbmRleCBdID0gbGFzdEJpbmRpbmdzO1xcclxcblxcdFxcdFxcdFxcdGJpbmRpbmdzLnBvcCgpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHBhcnNlZFBhdGhzWyBpbmRleCBdID0gcGFyc2VkUGF0aHNbIGxhc3RCaW5kaW5nc0luZGV4IF07XFxyXFxuXFx0XFx0XFx0XFx0cGFyc2VkUGF0aHMucG9wKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cGF0aHNbIGluZGV4IF0gPSBwYXRoc1sgbGFzdEJpbmRpbmdzSW5kZXggXTtcXHJcXG5cXHRcXHRcXHRcXHRwYXRocy5wb3AoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKlxcclxcblxcdCAqIEFjdGlvbiBwcm92aWRlZCBieSBBbmltYXRpb25NaXhlciBmb3Igc2NoZWR1bGluZyBjbGlwIHBsYXliYWNrIG9uIHNwZWNpZmljXFxyXFxuXFx0ICogb2JqZWN0cy5cXHJcXG5cXHQgKlxcclxcblxcdCAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXFxyXFxuXFx0ICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXFxyXFxuXFx0ICogQGF1dGhvciB0c2Nod1xcclxcblxcdCAqXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gQW5pbWF0aW9uQWN0aW9uKCBtaXhlciwgY2xpcCwgbG9jYWxSb290ICkge1xcclxcblxcclxcblxcdFxcdHRoaXMuX21peGVyID0gbWl4ZXI7XFxyXFxuXFx0XFx0dGhpcy5fY2xpcCA9IGNsaXA7XFxyXFxuXFx0XFx0dGhpcy5fbG9jYWxSb290ID0gbG9jYWxSb290IHx8IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHRyYWNrcyA9IGNsaXAudHJhY2tzLFxcclxcblxcdFxcdFxcdG5UcmFja3MgPSB0cmFja3MubGVuZ3RoLFxcclxcblxcdFxcdFxcdGludGVycG9sYW50cyA9IG5ldyBBcnJheSggblRyYWNrcyApO1xcclxcblxcclxcblxcdFxcdHZhciBpbnRlcnBvbGFudFNldHRpbmdzID0ge1xcclxcblxcdFxcdFxcdGVuZGluZ1N0YXJ0OiBaZXJvQ3VydmF0dXJlRW5kaW5nLFxcclxcblxcdFxcdFxcdGVuZGluZ0VuZDogWmVyb0N1cnZhdHVyZUVuZGluZ1xcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuVHJhY2tzOyArKyBpICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBpbnRlcnBvbGFudCA9IHRyYWNrc1sgaSBdLmNyZWF0ZUludGVycG9sYW50KCBudWxsICk7XFxyXFxuXFx0XFx0XFx0aW50ZXJwb2xhbnRzWyBpIF0gPSBpbnRlcnBvbGFudDtcXHJcXG5cXHRcXHRcXHRpbnRlcnBvbGFudC5zZXR0aW5ncyA9IGludGVycG9sYW50U2V0dGluZ3M7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHRoaXMuX2ludGVycG9sYW50U2V0dGluZ3MgPSBpbnRlcnBvbGFudFNldHRpbmdzO1xcclxcblxcclxcblxcdFxcdHRoaXMuX2ludGVycG9sYW50cyA9IGludGVycG9sYW50cztcXHQvLyBib3VuZCBieSB0aGUgbWl4ZXJcXHJcXG5cXHJcXG5cXHRcXHQvLyBpbnNpZGU6IFByb3BlcnR5TWl4ZXIgKG1hbmFnZWQgYnkgdGhlIG1peGVyKVxcclxcblxcdFxcdHRoaXMuX3Byb3BlcnR5QmluZGluZ3MgPSBuZXcgQXJyYXkoIG5UcmFja3MgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLl9jYWNoZUluZGV4ID0gbnVsbDtcXHRcXHRcXHQvLyBmb3IgdGhlIG1lbW9yeSBtYW5hZ2VyXFxyXFxuXFx0XFx0dGhpcy5fYnlDbGlwQ2FjaGVJbmRleCA9IG51bGw7XFx0XFx0Ly8gZm9yIHRoZSBtZW1vcnkgbWFuYWdlclxcclxcblxcclxcblxcdFxcdHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50ID0gbnVsbDtcXHJcXG5cXHRcXHR0aGlzLl93ZWlnaHRJbnRlcnBvbGFudCA9IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5sb29wID0gTG9vcFJlcGVhdDtcXHJcXG5cXHRcXHR0aGlzLl9sb29wQ291bnQgPSAtIDE7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gZ2xvYmFsIG1peGVyIHRpbWUgd2hlbiB0aGUgYWN0aW9uIGlzIHRvIGJlIHN0YXJ0ZWRcXHJcXG5cXHRcXHQvLyBpdCdzIHNldCBiYWNrIHRvICdudWxsJyB1cG9uIHN0YXJ0IG9mIHRoZSBhY3Rpb25cXHJcXG5cXHRcXHR0aGlzLl9zdGFydFRpbWUgPSBudWxsO1xcclxcblxcclxcblxcdFxcdC8vIHNjYWxlZCBsb2NhbCB0aW1lIG9mIHRoZSBhY3Rpb25cXHJcXG5cXHRcXHQvLyBnZXRzIGNsYW1wZWQgb3Igd3JhcHBlZCB0byAwLi5jbGlwLmR1cmF0aW9uIGFjY29yZGluZyB0byBsb29wXFxyXFxuXFx0XFx0dGhpcy50aW1lID0gMDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnRpbWVTY2FsZSA9IDE7XFxyXFxuXFx0XFx0dGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlID0gMTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLndlaWdodCA9IDE7XFxyXFxuXFx0XFx0dGhpcy5fZWZmZWN0aXZlV2VpZ2h0ID0gMTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnJlcGV0aXRpb25zID0gSW5maW5pdHk7IFxcdFxcdC8vIG5vLiBvZiByZXBldGl0aW9ucyB3aGVuIGxvb3BpbmdcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnBhdXNlZCA9IGZhbHNlO1xcdFxcdFxcdFxcdC8vIHRydWUgLT4gemVybyBlZmZlY3RpdmUgdGltZSBzY2FsZVxcclxcblxcdFxcdHRoaXMuZW5hYmxlZCA9IHRydWU7XFx0XFx0XFx0XFx0Ly8gZmFsc2UgLT4gemVybyBlZmZlY3RpdmUgd2VpZ2h0XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5jbGFtcFdoZW5GaW5pc2hlZCBcXHQ9IGZhbHNlO1xcdC8vIGtlZXAgZmVlZGluZyB0aGUgbGFzdCBmcmFtZT9cXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnplcm9TbG9wZUF0U3RhcnQgXFx0PSB0cnVlO1xcdFxcdC8vIGZvciBzbW9vdGggaW50ZXJwb2xhdGlvbiB3L28gc2VwYXJhdGVcXHJcXG5cXHRcXHR0aGlzLnplcm9TbG9wZUF0RW5kXFx0XFx0PSB0cnVlO1xcdFxcdC8vIGNsaXBzIGZvciBzdGFydCwgbG9vcCBhbmQgZW5kXFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIEFuaW1hdGlvbkFjdGlvbi5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHQvLyBTdGF0ZSAmIFNjaGVkdWxpbmdcXHJcXG5cXHJcXG5cXHRcXHRwbGF5OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5fbWl4ZXIuX2FjdGl2YXRlQWN0aW9uKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzdG9wOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5fbWl4ZXIuX2RlYWN0aXZhdGVBY3Rpb24oIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5yZXNldCgpO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0cmVzZXQ6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnBhdXNlZCA9IGZhbHNlO1xcclxcblxcdFxcdFxcdHRoaXMuZW5hYmxlZCA9IHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy50aW1lID0gMDtcXHRcXHRcXHQvLyByZXN0YXJ0IGNsaXBcXHJcXG5cXHRcXHRcXHR0aGlzLl9sb29wQ291bnQgPSAtIDE7XFx0Ly8gZm9yZ2V0IHByZXZpb3VzIGxvb3BzXFxyXFxuXFx0XFx0XFx0dGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcXHQvLyBmb3JnZXQgc2NoZWR1bGluZ1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLnN0b3BGYWRpbmcoKS5zdG9wV2FycGluZygpO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0aXNSdW5uaW5nOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZW5hYmxlZCAmJiAhIHRoaXMucGF1c2VkICYmIHRoaXMudGltZVNjYWxlICE9PSAwICYmXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fc3RhcnRUaW1lID09PSBudWxsICYmIHRoaXMuX21peGVyLl9pc0FjdGl2ZUFjdGlvbiggdGhpcyApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Ly8gcmV0dXJuIHRydWUgd2hlbiBwbGF5IGhhcyBiZWVuIGNhbGxlZFxcclxcblxcdFxcdGlzU2NoZWR1bGVkOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuX21peGVyLl9pc0FjdGl2ZUFjdGlvbiggdGhpcyApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c3RhcnRBdDogZnVuY3Rpb24gKCB0aW1lICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuX3N0YXJ0VGltZSA9IHRpbWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRMb29wOiBmdW5jdGlvbiAoIG1vZGUsIHJlcGV0aXRpb25zICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMubG9vcCA9IG1vZGU7XFxyXFxuXFx0XFx0XFx0dGhpcy5yZXBldGl0aW9ucyA9IHJlcGV0aXRpb25zO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Ly8gV2VpZ2h0XFxyXFxuXFxyXFxuXFx0XFx0Ly8gc2V0IHRoZSB3ZWlnaHQgc3RvcHBpbmcgYW55IHNjaGVkdWxlZCBmYWRpbmdcXHJcXG5cXHRcXHQvLyBhbHRob3VnaCAuZW5hYmxlZCA9IGZhbHNlIHlpZWxkcyBhbiBlZmZlY3RpdmUgd2VpZ2h0IG9mIHplcm8sIHRoaXNcXHJcXG5cXHRcXHQvLyBtZXRob2QgZG9lcyAqbm90KiBjaGFuZ2UgLmVuYWJsZWQsIGJlY2F1c2UgaXQgd291bGQgYmUgY29uZnVzaW5nXFxyXFxuXFx0XFx0c2V0RWZmZWN0aXZlV2VpZ2h0OiBmdW5jdGlvbiAoIHdlaWdodCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLndlaWdodCA9IHdlaWdodDtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBub3RlOiBzYW1lIGxvZ2ljIGFzIHdoZW4gdXBkYXRlZCBhdCBydW50aW1lXFxyXFxuXFx0XFx0XFx0dGhpcy5fZWZmZWN0aXZlV2VpZ2h0ID0gdGhpcy5lbmFibGVkID8gd2VpZ2h0IDogMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5zdG9wRmFkaW5nKCk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHQvLyByZXR1cm4gdGhlIHdlaWdodCBjb25zaWRlcmluZyBmYWRpbmcgYW5kIC5lbmFibGVkXFxyXFxuXFx0XFx0Z2V0RWZmZWN0aXZlV2VpZ2h0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuX2VmZmVjdGl2ZVdlaWdodDtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGZhZGVJbjogZnVuY3Rpb24gKCBkdXJhdGlvbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5fc2NoZWR1bGVGYWRpbmcoIGR1cmF0aW9uLCAwLCAxICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRmYWRlT3V0OiBmdW5jdGlvbiAoIGR1cmF0aW9uICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLl9zY2hlZHVsZUZhZGluZyggZHVyYXRpb24sIDEsIDAgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNyb3NzRmFkZUZyb206IGZ1bmN0aW9uICggZmFkZU91dEFjdGlvbiwgZHVyYXRpb24sIHdhcnAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZmFkZU91dEFjdGlvbi5mYWRlT3V0KCBkdXJhdGlvbiApO1xcclxcblxcdFxcdFxcdHRoaXMuZmFkZUluKCBkdXJhdGlvbiApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggd2FycCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgZmFkZUluRHVyYXRpb24gPSB0aGlzLl9jbGlwLmR1cmF0aW9uLFxcclxcblxcdFxcdFxcdFxcdFxcdGZhZGVPdXREdXJhdGlvbiA9IGZhZGVPdXRBY3Rpb24uX2NsaXAuZHVyYXRpb24sXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0c3RhcnRFbmRSYXRpbyA9IGZhZGVPdXREdXJhdGlvbiAvIGZhZGVJbkR1cmF0aW9uLFxcclxcblxcdFxcdFxcdFxcdFxcdGVuZFN0YXJ0UmF0aW8gPSBmYWRlSW5EdXJhdGlvbiAvIGZhZGVPdXREdXJhdGlvbjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmYWRlT3V0QWN0aW9uLndhcnAoIDEuMCwgc3RhcnRFbmRSYXRpbywgZHVyYXRpb24gKTtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLndhcnAoIGVuZFN0YXJ0UmF0aW8sIDEuMCwgZHVyYXRpb24gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjcm9zc0ZhZGVUbzogZnVuY3Rpb24gKCBmYWRlSW5BY3Rpb24sIGR1cmF0aW9uLCB3YXJwICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBmYWRlSW5BY3Rpb24uY3Jvc3NGYWRlRnJvbSggdGhpcywgZHVyYXRpb24sIHdhcnAgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHN0b3BGYWRpbmc6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgd2VpZ2h0SW50ZXJwb2xhbnQgPSB0aGlzLl93ZWlnaHRJbnRlcnBvbGFudDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHdlaWdodEludGVycG9sYW50ICE9PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuX3dlaWdodEludGVycG9sYW50ID0gbnVsbDtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLl9taXhlci5fdGFrZUJhY2tDb250cm9sSW50ZXJwb2xhbnQoIHdlaWdodEludGVycG9sYW50ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Ly8gVGltZSBTY2FsZSBDb250cm9sXFxyXFxuXFxyXFxuXFx0XFx0Ly8gc2V0IHRoZSB0aW1lIHNjYWxlIHN0b3BwaW5nIGFueSBzY2hlZHVsZWQgd2FycGluZ1xcclxcblxcdFxcdC8vIGFsdGhvdWdoIC5wYXVzZWQgPSB0cnVlIHlpZWxkcyBhbiBlZmZlY3RpdmUgdGltZSBzY2FsZSBvZiB6ZXJvLCB0aGlzXFxyXFxuXFx0XFx0Ly8gbWV0aG9kIGRvZXMgKm5vdCogY2hhbmdlIC5wYXVzZWQsIGJlY2F1c2UgaXQgd291bGQgYmUgY29uZnVzaW5nXFxyXFxuXFx0XFx0c2V0RWZmZWN0aXZlVGltZVNjYWxlOiBmdW5jdGlvbiAoIHRpbWVTY2FsZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnRpbWVTY2FsZSA9IHRpbWVTY2FsZTtcXHJcXG5cXHRcXHRcXHR0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGUgPSB0aGlzLnBhdXNlZCA/IDAgOiB0aW1lU2NhbGU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuc3RvcFdhcnBpbmcoKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdC8vIHJldHVybiB0aGUgdGltZSBzY2FsZSBjb25zaWRlcmluZyB3YXJwaW5nIGFuZCAucGF1c2VkXFxyXFxuXFx0XFx0Z2V0RWZmZWN0aXZlVGltZVNjYWxlOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldER1cmF0aW9uOiBmdW5jdGlvbiAoIGR1cmF0aW9uICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMudGltZVNjYWxlID0gdGhpcy5fY2xpcC5kdXJhdGlvbiAvIGR1cmF0aW9uO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLnN0b3BXYXJwaW5nKCk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzeW5jV2l0aDogZnVuY3Rpb24gKCBhY3Rpb24gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy50aW1lID0gYWN0aW9uLnRpbWU7XFxyXFxuXFx0XFx0XFx0dGhpcy50aW1lU2NhbGUgPSBhY3Rpb24udGltZVNjYWxlO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLnN0b3BXYXJwaW5nKCk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRoYWx0OiBmdW5jdGlvbiAoIGR1cmF0aW9uICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLndhcnAoIHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZSwgMCwgZHVyYXRpb24gKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHdhcnA6IGZ1bmN0aW9uICggc3RhcnRUaW1lU2NhbGUsIGVuZFRpbWVTY2FsZSwgZHVyYXRpb24gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG1peGVyID0gdGhpcy5fbWl4ZXIsIG5vdyA9IG1peGVyLnRpbWUsXFxyXFxuXFx0XFx0XFx0XFx0aW50ZXJwb2xhbnQgPSB0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudCxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aW1lU2NhbGUgPSB0aGlzLnRpbWVTY2FsZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGludGVycG9sYW50ID09PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGludGVycG9sYW50ID0gbWl4ZXIuX2xlbmRDb250cm9sSW50ZXJwb2xhbnQoKTtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudCA9IGludGVycG9sYW50O1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgdGltZXMgPSBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnMsXFxyXFxuXFx0XFx0XFx0XFx0dmFsdWVzID0gaW50ZXJwb2xhbnQuc2FtcGxlVmFsdWVzO1xcclxcblxcclxcblxcdFxcdFxcdHRpbWVzWyAwIF0gPSBub3c7XFxyXFxuXFx0XFx0XFx0dGltZXNbIDEgXSA9IG5vdyArIGR1cmF0aW9uO1xcclxcblxcclxcblxcdFxcdFxcdHZhbHVlc1sgMCBdID0gc3RhcnRUaW1lU2NhbGUgLyB0aW1lU2NhbGU7XFxyXFxuXFx0XFx0XFx0dmFsdWVzWyAxIF0gPSBlbmRUaW1lU2NhbGUgLyB0aW1lU2NhbGU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzdG9wV2FycGluZzogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB0aW1lU2NhbGVJbnRlcnBvbGFudCA9IHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50O1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGltZVNjYWxlSW50ZXJwb2xhbnQgIT09IG51bGwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQgPSBudWxsO1xcclxcblxcdFxcdFxcdFxcdHRoaXMuX21peGVyLl90YWtlQmFja0NvbnRyb2xJbnRlcnBvbGFudCggdGltZVNjYWxlSW50ZXJwb2xhbnQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHQvLyBPYmplY3QgQWNjZXNzb3JzXFxyXFxuXFxyXFxuXFx0XFx0Z2V0TWl4ZXI6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5fbWl4ZXI7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRnZXRDbGlwOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuX2NsaXA7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRnZXRSb290OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuX2xvY2FsUm9vdCB8fCB0aGlzLl9taXhlci5fcm9vdDtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdC8vIEludGVybmFcXHJcXG5cXHJcXG5cXHRcXHRfdXBkYXRlOiBmdW5jdGlvbiAoIHRpbWUsIGRlbHRhVGltZSwgdGltZURpcmVjdGlvbiwgYWNjdUluZGV4ICkge1xcclxcblxcclxcblxcdFxcdFxcdC8vIGNhbGxlZCBieSB0aGUgbWl4ZXJcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoICEgdGhpcy5lbmFibGVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGNhbGwgLl91cGRhdGVXZWlnaHQoKSB0byB1cGRhdGUgLl9lZmZlY3RpdmVXZWlnaHRcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLl91cGRhdGVXZWlnaHQoIHRpbWUgKTtcXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHZhciBzdGFydFRpbWUgPSB0aGlzLl9zdGFydFRpbWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBzdGFydFRpbWUgIT09IG51bGwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gY2hlY2sgZm9yIHNjaGVkdWxlZCBzdGFydCBvZiBhY3Rpb25cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgdGltZVJ1bm5pbmcgPSAoIHRpbWUgLSBzdGFydFRpbWUgKSAqIHRpbWVEaXJlY3Rpb247XFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB0aW1lUnVubmluZyA8IDAgfHwgdGltZURpcmVjdGlvbiA9PT0gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47IC8vIHlldCB0byBjb21lIC8gZG9uJ3QgZGVjaWRlIHdoZW4gZGVsdGEgPSAwXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIHN0YXJ0XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5fc3RhcnRUaW1lID0gbnVsbDsgLy8gdW5zY2hlZHVsZVxcclxcblxcdFxcdFxcdFxcdGRlbHRhVGltZSA9IHRpbWVEaXJlY3Rpb24gKiB0aW1lUnVubmluZztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gYXBwbHkgdGltZSBzY2FsZSBhbmQgYWR2YW5jZSB0aW1lXFxyXFxuXFxyXFxuXFx0XFx0XFx0ZGVsdGFUaW1lICo9IHRoaXMuX3VwZGF0ZVRpbWVTY2FsZSggdGltZSApO1xcclxcblxcdFxcdFxcdHZhciBjbGlwVGltZSA9IHRoaXMuX3VwZGF0ZVRpbWUoIGRlbHRhVGltZSApO1xcclxcblxcclxcblxcdFxcdFxcdC8vIG5vdGU6IF91cGRhdGVUaW1lIG1heSBkaXNhYmxlIHRoZSBhY3Rpb24gcmVzdWx0aW5nIGluXFxyXFxuXFx0XFx0XFx0Ly8gYW4gZWZmZWN0aXZlIHdlaWdodCBvZiAwXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHdlaWdodCA9IHRoaXMuX3VwZGF0ZVdlaWdodCggdGltZSApO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggd2VpZ2h0ID4gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgaW50ZXJwb2xhbnRzID0gdGhpcy5faW50ZXJwb2xhbnRzO1xcclxcblxcdFxcdFxcdFxcdHZhciBwcm9wZXJ0eU1peGVycyA9IHRoaXMuX3Byb3BlcnR5QmluZGluZ3M7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGogPSAwLCBtID0gaW50ZXJwb2xhbnRzLmxlbmd0aDsgaiAhPT0gbTsgKysgaiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpbnRlcnBvbGFudHNbIGogXS5ldmFsdWF0ZSggY2xpcFRpbWUgKTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRwcm9wZXJ0eU1peGVyc1sgaiBdLmFjY3VtdWxhdGUoIGFjY3VJbmRleCwgd2VpZ2h0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdF91cGRhdGVXZWlnaHQ6IGZ1bmN0aW9uICggdGltZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgd2VpZ2h0ID0gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMuZW5hYmxlZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR3ZWlnaHQgPSB0aGlzLndlaWdodDtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgaW50ZXJwb2xhbnQgPSB0aGlzLl93ZWlnaHRJbnRlcnBvbGFudDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGludGVycG9sYW50ICE9PSBudWxsICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBpbnRlcnBvbGFudFZhbHVlID0gaW50ZXJwb2xhbnQuZXZhbHVhdGUoIHRpbWUgKVsgMCBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHdlaWdodCAqPSBpbnRlcnBvbGFudFZhbHVlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggdGltZSA+IGludGVycG9sYW50LnBhcmFtZXRlclBvc2l0aW9uc1sgMSBdICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuc3RvcEZhZGluZygpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggaW50ZXJwb2xhbnRWYWx1ZSA9PT0gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBmYWRlZCBvdXQsIGRpc2FibGVcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmVuYWJsZWQgPSBmYWxzZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5fZWZmZWN0aXZlV2VpZ2h0ID0gd2VpZ2h0O1xcclxcblxcdFxcdFxcdHJldHVybiB3ZWlnaHQ7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRfdXBkYXRlVGltZVNjYWxlOiBmdW5jdGlvbiAoIHRpbWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHRpbWVTY2FsZSA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCAhIHRoaXMucGF1c2VkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRpbWVTY2FsZSA9IHRoaXMudGltZVNjYWxlO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBpbnRlcnBvbGFudCA9IHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50O1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggaW50ZXJwb2xhbnQgIT09IG51bGwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGludGVycG9sYW50VmFsdWUgPSBpbnRlcnBvbGFudC5ldmFsdWF0ZSggdGltZSApWyAwIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGltZVNjYWxlICo9IGludGVycG9sYW50VmFsdWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0aW1lID4gaW50ZXJwb2xhbnQucGFyYW1ldGVyUG9zaXRpb25zWyAxIF0gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5zdG9wV2FycGluZygpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggdGltZVNjYWxlID09PSAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIG1vdGlvbiBoYXMgaGFsdGVkLCBwYXVzZVxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMucGF1c2VkID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHdhcnAgZG9uZSAtIGFwcGx5IGZpbmFsIHRpbWUgc2NhbGVcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnRpbWVTY2FsZSA9IHRpbWVTY2FsZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlID0gdGltZVNjYWxlO1xcclxcblxcdFxcdFxcdHJldHVybiB0aW1lU2NhbGU7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRfdXBkYXRlVGltZTogZnVuY3Rpb24gKCBkZWx0YVRpbWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHRpbWUgPSB0aGlzLnRpbWUgKyBkZWx0YVRpbWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBkZWx0YVRpbWUgPT09IDAgKSByZXR1cm4gdGltZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgZHVyYXRpb24gPSB0aGlzLl9jbGlwLmR1cmF0aW9uLFxcclxcblxcclxcblxcdFxcdFxcdFxcdGxvb3AgPSB0aGlzLmxvb3AsXFxyXFxuXFx0XFx0XFx0XFx0bG9vcENvdW50ID0gdGhpcy5fbG9vcENvdW50O1xcclxcblxcclxcblxcdFxcdFxcdGlmICggbG9vcCA9PT0gTG9vcE9uY2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBsb29wQ291bnQgPT09IC0gMSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBqdXN0IHN0YXJ0ZWRcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9sb29wQ291bnQgPSAwO1xcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3NldEVuZGluZ3MoIHRydWUsIHRydWUsIGZhbHNlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdGhhbmRsZV9zdG9wOiB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0aW1lID49IGR1cmF0aW9uICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHRpbWUgPSBkdXJhdGlvbjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCB0aW1lIDwgMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aW1lID0gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgYnJlYWsgaGFuZGxlX3N0b3A7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0aGlzLmNsYW1wV2hlbkZpbmlzaGVkICkgdGhpcy5wYXVzZWQgPSB0cnVlO1xcclxcblxcdFxcdFxcdFxcdFxcdGVsc2UgdGhpcy5lbmFibGVkID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fbWl4ZXIuZGlzcGF0Y2hFdmVudCgge1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHR5cGU6ICdmaW5pc2hlZCcsIGFjdGlvbjogdGhpcyxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRkaXJlY3Rpb246IGRlbHRhVGltZSA8IDAgPyAtIDEgOiAxXFxyXFxuXFx0XFx0XFx0XFx0XFx0fSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgeyAvLyByZXBldGl0aXZlIFJlcGVhdCBvciBQaW5nUG9uZ1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBwaW5nUG9uZyA9ICggbG9vcCA9PT0gTG9vcFBpbmdQb25nICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBsb29wQ291bnQgPT09IC0gMSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQvLyBqdXN0IHN0YXJ0ZWRcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGRlbHRhVGltZSA+PSAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGxvb3BDb3VudCA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fc2V0RW5kaW5ncyggdHJ1ZSwgdGhpcy5yZXBldGl0aW9ucyA9PT0gMCwgcGluZ1BvbmcgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHdoZW4gbG9vcGluZyBpbiByZXZlcnNlIGRpcmVjdGlvbiwgdGhlIGluaXRpYWxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyB0cmFuc2l0aW9uIHRocm91Z2ggemVybyBjb3VudHMgYXMgYSByZXBldGl0aW9uLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHNvIGxlYXZlIGxvb3BDb3VudCBhdCAtMVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX3NldEVuZGluZ3MoIHRoaXMucmVwZXRpdGlvbnMgPT09IDAsIHRydWUsIHBpbmdQb25nICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIHRpbWUgPj0gZHVyYXRpb24gfHwgdGltZSA8IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gd3JhcCBhcm91bmRcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgbG9vcERlbHRhID0gTWF0aC5mbG9vciggdGltZSAvIGR1cmF0aW9uICk7IC8vIHNpZ25lZFxcclxcblxcdFxcdFxcdFxcdFxcdHRpbWUgLT0gZHVyYXRpb24gKiBsb29wRGVsdGE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0bG9vcENvdW50ICs9IE1hdGguYWJzKCBsb29wRGVsdGEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgcGVuZGluZyA9IHRoaXMucmVwZXRpdGlvbnMgLSBsb29wQ291bnQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBwZW5kaW5nIDwgMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBoYXZlIHRvIHN0b3AgKHN3aXRjaCBzdGF0ZSwgY2xhbXAgdGltZSwgZmlyZSBldmVudClcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHRoaXMuY2xhbXBXaGVuRmluaXNoZWQgKSB0aGlzLnBhdXNlZCA9IHRydWU7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxzZSB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aW1lID0gZGVsdGFUaW1lID4gMCA/IGR1cmF0aW9uIDogMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9taXhlci5kaXNwYXRjaEV2ZW50KCB7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dHlwZTogJ2ZpbmlzaGVkJywgYWN0aW9uOiB0aGlzLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRpcmVjdGlvbjogZGVsdGFUaW1lID4gMCA/IDEgOiAtIDFcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBrZWVwIHJ1bm5pbmdcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHBlbmRpbmcgPT09IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gZW50ZXJpbmcgdGhlIGxhc3Qgcm91bmRcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgYXRTdGFydCA9IGRlbHRhVGltZSA8IDA7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fc2V0RW5kaW5ncyggYXRTdGFydCwgISBhdFN0YXJ0LCBwaW5nUG9uZyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fc2V0RW5kaW5ncyggZmFsc2UsIGZhbHNlLCBwaW5nUG9uZyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9sb29wQ291bnQgPSBsb29wQ291bnQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fbWl4ZXIuZGlzcGF0Y2hFdmVudCgge1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHR5cGU6ICdsb29wJywgYWN0aW9uOiB0aGlzLCBsb29wRGVsdGE6IGxvb3BEZWx0YVxcclxcblxcdFxcdFxcdFxcdFxcdFxcdH0gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggcGluZ1BvbmcgJiYgKCBsb29wQ291bnQgJiAxICkgPT09IDEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gaW52ZXJ0IHRpbWUgZm9yIHRoZSBcXFwicG9uZyByb3VuZFxcXCJcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnRpbWUgPSB0aW1lO1xcclxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBkdXJhdGlvbiAtIHRpbWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnRpbWUgPSB0aW1lO1xcclxcblxcdFxcdFxcdHJldHVybiB0aW1lO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0X3NldEVuZGluZ3M6IGZ1bmN0aW9uICggYXRTdGFydCwgYXRFbmQsIHBpbmdQb25nICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBzZXR0aW5ncyA9IHRoaXMuX2ludGVycG9sYW50U2V0dGluZ3M7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBwaW5nUG9uZyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzZXR0aW5ncy5lbmRpbmdTdGFydCBcXHQ9IFplcm9TbG9wZUVuZGluZztcXHJcXG5cXHRcXHRcXHRcXHRzZXR0aW5ncy5lbmRpbmdFbmRcXHRcXHQ9IFplcm9TbG9wZUVuZGluZztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGFzc3VtaW5nIGZvciBMb29wT25jZSBhdFN0YXJ0ID09IGF0RW5kID09IHRydWVcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGF0U3RhcnQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0c2V0dGluZ3MuZW5kaW5nU3RhcnQgPSB0aGlzLnplcm9TbG9wZUF0U3RhcnQgPyBaZXJvU2xvcGVFbmRpbmcgOiBaZXJvQ3VydmF0dXJlRW5kaW5nO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0c2V0dGluZ3MuZW5kaW5nU3RhcnQgPSBXcmFwQXJvdW5kRW5kaW5nO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGF0RW5kICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHNldHRpbmdzLmVuZGluZ0VuZCA9IHRoaXMuemVyb1Nsb3BlQXRFbmQgPyBaZXJvU2xvcGVFbmRpbmcgOiBaZXJvQ3VydmF0dXJlRW5kaW5nO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0c2V0dGluZ3MuZW5kaW5nRW5kIFxcdCA9IFdyYXBBcm91bmRFbmRpbmc7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdF9zY2hlZHVsZUZhZGluZzogZnVuY3Rpb24gKCBkdXJhdGlvbiwgd2VpZ2h0Tm93LCB3ZWlnaHRUaGVuICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBtaXhlciA9IHRoaXMuX21peGVyLCBub3cgPSBtaXhlci50aW1lLFxcclxcblxcdFxcdFxcdFxcdGludGVycG9sYW50ID0gdGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBpbnRlcnBvbGFudCA9PT0gbnVsbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpbnRlcnBvbGFudCA9IG1peGVyLl9sZW5kQ29udHJvbEludGVycG9sYW50KCk7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQgPSBpbnRlcnBvbGFudDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHRpbWVzID0gaW50ZXJwb2xhbnQucGFyYW1ldGVyUG9zaXRpb25zLFxcclxcblxcdFxcdFxcdFxcdHZhbHVlcyA9IGludGVycG9sYW50LnNhbXBsZVZhbHVlcztcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aW1lc1sgMCBdID0gbm93OyBcXHRcXHRcXHRcXHR2YWx1ZXNbIDAgXSA9IHdlaWdodE5vdztcXHJcXG5cXHRcXHRcXHR0aW1lc1sgMSBdID0gbm93ICsgZHVyYXRpb247XFx0dmFsdWVzWyAxIF0gPSB3ZWlnaHRUaGVuO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBQbGF5ZXIgZm9yIEFuaW1hdGlvbkNsaXBzLlxcclxcblxcdCAqXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xcclxcblxcdCAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xcclxcblxcdCAqIEBhdXRob3IgdHNjaHdcXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBBbmltYXRpb25NaXhlciggcm9vdCApIHtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLl9yb290ID0gcm9vdDtcXHJcXG5cXHRcXHR0aGlzLl9pbml0TWVtb3J5TWFuYWdlcigpO1xcclxcblxcdFxcdHRoaXMuX2FjY3VJbmRleCA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50aW1lID0gMDtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnRpbWVTY2FsZSA9IDEuMDtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0QW5pbWF0aW9uTWl4ZXIucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSApLCB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc3RydWN0b3I6IEFuaW1hdGlvbk1peGVyLFxcclxcblxcclxcblxcdFxcdF9iaW5kQWN0aW9uOiBmdW5jdGlvbiAoIGFjdGlvbiwgcHJvdG90eXBlQWN0aW9uICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciByb290ID0gYWN0aW9uLl9sb2NhbFJvb3QgfHwgdGhpcy5fcm9vdCxcXHJcXG5cXHRcXHRcXHRcXHR0cmFja3MgPSBhY3Rpb24uX2NsaXAudHJhY2tzLFxcclxcblxcdFxcdFxcdFxcdG5UcmFja3MgPSB0cmFja3MubGVuZ3RoLFxcclxcblxcdFxcdFxcdFxcdGJpbmRpbmdzID0gYWN0aW9uLl9wcm9wZXJ0eUJpbmRpbmdzLFxcclxcblxcdFxcdFxcdFxcdGludGVycG9sYW50cyA9IGFjdGlvbi5faW50ZXJwb2xhbnRzLFxcclxcblxcdFxcdFxcdFxcdHJvb3RVdWlkID0gcm9vdC51dWlkLFxcclxcblxcdFxcdFxcdFxcdGJpbmRpbmdzQnlSb290ID0gdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lLFxcclxcblxcdFxcdFxcdFxcdGJpbmRpbmdzQnlOYW1lID0gYmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBiaW5kaW5nc0J5TmFtZSA9PT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGJpbmRpbmdzQnlOYW1lID0ge307XFxyXFxuXFx0XFx0XFx0XFx0YmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF0gPSBiaW5kaW5nc0J5TmFtZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuVHJhY2tzOyArKyBpICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciB0cmFjayA9IHRyYWNrc1sgaSBdLFxcclxcblxcdFxcdFxcdFxcdFxcdHRyYWNrTmFtZSA9IHRyYWNrLm5hbWUsXFxyXFxuXFx0XFx0XFx0XFx0XFx0YmluZGluZyA9IGJpbmRpbmdzQnlOYW1lWyB0cmFja05hbWUgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGJpbmRpbmcgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRiaW5kaW5nc1sgaSBdID0gYmluZGluZztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGJpbmRpbmcgPSBiaW5kaW5nc1sgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlmICggYmluZGluZyAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGV4aXN0aW5nIGJpbmRpbmcsIG1ha2Ugc3VyZSB0aGUgY2FjaGUga25vd3NcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGJpbmRpbmcuX2NhY2hlSW5kZXggPT09IG51bGwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0KysgYmluZGluZy5yZWZlcmVuY2VDb3VudDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9hZGRJbmFjdGl2ZUJpbmRpbmcoIGJpbmRpbmcsIHJvb3RVdWlkLCB0cmFja05hbWUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29udGludWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBwYXRoID0gcHJvdG90eXBlQWN0aW9uICYmIHByb3RvdHlwZUFjdGlvbi5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRfcHJvcGVydHlCaW5kaW5nc1sgaSBdLmJpbmRpbmcucGFyc2VkUGF0aDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRiaW5kaW5nID0gbmV3IFByb3BlcnR5TWl4ZXIoXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0UHJvcGVydHlCaW5kaW5nLmNyZWF0ZSggcm9vdCwgdHJhY2tOYW1lLCBwYXRoICksXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0dHJhY2suVmFsdWVUeXBlTmFtZSwgdHJhY2suZ2V0VmFsdWVTaXplKCkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHQrKyBiaW5kaW5nLnJlZmVyZW5jZUNvdW50O1xcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2FkZEluYWN0aXZlQmluZGluZyggYmluZGluZywgcm9vdFV1aWQsIHRyYWNrTmFtZSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGJpbmRpbmdzWyBpIF0gPSBiaW5kaW5nO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpbnRlcnBvbGFudHNbIGkgXS5yZXN1bHRCdWZmZXIgPSBiaW5kaW5nLmJ1ZmZlcjtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRfYWN0aXZhdGVBY3Rpb246IGZ1bmN0aW9uICggYWN0aW9uICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggISB0aGlzLl9pc0FjdGl2ZUFjdGlvbiggYWN0aW9uICkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBhY3Rpb24uX2NhY2hlSW5kZXggPT09IG51bGwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdGhpcyBhY3Rpb24gaGFzIGJlZW4gZm9yZ290dGVuIGJ5IHRoZSBjYWNoZSwgYnV0IHRoZSB1c2VyXFxyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gYXBwZWFycyB0byBiZSBzdGlsbCB1c2luZyBpdCAtPiByZWJpbmRcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgcm9vdFV1aWQgPSAoIGFjdGlvbi5fbG9jYWxSb290IHx8IHRoaXMuX3Jvb3QgKS51dWlkLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGNsaXBVdWlkID0gYWN0aW9uLl9jbGlwLnV1aWQsXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0YWN0aW9uc0ZvckNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2JpbmRBY3Rpb24oIGFjdGlvbixcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRhY3Rpb25zRm9yQ2xpcCAmJiBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnNbIDAgXSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2FkZEluYWN0aXZlQWN0aW9uKCBhY3Rpb24sIGNsaXBVdWlkLCByb290VXVpZCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgYmluZGluZ3MgPSBhY3Rpb24uX3Byb3BlcnR5QmluZGluZ3M7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gaW5jcmVtZW50IHJlZmVyZW5jZSBjb3VudHMgLyBzb3J0IG91dCBzdGF0ZVxcclxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgYmluZGluZyA9IGJpbmRpbmdzWyBpIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBiaW5kaW5nLnVzZUNvdW50ICsrID09PSAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2xlbmRCaW5kaW5nKCBiaW5kaW5nICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0YmluZGluZy5zYXZlT3JpZ2luYWxTdGF0ZSgpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5fbGVuZEFjdGlvbiggYWN0aW9uICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0X2RlYWN0aXZhdGVBY3Rpb246IGZ1bmN0aW9uICggYWN0aW9uICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdGhpcy5faXNBY3RpdmVBY3Rpb24oIGFjdGlvbiApICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBiaW5kaW5ncyA9IGFjdGlvbi5fcHJvcGVydHlCaW5kaW5ncztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBkZWNyZW1lbnQgcmVmZXJlbmNlIGNvdW50cyAvIHNvcnQgb3V0IHN0YXRlXFxyXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBiaW5kaW5nID0gYmluZGluZ3NbIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIC0tIGJpbmRpbmcudXNlQ291bnQgPT09IDAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0YmluZGluZy5yZXN0b3JlT3JpZ2luYWxTdGF0ZSgpO1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX3Rha2VCYWNrQmluZGluZyggYmluZGluZyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5fdGFrZUJhY2tBY3Rpb24oIGFjdGlvbiApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdC8vIE1lbW9yeSBtYW5hZ2VyXFxyXFxuXFxyXFxuXFx0XFx0X2luaXRNZW1vcnlNYW5hZ2VyOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5fYWN0aW9ucyA9IFtdOyAvLyAnbkFjdGl2ZUFjdGlvbnMnIGZvbGxvd2VkIGJ5IGluYWN0aXZlIG9uZXNcXHJcXG5cXHRcXHRcXHR0aGlzLl9uQWN0aXZlQWN0aW9ucyA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5fYWN0aW9uc0J5Q2xpcCA9IHt9O1xcclxcblxcdFxcdFxcdC8vIGluc2lkZTpcXHJcXG5cXHRcXHRcXHQvLyB7XFxyXFxuXFx0XFx0XFx0Ly8gXFx0XFx0a25vd25BY3Rpb25zOiBBcnJheTwgQW5pbWF0aW9uQWN0aW9uID5cXHQtIHVzZWQgYXMgcHJvdG90eXBlc1xcclxcblxcdFxcdFxcdC8vIFxcdFxcdGFjdGlvbkJ5Um9vdDogQW5pbWF0aW9uQWN0aW9uXFx0XFx0XFx0LSBsb29rdXBcXHJcXG5cXHRcXHRcXHQvLyB9XFxyXFxuXFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5fYmluZGluZ3MgPSBbXTsgLy8gJ25BY3RpdmVCaW5kaW5ncycgZm9sbG93ZWQgYnkgaW5hY3RpdmUgb25lc1xcclxcblxcdFxcdFxcdHRoaXMuX25BY3RpdmVCaW5kaW5ncyA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lID0ge307IC8vIGluc2lkZTogTWFwPCBuYW1lLCBQcm9wZXJ0eU1peGVyID5cXHJcXG5cXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLl9jb250cm9sSW50ZXJwb2xhbnRzID0gW107IC8vIHNhbWUgZ2FtZSBhcyBhYm92ZVxcclxcblxcdFxcdFxcdHRoaXMuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzID0gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgc2NvcGUgPSB0aGlzO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuc3RhdHMgPSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YWN0aW9uczoge1xcclxcblxcdFxcdFxcdFxcdFxcdGdldCB0b3RhbCgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gc2NvcGUuX2FjdGlvbnMubGVuZ3RoO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH0sXFxyXFxuXFx0XFx0XFx0XFx0XFx0Z2V0IGluVXNlKCkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBzY29wZS5fbkFjdGl2ZUFjdGlvbnM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcdFxcdFxcdFxcdH0sXFxyXFxuXFx0XFx0XFx0XFx0YmluZGluZ3M6IHtcXHJcXG5cXHRcXHRcXHRcXHRcXHRnZXQgdG90YWwoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHNjb3BlLl9iaW5kaW5ncy5sZW5ndGg7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fSxcXHJcXG5cXHRcXHRcXHRcXHRcXHRnZXQgaW5Vc2UoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHNjb3BlLl9uQWN0aXZlQmluZGluZ3M7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcdFxcdFxcdFxcdH0sXFxyXFxuXFx0XFx0XFx0XFx0Y29udHJvbEludGVycG9sYW50czoge1xcclxcblxcdFxcdFxcdFxcdFxcdGdldCB0b3RhbCgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gc2NvcGUuX2NvbnRyb2xJbnRlcnBvbGFudHMubGVuZ3RoO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH0sXFxyXFxuXFx0XFx0XFx0XFx0XFx0Z2V0IGluVXNlKCkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBzY29wZS5fbkFjdGl2ZUNvbnRyb2xJbnRlcnBvbGFudHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Ly8gTWVtb3J5IG1hbmFnZW1lbnQgZm9yIEFuaW1hdGlvbkFjdGlvbiBvYmplY3RzXFxyXFxuXFxyXFxuXFx0XFx0X2lzQWN0aXZlQWN0aW9uOiBmdW5jdGlvbiAoIGFjdGlvbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgaW5kZXggPSBhY3Rpb24uX2NhY2hlSW5kZXg7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIGluZGV4ICE9PSBudWxsICYmIGluZGV4IDwgdGhpcy5fbkFjdGl2ZUFjdGlvbnM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRfYWRkSW5hY3RpdmVBY3Rpb246IGZ1bmN0aW9uICggYWN0aW9uLCBjbGlwVXVpZCwgcm9vdFV1aWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxcclxcblxcdFxcdFxcdFxcdGFjdGlvbnNCeUNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwLFxcclxcblxcdFxcdFxcdFxcdGFjdGlvbnNGb3JDbGlwID0gYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGFjdGlvbnNGb3JDbGlwID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YWN0aW9uc0ZvckNsaXAgPSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0a25vd25BY3Rpb25zOiBbIGFjdGlvbiBdLFxcclxcblxcdFxcdFxcdFxcdFxcdGFjdGlvbkJ5Um9vdDoge31cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdFxcdFxcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXSA9IGFjdGlvbnNGb3JDbGlwO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGtub3duQWN0aW9ucyA9IGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9ucztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRhY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXggPSBrbm93bkFjdGlvbnMubGVuZ3RoO1xcclxcblxcdFxcdFxcdFxcdGtub3duQWN0aW9ucy5wdXNoKCBhY3Rpb24gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0YWN0aW9uLl9jYWNoZUluZGV4ID0gYWN0aW9ucy5sZW5ndGg7XFxyXFxuXFx0XFx0XFx0YWN0aW9ucy5wdXNoKCBhY3Rpb24gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRhY3Rpb25zRm9yQ2xpcC5hY3Rpb25CeVJvb3RbIHJvb3RVdWlkIF0gPSBhY3Rpb247XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRfcmVtb3ZlSW5hY3RpdmVBY3Rpb246IGZ1bmN0aW9uICggYWN0aW9uICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcXHJcXG5cXHRcXHRcXHRcXHRsYXN0SW5hY3RpdmVBY3Rpb24gPSBhY3Rpb25zWyBhY3Rpb25zLmxlbmd0aCAtIDEgXSxcXHJcXG5cXHRcXHRcXHRcXHRjYWNoZUluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4O1xcclxcblxcclxcblxcdFxcdFxcdGxhc3RJbmFjdGl2ZUFjdGlvbi5fY2FjaGVJbmRleCA9IGNhY2hlSW5kZXg7XFxyXFxuXFx0XFx0XFx0YWN0aW9uc1sgY2FjaGVJbmRleCBdID0gbGFzdEluYWN0aXZlQWN0aW9uO1xcclxcblxcdFxcdFxcdGFjdGlvbnMucG9wKCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0YWN0aW9uLl9jYWNoZUluZGV4ID0gbnVsbDtcXHJcXG5cXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgY2xpcFV1aWQgPSBhY3Rpb24uX2NsaXAudXVpZCxcXHJcXG5cXHRcXHRcXHRcXHRhY3Rpb25zQnlDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcCxcXHJcXG5cXHRcXHRcXHRcXHRhY3Rpb25zRm9yQ2xpcCA9IGFjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF0sXFxyXFxuXFx0XFx0XFx0XFx0a25vd25BY3Rpb25zRm9yQ2xpcCA9IGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9ucyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRsYXN0S25vd25BY3Rpb24gPVxcclxcblxcdFxcdFxcdFxcdFxcdGtub3duQWN0aW9uc0ZvckNsaXBbIGtub3duQWN0aW9uc0ZvckNsaXAubGVuZ3RoIC0gMSBdLFxcclxcblxcclxcblxcdFxcdFxcdFxcdGJ5Q2xpcENhY2hlSW5kZXggPSBhY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXg7XFxyXFxuXFxyXFxuXFx0XFx0XFx0bGFzdEtub3duQWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4ID0gYnlDbGlwQ2FjaGVJbmRleDtcXHJcXG5cXHRcXHRcXHRrbm93bkFjdGlvbnNGb3JDbGlwWyBieUNsaXBDYWNoZUluZGV4IF0gPSBsYXN0S25vd25BY3Rpb247XFxyXFxuXFx0XFx0XFx0a25vd25BY3Rpb25zRm9yQ2xpcC5wb3AoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRhY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXggPSBudWxsO1xcclxcblxcclxcblxcclxcblxcdFxcdFxcdHZhciBhY3Rpb25CeVJvb3QgPSBhY3Rpb25zRm9yQ2xpcC5hY3Rpb25CeVJvb3QsXFxyXFxuXFx0XFx0XFx0XFx0cm9vdFV1aWQgPSAoIGFjdGlvbi5fbG9jYWxSb290IHx8IHRoaXMuX3Jvb3QgKS51dWlkO1xcclxcblxcclxcblxcdFxcdFxcdGRlbGV0ZSBhY3Rpb25CeVJvb3RbIHJvb3RVdWlkIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBrbm93bkFjdGlvbnNGb3JDbGlwLmxlbmd0aCA9PT0gMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRkZWxldGUgYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nc0ZvckFjdGlvbiggYWN0aW9uICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRfcmVtb3ZlSW5hY3RpdmVCaW5kaW5nc0ZvckFjdGlvbjogZnVuY3Rpb24gKCBhY3Rpb24gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGJpbmRpbmdzID0gYWN0aW9uLl9wcm9wZXJ0eUJpbmRpbmdzO1xcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgYmluZGluZyA9IGJpbmRpbmdzWyBpIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCAtLSBiaW5kaW5nLnJlZmVyZW5jZUNvdW50ID09PSAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZyggYmluZGluZyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRfbGVuZEFjdGlvbjogZnVuY3Rpb24gKCBhY3Rpb24gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gWyBhY3RpdmUgYWN0aW9ucyB8ICBpbmFjdGl2ZSBhY3Rpb25zICBdXFxyXFxuXFx0XFx0XFx0Ly8gWyAgYWN0aXZlIGFjdGlvbnMgPnwgaW5hY3RpdmUgYWN0aW9ucyBdXFxyXFxuXFx0XFx0XFx0Ly8gICAgICAgICAgICAgICAgIHMgICAgICAgIGFcXHJcXG5cXHRcXHRcXHQvLyAgICAgICAgICAgICAgICAgIDwtc3dhcC0+XFxyXFxuXFx0XFx0XFx0Ly8gICAgICAgICAgICAgICAgIGEgICAgICAgIHNcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXFxyXFxuXFx0XFx0XFx0XFx0cHJldkluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4LFxcclxcblxcclxcblxcdFxcdFxcdFxcdGxhc3RBY3RpdmVJbmRleCA9IHRoaXMuX25BY3RpdmVBY3Rpb25zICsrLFxcclxcblxcclxcblxcdFxcdFxcdFxcdGZpcnN0SW5hY3RpdmVBY3Rpb24gPSBhY3Rpb25zWyBsYXN0QWN0aXZlSW5kZXggXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRhY3Rpb24uX2NhY2hlSW5kZXggPSBsYXN0QWN0aXZlSW5kZXg7XFxyXFxuXFx0XFx0XFx0YWN0aW9uc1sgbGFzdEFjdGl2ZUluZGV4IF0gPSBhY3Rpb247XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zmlyc3RJbmFjdGl2ZUFjdGlvbi5fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcXHJcXG5cXHRcXHRcXHRhY3Rpb25zWyBwcmV2SW5kZXggXSA9IGZpcnN0SW5hY3RpdmVBY3Rpb247XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRfdGFrZUJhY2tBY3Rpb246IGZ1bmN0aW9uICggYWN0aW9uICkge1xcclxcblxcclxcblxcdFxcdFxcdC8vIFsgIGFjdGl2ZSBhY3Rpb25zICB8IGluYWN0aXZlIGFjdGlvbnMgXVxcclxcblxcdFxcdFxcdC8vIFsgYWN0aXZlIGFjdGlvbnMgfDwgaW5hY3RpdmUgYWN0aW9ucyAgXVxcclxcblxcdFxcdFxcdC8vICAgICAgICBhICAgICAgICBzXFxyXFxuXFx0XFx0XFx0Ly8gICAgICAgICA8LXN3YXAtPlxcclxcblxcdFxcdFxcdC8vICAgICAgICBzICAgICAgICBhXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxcclxcblxcdFxcdFxcdFxcdHByZXZJbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleCxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmaXJzdEluYWN0aXZlSW5kZXggPSAtLSB0aGlzLl9uQWN0aXZlQWN0aW9ucyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRsYXN0QWN0aXZlQWN0aW9uID0gYWN0aW9uc1sgZmlyc3RJbmFjdGl2ZUluZGV4IF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0YWN0aW9uLl9jYWNoZUluZGV4ID0gZmlyc3RJbmFjdGl2ZUluZGV4O1xcclxcblxcdFxcdFxcdGFjdGlvbnNbIGZpcnN0SW5hY3RpdmVJbmRleCBdID0gYWN0aW9uO1xcclxcblxcclxcblxcdFxcdFxcdGxhc3RBY3RpdmVBY3Rpb24uX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XFxyXFxuXFx0XFx0XFx0YWN0aW9uc1sgcHJldkluZGV4IF0gPSBsYXN0QWN0aXZlQWN0aW9uO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Ly8gTWVtb3J5IG1hbmFnZW1lbnQgZm9yIFByb3BlcnR5TWl4ZXIgb2JqZWN0c1xcclxcblxcclxcblxcdFxcdF9hZGRJbmFjdGl2ZUJpbmRpbmc6IGZ1bmN0aW9uICggYmluZGluZywgcm9vdFV1aWQsIHRyYWNrTmFtZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgYmluZGluZ3NCeVJvb3QgPSB0aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWUsXFxyXFxuXFx0XFx0XFx0XFx0YmluZGluZ0J5TmFtZSA9IGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdLFxcclxcblxcclxcblxcdFxcdFxcdFxcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBiaW5kaW5nQnlOYW1lID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YmluZGluZ0J5TmFtZSA9IHt9O1xcclxcblxcdFxcdFxcdFxcdGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdID0gYmluZGluZ0J5TmFtZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0YmluZGluZ0J5TmFtZVsgdHJhY2tOYW1lIF0gPSBiaW5kaW5nO1xcclxcblxcclxcblxcdFxcdFxcdGJpbmRpbmcuX2NhY2hlSW5kZXggPSBiaW5kaW5ncy5sZW5ndGg7XFxyXFxuXFx0XFx0XFx0YmluZGluZ3MucHVzaCggYmluZGluZyApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0X3JlbW92ZUluYWN0aXZlQmluZGluZzogZnVuY3Rpb24gKCBiaW5kaW5nICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxcclxcblxcdFxcdFxcdFxcdHByb3BCaW5kaW5nID0gYmluZGluZy5iaW5kaW5nLFxcclxcblxcdFxcdFxcdFxcdHJvb3RVdWlkID0gcHJvcEJpbmRpbmcucm9vdE5vZGUudXVpZCxcXHJcXG5cXHRcXHRcXHRcXHR0cmFja05hbWUgPSBwcm9wQmluZGluZy5wYXRoLFxcclxcblxcdFxcdFxcdFxcdGJpbmRpbmdzQnlSb290ID0gdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lLFxcclxcblxcdFxcdFxcdFxcdGJpbmRpbmdCeU5hbWUgPSBiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXSxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRsYXN0SW5hY3RpdmVCaW5kaW5nID0gYmluZGluZ3NbIGJpbmRpbmdzLmxlbmd0aCAtIDEgXSxcXHJcXG5cXHRcXHRcXHRcXHRjYWNoZUluZGV4ID0gYmluZGluZy5fY2FjaGVJbmRleDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRsYXN0SW5hY3RpdmVCaW5kaW5nLl9jYWNoZUluZGV4ID0gY2FjaGVJbmRleDtcXHJcXG5cXHRcXHRcXHRiaW5kaW5nc1sgY2FjaGVJbmRleCBdID0gbGFzdEluYWN0aXZlQmluZGluZztcXHJcXG5cXHRcXHRcXHRiaW5kaW5ncy5wb3AoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRkZWxldGUgYmluZGluZ0J5TmFtZVsgdHJhY2tOYW1lIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmVtb3ZlX2VtcHR5X21hcDoge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBfIGluIGJpbmRpbmdCeU5hbWUgKSBicmVhayByZW1vdmVfZW1wdHlfbWFwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZGVsZXRlIGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdF9sZW5kQmluZGluZzogZnVuY3Rpb24gKCBiaW5kaW5nICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxcclxcblxcdFxcdFxcdFxcdHByZXZJbmRleCA9IGJpbmRpbmcuX2NhY2hlSW5kZXgsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0bGFzdEFjdGl2ZUluZGV4ID0gdGhpcy5fbkFjdGl2ZUJpbmRpbmdzICsrLFxcclxcblxcclxcblxcdFxcdFxcdFxcdGZpcnN0SW5hY3RpdmVCaW5kaW5nID0gYmluZGluZ3NbIGxhc3RBY3RpdmVJbmRleCBdO1xcclxcblxcclxcblxcdFxcdFxcdGJpbmRpbmcuX2NhY2hlSW5kZXggPSBsYXN0QWN0aXZlSW5kZXg7XFxyXFxuXFx0XFx0XFx0YmluZGluZ3NbIGxhc3RBY3RpdmVJbmRleCBdID0gYmluZGluZztcXHJcXG5cXHJcXG5cXHRcXHRcXHRmaXJzdEluYWN0aXZlQmluZGluZy5fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcXHJcXG5cXHRcXHRcXHRiaW5kaW5nc1sgcHJldkluZGV4IF0gPSBmaXJzdEluYWN0aXZlQmluZGluZztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdF90YWtlQmFja0JpbmRpbmc6IGZ1bmN0aW9uICggYmluZGluZyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcXHJcXG5cXHRcXHRcXHRcXHRwcmV2SW5kZXggPSBiaW5kaW5nLl9jYWNoZUluZGV4LFxcclxcblxcclxcblxcdFxcdFxcdFxcdGZpcnN0SW5hY3RpdmVJbmRleCA9IC0tIHRoaXMuX25BY3RpdmVCaW5kaW5ncyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRsYXN0QWN0aXZlQmluZGluZyA9IGJpbmRpbmdzWyBmaXJzdEluYWN0aXZlSW5kZXggXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRiaW5kaW5nLl9jYWNoZUluZGV4ID0gZmlyc3RJbmFjdGl2ZUluZGV4O1xcclxcblxcdFxcdFxcdGJpbmRpbmdzWyBmaXJzdEluYWN0aXZlSW5kZXggXSA9IGJpbmRpbmc7XFxyXFxuXFxyXFxuXFx0XFx0XFx0bGFzdEFjdGl2ZUJpbmRpbmcuX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XFxyXFxuXFx0XFx0XFx0YmluZGluZ3NbIHByZXZJbmRleCBdID0gbGFzdEFjdGl2ZUJpbmRpbmc7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHJcXG5cXHRcXHQvLyBNZW1vcnkgbWFuYWdlbWVudCBvZiBJbnRlcnBvbGFudHMgZm9yIHdlaWdodCBhbmQgdGltZSBzY2FsZVxcclxcblxcclxcblxcdFxcdF9sZW5kQ29udHJvbEludGVycG9sYW50OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGludGVycG9sYW50cyA9IHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHMsXFxyXFxuXFx0XFx0XFx0XFx0bGFzdEFjdGl2ZUluZGV4ID0gdGhpcy5fbkFjdGl2ZUNvbnRyb2xJbnRlcnBvbGFudHMgKyssXFxyXFxuXFx0XFx0XFx0XFx0aW50ZXJwb2xhbnQgPSBpbnRlcnBvbGFudHNbIGxhc3RBY3RpdmVJbmRleCBdO1xcclxcblxcclxcblxcdFxcdFxcdGlmICggaW50ZXJwb2xhbnQgPT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpbnRlcnBvbGFudCA9IG5ldyBMaW5lYXJJbnRlcnBvbGFudChcXHJcXG5cXHRcXHRcXHRcXHRcXHRuZXcgRmxvYXQzMkFycmF5KCAyICksIG5ldyBGbG9hdDMyQXJyYXkoIDIgKSxcXHJcXG5cXHRcXHRcXHRcXHRcXHQxLCB0aGlzLl9jb250cm9sSW50ZXJwb2xhbnRzUmVzdWx0QnVmZmVyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aW50ZXJwb2xhbnQuX19jYWNoZUluZGV4ID0gbGFzdEFjdGl2ZUluZGV4O1xcclxcblxcdFxcdFxcdFxcdGludGVycG9sYW50c1sgbGFzdEFjdGl2ZUluZGV4IF0gPSBpbnRlcnBvbGFudDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGludGVycG9sYW50O1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0X3Rha2VCYWNrQ29udHJvbEludGVycG9sYW50OiBmdW5jdGlvbiAoIGludGVycG9sYW50ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBpbnRlcnBvbGFudHMgPSB0aGlzLl9jb250cm9sSW50ZXJwb2xhbnRzLFxcclxcblxcdFxcdFxcdFxcdHByZXZJbmRleCA9IGludGVycG9sYW50Ll9fY2FjaGVJbmRleCxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmaXJzdEluYWN0aXZlSW5kZXggPSAtLSB0aGlzLl9uQWN0aXZlQ29udHJvbEludGVycG9sYW50cyxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRsYXN0QWN0aXZlSW50ZXJwb2xhbnQgPSBpbnRlcnBvbGFudHNbIGZpcnN0SW5hY3RpdmVJbmRleCBdO1xcclxcblxcclxcblxcdFxcdFxcdGludGVycG9sYW50Ll9fY2FjaGVJbmRleCA9IGZpcnN0SW5hY3RpdmVJbmRleDtcXHJcXG5cXHRcXHRcXHRpbnRlcnBvbGFudHNbIGZpcnN0SW5hY3RpdmVJbmRleCBdID0gaW50ZXJwb2xhbnQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0bGFzdEFjdGl2ZUludGVycG9sYW50Ll9fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcXHJcXG5cXHRcXHRcXHRpbnRlcnBvbGFudHNbIHByZXZJbmRleCBdID0gbGFzdEFjdGl2ZUludGVycG9sYW50O1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0X2NvbnRyb2xJbnRlcnBvbGFudHNSZXN1bHRCdWZmZXI6IG5ldyBGbG9hdDMyQXJyYXkoIDEgKSxcXHJcXG5cXHJcXG5cXHRcXHQvLyByZXR1cm4gYW4gYWN0aW9uIGZvciBhIGNsaXAgb3B0aW9uYWxseSB1c2luZyBhIGN1c3RvbSByb290IHRhcmdldFxcclxcblxcdFxcdC8vIG9iamVjdCAodGhpcyBtZXRob2QgYWxsb2NhdGVzIGEgbG90IG9mIGR5bmFtaWMgbWVtb3J5IGluIGNhc2UgYVxcclxcblxcdFxcdC8vIHByZXZpb3VzbHkgdW5rbm93biBjbGlwL3Jvb3QgY29tYmluYXRpb24gaXMgc3BlY2lmaWVkKVxcclxcblxcdFxcdGNsaXBBY3Rpb246IGZ1bmN0aW9uICggY2xpcCwgb3B0aW9uYWxSb290ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciByb290ID0gb3B0aW9uYWxSb290IHx8IHRoaXMuX3Jvb3QsXFxyXFxuXFx0XFx0XFx0XFx0cm9vdFV1aWQgPSByb290LnV1aWQsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y2xpcE9iamVjdCA9IHR5cGVvZiBjbGlwID09PSAnc3RyaW5nJyA/XFxyXFxuXFx0XFx0XFx0XFx0XFx0QW5pbWF0aW9uQ2xpcC5maW5kQnlOYW1lKCByb290LCBjbGlwICkgOiBjbGlwLFxcclxcblxcclxcblxcdFxcdFxcdFxcdGNsaXBVdWlkID0gY2xpcE9iamVjdCAhPT0gbnVsbCA/IGNsaXBPYmplY3QudXVpZCA6IGNsaXAsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YWN0aW9uc0ZvckNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdLFxcclxcblxcdFxcdFxcdFxcdHByb3RvdHlwZUFjdGlvbiA9IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBhY3Rpb25zRm9yQ2xpcCAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBleGlzdGluZ0FjdGlvbiA9XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0YWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290WyByb290VXVpZCBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggZXhpc3RpbmdBY3Rpb24gIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZXhpc3RpbmdBY3Rpb247XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIHdlIGtub3cgdGhlIGNsaXAsIHNvIHdlIGRvbid0IGhhdmUgdG8gcGFyc2UgYWxsXFxyXFxuXFx0XFx0XFx0XFx0Ly8gdGhlIGJpbmRpbmdzIGFnYWluIGJ1dCBjYW4ganVzdCBjb3B5XFxyXFxuXFx0XFx0XFx0XFx0cHJvdG90eXBlQWN0aW9uID0gYWN0aW9uc0ZvckNsaXAua25vd25BY3Rpb25zWyAwIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ly8gYWxzbywgdGFrZSB0aGUgY2xpcCBmcm9tIHRoZSBwcm90b3R5cGUgYWN0aW9uXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCBjbGlwT2JqZWN0ID09PSBudWxsIClcXHJcXG5cXHRcXHRcXHRcXHRcXHRjbGlwT2JqZWN0ID0gcHJvdG90eXBlQWN0aW9uLl9jbGlwO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBjbGlwIG11c3QgYmUga25vd24gd2hlbiBzcGVjaWZpZWQgdmlhIHN0cmluZ1xcclxcblxcdFxcdFxcdGlmICggY2xpcE9iamVjdCA9PT0gbnVsbCApIHJldHVybiBudWxsO1xcclxcblxcclxcblxcdFxcdFxcdC8vIGFsbG9jYXRlIGFsbCByZXNvdXJjZXMgcmVxdWlyZWQgdG8gcnVuIGl0XFxyXFxuXFx0XFx0XFx0dmFyIG5ld0FjdGlvbiA9IG5ldyBBbmltYXRpb25BY3Rpb24oIHRoaXMsIGNsaXBPYmplY3QsIG9wdGlvbmFsUm9vdCApO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuX2JpbmRBY3Rpb24oIG5ld0FjdGlvbiwgcHJvdG90eXBlQWN0aW9uICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gYW5kIG1ha2UgdGhlIGFjdGlvbiBrbm93biB0byB0aGUgbWVtb3J5IG1hbmFnZXJcXHJcXG5cXHRcXHRcXHR0aGlzLl9hZGRJbmFjdGl2ZUFjdGlvbiggbmV3QWN0aW9uLCBjbGlwVXVpZCwgcm9vdFV1aWQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gbmV3QWN0aW9uO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Ly8gZ2V0IGFuIGV4aXN0aW5nIGFjdGlvblxcclxcblxcdFxcdGV4aXN0aW5nQWN0aW9uOiBmdW5jdGlvbiAoIGNsaXAsIG9wdGlvbmFsUm9vdCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgcm9vdCA9IG9wdGlvbmFsUm9vdCB8fCB0aGlzLl9yb290LFxcclxcblxcdFxcdFxcdFxcdHJvb3RVdWlkID0gcm9vdC51dWlkLFxcclxcblxcclxcblxcdFxcdFxcdFxcdGNsaXBPYmplY3QgPSB0eXBlb2YgY2xpcCA9PT0gJ3N0cmluZycgP1xcclxcblxcdFxcdFxcdFxcdFxcdEFuaW1hdGlvbkNsaXAuZmluZEJ5TmFtZSggcm9vdCwgY2xpcCApIDogY2xpcCxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjbGlwVXVpZCA9IGNsaXBPYmplY3QgPyBjbGlwT2JqZWN0LnV1aWQgOiBjbGlwLFxcclxcblxcclxcblxcdFxcdFxcdFxcdGFjdGlvbnNGb3JDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGFjdGlvbnNGb3JDbGlwICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGFjdGlvbnNGb3JDbGlwLmFjdGlvbkJ5Um9vdFsgcm9vdFV1aWQgXSB8fCBudWxsO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gbnVsbDtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdC8vIGRlYWN0aXZhdGVzIGFsbCBwcmV2aW91c2x5IHNjaGVkdWxlZCBhY3Rpb25zXFxyXFxuXFx0XFx0c3RvcEFsbEFjdGlvbjogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcXHJcXG5cXHRcXHRcXHRcXHRuQWN0aW9ucyA9IHRoaXMuX25BY3RpdmVBY3Rpb25zLFxcclxcblxcdFxcdFxcdFxcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXFxyXFxuXFx0XFx0XFx0XFx0bkJpbmRpbmdzID0gdGhpcy5fbkFjdGl2ZUJpbmRpbmdzO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuX25BY3RpdmVBY3Rpb25zID0gMDtcXHJcXG5cXHRcXHRcXHR0aGlzLl9uQWN0aXZlQmluZGluZ3MgPSAwO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbkFjdGlvbnM7ICsrIGkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YWN0aW9uc1sgaSBdLnJlc2V0KCk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbkJpbmRpbmdzOyArKyBpICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGJpbmRpbmdzWyBpIF0udXNlQ291bnQgPSAwO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdC8vIGFkdmFuY2UgdGhlIHRpbWUgYW5kIHVwZGF0ZSBhcHBseSB0aGUgYW5pbWF0aW9uXFxyXFxuXFx0XFx0dXBkYXRlOiBmdW5jdGlvbiAoIGRlbHRhVGltZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRkZWx0YVRpbWUgKj0gdGhpcy50aW1lU2NhbGU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxcclxcblxcdFxcdFxcdFxcdG5BY3Rpb25zID0gdGhpcy5fbkFjdGl2ZUFjdGlvbnMsXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGltZSA9IHRoaXMudGltZSArPSBkZWx0YVRpbWUsXFxyXFxuXFx0XFx0XFx0XFx0dGltZURpcmVjdGlvbiA9IE1hdGguc2lnbiggZGVsdGFUaW1lICksXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YWNjdUluZGV4ID0gdGhpcy5fYWNjdUluZGV4IF49IDE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gcnVuIGFjdGl2ZSBhY3Rpb25zXFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuQWN0aW9uczsgKysgaSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgYWN0aW9uID0gYWN0aW9uc1sgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGFjdGlvbi5fdXBkYXRlKCB0aW1lLCBkZWx0YVRpbWUsIHRpbWVEaXJlY3Rpb24sIGFjY3VJbmRleCApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyB1cGRhdGUgc2NlbmUgZ3JhcGhcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcXHJcXG5cXHRcXHRcXHRcXHRuQmluZGluZ3MgPSB0aGlzLl9uQWN0aXZlQmluZGluZ3M7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuQmluZGluZ3M7ICsrIGkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0YmluZGluZ3NbIGkgXS5hcHBseSggYWNjdUluZGV4ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Ly8gcmV0dXJuIHRoaXMgbWl4ZXIncyByb290IHRhcmdldCBvYmplY3RcXHJcXG5cXHRcXHRnZXRSb290OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuX3Jvb3Q7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHQvLyBmcmVlIGFsbCByZXNvdXJjZXMgc3BlY2lmaWMgdG8gYSBwYXJ0aWN1bGFyIGNsaXBcXHJcXG5cXHRcXHR1bmNhY2hlQ2xpcDogZnVuY3Rpb24gKCBjbGlwICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcXHJcXG5cXHRcXHRcXHRcXHRjbGlwVXVpZCA9IGNsaXAudXVpZCxcXHJcXG5cXHRcXHRcXHRcXHRhY3Rpb25zQnlDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcCxcXHJcXG5cXHRcXHRcXHRcXHRhY3Rpb25zRm9yQ2xpcCA9IGFjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBhY3Rpb25zRm9yQ2xpcCAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIG5vdGU6IGp1c3QgY2FsbGluZyBfcmVtb3ZlSW5hY3RpdmVBY3Rpb24gd291bGQgbWVzcyB1cCB0aGVcXHJcXG5cXHRcXHRcXHRcXHQvLyBpdGVyYXRpb24gc3RhdGUgYW5kIGFsc28gcmVxdWlyZSB1cGRhdGluZyB0aGUgc3RhdGUgd2UgY2FuXFxyXFxuXFx0XFx0XFx0XFx0Ly8ganVzdCB0aHJvdyBhd2F5XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIGFjdGlvbnNUb1JlbW92ZSA9IGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9ucztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBhY3Rpb25zVG9SZW1vdmUubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBhY3Rpb24gPSBhY3Rpb25zVG9SZW1vdmVbIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9kZWFjdGl2YXRlQWN0aW9uKCBhY3Rpb24gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgY2FjaGVJbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleCxcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRsYXN0SW5hY3RpdmVBY3Rpb24gPSBhY3Rpb25zWyBhY3Rpb25zLmxlbmd0aCAtIDEgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRhY3Rpb24uX2NhY2hlSW5kZXggPSBudWxsO1xcclxcblxcdFxcdFxcdFxcdFxcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IG51bGw7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0bGFzdEluYWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gY2FjaGVJbmRleDtcXHJcXG5cXHRcXHRcXHRcXHRcXHRhY3Rpb25zWyBjYWNoZUluZGV4IF0gPSBsYXN0SW5hY3RpdmVBY3Rpb247XFxyXFxuXFx0XFx0XFx0XFx0XFx0YWN0aW9ucy5wb3AoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUJpbmRpbmdzRm9yQWN0aW9uKCBhY3Rpb24gKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0ZGVsZXRlIGFjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Ly8gZnJlZSBhbGwgcmVzb3VyY2VzIHNwZWNpZmljIHRvIGEgcGFydGljdWxhciByb290IHRhcmdldCBvYmplY3RcXHJcXG5cXHRcXHR1bmNhY2hlUm9vdDogZnVuY3Rpb24gKCByb290ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciByb290VXVpZCA9IHJvb3QudXVpZCxcXHJcXG5cXHRcXHRcXHRcXHRhY3Rpb25zQnlDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgY2xpcFV1aWQgaW4gYWN0aW9uc0J5Q2xpcCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgYWN0aW9uQnlSb290ID0gYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXS5hY3Rpb25CeVJvb3QsXFxyXFxuXFx0XFx0XFx0XFx0XFx0YWN0aW9uID0gYWN0aW9uQnlSb290WyByb290VXVpZCBdO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlmICggYWN0aW9uICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fZGVhY3RpdmF0ZUFjdGlvbiggYWN0aW9uICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVBY3Rpb24oIGFjdGlvbiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGJpbmRpbmdzQnlSb290ID0gdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lLFxcclxcblxcdFxcdFxcdFxcdGJpbmRpbmdCeU5hbWUgPSBiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGJpbmRpbmdCeU5hbWUgIT09IHVuZGVmaW5lZCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgdHJhY2tOYW1lIGluIGJpbmRpbmdCeU5hbWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGJpbmRpbmcgPSBiaW5kaW5nQnlOYW1lWyB0cmFja05hbWUgXTtcXHJcXG5cXHRcXHRcXHRcXHRcXHRiaW5kaW5nLnJlc3RvcmVPcmlnaW5hbFN0YXRlKCk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nKCBiaW5kaW5nICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdC8vIHJlbW92ZSBhIHRhcmdldGVkIGNsaXAgZnJvbSB0aGUgY2FjaGVcXHJcXG5cXHRcXHR1bmNhY2hlQWN0aW9uOiBmdW5jdGlvbiAoIGNsaXAsIG9wdGlvbmFsUm9vdCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgYWN0aW9uID0gdGhpcy5leGlzdGluZ0FjdGlvbiggY2xpcCwgb3B0aW9uYWxSb290ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCBhY3Rpb24gIT09IG51bGwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5fZGVhY3RpdmF0ZUFjdGlvbiggYWN0aW9uICk7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVBY3Rpb24oIGFjdGlvbiApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gVW5pZm9ybSggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlVuaWZvcm06IFR5cGUgcGFyYW1ldGVyIGlzIG5vIGxvbmdlciBuZWVkZWQuJyApO1xcclxcblxcdFxcdFxcdHZhbHVlID0gYXJndW1lbnRzWyAxIF07XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHRoaXMudmFsdWUgPSB2YWx1ZTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0VW5pZm9ybS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIG5ldyBVbmlmb3JtKCB0aGlzLnZhbHVlLmNsb25lID09PSB1bmRlZmluZWQgPyB0aGlzLnZhbHVlIDogdGhpcy52YWx1ZS5jbG9uZSgpICk7XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSgpIHtcXHJcXG5cXHJcXG5cXHRcXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy50eXBlID0gJ0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5JztcXHJcXG5cXHRcXHR0aGlzLm1heEluc3RhbmNlZENvdW50ID0gdW5kZWZpbmVkO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKSwge1xcclxcblxcclxcblxcdFxcdGNvbnN0cnVjdG9yOiBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSxcXHJcXG5cXHJcXG5cXHRcXHRpc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5OiB0cnVlLFxcclxcblxcclxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xcclxcblxcclxcblxcdFxcdFxcdEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMubWF4SW5zdGFuY2VkQ291bnQgPSBzb3VyY2UubWF4SW5zdGFuY2VkQ291bnQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKCBpbnRlcmxlYXZlZEJ1ZmZlciwgaXRlbVNpemUsIG9mZnNldCwgbm9ybWFsaXplZCApIHtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmRhdGEgPSBpbnRlcmxlYXZlZEJ1ZmZlcjtcXHJcXG5cXHRcXHR0aGlzLml0ZW1TaXplID0gaXRlbVNpemU7XFxyXFxuXFx0XFx0dGhpcy5vZmZzZXQgPSBvZmZzZXQ7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5ub3JtYWxpemVkID0gbm9ybWFsaXplZCA9PT0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdGNvdW50OiB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZGF0YS5jb3VudDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRhcnJheToge1xcclxcblxcclxcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmRhdGEuYXJyYXk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0T2JqZWN0LmFzc2lnbiggSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLCB7XFxyXFxuXFxyXFxuXFx0XFx0aXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZTogdHJ1ZSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRYOiBmdW5jdGlvbiAoIGluZGV4LCB4ICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgXSA9IHg7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRZOiBmdW5jdGlvbiAoIGluZGV4LCB5ICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAxIF0gPSB5O1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0WjogZnVuY3Rpb24gKCBpbmRleCwgeiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMiBdID0gejtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldFc6IGZ1bmN0aW9uICggaW5kZXgsIHcgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDMgXSA9IHc7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRnZXRYOiBmdW5jdGlvbiAoIGluZGV4ICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0IF07XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRnZXRZOiBmdW5jdGlvbiAoIGluZGV4ICkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMSBdO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Z2V0WjogZnVuY3Rpb24gKCBpbmRleCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDIgXTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGdldFc6IGZ1bmN0aW9uICggaW5kZXggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAzIF07XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRYWTogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpbmRleCA9IGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xcclxcblxcdFxcdFxcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c2V0WFlaOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5LCB6ICkge1xcclxcblxcclxcblxcdFxcdFxcdGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XFxyXFxuXFx0XFx0XFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XFxyXFxuXFx0XFx0XFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRYWVpXOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5LCB6LCB3ICkge1xcclxcblxcclxcblxcdFxcdFxcdGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XFxyXFxuXFx0XFx0XFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XFxyXFxuXFx0XFx0XFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XFxyXFxuXFx0XFx0XFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDMgXSA9IHc7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBJbnRlcmxlYXZlZEJ1ZmZlciggYXJyYXksIHN0cmlkZSApIHtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmFycmF5ID0gYXJyYXk7XFxyXFxuXFx0XFx0dGhpcy5zdHJpZGUgPSBzdHJpZGU7XFxyXFxuXFx0XFx0dGhpcy5jb3VudCA9IGFycmF5ICE9PSB1bmRlZmluZWQgPyBhcnJheS5sZW5ndGggLyBzdHJpZGUgOiAwO1xcclxcblxcclxcblxcdFxcdHRoaXMuZHluYW1pYyA9IGZhbHNlO1xcclxcblxcdFxcdHRoaXMudXBkYXRlUmFuZ2UgPSB7IG9mZnNldDogMCwgY291bnQ6IC0gMSB9O1xcclxcblxcclxcblxcdFxcdHRoaXMub25VcGxvYWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xcclxcblxcclxcblxcdFxcdHRoaXMudmVyc2lvbiA9IDA7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlLCAnbmVlZHNVcGRhdGUnLCB7XFxyXFxuXFxyXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24gKys7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHRPYmplY3QuYXNzaWduKCBJbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHRpc0ludGVybGVhdmVkQnVmZmVyOiB0cnVlLFxcclxcblxcclxcblxcdFxcdHNldEFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggQXJyYXkuaXNBcnJheSggYXJyYXkgKSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlOiBhcnJheSBzaG91bGQgYmUgYSBUeXBlZCBBcnJheS4nICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHRoaXMuY291bnQgPSBhcnJheSAhPT0gdW5kZWZpbmVkID8gYXJyYXkubGVuZ3RoIC8gdGhpcy5zdHJpZGUgOiAwO1xcclxcblxcdFxcdFxcdHRoaXMuYXJyYXkgPSBhcnJheTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldER5bmFtaWM6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5keW5hbWljID0gdmFsdWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmFycmF5ID0gbmV3IHNvdXJjZS5hcnJheS5jb25zdHJ1Y3Rvciggc291cmNlLmFycmF5ICk7XFxyXFxuXFx0XFx0XFx0dGhpcy5jb3VudCA9IHNvdXJjZS5jb3VudDtcXHJcXG5cXHRcXHRcXHR0aGlzLnN0cmlkZSA9IHNvdXJjZS5zdHJpZGU7XFxyXFxuXFx0XFx0XFx0dGhpcy5keW5hbWljID0gc291cmNlLmR5bmFtaWM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjb3B5QXQ6IGZ1bmN0aW9uICggaW5kZXgxLCBhdHRyaWJ1dGUsIGluZGV4MiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpbmRleDEgKj0gdGhpcy5zdHJpZGU7XFxyXFxuXFx0XFx0XFx0aW5kZXgyICo9IGF0dHJpYnV0ZS5zdHJpZGU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5zdHJpZGU7IGkgPCBsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuYXJyYXlbIGluZGV4MSArIGkgXSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXgyICsgaSBdO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSwgb2Zmc2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuYXJyYXkuc2V0KCB2YWx1ZSwgb2Zmc2V0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdG9uVXBsb2FkOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMub25VcGxvYWRDYWxsYmFjayA9IGNhbGxiYWNrO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIoIGFycmF5LCBzdHJpZGUsIG1lc2hQZXJBdHRyaWJ1dGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0SW50ZXJsZWF2ZWRCdWZmZXIuY2FsbCggdGhpcywgYXJyYXksIHN0cmlkZSApO1xcclxcblxcclxcblxcdFxcdHRoaXMubWVzaFBlckF0dHJpYnV0ZSA9IG1lc2hQZXJBdHRyaWJ1dGUgfHwgMTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0SW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlICksIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zdHJ1Y3RvcjogSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIsXFxyXFxuXFxyXFxuXFx0XFx0aXNJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlcjogdHJ1ZSxcXHJcXG5cXHJcXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRJbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBzb3VyY2UubWVzaFBlckF0dHJpYnV0ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBtZXNoUGVyQXR0cmlidXRlICkge1xcclxcblxcclxcblxcdFxcdEJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBhcnJheSwgaXRlbVNpemUgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBtZXNoUGVyQXR0cmlidXRlIHx8IDE7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICksIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zdHJ1Y3RvcjogSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLFxcclxcblxcclxcblxcdFxcdGlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlOiB0cnVlLFxcclxcblxcclxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xcclxcblxcclxcblxcdFxcdFxcdEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBzb3VyY2UubWVzaFBlckF0dHJpYnV0ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cXHJcXG5cXHQgKiBAYXV0aG9yIHN0ZXBob21pIC8gaHR0cDovL3N0ZXBoYW5lZ2luaWVyLmNvbS9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBSYXljYXN0ZXIoIG9yaWdpbiwgZGlyZWN0aW9uLCBuZWFyLCBmYXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5yYXkgPSBuZXcgUmF5KCBvcmlnaW4sIGRpcmVjdGlvbiApO1xcclxcblxcdFxcdC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5uZWFyID0gbmVhciB8fCAwO1xcclxcblxcdFxcdHRoaXMuZmFyID0gZmFyIHx8IEluZmluaXR5O1xcclxcblxcclxcblxcdFxcdHRoaXMucGFyYW1zID0ge1xcclxcblxcdFxcdFxcdE1lc2g6IHt9LFxcclxcblxcdFxcdFxcdExpbmU6IHt9LFxcclxcblxcdFxcdFxcdExPRDoge30sXFxyXFxuXFx0XFx0XFx0UG9pbnRzOiB7IHRocmVzaG9sZDogMSB9LFxcclxcblxcdFxcdFxcdFNwcml0ZToge31cXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdFxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLnBhcmFtcywge1xcclxcblxcdFxcdFxcdFBvaW50Q2xvdWQ6IHtcXHJcXG5cXHRcXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5SYXljYXN0ZXI6IHBhcmFtcy5Qb2ludENsb3VkIGhhcyBiZWVuIHJlbmFtZWQgdG8gcGFyYW1zLlBvaW50cy4nICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuUG9pbnRzO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFx0XFx0fSApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBhc2NTb3J0KCBhLCBiICkge1xcclxcblxcclxcblxcdFxcdHJldHVybiBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gaW50ZXJzZWN0T2JqZWN0KCBvYmplY3QsIHJheWNhc3RlciwgaW50ZXJzZWN0cywgcmVjdXJzaXZlICkge1xcclxcblxcclxcblxcdFxcdGlmICggb2JqZWN0LnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xcclxcblxcclxcblxcdFxcdG9iamVjdC5yYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKTtcXHJcXG5cXHJcXG5cXHRcXHRpZiAoIHJlY3Vyc2l2ZSA9PT0gdHJ1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpbnRlcnNlY3RPYmplY3QoIGNoaWxkcmVuWyBpIF0sIHJheWNhc3RlciwgaW50ZXJzZWN0cywgdHJ1ZSApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIFJheWNhc3Rlci5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHRsaW5lUHJlY2lzaW9uOiAxLFxcclxcblxcclxcblxcdFxcdHNldDogZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBkaXJlY3Rpb24gaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkIChmb3IgYWNjdXJhdGUgZGlzdGFuY2UgY2FsY3VsYXRpb25zKVxcclxcblxcclxcblxcdFxcdFxcdHRoaXMucmF5LnNldCggb3JpZ2luLCBkaXJlY3Rpb24gKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldEZyb21DYW1lcmE6IGZ1bmN0aW9uICggY29vcmRzLCBjYW1lcmEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCAoIGNhbWVyYSAmJiBjYW1lcmEuaXNQZXJzcGVjdGl2ZUNhbWVyYSApICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMucmF5Lm9yaWdpbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xcclxcblxcdFxcdFxcdFxcdHRoaXMucmF5LmRpcmVjdGlvbi5zZXQoIGNvb3Jkcy54LCBjb29yZHMueSwgMC41ICkudW5wcm9qZWN0KCBjYW1lcmEgKS5zdWIoIHRoaXMucmF5Lm9yaWdpbiApLm5vcm1hbGl6ZSgpO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSBpZiAoICggY2FtZXJhICYmIGNhbWVyYS5pc09ydGhvZ3JhcGhpY0NhbWVyYSApICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMucmF5Lm9yaWdpbi5zZXQoIGNvb3Jkcy54LCBjb29yZHMueSwgKCBjYW1lcmEubmVhciArIGNhbWVyYS5mYXIgKSAvICggY2FtZXJhLm5lYXIgLSBjYW1lcmEuZmFyICkgKS51bnByb2plY3QoIGNhbWVyYSApOyAvLyBzZXQgb3JpZ2luIGluIHBsYW5lIG9mIGNhbWVyYVxcclxcblxcdFxcdFxcdFxcdHRoaXMucmF5LmRpcmVjdGlvbi5zZXQoIDAsIDAsIC0gMSApLnRyYW5zZm9ybURpcmVjdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUmF5Y2FzdGVyOiBVbnN1cHBvcnRlZCBjYW1lcmEgdHlwZS4nICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0aW50ZXJzZWN0T2JqZWN0OiBmdW5jdGlvbiAoIG9iamVjdCwgcmVjdXJzaXZlICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBpbnRlcnNlY3RzID0gW107XFxyXFxuXFxyXFxuXFx0XFx0XFx0aW50ZXJzZWN0T2JqZWN0KCBvYmplY3QsIHRoaXMsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSApO1xcclxcblxcclxcblxcdFxcdFxcdGludGVyc2VjdHMuc29ydCggYXNjU29ydCApO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiBpbnRlcnNlY3RzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0aW50ZXJzZWN0T2JqZWN0czogZnVuY3Rpb24gKCBvYmplY3RzLCByZWN1cnNpdmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGludGVyc2VjdHMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIEFycmF5LmlzQXJyYXkoIG9iamVjdHMgKSA9PT0gZmFsc2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdHM6IG9iamVjdHMgaXMgbm90IGFuIEFycmF5LicgKTtcXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gaW50ZXJzZWN0cztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGludGVyc2VjdE9iamVjdCggb2JqZWN0c1sgaSBdLCB0aGlzLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aW50ZXJzZWN0cy5zb3J0KCBhc2NTb3J0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIGludGVyc2VjdHM7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIENsb2NrKCBhdXRvU3RhcnQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5hdXRvU3RhcnQgPSAoIGF1dG9TdGFydCAhPT0gdW5kZWZpbmVkICkgPyBhdXRvU3RhcnQgOiB0cnVlO1xcclxcblxcclxcblxcdFxcdHRoaXMuc3RhcnRUaW1lID0gMDtcXHJcXG5cXHRcXHR0aGlzLm9sZFRpbWUgPSAwO1xcclxcblxcdFxcdHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xcclxcblxcclxcblxcdFxcdHRoaXMucnVubmluZyA9IGZhbHNlO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRPYmplY3QuYXNzaWduKCBDbG9jay5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHRzdGFydDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuc3RhcnRUaW1lID0gKCB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICd1bmRlZmluZWQnID8gRGF0ZSA6IHBlcmZvcm1hbmNlICkubm93KCk7IC8vIHNlZSAjMTA3MzJcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm9sZFRpbWUgPSB0aGlzLnN0YXJ0VGltZTtcXHJcXG5cXHRcXHRcXHR0aGlzLmVsYXBzZWRUaW1lID0gMDtcXHJcXG5cXHRcXHRcXHR0aGlzLnJ1bm5pbmcgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0c3RvcDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMuZ2V0RWxhcHNlZFRpbWUoKTtcXHJcXG5cXHRcXHRcXHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcXHJcXG5cXHRcXHRcXHR0aGlzLmF1dG9TdGFydCA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Z2V0RWxhcHNlZFRpbWU6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmdldERlbHRhKCk7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZWxhcHNlZFRpbWU7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRnZXREZWx0YTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBkaWZmID0gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMuYXV0b1N0YXJ0ICYmICEgdGhpcy5ydW5uaW5nICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMuc3RhcnQoKTtcXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLnJ1bm5pbmcgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIG5ld1RpbWUgPSAoIHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ3VuZGVmaW5lZCcgPyBEYXRlIDogcGVyZm9ybWFuY2UgKS5ub3coKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRkaWZmID0gKCBuZXdUaW1lIC0gdGhpcy5vbGRUaW1lICkgLyAxMDAwO1xcclxcblxcdFxcdFxcdFxcdHRoaXMub2xkVGltZSA9IG5ld1RpbWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5lbGFwc2VkVGltZSArPSBkaWZmO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZGlmZjtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cXHJcXG5cXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcXHJcXG5cXHQgKlxcclxcblxcdCAqIFJlZjogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BoZXJpY2FsX2Nvb3JkaW5hdGVfc3lzdGVtXFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBUaGUgcG9sZXMgKHBoaSkgYXJlIGF0IHRoZSBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgeSBheGlzLlxcclxcblxcdCAqIFRoZSBlcXVhdG9yIHN0YXJ0cyBhdCBwb3NpdGl2ZSB6LlxcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIFNwaGVyaWNhbCggcmFkaXVzLCBwaGksIHRoZXRhICkge1xcclxcblxcclxcblxcdFxcdHRoaXMucmFkaXVzID0gKCByYWRpdXMgIT09IHVuZGVmaW5lZCApID8gcmFkaXVzIDogMS4wO1xcclxcblxcdFxcdHRoaXMucGhpID0gKCBwaGkgIT09IHVuZGVmaW5lZCApID8gcGhpIDogMDsgLy8gdXAgLyBkb3duIHRvd2FyZHMgdG9wIGFuZCBib3R0b20gcG9sZVxcclxcblxcdFxcdHRoaXMudGhldGEgPSAoIHRoZXRhICE9PSB1bmRlZmluZWQgKSA/IHRoZXRhIDogMDsgLy8gYXJvdW5kIHRoZSBlcXVhdG9yIG9mIHRoZSBzcGhlcmVcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0T2JqZWN0LmFzc2lnbiggU3BoZXJpY2FsLnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdHNldDogZnVuY3Rpb24gKCByYWRpdXMsIHBoaSwgdGhldGEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XFxyXFxuXFx0XFx0XFx0dGhpcy5waGkgPSBwaGk7XFxyXFxuXFx0XFx0XFx0dGhpcy50aGV0YSA9IHRoZXRhO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIG90aGVyICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMucmFkaXVzID0gb3RoZXIucmFkaXVzO1xcclxcblxcdFxcdFxcdHRoaXMucGhpID0gb3RoZXIucGhpO1xcclxcblxcdFxcdFxcdHRoaXMudGhldGEgPSBvdGhlci50aGV0YTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdC8vIHJlc3RyaWN0IHBoaSB0byBiZSBiZXR3ZWUgRVBTIGFuZCBQSS1FUFNcXHJcXG5cXHRcXHRtYWtlU2FmZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBFUFMgPSAwLjAwMDAwMTtcXHJcXG5cXHRcXHRcXHR0aGlzLnBoaSA9IE1hdGgubWF4KCBFUFMsIE1hdGgubWluKCBNYXRoLlBJIC0gRVBTLCB0aGlzLnBoaSApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzZXRGcm9tVmVjdG9yMzogZnVuY3Rpb24gKCB2ZWMzICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMucmFkaXVzID0gdmVjMy5sZW5ndGgoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMucmFkaXVzID09PSAwICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMudGhldGEgPSAwO1xcclxcblxcdFxcdFxcdFxcdHRoaXMucGhpID0gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMudGhldGEgPSBNYXRoLmF0YW4yKCB2ZWMzLngsIHZlYzMueiApOyAvLyBlcXVhdG9yIGFuZ2xlIGFyb3VuZCB5LXVwIGF4aXNcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnBoaSA9IE1hdGguYWNvcyggX01hdGguY2xhbXAoIHZlYzMueSAvIHRoaXMucmFkaXVzLCAtIDEsIDEgKSApOyAvLyBwb2xhciBhbmdsZVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XFxyXFxuXFx0ICpcXHJcXG5cXHQgKiBSZWY6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0N5bGluZHJpY2FsX2Nvb3JkaW5hdGVfc3lzdGVtXFxyXFxuXFx0ICpcXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBDeWxpbmRyaWNhbCggcmFkaXVzLCB0aGV0YSwgeSApIHtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnJhZGl1cyA9ICggcmFkaXVzICE9PSB1bmRlZmluZWQgKSA/IHJhZGl1cyA6IDEuMDsgLy8gZGlzdGFuY2UgZnJvbSB0aGUgb3JpZ2luIHRvIGEgcG9pbnQgaW4gdGhlIHgteiBwbGFuZVxcclxcblxcdFxcdHRoaXMudGhldGEgPSAoIHRoZXRhICE9PSB1bmRlZmluZWQgKSA/IHRoZXRhIDogMDsgLy8gY291bnRlcmNsb2Nrd2lzZSBhbmdsZSBpbiB0aGUgeC16IHBsYW5lIG1lYXN1cmVkIGluIHJhZGlhbnMgZnJvbSB0aGUgcG9zaXRpdmUgei1heGlzXFxyXFxuXFx0XFx0dGhpcy55ID0gKCB5ICE9PSB1bmRlZmluZWQgKSA/IHkgOiAwOyAvLyBoZWlnaHQgYWJvdmUgdGhlIHgteiBwbGFuZVxcclxcblxcclxcblxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRPYmplY3QuYXNzaWduKCBDeWxpbmRyaWNhbC5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uICggcmFkaXVzLCB0aGV0YSwgeSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcXHJcXG5cXHRcXHRcXHR0aGlzLnRoZXRhID0gdGhldGE7XFxyXFxuXFx0XFx0XFx0dGhpcy55ID0geTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBvdGhlciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLnJhZGl1cyA9IG90aGVyLnJhZGl1cztcXHJcXG5cXHRcXHRcXHR0aGlzLnRoZXRhID0gb3RoZXIudGhldGE7XFxyXFxuXFx0XFx0XFx0dGhpcy55ID0gb3RoZXIueTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHNldEZyb21WZWN0b3IzOiBmdW5jdGlvbiAoIHZlYzMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5yYWRpdXMgPSBNYXRoLnNxcnQoIHZlYzMueCAqIHZlYzMueCArIHZlYzMueiAqIHZlYzMueiApO1xcclxcblxcdFxcdFxcdHRoaXMudGhldGEgPSBNYXRoLmF0YW4yKCB2ZWMzLngsIHZlYzMueiApO1xcclxcblxcdFxcdFxcdHRoaXMueSA9IHZlYzMueTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gSW1tZWRpYXRlUmVuZGVyT2JqZWN0KCBtYXRlcmlhbCApIHtcXHJcXG5cXHJcXG5cXHRcXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsO1xcclxcblxcdFxcdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCAvKiByZW5kZXJDYWxsYmFjayAqLyApIHt9O1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRJbW1lZGlhdGVSZW5kZXJPYmplY3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICk7XFxyXFxuXFx0SW1tZWRpYXRlUmVuZGVyT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEltbWVkaWF0ZVJlbmRlck9iamVjdDtcXHJcXG5cXHJcXG5cXHRJbW1lZGlhdGVSZW5kZXJPYmplY3QucHJvdG90eXBlLmlzSW1tZWRpYXRlUmVuZGVyT2JqZWN0ID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIFZlcnRleE5vcm1hbHNIZWxwZXIoIG9iamVjdCwgc2l6ZSwgaGV4LCBsaW5ld2lkdGggKSB7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5zaXplID0gKCBzaXplICE9PSB1bmRlZmluZWQgKSA/IHNpemUgOiAxO1xcclxcblxcclxcblxcdFxcdHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ZmYwMDAwO1xcclxcblxcclxcblxcdFxcdHZhciB3aWR0aCA9ICggbGluZXdpZHRoICE9PSB1bmRlZmluZWQgKSA/IGxpbmV3aWR0aCA6IDE7XFxyXFxuXFxyXFxuXFx0XFx0Ly9cXHJcXG5cXHJcXG5cXHRcXHR2YXIgbk5vcm1hbHMgPSAwO1xcclxcblxcclxcblxcdFxcdHZhciBvYmpHZW9tZXRyeSA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5O1xcclxcblxcclxcblxcdFxcdGlmICggb2JqR2VvbWV0cnkgJiYgb2JqR2VvbWV0cnkuaXNHZW9tZXRyeSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRuTm9ybWFscyA9IG9iakdlb21ldHJ5LmZhY2VzLmxlbmd0aCAqIDM7XFxyXFxuXFxyXFxuXFx0XFx0fSBlbHNlIGlmICggb2JqR2VvbWV0cnkgJiYgb2JqR2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRuTm9ybWFscyA9IG9iakdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsLmNvdW50O1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHQvL1xcclxcblxcclxcblxcdFxcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xcclxcblxcclxcblxcdFxcdHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbk5vcm1hbHMgKiAyICogMywgMyApO1xcclxcblxcclxcblxcdFxcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25zICk7XFxyXFxuXFxyXFxuXFx0XFx0TGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCBsaW5ld2lkdGg6IHdpZHRoIH0gKSApO1xcclxcblxcclxcblxcdFxcdC8vXFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy51cGRhdGUoKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0VmVydGV4Tm9ybWFsc0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMaW5lU2VnbWVudHMucHJvdG90eXBlICk7XFxyXFxuXFx0VmVydGV4Tm9ybWFsc0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBWZXJ0ZXhOb3JtYWxzSGVscGVyO1xcclxcblxcclxcblxcdFZlcnRleE5vcm1hbHNIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0dmFyIHYyID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHRcXHR2YXIgbm9ybWFsTWF0cml4ID0gbmV3IE1hdHJpeDMoKTtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBrZXlzID0gWyAnYScsICdiJywgJ2MnIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5vYmplY3QudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCB0aGlzLm9iamVjdC5tYXRyaXhXb3JsZCApO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBtYXRyaXhXb3JsZCA9IHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBwb3NpdGlvbiA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvL1xcclxcblxcclxcblxcdFxcdFxcdHZhciBvYmpHZW9tZXRyeSA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5O1xcclxcblxcclxcblxcdFxcdFxcdGlmICggb2JqR2VvbWV0cnkgJiYgb2JqR2VvbWV0cnkuaXNHZW9tZXRyeSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgdmVydGljZXMgPSBvYmpHZW9tZXRyeS52ZXJ0aWNlcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgZmFjZXMgPSBvYmpHZW9tZXRyeS5mYWNlcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgaWR4ID0gMDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlc1sgZmFjZVsga2V5c1sgaiBdIF0gXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgbm9ybWFsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzWyBqIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0djEuY29weSggdmVydGV4ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdHYyLmNvcHkoIG5vcm1hbCApLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIHRoaXMuc2l6ZSApLmFkZCggdjEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjEueCwgdjEueSwgdjEueiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGlkeCA9IGlkeCArIDE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0cG9zaXRpb24uc2V0WFlaKCBpZHgsIHYyLngsIHYyLnksIHYyLnogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZHggPSBpZHggKyAxO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggb2JqR2VvbWV0cnkgJiYgb2JqR2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgb2JqUG9zID0gb2JqR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgb2JqTm9ybSA9IG9iakdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBpZHggPSAwO1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIGZvciBzaW1wbGljaXR5LCBpZ25vcmUgaW5kZXggYW5kIGRyYXdjYWxscywgYW5kIHJlbmRlciBldmVyeSBub3JtYWxcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gb2JqUG9zLmNvdW50OyBqIDwgamw7IGogKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0djEuc2V0KCBvYmpQb3MuZ2V0WCggaiApLCBvYmpQb3MuZ2V0WSggaiApLCBvYmpQb3MuZ2V0WiggaiApICkuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHYyLnNldCggb2JqTm9ybS5nZXRYKCBqICksIG9iak5vcm0uZ2V0WSggaiApLCBvYmpOb3JtLmdldFooIGogKSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHYyLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIHRoaXMuc2l6ZSApLmFkZCggdjEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjEueCwgdjEueSwgdjEueiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGlkeCA9IGlkeCArIDE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0cG9zaXRpb24uc2V0WFlaKCBpZHgsIHYyLngsIHYyLnksIHYyLnogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRpZHggPSBpZHggKyAxO1xcclxcblxcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0fSgpICk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIFNwb3RMaWdodEhlbHBlciggbGlnaHQsIGNvbG9yICkge1xcclxcblxcclxcblxcdFxcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XFxyXFxuXFx0XFx0dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xcclxcblxcclxcblxcdFxcdHRoaXMubWF0cml4ID0gbGlnaHQubWF0cml4V29ybGQ7XFxyXFxuXFx0XFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5jb2xvciA9IGNvbG9yO1xcclxcblxcclxcblxcdFxcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xcclxcblxcclxcblxcdFxcdHZhciBwb3NpdGlvbnMgPSBbXFxyXFxuXFx0XFx0XFx0MCwgMCwgMCwgXFx0MCwgMCwgMSxcXHJcXG5cXHRcXHRcXHQwLCAwLCAwLCBcXHQxLCAwLCAxLFxcclxcblxcdFxcdFxcdDAsIDAsIDAsXFx0LSAxLCAwLCAxLFxcclxcblxcdFxcdFxcdDAsIDAsIDAsIFxcdDAsIDEsIDEsXFxyXFxuXFx0XFx0XFx0MCwgMCwgMCwgXFx0MCwgLSAxLCAxXFxyXFxuXFx0XFx0XTtcXHJcXG5cXHJcXG5cXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGogPSAxLCBsID0gMzI7IGkgPCBsOyBpICsrLCBqICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBwMSA9ICggaSAvIGwgKSAqIE1hdGguUEkgKiAyO1xcclxcblxcdFxcdFxcdHZhciBwMiA9ICggaiAvIGwgKSAqIE1hdGguUEkgKiAyO1xcclxcblxcclxcblxcdFxcdFxcdHBvc2l0aW9ucy5wdXNoKFxcclxcblxcdFxcdFxcdFxcdE1hdGguY29zKCBwMSApLCBNYXRoLnNpbiggcDEgKSwgMSxcXHJcXG5cXHRcXHRcXHRcXHRNYXRoLmNvcyggcDIgKSwgTWF0aC5zaW4oIHAyICksIDFcXHJcXG5cXHRcXHRcXHQpO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIDMgKSApO1xcclxcblxcclxcblxcdFxcdHZhciBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBmb2c6IGZhbHNlIH0gKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmNvbmUgPSBuZXcgTGluZVNlZ21lbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcXHJcXG5cXHRcXHR0aGlzLmFkZCggdGhpcy5jb25lICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy51cGRhdGUoKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0U3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApO1xcclxcblxcdFNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcG90TGlnaHRIZWxwZXI7XFxyXFxuXFxyXFxuXFx0U3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdHRoaXMuY29uZS5nZW9tZXRyeS5kaXNwb3NlKCk7XFxyXFxuXFx0XFx0dGhpcy5jb25lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcXHJcXG5cXHJcXG5cXHR9O1xcclxcblxcclxcblxcdFNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdHZhciB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdHZhciB2ZWN0b3IyID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgY29uZUxlbmd0aCA9IHRoaXMubGlnaHQuZGlzdGFuY2UgPyB0aGlzLmxpZ2h0LmRpc3RhbmNlIDogMTAwMDtcXHJcXG5cXHRcXHRcXHR2YXIgY29uZVdpZHRoID0gY29uZUxlbmd0aCAqIE1hdGgudGFuKCB0aGlzLmxpZ2h0LmFuZ2xlICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5jb25lLnNjYWxlLnNldCggY29uZVdpZHRoLCBjb25lV2lkdGgsIGNvbmVMZW5ndGggKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2ZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICk7XFxyXFxuXFx0XFx0XFx0dmVjdG9yMi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5jb25lLmxvb2tBdCggdmVjdG9yMi5zdWIoIHZlY3RvciApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmNvbG9yICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5jb25lLm1hdGVyaWFsLmNvbG9yLnNldCggdGhpcy5jb2xvciApO1xcclxcblxcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5jb25lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHR9KCk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBTZWFuIEdyaWZmaW4gLyBodHRwOi8vdHdpdHRlci5jb20vc2dyaWZcXHJcXG5cXHQgKiBAYXV0aG9yIE1pY2hhZWwgR3VlcnJlcm8gLyBodHRwOi8vcmVhbGl0eW1lbHRkb3duLmNvbVxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXFxyXFxuXFx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBnZXRCb25lTGlzdCggb2JqZWN0ICkge1xcclxcblxcclxcblxcdFxcdHZhciBib25lTGlzdCA9IFtdO1xcclxcblxcclxcblxcdFxcdGlmICggb2JqZWN0ICYmIG9iamVjdC5pc0JvbmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ym9uZUxpc3QucHVzaCggb2JqZWN0ICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IG9iamVjdC5jaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ym9uZUxpc3QucHVzaC5hcHBseSggYm9uZUxpc3QsIGdldEJvbmVMaXN0KCBvYmplY3QuY2hpbGRyZW5bIGkgXSApICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHJldHVybiBib25lTGlzdDtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gU2tlbGV0b25IZWxwZXIoIG9iamVjdCApIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgYm9uZXMgPSBnZXRCb25lTGlzdCggb2JqZWN0ICk7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHZlcnRpY2VzID0gW107XFxyXFxuXFx0XFx0dmFyIGNvbG9ycyA9IFtdO1xcclxcblxcclxcblxcdFxcdHZhciBjb2xvcjEgPSBuZXcgQ29sb3IoIDAsIDAsIDEgKTtcXHJcXG5cXHRcXHR2YXIgY29sb3IyID0gbmV3IENvbG9yKCAwLCAxLCAwICk7XFxyXFxuXFxyXFxuXFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYm9uZXMubGVuZ3RoOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBib25lID0gYm9uZXNbIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGJvbmUucGFyZW50ICYmIGJvbmUucGFyZW50LmlzQm9uZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCAwLCAwLCAwICk7XFxyXFxuXFx0XFx0XFx0XFx0dmVydGljZXMucHVzaCggMCwgMCwgMCApO1xcclxcblxcdFxcdFxcdFxcdGNvbG9ycy5wdXNoKCBjb2xvcjEuciwgY29sb3IxLmcsIGNvbG9yMS5iICk7XFxyXFxuXFx0XFx0XFx0XFx0Y29sb3JzLnB1c2goIGNvbG9yMi5yLCBjb2xvcjIuZywgY29sb3IyLmIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcXHJcXG5cXHRcXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xcclxcblxcclxcblxcdFxcdHZhciBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFZlcnRleENvbG9ycywgZGVwdGhUZXN0OiBmYWxzZSwgZGVwdGhXcml0ZTogZmFsc2UsIHRyYW5zcGFyZW50OiB0cnVlIH0gKTtcXHJcXG5cXHJcXG5cXHRcXHRMaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5yb290ID0gb2JqZWN0O1xcclxcblxcdFxcdHRoaXMuYm9uZXMgPSBib25lcztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm1hdHJpeCA9IG9iamVjdC5tYXRyaXhXb3JsZDtcXHJcXG5cXHRcXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0U2tlbGV0b25IZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xcclxcblxcdFNrZWxldG9uSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNrZWxldG9uSGVscGVyO1xcclxcblxcclxcblxcdFNrZWxldG9uSGVscGVyLnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZCA9IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgYm9uZU1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XFxyXFxuXFx0XFx0dmFyIG1hdHJpeFdvcmxkSW52ID0gbmV3IE1hdHJpeDQoKTtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciBib25lcyA9IHRoaXMuYm9uZXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcXHJcXG5cXHRcXHRcXHR2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRtYXRyaXhXb3JsZEludi5nZXRJbnZlcnNlKCB0aGlzLnJvb3QubWF0cml4V29ybGQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGogPSAwOyBpIDwgYm9uZXMubGVuZ3RoOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBib25lID0gYm9uZXNbIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRpZiAoIGJvbmUucGFyZW50ICYmIGJvbmUucGFyZW50LmlzQm9uZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRib25lTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeFdvcmxkSW52LCBib25lLm1hdHJpeFdvcmxkICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmVjdG9yLnNldEZyb21NYXRyaXhQb3NpdGlvbiggYm9uZU1hdHJpeCApO1xcclxcblxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uLnNldFhZWiggaiwgdmVjdG9yLngsIHZlY3Rvci55LCB2ZWN0b3IueiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGJvbmVNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4V29ybGRJbnYsIGJvbmUucGFyZW50Lm1hdHJpeFdvcmxkICk7XFxyXFxuXFx0XFx0XFx0XFx0XFx0dmVjdG9yLnNldEZyb21NYXRyaXhQb3NpdGlvbiggYm9uZU1hdHJpeCApO1xcclxcblxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uLnNldFhZWiggaiArIDEsIHZlY3Rvci54LCB2ZWN0b3IueSwgdmVjdG9yLnogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRcXHRqICs9IDI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKS5uZWVkc1VwZGF0ZSA9IHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0T2JqZWN0M0QucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkLmNhbGwoIHRoaXMsIGZvcmNlICk7XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHR9KCk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIFBvaW50TGlnaHRIZWxwZXIoIGxpZ2h0LCBzcGhlcmVTaXplLCBjb2xvciApIHtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XFxyXFxuXFx0XFx0dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xcclxcblxcclxcblxcdFxcdHRoaXMuY29sb3IgPSBjb2xvcjtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgZ2VvbWV0cnkgPSBuZXcgU3BoZXJlQnVmZmVyR2VvbWV0cnkoIHNwaGVyZVNpemUsIDQsIDIgKTtcXHJcXG5cXHRcXHR2YXIgbWF0ZXJpYWwgPSBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoIHsgd2lyZWZyYW1lOiB0cnVlLCBmb2c6IGZhbHNlIH0gKTtcXHJcXG5cXHJcXG5cXHRcXHRNZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xcclxcblxcclxcblxcdFxcdHRoaXMubWF0cml4ID0gdGhpcy5saWdodC5tYXRyaXhXb3JsZDtcXHJcXG5cXHRcXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnVwZGF0ZSgpO1xcclxcblxcclxcblxcclxcblxcdFxcdC8qXFxyXFxuXFx0XFx0dmFyIGRpc3RhbmNlR2VvbWV0cnkgPSBuZXcgVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeSggMSwgMiApO1xcclxcblxcdFxcdHZhciBkaXN0YW5jZU1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBoZXhDb2xvciwgZm9nOiBmYWxzZSwgd2lyZWZyYW1lOiB0cnVlLCBvcGFjaXR5OiAwLjEsIHRyYW5zcGFyZW50OiB0cnVlIH0gKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmxpZ2h0U3BoZXJlID0gbmV3IFRIUkVFLk1lc2goIGJ1bGJHZW9tZXRyeSwgYnVsYk1hdGVyaWFsICk7XFxyXFxuXFx0XFx0dGhpcy5saWdodERpc3RhbmNlID0gbmV3IFRIUkVFLk1lc2goIGRpc3RhbmNlR2VvbWV0cnksIGRpc3RhbmNlTWF0ZXJpYWwgKTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgZCA9IGxpZ2h0LmRpc3RhbmNlO1xcclxcblxcclxcblxcdFxcdGlmICggZCA9PT0gMC4wICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmxpZ2h0RGlzdGFuY2Uuc2NhbGUuc2V0KCBkLCBkLCBkICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHRoaXMuYWRkKCB0aGlzLmxpZ2h0RGlzdGFuY2UgKTtcXHJcXG5cXHRcXHQqL1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRQb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1lc2gucHJvdG90eXBlICk7XFxyXFxuXFx0UG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2ludExpZ2h0SGVscGVyO1xcclxcblxcclxcblxcdFBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XFxyXFxuXFx0XFx0dGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHRQb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCB0aGlzLmNvbG9yICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5tYXRlcmlhbC5jb2xvci5zZXQoIHRoaXMuY29sb3IgKTtcXHJcXG5cXHJcXG5cXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHQvKlxcclxcblxcdFxcdHZhciBkID0gdGhpcy5saWdodC5kaXN0YW5jZTtcXHJcXG5cXHJcXG5cXHRcXHRpZiAoIGQgPT09IDAuMCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmxpZ2h0RGlzdGFuY2UudmlzaWJsZSA9IGZhbHNlO1xcclxcblxcclxcblxcdFxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSB0cnVlO1xcclxcblxcdFxcdFxcdHRoaXMubGlnaHREaXN0YW5jZS5zY2FsZS5zZXQoIGQsIGQsIGQgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFx0XFx0Ki9cXHJcXG5cXHJcXG5cXHR9O1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgYWJlbG5hdGlvbiAvIGh0dHA6Ly9naXRodWIuY29tL2FiZWxuYXRpb25cXHJcXG5cXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwOi8vZ2l0aHViLmNvbS9NdWdlbjg3XFxyXFxuXFx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gUmVjdEFyZWFMaWdodEhlbHBlciggbGlnaHQsIGNvbG9yICkge1xcclxcblxcclxcblxcdFxcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XFxyXFxuXFx0XFx0dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xcclxcblxcclxcblxcdFxcdHRoaXMubWF0cml4ID0gbGlnaHQubWF0cml4V29ybGQ7XFxyXFxuXFx0XFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5jb2xvciA9IGNvbG9yO1xcclxcblxcclxcblxcdFxcdHZhciBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBmb2c6IGZhbHNlIH0gKTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcXHJcXG5cXHJcXG5cXHRcXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIDUgKiAzICksIDMgKSApO1xcclxcblxcclxcblxcdFxcdHRoaXMubGluZSA9IG5ldyBMaW5lKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcXHJcXG5cXHRcXHR0aGlzLmFkZCggdGhpcy5saW5lICk7XFxyXFxuXFxyXFxuXFxyXFxuXFx0XFx0dGhpcy51cGRhdGUoKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0UmVjdEFyZWFMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKTtcXHJcXG5cXHRSZWN0QXJlYUxpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlY3RBcmVhTGlnaHRIZWxwZXI7XFxyXFxuXFxyXFxuXFx0UmVjdEFyZWFMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmNoaWxkcmVuWyAwIF0uZ2VvbWV0cnkuZGlzcG9zZSgpO1xcclxcblxcdFxcdHRoaXMuY2hpbGRyZW5bIDAgXS5tYXRlcmlhbC5kaXNwb3NlKCk7XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHRSZWN0QXJlYUxpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gY2FsY3VsYXRlIG5ldyBkaW1lbnNpb25zIG9mIHRoZSBoZWxwZXJcXHJcXG5cXHJcXG5cXHRcXHR2YXIgaHggPSB0aGlzLmxpZ2h0LndpZHRoICogMC41O1xcclxcblxcdFxcdHZhciBoeSA9IHRoaXMubGlnaHQuaGVpZ2h0ICogMC41O1xcclxcblxcclxcblxcdFxcdHZhciBwb3NpdGlvbiA9IHRoaXMubGluZS5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xcclxcblxcdFxcdHZhciBhcnJheSA9IHBvc2l0aW9uLmFycmF5O1xcclxcblxcclxcblxcdFxcdC8vIHVwZGF0ZSB2ZXJ0aWNlc1xcclxcblxcclxcblxcdFxcdGFycmF5WyAwIF0gPSBoeDsgYXJyYXlbIDEgXSA9IC0gaHk7IGFycmF5WyAyIF0gPSAwO1xcclxcblxcdFxcdGFycmF5WyAzIF0gPSBoeDsgYXJyYXlbIDQgXSA9IGh5OyBhcnJheVsgNSBdID0gMDtcXHJcXG5cXHRcXHRhcnJheVsgNiBdID0gLSBoeDsgYXJyYXlbIDcgXSA9IGh5OyBhcnJheVsgOCBdID0gMDtcXHJcXG5cXHRcXHRhcnJheVsgOSBdID0gLSBoeDsgYXJyYXlbIDEwIF0gPSAtIGh5OyBhcnJheVsgMTEgXSA9IDA7XFxyXFxuXFx0XFx0YXJyYXlbIDEyIF0gPSBoeDsgYXJyYXlbIDEzIF0gPSAtIGh5OyBhcnJheVsgMTQgXSA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0cG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xcclxcblxcclxcblxcdFxcdGlmICggdGhpcy5jb2xvciAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMubGluZS5tYXRlcmlhbC5jb2xvci5zZXQoIHRoaXMuY29sb3IgKTtcXHJcXG5cXHJcXG5cXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMubGluZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXHJcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcclxcblxcdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gSGVtaXNwaGVyZUxpZ2h0SGVscGVyKCBsaWdodCwgc2l6ZSwgY29sb3IgKSB7XFxyXFxuXFxyXFxuXFx0XFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMubGlnaHQgPSBsaWdodDtcXHJcXG5cXHRcXHR0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcXHJcXG5cXHRcXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmNvbG9yID0gY29sb3I7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGdlb21ldHJ5ID0gbmV3IE9jdGFoZWRyb25CdWZmZXJHZW9tZXRyeSggc2l6ZSApO1xcclxcblxcdFxcdGdlb21ldHJ5LnJvdGF0ZVkoIE1hdGguUEkgKiAwLjUgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLm1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7IHdpcmVmcmFtZTogdHJ1ZSwgZm9nOiBmYWxzZSB9ICk7XFxyXFxuXFx0XFx0aWYgKCB0aGlzLmNvbG9yID09PSB1bmRlZmluZWQgKSB0aGlzLm1hdGVyaWFsLnZlcnRleENvbG9ycyA9IFZlcnRleENvbG9ycztcXHJcXG5cXHJcXG5cXHRcXHR2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcXHJcXG5cXHRcXHR2YXIgY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheSggcG9zaXRpb24uY291bnQgKiAzICk7XFxyXFxuXFxyXFxuXFx0XFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xcclxcblxcclxcblxcdFxcdHRoaXMuYWRkKCBuZXcgTWVzaCggZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwgKSApO1xcclxcblxcclxcblxcdFxcdHRoaXMudXBkYXRlKCk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdEhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKTtcXHJcXG5cXHRIZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSGVtaXNwaGVyZUxpZ2h0SGVscGVyO1xcclxcblxcclxcblxcdEhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmNoaWxkcmVuWyAwIF0uZ2VvbWV0cnkuZGlzcG9zZSgpO1xcclxcblxcdFxcdHRoaXMuY2hpbGRyZW5bIDAgXS5tYXRlcmlhbC5kaXNwb3NlKCk7XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHRIZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgY29sb3IxID0gbmV3IENvbG9yKCk7XFxyXFxuXFx0XFx0dmFyIGNvbG9yMiA9IG5ldyBDb2xvcigpO1xcclxcblxcclxcblxcdFxcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG1lc2ggPSB0aGlzLmNoaWxkcmVuWyAwIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmNvbG9yICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5tYXRlcmlhbC5jb2xvci5zZXQoIHRoaXMuY29sb3IgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBjb2xvcnMgPSBtZXNoLmdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ2NvbG9yJyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbG9yMS5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICk7XFxyXFxuXFx0XFx0XFx0XFx0Y29sb3IyLmNvcHkoIHRoaXMubGlnaHQuZ3JvdW5kQ29sb3IgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjb2xvcnMuY291bnQ7IGkgPCBsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHZhciBjb2xvciA9ICggaSA8ICggbCAvIDIgKSApID8gY29sb3IxIDogY29sb3IyO1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdGNvbG9ycy5zZXRYWVooIGksIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29sb3JzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0bWVzaC5sb29rQXQoIHZlY3Rvci5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKS5uZWdhdGUoKSApO1xcclxcblxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0fSgpO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gR3JpZEhlbHBlciggc2l6ZSwgZGl2aXNpb25zLCBjb2xvcjEsIGNvbG9yMiApIHtcXHJcXG5cXHJcXG5cXHRcXHRzaXplID0gc2l6ZSB8fCAxMDtcXHJcXG5cXHRcXHRkaXZpc2lvbnMgPSBkaXZpc2lvbnMgfHwgMTA7XFxyXFxuXFx0XFx0Y29sb3IxID0gbmV3IENvbG9yKCBjb2xvcjEgIT09IHVuZGVmaW5lZCA/IGNvbG9yMSA6IDB4NDQ0NDQ0ICk7XFxyXFxuXFx0XFx0Y29sb3IyID0gbmV3IENvbG9yKCBjb2xvcjIgIT09IHVuZGVmaW5lZCA/IGNvbG9yMiA6IDB4ODg4ODg4ICk7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGNlbnRlciA9IGRpdmlzaW9ucyAvIDI7XFxyXFxuXFx0XFx0dmFyIHN0ZXAgPSBzaXplIC8gZGl2aXNpb25zO1xcclxcblxcdFxcdHZhciBoYWxmU2l6ZSA9IHNpemUgLyAyO1xcclxcblxcclxcblxcdFxcdHZhciB2ZXJ0aWNlcyA9IFtdLCBjb2xvcnMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGogPSAwLCBrID0gLSBoYWxmU2l6ZTsgaSA8PSBkaXZpc2lvbnM7IGkgKyssIGsgKz0gc3RlcCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCAtIGhhbGZTaXplLCAwLCBrLCBoYWxmU2l6ZSwgMCwgayApO1xcclxcblxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIGssIDAsIC0gaGFsZlNpemUsIGssIDAsIGhhbGZTaXplICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGNvbG9yID0gaSA9PT0gY2VudGVyID8gY29sb3IxIDogY29sb3IyO1xcclxcblxcclxcblxcdFxcdFxcdGNvbG9yLnRvQXJyYXkoIGNvbG9ycywgaiApOyBqICs9IDM7XFxyXFxuXFx0XFx0XFx0Y29sb3IudG9BcnJheSggY29sb3JzLCBqICk7IGogKz0gMztcXHJcXG5cXHRcXHRcXHRjb2xvci50b0FycmF5KCBjb2xvcnMsIGogKTsgaiArPSAzO1xcclxcblxcdFxcdFxcdGNvbG9yLnRvQXJyYXkoIGNvbG9ycywgaiApOyBqICs9IDM7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xcclxcblxcdFxcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcXHJcXG5cXHRcXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xcclxcblxcclxcblxcdFxcdHZhciBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFZlcnRleENvbG9ycyB9ICk7XFxyXFxuXFxyXFxuXFx0XFx0TGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRHcmlkSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcXHJcXG5cXHRHcmlkSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdyaWRIZWxwZXI7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwOi8vZ2l0aHViLmNvbS9NdWdlbjg3XFxyXFxuXFx0ICogQGF1dGhvciBIZWN0YXRlIC8gaHR0cDovL3d3dy5naXRodWIuY29tL0hlY3RhdGVcXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBQb2xhckdyaWRIZWxwZXIoIHJhZGl1cywgcmFkaWFscywgY2lyY2xlcywgZGl2aXNpb25zLCBjb2xvcjEsIGNvbG9yMiApIHtcXHJcXG5cXHJcXG5cXHRcXHRyYWRpdXMgPSByYWRpdXMgfHwgMTA7XFxyXFxuXFx0XFx0cmFkaWFscyA9IHJhZGlhbHMgfHwgMTY7XFxyXFxuXFx0XFx0Y2lyY2xlcyA9IGNpcmNsZXMgfHwgODtcXHJcXG5cXHRcXHRkaXZpc2lvbnMgPSBkaXZpc2lvbnMgfHwgNjQ7XFxyXFxuXFx0XFx0Y29sb3IxID0gbmV3IENvbG9yKCBjb2xvcjEgIT09IHVuZGVmaW5lZCA/IGNvbG9yMSA6IDB4NDQ0NDQ0ICk7XFxyXFxuXFx0XFx0Y29sb3IyID0gbmV3IENvbG9yKCBjb2xvcjIgIT09IHVuZGVmaW5lZCA/IGNvbG9yMiA6IDB4ODg4ODg4ICk7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHZlcnRpY2VzID0gW107XFxyXFxuXFx0XFx0dmFyIGNvbG9ycyA9IFtdO1xcclxcblxcclxcblxcdFxcdHZhciB4LCB6O1xcclxcblxcdFxcdHZhciB2LCBpLCBqLCByLCBjb2xvcjtcXHJcXG5cXHJcXG5cXHRcXHQvLyBjcmVhdGUgdGhlIHJhZGlhbHNcXHJcXG5cXHJcXG5cXHRcXHRmb3IgKCBpID0gMDsgaSA8PSByYWRpYWxzOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdHYgPSAoIGkgLyByYWRpYWxzICkgKiAoIE1hdGguUEkgKiAyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0eCA9IE1hdGguc2luKCB2ICkgKiByYWRpdXM7XFxyXFxuXFx0XFx0XFx0eiA9IE1hdGguY29zKCB2ICkgKiByYWRpdXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmVydGljZXMucHVzaCggMCwgMCwgMCApO1xcclxcblxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIHgsIDAsIHogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb2xvciA9ICggaSAmIDEgKSA/IGNvbG9yMSA6IGNvbG9yMjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb2xvcnMucHVzaCggY29sb3IuciwgY29sb3IuZywgY29sb3IuYiApO1xcclxcblxcdFxcdFxcdGNvbG9ycy5wdXNoKCBjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdC8vIGNyZWF0ZSB0aGUgY2lyY2xlc1xcclxcblxcclxcblxcdFxcdGZvciAoIGkgPSAwOyBpIDw9IGNpcmNsZXM7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29sb3IgPSAoIGkgJiAxICkgPyBjb2xvcjEgOiBjb2xvcjI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0ciA9IHJhZGl1cyAtICggcmFkaXVzIC8gY2lyY2xlcyAqIGkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCBqID0gMDsgaiA8IGRpdmlzaW9uczsgaiArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBmaXJzdCB2ZXJ0ZXhcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2ID0gKCBqIC8gZGl2aXNpb25zICkgKiAoIE1hdGguUEkgKiAyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0eCA9IE1hdGguc2luKCB2ICkgKiByO1xcclxcblxcdFxcdFxcdFxcdHogPSBNYXRoLmNvcyggdiApICogcjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCB4LCAwLCB6ICk7XFxyXFxuXFx0XFx0XFx0XFx0Y29sb3JzLnB1c2goIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBzZWNvbmQgdmVydGV4XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0diA9ICggKCBqICsgMSApIC8gZGl2aXNpb25zICkgKiAoIE1hdGguUEkgKiAyICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0eCA9IE1hdGguc2luKCB2ICkgKiByO1xcclxcblxcdFxcdFxcdFxcdHogPSBNYXRoLmNvcyggdiApICogcjtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCB4LCAwLCB6ICk7XFxyXFxuXFx0XFx0XFx0XFx0Y29sb3JzLnB1c2goIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xcclxcblxcdFxcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcXHJcXG5cXHRcXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xcclxcblxcclxcblxcdFxcdHZhciBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFZlcnRleENvbG9ycyB9ICk7XFxyXFxuXFxyXFxuXFx0XFx0TGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRQb2xhckdyaWRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xcclxcblxcdFBvbGFyR3JpZEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2xhckdyaWRIZWxwZXI7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBGYWNlTm9ybWFsc0hlbHBlciggb2JqZWN0LCBzaXplLCBoZXgsIGxpbmV3aWR0aCApIHtcXHJcXG5cXHJcXG5cXHRcXHQvLyBGYWNlTm9ybWFsc0hlbHBlciBvbmx5IHN1cHBvcnRzIFRIUkVFLkdlb21ldHJ5XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5zaXplID0gKCBzaXplICE9PSB1bmRlZmluZWQgKSA/IHNpemUgOiAxO1xcclxcblxcclxcblxcdFxcdHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ZmZmZjAwO1xcclxcblxcclxcblxcdFxcdHZhciB3aWR0aCA9ICggbGluZXdpZHRoICE9PSB1bmRlZmluZWQgKSA/IGxpbmV3aWR0aCA6IDE7XFxyXFxuXFxyXFxuXFx0XFx0Ly9cXHJcXG5cXHJcXG5cXHRcXHR2YXIgbk5vcm1hbHMgPSAwO1xcclxcblxcclxcblxcdFxcdHZhciBvYmpHZW9tZXRyeSA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5O1xcclxcblxcclxcblxcdFxcdGlmICggb2JqR2VvbWV0cnkgJiYgb2JqR2VvbWV0cnkuaXNHZW9tZXRyeSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRuTm9ybWFscyA9IG9iakdlb21ldHJ5LmZhY2VzLmxlbmd0aDtcXHJcXG5cXHJcXG5cXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkZhY2VOb3JtYWxzSGVscGVyOiBvbmx5IFRIUkVFLkdlb21ldHJ5IGlzIHN1cHBvcnRlZC4gVXNlIFRIUkVFLlZlcnRleE5vcm1hbHNIZWxwZXIsIGluc3RlYWQuJyApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHQvL1xcclxcblxcclxcblxcdFxcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xcclxcblxcclxcblxcdFxcdHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbk5vcm1hbHMgKiAyICogMywgMyApO1xcclxcblxcclxcblxcdFxcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25zICk7XFxyXFxuXFxyXFxuXFx0XFx0TGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCBsaW5ld2lkdGg6IHdpZHRoIH0gKSApO1xcclxcblxcclxcblxcdFxcdC8vXFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XFxyXFxuXFx0XFx0dGhpcy51cGRhdGUoKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0RmFjZU5vcm1hbHNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xcclxcblxcdEZhY2VOb3JtYWxzSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZhY2VOb3JtYWxzSGVscGVyO1xcclxcblxcclxcblxcdEZhY2VOb3JtYWxzSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSAoIGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdHZhciB2MiA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0dmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBNYXRyaXgzKCk7XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLm9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xcclxcblxcclxcblxcdFxcdFxcdG5vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG1hdHJpeFdvcmxkID0gdGhpcy5vYmplY3QubWF0cml4V29ybGQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHBvc2l0aW9uID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xcclxcblxcclxcblxcdFxcdFxcdC8vXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG9iakdlb21ldHJ5ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHZlcnRpY2VzID0gb2JqR2VvbWV0cnkudmVydGljZXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGZhY2VzID0gb2JqR2VvbWV0cnkuZmFjZXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIGlkeCA9IDA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmFyIG5vcm1hbCA9IGZhY2Uubm9ybWFsO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHYxLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmEgXSApXFxyXFxuXFx0XFx0XFx0XFx0XFx0LmFkZCggdmVydGljZXNbIGZhY2UuYiBdIClcXHJcXG5cXHRcXHRcXHRcXHRcXHQuYWRkKCB2ZXJ0aWNlc1sgZmFjZS5jIF0gKVxcclxcblxcdFxcdFxcdFxcdFxcdC5kaXZpZGVTY2FsYXIoIDMgKVxcclxcblxcdFxcdFxcdFxcdFxcdC5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0djIuY29weSggbm9ybWFsICkuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggdGhpcy5zaXplICkuYWRkKCB2MSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHBvc2l0aW9uLnNldFhZWiggaWR4LCB2MS54LCB2MS55LCB2MS56ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWR4ID0gaWR4ICsgMTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjIueCwgdjIueSwgdjIueiApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGlkeCA9IGlkeCArIDE7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHR9O1xcclxcblxcclxcblxcdH0oKSApO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBEaXJlY3Rpb25hbExpZ2h0SGVscGVyKCBsaWdodCwgc2l6ZSwgY29sb3IgKSB7XFxyXFxuXFxyXFxuXFx0XFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdHRoaXMubGlnaHQgPSBsaWdodDtcXHJcXG5cXHRcXHR0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcXHJcXG5cXHRcXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmNvbG9yID0gY29sb3I7XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCBzaXplID09PSB1bmRlZmluZWQgKSBzaXplID0gMTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcXHJcXG5cXHRcXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBbXFxyXFxuXFx0XFx0XFx0LSBzaXplLCBzaXplLCAwLFxcclxcblxcdFxcdFxcdHNpemUsIHNpemUsIDAsXFxyXFxuXFx0XFx0XFx0c2l6ZSwgLSBzaXplLCAwLFxcclxcblxcdFxcdFxcdC0gc2l6ZSwgLSBzaXplLCAwLFxcclxcblxcdFxcdFxcdC0gc2l6ZSwgc2l6ZSwgMFxcclxcblxcdFxcdF0sIDMgKSApO1xcclxcblxcclxcblxcdFxcdHZhciBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBmb2c6IGZhbHNlIH0gKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmxpZ2h0UGxhbmUgPSBuZXcgTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsICk7XFxyXFxuXFx0XFx0dGhpcy5hZGQoIHRoaXMubGlnaHRQbGFuZSApO1xcclxcblxcclxcblxcdFxcdGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XFxyXFxuXFx0XFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggWyAwLCAwLCAwLCAwLCAwLCAxIF0sIDMgKSApO1xcclxcblxcclxcblxcdFxcdHRoaXMudGFyZ2V0TGluZSA9IG5ldyBMaW5lKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcXHJcXG5cXHRcXHR0aGlzLmFkZCggdGhpcy50YXJnZXRMaW5lICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy51cGRhdGUoKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0RGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKTtcXHJcXG5cXHREaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERpcmVjdGlvbmFsTGlnaHRIZWxwZXI7XFxyXFxuXFxyXFxuXFx0RGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmxpZ2h0UGxhbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xcclxcblxcdFxcdHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5kaXNwb3NlKCk7XFxyXFxuXFx0XFx0dGhpcy50YXJnZXRMaW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcXHJcXG5cXHRcXHR0aGlzLnRhcmdldExpbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0RGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XFxyXFxuXFx0XFx0dmFyIHYyID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHRcXHR2YXIgdjMgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcclxcblxcdFxcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0djEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICk7XFxyXFxuXFx0XFx0XFx0djIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xcclxcblxcdFxcdFxcdHYzLnN1YlZlY3RvcnMoIHYyLCB2MSApO1xcclxcblxcclxcblxcdFxcdFxcdHRoaXMubGlnaHRQbGFuZS5sb29rQXQoIHYzICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmNvbG9yICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5saWdodFBsYW5lLm1hdGVyaWFsLmNvbG9yLnNldCggdGhpcy5jb2xvciApO1xcclxcblxcdFxcdFxcdFxcdHRoaXMudGFyZ2V0TGluZS5tYXRlcmlhbC5jb2xvci5zZXQoIHRoaXMuY29sb3IgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICk7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy50YXJnZXRMaW5lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0dGhpcy50YXJnZXRMaW5lLmxvb2tBdCggdjMgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLnRhcmdldExpbmUuc2NhbGUueiA9IHYzLmxlbmd0aCgpO1xcclxcblxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0fSgpO1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxyXFxuXFx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcXHJcXG5cXHQgKlxcclxcblxcdCAqXFx0LSBzaG93cyBmcnVzdHVtLCBsaW5lIG9mIHNpZ2h0IGFuZCB1cCBvZiB0aGUgY2FtZXJhXFxyXFxuXFx0ICpcXHQtIHN1aXRhYmxlIGZvciBmYXN0IHVwZGF0ZXNcXHJcXG5cXHQgKiBcXHQtIGJhc2VkIG9uIGZydXN0dW0gdmlzdWFsaXphdGlvbiBpbiBsaWdodGdsLmpzIHNoYWRvd21hcCBleGFtcGxlXFxyXFxuXFx0ICpcXHRcXHRodHRwOi8vZXZhbncuZ2l0aHViLmNvbS9saWdodGdsLmpzL3Rlc3RzL3NoYWRvd21hcC5odG1sXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gQ2FtZXJhSGVscGVyKCBjYW1lcmEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XFxyXFxuXFx0XFx0dmFyIG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiAweGZmZmZmZiwgdmVydGV4Q29sb3JzOiBGYWNlQ29sb3JzIH0gKTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgdmVydGljZXMgPSBbXTtcXHJcXG5cXHRcXHR2YXIgY29sb3JzID0gW107XFxyXFxuXFxyXFxuXFx0XFx0dmFyIHBvaW50TWFwID0ge307XFxyXFxuXFxyXFxuXFx0XFx0Ly8gY29sb3JzXFxyXFxuXFxyXFxuXFx0XFx0dmFyIGNvbG9yRnJ1c3R1bSA9IG5ldyBDb2xvciggMHhmZmFhMDAgKTtcXHJcXG5cXHRcXHR2YXIgY29sb3JDb25lID0gbmV3IENvbG9yKCAweGZmMDAwMCApO1xcclxcblxcdFxcdHZhciBjb2xvclVwID0gbmV3IENvbG9yKCAweDAwYWFmZiApO1xcclxcblxcdFxcdHZhciBjb2xvclRhcmdldCA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTtcXHJcXG5cXHRcXHR2YXIgY29sb3JDcm9zcyA9IG5ldyBDb2xvciggMHgzMzMzMzMgKTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBuZWFyXFxyXFxuXFxyXFxuXFx0XFx0YWRkTGluZSggJ24xJywgJ24yJywgY29sb3JGcnVzdHVtICk7XFxyXFxuXFx0XFx0YWRkTGluZSggJ24yJywgJ240JywgY29sb3JGcnVzdHVtICk7XFxyXFxuXFx0XFx0YWRkTGluZSggJ240JywgJ24zJywgY29sb3JGcnVzdHVtICk7XFxyXFxuXFx0XFx0YWRkTGluZSggJ24zJywgJ24xJywgY29sb3JGcnVzdHVtICk7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gZmFyXFxyXFxuXFxyXFxuXFx0XFx0YWRkTGluZSggJ2YxJywgJ2YyJywgY29sb3JGcnVzdHVtICk7XFxyXFxuXFx0XFx0YWRkTGluZSggJ2YyJywgJ2Y0JywgY29sb3JGcnVzdHVtICk7XFxyXFxuXFx0XFx0YWRkTGluZSggJ2Y0JywgJ2YzJywgY29sb3JGcnVzdHVtICk7XFxyXFxuXFx0XFx0YWRkTGluZSggJ2YzJywgJ2YxJywgY29sb3JGcnVzdHVtICk7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gc2lkZXNcXHJcXG5cXHJcXG5cXHRcXHRhZGRMaW5lKCAnbjEnLCAnZjEnLCBjb2xvckZydXN0dW0gKTtcXHJcXG5cXHRcXHRhZGRMaW5lKCAnbjInLCAnZjInLCBjb2xvckZydXN0dW0gKTtcXHJcXG5cXHRcXHRhZGRMaW5lKCAnbjMnLCAnZjMnLCBjb2xvckZydXN0dW0gKTtcXHJcXG5cXHRcXHRhZGRMaW5lKCAnbjQnLCAnZjQnLCBjb2xvckZydXN0dW0gKTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBjb25lXFxyXFxuXFxyXFxuXFx0XFx0YWRkTGluZSggJ3AnLCAnbjEnLCBjb2xvckNvbmUgKTtcXHJcXG5cXHRcXHRhZGRMaW5lKCAncCcsICduMicsIGNvbG9yQ29uZSApO1xcclxcblxcdFxcdGFkZExpbmUoICdwJywgJ24zJywgY29sb3JDb25lICk7XFxyXFxuXFx0XFx0YWRkTGluZSggJ3AnLCAnbjQnLCBjb2xvckNvbmUgKTtcXHJcXG5cXHJcXG5cXHRcXHQvLyB1cFxcclxcblxcclxcblxcdFxcdGFkZExpbmUoICd1MScsICd1MicsIGNvbG9yVXAgKTtcXHJcXG5cXHRcXHRhZGRMaW5lKCAndTInLCAndTMnLCBjb2xvclVwICk7XFxyXFxuXFx0XFx0YWRkTGluZSggJ3UzJywgJ3UxJywgY29sb3JVcCApO1xcclxcblxcclxcblxcdFxcdC8vIHRhcmdldFxcclxcblxcclxcblxcdFxcdGFkZExpbmUoICdjJywgJ3QnLCBjb2xvclRhcmdldCApO1xcclxcblxcdFxcdGFkZExpbmUoICdwJywgJ2MnLCBjb2xvckNyb3NzICk7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gY3Jvc3NcXHJcXG5cXHJcXG5cXHRcXHRhZGRMaW5lKCAnY24xJywgJ2NuMicsIGNvbG9yQ3Jvc3MgKTtcXHJcXG5cXHRcXHRhZGRMaW5lKCAnY24zJywgJ2NuNCcsIGNvbG9yQ3Jvc3MgKTtcXHJcXG5cXHJcXG5cXHRcXHRhZGRMaW5lKCAnY2YxJywgJ2NmMicsIGNvbG9yQ3Jvc3MgKTtcXHJcXG5cXHRcXHRhZGRMaW5lKCAnY2YzJywgJ2NmNCcsIGNvbG9yQ3Jvc3MgKTtcXHJcXG5cXHJcXG5cXHRcXHRmdW5jdGlvbiBhZGRMaW5lKCBhLCBiLCBjb2xvciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRhZGRQb2ludCggYSwgY29sb3IgKTtcXHJcXG5cXHRcXHRcXHRhZGRQb2ludCggYiwgY29sb3IgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gYWRkUG9pbnQoIGlkLCBjb2xvciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCAwLCAwLCAwICk7XFxyXFxuXFx0XFx0XFx0Y29sb3JzLnB1c2goIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHBvaW50TWFwWyBpZCBdID09PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cG9pbnRNYXBbIGlkIF0gPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0cG9pbnRNYXBbIGlkIF0ucHVzaCggKCB2ZXJ0aWNlcy5sZW5ndGggLyAzICkgLSAxICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcXHJcXG5cXHRcXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xcclxcblxcclxcblxcdFxcdExpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmNhbWVyYSA9IGNhbWVyYTtcXHJcXG5cXHRcXHRpZiAoIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXggKSB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5tYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGQ7XFxyXFxuXFx0XFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5wb2ludE1hcCA9IHBvaW50TWFwO1xcclxcblxcclxcblxcdFxcdHRoaXMudXBkYXRlKCk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdENhbWVyYUhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMaW5lU2VnbWVudHMucHJvdG90eXBlICk7XFxyXFxuXFx0Q2FtZXJhSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbWVyYUhlbHBlcjtcXHJcXG5cXHJcXG5cXHRDYW1lcmFIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgZ2VvbWV0cnksIHBvaW50TWFwO1xcclxcblxcclxcblxcdFxcdHZhciB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdHZhciBjYW1lcmEgPSBuZXcgQ2FtZXJhKCk7XFxyXFxuXFxyXFxuXFx0XFx0ZnVuY3Rpb24gc2V0UG9pbnQoIHBvaW50LCB4LCB5LCB6ICkge1xcclxcblxcclxcblxcdFxcdFxcdHZlY3Rvci5zZXQoIHgsIHksIHogKS51bnByb2plY3QoIGNhbWVyYSApO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBwb2ludHMgPSBwb2ludE1hcFsgcG9pbnQgXTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHBvaW50cyAhPT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uLnNldFhZWiggcG9pbnRzWyBpIF0sIHZlY3Rvci54LCB2ZWN0b3IueSwgdmVjdG9yLnogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xcclxcblxcclxcblxcdFxcdFxcdGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcXHJcXG5cXHRcXHRcXHRwb2ludE1hcCA9IHRoaXMucG9pbnRNYXA7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHcgPSAxLCBoID0gMTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyB3ZSBuZWVkIGp1c3QgY2FtZXJhIHByb2plY3Rpb24gbWF0cml4XFxyXFxuXFx0XFx0XFx0Ly8gd29ybGQgbWF0cml4IG11c3QgYmUgaWRlbnRpdHlcXHJcXG5cXHJcXG5cXHRcXHRcXHRjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5jb3B5KCB0aGlzLmNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gY2VudGVyIC8gdGFyZ2V0XFxyXFxuXFxyXFxuXFx0XFx0XFx0c2V0UG9pbnQoICdjJywgMCwgMCwgLSAxICk7XFxyXFxuXFx0XFx0XFx0c2V0UG9pbnQoICd0JywgMCwgMCwgMSApO1xcclxcblxcclxcblxcdFxcdFxcdC8vIG5lYXJcXHJcXG5cXHJcXG5cXHRcXHRcXHRzZXRQb2ludCggJ24xJywgLSB3LCAtIGgsIC0gMSApO1xcclxcblxcdFxcdFxcdHNldFBvaW50KCAnbjInLCB3LCAtIGgsIC0gMSApO1xcclxcblxcdFxcdFxcdHNldFBvaW50KCAnbjMnLCAtIHcsIGgsIC0gMSApO1xcclxcblxcdFxcdFxcdHNldFBvaW50KCAnbjQnLCB3LCBoLCAtIDEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBmYXJcXHJcXG5cXHJcXG5cXHRcXHRcXHRzZXRQb2ludCggJ2YxJywgLSB3LCAtIGgsIDEgKTtcXHJcXG5cXHRcXHRcXHRzZXRQb2ludCggJ2YyJywgdywgLSBoLCAxICk7XFxyXFxuXFx0XFx0XFx0c2V0UG9pbnQoICdmMycsIC0gdywgaCwgMSApO1xcclxcblxcdFxcdFxcdHNldFBvaW50KCAnZjQnLCB3LCBoLCAxICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gdXBcXHJcXG5cXHJcXG5cXHRcXHRcXHRzZXRQb2ludCggJ3UxJywgdyAqIDAuNywgaCAqIDEuMSwgLSAxICk7XFxyXFxuXFx0XFx0XFx0c2V0UG9pbnQoICd1MicsIC0gdyAqIDAuNywgaCAqIDEuMSwgLSAxICk7XFxyXFxuXFx0XFx0XFx0c2V0UG9pbnQoICd1MycsIDAsIGggKiAyLCAtIDEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBjcm9zc1xcclxcblxcclxcblxcdFxcdFxcdHNldFBvaW50KCAnY2YxJywgLSB3LCAwLCAxICk7XFxyXFxuXFx0XFx0XFx0c2V0UG9pbnQoICdjZjInLCB3LCAwLCAxICk7XFxyXFxuXFx0XFx0XFx0c2V0UG9pbnQoICdjZjMnLCAwLCAtIGgsIDEgKTtcXHJcXG5cXHRcXHRcXHRzZXRQb2ludCggJ2NmNCcsIDAsIGgsIDEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRzZXRQb2ludCggJ2NuMScsIC0gdywgMCwgLSAxICk7XFxyXFxuXFx0XFx0XFx0c2V0UG9pbnQoICdjbjInLCB3LCAwLCAtIDEgKTtcXHJcXG5cXHRcXHRcXHRzZXRQb2ludCggJ2NuMycsIDAsIC0gaCwgLSAxICk7XFxyXFxuXFx0XFx0XFx0c2V0UG9pbnQoICdjbjQnLCAwLCBoLCAtIDEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKS5uZWVkc1VwZGF0ZSA9IHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHR9KCk7XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwOi8vZ2l0aHViLmNvbS9NdWdlbjg3XFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gQm94SGVscGVyKCBvYmplY3QsIGNvbG9yICkge1xcclxcblxcclxcblxcdFxcdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xcclxcblxcclxcblxcdFxcdGlmICggY29sb3IgPT09IHVuZGVmaW5lZCApIGNvbG9yID0gMHhmZmZmMDA7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoIFsgMCwgMSwgMSwgMiwgMiwgMywgMywgMCwgNCwgNSwgNSwgNiwgNiwgNywgNywgNCwgMCwgNCwgMSwgNSwgMiwgNiwgMywgNyBdICk7XFxyXFxuXFx0XFx0dmFyIHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoIDggKiAzICk7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XFxyXFxuXFx0XFx0Z2VvbWV0cnkuc2V0SW5kZXgoIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGluZGljZXMsIDEgKSApO1xcclxcblxcdFxcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCAzICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRMaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy51cGRhdGUoKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0Qm94SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcXHJcXG5cXHRCb3hIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQm94SGVscGVyO1xcclxcblxcclxcblxcdEJveEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gKCBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGJveCA9IG5ldyBCb3gzKCk7XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSggb2JqZWN0ICkge1xcclxcblxcclxcblxcdFxcdFxcdGlmICggb2JqZWN0ICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94SGVscGVyOiAudXBkYXRlKCkgaGFzIG5vIGxvbmdlciBhcmd1bWVudHMuJyApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHRoaXMub2JqZWN0ICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Ym94LnNldEZyb21PYmplY3QoIHRoaXMub2JqZWN0ICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdFxcdGlmICggYm94LmlzRW1wdHkoKSApIHJldHVybjtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbWluID0gYm94Lm1pbjtcXHJcXG5cXHRcXHRcXHR2YXIgbWF4ID0gYm94Lm1heDtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvKlxcclxcblxcdFxcdFxcdCAgNV9fX180XFxyXFxuXFx0XFx0XFx0MS9fX18wL3xcXHJcXG5cXHRcXHRcXHR8IDZfX3xfN1xcclxcblxcdFxcdFxcdDIvX19fMy9cXHJcXG5cXHJcXG5cXHRcXHRcXHQwOiBtYXgueCwgbWF4LnksIG1heC56XFxyXFxuXFx0XFx0XFx0MTogbWluLngsIG1heC55LCBtYXguelxcclxcblxcdFxcdFxcdDI6IG1pbi54LCBtaW4ueSwgbWF4LnpcXHJcXG5cXHRcXHRcXHQzOiBtYXgueCwgbWluLnksIG1heC56XFxyXFxuXFx0XFx0XFx0NDogbWF4LngsIG1heC55LCBtaW4uelxcclxcblxcdFxcdFxcdDU6IG1pbi54LCBtYXgueSwgbWluLnpcXHJcXG5cXHRcXHRcXHQ2OiBtaW4ueCwgbWluLnksIG1pbi56XFxyXFxuXFx0XFx0XFx0NzogbWF4LngsIG1pbi55LCBtaW4uelxcclxcblxcdFxcdFxcdCovXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHBvc2l0aW9uID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xcclxcblxcdFxcdFxcdHZhciBhcnJheSA9IHBvc2l0aW9uLmFycmF5O1xcclxcblxcclxcblxcdFxcdFxcdGFycmF5WyAwIF0gPSBtYXgueDsgYXJyYXlbIDEgXSA9IG1heC55OyBhcnJheVsgMiBdID0gbWF4Lno7XFxyXFxuXFx0XFx0XFx0YXJyYXlbIDMgXSA9IG1pbi54OyBhcnJheVsgNCBdID0gbWF4Lnk7IGFycmF5WyA1IF0gPSBtYXguejtcXHJcXG5cXHRcXHRcXHRhcnJheVsgNiBdID0gbWluLng7IGFycmF5WyA3IF0gPSBtaW4ueTsgYXJyYXlbIDggXSA9IG1heC56O1xcclxcblxcdFxcdFxcdGFycmF5WyA5IF0gPSBtYXgueDsgYXJyYXlbIDEwIF0gPSBtaW4ueTsgYXJyYXlbIDExIF0gPSBtYXguejtcXHJcXG5cXHRcXHRcXHRhcnJheVsgMTIgXSA9IG1heC54OyBhcnJheVsgMTMgXSA9IG1heC55OyBhcnJheVsgMTQgXSA9IG1pbi56O1xcclxcblxcdFxcdFxcdGFycmF5WyAxNSBdID0gbWluLng7IGFycmF5WyAxNiBdID0gbWF4Lnk7IGFycmF5WyAxNyBdID0gbWluLno7XFxyXFxuXFx0XFx0XFx0YXJyYXlbIDE4IF0gPSBtaW4ueDsgYXJyYXlbIDE5IF0gPSBtaW4ueTsgYXJyYXlbIDIwIF0gPSBtaW4uejtcXHJcXG5cXHRcXHRcXHRhcnJheVsgMjEgXSA9IG1heC54OyBhcnJheVsgMjIgXSA9IG1pbi55OyBhcnJheVsgMjMgXSA9IG1pbi56O1xcclxcblxcclxcblxcdFxcdFxcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR0aGlzLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xcclxcblxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0fSApKCk7XFxyXFxuXFxyXFxuXFx0Qm94SGVscGVyLnByb3RvdHlwZS5zZXRGcm9tT2JqZWN0ID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XFxyXFxuXFx0XFx0dGhpcy51cGRhdGUoKTtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gdGhpcztcXHJcXG5cXHJcXG5cXHR9O1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIEJveDNIZWxwZXIoIGJveCwgaGV4ICkge1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdCb3gzSGVscGVyJztcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmJveCA9IGJveDtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweGZmZmYwMDtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSggWyAwLCAxLCAxLCAyLCAyLCAzLCAzLCAwLCA0LCA1LCA1LCA2LCA2LCA3LCA3LCA0LCAwLCA0LCAxLCA1LCAyLCA2LCAzLCA3IF0gKTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgcG9zaXRpb25zID0gWyAxLCAxLCAxLCAtIDEsIDEsIDEsIC0gMSwgLSAxLCAxLCAxLCAtIDEsIDEsIDEsIDEsIC0gMSwgLSAxLCAxLCAtIDEsIC0gMSwgLSAxLCAtIDEsIDEsIC0gMSwgLSAxIF07XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XFxyXFxuXFxyXFxuXFx0XFx0Z2VvbWV0cnkuc2V0SW5kZXgoIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGluZGljZXMsIDEgKSApO1xcclxcblxcclxcblxcdFxcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XFxyXFxuXFxyXFxuXFx0XFx0TGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSApO1xcclxcblxcclxcblxcdFxcdHRoaXMuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdEJveDNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xcclxcblxcdEJveDNIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQm94M0hlbHBlcjtcXHJcXG5cXHJcXG5cXHRCb3gzSGVscGVyLnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZCA9IGZ1bmN0aW9uICggZm9yY2UgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGJveCA9IHRoaXMuYm94O1xcclxcblxcclxcblxcdFxcdGlmICggYm94LmlzRW1wdHkoKSApIHJldHVybjtcXHJcXG5cXHJcXG5cXHRcXHRib3guZ2V0Q2VudGVyKCB0aGlzLnBvc2l0aW9uICk7XFxyXFxuXFxyXFxuXFx0XFx0Ym94LmdldFNpemUoIHRoaXMuc2NhbGUgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnNjYWxlLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcXHJcXG5cXHJcXG5cXHRcXHRPYmplY3QzRC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgZm9yY2UgKTtcXHJcXG5cXHJcXG5cXHR9O1xcclxcblxcclxcblxcdC8qKlxcclxcblxcdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxcclxcblxcdCAqL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIFBsYW5lSGVscGVyKCBwbGFuZSwgc2l6ZSwgaGV4ICkge1xcclxcblxcclxcblxcdFxcdHRoaXMudHlwZSA9ICdQbGFuZUhlbHBlcic7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5wbGFuZSA9IHBsYW5lO1xcclxcblxcclxcblxcdFxcdHRoaXMuc2l6ZSA9ICggc2l6ZSA9PT0gdW5kZWZpbmVkICkgPyAxIDogc2l6ZTtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweGZmZmYwMDtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgcG9zaXRpb25zID0gWyAxLCAtIDEsIDEsIC0gMSwgMSwgMSwgLSAxLCAtIDEsIDEsIDEsIDEsIDEsIC0gMSwgMSwgMSwgLSAxLCAtIDEsIDEsIDEsIC0gMSwgMSwgMSwgMSwgMSwgMCwgMCwgMSwgMCwgMCwgMCBdO1xcclxcblxcclxcblxcdFxcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xcclxcblxcdFxcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XFxyXFxuXFx0XFx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XFxyXFxuXFxyXFxuXFx0XFx0TGluZS5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciB9ICkgKTtcXHJcXG5cXHJcXG5cXHRcXHQvL1xcclxcblxcclxcblxcdFxcdHZhciBwb3NpdGlvbnMyID0gWyAxLCAxLCAxLCAtIDEsIDEsIDEsIC0gMSwgLSAxLCAxLCAxLCAxLCAxLCAtIDEsIC0gMSwgMSwgMSwgLSAxLCAxIF07XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGdlb21ldHJ5MiA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xcclxcblxcdFxcdGdlb21ldHJ5Mi5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMyLCAzICkgKTtcXHJcXG5cXHRcXHRnZW9tZXRyeTIuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5hZGQoIG5ldyBNZXNoKCBnZW9tZXRyeTIsIG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIG9wYWNpdHk6IDAuMiwgdHJhbnNwYXJlbnQ6IHRydWUsIGRlcHRoV3JpdGU6IGZhbHNlIH0gKSApICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdFBsYW5lSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmUucHJvdG90eXBlICk7XFxyXFxuXFx0UGxhbmVIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGxhbmVIZWxwZXI7XFxyXFxuXFxyXFxuXFx0UGxhbmVIZWxwZXIucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkID0gZnVuY3Rpb24gKCBmb3JjZSApIHtcXHJcXG5cXHJcXG5cXHRcXHR2YXIgc2NhbGUgPSAtIHRoaXMucGxhbmUuY29uc3RhbnQ7XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCBNYXRoLmFicyggc2NhbGUgKSA8IDFlLTggKSBzY2FsZSA9IDFlLTg7IC8vIHNpZ24gZG9lcyBub3QgbWF0dGVyXFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5zY2FsZS5zZXQoIDAuNSAqIHRoaXMuc2l6ZSwgMC41ICogdGhpcy5zaXplLCBzY2FsZSApO1xcclxcblxcclxcblxcdFxcdHRoaXMubG9va0F0KCB0aGlzLnBsYW5lLm5vcm1hbCApO1xcclxcblxcclxcblxcdFxcdE9iamVjdDNELnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKCB0aGlzLCBmb3JjZSApO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XFxyXFxuXFx0ICogQGF1dGhvciB6ejg1IC8gaHR0cDovL2dpdGh1Yi5jb20veno4NVxcclxcblxcdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cXHJcXG5cXHQgKlxcclxcblxcdCAqIENyZWF0ZXMgYW4gYXJyb3cgZm9yIHZpc3VhbGl6aW5nIGRpcmVjdGlvbnNcXHJcXG5cXHQgKlxcclxcblxcdCAqIFBhcmFtZXRlcnM6XFxyXFxuXFx0ICogIGRpciAtIFZlY3RvcjNcXHJcXG5cXHQgKiAgb3JpZ2luIC0gVmVjdG9yM1xcclxcblxcdCAqICBsZW5ndGggLSBOdW1iZXJcXHJcXG5cXHQgKiAgY29sb3IgLSBjb2xvciBpbiBoZXggdmFsdWVcXHJcXG5cXHQgKiAgaGVhZExlbmd0aCAtIE51bWJlclxcclxcblxcdCAqICBoZWFkV2lkdGggLSBOdW1iZXJcXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHR2YXIgbGluZUdlb21ldHJ5O1xcclxcblxcdHZhciBjb25lR2VvbWV0cnk7XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gQXJyb3dIZWxwZXIoIGRpciwgb3JpZ2luLCBsZW5ndGgsIGNvbG9yLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKSB7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gZGlyIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxcclxcblxcclxcblxcdFxcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSBjb2xvciA9IDB4ZmZmZjAwO1xcclxcblxcdFxcdGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSAxO1xcclxcblxcdFxcdGlmICggaGVhZExlbmd0aCA9PT0gdW5kZWZpbmVkICkgaGVhZExlbmd0aCA9IDAuMiAqIGxlbmd0aDtcXHJcXG5cXHRcXHRpZiAoIGhlYWRXaWR0aCA9PT0gdW5kZWZpbmVkICkgaGVhZFdpZHRoID0gMC4yICogaGVhZExlbmd0aDtcXHJcXG5cXHJcXG5cXHRcXHRpZiAoIGxpbmVHZW9tZXRyeSA9PT0gdW5kZWZpbmVkICkge1xcclxcblxcclxcblxcdFxcdFxcdGxpbmVHZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xcclxcblxcdFxcdFxcdGxpbmVHZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBbIDAsIDAsIDAsIDAsIDEsIDAgXSwgMyApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uZUdlb21ldHJ5ID0gbmV3IEN5bGluZGVyQnVmZmVyR2VvbWV0cnkoIDAsIDAuNSwgMSwgNSwgMSApO1xcclxcblxcdFxcdFxcdGNvbmVHZW9tZXRyeS50cmFuc2xhdGUoIDAsIC0gMC41LCAwICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdHRoaXMucG9zaXRpb24uY29weSggb3JpZ2luICk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5saW5lID0gbmV3IExpbmUoIGxpbmVHZW9tZXRyeSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciB9ICkgKTtcXHJcXG5cXHRcXHR0aGlzLmxpbmUubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xcclxcblxcdFxcdHRoaXMuYWRkKCB0aGlzLmxpbmUgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmNvbmUgPSBuZXcgTWVzaCggY29uZUdlb21ldHJ5LCBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSApO1xcclxcblxcdFxcdHRoaXMuY29uZS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XFxyXFxuXFx0XFx0dGhpcy5hZGQoIHRoaXMuY29uZSApO1xcclxcblxcclxcblxcdFxcdHRoaXMuc2V0RGlyZWN0aW9uKCBkaXIgKTtcXHJcXG5cXHRcXHR0aGlzLnNldExlbmd0aCggbGVuZ3RoLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0QXJyb3dIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICk7XFxyXFxuXFx0QXJyb3dIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXJyb3dIZWxwZXI7XFxyXFxuXFxyXFxuXFx0QXJyb3dIZWxwZXIucHJvdG90eXBlLnNldERpcmVjdGlvbiA9ICggZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdHZhciBheGlzID0gbmV3IFZlY3RvcjMoKTtcXHJcXG5cXHRcXHR2YXIgcmFkaWFucztcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gZnVuY3Rpb24gc2V0RGlyZWN0aW9uKCBkaXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gZGlyIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxcclxcblxcclxcblxcdFxcdFxcdGlmICggZGlyLnkgPiAwLjk5OTk5ICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMucXVhdGVybmlvbi5zZXQoIDAsIDAsIDAsIDEgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBkaXIueSA8IC0gMC45OTk5OSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnF1YXRlcm5pb24uc2V0KCAxLCAwLCAwLCAwICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRheGlzLnNldCggZGlyLnosIDAsIC0gZGlyLnggKS5ub3JtYWxpemUoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyYWRpYW5zID0gTWF0aC5hY29zKCBkaXIueSApO1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCByYWRpYW5zICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH07XFxyXFxuXFxyXFxuXFx0fSgpICk7XFxyXFxuXFxyXFxuXFx0QXJyb3dIZWxwZXIucHJvdG90eXBlLnNldExlbmd0aCA9IGZ1bmN0aW9uICggbGVuZ3RoLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKSB7XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCBoZWFkTGVuZ3RoID09PSB1bmRlZmluZWQgKSBoZWFkTGVuZ3RoID0gMC4yICogbGVuZ3RoO1xcclxcblxcdFxcdGlmICggaGVhZFdpZHRoID09PSB1bmRlZmluZWQgKSBoZWFkV2lkdGggPSAwLjIgKiBoZWFkTGVuZ3RoO1xcclxcblxcclxcblxcdFxcdHRoaXMubGluZS5zY2FsZS5zZXQoIDEsIE1hdGgubWF4KCAwLCBsZW5ndGggLSBoZWFkTGVuZ3RoICksIDEgKTtcXHJcXG5cXHRcXHR0aGlzLmxpbmUudXBkYXRlTWF0cml4KCk7XFxyXFxuXFxyXFxuXFx0XFx0dGhpcy5jb25lLnNjYWxlLnNldCggaGVhZFdpZHRoLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKTtcXHJcXG5cXHRcXHR0aGlzLmNvbmUucG9zaXRpb24ueSA9IGxlbmd0aDtcXHJcXG5cXHRcXHR0aGlzLmNvbmUudXBkYXRlTWF0cml4KCk7XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHRBcnJvd0hlbHBlci5wcm90b3R5cGUuc2V0Q29sb3IgPSBmdW5jdGlvbiAoIGNvbG9yICkge1xcclxcblxcclxcblxcdFxcdHRoaXMubGluZS5tYXRlcmlhbC5jb2xvci5jb3B5KCBjb2xvciApO1xcclxcblxcdFxcdHRoaXMuY29uZS5tYXRlcmlhbC5jb2xvci5jb3B5KCBjb2xvciApO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBzcm91Y2hlcmF5IC8gaHR0cDovL3Nyb3VjaGVyYXkub3JnL1xcclxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxyXFxuXFx0ICovXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gQXhlc0hlbHBlciggc2l6ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRzaXplID0gc2l6ZSB8fCAxO1xcclxcblxcclxcblxcdFxcdHZhciB2ZXJ0aWNlcyA9IFtcXHJcXG5cXHRcXHRcXHQwLCAwLCAwLFxcdHNpemUsIDAsIDAsXFxyXFxuXFx0XFx0XFx0MCwgMCwgMCxcXHQwLCBzaXplLCAwLFxcclxcblxcdFxcdFxcdDAsIDAsIDAsXFx0MCwgMCwgc2l6ZVxcclxcblxcdFxcdF07XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGNvbG9ycyA9IFtcXHJcXG5cXHRcXHRcXHQxLCAwLCAwLFxcdDEsIDAuNiwgMCxcXHJcXG5cXHRcXHRcXHQwLCAxLCAwLFxcdDAuNiwgMSwgMCxcXHJcXG5cXHRcXHRcXHQwLCAwLCAxLFxcdDAsIDAuNiwgMVxcclxcblxcdFxcdF07XFxyXFxuXFxyXFxuXFx0XFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XFxyXFxuXFx0XFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xcclxcblxcdFxcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApICk7XFxyXFxuXFxyXFxuXFx0XFx0dmFyIG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVmVydGV4Q29sb3JzIH0gKTtcXHJcXG5cXHJcXG5cXHRcXHRMaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdEF4ZXNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xcclxcblxcdEF4ZXNIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXhlc0hlbHBlcjtcXHJcXG5cXHJcXG5cXHQvKipcXHJcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcclxcblxcdCAqL1xcclxcblxcclxcblxcdHZhciBTY2VuZVV0aWxzID0ge1xcclxcblxcclxcblxcdFxcdGNyZWF0ZU11bHRpTWF0ZXJpYWxPYmplY3Q6IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFscyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgZ3JvdXAgPSBuZXcgR3JvdXAoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBtYXRlcmlhbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRncm91cC5hZGQoIG5ldyBNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWxzWyBpIF0gKSApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZ3JvdXA7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRkZXRhY2g6IGZ1bmN0aW9uICggY2hpbGQsIHBhcmVudCwgc2NlbmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y2hpbGQuYXBwbHlNYXRyaXgoIHBhcmVudC5tYXRyaXhXb3JsZCApO1xcclxcblxcdFxcdFxcdHBhcmVudC5yZW1vdmUoIGNoaWxkICk7XFxyXFxuXFx0XFx0XFx0c2NlbmUuYWRkKCBjaGlsZCApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0YXR0YWNoOiBmdW5jdGlvbiAoIGNoaWxkLCBzY2VuZSwgcGFyZW50ICkge1xcclxcblxcclxcblxcdFxcdFxcdGNoaWxkLmFwcGx5TWF0cml4KCBuZXcgTWF0cml4NCgpLmdldEludmVyc2UoIHBhcmVudC5tYXRyaXhXb3JsZCApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0c2NlbmUucmVtb3ZlKCBjaGlsZCApO1xcclxcblxcdFxcdFxcdHBhcmVudC5hZGQoIGNoaWxkICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0LyoqXFxyXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBGYWNlNCggYSwgYiwgYywgZCwgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5GYWNlNCBoYXMgYmVlbiByZW1vdmVkLiBBIFRIUkVFLkZhY2UzIHdpbGwgYmUgY3JlYXRlZCBpbnN0ZWFkLicgKTtcXHJcXG5cXHRcXHRyZXR1cm4gbmV3IEZhY2UzKCBhLCBiLCBjLCBub3JtYWwsIGNvbG9yLCBtYXRlcmlhbEluZGV4ICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdHZhciBMaW5lU3RyaXAgPSAwO1xcclxcblxcclxcblxcdHZhciBMaW5lUGllY2VzID0gMTtcXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBNZXNoRmFjZU1hdGVyaWFsKCBtYXRlcmlhbHMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWVzaEZhY2VNYXRlcmlhbCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgYW4gQXJyYXkgaW5zdGVhZC4nICk7XFxyXFxuXFx0XFx0cmV0dXJuIG1hdGVyaWFscztcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gTXVsdGlNYXRlcmlhbCggbWF0ZXJpYWxzICkge1xcclxcblxcclxcblxcdFxcdGlmICggbWF0ZXJpYWxzID09PSB1bmRlZmluZWQgKSBtYXRlcmlhbHMgPSBbXTtcXHJcXG5cXHJcXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5NdWx0aU1hdGVyaWFsIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBhbiBBcnJheSBpbnN0ZWFkLicgKTtcXHJcXG5cXHRcXHRtYXRlcmlhbHMuaXNNdWx0aU1hdGVyaWFsID0gdHJ1ZTtcXHJcXG5cXHRcXHRtYXRlcmlhbHMubWF0ZXJpYWxzID0gbWF0ZXJpYWxzO1xcclxcblxcdFxcdG1hdGVyaWFscy5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gbWF0ZXJpYWxzLnNsaWNlKCk7XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHRcXHRyZXR1cm4gbWF0ZXJpYWxzO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBQb2ludENsb3VkKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUG9pbnRDbG91ZCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50cy4nICk7XFxyXFxuXFx0XFx0cmV0dXJuIG5ldyBQb2ludHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBQYXJ0aWNsZSggbWF0ZXJpYWwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUGFydGljbGUgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5TcHJpdGUuJyApO1xcclxcblxcdFxcdHJldHVybiBuZXcgU3ByaXRlKCBtYXRlcmlhbCApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBQYXJ0aWNsZVN5c3RlbSggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xcclxcblxcclxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlBhcnRpY2xlU3lzdGVtIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzLicgKTtcXHJcXG5cXHRcXHRyZXR1cm4gbmV3IFBvaW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdGZ1bmN0aW9uIFBvaW50Q2xvdWRNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHNNYXRlcmlhbC4nICk7XFxyXFxuXFx0XFx0cmV0dXJuIG5ldyBQb2ludHNNYXRlcmlhbCggcGFyYW1ldGVycyApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBQYXJ0aWNsZUJhc2ljTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUGFydGljbGVCYXNpY01hdGVyaWFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzTWF0ZXJpYWwuJyApO1xcclxcblxcdFxcdHJldHVybiBuZXcgUG9pbnRzTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gUGFydGljbGVTeXN0ZW1NYXRlcmlhbCggcGFyYW1ldGVycyApIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5QYXJ0aWNsZVN5c3RlbU1hdGVyaWFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzTWF0ZXJpYWwuJyApO1xcclxcblxcdFxcdHJldHVybiBuZXcgUG9pbnRzTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gVmVydGV4KCB4LCB5LCB6ICkge1xcclxcblxcclxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlcnRleCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuVmVjdG9yMyBpbnN0ZWFkLicgKTtcXHJcXG5cXHRcXHRyZXR1cm4gbmV3IFZlY3RvcjMoIHgsIHksIHogKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0Ly9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBEeW5hbWljQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRHluYW1pY0J1ZmZlckF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSgpLnNldER5bmFtaWMoIHRydWUgKSBpbnN0ZWFkLicgKTtcXHJcXG5cXHRcXHRyZXR1cm4gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkuc2V0RHluYW1pYyggdHJ1ZSApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBJbnQ4QXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW50OEF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkludDhCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLicgKTtcXHJcXG5cXHRcXHRyZXR1cm4gbmV3IEludDhCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBVaW50OEF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkge1xcclxcblxcclxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlVpbnQ4QXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuVWludDhCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLicgKTtcXHJcXG5cXHRcXHRyZXR1cm4gbmV3IFVpbnQ4QnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gVWludDhDbGFtcGVkQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVWludDhDbGFtcGVkQXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlKCkgaW5zdGVhZC4nICk7XFxyXFxuXFx0XFx0cmV0dXJuIG5ldyBVaW50OENsYW1wZWRCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBJbnQxNkF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkge1xcclxcblxcclxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkludDE2QXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuSW50MTZCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLicgKTtcXHJcXG5cXHRcXHRyZXR1cm4gbmV3IEludDE2QnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gVWludDE2QXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVWludDE2QXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuVWludDE2QnVmZmVyQXR0cmlidXRlKCkgaW5zdGVhZC4nICk7XFxyXFxuXFx0XFx0cmV0dXJuIG5ldyBVaW50MTZCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBJbnQzMkF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkge1xcclxcblxcclxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkludDMyQXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuSW50MzJCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLicgKTtcXHJcXG5cXHRcXHRyZXR1cm4gbmV3IEludDMyQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gVWludDMyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVWludDMyQXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuVWludDMyQnVmZmVyQXR0cmlidXRlKCkgaW5zdGVhZC4nICk7XFxyXFxuXFx0XFx0cmV0dXJuIG5ldyBVaW50MzJCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBGbG9hdDMyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLicgKTtcXHJcXG5cXHRcXHRyZXR1cm4gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBGbG9hdDY0QXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRmxvYXQ2NEF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkZsb2F0NjRCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLicgKTtcXHJcXG5cXHRcXHRyZXR1cm4gbmV3IEZsb2F0NjRCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHQvL1xcclxcblxcclxcblxcdEN1cnZlLmNyZWF0ZSA9IGZ1bmN0aW9uICggY29uc3RydWN0LCBnZXRQb2ludCApIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zb2xlLmxvZyggJ1RIUkVFLkN1cnZlLmNyZWF0ZSgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQnICk7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc3RydWN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN1cnZlLnByb3RvdHlwZSApO1xcclxcblxcdFxcdGNvbnN0cnVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3Q7XFxyXFxuXFx0XFx0Y29uc3RydWN0LnByb3RvdHlwZS5nZXRQb2ludCA9IGdldFBvaW50O1xcclxcblxcclxcblxcdFxcdHJldHVybiBjb25zdHJ1Y3Q7XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHQvL1xcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIEN1cnZlUGF0aC5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHRjcmVhdGVQb2ludHNHZW9tZXRyeTogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ3VydmVQYXRoOiAuY3JlYXRlUG9pbnRzR2VvbWV0cnkoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkdlb21ldHJ5KCkuc2V0RnJvbVBvaW50cyggcG9pbnRzICkgaW5zdGVhZC4nICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gZ2VuZXJhdGUgZ2VvbWV0cnkgZnJvbSBwYXRoIHBvaW50cyAoZm9yIExpbmUgb3IgUG9pbnRzIG9iamVjdHMpXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHB0cyA9IHRoaXMuZ2V0UG9pbnRzKCBkaXZpc2lvbnMgKTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeSggcHRzICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjcmVhdGVTcGFjZWRQb2ludHNHZW9tZXRyeTogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ3VydmVQYXRoOiAuY3JlYXRlU3BhY2VkUG9pbnRzR2VvbWV0cnkoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkdlb21ldHJ5KCkuc2V0RnJvbVBvaW50cyggcG9pbnRzICkgaW5zdGVhZC4nICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Ly8gZ2VuZXJhdGUgZ2VvbWV0cnkgZnJvbSBlcXVpZGlzdGFudCBzYW1wbGluZyBhbG9uZyB0aGUgcGF0aFxcclxcblxcclxcblxcdFxcdFxcdHZhciBwdHMgPSB0aGlzLmdldFNwYWNlZFBvaW50cyggZGl2aXNpb25zICk7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnkoIHB0cyApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Y3JlYXRlR2VvbWV0cnk6IGZ1bmN0aW9uICggcG9pbnRzICkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkN1cnZlUGF0aDogLmNyZWF0ZUdlb21ldHJ5KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5HZW9tZXRyeSgpLnNldEZyb21Qb2ludHMoIHBvaW50cyApIGluc3RlYWQuJyApO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeSgpO1xcclxcblxcclxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHZhciBwb2ludCA9IHBvaW50c1sgaSBdO1xcclxcblxcdFxcdFxcdFxcdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBWZWN0b3IzKCBwb2ludC54LCBwb2ludC55LCBwb2ludC56IHx8IDAgKSApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZ2VvbWV0cnk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvL1xcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIFBhdGgucHJvdG90eXBlLCB7XFxyXFxuXFxyXFxuXFx0XFx0ZnJvbVBvaW50czogZnVuY3Rpb24gKCBwb2ludHMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUGF0aDogLmZyb21Qb2ludHMoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tUG9pbnRzKCkuJyApO1xcclxcblxcdFxcdFxcdHRoaXMuc2V0RnJvbVBvaW50cyggcG9pbnRzICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIENsb3NlZFNwbGluZUN1cnZlMyggcG9pbnRzICkge1xcclxcblxcclxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNsb3NlZFNwbGluZUN1cnZlMyBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgVEhSRUUuQ2F0bXVsbFJvbUN1cnZlMyBpbnN0ZWFkLicgKTtcXHJcXG5cXHJcXG5cXHRcXHRDYXRtdWxsUm9tQ3VydmUzLmNhbGwoIHRoaXMsIHBvaW50cyApO1xcclxcblxcdFxcdHRoaXMudHlwZSA9ICdjYXRtdWxscm9tJztcXHJcXG5cXHRcXHR0aGlzLmNsb3NlZCA9IHRydWU7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdENsb3NlZFNwbGluZUN1cnZlMy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDYXRtdWxsUm9tQ3VydmUzLnByb3RvdHlwZSApO1xcclxcblxcclxcblxcdC8vXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gU3BsaW5lQ3VydmUzKCBwb2ludHMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU3BsaW5lQ3VydmUzIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBUSFJFRS5DYXRtdWxsUm9tQ3VydmUzIGluc3RlYWQuJyApO1xcclxcblxcclxcblxcdFxcdENhdG11bGxSb21DdXJ2ZTMuY2FsbCggdGhpcywgcG9pbnRzICk7XFxyXFxuXFx0XFx0dGhpcy50eXBlID0gJ2NhdG11bGxyb20nO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRTcGxpbmVDdXJ2ZTMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ2F0bXVsbFJvbUN1cnZlMy5wcm90b3R5cGUgKTtcXHJcXG5cXHJcXG5cXHQvL1xcclxcblxcclxcblxcdGZ1bmN0aW9uIFNwbGluZSggcG9pbnRzICkge1xcclxcblxcclxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNwbGluZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuQ2F0bXVsbFJvbUN1cnZlMyBpbnN0ZWFkLicgKTtcXHJcXG5cXHJcXG5cXHRcXHRDYXRtdWxsUm9tQ3VydmUzLmNhbGwoIHRoaXMsIHBvaW50cyApO1xcclxcblxcdFxcdHRoaXMudHlwZSA9ICdjYXRtdWxscm9tJztcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0U3BsaW5lLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENhdG11bGxSb21DdXJ2ZTMucHJvdG90eXBlICk7XFxyXFxuXFxyXFxuXFx0T2JqZWN0LmFzc2lnbiggU3BsaW5lLnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdGluaXRGcm9tQXJyYXk6IGZ1bmN0aW9uICggLyogYSAqLyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuU3BsaW5lOiAuaW5pdEZyb21BcnJheSgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0Z2V0Q29udHJvbFBvaW50c0FycmF5OiBmdW5jdGlvbiAoIC8qIG9wdGlvbmFsVGFyZ2V0ICovICkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5TcGxpbmU6IC5nZXRDb250cm9sUG9pbnRzQXJyYXkoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdHJlcGFyYW1ldHJpemVCeUFyY0xlbmd0aDogZnVuY3Rpb24gKCAvKiBzYW1wbGluZ0NvZWYgKi8gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlNwbGluZTogLnJlcGFyYW1ldHJpemVCeUFyY0xlbmd0aCgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0Ly9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBBeGlzSGVscGVyKCBzaXplICkge1xcclxcblxcclxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF4aXNIZWxwZXIgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5BeGVzSGVscGVyLicgKTtcXHJcXG5cXHRcXHRyZXR1cm4gbmV3IEF4ZXNIZWxwZXIoIHNpemUgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gQm91bmRpbmdCb3hIZWxwZXIoIG9iamVjdCwgY29sb3IgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm91bmRpbmdCb3hIZWxwZXIgaGFzIGJlZW4gZGVwcmVjYXRlZC4gQ3JlYXRpbmcgYSBUSFJFRS5Cb3hIZWxwZXIgaW5zdGVhZC4nICk7XFxyXFxuXFx0XFx0cmV0dXJuIG5ldyBCb3hIZWxwZXIoIG9iamVjdCwgY29sb3IgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gRWRnZXNIZWxwZXIoIG9iamVjdCwgaGV4ICkge1xcclxcblxcclxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkVkZ2VzSGVscGVyIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5FZGdlc0dlb21ldHJ5IGluc3RlYWQuJyApO1xcclxcblxcdFxcdHJldHVybiBuZXcgTGluZVNlZ21lbnRzKCBuZXcgRWRnZXNHZW9tZXRyeSggb2JqZWN0Lmdlb21ldHJ5ICksIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogaGV4ICE9PSB1bmRlZmluZWQgPyBoZXggOiAweGZmZmZmZiB9ICkgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0R3JpZEhlbHBlci5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5HcmlkSGVscGVyOiBzZXRDb2xvcnMoKSBoYXMgYmVlbiBkZXByZWNhdGVkLCBwYXNzIHRoZW0gaW4gdGhlIGNvbnN0cnVjdG9yIGluc3RlYWQuJyApO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0U2tlbGV0b25IZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuU2tlbGV0b25IZWxwZXI6IHVwZGF0ZSgpIG5vIGxvbmdlciBuZWVkcyB0byBiZSBjYWxsZWQuJyApO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gV2lyZWZyYW1lSGVscGVyKCBvYmplY3QsIGhleCApIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XaXJlZnJhbWVIZWxwZXIgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLldpcmVmcmFtZUdlb21ldHJ5IGluc3RlYWQuJyApO1xcclxcblxcdFxcdHJldHVybiBuZXcgTGluZVNlZ21lbnRzKCBuZXcgV2lyZWZyYW1lR2VvbWV0cnkoIG9iamVjdC5nZW9tZXRyeSApLCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGhleCAhPT0gdW5kZWZpbmVkID8gaGV4IDogMHhmZmZmZmYgfSApICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8vXFxyXFxuXFxyXFxuXFx0T2JqZWN0LmFzc2lnbiggTG9hZGVyLnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdGV4dHJhY3RVcmxCYXNlOiBmdW5jdGlvbiAoIHVybCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5Mb2FkZXI6IC5leHRyYWN0VXJsQmFzZSgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBUSFJFRS5Mb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSgpIGluc3RlYWQuJyApO1xcclxcblxcdFxcdFxcdHJldHVybiBMb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSggdXJsICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBYSFJMb2FkZXIoIG1hbmFnZXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuWEhSTG9hZGVyIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuRmlsZUxvYWRlci4nICk7XFxyXFxuXFx0XFx0cmV0dXJuIG5ldyBGaWxlTG9hZGVyKCBtYW5hZ2VyICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdGZ1bmN0aW9uIEJpbmFyeVRleHR1cmVMb2FkZXIoIG1hbmFnZXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQmluYXJ5VGV4dHVyZUxvYWRlciBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLkRhdGFUZXh0dXJlTG9hZGVyLicgKTtcXHJcXG5cXHRcXHRyZXR1cm4gbmV3IERhdGFUZXh0dXJlTG9hZGVyKCBtYW5hZ2VyICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8vXFxyXFxuXFxyXFxuXFx0T2JqZWN0LmFzc2lnbiggQm94Mi5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHRjZW50ZXI6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MjogLmNlbnRlcigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldENlbnRlcigpLicgKTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5nZXRDZW50ZXIoIG9wdGlvbmFsVGFyZ2V0ICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHRlbXB0eTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveDI6IC5lbXB0eSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmlzRW1wdHkoKS4nICk7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuaXNFbXB0eSgpO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0aXNJbnRlcnNlY3Rpb25Cb3g6IGZ1bmN0aW9uICggYm94ICkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveDI6IC5pc0ludGVyc2VjdGlvbkJveCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNCb3goKS4nICk7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c0JveCggYm94ICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHRzaXplOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveDI6IC5zaXplKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0U2l6ZSgpLicgKTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5nZXRTaXplKCBvcHRpb25hbFRhcmdldCApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0T2JqZWN0LmFzc2lnbiggQm94My5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHRjZW50ZXI6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MzogLmNlbnRlcigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldENlbnRlcigpLicgKTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5nZXRDZW50ZXIoIG9wdGlvbmFsVGFyZ2V0ICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHRlbXB0eTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveDM6IC5lbXB0eSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmlzRW1wdHkoKS4nICk7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuaXNFbXB0eSgpO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0aXNJbnRlcnNlY3Rpb25Cb3g6IGZ1bmN0aW9uICggYm94ICkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveDM6IC5pc0ludGVyc2VjdGlvbkJveCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNCb3goKS4nICk7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c0JveCggYm94ICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHRpc0ludGVyc2VjdGlvblNwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MzogLmlzSW50ZXJzZWN0aW9uU3BoZXJlKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c1NwaGVyZSgpLicgKTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdHNpemU6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MzogLnNpemUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRTaXplKCkuJyApO1xcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmdldFNpemUoIG9wdGlvbmFsVGFyZ2V0ICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHRMaW5lMy5wcm90b3R5cGUuY2VudGVyID0gZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5MaW5lMzogLmNlbnRlcigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldENlbnRlcigpLicgKTtcXHJcXG5cXHRcXHRyZXR1cm4gdGhpcy5nZXRDZW50ZXIoIG9wdGlvbmFsVGFyZ2V0ICk7XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHRPYmplY3QuYXNzaWduKCBfTWF0aCwge1xcclxcblxcclxcblxcdFxcdHJhbmRvbTE2OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0aDogLnJhbmRvbTE2KCkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIE1hdGgucmFuZG9tKCkgaW5zdGVhZC4nICk7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIE1hdGgucmFuZG9tKCk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRuZWFyZXN0UG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRoOiAubmVhcmVzdFBvd2VyT2ZUd28oKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5mbG9vclBvd2VyT2ZUd28oKS4nICk7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIF9NYXRoLmZsb29yUG93ZXJPZlR3byggdmFsdWUgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdG5leHRQb3dlck9mVHdvOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGg6IC5uZXh0UG93ZXJPZlR3bygpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmNlaWxQb3dlck9mVHdvKCkuJyApO1xcclxcblxcdFxcdFxcdHJldHVybiBfTWF0aC5jZWlsUG93ZXJPZlR3byggdmFsdWUgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIE1hdHJpeDMucHJvdG90eXBlLCB7XFxyXFxuXFxyXFxuXFx0XFx0ZmxhdHRlblRvQXJyYXlPZmZzZXQ6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oIFxcXCJUSFJFRS5NYXRyaXgzOiAuZmxhdHRlblRvQXJyYXlPZmZzZXQoKSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLnRvQXJyYXkoKSBpbnN0ZWFkLlxcXCIgKTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy50b0FycmF5KCBhcnJheSwgb2Zmc2V0ICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHRtdWx0aXBseVZlY3RvcjM6IGZ1bmN0aW9uICggdmVjdG9yICkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDM6IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4MyggbWF0cml4ICkgaW5zdGVhZC4nICk7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDMoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdG11bHRpcGx5VmVjdG9yM0FycmF5OiBmdW5jdGlvbiAoIC8qIGEgKi8gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDM6IC5tdWx0aXBseVZlY3RvcjNBcnJheSgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0YXBwbHlUb0J1ZmZlcjogZnVuY3Rpb24gKCBidWZmZXIgLyosIG9mZnNldCwgbGVuZ3RoICovICkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDM6IC5hcHBseVRvQnVmZmVyKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG1hdHJpeC5hcHBseVRvQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSBpbnN0ZWFkLicgKTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5hcHBseVRvQnVmZmVyQXR0cmlidXRlKCBidWZmZXIgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdGFwcGx5VG9WZWN0b3IzQXJyYXk6IGZ1bmN0aW9uICggLyogYXJyYXksIG9mZnNldCwgbGVuZ3RoICovICkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXgzOiAuYXBwbHlUb1ZlY3RvcjNBcnJheSgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0T2JqZWN0LmFzc2lnbiggTWF0cml4NC5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHRleHRyYWN0UG9zaXRpb246IGZ1bmN0aW9uICggbSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuZXh0cmFjdFBvc2l0aW9uKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuY29weVBvc2l0aW9uKCkuJyApO1xcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmNvcHlQb3NpdGlvbiggbSApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0ZmxhdHRlblRvQXJyYXlPZmZzZXQ6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oIFxcXCJUSFJFRS5NYXRyaXg0OiAuZmxhdHRlblRvQXJyYXlPZmZzZXQoKSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLnRvQXJyYXkoKSBpbnN0ZWFkLlxcXCIgKTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy50b0FycmF5KCBhcnJheSwgb2Zmc2V0ICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHRnZXRQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdHZhciB2MTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gZ2V0UG9zaXRpb24oKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVmVjdG9yMygpO1xcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5nZXRQb3NpdGlvbigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBWZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbWF0cml4ICkgaW5zdGVhZC4nICk7XFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHYxLnNldEZyb21NYXRyaXhDb2x1bW4oIHRoaXMsIDMgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9O1xcclxcblxcclxcblxcdFxcdH0oKSxcXHJcXG5cXHRcXHRzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLnNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24oKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbigpLicgKTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiggcSApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0bXVsdGlwbHlUb0FycmF5OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5VG9BcnJheSgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0bXVsdGlwbHlWZWN0b3IzOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIGluc3RlYWQuJyApO1xcclxcblxcdFxcdFxcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCB0aGlzICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHRtdWx0aXBseVZlY3RvcjQ6IGZ1bmN0aW9uICggdmVjdG9yICkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjQoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgaW5zdGVhZC4nICk7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdG11bHRpcGx5VmVjdG9yM0FycmF5OiBmdW5jdGlvbiAoIC8qIGEgKi8gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjNBcnJheSgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0cm90YXRlQXhpczogZnVuY3Rpb24gKCB2ICkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVBeGlzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFZlY3RvcjMudHJhbnNmb3JtRGlyZWN0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcXHJcXG5cXHRcXHRcXHR2LnRyYW5zZm9ybURpcmVjdGlvbiggdGhpcyApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0Y3Jvc3NWZWN0b3I6IGZ1bmN0aW9uICggdmVjdG9yICkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5jcm9zc1ZlY3RvcigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggdGhpcyApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC50cmFuc2xhdGUoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdHJvdGF0ZVg6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZVgoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZVkoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdHJvdGF0ZVo6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZVooKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdHJvdGF0ZUJ5QXhpczogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAucm90YXRlQnlBeGlzKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHRhcHBseVRvQnVmZmVyOiBmdW5jdGlvbiAoIGJ1ZmZlciAvKiwgb2Zmc2V0LCBsZW5ndGggKi8gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLmFwcGx5VG9CdWZmZXIoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbWF0cml4LmFwcGx5VG9CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIGluc3RlYWQuJyApO1xcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmFwcGx5VG9CdWZmZXJBdHRyaWJ1dGUoIGJ1ZmZlciApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0YXBwbHlUb1ZlY3RvcjNBcnJheTogZnVuY3Rpb24gKCAvKiBhcnJheSwgb2Zmc2V0LCBsZW5ndGggKi8gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5hcHBseVRvVmVjdG9yM0FycmF5KCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHRtYWtlRnJ1c3R1bTogZnVuY3Rpb24gKCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubWFrZUZydXN0dW0oKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgLm1ha2VQZXJzcGVjdGl2ZSggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIgKSBpbnN0ZWFkLicgKTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5tYWtlUGVyc3BlY3RpdmUoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHRQbGFuZS5wcm90b3R5cGUuaXNJbnRlcnNlY3Rpb25MaW5lID0gZnVuY3Rpb24gKCBsaW5lICkge1xcclxcblxcclxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlBsYW5lOiAuaXNJbnRlcnNlY3Rpb25MaW5lKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c0xpbmUoKS4nICk7XFxyXFxuXFx0XFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c0xpbmUoIGxpbmUgKTtcXHJcXG5cXHJcXG5cXHR9O1xcclxcblxcclxcblxcdFF1YXRlcm5pb24ucHJvdG90eXBlLm11bHRpcGx5VmVjdG9yMyA9IGZ1bmN0aW9uICggdmVjdG9yICkge1xcclxcblxcclxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlF1YXRlcm5pb246IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgaXMgbm93IHZlY3Rvci5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKSBpbnN0ZWFkLicgKTtcXHJcXG5cXHRcXHRyZXR1cm4gdmVjdG9yLmFwcGx5UXVhdGVybmlvbiggdGhpcyApO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0T2JqZWN0LmFzc2lnbiggUmF5LnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdGlzSW50ZXJzZWN0aW9uQm94OiBmdW5jdGlvbiAoIGJveCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5SYXk6IC5pc0ludGVyc2VjdGlvbkJveCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNCb3goKS4nICk7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c0JveCggYm94ICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHRpc0ludGVyc2VjdGlvblBsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlJheTogLmlzSW50ZXJzZWN0aW9uUGxhbmUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzUGxhbmUoKS4nICk7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c1BsYW5lKCBwbGFuZSApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0aXNJbnRlcnNlY3Rpb25TcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlJheTogLmlzSW50ZXJzZWN0aW9uU3BoZXJlKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c1NwaGVyZSgpLicgKTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIFNoYXBlLnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdGV4dHJhY3RBbGxQb2ludHM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNoYXBlOiAuZXh0cmFjdEFsbFBvaW50cygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAuZXh0cmFjdFBvaW50cygpIGluc3RlYWQuJyApO1xcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmV4dHJhY3RQb2ludHMoIGRpdmlzaW9ucyApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0ZXh0cnVkZTogZnVuY3Rpb24gKCBvcHRpb25zICkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNoYXBlOiAuZXh0cnVkZSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBFeHRydWRlR2VvbWV0cnkoKSBpbnN0ZWFkLicgKTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gbmV3IEV4dHJ1ZGVHZW9tZXRyeSggdGhpcywgb3B0aW9ucyApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0bWFrZUdlb21ldHJ5OiBmdW5jdGlvbiAoIG9wdGlvbnMgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU2hhcGU6IC5tYWtlR2VvbWV0cnkoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgU2hhcGVHZW9tZXRyeSgpIGluc3RlYWQuJyApO1xcclxcblxcdFxcdFxcdHJldHVybiBuZXcgU2hhcGVHZW9tZXRyeSggdGhpcywgb3B0aW9ucyApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0T2JqZWN0LmFzc2lnbiggVmVjdG9yMi5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHRmcm9tQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IyOiAuZnJvbUF0dHJpYnV0ZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmZyb21CdWZmZXJBdHRyaWJ1dGUoKS4nICk7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHRkaXN0YW5jZVRvTWFuaGF0dGFuOiBmdW5jdGlvbiAoIHYgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMjogLmRpc3RhbmNlVG9NYW5oYXR0YW4oKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5tYW5oYXR0YW5EaXN0YW5jZVRvKCkuJyApO1xcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLm1hbmhhdHRhbkRpc3RhbmNlVG8oIHYgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdGxlbmd0aE1hbmhhdHRhbjogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjI6IC5sZW5ndGhNYW5oYXR0YW4oKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5tYW5oYXR0YW5MZW5ndGgoKS4nICk7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMubWFuaGF0dGFuTGVuZ3RoKCk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHRPYmplY3QuYXNzaWduKCBWZWN0b3IzLnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdHNldEV1bGVyRnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlZlY3RvcjM6IC5zZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeCgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBFdWxlci5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBpbnN0ZWFkLicgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdHNldEV1bGVyRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLnNldEV1bGVyRnJvbVF1YXRlcm5pb24oKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgRXVsZXIuc2V0RnJvbVF1YXRlcm5pb24oKSBpbnN0ZWFkLicgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdGdldFBvc2l0aW9uRnJvbU1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5nZXRQb3NpdGlvbkZyb21NYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tTWF0cml4UG9zaXRpb24oKS4nICk7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBtICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHRnZXRTY2FsZUZyb21NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZ2V0U2NhbGVGcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbU1hdHJpeFNjYWxlKCkuJyApO1xcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXhTY2FsZSggbSApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0Z2V0Q29sdW1uRnJvbU1hdHJpeDogZnVuY3Rpb24gKCBpbmRleCwgbWF0cml4ICkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5nZXRDb2x1bW5Gcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbU1hdHJpeENvbHVtbigpLicgKTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBtYXRyaXgsIGluZGV4ICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHRhcHBseVByb2plY3Rpb246IGZ1bmN0aW9uICggbSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuYXBwbHlQcm9qZWN0aW9uKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIC5hcHBseU1hdHJpeDQoIG0gKSBpbnN0ZWFkLicgKTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQoIG0gKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdGZyb21BdHRyaWJ1dGU6IGZ1bmN0aW9uICggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5mcm9tQXR0cmlidXRlKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSgpLicgKTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5mcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdGRpc3RhbmNlVG9NYW5oYXR0YW46IGZ1bmN0aW9uICggdiApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZGlzdGFuY2VUb01hbmhhdHRhbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLm1hbmhhdHRhbkRpc3RhbmNlVG8oKS4nICk7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMubWFuaGF0dGFuRGlzdGFuY2VUbyggdiApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0bGVuZ3RoTWFuaGF0dGFuOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmxlbmd0aE1hbmhhdHRhbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLm1hbmhhdHRhbkxlbmd0aCgpLicgKTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5tYW5oYXR0YW5MZW5ndGgoKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIFZlY3RvcjQucHJvdG90eXBlLCB7XFxyXFxuXFxyXFxuXFx0XFx0ZnJvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yNDogLmZyb21BdHRyaWJ1dGUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5mcm9tQnVmZmVyQXR0cmlidXRlKCkuJyApO1xcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0bGVuZ3RoTWFuaGF0dGFuOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yNDogLmxlbmd0aE1hbmhhdHRhbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLm1hbmhhdHRhbkxlbmd0aCgpLicgKTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5tYW5oYXR0YW5MZW5ndGgoKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8vXFxyXFxuXFxyXFxuXFx0R2VvbWV0cnkucHJvdG90eXBlLmNvbXB1dGVUYW5nZW50cyA9IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5HZW9tZXRyeTogLmNvbXB1dGVUYW5nZW50cygpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0T2JqZWN0LmFzc2lnbiggT2JqZWN0M0QucHJvdG90eXBlLCB7XFxyXFxuXFxyXFxuXFx0XFx0Z2V0Q2hpbGRCeU5hbWU6IGZ1bmN0aW9uICggbmFtZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLmdldENoaWxkQnlOYW1lKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0T2JqZWN0QnlOYW1lKCkuJyApO1xcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmdldE9iamVjdEJ5TmFtZSggbmFtZSApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0cmVuZGVyRGVwdGg6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLnJlbmRlckRlcHRoIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAucmVuZGVyT3JkZXIsIGluc3RlYWQuJyApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIGRpc3RhbmNlLCBheGlzICkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAudHJhbnNsYXRlKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIC50cmFuc2xhdGVPbkF4aXMoIGF4aXMsIGRpc3RhbmNlICkgaW5zdGVhZC4nICk7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCBheGlzLCBkaXN0YW5jZSApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE9iamVjdDNELnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdGV1bGVyT3JkZXI6IHtcXHJcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLmV1bGVyT3JkZXIgaXMgbm93IC5yb3RhdGlvbi5vcmRlci4nICk7XFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMucm90YXRpb24ub3JkZXI7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSxcXHJcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5ldWxlck9yZGVyIGlzIG5vdyAucm90YXRpb24ub3JkZXIuJyApO1xcclxcblxcdFxcdFxcdFxcdHRoaXMucm90YXRpb24ub3JkZXIgPSB2YWx1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHR1c2VRdWF0ZXJuaW9uOiB7XFxyXFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC51c2VRdWF0ZXJuaW9uIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSBsaWJyYXJ5IG5vdyB1c2VzIHF1YXRlcm5pb25zIGJ5IGRlZmF1bHQuJyApO1xcclxcblxcclxcblxcdFxcdFxcdH0sXFxyXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC51c2VRdWF0ZXJuaW9uIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSBsaWJyYXJ5IG5vdyB1c2VzIHF1YXRlcm5pb25zIGJ5IGRlZmF1bHQuJyApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBMT0QucHJvdG90eXBlLCB7XFxyXFxuXFxyXFxuXFx0XFx0b2JqZWN0czoge1xcclxcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxPRDogLm9iamVjdHMgaGFzIGJlZW4gcmVuYW1lZCB0byAubGV2ZWxzLicgKTtcXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5sZXZlbHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBTa2VsZXRvbi5wcm90b3R5cGUsICd1c2VWZXJ0ZXhUZXh0dXJlJywge1xcclxcblxcclxcblxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNrZWxldG9uOiB1c2VWZXJ0ZXhUZXh0dXJlIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU2tlbGV0b246IHVzZVZlcnRleFRleHR1cmUgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIEN1cnZlLnByb3RvdHlwZSwgJ19fYXJjTGVuZ3RoRGl2aXNpb25zJywge1xcclxcblxcclxcblxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkN1cnZlOiAuX19hcmNMZW5ndGhEaXZpc2lvbnMgaXMgbm93IC5hcmNMZW5ndGhEaXZpc2lvbnMuJyApO1xcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmFyY0xlbmd0aERpdmlzaW9ucztcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5DdXJ2ZTogLl9fYXJjTGVuZ3RoRGl2aXNpb25zIGlzIG5vdyAuYXJjTGVuZ3RoRGl2aXNpb25zLicgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLmFyY0xlbmd0aERpdmlzaW9ucyA9IHZhbHVlO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0Ly9cXHJcXG5cXHJcXG5cXHRQZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuc2V0TGVucyA9IGZ1bmN0aW9uICggZm9jYWxMZW5ndGgsIGZpbG1HYXVnZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zb2xlLndhcm4oIFxcXCJUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5zZXRMZW5zIGlzIGRlcHJlY2F0ZWQuIFxcXCIgK1xcclxcblxcdFxcdFxcdFxcdFxcXCJVc2UgLnNldEZvY2FsTGVuZ3RoIGFuZCAuZmlsbUdhdWdlIGZvciBhIHBob3RvZ3JhcGhpYyBzZXR1cC5cXFwiICk7XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCBmaWxtR2F1Z2UgIT09IHVuZGVmaW5lZCApIHRoaXMuZmlsbUdhdWdlID0gZmlsbUdhdWdlO1xcclxcblxcdFxcdHRoaXMuc2V0Rm9jYWxMZW5ndGgoIGZvY2FsTGVuZ3RoICk7XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHQvL1xcclxcblxcclxcblxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBMaWdodC5wcm90b3R5cGUsIHtcXHJcXG5cXHRcXHRvbmx5U2hhZG93OiB7XFxyXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5vbmx5U2hhZG93IGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdHNoYWRvd0NhbWVyYUZvdjoge1xcclxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYUZvdiBpcyBub3cgLnNoYWRvdy5jYW1lcmEuZm92LicgKTtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnNoYWRvdy5jYW1lcmEuZm92ID0gdmFsdWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0c2hhZG93Q2FtZXJhTGVmdDoge1xcclxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYUxlZnQgaXMgbm93IC5zaGFkb3cuY2FtZXJhLmxlZnQuJyApO1xcclxcblxcdFxcdFxcdFxcdHRoaXMuc2hhZG93LmNhbWVyYS5sZWZ0ID0gdmFsdWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0c2hhZG93Q2FtZXJhUmlnaHQ6IHtcXHJcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFSaWdodCBpcyBub3cgLnNoYWRvdy5jYW1lcmEucmlnaHQuJyApO1xcclxcblxcdFxcdFxcdFxcdHRoaXMuc2hhZG93LmNhbWVyYS5yaWdodCA9IHZhbHVlO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdHNoYWRvd0NhbWVyYVRvcDoge1xcclxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYVRvcCBpcyBub3cgLnNoYWRvdy5jYW1lcmEudG9wLicgKTtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnNoYWRvdy5jYW1lcmEudG9wID0gdmFsdWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0c2hhZG93Q2FtZXJhQm90dG9tOiB7XFxyXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhQm90dG9tIGlzIG5vdyAuc2hhZG93LmNhbWVyYS5ib3R0b20uJyApO1xcclxcblxcdFxcdFxcdFxcdHRoaXMuc2hhZG93LmNhbWVyYS5ib3R0b20gPSB2YWx1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHRzaGFkb3dDYW1lcmFOZWFyOiB7XFxyXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhTmVhciBpcyBub3cgLnNoYWRvdy5jYW1lcmEubmVhci4nICk7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5zaGFkb3cuY2FtZXJhLm5lYXIgPSB2YWx1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHRzaGFkb3dDYW1lcmFGYXI6IHtcXHJcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFGYXIgaXMgbm93IC5zaGFkb3cuY2FtZXJhLmZhci4nICk7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5zaGFkb3cuY2FtZXJhLmZhciA9IHZhbHVlO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdHNoYWRvd0NhbWVyYVZpc2libGU6IHtcXHJcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYVZpc2libGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5DYW1lcmFIZWxwZXIoIGxpZ2h0LnNoYWRvdy5jYW1lcmEgKSBpbnN0ZWFkLicgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHRzaGFkb3dCaWFzOiB7XFxyXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93QmlhcyBpcyBub3cgLnNoYWRvdy5iaWFzLicgKTtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnNoYWRvdy5iaWFzID0gdmFsdWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0c2hhZG93RGFya25lc3M6IHtcXHJcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0RhcmtuZXNzIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdHNoYWRvd01hcFdpZHRoOiB7XFxyXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93TWFwV2lkdGggaXMgbm93IC5zaGFkb3cubWFwU2l6ZS53aWR0aC4nICk7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5zaGFkb3cubWFwU2l6ZS53aWR0aCA9IHZhbHVlO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdHNoYWRvd01hcEhlaWdodDoge1xcclxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd01hcEhlaWdodCBpcyBub3cgLnNoYWRvdy5tYXBTaXplLmhlaWdodC4nICk7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5zaGFkb3cubWFwU2l6ZS5oZWlnaHQgPSB2YWx1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFx0XFx0fVxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvL1xcclxcblxcclxcblxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLCB7XFxyXFxuXFxyXFxuXFx0XFx0bGVuZ3RoOiB7XFxyXFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlOiAubGVuZ3RoIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuY291bnQgaW5zdGVhZC4nICk7XFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdGFkZEluZGV4OiBmdW5jdGlvbiAoIGluZGV4ICkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYWRkSW5kZXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRJbmRleCgpLicgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLnNldEluZGV4KCBpbmRleCApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0YWRkRHJhd0NhbGw6IGZ1bmN0aW9uICggc3RhcnQsIGNvdW50LCBpbmRleE9mZnNldCApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGluZGV4T2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGREcmF3Q2FsbCgpIG5vIGxvbmdlciBzdXBwb3J0cyBpbmRleE9mZnNldC4nICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYWRkRHJhd0NhbGwoKSBpcyBub3cgLmFkZEdyb3VwKCkuJyApO1xcclxcblxcdFxcdFxcdHRoaXMuYWRkR3JvdXAoIHN0YXJ0LCBjb3VudCApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0Y2xlYXJEcmF3Q2FsbHM6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNsZWFyRHJhd0NhbGxzKCkgaXMgbm93IC5jbGVhckdyb3VwcygpLicgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLmNsZWFyR3JvdXBzKCk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHRjb21wdXRlVGFuZ2VudHM6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNvbXB1dGVUYW5nZW50cygpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0Y29tcHV0ZU9mZnNldHM6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNvbXB1dGVPZmZzZXRzKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLCB7XFxyXFxuXFxyXFxuXFx0XFx0ZHJhd2NhbGxzOiB7XFxyXFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuZHJhd2NhbGxzIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdyb3Vwcy4nICk7XFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZ3JvdXBzO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdG9mZnNldHM6IHtcXHJcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLm9mZnNldHMgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ3JvdXBzLicgKTtcXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5ncm91cHM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0Ly9cXHJcXG5cXHJcXG5cXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggVW5pZm9ybS5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHRkeW5hbWljOiB7XFxyXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVW5pZm9ybTogLmR5bmFtaWMgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG9iamVjdC5vbkJlZm9yZVJlbmRlcigpIGluc3RlYWQuJyApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdG9uVXBkYXRlOiB7XFxyXFxuXFx0XFx0XFx0dmFsdWU6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5Vbmlmb3JtOiAub25VcGRhdGUoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2Ugb2JqZWN0Lm9uQmVmb3JlUmVuZGVyKCkgaW5zdGVhZC4nICk7XFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0Ly9cXHJcXG5cXHJcXG5cXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggTWF0ZXJpYWwucHJvdG90eXBlLCB7XFxyXFxuXFxyXFxuXFx0XFx0d3JhcEFyb3VuZDoge1xcclxcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGVyaWFsOiAud3JhcEFyb3VuZCBoYXMgYmVlbiByZW1vdmVkLicgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9LFxcclxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGVyaWFsOiAud3JhcEFyb3VuZCBoYXMgYmVlbiByZW1vdmVkLicgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHR3cmFwUkdCOiB7XFxyXFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0ZXJpYWw6IC53cmFwUkdCIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcclxcblxcdFxcdFxcdFxcdHJldHVybiBuZXcgQ29sb3IoKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzaGFkaW5nOiB7XFxyXFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLicgKyB0aGlzLnR5cGUgKyAnOiAuc2hhZGluZyBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdGhlIGJvb2xlYW4gLmZsYXRTaGFkaW5nIGluc3RlYWQuJyApO1xcclxcblxcclxcblxcdFxcdFxcdH0sXFxyXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLicgKyB0aGlzLnR5cGUgKyAnOiAuc2hhZGluZyBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdGhlIGJvb2xlYW4gLmZsYXRTaGFkaW5nIGluc3RlYWQuJyApO1xcclxcblxcdFxcdFxcdFxcdHRoaXMuZmxhdFNoYWRpbmcgPSAoIHZhbHVlID09PSBGbGF0U2hhZGluZyApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBNZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHRtZXRhbDoge1xcclxcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1lc2hQaG9uZ01hdGVyaWFsOiAubWV0YWwgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsIGluc3RlYWQuJyApO1xcclxcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9LFxcclxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1lc2hQaG9uZ01hdGVyaWFsOiAubWV0YWwgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsIGluc3RlYWQnICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFNoYWRlck1hdGVyaWFsLnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdGRlcml2YXRpdmVzOiB7XFxyXFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU2hhZGVyTWF0ZXJpYWw6IC5kZXJpdmF0aXZlcyBoYXMgYmVlbiBtb3ZlZCB0byAuZXh0ZW5zaW9ucy5kZXJpdmF0aXZlcy4nICk7XFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5kZXJpdmF0aXZlcztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9LFxcclxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS4gU2hhZGVyTWF0ZXJpYWw6IC5kZXJpdmF0aXZlcyBoYXMgYmVlbiBtb3ZlZCB0byAuZXh0ZW5zaW9ucy5kZXJpdmF0aXZlcy4nICk7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5leHRlbnNpb25zLmRlcml2YXRpdmVzID0gdmFsdWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0Ly9cXHJcXG5cXHJcXG5cXHRPYmplY3QuYXNzaWduKCBXZWJHTFJlbmRlcmVyLnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdGdldEN1cnJlbnRSZW5kZXJUYXJnZXQ6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuZ2V0Q3VycmVudFJlbmRlclRhcmdldCgpIGlzIG5vdyAuZ2V0UmVuZGVyVGFyZ2V0KCkuJyApO1xcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmdldFJlbmRlclRhcmdldCgpO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Z2V0TWF4QW5pc290cm9weTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5nZXRNYXhBbmlzb3Ryb3B5KCkgaXMgbm93IC5jYXBhYmlsaXRpZXMuZ2V0TWF4QW5pc290cm9weSgpLicgKTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5jYXBhYmlsaXRpZXMuZ2V0TWF4QW5pc290cm9weSgpO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0Z2V0UHJlY2lzaW9uOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLmdldFByZWNpc2lvbigpIGlzIG5vdyAuY2FwYWJpbGl0aWVzLnByZWNpc2lvbi4nICk7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuY2FwYWJpbGl0aWVzLnByZWNpc2lvbjtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcclxcblxcdFxcdHJlc2V0R0xTdGF0ZTogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5yZXNldEdMU3RhdGUoKSBpcyBub3cgLnN0YXRlLnJlc2V0KCkuJyApO1xcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLnN0YXRlLnJlc2V0KCk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRzdXBwb3J0c0Zsb2F0VGV4dHVyZXM6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNGbG9hdFRleHR1cmVzKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFxcXCdPRVNfdGV4dHVyZV9mbG9hdFxcXFwnICkuJyApO1xcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXQnICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHRzdXBwb3J0c0hhbGZGbG9hdFRleHR1cmVzOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzSGFsZkZsb2F0VGV4dHVyZXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXFxcJ09FU190ZXh0dXJlX2hhbGZfZmxvYXRcXFxcJyApLicgKTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHRzdXBwb3J0c1N0YW5kYXJkRGVyaXZhdGl2ZXM6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNTdGFuZGFyZERlcml2YXRpdmVzKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFxcXCdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXNcXFxcJyApLicgKTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldCggJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcycgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdHN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVTM1RDOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVTM1RDKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFxcXCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1xcXFwnICkuJyApO1xcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHRzdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUFZSVEM6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVBWUlRDKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFxcXCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGNcXFxcJyApLicgKTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdHN1cHBvcnRzQmxlbmRNaW5NYXg6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNCbGVuZE1pbk1heCgpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcXFwnRVhUX2JsZW5kX21pbm1heFxcXFwnICkuJyApO1xcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KCAnRVhUX2JsZW5kX21pbm1heCcgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdHN1cHBvcnRzVmVydGV4VGV4dHVyZXM6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcygpIGlzIG5vdyAuY2FwYWJpbGl0aWVzLnZlcnRleFRleHR1cmVzLicgKTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5jYXBhYmlsaXRpZXMudmVydGV4VGV4dHVyZXM7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHRzdXBwb3J0c0luc3RhbmNlZEFycmF5czogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0luc3RhbmNlZEFycmF5cygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcXFwnQU5HTEVfaW5zdGFuY2VkX2FycmF5c1xcXFwnICkuJyApO1xcclxcblxcdFxcdFxcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdGVuYWJsZVNjaXNzb3JUZXN0OiBmdW5jdGlvbiAoIGJvb2xlYW4gKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLmVuYWJsZVNjaXNzb3JUZXN0KCkgaXMgbm93IC5zZXRTY2lzc29yVGVzdCgpLicgKTtcXHJcXG5cXHRcXHRcXHR0aGlzLnNldFNjaXNzb3JUZXN0KCBib29sZWFuICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHRpbml0TWF0ZXJpYWw6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuaW5pdE1hdGVyaWFsKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHRhZGRQcmVQbHVnaW46IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuYWRkUHJlUGx1Z2luKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHRhZGRQb3N0UGx1Z2luOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLmFkZFBvc3RQbHVnaW4oKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcXHJcXG5cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdHVwZGF0ZVNoYWRvd01hcDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC51cGRhdGVTaGFkb3dNYXAoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBXZWJHTFJlbmRlcmVyLnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdHNoYWRvd01hcEVuYWJsZWQ6IHtcXHJcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5zaGFkb3dNYXAuZW5hYmxlZDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9LFxcclxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwRW5hYmxlZCBpcyBub3cgLnNoYWRvd01hcC5lbmFibGVkLicgKTtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnNoYWRvd01hcC5lbmFibGVkID0gdmFsdWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0c2hhZG93TWFwVHlwZToge1xcclxcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnNoYWRvd01hcC50eXBlO1xcclxcblxcclxcblxcdFxcdFxcdH0sXFxyXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXBUeXBlIGlzIG5vdyAuc2hhZG93TWFwLnR5cGUuJyApO1xcclxcblxcdFxcdFxcdFxcdHRoaXMuc2hhZG93TWFwLnR5cGUgPSB2YWx1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHRzaGFkb3dNYXBDdWxsRmFjZToge1xcclxcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnNoYWRvd01hcC5jdWxsRmFjZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9LFxcclxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwQ3VsbEZhY2UgaXMgbm93IC5zaGFkb3dNYXAuY3VsbEZhY2UuJyApO1xcclxcblxcdFxcdFxcdFxcdHRoaXMuc2hhZG93TWFwLmN1bGxGYWNlID0gdmFsdWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcdFxcdH1cXHJcXG5cXHR9ICk7XFxyXFxuXFxyXFxuXFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFdlYkdMU2hhZG93TWFwLnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdGN1bGxGYWNlOiB7XFxyXFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMucmVuZGVyUmV2ZXJzZVNpZGVkID8gQ3VsbEZhY2VGcm9udCA6IEN1bGxGYWNlQmFjaztcXHJcXG5cXHJcXG5cXHRcXHRcXHR9LFxcclxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCBjdWxsRmFjZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2YXIgdmFsdWUgPSAoIGN1bGxGYWNlICE9PSBDdWxsRmFjZUJhY2sgKTtcXHJcXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oIFxcXCJXZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwLmN1bGxGYWNlIGlzIGRlcHJlY2F0ZWQuIFNldCAuc2hhZG93TWFwLnJlbmRlclJldmVyc2VTaWRlZCB0byBcXFwiICsgdmFsdWUgKyBcXFwiLlxcXCIgKTtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnJlbmRlclJldmVyc2VTaWRlZCA9IHZhbHVlO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8vXFxyXFxuXFxyXFxuXFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFdlYkdMUmVuZGVyVGFyZ2V0LnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdHdyYXBTOiB7XFxyXFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC53cmFwUyBpcyBub3cgLnRleHR1cmUud3JhcFMuJyApO1xcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnRleHR1cmUud3JhcFM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSxcXHJcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC53cmFwUyBpcyBub3cgLnRleHR1cmUud3JhcFMuJyApO1xcclxcblxcdFxcdFxcdFxcdHRoaXMudGV4dHVyZS53cmFwUyA9IHZhbHVlO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdHdyYXBUOiB7XFxyXFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC53cmFwVCBpcyBub3cgLnRleHR1cmUud3JhcFQuJyApO1xcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnRleHR1cmUud3JhcFQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSxcXHJcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC53cmFwVCBpcyBub3cgLnRleHR1cmUud3JhcFQuJyApO1xcclxcblxcdFxcdFxcdFxcdHRoaXMudGV4dHVyZS53cmFwVCA9IHZhbHVlO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdG1hZ0ZpbHRlcjoge1xcclxcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAubWFnRmlsdGVyIGlzIG5vdyAudGV4dHVyZS5tYWdGaWx0ZXIuJyApO1xcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnRleHR1cmUubWFnRmlsdGVyO1xcclxcblxcclxcblxcdFxcdFxcdH0sXFxyXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAubWFnRmlsdGVyIGlzIG5vdyAudGV4dHVyZS5tYWdGaWx0ZXIuJyApO1xcclxcblxcdFxcdFxcdFxcdHRoaXMudGV4dHVyZS5tYWdGaWx0ZXIgPSB2YWx1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHRtaW5GaWx0ZXI6IHtcXHJcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1pbkZpbHRlciBpcyBub3cgLnRleHR1cmUubWluRmlsdGVyLicgKTtcXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy50ZXh0dXJlLm1pbkZpbHRlcjtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9LFxcclxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1pbkZpbHRlciBpcyBub3cgLnRleHR1cmUubWluRmlsdGVyLicgKTtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnRleHR1cmUubWluRmlsdGVyID0gdmFsdWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0YW5pc290cm9weToge1xcclxcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuYW5pc290cm9weSBpcyBub3cgLnRleHR1cmUuYW5pc290cm9weS4nICk7XFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMudGV4dHVyZS5hbmlzb3Ryb3B5O1xcclxcblxcclxcblxcdFxcdFxcdH0sXFxyXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuYW5pc290cm9weSBpcyBub3cgLnRleHR1cmUuYW5pc290cm9weS4nICk7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy50ZXh0dXJlLmFuaXNvdHJvcHkgPSB2YWx1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHRvZmZzZXQ6IHtcXHJcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm9mZnNldCBpcyBub3cgLnRleHR1cmUub2Zmc2V0LicgKTtcXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy50ZXh0dXJlLm9mZnNldDtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9LFxcclxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm9mZnNldCBpcyBub3cgLnRleHR1cmUub2Zmc2V0LicgKTtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnRleHR1cmUub2Zmc2V0ID0gdmFsdWU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0cmVwZWF0OiB7XFxyXFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5yZXBlYXQgaXMgbm93IC50ZXh0dXJlLnJlcGVhdC4nICk7XFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMudGV4dHVyZS5yZXBlYXQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSxcXHJcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5yZXBlYXQgaXMgbm93IC50ZXh0dXJlLnJlcGVhdC4nICk7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy50ZXh0dXJlLnJlcGVhdCA9IHZhbHVlO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdGZvcm1hdDoge1xcclxcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuZm9ybWF0IGlzIG5vdyAudGV4dHVyZS5mb3JtYXQuJyApO1xcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnRleHR1cmUuZm9ybWF0O1xcclxcblxcclxcblxcdFxcdFxcdH0sXFxyXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuZm9ybWF0IGlzIG5vdyAudGV4dHVyZS5mb3JtYXQuJyApO1xcclxcblxcdFxcdFxcdFxcdHRoaXMudGV4dHVyZS5mb3JtYXQgPSB2YWx1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHR0eXBlOiB7XFxyXFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC50eXBlIGlzIG5vdyAudGV4dHVyZS50eXBlLicgKTtcXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy50ZXh0dXJlLnR5cGU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fSxcXHJcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC50eXBlIGlzIG5vdyAudGV4dHVyZS50eXBlLicgKTtcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnRleHR1cmUudHlwZSA9IHZhbHVlO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdGdlbmVyYXRlTWlwbWFwczoge1xcclxcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuZ2VuZXJhdGVNaXBtYXBzIGlzIG5vdyAudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMuJyApO1xcclxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzO1xcclxcblxcclxcblxcdFxcdFxcdH0sXFxyXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuZ2VuZXJhdGVNaXBtYXBzIGlzIG5vdyAudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMuJyApO1xcclxcblxcdFxcdFxcdFxcdHRoaXMudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSB2YWx1ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHQvL1xcclxcblxcclxcblxcdE9iamVjdC5hc3NpZ24oIFdlYlZSTWFuYWdlci5wcm90b3R5cGUsIHtcXHJcXG5cXHJcXG5cXHRcXHRnZXRTdGFuZGluZ01hdHJpeDogZnVuY3Rpb24gKCkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYlZSTWFuYWdlcjogLmdldFN0YW5kaW5nTWF0cml4KCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdH0gKTtcXHJcXG5cXHJcXG5cXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggV2ViVlJNYW5hZ2VyLnByb3RvdHlwZSwge1xcclxcblxcclxcblxcdFxcdHN0YW5kaW5nOiB7XFxyXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIC8qIHZhbHVlICovICkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYlZSTWFuYWdlcjogLnN0YW5kaW5nIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fSApO1xcclxcblxcclxcblxcdC8vXFxyXFxuXFxyXFxuXFx0QXVkaW8ucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoIGZpbGUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IC5sb2FkIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBUSFJFRS5BdWRpb0xvYWRlciBpbnN0ZWFkLicgKTtcXHJcXG5cXHRcXHR2YXIgc2NvcGUgPSB0aGlzO1xcclxcblxcdFxcdHZhciBhdWRpb0xvYWRlciA9IG5ldyBBdWRpb0xvYWRlcigpO1xcclxcblxcdFxcdGF1ZGlvTG9hZGVyLmxvYWQoIGZpbGUsIGZ1bmN0aW9uICggYnVmZmVyICkge1xcclxcblxcclxcblxcdFxcdFxcdHNjb3BlLnNldEJ1ZmZlciggYnVmZmVyICk7XFxyXFxuXFxyXFxuXFx0XFx0fSApO1xcclxcblxcdFxcdHJldHVybiB0aGlzO1xcclxcblxcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0QXVkaW9BbmFseXNlci5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpb0FuYWx5c2VyOiAuZ2V0RGF0YSgpIGlzIG5vdyAuZ2V0RnJlcXVlbmN5RGF0YSgpLicgKTtcXHJcXG5cXHRcXHRyZXR1cm4gdGhpcy5nZXRGcmVxdWVuY3lEYXRhKCk7XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHQvL1xcclxcblxcclxcblxcdEN1YmVDYW1lcmEucHJvdG90eXBlLnVwZGF0ZUN1YmVNYXAgPSBmdW5jdGlvbiAoIHJlbmRlcmVyLCBzY2VuZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5DdWJlQ2FtZXJhOiAudXBkYXRlQ3ViZU1hcCgpIGlzIG5vdyAudXBkYXRlKCkuJyApO1xcclxcblxcdFxcdHJldHVybiB0aGlzLnVwZGF0ZSggcmVuZGVyZXIsIHNjZW5lICk7XFxyXFxuXFxyXFxuXFx0fTtcXHJcXG5cXHJcXG5cXHQvL1xcclxcblxcclxcblxcdHZhciBHZW9tZXRyeVV0aWxzID0ge1xcclxcblxcclxcblxcdFxcdG1lcmdlOiBmdW5jdGlvbiAoIGdlb21ldHJ5MSwgZ2VvbWV0cnkyLCBtYXRlcmlhbEluZGV4T2Zmc2V0ICkge1xcclxcblxcclxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdlb21ldHJ5VXRpbHM6IC5tZXJnZSgpIGhhcyBiZWVuIG1vdmVkIHRvIEdlb21ldHJ5LiBVc2UgZ2VvbWV0cnkubWVyZ2UoIGdlb21ldHJ5MiwgbWF0cml4LCBtYXRlcmlhbEluZGV4T2Zmc2V0ICkgaW5zdGVhZC4nICk7XFxyXFxuXFx0XFx0XFx0dmFyIG1hdHJpeDtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIGdlb21ldHJ5Mi5pc01lc2ggKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0Z2VvbWV0cnkyLm1hdHJpeEF1dG9VcGRhdGUgJiYgZ2VvbWV0cnkyLnVwZGF0ZU1hdHJpeCgpO1xcclxcblxcclxcblxcdFxcdFxcdFxcdG1hdHJpeCA9IGdlb21ldHJ5Mi5tYXRyaXg7XFxyXFxuXFx0XFx0XFx0XFx0Z2VvbWV0cnkyID0gZ2VvbWV0cnkyLmdlb21ldHJ5O1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRnZW9tZXRyeTEubWVyZ2UoIGdlb21ldHJ5MiwgbWF0cml4LCBtYXRlcmlhbEluZGV4T2Zmc2V0ICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRjZW50ZXI6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR2VvbWV0cnlVdGlsczogLmNlbnRlcigpIGhhcyBiZWVuIG1vdmVkIHRvIEdlb21ldHJ5LiBVc2UgZ2VvbWV0cnkuY2VudGVyKCkgaW5zdGVhZC4nICk7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIGdlb21ldHJ5LmNlbnRlcigpO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9O1xcclxcblxcclxcblxcdHZhciBJbWFnZVV0aWxzID0ge1xcclxcblxcclxcblxcdFxcdGNyb3NzT3JpZ2luOiB1bmRlZmluZWQsXFxyXFxuXFxyXFxuXFx0XFx0bG9hZFRleHR1cmU6IGZ1bmN0aW9uICggdXJsLCBtYXBwaW5nLCBvbkxvYWQsIG9uRXJyb3IgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkVGV4dHVyZSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgVEhSRUUuVGV4dHVyZUxvYWRlcigpIGluc3RlYWQuJyApO1xcclxcblxcclxcblxcdFxcdFxcdHZhciBsb2FkZXIgPSBuZXcgVGV4dHVyZUxvYWRlcigpO1xcclxcblxcdFxcdFxcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xcclxcblxcclxcblxcdFxcdFxcdHZhciB0ZXh0dXJlID0gbG9hZGVyLmxvYWQoIHVybCwgb25Mb2FkLCB1bmRlZmluZWQsIG9uRXJyb3IgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIG1hcHBpbmcgKSB0ZXh0dXJlLm1hcHBpbmcgPSBtYXBwaW5nO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0ZXh0dXJlO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0bG9hZFRleHR1cmVDdWJlOiBmdW5jdGlvbiAoIHVybHMsIG1hcHBpbmcsIG9uTG9hZCwgb25FcnJvciApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5JbWFnZVV0aWxzLmxvYWRUZXh0dXJlQ3ViZSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgVEhSRUUuQ3ViZVRleHR1cmVMb2FkZXIoKSBpbnN0ZWFkLicgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgbG9hZGVyID0gbmV3IEN1YmVUZXh0dXJlTG9hZGVyKCk7XFxyXFxuXFx0XFx0XFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIHRleHR1cmUgPSBsb2FkZXIubG9hZCggdXJscywgb25Mb2FkLCB1bmRlZmluZWQsIG9uRXJyb3IgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIG1hcHBpbmcgKSB0ZXh0dXJlLm1hcHBpbmcgPSBtYXBwaW5nO1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0ZXh0dXJlO1xcclxcblxcclxcblxcdFxcdH0sXFxyXFxuXFxyXFxuXFx0XFx0bG9hZENvbXByZXNzZWRUZXh0dXJlOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkltYWdlVXRpbHMubG9hZENvbXByZXNzZWRUZXh0dXJlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5ERFNMb2FkZXIgaW5zdGVhZC4nICk7XFxyXFxuXFxyXFxuXFx0XFx0fSxcXHJcXG5cXHJcXG5cXHRcXHRsb2FkQ29tcHJlc3NlZFRleHR1cmVDdWJlOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkltYWdlVXRpbHMubG9hZENvbXByZXNzZWRUZXh0dXJlQ3ViZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuRERTTG9hZGVyIGluc3RlYWQuJyApO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9O1xcclxcblxcclxcblxcdC8vXFxyXFxuXFxyXFxuXFx0ZnVuY3Rpb24gUHJvamVjdG9yKCkge1xcclxcblxcclxcblxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9qZWN0b3IgaGFzIGJlZW4gbW92ZWQgdG8gL2V4YW1wbGVzL2pzL3JlbmRlcmVycy9Qcm9qZWN0b3IuanMuJyApO1xcclxcblxcclxcblxcdFxcdHRoaXMucHJvamVjdFZlY3RvciA9IGZ1bmN0aW9uICggdmVjdG9yLCBjYW1lcmEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUHJvamVjdG9yOiAucHJvamVjdFZlY3RvcigpIGlzIG5vdyB2ZWN0b3IucHJvamVjdCgpLicgKTtcXHJcXG5cXHRcXHRcXHR2ZWN0b3IucHJvamVjdCggY2FtZXJhICk7XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnVucHJvamVjdFZlY3RvciA9IGZ1bmN0aW9uICggdmVjdG9yLCBjYW1lcmEgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUHJvamVjdG9yOiAudW5wcm9qZWN0VmVjdG9yKCkgaXMgbm93IHZlY3Rvci51bnByb2plY3QoKS4nICk7XFxyXFxuXFx0XFx0XFx0dmVjdG9yLnVucHJvamVjdCggY2FtZXJhICk7XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLnBpY2tpbmdSYXkgPSBmdW5jdGlvbiAoKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb2plY3RvcjogLnBpY2tpbmdSYXkoKSBpcyBub3cgcmF5Y2FzdGVyLnNldEZyb21DYW1lcmEoKS4nICk7XFxyXFxuXFxyXFxuXFx0XFx0fTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0Ly9cXHJcXG5cXHJcXG5cXHRmdW5jdGlvbiBDYW52YXNSZW5kZXJlcigpIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQ2FudmFzUmVuZGVyZXIgaGFzIGJlZW4gbW92ZWQgdG8gL2V4YW1wbGVzL2pzL3JlbmRlcmVycy9DYW52YXNSZW5kZXJlci5qcycgKTtcXHJcXG5cXHJcXG5cXHRcXHR0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJywgJ2NhbnZhcycgKTtcXHJcXG5cXHRcXHR0aGlzLmNsZWFyID0gZnVuY3Rpb24gKCkge307XFxyXFxuXFx0XFx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7fTtcXHJcXG5cXHRcXHR0aGlzLnNldENsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7fTtcXHJcXG5cXHRcXHR0aGlzLnNldFNpemUgPSBmdW5jdGlvbiAoKSB7fTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0ZXhwb3J0cy5XZWJHTFJlbmRlclRhcmdldEN1YmUgPSBXZWJHTFJlbmRlclRhcmdldEN1YmU7XFxyXFxuXFx0ZXhwb3J0cy5XZWJHTFJlbmRlclRhcmdldCA9IFdlYkdMUmVuZGVyVGFyZ2V0O1xcclxcblxcdGV4cG9ydHMuV2ViR0xSZW5kZXJlciA9IFdlYkdMUmVuZGVyZXI7XFxyXFxuXFx0ZXhwb3J0cy5TaGFkZXJMaWIgPSBTaGFkZXJMaWI7XFxyXFxuXFx0ZXhwb3J0cy5Vbmlmb3Jtc0xpYiA9IFVuaWZvcm1zTGliO1xcclxcblxcdGV4cG9ydHMuVW5pZm9ybXNVdGlscyA9IFVuaWZvcm1zVXRpbHM7XFxyXFxuXFx0ZXhwb3J0cy5TaGFkZXJDaHVuayA9IFNoYWRlckNodW5rO1xcclxcblxcdGV4cG9ydHMuRm9nRXhwMiA9IEZvZ0V4cDI7XFxyXFxuXFx0ZXhwb3J0cy5Gb2cgPSBGb2c7XFxyXFxuXFx0ZXhwb3J0cy5TY2VuZSA9IFNjZW5lO1xcclxcblxcdGV4cG9ydHMuTGVuc0ZsYXJlID0gTGVuc0ZsYXJlO1xcclxcblxcdGV4cG9ydHMuU3ByaXRlID0gU3ByaXRlO1xcclxcblxcdGV4cG9ydHMuTE9EID0gTE9EO1xcclxcblxcdGV4cG9ydHMuU2tpbm5lZE1lc2ggPSBTa2lubmVkTWVzaDtcXHJcXG5cXHRleHBvcnRzLlNrZWxldG9uID0gU2tlbGV0b247XFxyXFxuXFx0ZXhwb3J0cy5Cb25lID0gQm9uZTtcXHJcXG5cXHRleHBvcnRzLk1lc2ggPSBNZXNoO1xcclxcblxcdGV4cG9ydHMuTGluZVNlZ21lbnRzID0gTGluZVNlZ21lbnRzO1xcclxcblxcdGV4cG9ydHMuTGluZUxvb3AgPSBMaW5lTG9vcDtcXHJcXG5cXHRleHBvcnRzLkxpbmUgPSBMaW5lO1xcclxcblxcdGV4cG9ydHMuUG9pbnRzID0gUG9pbnRzO1xcclxcblxcdGV4cG9ydHMuR3JvdXAgPSBHcm91cDtcXHJcXG5cXHRleHBvcnRzLlZpZGVvVGV4dHVyZSA9IFZpZGVvVGV4dHVyZTtcXHJcXG5cXHRleHBvcnRzLkRhdGFUZXh0dXJlID0gRGF0YVRleHR1cmU7XFxyXFxuXFx0ZXhwb3J0cy5Db21wcmVzc2VkVGV4dHVyZSA9IENvbXByZXNzZWRUZXh0dXJlO1xcclxcblxcdGV4cG9ydHMuQ3ViZVRleHR1cmUgPSBDdWJlVGV4dHVyZTtcXHJcXG5cXHRleHBvcnRzLkNhbnZhc1RleHR1cmUgPSBDYW52YXNUZXh0dXJlO1xcclxcblxcdGV4cG9ydHMuRGVwdGhUZXh0dXJlID0gRGVwdGhUZXh0dXJlO1xcclxcblxcdGV4cG9ydHMuVGV4dHVyZSA9IFRleHR1cmU7XFxyXFxuXFx0ZXhwb3J0cy5Db21wcmVzc2VkVGV4dHVyZUxvYWRlciA9IENvbXByZXNzZWRUZXh0dXJlTG9hZGVyO1xcclxcblxcdGV4cG9ydHMuRGF0YVRleHR1cmVMb2FkZXIgPSBEYXRhVGV4dHVyZUxvYWRlcjtcXHJcXG5cXHRleHBvcnRzLkN1YmVUZXh0dXJlTG9hZGVyID0gQ3ViZVRleHR1cmVMb2FkZXI7XFxyXFxuXFx0ZXhwb3J0cy5UZXh0dXJlTG9hZGVyID0gVGV4dHVyZUxvYWRlcjtcXHJcXG5cXHRleHBvcnRzLk9iamVjdExvYWRlciA9IE9iamVjdExvYWRlcjtcXHJcXG5cXHRleHBvcnRzLk1hdGVyaWFsTG9hZGVyID0gTWF0ZXJpYWxMb2FkZXI7XFxyXFxuXFx0ZXhwb3J0cy5CdWZmZXJHZW9tZXRyeUxvYWRlciA9IEJ1ZmZlckdlb21ldHJ5TG9hZGVyO1xcclxcblxcdGV4cG9ydHMuRGVmYXVsdExvYWRpbmdNYW5hZ2VyID0gRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xcclxcblxcdGV4cG9ydHMuTG9hZGluZ01hbmFnZXIgPSBMb2FkaW5nTWFuYWdlcjtcXHJcXG5cXHRleHBvcnRzLkpTT05Mb2FkZXIgPSBKU09OTG9hZGVyO1xcclxcblxcdGV4cG9ydHMuSW1hZ2VMb2FkZXIgPSBJbWFnZUxvYWRlcjtcXHJcXG5cXHRleHBvcnRzLkltYWdlQml0bWFwTG9hZGVyID0gSW1hZ2VCaXRtYXBMb2FkZXI7XFxyXFxuXFx0ZXhwb3J0cy5Gb250TG9hZGVyID0gRm9udExvYWRlcjtcXHJcXG5cXHRleHBvcnRzLkZpbGVMb2FkZXIgPSBGaWxlTG9hZGVyO1xcclxcblxcdGV4cG9ydHMuTG9hZGVyID0gTG9hZGVyO1xcclxcblxcdGV4cG9ydHMuTG9hZGVyVXRpbHMgPSBMb2FkZXJVdGlscztcXHJcXG5cXHRleHBvcnRzLkNhY2hlID0gQ2FjaGU7XFxyXFxuXFx0ZXhwb3J0cy5BdWRpb0xvYWRlciA9IEF1ZGlvTG9hZGVyO1xcclxcblxcdGV4cG9ydHMuU3BvdExpZ2h0U2hhZG93ID0gU3BvdExpZ2h0U2hhZG93O1xcclxcblxcdGV4cG9ydHMuU3BvdExpZ2h0ID0gU3BvdExpZ2h0O1xcclxcblxcdGV4cG9ydHMuUG9pbnRMaWdodCA9IFBvaW50TGlnaHQ7XFxyXFxuXFx0ZXhwb3J0cy5SZWN0QXJlYUxpZ2h0ID0gUmVjdEFyZWFMaWdodDtcXHJcXG5cXHRleHBvcnRzLkhlbWlzcGhlcmVMaWdodCA9IEhlbWlzcGhlcmVMaWdodDtcXHJcXG5cXHRleHBvcnRzLkRpcmVjdGlvbmFsTGlnaHRTaGFkb3cgPSBEaXJlY3Rpb25hbExpZ2h0U2hhZG93O1xcclxcblxcdGV4cG9ydHMuRGlyZWN0aW9uYWxMaWdodCA9IERpcmVjdGlvbmFsTGlnaHQ7XFxyXFxuXFx0ZXhwb3J0cy5BbWJpZW50TGlnaHQgPSBBbWJpZW50TGlnaHQ7XFxyXFxuXFx0ZXhwb3J0cy5MaWdodFNoYWRvdyA9IExpZ2h0U2hhZG93O1xcclxcblxcdGV4cG9ydHMuTGlnaHQgPSBMaWdodDtcXHJcXG5cXHRleHBvcnRzLlN0ZXJlb0NhbWVyYSA9IFN0ZXJlb0NhbWVyYTtcXHJcXG5cXHRleHBvcnRzLlBlcnNwZWN0aXZlQ2FtZXJhID0gUGVyc3BlY3RpdmVDYW1lcmE7XFxyXFxuXFx0ZXhwb3J0cy5PcnRob2dyYXBoaWNDYW1lcmEgPSBPcnRob2dyYXBoaWNDYW1lcmE7XFxyXFxuXFx0ZXhwb3J0cy5DdWJlQ2FtZXJhID0gQ3ViZUNhbWVyYTtcXHJcXG5cXHRleHBvcnRzLkFycmF5Q2FtZXJhID0gQXJyYXlDYW1lcmE7XFxyXFxuXFx0ZXhwb3J0cy5DYW1lcmEgPSBDYW1lcmE7XFxyXFxuXFx0ZXhwb3J0cy5BdWRpb0xpc3RlbmVyID0gQXVkaW9MaXN0ZW5lcjtcXHJcXG5cXHRleHBvcnRzLlBvc2l0aW9uYWxBdWRpbyA9IFBvc2l0aW9uYWxBdWRpbztcXHJcXG5cXHRleHBvcnRzLkF1ZGlvQ29udGV4dCA9IEF1ZGlvQ29udGV4dDtcXHJcXG5cXHRleHBvcnRzLkF1ZGlvQW5hbHlzZXIgPSBBdWRpb0FuYWx5c2VyO1xcclxcblxcdGV4cG9ydHMuQXVkaW8gPSBBdWRpbztcXHJcXG5cXHRleHBvcnRzLlZlY3RvcktleWZyYW1lVHJhY2sgPSBWZWN0b3JLZXlmcmFtZVRyYWNrO1xcclxcblxcdGV4cG9ydHMuU3RyaW5nS2V5ZnJhbWVUcmFjayA9IFN0cmluZ0tleWZyYW1lVHJhY2s7XFxyXFxuXFx0ZXhwb3J0cy5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayA9IFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrO1xcclxcblxcdGV4cG9ydHMuTnVtYmVyS2V5ZnJhbWVUcmFjayA9IE51bWJlcktleWZyYW1lVHJhY2s7XFxyXFxuXFx0ZXhwb3J0cy5Db2xvcktleWZyYW1lVHJhY2sgPSBDb2xvcktleWZyYW1lVHJhY2s7XFxyXFxuXFx0ZXhwb3J0cy5Cb29sZWFuS2V5ZnJhbWVUcmFjayA9IEJvb2xlYW5LZXlmcmFtZVRyYWNrO1xcclxcblxcdGV4cG9ydHMuUHJvcGVydHlNaXhlciA9IFByb3BlcnR5TWl4ZXI7XFxyXFxuXFx0ZXhwb3J0cy5Qcm9wZXJ0eUJpbmRpbmcgPSBQcm9wZXJ0eUJpbmRpbmc7XFxyXFxuXFx0ZXhwb3J0cy5LZXlmcmFtZVRyYWNrID0gS2V5ZnJhbWVUcmFjaztcXHJcXG5cXHRleHBvcnRzLkFuaW1hdGlvblV0aWxzID0gQW5pbWF0aW9uVXRpbHM7XFxyXFxuXFx0ZXhwb3J0cy5BbmltYXRpb25PYmplY3RHcm91cCA9IEFuaW1hdGlvbk9iamVjdEdyb3VwO1xcclxcblxcdGV4cG9ydHMuQW5pbWF0aW9uTWl4ZXIgPSBBbmltYXRpb25NaXhlcjtcXHJcXG5cXHRleHBvcnRzLkFuaW1hdGlvbkNsaXAgPSBBbmltYXRpb25DbGlwO1xcclxcblxcdGV4cG9ydHMuVW5pZm9ybSA9IFVuaWZvcm07XFxyXFxuXFx0ZXhwb3J0cy5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSA9IEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5O1xcclxcblxcdGV4cG9ydHMuQnVmZmVyR2VvbWV0cnkgPSBCdWZmZXJHZW9tZXRyeTtcXHJcXG5cXHRleHBvcnRzLkdlb21ldHJ5ID0gR2VvbWV0cnk7XFxyXFxuXFx0ZXhwb3J0cy5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA9IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlO1xcclxcblxcdGV4cG9ydHMuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgPSBJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlcjtcXHJcXG5cXHRleHBvcnRzLkludGVybGVhdmVkQnVmZmVyID0gSW50ZXJsZWF2ZWRCdWZmZXI7XFxyXFxuXFx0ZXhwb3J0cy5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgPSBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGU7XFxyXFxuXFx0ZXhwb3J0cy5GYWNlMyA9IEZhY2UzO1xcclxcblxcdGV4cG9ydHMuT2JqZWN0M0QgPSBPYmplY3QzRDtcXHJcXG5cXHRleHBvcnRzLlJheWNhc3RlciA9IFJheWNhc3RlcjtcXHJcXG5cXHRleHBvcnRzLkxheWVycyA9IExheWVycztcXHJcXG5cXHRleHBvcnRzLkV2ZW50RGlzcGF0Y2hlciA9IEV2ZW50RGlzcGF0Y2hlcjtcXHJcXG5cXHRleHBvcnRzLkNsb2NrID0gQ2xvY2s7XFxyXFxuXFx0ZXhwb3J0cy5RdWF0ZXJuaW9uTGluZWFySW50ZXJwb2xhbnQgPSBRdWF0ZXJuaW9uTGluZWFySW50ZXJwb2xhbnQ7XFxyXFxuXFx0ZXhwb3J0cy5MaW5lYXJJbnRlcnBvbGFudCA9IExpbmVhckludGVycG9sYW50O1xcclxcblxcdGV4cG9ydHMuRGlzY3JldGVJbnRlcnBvbGFudCA9IERpc2NyZXRlSW50ZXJwb2xhbnQ7XFxyXFxuXFx0ZXhwb3J0cy5DdWJpY0ludGVycG9sYW50ID0gQ3ViaWNJbnRlcnBvbGFudDtcXHJcXG5cXHRleHBvcnRzLkludGVycG9sYW50ID0gSW50ZXJwb2xhbnQ7XFxyXFxuXFx0ZXhwb3J0cy5UcmlhbmdsZSA9IFRyaWFuZ2xlO1xcclxcblxcdGV4cG9ydHMuTWF0aCA9IF9NYXRoO1xcclxcblxcdGV4cG9ydHMuU3BoZXJpY2FsID0gU3BoZXJpY2FsO1xcclxcblxcdGV4cG9ydHMuQ3lsaW5kcmljYWwgPSBDeWxpbmRyaWNhbDtcXHJcXG5cXHRleHBvcnRzLlBsYW5lID0gUGxhbmU7XFxyXFxuXFx0ZXhwb3J0cy5GcnVzdHVtID0gRnJ1c3R1bTtcXHJcXG5cXHRleHBvcnRzLlNwaGVyZSA9IFNwaGVyZTtcXHJcXG5cXHRleHBvcnRzLlJheSA9IFJheTtcXHJcXG5cXHRleHBvcnRzLk1hdHJpeDQgPSBNYXRyaXg0O1xcclxcblxcdGV4cG9ydHMuTWF0cml4MyA9IE1hdHJpeDM7XFxyXFxuXFx0ZXhwb3J0cy5Cb3gzID0gQm94MztcXHJcXG5cXHRleHBvcnRzLkJveDIgPSBCb3gyO1xcclxcblxcdGV4cG9ydHMuTGluZTMgPSBMaW5lMztcXHJcXG5cXHRleHBvcnRzLkV1bGVyID0gRXVsZXI7XFxyXFxuXFx0ZXhwb3J0cy5WZWN0b3I0ID0gVmVjdG9yNDtcXHJcXG5cXHRleHBvcnRzLlZlY3RvcjMgPSBWZWN0b3IzO1xcclxcblxcdGV4cG9ydHMuVmVjdG9yMiA9IFZlY3RvcjI7XFxyXFxuXFx0ZXhwb3J0cy5RdWF0ZXJuaW9uID0gUXVhdGVybmlvbjtcXHJcXG5cXHRleHBvcnRzLkNvbG9yID0gQ29sb3I7XFxyXFxuXFx0ZXhwb3J0cy5JbW1lZGlhdGVSZW5kZXJPYmplY3QgPSBJbW1lZGlhdGVSZW5kZXJPYmplY3Q7XFxyXFxuXFx0ZXhwb3J0cy5WZXJ0ZXhOb3JtYWxzSGVscGVyID0gVmVydGV4Tm9ybWFsc0hlbHBlcjtcXHJcXG5cXHRleHBvcnRzLlNwb3RMaWdodEhlbHBlciA9IFNwb3RMaWdodEhlbHBlcjtcXHJcXG5cXHRleHBvcnRzLlNrZWxldG9uSGVscGVyID0gU2tlbGV0b25IZWxwZXI7XFxyXFxuXFx0ZXhwb3J0cy5Qb2ludExpZ2h0SGVscGVyID0gUG9pbnRMaWdodEhlbHBlcjtcXHJcXG5cXHRleHBvcnRzLlJlY3RBcmVhTGlnaHRIZWxwZXIgPSBSZWN0QXJlYUxpZ2h0SGVscGVyO1xcclxcblxcdGV4cG9ydHMuSGVtaXNwaGVyZUxpZ2h0SGVscGVyID0gSGVtaXNwaGVyZUxpZ2h0SGVscGVyO1xcclxcblxcdGV4cG9ydHMuR3JpZEhlbHBlciA9IEdyaWRIZWxwZXI7XFxyXFxuXFx0ZXhwb3J0cy5Qb2xhckdyaWRIZWxwZXIgPSBQb2xhckdyaWRIZWxwZXI7XFxyXFxuXFx0ZXhwb3J0cy5GYWNlTm9ybWFsc0hlbHBlciA9IEZhY2VOb3JtYWxzSGVscGVyO1xcclxcblxcdGV4cG9ydHMuRGlyZWN0aW9uYWxMaWdodEhlbHBlciA9IERpcmVjdGlvbmFsTGlnaHRIZWxwZXI7XFxyXFxuXFx0ZXhwb3J0cy5DYW1lcmFIZWxwZXIgPSBDYW1lcmFIZWxwZXI7XFxyXFxuXFx0ZXhwb3J0cy5Cb3hIZWxwZXIgPSBCb3hIZWxwZXI7XFxyXFxuXFx0ZXhwb3J0cy5Cb3gzSGVscGVyID0gQm94M0hlbHBlcjtcXHJcXG5cXHRleHBvcnRzLlBsYW5lSGVscGVyID0gUGxhbmVIZWxwZXI7XFxyXFxuXFx0ZXhwb3J0cy5BcnJvd0hlbHBlciA9IEFycm93SGVscGVyO1xcclxcblxcdGV4cG9ydHMuQXhlc0hlbHBlciA9IEF4ZXNIZWxwZXI7XFxyXFxuXFx0ZXhwb3J0cy5TaGFwZSA9IFNoYXBlO1xcclxcblxcdGV4cG9ydHMuUGF0aCA9IFBhdGg7XFxyXFxuXFx0ZXhwb3J0cy5TaGFwZVBhdGggPSBTaGFwZVBhdGg7XFxyXFxuXFx0ZXhwb3J0cy5Gb250ID0gRm9udDtcXHJcXG5cXHRleHBvcnRzLkN1cnZlUGF0aCA9IEN1cnZlUGF0aDtcXHJcXG5cXHRleHBvcnRzLkN1cnZlID0gQ3VydmU7XFxyXFxuXFx0ZXhwb3J0cy5TaGFwZVV0aWxzID0gU2hhcGVVdGlscztcXHJcXG5cXHRleHBvcnRzLlNjZW5lVXRpbHMgPSBTY2VuZVV0aWxzO1xcclxcblxcdGV4cG9ydHMuV2ViR0xVdGlscyA9IFdlYkdMVXRpbHM7XFxyXFxuXFx0ZXhwb3J0cy5XaXJlZnJhbWVHZW9tZXRyeSA9IFdpcmVmcmFtZUdlb21ldHJ5O1xcclxcblxcdGV4cG9ydHMuUGFyYW1ldHJpY0dlb21ldHJ5ID0gUGFyYW1ldHJpY0dlb21ldHJ5O1xcclxcblxcdGV4cG9ydHMuUGFyYW1ldHJpY0J1ZmZlckdlb21ldHJ5ID0gUGFyYW1ldHJpY0J1ZmZlckdlb21ldHJ5O1xcclxcblxcdGV4cG9ydHMuVGV0cmFoZWRyb25HZW9tZXRyeSA9IFRldHJhaGVkcm9uR2VvbWV0cnk7XFxyXFxuXFx0ZXhwb3J0cy5UZXRyYWhlZHJvbkJ1ZmZlckdlb21ldHJ5ID0gVGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeTtcXHJcXG5cXHRleHBvcnRzLk9jdGFoZWRyb25HZW9tZXRyeSA9IE9jdGFoZWRyb25HZW9tZXRyeTtcXHJcXG5cXHRleHBvcnRzLk9jdGFoZWRyb25CdWZmZXJHZW9tZXRyeSA9IE9jdGFoZWRyb25CdWZmZXJHZW9tZXRyeTtcXHJcXG5cXHRleHBvcnRzLkljb3NhaGVkcm9uR2VvbWV0cnkgPSBJY29zYWhlZHJvbkdlb21ldHJ5O1xcclxcblxcdGV4cG9ydHMuSWNvc2FoZWRyb25CdWZmZXJHZW9tZXRyeSA9IEljb3NhaGVkcm9uQnVmZmVyR2VvbWV0cnk7XFxyXFxuXFx0ZXhwb3J0cy5Eb2RlY2FoZWRyb25HZW9tZXRyeSA9IERvZGVjYWhlZHJvbkdlb21ldHJ5O1xcclxcblxcdGV4cG9ydHMuRG9kZWNhaGVkcm9uQnVmZmVyR2VvbWV0cnkgPSBEb2RlY2FoZWRyb25CdWZmZXJHZW9tZXRyeTtcXHJcXG5cXHRleHBvcnRzLlBvbHloZWRyb25HZW9tZXRyeSA9IFBvbHloZWRyb25HZW9tZXRyeTtcXHJcXG5cXHRleHBvcnRzLlBvbHloZWRyb25CdWZmZXJHZW9tZXRyeSA9IFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeTtcXHJcXG5cXHRleHBvcnRzLlR1YmVHZW9tZXRyeSA9IFR1YmVHZW9tZXRyeTtcXHJcXG5cXHRleHBvcnRzLlR1YmVCdWZmZXJHZW9tZXRyeSA9IFR1YmVCdWZmZXJHZW9tZXRyeTtcXHJcXG5cXHRleHBvcnRzLlRvcnVzS25vdEdlb21ldHJ5ID0gVG9ydXNLbm90R2VvbWV0cnk7XFxyXFxuXFx0ZXhwb3J0cy5Ub3J1c0tub3RCdWZmZXJHZW9tZXRyeSA9IFRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5O1xcclxcblxcdGV4cG9ydHMuVG9ydXNHZW9tZXRyeSA9IFRvcnVzR2VvbWV0cnk7XFxyXFxuXFx0ZXhwb3J0cy5Ub3J1c0J1ZmZlckdlb21ldHJ5ID0gVG9ydXNCdWZmZXJHZW9tZXRyeTtcXHJcXG5cXHRleHBvcnRzLlRleHRHZW9tZXRyeSA9IFRleHRHZW9tZXRyeTtcXHJcXG5cXHRleHBvcnRzLlRleHRCdWZmZXJHZW9tZXRyeSA9IFRleHRCdWZmZXJHZW9tZXRyeTtcXHJcXG5cXHRleHBvcnRzLlNwaGVyZUdlb21ldHJ5ID0gU3BoZXJlR2VvbWV0cnk7XFxyXFxuXFx0ZXhwb3J0cy5TcGhlcmVCdWZmZXJHZW9tZXRyeSA9IFNwaGVyZUJ1ZmZlckdlb21ldHJ5O1xcclxcblxcdGV4cG9ydHMuUmluZ0dlb21ldHJ5ID0gUmluZ0dlb21ldHJ5O1xcclxcblxcdGV4cG9ydHMuUmluZ0J1ZmZlckdlb21ldHJ5ID0gUmluZ0J1ZmZlckdlb21ldHJ5O1xcclxcblxcdGV4cG9ydHMuUGxhbmVHZW9tZXRyeSA9IFBsYW5lR2VvbWV0cnk7XFxyXFxuXFx0ZXhwb3J0cy5QbGFuZUJ1ZmZlckdlb21ldHJ5ID0gUGxhbmVCdWZmZXJHZW9tZXRyeTtcXHJcXG5cXHRleHBvcnRzLkxhdGhlR2VvbWV0cnkgPSBMYXRoZUdlb21ldHJ5O1xcclxcblxcdGV4cG9ydHMuTGF0aGVCdWZmZXJHZW9tZXRyeSA9IExhdGhlQnVmZmVyR2VvbWV0cnk7XFxyXFxuXFx0ZXhwb3J0cy5TaGFwZUdlb21ldHJ5ID0gU2hhcGVHZW9tZXRyeTtcXHJcXG5cXHRleHBvcnRzLlNoYXBlQnVmZmVyR2VvbWV0cnkgPSBTaGFwZUJ1ZmZlckdlb21ldHJ5O1xcclxcblxcdGV4cG9ydHMuRXh0cnVkZUdlb21ldHJ5ID0gRXh0cnVkZUdlb21ldHJ5O1xcclxcblxcdGV4cG9ydHMuRXh0cnVkZUJ1ZmZlckdlb21ldHJ5ID0gRXh0cnVkZUJ1ZmZlckdlb21ldHJ5O1xcclxcblxcdGV4cG9ydHMuRWRnZXNHZW9tZXRyeSA9IEVkZ2VzR2VvbWV0cnk7XFxyXFxuXFx0ZXhwb3J0cy5Db25lR2VvbWV0cnkgPSBDb25lR2VvbWV0cnk7XFxyXFxuXFx0ZXhwb3J0cy5Db25lQnVmZmVyR2VvbWV0cnkgPSBDb25lQnVmZmVyR2VvbWV0cnk7XFxyXFxuXFx0ZXhwb3J0cy5DeWxpbmRlckdlb21ldHJ5ID0gQ3lsaW5kZXJHZW9tZXRyeTtcXHJcXG5cXHRleHBvcnRzLkN5bGluZGVyQnVmZmVyR2VvbWV0cnkgPSBDeWxpbmRlckJ1ZmZlckdlb21ldHJ5O1xcclxcblxcdGV4cG9ydHMuQ2lyY2xlR2VvbWV0cnkgPSBDaXJjbGVHZW9tZXRyeTtcXHJcXG5cXHRleHBvcnRzLkNpcmNsZUJ1ZmZlckdlb21ldHJ5ID0gQ2lyY2xlQnVmZmVyR2VvbWV0cnk7XFxyXFxuXFx0ZXhwb3J0cy5Cb3hHZW9tZXRyeSA9IEJveEdlb21ldHJ5O1xcclxcblxcdGV4cG9ydHMuQm94QnVmZmVyR2VvbWV0cnkgPSBCb3hCdWZmZXJHZW9tZXRyeTtcXHJcXG5cXHRleHBvcnRzLlNoYWRvd01hdGVyaWFsID0gU2hhZG93TWF0ZXJpYWw7XFxyXFxuXFx0ZXhwb3J0cy5TcHJpdGVNYXRlcmlhbCA9IFNwcml0ZU1hdGVyaWFsO1xcclxcblxcdGV4cG9ydHMuUmF3U2hhZGVyTWF0ZXJpYWwgPSBSYXdTaGFkZXJNYXRlcmlhbDtcXHJcXG5cXHRleHBvcnRzLlNoYWRlck1hdGVyaWFsID0gU2hhZGVyTWF0ZXJpYWw7XFxyXFxuXFx0ZXhwb3J0cy5Qb2ludHNNYXRlcmlhbCA9IFBvaW50c01hdGVyaWFsO1xcclxcblxcdGV4cG9ydHMuTWVzaFBoeXNpY2FsTWF0ZXJpYWwgPSBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcXHJcXG5cXHRleHBvcnRzLk1lc2hTdGFuZGFyZE1hdGVyaWFsID0gTWVzaFN0YW5kYXJkTWF0ZXJpYWw7XFxyXFxuXFx0ZXhwb3J0cy5NZXNoUGhvbmdNYXRlcmlhbCA9IE1lc2hQaG9uZ01hdGVyaWFsO1xcclxcblxcdGV4cG9ydHMuTWVzaFRvb25NYXRlcmlhbCA9IE1lc2hUb29uTWF0ZXJpYWw7XFxyXFxuXFx0ZXhwb3J0cy5NZXNoTm9ybWFsTWF0ZXJpYWwgPSBNZXNoTm9ybWFsTWF0ZXJpYWw7XFxyXFxuXFx0ZXhwb3J0cy5NZXNoTGFtYmVydE1hdGVyaWFsID0gTWVzaExhbWJlcnRNYXRlcmlhbDtcXHJcXG5cXHRleHBvcnRzLk1lc2hEZXB0aE1hdGVyaWFsID0gTWVzaERlcHRoTWF0ZXJpYWw7XFxyXFxuXFx0ZXhwb3J0cy5NZXNoRGlzdGFuY2VNYXRlcmlhbCA9IE1lc2hEaXN0YW5jZU1hdGVyaWFsO1xcclxcblxcdGV4cG9ydHMuTWVzaEJhc2ljTWF0ZXJpYWwgPSBNZXNoQmFzaWNNYXRlcmlhbDtcXHJcXG5cXHRleHBvcnRzLkxpbmVEYXNoZWRNYXRlcmlhbCA9IExpbmVEYXNoZWRNYXRlcmlhbDtcXHJcXG5cXHRleHBvcnRzLkxpbmVCYXNpY01hdGVyaWFsID0gTGluZUJhc2ljTWF0ZXJpYWw7XFxyXFxuXFx0ZXhwb3J0cy5NYXRlcmlhbCA9IE1hdGVyaWFsO1xcclxcblxcdGV4cG9ydHMuRmxvYXQ2NEJ1ZmZlckF0dHJpYnV0ZSA9IEZsb2F0NjRCdWZmZXJBdHRyaWJ1dGU7XFxyXFxuXFx0ZXhwb3J0cy5GbG9hdDMyQnVmZmVyQXR0cmlidXRlID0gRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZTtcXHJcXG5cXHRleHBvcnRzLlVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSA9IFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZTtcXHJcXG5cXHRleHBvcnRzLkludDMyQnVmZmVyQXR0cmlidXRlID0gSW50MzJCdWZmZXJBdHRyaWJ1dGU7XFxyXFxuXFx0ZXhwb3J0cy5VaW50MTZCdWZmZXJBdHRyaWJ1dGUgPSBVaW50MTZCdWZmZXJBdHRyaWJ1dGU7XFxyXFxuXFx0ZXhwb3J0cy5JbnQxNkJ1ZmZlckF0dHJpYnV0ZSA9IEludDE2QnVmZmVyQXR0cmlidXRlO1xcclxcblxcdGV4cG9ydHMuVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlID0gVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlO1xcclxcblxcdGV4cG9ydHMuVWludDhCdWZmZXJBdHRyaWJ1dGUgPSBVaW50OEJ1ZmZlckF0dHJpYnV0ZTtcXHJcXG5cXHRleHBvcnRzLkludDhCdWZmZXJBdHRyaWJ1dGUgPSBJbnQ4QnVmZmVyQXR0cmlidXRlO1xcclxcblxcdGV4cG9ydHMuQnVmZmVyQXR0cmlidXRlID0gQnVmZmVyQXR0cmlidXRlO1xcclxcblxcdGV4cG9ydHMuQXJjQ3VydmUgPSBBcmNDdXJ2ZTtcXHJcXG5cXHRleHBvcnRzLkNhdG11bGxSb21DdXJ2ZTMgPSBDYXRtdWxsUm9tQ3VydmUzO1xcclxcblxcdGV4cG9ydHMuQ3ViaWNCZXppZXJDdXJ2ZSA9IEN1YmljQmV6aWVyQ3VydmU7XFxyXFxuXFx0ZXhwb3J0cy5DdWJpY0JlemllckN1cnZlMyA9IEN1YmljQmV6aWVyQ3VydmUzO1xcclxcblxcdGV4cG9ydHMuRWxsaXBzZUN1cnZlID0gRWxsaXBzZUN1cnZlO1xcclxcblxcdGV4cG9ydHMuTGluZUN1cnZlID0gTGluZUN1cnZlO1xcclxcblxcdGV4cG9ydHMuTGluZUN1cnZlMyA9IExpbmVDdXJ2ZTM7XFxyXFxuXFx0ZXhwb3J0cy5RdWFkcmF0aWNCZXppZXJDdXJ2ZSA9IFF1YWRyYXRpY0JlemllckN1cnZlO1xcclxcblxcdGV4cG9ydHMuUXVhZHJhdGljQmV6aWVyQ3VydmUzID0gUXVhZHJhdGljQmV6aWVyQ3VydmUzO1xcclxcblxcdGV4cG9ydHMuU3BsaW5lQ3VydmUgPSBTcGxpbmVDdXJ2ZTtcXHJcXG5cXHRleHBvcnRzLlJFVklTSU9OID0gUkVWSVNJT047XFxyXFxuXFx0ZXhwb3J0cy5NT1VTRSA9IE1PVVNFO1xcclxcblxcdGV4cG9ydHMuQ3VsbEZhY2VOb25lID0gQ3VsbEZhY2VOb25lO1xcclxcblxcdGV4cG9ydHMuQ3VsbEZhY2VCYWNrID0gQ3VsbEZhY2VCYWNrO1xcclxcblxcdGV4cG9ydHMuQ3VsbEZhY2VGcm9udCA9IEN1bGxGYWNlRnJvbnQ7XFxyXFxuXFx0ZXhwb3J0cy5DdWxsRmFjZUZyb250QmFjayA9IEN1bGxGYWNlRnJvbnRCYWNrO1xcclxcblxcdGV4cG9ydHMuRnJvbnRGYWNlRGlyZWN0aW9uQ1cgPSBGcm9udEZhY2VEaXJlY3Rpb25DVztcXHJcXG5cXHRleHBvcnRzLkZyb250RmFjZURpcmVjdGlvbkNDVyA9IEZyb250RmFjZURpcmVjdGlvbkNDVztcXHJcXG5cXHRleHBvcnRzLkJhc2ljU2hhZG93TWFwID0gQmFzaWNTaGFkb3dNYXA7XFxyXFxuXFx0ZXhwb3J0cy5QQ0ZTaGFkb3dNYXAgPSBQQ0ZTaGFkb3dNYXA7XFxyXFxuXFx0ZXhwb3J0cy5QQ0ZTb2Z0U2hhZG93TWFwID0gUENGU29mdFNoYWRvd01hcDtcXHJcXG5cXHRleHBvcnRzLkZyb250U2lkZSA9IEZyb250U2lkZTtcXHJcXG5cXHRleHBvcnRzLkJhY2tTaWRlID0gQmFja1NpZGU7XFxyXFxuXFx0ZXhwb3J0cy5Eb3VibGVTaWRlID0gRG91YmxlU2lkZTtcXHJcXG5cXHRleHBvcnRzLkZsYXRTaGFkaW5nID0gRmxhdFNoYWRpbmc7XFxyXFxuXFx0ZXhwb3J0cy5TbW9vdGhTaGFkaW5nID0gU21vb3RoU2hhZGluZztcXHJcXG5cXHRleHBvcnRzLk5vQ29sb3JzID0gTm9Db2xvcnM7XFxyXFxuXFx0ZXhwb3J0cy5GYWNlQ29sb3JzID0gRmFjZUNvbG9ycztcXHJcXG5cXHRleHBvcnRzLlZlcnRleENvbG9ycyA9IFZlcnRleENvbG9ycztcXHJcXG5cXHRleHBvcnRzLk5vQmxlbmRpbmcgPSBOb0JsZW5kaW5nO1xcclxcblxcdGV4cG9ydHMuTm9ybWFsQmxlbmRpbmcgPSBOb3JtYWxCbGVuZGluZztcXHJcXG5cXHRleHBvcnRzLkFkZGl0aXZlQmxlbmRpbmcgPSBBZGRpdGl2ZUJsZW5kaW5nO1xcclxcblxcdGV4cG9ydHMuU3VidHJhY3RpdmVCbGVuZGluZyA9IFN1YnRyYWN0aXZlQmxlbmRpbmc7XFxyXFxuXFx0ZXhwb3J0cy5NdWx0aXBseUJsZW5kaW5nID0gTXVsdGlwbHlCbGVuZGluZztcXHJcXG5cXHRleHBvcnRzLkN1c3RvbUJsZW5kaW5nID0gQ3VzdG9tQmxlbmRpbmc7XFxyXFxuXFx0ZXhwb3J0cy5BZGRFcXVhdGlvbiA9IEFkZEVxdWF0aW9uO1xcclxcblxcdGV4cG9ydHMuU3VidHJhY3RFcXVhdGlvbiA9IFN1YnRyYWN0RXF1YXRpb247XFxyXFxuXFx0ZXhwb3J0cy5SZXZlcnNlU3VidHJhY3RFcXVhdGlvbiA9IFJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uO1xcclxcblxcdGV4cG9ydHMuTWluRXF1YXRpb24gPSBNaW5FcXVhdGlvbjtcXHJcXG5cXHRleHBvcnRzLk1heEVxdWF0aW9uID0gTWF4RXF1YXRpb247XFxyXFxuXFx0ZXhwb3J0cy5aZXJvRmFjdG9yID0gWmVyb0ZhY3RvcjtcXHJcXG5cXHRleHBvcnRzLk9uZUZhY3RvciA9IE9uZUZhY3RvcjtcXHJcXG5cXHRleHBvcnRzLlNyY0NvbG9yRmFjdG9yID0gU3JjQ29sb3JGYWN0b3I7XFxyXFxuXFx0ZXhwb3J0cy5PbmVNaW51c1NyY0NvbG9yRmFjdG9yID0gT25lTWludXNTcmNDb2xvckZhY3RvcjtcXHJcXG5cXHRleHBvcnRzLlNyY0FscGhhRmFjdG9yID0gU3JjQWxwaGFGYWN0b3I7XFxyXFxuXFx0ZXhwb3J0cy5PbmVNaW51c1NyY0FscGhhRmFjdG9yID0gT25lTWludXNTcmNBbHBoYUZhY3RvcjtcXHJcXG5cXHRleHBvcnRzLkRzdEFscGhhRmFjdG9yID0gRHN0QWxwaGFGYWN0b3I7XFxyXFxuXFx0ZXhwb3J0cy5PbmVNaW51c0RzdEFscGhhRmFjdG9yID0gT25lTWludXNEc3RBbHBoYUZhY3RvcjtcXHJcXG5cXHRleHBvcnRzLkRzdENvbG9yRmFjdG9yID0gRHN0Q29sb3JGYWN0b3I7XFxyXFxuXFx0ZXhwb3J0cy5PbmVNaW51c0RzdENvbG9yRmFjdG9yID0gT25lTWludXNEc3RDb2xvckZhY3RvcjtcXHJcXG5cXHRleHBvcnRzLlNyY0FscGhhU2F0dXJhdGVGYWN0b3IgPSBTcmNBbHBoYVNhdHVyYXRlRmFjdG9yO1xcclxcblxcdGV4cG9ydHMuTmV2ZXJEZXB0aCA9IE5ldmVyRGVwdGg7XFxyXFxuXFx0ZXhwb3J0cy5BbHdheXNEZXB0aCA9IEFsd2F5c0RlcHRoO1xcclxcblxcdGV4cG9ydHMuTGVzc0RlcHRoID0gTGVzc0RlcHRoO1xcclxcblxcdGV4cG9ydHMuTGVzc0VxdWFsRGVwdGggPSBMZXNzRXF1YWxEZXB0aDtcXHJcXG5cXHRleHBvcnRzLkVxdWFsRGVwdGggPSBFcXVhbERlcHRoO1xcclxcblxcdGV4cG9ydHMuR3JlYXRlckVxdWFsRGVwdGggPSBHcmVhdGVyRXF1YWxEZXB0aDtcXHJcXG5cXHRleHBvcnRzLkdyZWF0ZXJEZXB0aCA9IEdyZWF0ZXJEZXB0aDtcXHJcXG5cXHRleHBvcnRzLk5vdEVxdWFsRGVwdGggPSBOb3RFcXVhbERlcHRoO1xcclxcblxcdGV4cG9ydHMuTXVsdGlwbHlPcGVyYXRpb24gPSBNdWx0aXBseU9wZXJhdGlvbjtcXHJcXG5cXHRleHBvcnRzLk1peE9wZXJhdGlvbiA9IE1peE9wZXJhdGlvbjtcXHJcXG5cXHRleHBvcnRzLkFkZE9wZXJhdGlvbiA9IEFkZE9wZXJhdGlvbjtcXHJcXG5cXHRleHBvcnRzLk5vVG9uZU1hcHBpbmcgPSBOb1RvbmVNYXBwaW5nO1xcclxcblxcdGV4cG9ydHMuTGluZWFyVG9uZU1hcHBpbmcgPSBMaW5lYXJUb25lTWFwcGluZztcXHJcXG5cXHRleHBvcnRzLlJlaW5oYXJkVG9uZU1hcHBpbmcgPSBSZWluaGFyZFRvbmVNYXBwaW5nO1xcclxcblxcdGV4cG9ydHMuVW5jaGFydGVkMlRvbmVNYXBwaW5nID0gVW5jaGFydGVkMlRvbmVNYXBwaW5nO1xcclxcblxcdGV4cG9ydHMuQ2luZW9uVG9uZU1hcHBpbmcgPSBDaW5lb25Ub25lTWFwcGluZztcXHJcXG5cXHRleHBvcnRzLlVWTWFwcGluZyA9IFVWTWFwcGluZztcXHJcXG5cXHRleHBvcnRzLkN1YmVSZWZsZWN0aW9uTWFwcGluZyA9IEN1YmVSZWZsZWN0aW9uTWFwcGluZztcXHJcXG5cXHRleHBvcnRzLkN1YmVSZWZyYWN0aW9uTWFwcGluZyA9IEN1YmVSZWZyYWN0aW9uTWFwcGluZztcXHJcXG5cXHRleHBvcnRzLkVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nID0gRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmc7XFxyXFxuXFx0ZXhwb3J0cy5FcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZyA9IEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nO1xcclxcblxcdGV4cG9ydHMuU3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmcgPSBTcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZztcXHJcXG5cXHRleHBvcnRzLkN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nID0gQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmc7XFxyXFxuXFx0ZXhwb3J0cy5DdWJlVVZSZWZyYWN0aW9uTWFwcGluZyA9IEN1YmVVVlJlZnJhY3Rpb25NYXBwaW5nO1xcclxcblxcdGV4cG9ydHMuUmVwZWF0V3JhcHBpbmcgPSBSZXBlYXRXcmFwcGluZztcXHJcXG5cXHRleHBvcnRzLkNsYW1wVG9FZGdlV3JhcHBpbmcgPSBDbGFtcFRvRWRnZVdyYXBwaW5nO1xcclxcblxcdGV4cG9ydHMuTWlycm9yZWRSZXBlYXRXcmFwcGluZyA9IE1pcnJvcmVkUmVwZWF0V3JhcHBpbmc7XFxyXFxuXFx0ZXhwb3J0cy5OZWFyZXN0RmlsdGVyID0gTmVhcmVzdEZpbHRlcjtcXHJcXG5cXHRleHBvcnRzLk5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyID0gTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXI7XFxyXFxuXFx0ZXhwb3J0cy5OZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyID0gTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlcjtcXHJcXG5cXHRleHBvcnRzLkxpbmVhckZpbHRlciA9IExpbmVhckZpbHRlcjtcXHJcXG5cXHRleHBvcnRzLkxpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIgPSBMaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyO1xcclxcblxcdGV4cG9ydHMuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyID0gTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyO1xcclxcblxcdGV4cG9ydHMuVW5zaWduZWRCeXRlVHlwZSA9IFVuc2lnbmVkQnl0ZVR5cGU7XFxyXFxuXFx0ZXhwb3J0cy5CeXRlVHlwZSA9IEJ5dGVUeXBlO1xcclxcblxcdGV4cG9ydHMuU2hvcnRUeXBlID0gU2hvcnRUeXBlO1xcclxcblxcdGV4cG9ydHMuVW5zaWduZWRTaG9ydFR5cGUgPSBVbnNpZ25lZFNob3J0VHlwZTtcXHJcXG5cXHRleHBvcnRzLkludFR5cGUgPSBJbnRUeXBlO1xcclxcblxcdGV4cG9ydHMuVW5zaWduZWRJbnRUeXBlID0gVW5zaWduZWRJbnRUeXBlO1xcclxcblxcdGV4cG9ydHMuRmxvYXRUeXBlID0gRmxvYXRUeXBlO1xcclxcblxcdGV4cG9ydHMuSGFsZkZsb2F0VHlwZSA9IEhhbGZGbG9hdFR5cGU7XFxyXFxuXFx0ZXhwb3J0cy5VbnNpZ25lZFNob3J0NDQ0NFR5cGUgPSBVbnNpZ25lZFNob3J0NDQ0NFR5cGU7XFxyXFxuXFx0ZXhwb3J0cy5VbnNpZ25lZFNob3J0NTU1MVR5cGUgPSBVbnNpZ25lZFNob3J0NTU1MVR5cGU7XFxyXFxuXFx0ZXhwb3J0cy5VbnNpZ25lZFNob3J0NTY1VHlwZSA9IFVuc2lnbmVkU2hvcnQ1NjVUeXBlO1xcclxcblxcdGV4cG9ydHMuVW5zaWduZWRJbnQyNDhUeXBlID0gVW5zaWduZWRJbnQyNDhUeXBlO1xcclxcblxcdGV4cG9ydHMuQWxwaGFGb3JtYXQgPSBBbHBoYUZvcm1hdDtcXHJcXG5cXHRleHBvcnRzLlJHQkZvcm1hdCA9IFJHQkZvcm1hdDtcXHJcXG5cXHRleHBvcnRzLlJHQkFGb3JtYXQgPSBSR0JBRm9ybWF0O1xcclxcblxcdGV4cG9ydHMuTHVtaW5hbmNlRm9ybWF0ID0gTHVtaW5hbmNlRm9ybWF0O1xcclxcblxcdGV4cG9ydHMuTHVtaW5hbmNlQWxwaGFGb3JtYXQgPSBMdW1pbmFuY2VBbHBoYUZvcm1hdDtcXHJcXG5cXHRleHBvcnRzLlJHQkVGb3JtYXQgPSBSR0JFRm9ybWF0O1xcclxcblxcdGV4cG9ydHMuRGVwdGhGb3JtYXQgPSBEZXB0aEZvcm1hdDtcXHJcXG5cXHRleHBvcnRzLkRlcHRoU3RlbmNpbEZvcm1hdCA9IERlcHRoU3RlbmNpbEZvcm1hdDtcXHJcXG5cXHRleHBvcnRzLlJHQl9TM1RDX0RYVDFfRm9ybWF0ID0gUkdCX1MzVENfRFhUMV9Gb3JtYXQ7XFxyXFxuXFx0ZXhwb3J0cy5SR0JBX1MzVENfRFhUMV9Gb3JtYXQgPSBSR0JBX1MzVENfRFhUMV9Gb3JtYXQ7XFxyXFxuXFx0ZXhwb3J0cy5SR0JBX1MzVENfRFhUM19Gb3JtYXQgPSBSR0JBX1MzVENfRFhUM19Gb3JtYXQ7XFxyXFxuXFx0ZXhwb3J0cy5SR0JBX1MzVENfRFhUNV9Gb3JtYXQgPSBSR0JBX1MzVENfRFhUNV9Gb3JtYXQ7XFxyXFxuXFx0ZXhwb3J0cy5SR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IFJHQl9QVlJUQ180QlBQVjFfRm9ybWF0O1xcclxcblxcdGV4cG9ydHMuUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSBSR0JfUFZSVENfMkJQUFYxX0Zvcm1hdDtcXHJcXG5cXHRleHBvcnRzLlJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IFJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdDtcXHJcXG5cXHRleHBvcnRzLlJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCA9IFJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdDtcXHJcXG5cXHRleHBvcnRzLlJHQl9FVEMxX0Zvcm1hdCA9IFJHQl9FVEMxX0Zvcm1hdDtcXHJcXG5cXHRleHBvcnRzLkxvb3BPbmNlID0gTG9vcE9uY2U7XFxyXFxuXFx0ZXhwb3J0cy5Mb29wUmVwZWF0ID0gTG9vcFJlcGVhdDtcXHJcXG5cXHRleHBvcnRzLkxvb3BQaW5nUG9uZyA9IExvb3BQaW5nUG9uZztcXHJcXG5cXHRleHBvcnRzLkludGVycG9sYXRlRGlzY3JldGUgPSBJbnRlcnBvbGF0ZURpc2NyZXRlO1xcclxcblxcdGV4cG9ydHMuSW50ZXJwb2xhdGVMaW5lYXIgPSBJbnRlcnBvbGF0ZUxpbmVhcjtcXHJcXG5cXHRleHBvcnRzLkludGVycG9sYXRlU21vb3RoID0gSW50ZXJwb2xhdGVTbW9vdGg7XFxyXFxuXFx0ZXhwb3J0cy5aZXJvQ3VydmF0dXJlRW5kaW5nID0gWmVyb0N1cnZhdHVyZUVuZGluZztcXHJcXG5cXHRleHBvcnRzLlplcm9TbG9wZUVuZGluZyA9IFplcm9TbG9wZUVuZGluZztcXHJcXG5cXHRleHBvcnRzLldyYXBBcm91bmRFbmRpbmcgPSBXcmFwQXJvdW5kRW5kaW5nO1xcclxcblxcdGV4cG9ydHMuVHJpYW5nbGVzRHJhd01vZGUgPSBUcmlhbmdsZXNEcmF3TW9kZTtcXHJcXG5cXHRleHBvcnRzLlRyaWFuZ2xlU3RyaXBEcmF3TW9kZSA9IFRyaWFuZ2xlU3RyaXBEcmF3TW9kZTtcXHJcXG5cXHRleHBvcnRzLlRyaWFuZ2xlRmFuRHJhd01vZGUgPSBUcmlhbmdsZUZhbkRyYXdNb2RlO1xcclxcblxcdGV4cG9ydHMuTGluZWFyRW5jb2RpbmcgPSBMaW5lYXJFbmNvZGluZztcXHJcXG5cXHRleHBvcnRzLnNSR0JFbmNvZGluZyA9IHNSR0JFbmNvZGluZztcXHJcXG5cXHRleHBvcnRzLkdhbW1hRW5jb2RpbmcgPSBHYW1tYUVuY29kaW5nO1xcclxcblxcdGV4cG9ydHMuUkdCRUVuY29kaW5nID0gUkdCRUVuY29kaW5nO1xcclxcblxcdGV4cG9ydHMuTG9nTHV2RW5jb2RpbmcgPSBMb2dMdXZFbmNvZGluZztcXHJcXG5cXHRleHBvcnRzLlJHQk03RW5jb2RpbmcgPSBSR0JNN0VuY29kaW5nO1xcclxcblxcdGV4cG9ydHMuUkdCTTE2RW5jb2RpbmcgPSBSR0JNMTZFbmNvZGluZztcXHJcXG5cXHRleHBvcnRzLlJHQkRFbmNvZGluZyA9IFJHQkRFbmNvZGluZztcXHJcXG5cXHRleHBvcnRzLkJhc2ljRGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmc7XFxyXFxuXFx0ZXhwb3J0cy5SR0JBRGVwdGhQYWNraW5nID0gUkdCQURlcHRoUGFja2luZztcXHJcXG5cXHRleHBvcnRzLkN1YmVHZW9tZXRyeSA9IEJveEdlb21ldHJ5O1xcclxcblxcdGV4cG9ydHMuRmFjZTQgPSBGYWNlNDtcXHJcXG5cXHRleHBvcnRzLkxpbmVTdHJpcCA9IExpbmVTdHJpcDtcXHJcXG5cXHRleHBvcnRzLkxpbmVQaWVjZXMgPSBMaW5lUGllY2VzO1xcclxcblxcdGV4cG9ydHMuTWVzaEZhY2VNYXRlcmlhbCA9IE1lc2hGYWNlTWF0ZXJpYWw7XFxyXFxuXFx0ZXhwb3J0cy5NdWx0aU1hdGVyaWFsID0gTXVsdGlNYXRlcmlhbDtcXHJcXG5cXHRleHBvcnRzLlBvaW50Q2xvdWQgPSBQb2ludENsb3VkO1xcclxcblxcdGV4cG9ydHMuUGFydGljbGUgPSBQYXJ0aWNsZTtcXHJcXG5cXHRleHBvcnRzLlBhcnRpY2xlU3lzdGVtID0gUGFydGljbGVTeXN0ZW07XFxyXFxuXFx0ZXhwb3J0cy5Qb2ludENsb3VkTWF0ZXJpYWwgPSBQb2ludENsb3VkTWF0ZXJpYWw7XFxyXFxuXFx0ZXhwb3J0cy5QYXJ0aWNsZUJhc2ljTWF0ZXJpYWwgPSBQYXJ0aWNsZUJhc2ljTWF0ZXJpYWw7XFxyXFxuXFx0ZXhwb3J0cy5QYXJ0aWNsZVN5c3RlbU1hdGVyaWFsID0gUGFydGljbGVTeXN0ZW1NYXRlcmlhbDtcXHJcXG5cXHRleHBvcnRzLlZlcnRleCA9IFZlcnRleDtcXHJcXG5cXHRleHBvcnRzLkR5bmFtaWNCdWZmZXJBdHRyaWJ1dGUgPSBEeW5hbWljQnVmZmVyQXR0cmlidXRlO1xcclxcblxcdGV4cG9ydHMuSW50OEF0dHJpYnV0ZSA9IEludDhBdHRyaWJ1dGU7XFxyXFxuXFx0ZXhwb3J0cy5VaW50OEF0dHJpYnV0ZSA9IFVpbnQ4QXR0cmlidXRlO1xcclxcblxcdGV4cG9ydHMuVWludDhDbGFtcGVkQXR0cmlidXRlID0gVWludDhDbGFtcGVkQXR0cmlidXRlO1xcclxcblxcdGV4cG9ydHMuSW50MTZBdHRyaWJ1dGUgPSBJbnQxNkF0dHJpYnV0ZTtcXHJcXG5cXHRleHBvcnRzLlVpbnQxNkF0dHJpYnV0ZSA9IFVpbnQxNkF0dHJpYnV0ZTtcXHJcXG5cXHRleHBvcnRzLkludDMyQXR0cmlidXRlID0gSW50MzJBdHRyaWJ1dGU7XFxyXFxuXFx0ZXhwb3J0cy5VaW50MzJBdHRyaWJ1dGUgPSBVaW50MzJBdHRyaWJ1dGU7XFxyXFxuXFx0ZXhwb3J0cy5GbG9hdDMyQXR0cmlidXRlID0gRmxvYXQzMkF0dHJpYnV0ZTtcXHJcXG5cXHRleHBvcnRzLkZsb2F0NjRBdHRyaWJ1dGUgPSBGbG9hdDY0QXR0cmlidXRlO1xcclxcblxcdGV4cG9ydHMuQ2xvc2VkU3BsaW5lQ3VydmUzID0gQ2xvc2VkU3BsaW5lQ3VydmUzO1xcclxcblxcdGV4cG9ydHMuU3BsaW5lQ3VydmUzID0gU3BsaW5lQ3VydmUzO1xcclxcblxcdGV4cG9ydHMuU3BsaW5lID0gU3BsaW5lO1xcclxcblxcdGV4cG9ydHMuQXhpc0hlbHBlciA9IEF4aXNIZWxwZXI7XFxyXFxuXFx0ZXhwb3J0cy5Cb3VuZGluZ0JveEhlbHBlciA9IEJvdW5kaW5nQm94SGVscGVyO1xcclxcblxcdGV4cG9ydHMuRWRnZXNIZWxwZXIgPSBFZGdlc0hlbHBlcjtcXHJcXG5cXHRleHBvcnRzLldpcmVmcmFtZUhlbHBlciA9IFdpcmVmcmFtZUhlbHBlcjtcXHJcXG5cXHRleHBvcnRzLlhIUkxvYWRlciA9IFhIUkxvYWRlcjtcXHJcXG5cXHRleHBvcnRzLkJpbmFyeVRleHR1cmVMb2FkZXIgPSBCaW5hcnlUZXh0dXJlTG9hZGVyO1xcclxcblxcdGV4cG9ydHMuR2VvbWV0cnlVdGlscyA9IEdlb21ldHJ5VXRpbHM7XFxyXFxuXFx0ZXhwb3J0cy5JbWFnZVV0aWxzID0gSW1hZ2VVdGlscztcXHJcXG5cXHRleHBvcnRzLlByb2plY3RvciA9IFByb2plY3RvcjtcXHJcXG5cXHRleHBvcnRzLkNhbnZhc1JlbmRlcmVyID0gQ2FudmFzUmVuZGVyZXI7XFxyXFxuXFxyXFxuXFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcXHJcXG5cXHJcXG59KSkpO1xcclxcblwiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///931\n")},685:module=>{eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nmodule.exports = function(src) {\n\tfunction log(error) {\n\t\t(typeof console !== "undefined")\n\t\t&& (console.error || console.log)("[Script Loader]", error);\n\t}\n\n\t// Check for IE =< 8\n\tfunction isIE() {\n\t\treturn typeof attachEvent !== "undefined" && typeof addEventListener === "undefined";\n\t}\n\n\ttry {\n\t\tif (typeof execScript !== "undefined" && isIE()) {\n\t\t\texecScript(src);\n\t\t} else if (typeof eval !== "undefined") {\n\t\t\teval.call(null, src);\n\t\t} else {\n\t\t\tlog("EvalError: No eval function available");\n\t\t}\n\t} catch (error) {\n\t\tlog(error);\n\t}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aHJlZS1hdnMtZGFzaC8uL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qcz9mMmI1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EiLCJmaWxlIjoiNjg1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3JjKSB7XG5cdGZ1bmN0aW9uIGxvZyhlcnJvcikge1xuXHRcdCh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIilcblx0XHQmJiAoY29uc29sZS5lcnJvciB8fCBjb25zb2xlLmxvZykoXCJbU2NyaXB0IExvYWRlcl1cIiwgZXJyb3IpO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIElFID08IDhcblx0ZnVuY3Rpb24gaXNJRSgpIHtcblx0XHRyZXR1cm4gdHlwZW9mIGF0dGFjaEV2ZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBhZGRFdmVudExpc3RlbmVyID09PSBcInVuZGVmaW5lZFwiO1xuXHR9XG5cblx0dHJ5IHtcblx0XHRpZiAodHlwZW9mIGV4ZWNTY3JpcHQgIT09IFwidW5kZWZpbmVkXCIgJiYgaXNJRSgpKSB7XG5cdFx0XHRleGVjU2NyaXB0KHNyYyk7XG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgZXZhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0ZXZhbC5jYWxsKG51bGwsIHNyYyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxvZyhcIkV2YWxFcnJvcjogTm8gZXZhbCBmdW5jdGlvbiBhdmFpbGFibGVcIik7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdGxvZyhlcnJvcik7XG5cdH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///685\n')},782:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("__webpack_require__(685)(__webpack_require__(243))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aHJlZS1hdnMtZGFzaC8uL2pzL1V0aWxzLmpzPzdiNWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsbUJBQU8sQ0FBQyxHQUFnRixFQUFFLG1CQUFPLENBQUMsR0FBeUgiLCJmaWxlIjoiNzgyLmpzIiwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIiEhRDpcXFxccHJvamVjdHNcXFxcYXZzXFxcXHRocmVlLWF2cy1kYXNoXFxcXG5vZGVfbW9kdWxlc1xcXFxzY3JpcHQtbG9hZGVyXFxcXGFkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISFEOlxcXFxwcm9qZWN0c1xcXFxhdnNcXFxcdGhyZWUtYXZzLWRhc2hcXFxcbm9kZV9tb2R1bGVzXFxcXHJhdy1sb2FkZXJcXFxcaW5kZXguanMhRDpcXFxccHJvamVjdHNcXFxcYXZzXFxcXHRocmVlLWF2cy1kYXNoXFxcXGpzXFxcXFV0aWxzLmpzXCIpKSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///782\n")},643:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("__webpack_require__(685)(__webpack_require__(931))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aHJlZS1hdnMtZGFzaC8uL3ZlbmRvci90aHJlZS5qcz9jOTJhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLG1CQUFPLENBQUMsR0FBZ0YsRUFBRSxtQkFBTyxDQUFDLEdBQTZIIiwiZmlsZSI6IjY0My5qcyIsInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIUQ6XFxcXHByb2plY3RzXFxcXGF2c1xcXFx0aHJlZS1hdnMtZGFzaFxcXFxub2RlX21vZHVsZXNcXFxcc2NyaXB0LWxvYWRlclxcXFxhZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhRDpcXFxccHJvamVjdHNcXFxcYXZzXFxcXHRocmVlLWF2cy1kYXNoXFxcXG5vZGVfbW9kdWxlc1xcXFxyYXctbG9hZGVyXFxcXGluZGV4LmpzIUQ6XFxcXHByb2plY3RzXFxcXGF2c1xcXFx0aHJlZS1hdnMtZGFzaFxcXFx2ZW5kb3JcXFxcdGhyZWUuanNcIikpIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///643\n")},279:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval("\n// EXTERNAL MODULE: ./node_modules/script-loader/index.js!./vendor/three.js\nvar three = __webpack_require__(643);\n// EXTERNAL MODULE: ./node_modules/script-loader/index.js!./js/Utils.js\nvar Utils = __webpack_require__(782);\n;// CONCATENATED MODULE: ./js/GPGPU.js\n/* Partially adapted from https://github.com/turbo/js/blob/master/turbo.js\r\n *\r\n * Turbo.js License:\r\n * Copyright (c) 2016 minxomat\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\nconst vertexShaderCode = `#version 300 es\r\nin vec2 position;\r\nin vec2 texture;\r\nout vec2 kernelPosition;\r\n\r\nvoid main(void) {\r\n  kernelPosition = texture;\r\n  gl_Position = vec4(position.xy, 0.0, 1.0);\r\n}\r\n`;\r\n\r\nconst fragmentShaderHeader = `#version 300 es\r\nprecision highp float;\r\nprecision highp int;\r\nprecision highp sampler2D;\r\nprecision highp sampler2DArray;\r\nprecision highp sampler3D;\r\nprecision highp samplerCube;\r\n\r\nin vec2 kernelPosition;\r\nout vec4 kernelOut;\r\nuniform ivec2 kernelSize;\r\n`;\r\n\r\nclass GPGPU {\r\n  static alloc(size, stride) {\r\n    if (!Number.isInteger(stride) || stride < 1 || stride > 4)\r\n      throw new Error(\"Data stride must be an integer between 1 and 4.\");\r\n\r\n    // Find the smallest perfect square greater than or equal to size\r\n    const squareSize = Math.pow(Math.ceil(Math.sqrt(size)), 2);\r\n\r\n    const data = new Float32Array(squareSize * stride);\r\n    data.gpgpuSize = size;\r\n    data.gpgpuStride = stride;\r\n    return data;\r\n  }\r\n\r\n  constructor(configs, shared = {}) {\r\n    this._setUpGL();\r\n\r\n    this.outputTextures = {};\r\n    this.sharedTextures = {};\r\n\r\n    this.programs = configs.map(c => this._prepareProgram(c));\r\n\r\n    for (const name in shared) {\r\n      const options = shared[name];\r\n      const { width, height, channels, data } = options;\r\n      this.sharedTextures[name] = this._createTexture(data, width, height, channels, options);\r\n    }\r\n  }\r\n\r\n  updateSharedTextures(shared) {\r\n    this.sharedTextures = {};\r\n\r\n    for (const name in shared) {\r\n      const options = shared[name];\r\n      const { width, height, channels, data } = options;\r\n      if (this.sharedTextures[name]) this.gl.deleteTexture(this.sharedTextures[name]);\r\n      this.sharedTextures[name] = this._createTexture(data, width, height, channels, options);\r\n    }\r\n  }\r\n\r\n  updateProgram(programOrProgramIndex, config) {\r\n    const program = typeof(programOrProgramIndex) == 'number' ? this.programs[programOrProgramIndex] : programOrProgramIndex;\r\n\r\n    if (!program)\r\n      throw new Error(`Program with index ${programOrProgramIndex} does not exist.`);\r\n\r\n    if (config.inputs)\r\n      throw new Error('The `updateProgram` function cannot be used to update inputs. Use `updateProgramInputs` instead.');\r\n\r\n    if (config.meta)\r\n      program.meta = Object.assign(program.meta, config.meta);\r\n\r\n    if (config.width !== undefined && config.height !== undefined)\r\n      this.updateProgramSize(program, config.width, config.height);\r\n\r\n    if (typeof(config.uniforms) == 'object')\r\n      this.updateProgramUniforms(program, config.uniforms);\r\n  }\r\n\r\n  updateProgramInputs(programIndex, inputs) {\r\n    const program = this.programs[programIndex];\r\n\r\n    if (!program)\r\n      throw new Error(`Program with index ${programIndex} does not exist.`);\r\n\r\n    if (program.inputTextures.length != inputs.length)\r\n      throw new Error(`You must provide the same number of inputs as when the program was set up: got ${inputs.length} but expected ${program.inputTextures.length}.`);\r\n\r\n    const previousInputWidth = program.inputWidth;\r\n    const previousInputHeight = program.inputHeight;\r\n\r\n    const config = program.config;\r\n\r\n    if (config.width === undefined || config.height === undefined) {\r\n      program.inputWidth = undefined;\r\n      program.inputHeight = undefined;\r\n      program.inputDataSize = undefined;\r\n    }\r\n\r\n    this._prepareProgramInputs(program, inputs);\r\n\r\n    if (program.inputWidth != previousInputWidth || program.inputHeight != previousInputHeight) {\r\n      this.gl.useProgram(program.glProgram);\r\n      this.gl.uniform2i(program.kernelSizeLocation, program.inputWidth, program.inputHeight);\r\n      this._prepareProgramOutput(program);\r\n    }\r\n  }\r\n\r\n  updateProgramSize(programOrProgramIndex, width, height) {\r\n    const program = typeof(programOrProgramIndex) == 'number' ? this.programs[programOrProgramIndex] : programOrProgramIndex;\r\n\r\n    if (!program)\r\n      throw new Error(`Program with index ${programOrProgramIndex} does not exist.`);\r\n\r\n    if (program.inputTextures.length != 0)\r\n      throw new Error(`Size can only be updated on programs with no inputs.`);\r\n\r\n    if (width == program.inputWidth && height == program.inputHeight) return;\r\n\r\n    program.inputWidth = width;\r\n    program.inputHeight = height;\r\n    program.inputDataSize = width * height;\r\n\r\n    this.gl.useProgram(program.glProgram);\r\n    this.gl.uniform2i(program.kernelSizeLocation, program.inputWidth, program.inputHeight);\r\n    this._prepareProgramOutput(program);\r\n  }\r\n\r\n  updateProgramUniforms(programOrProgramIndex, uniforms) {\r\n    const program = typeof(programOrProgramIndex) == 'number' ? this.programs[programOrProgramIndex] : programOrProgramIndex;\r\n    this.gl.useProgram(program.glProgram);\r\n\r\n    if (!program)\r\n      throw new Error(`Program with index ${programOrProgramIndex} does not exist.`);\r\n\r\n    for (const uniformName in uniforms) {\r\n      const value = uniforms[uniformName];\r\n      let uniform;\r\n\r\n      if (uniform = program.uniforms[uniformName]) {\r\n        this._setUniform(uniform.type, uniform.location, value)\r\n      } else if (uniform = program.uniformTextures[uniformName]) {\r\n        if (typeof(value) != 'object' || value.type != 'texture')\r\n          throw new Error(`Expected texture type for uniform ${uniformName}.`);\r\n\r\n        const { width, height, channels, data } = uniform;\r\n        if (program.uniformTextures[uniformName].texture) this.gl.deleteTexture(program.uniformTextures[uniformName].texture);\r\n        program.uniformTextures[uniformName].texture = this._createTexture(data, width, height, channels, uniform);\r\n      } else {\r\n        throw new Error(`The uniform ${uniformName} does not exist in this program.`);\r\n      }\r\n    }\r\n  }\r\n\r\n  run() {\r\n    const outputs = [];\r\n\r\n    for (const program of this.programs) {\r\n      this.gl.useProgram(program.glProgram);\r\n      this.gl.viewport(0, 0, program.inputWidth, program.inputHeight);\r\n      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, program.frameBuffer);\r\n\r\n      for (const [index, inputTexture] of program.inputTextures.entries()) {\r\n        this.gl.activeTexture(this.gl.TEXTURE0 + index);\r\n        this.gl.bindTexture(this.gl.TEXTURE_2D, inputTexture);\r\n      }\r\n\r\n      for (const uniformName in program.uniformTextures) {\r\n        const uniformTexture = program.uniformTextures[uniformName];\r\n        this.gl.activeTexture(this.gl.TEXTURE0 + uniformTexture.index);\r\n        this.gl.bindTexture(uniformTexture.target, uniformTexture.texture || this.sharedTextures[uniformTexture.name] || this.outputTextures[uniformTexture.name]);\r\n      }\r\n\r\n      if (typeof(program.draw) == 'function') {\r\n        program.draw(this, program);\r\n      } else {\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.textureBuffer);\r\n        this.gl.enableVertexAttribArray(program.textureLocation);\r\n        this.gl.vertexAttribPointer(program.textureLocation, 2, this.gl.FLOAT, false, 0, 0);\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);\r\n        this.gl.enableVertexAttribArray(program.positionLocation);\r\n        this.gl.vertexAttribPointer(program.positionLocation, 2, this.gl.FLOAT, false, 0, 0);\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\r\n\r\n        if (program.drawProxy) {\r\n          const draw = (() => this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_SHORT, 0)).bind(this);\r\n          program.drawProxy(this, program, draw);\r\n        } else {\r\n          this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_SHORT, 0);\r\n        }\r\n      }\r\n\r\n      if (program.output && program.output.name && !program.output.read) {\r\n        outputs.push(null);\r\n      } else {\r\n        const output = new Float32Array(program.inputWidth * program.inputHeight * 4);\r\n        this.gl.readPixels(0, 0, program.inputWidth, program.inputHeight, this.gl.RGBA, this.gl.FLOAT, output);\r\n        outputs.push(output.subarray(0, program.inputDataSize * 4));\r\n      }\r\n    }\r\n\r\n    return outputs;\r\n  }\r\n\r\n  _setUpGL() {\r\n    let canvas;\r\n\r\n    if (self.document)\r\n      canvas = document.createElement('canvas');\r\n    else if (self.OffscreenCanvas)\r\n      canvas = new OffscreenCanvas(0, 0);\r\n    else\r\n      throw new Error('Could not create a canvas.');\r\n\r\n    const attr = { alpha: false, antialias: false };\r\n    this.gl = canvas.getContext(\"webgl2\", attr) || canvas.getContext(\"experimental-webgl2\", attr);\r\n\r\n    if (!this.gl)\r\n      throw new Error(\"Unable to initialize WebGL2. Your browser may not support it.\");\r\n\r\n    if (!this.gl.getExtension('EXT_color_buffer_float'))\r\n      throw new Error('Required WebGL extension EXT_color_buffer_float not supported.');\r\n\r\n    if (!this.gl.getExtension('OES_texture_float_linear'))\r\n      throw new Error('Required WebGL extension OES_texture_float_linear not supported.');\r\n\r\n    this.positionBuffer = this._newBuffer([-1, -1, 1, -1, 1, 1, -1, 1]);\r\n    this.textureBuffer = this._newBuffer([0, 0, 1, 0, 1, 1, 0, 1]);\r\n    this.indexBuffer = this._newBuffer([1, 2, 0, 3, 0, 2], Uint16Array, this.gl.ELEMENT_ARRAY_BUFFER);\r\n  }\r\n\r\n  _prepareProgram(config) {\r\n    const program = { config };\r\n\r\n    program.draw = config.draw;\r\n    program.drawProxy = config.drawProxy;\r\n    program.meta = Object.assign({}, config.meta);\r\n\r\n    if (config.width && config.height) {\r\n      program.inputWidth = config.width;\r\n      program.inputHeight = config.height;\r\n      program.inputDataSize = config.width * config.height;\r\n    }\r\n\r\n    program.output = config.output;\r\n\r\n    const kernel = config.kernel;\r\n\r\n    if (typeof(kernel) != 'string' || kernel.length == 0)\r\n      throw new Error(\"Kernel code cannot be empty.\");\r\n\r\n    const inputs = config.inputs || [];\r\n    const uniforms = config.uniforms || {};\r\n\r\n    this._prepareProgramInputs(program, inputs);\r\n\r\n    let fragmentShaderConfig = \"\";\r\n    \r\n    for (const index in inputs)\r\n      fragmentShaderConfig += `uniform sampler2D _input${index};\\n`;\r\n\r\n    if (program.inputWidth === undefined || program.inputHeight === undefined)\r\n      throw new Error(\"Unknown kernel size. You must provide either an input or the `width` and `height` parameters in the kernel config.\");\r\n\r\n    program.uniformTextures = {};\r\n    program.uniforms = {};\r\n\r\n    for (const uniformName in uniforms) {\r\n      const uniform = uniforms[uniformName];\r\n\r\n      if (typeof(uniform) == 'number') {\r\n        program.uniforms[uniformName] = {\r\n          type: 'float',\r\n          value: uniform\r\n        };\r\n        fragmentShaderConfig += `uniform float ${uniformName};\\n`;\r\n      } else if (Array.isArray(uniform)) {\r\n        if (uniform.length < 2 || uniform.length > 4)\r\n          throw new Error(`Array uniforms can only have lengths of 2, 3, or 4 elements (corresponding to vec2, vec3, and vec4).`);\r\n\r\n        const type = ['vec2', 'vec3', 'vec4'][uniform.length - 2];\r\n        program.uniforms[uniformName] = {\r\n          type: type,\r\n          value: uniform\r\n        };\r\n        fragmentShaderConfig += `uniform ${type} ${uniformName};\\n`;\r\n      } else {\r\n        const { type, width, height, channels, data, value, length, name } = uniform;\r\n\r\n        if (type == 'texture' || type == 'outputTexture' || type == 'sharedTexture') {\r\n          let target, type;\r\n\r\n          if (uniform.textureType == '3D') {\r\n            target = this.gl.TEXTURE_3D;\r\n            type = 'sampler3D';\r\n          } else if (uniform.textureType == '2DArray') {\r\n            target = this.gl.TEXTURE_2D_ARRAY;\r\n            type = 'sampler2DArray';\r\n          } else {\r\n            target = this.gl.TEXTURE_2D;\r\n            type = 'sampler2D';\r\n          }\r\n\r\n          if (type == 'texture') {\r\n            program.uniformTextures[uniformName] = { target, texture: data ? this._createTexture(data, width, height, channels, uniform) : null };\r\n          } else {\r\n            program.uniformTextures[uniformName] = { target, texture: null, name: name || uniformName };\r\n          }\r\n\r\n          fragmentShaderConfig += `uniform ${type} ${uniformName};\\n`;\r\n        } else {\r\n          program.uniforms[uniformName] = { type, value };\r\n          if (length !== undefined)\r\n            fragmentShaderConfig += `uniform ${type} ${uniformName}[${length}];\\n`;\r\n          else\r\n            fragmentShaderConfig += `uniform ${type} ${uniformName};\\n`;\r\n        }\r\n      }\r\n    }\r\n\r\n    const vertexShader = this.gl.createShader(this.gl.VERTEX_SHADER);\r\n    this.gl.shaderSource(vertexShader, config.vertexShader || vertexShaderCode);\r\n    this.gl.compileShader(vertexShader);\r\n\r\n    if (!this.gl.getShaderParameter(vertexShader, this.gl.COMPILE_STATUS)) {\r\n      throw new Error(\r\n        \"Could not build vertex shader (fatal).\\n\" + \"\\n\" +\r\n        \"--- CODE DUMP ---\\n\" + (config.vertexShader || vertexShaderCode) + \"\\n\\n\" +\r\n        \"--- ERROR LOG ---\\n\" + this.gl.getShaderInfoLog(vertexShader)\r\n      );\r\n    }\r\n\r\n    const fragmentShaderMain = `\r\nvoid main() {\r\n  kernelOut = vec4(kernel(${[...Array(inputs.length).keys()].map(i => `texture(_input${i}, kernelPosition)`).join(', ')}));\r\n}\r\n    `;\r\n\r\n    const fragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);\r\n    const fragmentShaderSource = fragmentShaderHeader + fragmentShaderConfig + kernel + fragmentShaderMain;\r\n    this.gl.shaderSource(fragmentShader, fragmentShaderSource);\r\n    this.gl.compileShader(fragmentShader);\r\n\r\n    if (!this.gl.getShaderParameter(fragmentShader, this.gl.COMPILE_STATUS)) {\r\n      const source = fragmentShaderSource.split('\\n');\r\n      let dbgMsg = \"ERROR: Could not build shader (fatal).\\n\\n------------------ KERNEL CODE DUMP ------------------\\n\"\r\n\r\n      for (let l = 0; l < source.length; l++)\r\n        dbgMsg += `${l + 1}> ${source[l]}\\n`;\r\n\r\n      dbgMsg += \"\\n--------------------- ERROR  LOG ---------------------\\n\" + this.gl.getShaderInfoLog(fragmentShader);\r\n\r\n      throw new Error(dbgMsg);\r\n    }\r\n\r\n    program.glProgram = this.gl.createProgram();\r\n    this.gl.attachShader(program.glProgram, vertexShader);\r\n    this.gl.attachShader(program.glProgram, fragmentShader);\r\n    this.gl.linkProgram(program.glProgram);\r\n    this.gl.useProgram(program.glProgram);\r\n\r\n    if (!this.gl.getProgramParameter(program.glProgram, this.gl.LINK_STATUS))\r\n      throw new Error('Failed to link GLSL program code.');\r\n\r\n    let textureIndex = 0;\r\n\r\n    for (const input of program.inputTextures) {\r\n      const location = this.gl.getUniformLocation(program.glProgram, `_input${textureIndex}`);\r\n      this.gl.uniform1i(location, textureIndex);\r\n      textureIndex++;\r\n    }\r\n\r\n    for (const uniformName in program.uniformTextures) {\r\n      program.uniformTextures[uniformName].index = textureIndex;\r\n      const location = this.gl.getUniformLocation(program.glProgram, uniformName);\r\n      this.gl.uniform1i(location, textureIndex);\r\n      textureIndex++;\r\n    }\r\n\r\n    for (const uniformName in program.uniforms) {\r\n      const { type, value } = program.uniforms[uniformName];\r\n      const location = program.uniforms[uniformName].location = this.gl.getUniformLocation(program.glProgram, uniformName);\r\n\r\n      if (value !== undefined)\r\n        this._setUniform(type, location, value);\r\n\r\n      delete program.uniforms[uniformName].value;\r\n    }\r\n\r\n    program.kernelSizeLocation = this.gl.getUniformLocation(program.glProgram, 'kernelSize');\r\n    this.gl.uniform2i(program.kernelSizeLocation, program.inputWidth, program.inputHeight);\r\n\r\n    program.positionLocation = this.gl.getAttribLocation(program.glProgram, 'position');\r\n    program.textureLocation = this.gl.getAttribLocation(program.glProgram, 'texture');\r\n\r\n    program.frameBuffer = this.gl.createFramebuffer();\r\n    this._prepareProgramOutput(program);\r\n\r\n    return program;\r\n  }\r\n\r\n  _prepareProgramInputs(program, inputs) {\r\n    if (program.inputTextures)\r\n      program.inputTextures.forEach(t => this.gl.deleteTexture(t));\r\n\r\n    program.inputTextures = [];\r\n\r\n    for (const [index, data] of inputs.entries()) {\r\n      if (data.gpgpuSize === undefined || data.gpgpuStride === undefined)\r\n        throw new Error('GPGPU inputs must be created by the `alloc` function.');\r\n\r\n      const size = Math.sqrt(data.length / data.gpgpuStride);\r\n      if (size <= 0 || size % 1 != 0)\r\n        throw new Error('GPGPU input size is expected to be a perfect square.');\r\n\r\n      if (program.inputWidth === undefined || program.inputHeight === undefined) {\r\n        program.inputWidth = size;\r\n        program.inputHeight = size;\r\n        program.inputDataSize = data.gpgpuSize;\r\n      } else if (size != program.inputWidth || size != program.inputHeight) {\r\n        throw new Error(`All GPGPU inputs must be of the same size. Received ${data.gpgpuSize} (internal ${size * size}) but expected ${program.inputDataSize} (internal ${program.inputWidth * program.inputHeight}).`);\r\n      }\r\n\r\n      program.inputTextures.push(this._createTexture(data, size, size, data.gpgpuStride));\r\n    }\r\n  }\r\n\r\n  _prepareProgramOutput(program) {\r\n    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, program.frameBuffer);\r\n\r\n    const outputTexture = this._createTexture(null, program.inputWidth, program.inputHeight, 4, program.output);\r\n\r\n    if (program.output && program.output.textureType !== '3D' && program.output.textureType !== '2DArray') {\r\n      this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, outputTexture, 0);\r\n      const frameBufferStatus = (this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER) == this.gl.FRAMEBUFFER_COMPLETE);\r\n      if (!frameBufferStatus)\r\n        throw new Error('Error attaching float texture to framebuffer. Your device is probably incompatible.');\r\n    }\r\n\r\n    if (program.outputTexture !== undefined)\r\n      this.gl.deleteTexture(program.outputTexture);\r\n    program.outputTexture = outputTexture;\r\n\r\n    if (program.output && program.output.name)\r\n      this.outputTextures[program.output.name] = outputTexture;\r\n  }\r\n\r\n  _setUniform(type, location, value) {\r\n    switch (type) {\r\n      case 'int': this.gl.uniform1i(location, value); break;\r\n      case 'float': Array.isArray(value) ? this.gl.uniform1fv(location, value) : this.gl.uniform1f(location, value); break;\r\n      case 'vec2': this.gl.uniform2fv(location, value); break;\r\n      case 'vec3': this.gl.uniform3fv(location, value); break;\r\n      case 'vec4': this.gl.uniform4fv(location, value); break;\r\n      case 'mat3': this.gl.uniformMatrix3fv(location, value); break;\r\n      default: throw new Error(`Unknown uniform type ${type}.`);\r\n    }\r\n  }\r\n\r\n  _newBuffer(data, klass, target) {\r\n    const buf = this.gl.createBuffer();\r\n\r\n    this.gl.bindBuffer((target || this.gl.ARRAY_BUFFER), buf);\r\n    this.gl.bufferData((target || this.gl.ARRAY_BUFFER), new (klass || Float32Array)(data), this.gl.STATIC_DRAW);\r\n\r\n    return buf;\r\n  }\r\n\r\n  _createTexture(data, width, height, channels, options = {}) {\r\n    const texture = this.gl.createTexture();\r\n\r\n    let internalFormat, format;\r\n\r\n    switch (channels) {\r\n      case 1:\r\n        internalFormat = this.gl.R32F;\r\n        format = this.gl.RED;\r\n        break;\r\n      case 2:\r\n        internalFormat = this.gl.RG32F;\r\n        format = this.gl.RG;\r\n        break;\r\n      case 3:\r\n        internalFormat = this.gl.RGB32F;\r\n        format = this.gl.RGB;\r\n        break;\r\n      case 4:\r\n        internalFormat = this.gl.RGBA32F;\r\n        format = this.gl.RGBA;\r\n        break;\r\n      default:\r\n        throw(\"Texture channels must between 1 and 4.\");\r\n    }\r\n\r\n    const target = options.textureType == '3D' ? this.gl.TEXTURE_3D : options.textureType == '2DArray' ? this.gl.TEXTURE_2D_ARRAY : this.gl.TEXTURE_2D;\r\n\r\n    this.gl.bindTexture(target, texture);\r\n    this.gl.texParameteri(target, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\r\n    this.gl.texParameteri(target, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\r\n    this.gl.texParameteri(target, this.gl.TEXTURE_WRAP_R, this.gl.CLAMP_TO_EDGE);\r\n    this.gl.texParameteri(target, this.gl.TEXTURE_MIN_FILTER, options.filter == 'linear' ? this.gl.LINEAR : this.gl.NEAREST);\r\n    this.gl.texParameteri(target, this.gl.TEXTURE_MAG_FILTER, options.filter == 'linear' ? this.gl.LINEAR : this.gl.NEAREST);\r\n\r\n    if (options.textureType == '3D' || options.textureType == '2DArray') {\r\n      this.gl.texImage3D(target, 0, internalFormat, width, height, options.depth, 0, format, this.gl.FLOAT, data);\r\n    } else {\r\n      this.gl.texImage2D(target, 0, internalFormat, width, height, 0, format, this.gl.FLOAT, data);\r\n    }\r\n\r\n    this.gl.bindTexture(target, null);\r\n\r\n    return texture;\r\n  }\r\n}\r\n\n;// CONCATENATED MODULE: ./js/physics/Car.js\nclass Car {\r\n\r\n\tconstructor( x = 0, y = 0, rotation = 0 ) {\r\n\r\n\t\tthis.setPose( x, y, rotation );\r\n\r\n\t\tthis.score = 100;\r\n    \tthis.lastTimeLogger = new Date().getTime();\r\n\r\n\t}\r\n\r\n  static getFrontAxlePosition(pos, rot) {\r\n    return THREE.Vector2.fromAngle(rot).multiplyScalar(Car.WHEEL_BASE).add(pos);\r\n  }\r\n\r\n  static getFakeAxlePosition(pos, rot) {\r\n    return Car.frontToRearAxlePosition(pos, rot);\r\n  }\r\n\r\n  static centerToRearAxlePosition(pos, rot) {\r\n    return THREE.Vector2.fromAngle(rot).multiplyScalar(Car.REAR_AXLE_POS).add(pos);\r\n  }\r\n\r\n  static frontToRearAxlePosition(pos, rot) {\r\n    return THREE.Vector2.fromAngle(rot).multiplyScalar(-Car.WHEEL_BASE).add(pos);\r\n  }\r\n\r\n  get pose() {\r\n    return { pos: this.rearAxlePosition.clone(), rot: this.rotation, velocity: this.velocity, curv: this.curvature, dCurv: this.dCurv, ddCurv: this.ddCurv };\r\n  }\r\n\r\n  get curvature() {\r\n    return Math.tan(this.wheelAngle) / Car.WHEEL_BASE;\r\n  }\r\n\r\n  get rearAxlePosition() {\r\n    const { x, y } = this.position;\r\n    const rot = this.rotation;\r\n    return new THREE.Vector2(x + Math.cos(rot) * Car.REAR_AXLE_POS, y + Math.sin(rot) * Car.REAR_AXLE_POS);\r\n  }\r\n\r\n  get frontAxlePosition() {\r\n    const { x, y } = this.position;\r\n    const rot = this.rotation;\r\n    return new THREE.Vector2(x + Math.cos(rot) * Car.FRONT_AXLE_POS, y + Math.sin(rot) * Car.FRONT_AXLE_POS);\r\n  }\r\n\r\n  setPose(x, y, rotation) {\r\n    // Translate so that x and y become the center of the vehicle (instead of the center of the rear axle)\r\n    x -= Car.REAR_AXLE_POS * Math.cos(rotation);\r\n    y -= Car.REAR_AXLE_POS * Math.sin(rotation);\r\n\r\n    this.position = new THREE.Vector2(x, y);\r\n    this.rotation = Math.wrapAngle(rotation);\r\n    this.velocity = 0;\r\n    this.acceleration = 0;\r\n    this.wheelAngle = 0;\r\n    this.wheelAngularVelocity = 0;\r\n    this.dCurv = 0; // derivative with respect to arc length\r\n    this.ddCurv = 0; // derivative with respect to arc length\r\n  }\r\n\r\n\tstep ( delta ) {\r\n\r\n\t\tconst curvPrev = this.curvature;\r\n\t\tconst dCurvPrev = this.dCurv;\r\n\r\n\t\tconst drag = ( 0.5 * Car.DRAG_COEFF * Car.FRONTAL_AREA * Car.DENSITY_OF_AIR * Math.abs( this.velocity ) + Car.ROLL_RESIST ) * -this.velocity;\r\n\t\tthis.velocity += ( this.acceleration + drag / Car.MASS ) * delta;\r\n\r\n\t\tconst velocitySq = this.velocity * this.velocity;\r\n\t\tconst maxWheelAngle = Math.clamp( Math.atan( Car.MAX_LATERAL_ACCEL * Car.WHEEL_BASE / velocitySq ), 0.07, Car.MAX_WHEEL_ANGLE );\r\n\t\tthis.wheelAngle = Math.clamp( Math.wrapAngle( this.wheelAngle + this.wheelAngularVelocity * delta ), -maxWheelAngle, maxWheelAngle);\r\n\r\n\t\tconst angularVelocity = this.velocity * this.curvature;\r\n\t\tthis.rotation = Math.wrapAngle( this.rotation + angularVelocity * delta );\r\n\r\n\t\tconst dist = this.velocity * delta;\r\n\t\tthis.position = THREE.Vector2.fromAngle( this.rotation ).multiplyScalar( dist ).add( this.position );\r\n\r\n\t\tthis.dCurv = dist > 0.1 ? ( this.curvature - curvPrev ) / dist : 0;\r\n\t\tthis.ddCurv = dist > 0.1 ? ( this.dCurv - dCurvPrev ) / dist : 0;\r\n\r\n\t}\r\n\r\n\tupdate ( controls, delta ) {\r\n\r\n\t\tconst gas = Math.clamp( controls.gas, -1, +1 );\r\n\t\tconst brake = Math.clamp( controls.brake, 0, 1 );\r\n\t\tconst steer = Math.clamp( controls.steer, -1, +1 );\r\n\r\n\t\tif ( brake > 0 ) {\r\n\r\n\t\t\tthis.acceleration = -Math.sign( this.velocity ) * Car.MAX_BRAKE_DECEL * brake;\r\n\t\t\tconst newVelocity = this.velocity + this.acceleration * delta;\r\n\r\n\t\t\t// If applying the braking deceleration at the next step would cause the velocity\r\n\t\t\t// to change directions, then just set the car as stopped.\r\n\t\t\tif ( Math.sign( newVelocity ) != Math.sign( this.velocity ) ) {\r\n\r\n\t\t\t\tthis.velocity = 0;\r\n\t\t\t\tthis.acceleration = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.acceleration = Car.MAX_GAS_ACCEL * gas;\r\n\r\n\t\t}\r\n\r\n\t\tif ( steer != 0 ) {\r\n\r\n\t\t\tthis.wheelAngularVelocity = steer * Car.MAX_STEER_SPEED;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.wheelAngularVelocity = Math.clamp( -this.wheelAngle / Car.MAX_WHEEL_ANGLE * this.velocity * this.velocity * delta, -Car.MAX_STEER_SPEED, Car.MAX_STEER_SPEED );\r\n\r\n\t\t}\r\n\r\n\t\tif ( new Date().getTime() - this.lastTimeLogger > 5000 ) {\r\n\r\n\t\t\tthis.lastTimeLogger = new Date().getTime();\r\n\t\t\tconsole.log( this );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nCar.HALF_CAR_LENGTH = 2.5; // meters\r\nCar.HALF_CAR_WIDTH = 1; // meters\r\nCar.HALF_WHEEL_LENGTH = 0.38; // meters\r\nCar.HALF_WHEEL_WIDTH = 0.12; // meters\r\nCar.MAX_WHEEL_ANGLE = 32 / 180 * Math.PI; // radians\r\nCar.MASS = 1600; // kg\r\nCar.DRAG_COEFF = 0.7;\r\nCar.DENSITY_OF_AIR = 1.8580608; // (kg/m^3)\r\nCar.FRONTAL_AREA = 1.85; // m^2\r\nCar.ROLL_RESIST = 0;\r\nCar.MAX_STEER_SPEED = 0.8;//1.2; // Radians per second\r\nCar.MAX_GAS_ACCEL = 3.5; // m / s^2\r\nCar.MAX_BRAKE_DECEL = 6.5; // m / s^2\r\nCar.WHEEL_LATERAL_POS = 0.843; // meters\r\nCar.FRONT_AXLE_POS = 1.6; // meters\r\nCar.REAR_AXLE_POS = -1.43; // meters\r\nCar.WHEEL_BASE = Car.FRONT_AXLE_POS - Car.REAR_AXLE_POS; // meters\r\nCar.MAX_LATERAL_ACCEL = 9.81; // m / s^2\r\n\n;// CONCATENATED MODULE: ./js/autonomy/path-planning/CubicPath.js\nconst SIMPSONS_INTERVALS = 8;\r\nconst NEWTON_ITERATIONS = 16;\r\nconst RELAXATION_ITERATIONS = 32;\r\nconst CONVERGENCE_ERROR = 0.01;\r\n\r\nconst jacobian = new THREE.Matrix3();\r\nconst invJacobian = new THREE.Matrix3();\r\n\r\n// Alternate reference implementation: https://github.com/ApolloAuto/apollo/blob/master/modules/planning/math/spiral_curve/cubic_spiral_curve.cc\r\nclass CubicPath {\r\n  constructor(start, end, params = null) {\r\n    this.start = Object.assign({}, start);\r\n    this.end = Object.assign({}, end);\r\n\r\n    if (start.pos) {\r\n      this.start.x = start.pos.x;\r\n      this.start.y = start.pos.y\r\n    }\r\n\r\n    if (end.pos) {\r\n      this.end.x = end.pos.x;\r\n      this.end.y = end.pos.y\r\n    }\r\n\r\n    const diffX = this.end.x - this.start.x;\r\n    const diffY = this.end.y - this.start.y;\r\n    const sinRot = Math.sin(this.start.rot);\r\n    const cosRot = Math.cos(this.start.rot);\r\n\r\n    this.goal = {\r\n      x: cosRot * diffX + sinRot * diffY,\r\n      y: -sinRot * diffX + cosRot * diffY,\r\n      rot: Math.wrapAngle(this.end.rot - this.start.rot),\r\n      curv: this.end.curv\r\n    };\r\n\r\n    if (params)\r\n      this.params = Object.assign({}, params, { p0: this.start.curv, p3: this.end.curv });\r\n    else\r\n      this.guessInitialParams();\r\n\r\n    this.converged = false;\r\n  }\r\n\r\n  guessInitialParams() {\r\n    const originalGoal = this.goal;\r\n    const dStartCurv = this.start.curv / RELAXATION_ITERATIONS;\r\n    const dGoalY = originalGoal.y / RELAXATION_ITERATIONS;\r\n    const dGoalRot = originalGoal.rot / RELAXATION_ITERATIONS;\r\n    const dGoalCurv = originalGoal.curv / RELAXATION_ITERATIONS;\r\n\r\n    this.goal = {\r\n      x: originalGoal.x,\r\n      y: 0,\r\n      rot: 0,\r\n      curv: 0\r\n    };\r\n\r\n    this.params = {\r\n      p0: 0,\r\n      p1: 0,\r\n      p2: 0,\r\n      p3: 0,\r\n      sG: originalGoal.x\r\n    };\r\n\r\n    for (let i = 0; i < RELAXATION_ITERATIONS; i++) {\r\n      this.params.p0 += dStartCurv;\r\n      this.params.p3 += dGoalCurv;\r\n      this.goal.y += dGoalY;\r\n      this.goal.rot += dGoalRot;\r\n      this.goal.curv += dGoalCurv;\r\n\r\n      this.iterate();\r\n    }\r\n\r\n    this.goal = originalGoal;\r\n  }\r\n\r\n  optimize() {\r\n    for (let i = 0; i < NEWTON_ITERATIONS; i++) {\r\n      if (this.iterate()) {\r\n        this.converged = true;\r\n        return true;\r\n      }\r\n    }\r\n\r\n    this.converged = false;\r\n    return false;\r\n  }\r\n\r\n  iterate() {\r\n    const { p0, p1, p2, p3, sG } = this.params;\r\n\r\n    const ds = sG / SIMPSONS_INTERVALS;\r\n    const sG_2 = sG * sG;\r\n    const sG_3 = sG_2 * sG;\r\n\r\n    let dX_p1 = 0;\r\n    let dX_p2 = 0;\r\n    let dX_sG = 0;\r\n    let dY_p1 = 0;\r\n    let dY_p2 = 0;\r\n    let dY_sG = 0;\r\n    let guessX = 0;\r\n    let guessY = 0;\r\n\r\n    let theta, cosTheta, sinTheta, dT_p1, dT_p2, dT_sG;\r\n\r\n    for (let i = 0, s = 0; i <= SIMPSONS_INTERVALS; i++, s += ds) {\r\n      const coeff = i == 0 || i == SIMPSONS_INTERVALS ? 1 : i % 2 == 0 ? 2 : 4;\r\n\r\n      const a = p0;\r\n      const b = (-5.5 * p0 + 9 * p1 - 4.5 * p2 + p3) / sG;\r\n      const c = (9 * p0 - 22.5 * p1 + 18 * p2 - 4.5 * p3) / sG_2;\r\n      const d = (-4.5 * (p0 - 3 * p1 + 3 * p2 - p3)) / sG_3;\r\n\r\n      theta = (((d * s / 4 + c / 3) * s + b / 2) * s + a) * s;\r\n      cosTheta = Math.cos(theta);\r\n      sinTheta = Math.sin(theta);\r\n\r\n      const s_sG = s / sG;\r\n      dT_p1 = ((3.375 * s_sG - 7.5) * s_sG + 4.5) * s_sG * s;\r\n      dT_p2 = ((-3.375 * s_sG + 6) * s_sG - 2.25) * s_sG * s;\r\n      dT_sG = ((3.375 * (p0 - 3 * p1 + 3 * p2 - p3) * s_sG - 3 * (2 * p0 - 5 * p1 + 4 * p2 - p3)) * s_sG + 0.25 * (11 * p0 - 18 * p1 + 9 * p2 - 2 * p3)) * s_sG * s_sG;\r\n\r\n      dX_p1 -= coeff * sinTheta * dT_p1;\r\n      dX_p2 -= coeff * sinTheta * dT_p2;\r\n      dX_sG -= coeff * sinTheta * dT_sG;\r\n\r\n      dY_p1 += coeff * cosTheta * dT_p1;\r\n      dY_p2 += coeff * cosTheta * dT_p2;\r\n      dY_sG += coeff * cosTheta * dT_sG;\r\n\r\n      guessX += coeff * cosTheta;\r\n      guessY += coeff * sinTheta;\r\n    }\r\n\r\n    // After the Simpson's integration loop, `theta`, `cosTheta`, `sinTheta`,\r\n    // `dT_p1`, `dT_p2`, and `dT_sG` hold the appropriate values for `sG`.\r\n\r\n    const hOver3 = sG / SIMPSONS_INTERVALS / 3;\r\n\r\n    const deltaX = this.goal.x - guessX * hOver3;\r\n    const deltaY = this.goal.y - guessY * hOver3;\r\n    const deltaRot = Math.wrapAngle(this.goal.rot - theta);\r\n\r\n    if (Math.abs(deltaX) + Math.abs(deltaY) + Math.abs(deltaRot) < CONVERGENCE_ERROR)\r\n      return true;\r\n\r\n    jacobian.set(\r\n      dX_p1 * hOver3, dX_p2 * hOver3, cosTheta + dX_sG * hOver3,\r\n      dY_p1 * hOver3, dY_p2 * hOver3, sinTheta + dY_sG * hOver3,\r\n      dT_p1, dT_p2, dT_sG\r\n    );\r\n\r\n    const [m11, m21, m31, m12, m22, m32, m13, m23, m33] = invJacobian.getInverse(jacobian).elements;\r\n\r\n    this.params.p1 += m11 * deltaX + m12 * deltaY + m13 * deltaRot;\r\n    this.params.p2 += m21 * deltaX + m22 * deltaY + m23 * deltaRot;\r\n    this.params.sG += m31 * deltaX + m32 * deltaY + m33 * deltaRot;\r\n\r\n    return false;\r\n  }\r\n\r\n  buildPath(num) {\r\n    const { p0, p1, p2, p3, sG } = this.params;\r\n\r\n    const sG_2 = sG * sG;\r\n    const sG_3 = sG_2 * sG;\r\n\r\n    const a = p0;\r\n    const b = (-5.5 * p0 + 9 * p1 - 4.5 * p2 + p3) / sG;\r\n    const c = (9 * p0 - 22.5 * p1 + 18 * p2 - 4.5 * p3) / sG_2;\r\n    const d = (-4.5 * (p0 - 3 * p1 + 3 * p2 - p3)) / sG_3;\r\n\r\n    const path = [{ pos: new THREE.Vector2(this.start.x, this.start.y), rot: this.start.rot, curv: this.start.curv }];\r\n    const ds = sG / (num - 1);\r\n    let s = ds;\r\n    let dx = 0;\r\n    let dy = 0;\r\n    let prevCosRot = Math.cos(path[0].rot);\r\n    let prevSinRot = Math.sin(path[0].rot);\r\n\r\n    for (let i = 1; i < num - 1; i++) {\r\n      const rot = (((d * s / 4 + c / 3) * s + b / 2) * s + a) * s + this.start.rot;\r\n      const curv = ((d * s + c) * s + b) * s + a;\r\n      const cosRot = Math.cos(rot);\r\n      const sinRot = Math.sin(rot);\r\n\r\n      dx = dx * (i - 1) / i + (cosRot + prevCosRot) / (2 * i);\r\n      dy = dy * (i - 1) / i + (sinRot + prevSinRot) / (2 * i);\r\n\r\n      path.push({ pos: new THREE.Vector2(s * dx + this.start.x, s * dy + this.start.y), rot: rot, curv: curv });\r\n\r\n      s += ds;\r\n      prevCosRot = cosRot;\r\n      prevSinRot = sinRot;\r\n    }\r\n\r\n    path.push({ pos: new THREE.Vector2(this.end.x, this.end.y), rot: this.end.rot, curv: this.end.curv });\r\n\r\n    return path;\r\n  }\r\n}\r\n\n;// CONCATENATED MODULE: ./js/autonomy/path-planning/QuinticPath.js\nclass QuinticPath {\r\n  constructor(start, end, params) {\r\n    this.start = Object.assign({}, start);\r\n    this.end = Object.assign({}, end);\r\n\r\n    if (start.pos) {\r\n      this.start.x = start.pos.x;\r\n      this.start.y = start.pos.y\r\n    }\r\n\r\n    if (end.pos) {\r\n      this.end.x = end.pos.x;\r\n      this.end.y = end.pos.y\r\n    }\r\n\r\n    const diffX = this.end.x - this.start.x;\r\n    const diffY = this.end.y - this.start.y;\r\n    const sinRot = Math.sin(this.start.rot);\r\n    const cosRot = Math.cos(this.start.rot);\r\n\r\n    this.goal = {\r\n      x: cosRot * diffX + sinRot * diffY,\r\n      y: -sinRot * diffX + cosRot * diffY,\r\n      rot: Math.wrapAngle(this.end.rot - this.start.rot),\r\n      curv: this.end.curv\r\n    };\r\n\r\n    this.params = Object.assign({}, params, { p0: this.start.curv, p1: this.start.dCurv || 0, p2: this.start.ddCurv || 0, p5: this.end.curv });\r\n  }\r\n\r\n  buildPath(num) {\r\n    const { p0, p1, p2, p3, p4, p5, sG } = this.params;\r\n\r\n    const sG_2 = sG * sG;\r\n    const sG_3 = sG_2 * sG;\r\n\r\n    const a = p0;\r\n    const b = p1;\r\n    const c = p2 / 2.0;\r\n    const d = (-71.875 * p0 + 81.0 * p3 - 10.125 * p4 + p5 - 21.25 * p1 * sG - 2.75 * p2 * sG_2) / sG_3;\r\n    const e = (166.5 * p0 - 202.5 * p3 + 40.5 * p4 - 4.5 * p5 + 45.0 * p1 * sG + 4.5 * p2 * sG_2) / (sG_2 * sG_2);\r\n    const f = (-95.625 * p0 + 121.5 * p3 - 30.375 * p4 + 4.5 * p5 - 24.75 * p1 * sG - 2.25 * p2 * sG_2) / (sG_2 * sG_3);\r\n\r\n    const path = [{ pos: new THREE.Vector2(this.start.x, this.start.y), rot: this.start.rot, curv: this.start.curv }];\r\n    const ds = sG / (num - 1);\r\n    let s = ds;\r\n    let dx = 0;\r\n    let dy = 0;\r\n    let prevCosRot = Math.cos(path[0].rot);\r\n    let prevSinRot = Math.sin(path[0].rot);\r\n\r\n    for (let i = 1; i < num - 1; i++) {\r\n      const rot = (((((f * s / 6.0 + e / 5.0) * s + d / 4.0) * s + c / 3.0) * s + b / 2.0) * s + a) * s + this.start.rot;\r\n      const curv = ((((f * s + e) * s + d) * s + c) * s + b) * s + a;\r\n      const cosRot = Math.cos(rot);\r\n      const sinRot = Math.sin(rot);\r\n\r\n      dx = dx * (i - 1) / i + (cosRot + prevCosRot) / (2 * i);\r\n      dy = dy * (i - 1) / i + (sinRot + prevSinRot) / (2 * i);\r\n\r\n      path.push({ pos: new THREE.Vector2(s * dx + this.start.x, s * dy + this.start.y), rot: rot, curv: curv });\r\n\r\n      s += ds;\r\n      prevCosRot = cosRot;\r\n      prevSinRot = sinRot;\r\n    }\r\n\r\n    path.push({ pos: new THREE.Vector2(this.end.x, this.end.y), rot: this.end.rot, curv: this.end.curv });\r\n\r\n    return path;\r\n  }\r\n}\r\n\n;// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/xyObstacleGrid.js\nconst OBSTACLE_VERTEX_SHADER = `#version 300 es\r\nuniform mat3 xform;\r\nin vec2 position;\r\n\r\nvoid main(void) {\r\n  gl_Position = vec4((xform * vec3(position, 1)).xy, 0, 1);\r\n}\r\n`;\r\n\r\nconst OBSTACLE_KERNEL = `\r\n  vec4 kernel() {\r\n    return vec4(1, 0, 0, 1);\r\n  }\r\n`;\r\n\r\nlet obstacleVertices;\r\nlet obstacleXform;\r\n\r\n// Draw obstacle triangles to XY-space obstacle grid\r\n/* harmony default export */ const xyObstacleGrid = ({\r\n  setUp() {\r\n    return {\r\n      kernel: OBSTACLE_KERNEL,\r\n      vertexShader: OBSTACLE_VERTEX_SHADER,\r\n      output: { name: 'xyObstacleGrid' },\r\n      draw: (gpgpu, program) => {\r\n        const gl = gpgpu.gl;\r\n\r\n        gl.clearColor(0, 0, 0, 0);\r\n        gl.clear(gl.COLOR_BUFFER_BIT);\r\n\r\n        if (obstacleVertices.length > 0) {\r\n          const buf = gl.createBuffer();\r\n\r\n          gl.bindBuffer(gl.ARRAY_BUFFER, buf);\r\n          gl.bufferData(gl.ARRAY_BUFFER, obstacleVertices, gl.STATIC_DRAW);\r\n          gl.enableVertexAttribArray(program.positionLocation);\r\n          gl.vertexAttribPointer(program.positionLocation, 2, gl.FLOAT, false, 0, 0);\r\n\r\n          const xformLocation = gl.getUniformLocation(program.glProgram, 'xform');\r\n          gl.uniformMatrix3fv(xformLocation, false, obstacleXform.elements);\r\n\r\n          gl.drawArrays(gl.TRIANGLES, 0, obstacleVertices.length / 2);\r\n\r\n          gl.deleteBuffer(buf);\r\n        }\r\n      }\r\n    };\r\n  },\r\n\r\n  update(config, xyWidth, xyHeight, xyCenterPoint, vehicleXform, obstacles) {\r\n    obstacleVertices = new Float32Array(Array.prototype.concat.apply([], obstacles.map(o => o.vertices)));\r\n\r\n    const translate = new THREE.Matrix3();\r\n    translate.set(\r\n      1, 0, -xyCenterPoint.x,\r\n      0, 1, -xyCenterPoint.y,\r\n      0, 0, 1\r\n    );\r\n\r\n    const scale = new THREE.Matrix3();\r\n    scale.set(\r\n      2 / (xyWidth * config.xyGridCellSize), 0, 0,\r\n      0, 2 / (xyHeight * config.xyGridCellSize), 0,\r\n      0, 0, 1\r\n    );\r\n\r\n    obstacleXform = scale.multiply(translate).multiply(vehicleXform);\r\n\r\n    return {\r\n      width: xyWidth,\r\n      height: xyHeight\r\n    }\r\n  }\r\n});\r\n\n;// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/slObstacleGrid.js\nconst SL_OBSTACLE_KERNEL = `\r\n\r\nvec4 kernel() {\r\n  float centerlineWidth = float(textureSize(centerline, 0).x);\r\n\r\n  vec2 sl = (kernelPosition - 0.5) * vec2(kernelSize) * vec2(slGridCellSize) + slCenterPoint;\r\n  float centerlineCoord = sl.x / centerlineStationInterval / centerlineWidth * (centerlineWidth - 1.0) / centerlineWidth + (0.5 / centerlineWidth);\r\n  if (centerlineCoord < 0.0 || centerlineCoord > 1.0) return vec4(0);\r\n\r\n  vec3 centerlineSample = texture(centerline, vec2(centerlineCoord, 0)).xyz;\r\n  float perpindicular = centerlineSample.z + radians(90.0);\r\n  vec2 xy = centerlineSample.xy + sl.yy * vec2(cos(perpindicular), sin(perpindicular));\r\n\r\n  vec2 xyTexCoords = (xy - xyCenterPoint) / vec2(textureSize(xyObstacleGrid, 0)) / vec2(xyGridCellSize) + 0.5;\r\n  return texture(xyObstacleGrid, xyTexCoords);\r\n}\r\n\r\n`;\r\n\r\n// Convert XY-space obstacle grid to SL-space obstacle grid\r\n/* harmony default export */ const slObstacleGrid = ({\r\n  setUp() {\r\n    return {\r\n      kernel: SL_OBSTACLE_KERNEL,\r\n      output: { name: 'slObstacleGrid' },\r\n      uniforms: {\r\n        xyObstacleGrid: { type: 'outputTexture' },\r\n        slGridCellSize: { type: 'float' },\r\n        xyGridCellSize: { type: 'float' },\r\n        slCenterPoint: { type: 'vec2' },\r\n        xyCenterPoint: { type: 'vec2' },\r\n        centerlineStationInterval: { type: 'float' },\r\n        centerline: { type: 'sharedTexture' }\r\n      }\r\n    }\r\n  },\r\n\r\n  update(config, slWidth, slHeight, slCenterPoint, xyCenterPoint) {\r\n    return {\r\n      width: slWidth,\r\n      height: slHeight,\r\n      uniforms: {\r\n        slGridCellSize: config.slGridCellSize,\r\n        xyGridCellSize: config.xyGridCellSize,\r\n        slCenterPoint: [slCenterPoint.x, slCenterPoint.y],\r\n        xyCenterPoint: [xyCenterPoint.x, xyCenterPoint.y],\r\n        centerlineStationInterval: config.centerlineStationInterval\r\n      }\r\n    }\r\n  }\r\n});\r\n\n;// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/slObstacleGridDilation.js\nconst SL_OBSTACLE_DILATION_KERNEL = `\r\n\r\n// TODO: test performance of returning early if non-zero pixel found\r\nvec4 kernel() {\r\n  float val = 0.0;\r\n\r\n  for (int d = 0; d <= collisionDilation; d++) {\r\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(d)).r);\r\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(-d)).r);\r\n  }\r\n\r\n  for (int d = collisionDilation + 1; d <= collisionDilation + hazardDilation; d++) {\r\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(d)).r * 0.5);\r\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(-d)).r * 0.5);\r\n  }\r\n\r\n  val = max(val, step(0.1, val) * 0.5);\r\n\r\n  return vec4(val, 0, 0, 1);\r\n}\r\n\r\n`;\r\n\r\n/* harmony default export */ const slObstacleGridDilation = ({\r\n  setUp() {\r\n    return [\r\n      { // SL-space obstacle grid S dilation\r\n        kernel: SL_OBSTACLE_DILATION_KERNEL,\r\n        output: { name: 'slObstacleGridStationDilated' },\r\n        uniforms: {\r\n          slObstacleGrid: { type: 'outputTexture' },\r\n          delta: { type: 'vec2' },\r\n          collisionDilation: { type: 'int' },\r\n          hazardDilation: { type: 'int' }\r\n        }\r\n      },\r\n      { // SL-space obstacle grid L dilation\r\n        kernel: SL_OBSTACLE_DILATION_KERNEL,\r\n        output: { name: 'slObstacleGridDilated' },\r\n        uniforms: {\r\n          slObstacleGrid: { type: 'outputTexture', name: 'slObstacleGridStationDilated' },\r\n          delta: { type: 'vec2' },\r\n          collisionDilation: { type: 'int' },\r\n          hazardDilation: { type: 'int' }\r\n        }\r\n      }\r\n    ];\r\n  },\r\n\r\n  update(config, slWidth, slHeight) {\r\n    return [\r\n      { // SL-space obstacle grid S dilation\r\n        width: slWidth,\r\n        height: slHeight,\r\n        uniforms: {\r\n          delta: [1 / slWidth, 0],\r\n          collisionDilation: Math.ceil(config.collisionDilationS / config.slGridCellSize),\r\n          hazardDilation: Math.ceil(config.hazardDilationS / config.slGridCellSize)\r\n        }\r\n      },\r\n      { // SL-space obstacle grid L dilation\r\n        width: slWidth,\r\n        height: slHeight,\r\n        uniforms: {\r\n          delta: [0, 1 / slHeight],\r\n          collisionDilation: Math.ceil(config.collisionDilationL / config.slGridCellSize),\r\n          hazardDilation: Math.ceil(config.hazardDilationL / config.slGridCellSize)\r\n        }\r\n      }\r\n    ];\r\n  }\r\n});\r\n\n;// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/slDynamicObstacleGrid.js\nconst DYNAMIC_OBSTACLE_VERTEX_SHADER = `#version 300 es\r\nuniform mat3 xform;\r\nin vec3 position;\r\nout float color;\r\n\r\nvoid main(void) {\r\n  gl_Position = vec4((xform * vec3(position.xy, 1)).xy, position.z, 1);\r\n\r\n  // The z coordinate is 0.25 for collision zone and 0.75 for hazard zone,\r\n  // so that the collision zone is drawn on top.\r\n  // Convert this to 1.0 for collision zone, 0.5 for hazard zone\r\n  color = (1.0 - step(0.5, position.z)) * 0.5 + 0.5;\r\n}\r\n`;\r\n\r\nconst DYNAMIC_OBSTACLE_KERNEL = `\r\n  in float color;\r\n\r\n  vec4 kernel() {\r\n    return vec4(color, 0, 0, 1);\r\n  }\r\n`;\r\n\r\nlet slDynamicObstacleGrid_obstacleVertices;\r\nlet slDynamicObstacleGrid_obstacleXform;\r\nconst numDynamicFrames = 20;\r\n\r\n// Draw dynamic obstacle triangles to SL-space obstacle grid\r\n/* harmony default export */ const slDynamicObstacleGrid = ({\r\n  setUp() {\r\n    return {\r\n      kernel: DYNAMIC_OBSTACLE_KERNEL,\r\n      vertexShader: DYNAMIC_OBSTACLE_VERTEX_SHADER,\r\n      output: { name: 'slDynamicObstacleGrid', textureType: '2DArray', depth: numDynamicFrames },\r\n      draw: (gpgpu, program) => {\r\n        const gl = gpgpu.gl;\r\n\r\n        gl.enable(gl.DEPTH_TEST);\r\n\r\n        const renderbuffer = gl.createRenderbuffer();\r\n        gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);\r\n        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, program.inputWidth, program.inputHeight);\r\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);\r\n\r\n        for (let frame = 0; frame < numDynamicFrames; frame++) {\r\n          gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, program.outputTexture, 0, frame);\r\n          const frameBufferStatus = (gl.checkFramebufferStatus(gl.FRAMEBUFFER) == gl.FRAMEBUFFER_COMPLETE);\r\n          if (!frameBufferStatus)\r\n            throw new Error('Error attaching float texture to framebuffer. Your device is probably incompatible.');\r\n\r\n          gl.clearColor(0, 0, 0, 0);\r\n          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n          if (slDynamicObstacleGrid_obstacleVertices[frame].length > 0) {\r\n            const buf = gl.createBuffer();\r\n\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, buf);\r\n            gl.bufferData(gl.ARRAY_BUFFER, slDynamicObstacleGrid_obstacleVertices[frame], gl.STATIC_DRAW);\r\n            gl.enableVertexAttribArray(program.positionLocation);\r\n            gl.vertexAttribPointer(program.positionLocation, 3, gl.FLOAT, false, 0, 0);\r\n\r\n            const xformLocation = gl.getUniformLocation(program.glProgram, 'xform');\r\n            gl.uniformMatrix3fv(xformLocation, false, slDynamicObstacleGrid_obstacleXform.elements);\r\n\r\n            gl.drawArrays(gl.TRIANGLES, 0, slDynamicObstacleGrid_obstacleVertices[frame].length / 3);\r\n\r\n            if (frame == 0) {\r\n              const obstacleGrid = new Float32Array(program.inputWidth * program.inputHeight * 4);\r\n              gl.readPixels(0, 0, program.inputWidth, program.inputHeight, gl.RGBA, gl.FLOAT, obstacleGrid);\r\n              gpgpu._dynamicObstacleGrid = obstacleGrid;\r\n            }\r\n\r\n            gl.deleteBuffer(buf);\r\n          }\r\n        }\r\n\r\n        gl.bindRenderbuffer(gl.RENDERBUFFER, null);\r\n        gl.deleteRenderbuffer(renderbuffer);\r\n        gl.disable(gl.DEPTH_TEST);\r\n      }\r\n    };\r\n  },\r\n\r\n  update(config, slWidth, slHeight, slCenterPoint, vehicleStation, startTime, dynamicFrameTime, dynamicObstacles) {\r\n    slDynamicObstacleGrid_obstacleVertices = [];\r\n\r\n    let time = startTime;\r\n    for (let frame = 0; frame < numDynamicFrames; frame++) {\r\n      const vertices = Array.prototype.concat.apply([], dynamicObstacles.map(o => o.verticesInTimeRange(time, time + dynamicFrameTime, config)));\r\n      slDynamicObstacleGrid_obstacleVertices.push(new Float32Array(vertices));\r\n      time += dynamicFrameTime;\r\n    }\r\n\r\n    const translate = new THREE.Matrix3();\r\n    translate.set(\r\n      1, 0, -slCenterPoint.x - vehicleStation,\r\n      0, 1, -slCenterPoint.y,\r\n      0, 0, 1\r\n    );\r\n\r\n    const scale = new THREE.Matrix3();\r\n    scale.set(\r\n      2 / (slWidth * config.slGridCellSize), 0, 0,\r\n      0, 2 / (slHeight * config.slGridCellSize), 0,\r\n      0, 0, 1\r\n    );\r\n\r\n    slDynamicObstacleGrid_obstacleXform = scale.multiply(translate);\r\n\r\n    return {\r\n      width: slWidth,\r\n      height: slHeight\r\n    }\r\n  }\r\n});\r\n\n;// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/xyslMap.js\nconst XYSL_MAP_KERNEL = `\r\n\r\nvec4 kernel() {\r\n  vec2 xy = (kernelPosition - 0.5) * vec2(kernelSize) * vec2(xyGridCellSize) + xyCenterPoint;\r\n\r\n  int numSamples = textureSize(centerline, 0).x;\r\n  int closest = 0;\r\n  float closestDist = distance(xy, texelFetch(centerline, ivec2(0, 0), 0).xy);\r\n  for (int i = 1; i < numSamples; i++) {\r\n    float dist = distance(xy, texelFetch(centerline, ivec2(i, 0), 0).xy);\r\n    if (dist < closestDist) {\r\n      closestDist = dist;\r\n      closest = i;\r\n    }\r\n  }\r\n\r\n  vec2 closestPos = texelFetch(centerline, ivec2(closest, 0), 0).xy;\r\n  vec2 prev, next;\r\n  int prevIndex, nextIndex;\r\n\r\n  if (closest == 0) {\r\n    prevIndex = 0;\r\n    nextIndex = 1;\r\n    prev = closestPos;\r\n    next = texelFetch(centerline, ivec2(1, 0), 0).xy;\r\n  } else if (closest == numSamples - 1) {\r\n    prevIndex = closest - 1;\r\n    nextIndex = closest;\r\n    prev = texelFetch(centerline, ivec2(prevIndex, 0), 0).xy;\r\n    next = closestPos;\r\n  } else {\r\n    vec2 before = texelFetch(centerline, ivec2(closest - 1, 0), 0).xy;\r\n    vec2 after = texelFetch(centerline, ivec2(closest + 1, 0), 0).xy;\r\n\r\n    if (distance(before, xy) < distance(after, xy)) {\r\n      prevIndex = closest - 1;\r\n      nextIndex = closest;\r\n      prev = before;\r\n      next = closestPos;\r\n    } else {\r\n      prevIndex = closest;\r\n      nextIndex = closest + 1;\r\n      prev = closestPos;\r\n      next = after;\r\n    }\r\n  }\r\n\r\n  float dist = distance(prev, next);\r\n  float progress = clamp(dot(xy - prev, next - prev) / dist / dist, 0.0, 1.0);\r\n  vec2 projectedPos = (next - prev) * vec2(progress) + prev;\r\n\r\n  return vec4(\r\n    (float(prevIndex) + progress) * centerlineStationInterval,\r\n    sign(determinant(mat2(next - prev, xy - prev))) * distance(xy, projectedPos),\r\n    0,\r\n    0\r\n  );\r\n}\r\n\r\n`;\r\n\r\n// Build XY-SL map\r\n/* harmony default export */ const xyslMap = ({\r\n  setUp() {\r\n    return {\r\n      kernel: XYSL_MAP_KERNEL,\r\n      output: { name: 'xyslMap', filter: 'linear' },\r\n      uniforms: {\r\n        centerline: { type: 'sharedTexture' },\r\n        xyCenterPoint: { type: 'vec2' },\r\n        xyGridCellSize: { type: 'float'},\r\n        centerlineStationInterval: { type: 'float'}\r\n      }\r\n    };\r\n  },\r\n\r\n  update(config, xyWidth, xyHeight, xyCenterPoint) {\r\n    return {\r\n      width: xyWidth,\r\n      height: xyHeight,\r\n      uniforms: {\r\n        xyCenterPoint: [xyCenterPoint.x, xyCenterPoint.y],\r\n        xyGridCellSize: config.xyGridCellSize,\r\n        centerlineStationInterval: config.centerlineStationInterval\r\n      }\r\n    };\r\n  }\r\n});\r\n\n;// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/optimizeCubicPaths.js\n// Config:\r\n// num stations\r\n// num latitudes\r\n// station connectivity\r\n// latitude connectivity\r\n//\r\n// Shared:\r\n// lattice\r\n\r\nconst OPTIMIZE_CUBIC_SHARED = `\r\n\r\nconst int NEWTON_ITERATIONS = 16;\r\nconst int RELAXATION_ITERATIONS = 16;\r\nconst float CONVERGENCE_ERROR = 0.01;\r\n\r\n// These two consts must stay in sync.\r\nconst int SIMPSONS_INTERVALS = 8;\r\n//const float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\r\nconst float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\r\n\r\nconst float PI = 3.1415926535897932384626433832795;\r\nconst float TWO_PI = PI + PI;\r\n\r\nconst float RELAXATION_ITERATIONS_F = float(RELAXATION_ITERATIONS);\r\nconst float SIMPSONS_INTERVALS_F = float(SIMPSONS_INTERVALS);\r\n\r\nfloat wrapAngle(float angle) {\r\n  angle = mod(angle, TWO_PI);\r\n  if (angle <= -PI) return angle + TWO_PI;\r\n  else if (angle > PI) return angle - TWO_PI;\r\n  return angle;\r\n}\r\n\r\nvec4 iterate(vec4 goal, float p0, float p1, float p2, float p3, float sG) {\r\n  float ds = sG / SIMPSONS_INTERVALS_F;\r\n  float sG_2 = sG * sG;\r\n  float sG_3 = sG_2 * sG;\r\n\r\n  vec3 dX_p = vec3(0.0);\r\n  vec3 dY_p = vec3(0.0);\r\n  vec2 guess = vec2(0.0);\r\n  float s = 0.0;\r\n\r\n  float theta, cosTheta, sinTheta;\r\n  vec3 dT_p;\r\n\r\n  for (int i = 0; i <= SIMPSONS_INTERVALS; i++) {\r\n    float coeff = SIMPSONS_COEFFS[i];\r\n\r\n    float a = p0;\r\n    float b = (-5.5 * p0 + 9.0 * p1 - 4.5 * p2 + p3) / sG;\r\n    float c = (9.0 * p0 - 22.5 * p1 + 18.0 * p2 - 4.5 * p3) / sG_2;\r\n    float d = (-4.5 * (p0 - 3.0 * p1 + 3.0 * p2 - p3)) / sG_3;\r\n\r\n    theta = (((d * s / 4.0 + c / 3.0) * s + b / 2.0) * s + a) * s;\r\n    cosTheta = cos(theta);\r\n    sinTheta = sin(theta);\r\n\r\n    float s_sG = s / sG;\r\n\r\n    dT_p = vec3(\r\n      // p1\r\n      ((3.375 * s_sG - 7.5) * s_sG + 4.5) * s_sG * s,\r\n\r\n      // p2\r\n      ((-3.375 * s_sG + 6.0) * s_sG - 2.25) * s_sG * s,\r\n\r\n      // sG\r\n      ((3.375 * (p0 - 3.0 * p1 + 3.0 * p2 - p3) * s_sG - 3.0 * (2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3)) * s_sG + 0.25 * (11.0 * p0 - 18.0 * p1 + 9.0 * p2 - 2.0 * p3)) * s_sG * s_sG\r\n    );\r\n\r\n    dX_p -= coeff * sinTheta * dT_p;\r\n    dY_p += coeff * cosTheta * dT_p;\r\n\r\n    guess += coeff * vec2(cosTheta, sinTheta);\r\n\r\n    s += ds;\r\n  }\r\n\r\n  float hOver3 = sG / SIMPSONS_INTERVALS_F / 3.0;\r\n\r\n  vec3 delta;\r\n  delta.xy = goal.xy - guess * hOver3;\r\n  delta.z = wrapAngle(goal.z - theta);\r\n\r\n  if (abs(delta.x) + abs(delta.y) + abs(delta.z) < CONVERGENCE_ERROR)\r\n    return vec4(p1, p2, sG, 1.0);\r\n\r\n  dX_p.xyz *= hOver3;\r\n  dY_p.xyz *= hOver3;\r\n  dX_p.z += cosTheta;\r\n  dY_p.z += sinTheta;\r\n\r\n  mat3 invJacobian = inverse(transpose(mat3(dX_p, dY_p, dT_p)));\r\n\r\n  vec3 deltaP = invJacobian * delta;\r\n  vec4 params = vec4(p1, p2, sG, 0.0);\r\n  params.xyz += deltaP;\r\n\r\n  return params;\r\n}\r\n\r\n/* Input:\r\n *   start: (vec4)\r\n *     x: x position,\r\n *     y: y position,\r\n *     z: theta rotation,\r\n *     w: k curvature\r\n *   end: (vec4)\r\n *     x: x position,\r\n *     y: y position,\r\n *     z: theta rotation,\r\n *     w: k curvature\r\n *\r\n * Output: (vec4)\r\n *   x: p1,\r\n *   y: p2,\r\n *   z: sG,\r\n *   w: 1 if converged, 0 if not\r\n */\r\n\r\nvec4 optimize(vec4 start, vec4 end) {\r\n  // Translate and rotate start and end so that start is at the origin\r\n  float sinRot = sin(start.z);\r\n  float cosRot = cos(start.z);\r\n\r\n  vec4 diff = end - start;\r\n  vec4 goal;\r\n  goal.xy = mat2(cosRot, -sinRot, sinRot, cosRot) * diff.xy;\r\n  goal.z = wrapAngle(diff.z);\r\n  goal.w = end.w;\r\n\r\n  vec4 originalGoal = goal;\r\n  vec4 dGoal;\r\n  dGoal.x = 0.0;\r\n  dGoal.yzw = goal.yzw / RELAXATION_ITERATIONS_F;\r\n  float dK0 = start.w / RELAXATION_ITERATIONS_F;\r\n\r\n  // Relax the goal to (x, 0, 0, 0)\r\n  goal.yzw = vec3(0, 0, 0);\r\n\r\n  // Relax the params to (0, 0, 0, 0, goal.x)\r\n  float p0 = 0.0;\r\n  float p1 = 0.0;\r\n  float p2 = 0.0;\r\n  float p3 = 0.0;\r\n  float sG = goal.x;\r\n\r\n  if (sG < 0.1) return vec4(0.0);\r\n\r\n  for (int i = 0; i < RELAXATION_ITERATIONS; i++) {\r\n    p0 += dK0;\r\n    p3 += dGoal.w;\r\n    goal += dGoal;\r\n    \r\n    vec4 result = iterate(goal, p0, p1, p2, p3, sG);\r\n    p1 = result.x;\r\n    p2 = result.y;\r\n    sG = result.z;\r\n  }\r\n\r\n  goal = originalGoal;\r\n\r\n  for (int i = 0; i < NEWTON_ITERATIONS; i++) {\r\n    vec4 result = iterate(goal, p0, p1, p2, p3, sG);\r\n    if (result.w == 1.0) {\r\n      result.w = step(0.0, result.z);\r\n      return result;\r\n    }\r\n\r\n    p1 = result.x;\r\n    p2 = result.y;\r\n    sG = result.z;\r\n  }\r\n\r\n  return vec4(p1, p2, sG, 0.0);\r\n}\r\n\r\n`;\r\n\r\nconst OPTIMIZE_CUBIC_KERNEL = OPTIMIZE_CUBIC_SHARED + `\r\n\r\n// width: station * latitude index\r\n// height: station_conn * lattice_conn\r\n//\r\n// lattice:\r\n// width: latitudes\r\n// height: stations\r\n\r\nvec4 kernel() {\r\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\r\n\r\n  int endStation = indexes.x / numLatitudes;\r\n  int endLatitude = int(mod(float(indexes.x), float(numLatitudes)));\r\n\r\n  int startStation = endStation - stationConnectivity + indexes.y / latitudeConnectivity;\r\n  int startLatitude = endLatitude - latitudeConnectivity / 2 + int(mod(float(indexes.y), float(latitudeConnectivity)));\r\n\r\n  if (startStation < 0 || startStation >= numStations || startLatitude < 0 || startLatitude >= numLatitudes)\r\n    return vec4(0.0);\r\n\r\n  vec4 start = texelFetch(lattice, ivec2(startLatitude, startStation), 0);\r\n  vec4 end = texelFetch(lattice, ivec2(endLatitude, endStation), 0);\r\n\r\n  return optimize(start, end);\r\n}\r\n\r\n`;\r\n\r\nconst OPTIMIZE_CUBIC_FROM_VEHICLE_KERNEL = OPTIMIZE_CUBIC_SHARED + `\r\n\r\nvec4 kernel() {\r\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\r\n\r\n  vec4 start = vec4(0, 0, 0, curvVehicle);\r\n  vec4 end = texelFetch(lattice, indexes, 0);\r\n\r\n  return optimize(start, end);\r\n}\r\n\r\n`;\r\n\r\n/* harmony default export */ const optimizeCubicPaths = ({\r\n  setUp() {\r\n    return [\r\n      { // Cubic paths between lattice nodes\r\n        kernel: OPTIMIZE_CUBIC_KERNEL,\r\n        output: { name: 'cubicPaths', read: true },\r\n        uniforms: {\r\n          lattice: { type: 'sharedTexture' },\r\n          numStations: { type: 'int' },\r\n          numLatitudes: { type: 'int' },\r\n          stationConnectivity: { type: 'int' },\r\n          latitudeConnectivity: { type: 'int' }\r\n        }\r\n      },\r\n      { // Cubic paths from vehicle to lattice nodes\r\n        kernel: OPTIMIZE_CUBIC_FROM_VEHICLE_KERNEL,\r\n        output: { name: 'cubicPathsFromVehicle', read: true },\r\n        uniforms: {\r\n          lattice: { type: 'sharedTexture' },\r\n          curvVehicle: { type: 'float' }\r\n        }\r\n      }\r\n    ]\r\n  },\r\n\r\n  update(config, pose) {\r\n    return [\r\n      { // Cubic paths between lattice nodes\r\n        width: config.lattice.numStations * config.lattice.numLatitudes,\r\n        height: config.lattice.stationConnectivity * config.lattice.latitudeConnectivity,\r\n        uniforms: {\r\n          numStations: config.lattice.numStations,\r\n          numLatitudes: config.lattice.numLatitudes,\r\n          stationConnectivity: config.lattice.stationConnectivity,\r\n          latitudeConnectivity: config.lattice.latitudeConnectivity,\r\n        }\r\n      },\r\n      { // Cubic paths from vehicle to lattice nodes\r\n        width: config.lattice.numLatitudes,\r\n        height: config.lattice.stationConnectivity,\r\n        uniforms: {\r\n          curvVehicle: pose.curv\r\n        }\r\n      }\r\n    ];\r\n  }\r\n});\r\n\n;// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/optimizeQuinticPaths.js\nconst OPTIMIZE_KERNEL = `\r\n\r\nconst int NEWTON_ITERATIONS = 32;\r\nconst int RELAXATION_ITERATIONS = 32;\r\nconst float CONVERGENCE_ERROR = 0.01;\r\n\r\n// These two consts must stay in sync.\r\nconst int SIMPSONS_INTERVALS = 8;\r\nconst float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\r\n\r\nconst float PI = 3.1415926535897932384626433832795;\r\nconst float TWO_PI = PI + PI;\r\n\r\nconst float RELAXATION_ITERATIONS_F = float(RELAXATION_ITERATIONS);\r\nconst float SIMPSONS_INTERVALS_F = float(SIMPSONS_INTERVALS);\r\n\r\nfloat wrapAngle(float angle) {\r\n  angle = mod(angle, TWO_PI);\r\n  if (angle <= -PI) return angle + TWO_PI;\r\n  else if (angle > PI) return angle - TWO_PI;\r\n  return angle;\r\n}\r\n\r\nvec4 iterate(vec4 goal, float p0, float p1, float p2, float p3, float p4, float p5, float sG) {\r\n  float ds = sG / SIMPSONS_INTERVALS_F;\r\n  float sG_2 = sG * sG;\r\n  float sG_3 = sG_2 * sG;\r\n\r\n  vec3 dX_p = vec3(0.0);\r\n  vec3 dY_p = vec3(0.0);\r\n  vec2 guess = vec2(0.0);\r\n  float s = 0.0;\r\n\r\n  float theta, cosTheta, sinTheta;\r\n  vec3 dT_p;\r\n\r\n  for (int i = 0; i <= SIMPSONS_INTERVALS; i++) {\r\n    float coeff = SIMPSONS_COEFFS[i];\r\n\r\n    float a = p0;\r\n    float b = p1;\r\n    float c = p2 / 2.0;\r\n    float d = (-71.875 * p0 + 81.0 * p3 - 10.125 * p4 + p5 - 21.25 * p1 * sG - 2.75 * p2 * sG_2) / sG_3;\r\n    float e = (166.5 * p0 - 202.5 * p3 + 40.5 * p4 - 4.5 * p5 + 45.0 * p1 * sG + 4.5 * p2 * sG_2) / (sG_2 * sG_2);\r\n    float f = (-95.625 * p0 + 121.5 * p3 - 30.375 * p4 + 4.5 * p5 - 24.75 * p1 * sG - 2.25 * p2 * sG_2) / (sG_2 * sG_3);\r\n\r\n    theta = (((((f * s / 6.0 + e / 5.0) * s + d / 4.0) * s + c / 3.0) * s + b / 2.0) * s + a) * s;\r\n    cosTheta = cos(theta);\r\n    sinTheta = sin(theta);\r\n\r\n    float s_2 = s * s;\r\n    float s_sG = s / sG;\r\n    float s_sG_2 = s_sG * s_sG;\r\n    float s_sG_3 = s_sG_2 * s_sG;\r\n    float s_sG_4 = s_sG_3 * s_sG;\r\n    float s_sG_5 = s_sG_4 * s_sG;\r\n\r\n    dT_p = vec3(\r\n      // p3\r\n      ((20.25 * s_sG - 40.5) * s_sG + 20.25) * s_sG_3 * s,\r\n\r\n      // p4\r\n      ((-5.0625 * s_sG + 8.1) * s_sG - 2.53125) * s_sG_3 * s,\r\n\r\n      // sG\r\n      (53.90625 * p0 - 60.75 * p3 + 7.59375 * p4 - 0.75 * p5) * s_sG_4 + 10.625 * p1 * s * s_sG_3 + 0.6875 * p2 * s_2 * s_sG_2 + (-133.2 * p0 + 162.0 * p3 - 32.4 * p4 + 3.6 * p5) * s_sG_5 + (-27.0) * p1 * s * s_sG_4 - 1.8 * p2 * s_2 * s_sG_3 + (79.6875 * p0 - 101.25 * p3 + 25.3125 * p4 - 3.75 * p5) * s_sG_5 * s_sG + 16.5 * p1 * s * s_sG_5 + 1.125 * p2 * s_2 * s_sG_4\r\n    );\r\n\r\n    dX_p -= coeff * sinTheta * dT_p;\r\n    dY_p += coeff * cosTheta * dT_p;\r\n\r\n    guess += coeff * vec2(cosTheta, sinTheta);\r\n\r\n    s += ds;\r\n  }\r\n\r\n  float hOver3 = sG / SIMPSONS_INTERVALS_F / 3.0;\r\n\r\n  vec3 delta;\r\n  delta.xy = goal.xy - guess * hOver3;\r\n  delta.z = wrapAngle(goal.z - theta);\r\n\r\n  if (abs(delta.x) + abs(delta.y) + abs(delta.z) < CONVERGENCE_ERROR)\r\n    return vec4(p3, p4, sG, 1.0);\r\n\r\n  dX_p.xyz *= hOver3;\r\n  dY_p.xyz *= hOver3;\r\n  dX_p.z += cosTheta;\r\n  dY_p.z += sinTheta;\r\n\r\n  mat3 invJacobian = inverse(transpose(mat3(dX_p, dY_p, dT_p)));\r\n\r\n  vec3 deltaP = invJacobian * delta;\r\n  vec4 params = vec4(p3, p4, sG, 0.0);\r\n  params.xyz += deltaP;\r\n\r\n  return params;\r\n}\r\n\r\nvec4 optimize(vec4 start, vec4 end) {\r\n  // Translate and rotate start and end so that start is at the origin\r\n  float sinRot = sin(start.z);\r\n  float cosRot = cos(start.z);\r\n\r\n  vec4 diff = end - start;\r\n  vec4 goal;\r\n  goal.xy = mat2(cosRot, -sinRot, sinRot, cosRot) * diff.xy;\r\n  goal.z = wrapAngle(diff.z);\r\n  goal.w = end.w;\r\n\r\n  vec4 originalGoal = goal;\r\n  vec4 dGoal;\r\n  dGoal.x = 0.0;\r\n  dGoal.yzw = goal.yzw / RELAXATION_ITERATIONS_F;\r\n  float d_K0 = start.w / RELAXATION_ITERATIONS_F;\r\n  float d_dK0 = dCurvVehicle / RELAXATION_ITERATIONS_F;\r\n  float d_ddK0 = ddCurvVehicle / RELAXATION_ITERATIONS_F;\r\n\r\n  // Relax the goal to (x, 0, 0, 0)\r\n  goal.yzw = vec3(0, 0, 0);\r\n\r\n  // Relax the params to (0, 0, 0, 0, goal.x)\r\n  float p0 = 0.0;\r\n  float p1 = 0.0;\r\n  float p2 = 0.0;\r\n  float p3 = 0.0;\r\n  float p4 = 0.0;\r\n  float p5 = 0.0;\r\n  float sG = goal.x;\r\n\r\n  if (sG < 0.1) return vec4(0.0);\r\n\r\n  for (int i = 0; i < RELAXATION_ITERATIONS; i++) {\r\n    p0 += d_K0;\r\n    p1 += d_dK0;\r\n    p2 += d_ddK0;\r\n    p5 += dGoal.w;\r\n    goal += dGoal;\r\n    \r\n    vec4 result = iterate(goal, p0, p1, p2, p3, p4, p5, sG);\r\n    p3 = result.x;\r\n    p4 = result.y;\r\n    sG = result.z;\r\n  }\r\n\r\n  goal = originalGoal;\r\n\r\n  for (int i = 0; i < NEWTON_ITERATIONS; i++) {\r\n    vec4 result = iterate(goal, p0, p1, p2, p3, p4, p5, sG);\r\n    if (result.w == 1.0) {\r\n      result.w = step(0.0, result.z);\r\n      return result;\r\n    }\r\n\r\n    p3 = result.x;\r\n    p4 = result.y;\r\n    sG = result.z;\r\n  }\r\n\r\n  return vec4(p3, p4, sG, 0.0);\r\n}\r\n\r\nvec4 kernel() {\r\n  ivec2 latticeIndexes = ivec2(kernelPosition * vec2(kernelSize));\r\n\r\n  vec4 start = vec4(0, 0, 0, curvVehicle);\r\n  vec4 end = texelFetch(lattice, latticeIndexes, 0);\r\n\r\n  return optimize(start, end);\r\n}\r\n\r\n`;\r\n\r\n// Quintic spiral path optimizer\r\n//   * Start of paths is the vehicle pose\r\n//     * x-pos, y-pos, and rotation aren't needed, since the lattice origin is the vehicle pose\r\n//     * So assume position and rotation are 0\r\n//   * Ends of paths are all latitudes within the first (stationConnectivity) stations\r\n/* harmony default export */ const optimizeQuinticPaths = ({\r\n  setUp() {\r\n    return {\r\n      kernel: OPTIMIZE_KERNEL,\r\n      output: { name: 'quinticPathsFromVehicle', read: true },\r\n      uniforms: {\r\n        lattice: { type: 'sharedTexture' },\r\n        curvVehicle: { type: 'float' },\r\n        dCurvVehicle: { type: 'float' },\r\n        ddCurvVehicle: { type: 'float' }\r\n      }\r\n    };\r\n  },\r\n\r\n  update(config, pose) {\r\n    return {\r\n      width: config.lattice.numLatitudes,\r\n      height: config.lattice.stationConnectivity,\r\n      uniforms: {\r\n        curvVehicle: pose.curv,\r\n        dCurvVehicle: pose.dCurv,\r\n        ddCurvVehicle: pose.ddCurv\r\n      }\r\n    };\r\n  }\r\n});\r\n\n;// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/graphSearchShared.js\nconst SHARED_SHADER = `\r\n\r\nconst float smallV = 0.01;\r\nvec4 pathSamples[128];\r\nfloat pathSampleCurvRates[128];\r\n\r\nfloat calculateAcceleration(int index, float initialVelocitySq, float distance) {\r\n  if (index <= 4) {\r\n    // [aMaxHard, aMinHard, aMaxSoft, aMinSoft, 0]\r\n    return accelerationProfiles[index];\r\n  } else {\r\n    float finalVelocity = finalVelocityProfiles[index - 5];\r\n    if (distance < 0.001) return 0.0;\r\n    return clamp((finalVelocity * finalVelocity - initialVelocitySq) / (2.0 * distance), accelerationProfiles[1], accelerationProfiles[0]);\r\n  }\r\n}\r\n\r\nvec2 xy2sl(vec4 xytk) {\r\n  vec2 xy = xytk.xy + rearAxleToCenter * vec2(cos(xytk.z), sin(xytk.z));\r\n  vec2 xyTexCoords = (xy - xyCenterPoint) / vec2(textureSize(xyslMap, 0)) / vec2(xyGridCellSize) + 0.5;\r\n  return texture(xyslMap, xyTexCoords).xy;\r\n}\r\n\r\nfloat sampleStaticCost(vec4 xytk) {\r\n  vec2 sl = xy2sl(xytk);\r\n  vec2 slTexCoords = (sl - slCenterPoint) / vec2(textureSize(slObstacleGrid, 0)) / vec2(slGridCellSize) + 0.5;\r\n  float obstacleCost = texture(slObstacleGrid, slTexCoords).r;\r\n\r\n  if (obstacleCost >= 0.75) return -1.0; // Infinite cost\r\n\r\n  obstacleCost = step(0.25, obstacleCost) * obstacleHazardCost;\r\n\r\n  float absLatitude = abs(sl.y);\r\n  if (absLatitude >= laneShoulderLatitude) return -1.0;\r\n\r\n  float laneCost = abs(absLatitude - laneCenterLatitude) * laneCostSlope + step(0.0, -sl.y * sign(lanePreference)) * lanePreferenceDiscount;\r\n\r\n  return obstacleCost + laneCost;\r\n}\r\n\r\nfloat sampleDynamicCost(vec4 xytk, float time, float velocity, float acceleration) {\r\n  vec2 sl = xy2sl(xytk);\r\n  vec2 slTexCoords = (sl - slCenterPoint) / vec2(textureSize(slDynamicObstacleGrid, 0).xy) / vec2(slGridCellSize) + 0.5;\r\n  float dynamicFrame = floor(time / dynamicFrameTime);\r\n\r\n  float obstacleCost = texture(slDynamicObstacleGrid, vec3(slTexCoords, dynamicFrame)).r;\r\n\r\n  if (obstacleCost > 0.75) return -1.0; // Infinite cost\r\n\r\n  return step(0.25, obstacleCost) * obstacleHazardCost;\r\n}\r\n\r\nfloat calculateAverageStaticCost(int numSamples) {\r\n  float averageStaticCost = 0.0;\r\n\r\n  for (int i = 0; i < numSamples; i++) {\r\n    float cost = sampleStaticCost(pathSamples[i]);\r\n\r\n    if (cost < 0.0) return cost;\r\n\r\n    averageStaticCost += cost;\r\n  }\r\n\r\n  averageStaticCost /= float(numSamples);\r\n\r\n  return averageStaticCost;\r\n}\r\n\r\nfloat calculateAverageDynamicCost(int numSamples, float pathLength, float initialTime, float initialVelocity, float acceleration, float abandonThreshold) {\r\n  float s = 0.0;\r\n  float ds = pathLength / float(numSamples - 1);\r\n  float averageDynamicCost = 0.0;\r\n  float maxVelocity = 0.0;\r\n  float maxLateralAcceleration = 0.0;\r\n  float numSamples_f = float(numSamples);\r\n\r\n  for (int i = 0; i < numSamples; i++) {\r\n    vec4 pathSample = pathSamples[i]; // vec4(x-pos, y-pos, theta (rotation), kappa (curvature))\r\n\r\n    float velocitySq = 2.0 * acceleration * s + initialVelocity * initialVelocity;\r\n    float velocity = max(smallV, sqrt(max(0.0, velocitySq)));\r\n    maxVelocity = max(maxVelocity, velocity);\r\n    maxLateralAcceleration = max(maxLateralAcceleration, abs(pathSample.w * velocity * velocity));\r\n\r\n    float time = 2.0 * s / (initialVelocity + velocity) + initialTime;\r\n\r\n    float dCurv = pathSampleCurvRates[i] * velocity;\r\n    if (dCurv > dCurvatureMax) return -1.0;\r\n\r\n    float cost = sampleDynamicCost(pathSample, time, velocity, acceleration);\r\n    if (cost < 0.0) return cost;\r\n\r\n    averageDynamicCost += cost;\r\n    if (averageDynamicCost / numSamples_f >= abandonThreshold) return -1.0;\r\n\r\n    s += ds;\r\n  }\r\n\r\n  averageDynamicCost /= numSamples_f;\r\n\r\n  // Apply speeding penality if any velocity along the trajectory is over the speed limit\r\n  averageDynamicCost += step(speedLimit, maxVelocity) * speedLimitPenalty;\r\n\r\n  // Apply hard acceleration/deceleration penalties if the acceleration/deceleration exceeds the soft limits\r\n  averageDynamicCost += step(accelerationProfiles[2] + 0.0001, acceleration) * hardAccelerationPenalty;\r\n  averageDynamicCost += (1.0 - step(accelerationProfiles[3], acceleration)) * hardDecelerationPenalty;\r\n\r\n  // Penalize lateral acceleration\r\n  averageDynamicCost += step(softLateralAccelerationLimit, maxLateralAcceleration) * softLateralAccelerationPenalty;\r\n  averageDynamicCost += linearLateralAccelerationPenalty * maxLateralAcceleration;\r\n\r\n  return averageDynamicCost;\r\n}\r\n\r\nvec3 calculateAVT(int accelerationIndex, float initialVelocity, float initialTime, float pathLength) {\r\n  float initialVelocitySq = initialVelocity * initialVelocity;\r\n  float acceleration = calculateAcceleration(accelerationIndex, initialVelocitySq, pathLength);\r\n\r\n  float finalVelocitySq = 2.0 * acceleration * pathLength + initialVelocitySq;\r\n  float finalVelocity = max(smallV, sqrt(max(0.0, finalVelocitySq)));\r\n\r\n  float finalTime = initialTime;\r\n\r\n  if (acceleration == 0.0) {\r\n    finalTime += pathLength / finalVelocity;\r\n  } else if (finalVelocitySq <= 0.0) { // Calculate final time if the vehicle stops before the end of the trajectory\r\n    float distanceLeft = pathLength - (smallV * smallV - initialVelocitySq) / (2.0 * acceleration);\r\n    finalTime += (finalVelocity - initialVelocity) / acceleration + distanceLeft / smallV;\r\n  } else {\r\n    finalTime += 2.0 * pathLength / (finalVelocity + initialVelocity);\r\n  }\r\n\r\n  return vec3(acceleration, finalVelocity, finalTime);\r\n}\r\n\r\n`;\r\n\r\nconst SAMPLE_CUBIC_PATH_FN = `\r\n\r\nint sampleCubicPath(vec4 start, vec4 end, vec4 cubicPathParams) {\r\n  float p0 = start.w;\r\n  float p1 = cubicPathParams.x;\r\n  float p2 = cubicPathParams.y;\r\n  float p3 = end.w;\r\n  float sG = cubicPathParams.z;\r\n\r\n  if (sG <= 0.0) return 0;\r\n\r\n  int numSamples = int(ceil(sG / pathSamplingStep)) + 1;\r\n\r\n  float sG_2 = sG * sG;\r\n  float sG_3 = sG_2 * sG;\r\n\r\n  float a = p0;\r\n  float b = (-5.5 * p0 + 9.0 * p1 - 4.5 * p2 + p3) / sG;\r\n  float c = (9.0 * p0 - 22.5 * p1 + 18.0 * p2 - 4.5 * p3) / sG_2;\r\n  float d = (-4.5 * (p0 - 3.0 * p1 + 3.0 * p2 - p3)) / sG_3;\r\n\r\n  pathSamples[0] = start;\r\n\r\n  float ds = sG / float(numSamples - 1);\r\n  float s = ds;\r\n  vec2 dxy = vec2(0);\r\n  vec2 prevCosSin = vec2(cos(start.z), sin(start.z));\r\n\r\n  for (int i = 1; i < numSamples; i++) {\r\n    float rot = (((d * s / 4.0 + c / 3.0) * s + b / 2.0) * s + a) * s + start.z;\r\n    float curv = ((d * s + c) * s + b) * s + a;\r\n\r\n    vec2 cosSin = vec2(cos(rot), sin(rot));\r\n    dxy = dxy * vec2(float(i - 1) / float(i)) + (cosSin + prevCosSin) / vec2(2 * i);\r\n\r\n    pathSamples[i] = vec4(dxy * vec2(s) + start.xy, rot, curv);\r\n    pathSampleCurvRates[i] = b + s * (2.0 * c + 3.0 * d * s);\r\n\r\n    s += ds;\r\n    prevCosSin = cosSin;\r\n  }\r\n\r\n  return numSamples;\r\n}\r\n\r\n`;\r\n\r\nconst SAMPLE_QUINTIC_PATH_FN = `\r\n\r\nint sampleQuinticPath(vec4 start, vec4 end, vec4 quinticPathParams) {\r\n  float p0 = start.w;\r\n  float p1 = dCurvVehicle;\r\n  float p2 = ddCurvVehicle;\r\n  float p3 = quinticPathParams.x;\r\n  float p4 = quinticPathParams.y;\r\n  float p5 = end.w;\r\n  float sG = quinticPathParams.z;\r\n\r\n  if (sG <= 0.0) return 0;\r\n\r\n  int numSamples = int(ceil(sG / pathSamplingStep)) + 1;\r\n\r\n  float sG_2 = sG * sG;\r\n  float sG_3 = sG_2 * sG;\r\n\r\n  float a = p0;\r\n  float b = p1;\r\n  float c = p2 / 2.0;\r\n  float d = (-71.875 * p0 + 81.0 * p3 - 10.125 * p4 + p5 - 21.25 * p1 * sG - 2.75 * p2 * sG_2) / sG_3;\r\n  float e = (166.5 * p0 - 202.5 * p3 + 40.5 * p4 - 4.5 * p5 + 45.0 * p1 * sG + 4.5 * p2 * sG_2) / (sG_2 * sG_2);\r\n  float f = (-95.625 * p0 + 121.5 * p3 - 30.375 * p4 + 4.5 * p5 - 24.75 * p1 * sG - 2.25 * p2 * sG_2) / (sG_2 * sG_3);\r\n\r\n  pathSamples[0] = start;\r\n\r\n  float ds = sG / float(numSamples - 1);\r\n  float s = ds;\r\n  vec2 dxy = vec2(0);\r\n  vec2 prevCosSin = vec2(cos(start.z), sin(start.z));\r\n\r\n  for (int i = 1; i < numSamples; i++) {\r\n    float rot = (((((f * s / 6.0 + e / 5.0) * s + d / 4.0) * s + c / 3.0) * s + b / 2.0) * s + a) * s + start.z;\r\n    float curv = ((((f * s + e) * s + d) * s + c) * s + b) * s + a;\r\n\r\n    vec2 cosSin = vec2(cos(rot), sin(rot));\r\n    dxy = dxy * vec2(float(i - 1) / float(i)) + (cosSin + prevCosSin) / vec2(2 * i);\r\n\r\n    pathSamples[i] = vec4(dxy * vec2(s) + start.xy, rot, curv);\r\n    pathSampleCurvRates[i] = b + s * (2.0 * c + s * (3.0 * d + s * (4.0 * e + 5.0 * f * s)));\r\n\r\n    s += ds;\r\n    prevCosSin = cosSin;\r\n  }\r\n\r\n  return numSamples;\r\n}\r\n\r\n`;\r\n\r\nconst NUM_ACCELERATION_PROFILES = 8;\r\nconst NUM_VELOCITY_RANGES = 4;\r\nconst NUM_TIME_RANGES = 2;\r\n\r\nconst SHARED_UNIFORMS = {\r\n  xyslMap: { type: 'outputTexture' },\r\n  slObstacleGrid: { type: 'outputTexture', name: 'slObstacleGridDilated' },\r\n  slDynamicObstacleGrid: { type: 'outputTexture', name: 'slDynamicObstacleGrid', textureType: '2DArray' },\r\n  accelerationProfiles: { type: 'float', length: 5 },\r\n  finalVelocityProfiles: { type: 'float', length: 3 },\r\n  xyCenterPoint: { type: 'vec2' },\r\n  xyGridCellSize: { type: 'float' },\r\n  slCenterPoint: { type: 'vec2' },\r\n  slGridCellSize: { type: 'float'},\r\n  laneCenterLatitude: { type: 'float'},\r\n  laneShoulderLatitude: { type: 'float'},\r\n  laneCostSlope: { type: 'float'},\r\n  lanePreference: { type: 'float' },\r\n  lanePreferenceDiscount: { type: 'float' },\r\n  obstacleHazardCost: { type: 'float' },\r\n  speedLimit: { type: 'float' },\r\n  speedLimitPenalty: { type: 'float' },\r\n  hardAccelerationPenalty: { type: 'float' },\r\n  hardDecelerationPenalty: { type: 'float' },\r\n  softLateralAccelerationLimit: { type: 'float' },\r\n  softLateralAccelerationPenalty: { type: 'float' },\r\n  linearLateralAccelerationPenalty: { type: 'float' },\r\n  dCurvatureMax: { type: 'float' },\r\n  pathSamplingStep: { type: 'float' },\r\n  rearAxleToCenter: { type: 'float' },\r\n  dynamicFrameTime: { type: 'float' }\r\n};\r\n\r\nfunction buildUniformValues(config, xyCenterPoint, slCenterPoint, dynamicFrameTime) {\r\n  return {\r\n    accelerationProfiles: [3.5, -6.5, 2.0, -3.0, 0],\r\n    finalVelocityProfiles: [0.999 * config.speedLimit, 1.0, 0.01],\r\n    xyCenterPoint: [xyCenterPoint.x, xyCenterPoint.y],\r\n    xyGridCellSize: config.xyGridCellSize,\r\n    slCenterPoint: [slCenterPoint.x, slCenterPoint.y],\r\n    slGridCellSize: config.slGridCellSize,\r\n    laneCenterLatitude: config.laneCenterLatitude,\r\n    laneShoulderLatitude: config.laneShoulderLatitude,\r\n    laneCostSlope: config.laneCostSlope,\r\n    lanePreference: config.lanePreference,\r\n    lanePreferenceDiscount: config.lanePreferenceDiscount,\r\n    obstacleHazardCost: config.obstacleHazardCost,\r\n    speedLimit: config.speedLimit,\r\n    speedLimitPenalty: config.speedLimitPenalty,\r\n    hardAccelerationPenalty: config.hardAccelerationPenalty,\r\n    hardDecelerationPenalty: config.hardDecelerationPenalty,\r\n    softLateralAccelerationLimit: config.softLateralAccelerationLimit,\r\n    softLateralAccelerationPenalty: config.softLateralAccelerationPenalty,\r\n    linearLateralAccelerationPenalty: config.linearLateralAccelerationPenalty,\r\n    dCurvatureMax: config.dCurvatureMax,\r\n    pathSamplingStep: config.pathSamplingStep,\r\n    rearAxleToCenter: config.rearAxleToCenter,\r\n    dynamicFrameTime: dynamicFrameTime\r\n  };\r\n}\r\n\r\n\r\n\n;// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/pathFromVehicleCosts.js\n\r\n\r\nfunction fromVehiclePathCostsKernel(pathType) {\r\n  return SHARED_SHADER + (pathType == 'cubic' ? SAMPLE_CUBIC_PATH_FN : SAMPLE_QUINTIC_PATH_FN) +\r\n\r\n`\r\n\r\n/* Calculate cost of a {cubic|quintic} path from vehicle to (stationConnectivity * numLatitudes * numAccelerations) nodes\r\n *   width: numLatitudes\r\n *   height: station * numAccelerations\r\n */\r\nvec4 kernel() {\r\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\r\n\r\n  int latitude = indexes.x;\r\n  int station = indexes.y / numAccelerations;\r\n  int accelerationIndex = int(mod(float(indexes.y), float(numAccelerations)));\r\n\r\n  vec4 pathStart = vec4(0, 0, 0, curvVehicle);\r\n  vec4 pathEnd = texelFetch(lattice, ivec2(latitude, station), 0);\r\n\r\n  vec4 pathParams = texelFetch(pathsFromVehicle, ivec2(latitude, station), 0);\r\n\r\n  // If the path didn't converge\r\n  if (pathParams.w == 0.0) return vec4(-1);\r\n\r\n  int numSamples = ${pathType == 'cubic' ? 'sampleCubicPath' : 'sampleQuinticPath'}(pathStart, pathEnd, pathParams);\r\n  float pathLength = pathParams.z;\r\n\r\n  if (numSamples < 2) return vec4(-1);\r\n\r\n  float averageStaticCost = calculateAverageStaticCost(numSamples);\r\n  if (averageStaticCost < 0.0) return vec4(-1);\r\n\r\n  int slIndex = station * kernelSize.x + latitude;\r\n  float hysteresisAdjustment = (slIndex == firstLatticePoint || slIndex == secondLatticePoint) ?  0.0 : hysteresisDiscount;\r\n  averageStaticCost += hysteresisAdjustment;\r\n\r\n  vec3 avt = calculateAVT(accelerationIndex, velocityVehicle, 0.0, pathLength);\r\n  float acceleration = avt.x;\r\n  float finalVelocity = avt.y;\r\n  float finalTime = avt.z;\r\n\r\n  float averageDynamicCost = calculateAverageDynamicCost(numSamples, pathLength, 0.0, velocityVehicle, acceleration, 1.0 / 0.0);\r\n  if (averageDynamicCost < 0.0) return vec4(-1);\r\n\r\n  averageDynamicCost += accelerationChangePenalty;\r\n\r\n  // The cost of a trajectory is the average sample cost scaled by the path length\r\n  float totalCost = (averageStaticCost + averageDynamicCost + ${pathType == 'cubic' ? '(cubicPathPenalty * velocityVehicle * velocityVehicle)' : '0.0'}) * pathLength;\r\n  ${pathType != 'cubic' ? 'totalCost = -1.0;' : ''}\r\n\r\n  return vec4(totalCost, finalVelocity, finalTime, ${pathType == 'cubic' ? '-2' : '-1'});\r\n}\r\n\r\n`;\r\n}\r\n\r\n/* harmony default export */ const pathFromVehicleCosts = ({\r\n  setUp() {\r\n    return [\r\n      {\r\n        kernel: fromVehiclePathCostsKernel('cubic'),\r\n        output: { name: 'cubicPathFromVehicleCosts' },\r\n        uniforms: Object.assign({}, SHARED_UNIFORMS, {\r\n          lattice: { type: 'sharedTexture' },\r\n          pathsFromVehicle: { type: 'outputTexture', name: 'cubicPathsFromVehicle' },\r\n          firstLatticePoint: { type: 'int' },\r\n          secondLatticePoint: { type: 'int' },\r\n          velocityVehicle: { type: 'float' },\r\n          curvVehicle: { type: 'float' },\r\n          numAccelerations: { type: 'int' },\r\n          cubicPathPenalty: { type: 'float' },\r\n          hysteresisDiscount: { type: 'float' },\r\n          accelerationChangePenalty: { type: 'float' }\r\n        })\r\n      },\r\n      {\r\n        kernel: fromVehiclePathCostsKernel('quintic'),\r\n        output: { name: 'quinticPathFromVehicleCosts' },\r\n        uniforms: Object.assign({}, SHARED_UNIFORMS, {\r\n          lattice: { type: 'sharedTexture' },\r\n          pathsFromVehicle: { type: 'outputTexture', name: 'quinticPathsFromVehicle' },\r\n          firstLatticePoint: { type: 'int' },\r\n          secondLatticePoint: { type: 'int' },\r\n          velocityVehicle: { type: 'float' },\r\n          curvVehicle: { type: 'float' },\r\n          dCurvVehicle: { type: 'float' },\r\n          ddCurvVehicle: { type: 'float' },\r\n          numAccelerations: { type: 'int' },\r\n          hysteresisDiscount: { type: 'float' },\r\n          accelerationChangePenalty: { type: 'float' }\r\n        })\r\n      }\r\n    ];\r\n  },\r\n\r\n  update(config, pose, xyCenterPoint, slCenterPoint, firstLatticePoint, secondLatticePoint, dynamicFrameTime) {\r\n    return [\r\n      {\r\n        width: config.lattice.numLatitudes,\r\n        height: config.lattice.stationConnectivity * NUM_ACCELERATION_PROFILES,\r\n        uniforms: Object.assign({}, buildUniformValues(config, xyCenterPoint, slCenterPoint, dynamicFrameTime), {\r\n          firstLatticePoint: firstLatticePoint,\r\n          secondLatticePoint: secondLatticePoint,\r\n          velocityVehicle: pose.velocity,\r\n          curvVehicle: pose.curv,\r\n          numAccelerations: NUM_ACCELERATION_PROFILES,\r\n          cubicPathPenalty: config.cubicPathPenalty,\r\n          hysteresisDiscount: config.hysteresisDiscount,\r\n          accelerationChangePenalty: config.accelerationChangePenalty\r\n        })\r\n      },\r\n      {\r\n        width: config.lattice.numLatitudes,\r\n        height: config.lattice.stationConnectivity * NUM_ACCELERATION_PROFILES,\r\n        uniforms: Object.assign({}, buildUniformValues(config, xyCenterPoint, slCenterPoint, dynamicFrameTime), {\r\n          firstLatticePoint: firstLatticePoint,\r\n          secondLatticePoint: secondLatticePoint,\r\n          velocityVehicle: pose.velocity,\r\n          curvVehicle: pose.curv,\r\n          dCurvVehicle: pose.dCurv,\r\n          ddCurvVehicle: pose.ddCurv,\r\n          numAccelerations: NUM_ACCELERATION_PROFILES,\r\n          hysteresisDiscount: config.hysteresisDiscount,\r\n          accelerationChangePenalty: config.accelerationChangePenalty\r\n        })\r\n      }\r\n    ];\r\n  }\r\n});\r\n\n;// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/graphSearch.js\n/* State Lattice Cost Map\r\n * \r\n * 5-dimensional node: station, latitude, acceleration profile, velocity, time\r\n *\r\n * A draw call per station s\r\n *   * Input to kernel: latitude l, acceleration profile a, velocity range v, time range t\r\n *   * Find all SL vertices that can connect to this node\r\n *   * For each of those vertices, check if any terminate in this specific velocity and time range\r\n *     * Based on initial velocity, initial time, and acceleration\r\n *     * Each connected SL vertex should have a * v * t nodes that could possibly terminate at this node\r\n *   * For all valid edges, find the one with the lowest cost\r\n *\r\n * Input:\r\n *   * 2D texture array cost map\r\n *     * Height: num of latitudes (~20)\r\n *     * Width: num of acceleration profiles * num of time ranges * num of velocity ranges (8 * 2 * 4 = ~64)\r\n *       * A flattened 3D array:\r\n *         d1: acceleration\r\n *         d2: velocity\r\n *         d3: time\r\n *     * Layer: num of stations (~10)\r\n *   \r\n * Output:\r\n *   * 2D texture slice of the next station in the input 2D texture array cost map\r\n *\r\n * Cost Map Elements:\r\n *   * Traversal cost so far\r\n *   * Ending velocity\r\n *   * Ending time\r\n *   * Index of parent node\r\n *\r\n * Since one cubic path can be shared between multiple trajectories, they need to be pre-optimized.\r\n *\r\n * Quintic Paths:\r\n *   Stations 0 through (numStations - 1) correspond to the stations on the lattice; however,\r\n *   a new station (station -1) will be used to signifiy the single vehicle pose node. Either\r\n *   a cubic path or quintic path can be used to connect this single node to the lattice\r\n *   (depending on vehicle velocity). At station -1, latitude 0 will correspond to a cubic path,\r\n *   and latitude 1 will correspond to a quintic path. All other latitudes will be skipped.\r\n */\r\n\r\n\r\n\r\nconst SOLVE_STATION_KERNEL =\r\n  SHARED_SHADER +\r\n  SAMPLE_CUBIC_PATH_FN +\r\n  SAMPLE_QUINTIC_PATH_FN +\r\n\r\n`\r\n\r\nvec4 kernel() {\r\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\r\n\r\n  int latitude = indexes.y;\r\n\r\n  int numPerTime = numAccelerations * numVelocities;\r\n  int timeIndex = indexes.x / numPerTime;\r\n  indexes.x -= timeIndex * numPerTime;\r\n  int velocityIndex = indexes.x / numAccelerations;\r\n  int accelerationIndex = int(mod(float(indexes.x), float(numAccelerations)));\r\n\r\n  int minLatitude = max(latitude - latitudeConnectivity / 2, 0);\r\n  int maxLatitude = min(latitude + latitudeConnectivity / 2, numLatitudes - 1);\r\n\r\n  int slIndex = station * numLatitudes + latitude;\r\n\r\n  vec4 pathEnd = texelFetch(lattice, ivec2(latitude, station), 0);\r\n\r\n  float minVelocity = velocityRanges[velocityIndex];\r\n  float maxVelocity = velocityRanges[velocityIndex + 1];\r\n\r\n  float minTime = timeRanges[timeIndex];\r\n  float maxTime = timeRanges[timeIndex + 1];\r\n\r\n  vec4 bestTrajectory = vec4(-1); // -1 means infinite cost\r\n  float bestTerminalCost = 1.0 / 0.0;\r\n\r\n  float hysteresisAdjustment = (slIndex == firstLatticePoint || slIndex == secondLatticePoint) ?  0.0 : hysteresisDiscount;\r\n\r\n  for (int prevStation = max(station - stationConnectivity, 0); prevStation < station; prevStation++) {\r\n    int stationConnectivityIndex = prevStation - station + stationConnectivity;\r\n\r\n    for (int prevLatitude = minLatitude; prevLatitude <= maxLatitude; prevLatitude++) {\r\n      int latitudeConnectivityIndex = prevLatitude - latitude + latitudeConnectivity / 2;\r\n      int connectivityIndex = stationConnectivityIndex * latitudeConnectivity + latitudeConnectivityIndex;\r\n\r\n      vec4 pathStart = texelFetch(lattice, ivec2(prevLatitude, prevStation), 0);\r\n      vec4 cubicPathParams = texelFetch(cubicPaths, ivec2(slIndex, connectivityIndex), 0);\r\n\r\n      // If the path didn't converge\r\n      if (cubicPathParams.w == 0.0) continue;\r\n\r\n      int numSamples = sampleCubicPath(pathStart, pathEnd, cubicPathParams);\r\n      float pathLength = cubicPathParams.z;\r\n\r\n      if (numSamples < 2) continue;\r\n\r\n      float averageStaticCost = calculateAverageStaticCost(numSamples);\r\n      if (averageStaticCost < 0.0) continue;\r\n\r\n      averageStaticCost += hysteresisAdjustment;\r\n\r\n      if (averageStaticCost * pathLength >= bestTerminalCost) continue;\r\n\r\n      for (int prevVelocity = 0; prevVelocity < numVelocities; prevVelocity++) {\r\n        for (int prevTime = 0; prevTime < numTimes; prevTime++) {\r\n          for (int prevAccel = 0; prevAccel < numAccelerations; prevAccel++) {\r\n            int avtIndex = prevTime * numPerTime + prevVelocity * numAccelerations + prevAccel;\r\n\r\n            // Cost table entry:\r\n            //   x: cost so far\r\n            //   y: end velocity\r\n            //   z: end time\r\n            //   w: parent index\r\n            vec4 costTableEntry = texelFetch(costTable, ivec3(avtIndex, prevLatitude, prevStation), 0);\r\n\r\n            // If cost entry is infinity\r\n            if (costTableEntry.x < 0.0 || averageStaticCost * pathLength + costTableEntry.x >= bestTerminalCost) continue;\r\n\r\n            vec3 avt = calculateAVT(accelerationIndex, costTableEntry.y, costTableEntry.z, pathLength);\r\n            float acceleration = avt.x;\r\n            float finalVelocity = avt.y;\r\n            float finalTime = avt.z;\r\n\r\n            if (averageStaticCost * pathLength + costTableEntry.x + extraTimePenalty * finalTime >= bestTerminalCost) continue;\r\n\r\n            // If the calculated final velocity does not match this fragment's velocity range, then skip this trajectory\r\n            if (finalVelocity < minVelocity || finalVelocity >= maxVelocity) continue;\r\n\r\n            // If the calculated final time does not match this fragment's time range, then skip this trajectory\r\n            if (finalTime < minTime || finalTime >= maxTime) continue;\r\n\r\n            float abandonThreshold = (bestTerminalCost - extraTimePenalty * finalTime - costTableEntry.x) / pathLength - averageStaticCost;\r\n            float averageDynamicCost = calculateAverageDynamicCost(numSamples, pathLength, costTableEntry.z, costTableEntry.y, acceleration, abandonThreshold);\r\n            if (averageDynamicCost < 0.0) continue;\r\n\r\n            if (accelerationIndex != prevAccel)\r\n              averageDynamicCost += accelerationChangePenalty;\r\n\r\n            // The cost of a trajectory is the average sample cost scaled by the path length\r\n            float totalCost = (averageStaticCost + averageDynamicCost) * pathLength + costTableEntry.x;\r\n\r\n            float terminalCost = totalCost + extraTimePenalty * finalTime;\r\n            if (terminalCost >= bestTerminalCost) continue;\r\n            bestTerminalCost = terminalCost;\r\n\r\n            int incomingIndex = avtIndex + numPerTime * numTimes * (prevLatitude + numLatitudes * prevStation);\r\n            bestTrajectory = vec4(totalCost, finalVelocity, finalTime, incomingIndex);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (station < stationConnectivity) {\r\n    ivec2 slaIndex = ivec2(latitude, station * numAccelerations + accelerationIndex);\r\n\r\n    vec4 costTableEntry = texelFetch(cubicPathFromVehicleCosts, slaIndex, 0);\r\n    float terminalCost;\r\n\r\n    if (costTableEntry.x >= 0.0) {\r\n      terminalCost = costTableEntry.x + extraTimePenalty * costTableEntry.z;\r\n\r\n      if (terminalCost < bestTerminalCost) {\r\n        bestTerminalCost = terminalCost;\r\n        bestTrajectory = costTableEntry;\r\n      }\r\n    }\r\n\r\n    costTableEntry = texelFetch(quinticPathFromVehicleCosts, slaIndex, 0);\r\n\r\n    if (costTableEntry.x >= 0.0) {\r\n      terminalCost = costTableEntry.x + extraTimePenalty * costTableEntry.z;\r\n\r\n      if (terminalCost < bestTerminalCost) {\r\n        bestTerminalCost = terminalCost;\r\n        bestTrajectory = costTableEntry;\r\n      }\r\n    }\r\n  }\r\n\r\n  return bestTrajectory;\r\n}\r\n\r\n`;\r\n\r\n/* harmony default export */ const graphSearch = ({\r\n  setUp() {\r\n    return {\r\n      kernel: SOLVE_STATION_KERNEL,\r\n      output: { name: 'graphSearch' },\r\n      uniforms: Object.assign({}, SHARED_UNIFORMS, {\r\n        lattice: { type: 'sharedTexture' },\r\n        costTable: { type: 'sharedTexture', textureType: '2DArray' },\r\n        cubicPaths: { type: 'outputTexture' },\r\n        cubicPathFromVehicleCosts: { type: 'outputTexture' },\r\n        quinticPathFromVehicleCosts: { type: 'outputTexture' },\r\n        firstLatticePoint: { type: 'int' },\r\n        secondLatticePoint: { type: 'int' },\r\n        velocityVehicle: { type: 'float' },\r\n        curvVehicle: { type: 'float' },\r\n        dCurvVehicle: { type: 'float' },\r\n        ddCurvVehicle: { type: 'float' },\r\n        extraTimePenalty: { type: 'float' },\r\n        hysteresisDiscount: { type: 'float' },\r\n        accelerationChangePenalty: { type: 'float' },\r\n        numStations: { type: 'int' },\r\n        numLatitudes: { type: 'int' },\r\n        numAccelerations: { type: 'int' },\r\n        numVelocities: { type: 'int' },\r\n        numTimes: { type: 'int' },\r\n        stationConnectivity: { type: 'int' },\r\n        latitudeConnectivity: { type: 'int' },\r\n        velocityRanges: { type: 'float', length: NUM_VELOCITY_RANGES + 1 },\r\n        timeRanges: { type: 'float', length: NUM_TIME_RANGES + 1 },\r\n        station: { type: 'int' } // Updated in `drawProxy`\r\n      }),\r\n      drawProxy: (gpgpu, program, draw) => {\r\n        const width = NUM_ACCELERATION_PROFILES * NUM_VELOCITY_RANGES * NUM_TIME_RANGES;\r\n        const height = program.meta.lattice.numLatitudes;\r\n        const costTable = new Float32Array(width * height * program.meta.lattice.numStations * 4);\r\n\r\n        for (let s = 0; s < program.meta.lattice.numStations; s++) {\r\n          gpgpu.updateProgramUniforms(program, { station: s });\r\n          draw();\r\n\r\n          gpgpu.gl.readPixels(0, 0, width, height, gpgpu.gl.RGBA, gpgpu.gl.FLOAT, costTable, s * width * height * 4);\r\n\r\n          gpgpu.gl.bindTexture(gpgpu.gl.TEXTURE_2D_ARRAY, gpgpu.sharedTextures.costTable);\r\n          gpgpu.gl.copyTexSubImage3D(gpgpu.gl.TEXTURE_2D_ARRAY, 0, 0, 0, s, 0, 0, width, height);\r\n        }\r\n\r\n        gpgpu._graphSearchCostTable = costTable;\r\n      }\r\n    };\r\n  },\r\n\r\n  update(config, pose, xyCenterPoint, slCenterPoint, firstLatticePoint, secondLatticePoint, dynamicFrameTime) {\r\n    return {\r\n      width: NUM_ACCELERATION_PROFILES * NUM_VELOCITY_RANGES * NUM_TIME_RANGES,\r\n      height: config.lattice.numLatitudes,\r\n      meta: {\r\n        lattice: config.lattice\r\n      },\r\n      uniforms: Object.assign({}, buildUniformValues(config, xyCenterPoint, slCenterPoint, dynamicFrameTime), {\r\n        firstLatticePoint: firstLatticePoint,\r\n        secondLatticePoint: secondLatticePoint,\r\n        velocityVehicle: pose.velocity,\r\n        curvVehicle: pose.curv,\r\n        dCurvVehicle: pose.dCurv,\r\n        ddCurvVehicle: pose.ddCurv,\r\n        extraTimePenalty: config.extraTimePenalty,\r\n        hysteresisDiscount: config.hysteresisDiscount,\r\n        accelerationChangePenalty: config.accelerationChangePenalty,\r\n        numStations: config.lattice.numStations,\r\n        numLatitudes: config.lattice.numLatitudes,\r\n        numAccelerations: NUM_ACCELERATION_PROFILES,\r\n        numVelocities: NUM_VELOCITY_RANGES,\r\n        numTimes: NUM_TIME_RANGES,\r\n        stationConnectivity: config.lattice.stationConnectivity,\r\n        latitudeConnectivity: config.lattice.latitudeConnectivity,\r\n        velocityRanges: [0, config.speedLimit / 3, config.speedLimit * 2 / 3, config.speedLimit, 1000000],\r\n        timeRanges: [0, 10, 1000000]\r\n      })\r\n    };\r\n  }\r\n});\r\n\n;// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/xyObstacleCostGrid.js\nconst XY_OBSTACLE_COST_KERNEL = `\r\n\r\nvec4 kernel() {\r\n  vec2 xy = (kernelPosition - 0.5) * vec2(kernelSize) * vec2(xyGridCellSize) + xyCenterPoint;\r\n\r\n  vec2 xyTexCoords = (xy - xyCenterPoint) / vec2(textureSize(xyslMap, 0)) / vec2(xyGridCellSize) + 0.5;\r\n  vec2 sl = texture(xyslMap, xyTexCoords).xy;\r\n\r\n  vec2 slTexCoords = (sl - slCenterPoint) / vec2(textureSize(slObstacleGrid, 0)) / vec2(slGridCellSize) + 0.5;\r\n  return texture(slObstacleGrid, slTexCoords);\r\n}\r\n\r\n`;\r\n\r\n// Build XY obstacle costs using XYSL map\r\n/* harmony default export */ const xyObstacleCostGrid = ({\r\n  setUp() {\r\n    return {\r\n      kernel: XY_OBSTACLE_COST_KERNEL,\r\n      output: { name: 'xyObstacleCostGrid', read: true },\r\n      uniforms: {\r\n        xyslMap: { type: 'outputTexture' },\r\n        slObstacleGrid: { type: 'outputTexture', name: 'slObstacleGridDilated' },\r\n        xyCenterPoint: { type: 'vec2' },\r\n        xyGridCellSize: { type: 'float'},\r\n        slCenterPoint: { type: 'vec2' },\r\n        slGridCellSize: { type: 'float'}\r\n      }\r\n    };\r\n  },\r\n\r\n  update(config, xyWidth, xyHeight, xyCenterPoint, slCenterPoint) {\r\n    return {\r\n      width: xyWidth,\r\n      height: xyHeight,\r\n      uniforms: {\r\n        xyCenterPoint: [xyCenterPoint.x, xyCenterPoint.y],\r\n        xyGridCellSize: config.xyGridCellSize,\r\n        slCenterPoint: [slCenterPoint.x, slCenterPoint.y],\r\n        slGridCellSize: config.slGridCellSize\r\n      }\r\n    };\r\n  }\r\n});\r\n\n;// CONCATENATED MODULE: ./js/autonomy/path-planning/PathPlanner.js\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst PathPlanner_NUM_ACCELERATION_PROFILES = 8;\r\nconst PathPlanner_NUM_VELOCITY_RANGES = 4;\r\nconst PathPlanner_NUM_TIME_RANGES = 2;\r\n\r\n/* Obstacle cost map:\r\n *\r\n * 1. Rasterize triangles from polygonal obstacles into XY-space occupancy grid\r\n * 2. Convert occupancy grid to SL-space\r\n *    * Width is spatial horizon of the state lattice\r\n *    * Height is lane width\r\n *    * Resolution should be higher than XY-grid\r\n *    * Get XY position from centerline texture\r\n *    * Lookup XY in XY occupancy grid (nearest)\r\n * 3. Dilate SL-space grid using two passes (along station, then along latitude)\r\n *    * collision area: half car size + 0.3m\r\n *    * high cost area: 1 meter\r\n * 4. Convert back to XY-space using XYSL map\r\n */\r\n\r\nclass PathPlanner {\r\n  constructor() {\r\n    this.previousStartStation = null;\r\n    this.previousFirstLatticePoint = -1;\r\n    this.previousSecondLatticePoint = -1;\r\n    this.previousFirstAcceleration = -1;\r\n    this.previousSecondLatticePoint = -1;\r\n\r\n    let start = performance.now();\r\n    const programs = [\r\n      xyObstacleGrid.setUp(),\r\n      slObstacleGrid.setUp(),\r\n      ...slObstacleGridDilation.setUp(),\r\n      slDynamicObstacleGrid.setUp(),\r\n      xyslMap.setUp(),\r\n      ...optimizeCubicPaths.setUp(),\r\n      optimizeQuinticPaths.setUp(),\r\n      ...pathFromVehicleCosts.setUp(),\r\n      graphSearch.setUp(),\r\n    ].map(p => Object.assign({}, p, { width: 1, height: 1 }));\r\n\r\n    this.gpgpu = new GPGPU(programs);\r\n  }\r\n\r\n  reset() {\r\n    this.previousStartStation = null;\r\n    this.previousFirstLatticePoint = -1;\r\n    this.previousSecondLatticePoint = -1;\r\n    this.previousFirstAcceleration = -1;\r\n    this.previousSecondLatticePoint = -1;\r\n  }\r\n\r\n  plan(vehiclePose, vehicleStation, lanePath, startTime, staticObstacles, dynamicObstacles) {\r\n    const latticeStationInterval = this._latticeStationInterval();\r\n\r\n    const centerlineRaw = lanePath.sampleStations(vehicleStation, Math.ceil((this.config.spatialHorizon + latticeStationInterval) / this.config.centerlineStationInterval) + 1, this.config.centerlineStationInterval);\r\n\r\n    // Transform all centerline points into vehicle frame\r\n    const vehicleXform = vehicleTransform(vehiclePose);\r\n    const centerline = centerlineRaw.map(c => { return { pos: c.pos.clone().applyMatrix3(vehicleXform), rot: c.rot - vehiclePose.rot, curv: c.curv } });\r\n\r\n    const centerlineData = new Float32Array(centerline.length * 3);\r\n    const maxPoint = new THREE.Vector2(0, 0);\r\n    const minPoint = new THREE.Vector2(0, 0);\r\n\r\n    for (let i = 0; i < centerline.length; i++) {\r\n      const sample = centerline[i];\r\n      const pos = sample.pos;\r\n      centerlineData[i * 3 + 0] = pos.x;\r\n      centerlineData[i * 3 + 1] = pos.y;\r\n      centerlineData[i * 3 + 2] = sample.rot;\r\n\r\n      maxPoint.max(pos);\r\n      minPoint.min(pos);\r\n    }\r\n\r\n    const diff = maxPoint.clone().sub(minPoint);\r\n    const xyCenterPoint = minPoint.clone().add(maxPoint).divideScalar(2);\r\n\r\n    // Sizes of the xy grids (in pixels, not meters)\r\n    const xyWidth = Math.ceil((diff.x + this.config.gridMargin * 2) / this.config.xyGridCellSize);\r\n    const xyHeight = Math.ceil((diff.y + this.config.gridMargin * 2) / this.config.xyGridCellSize);\r\n\r\n    const stationWidth = this.config.spatialHorizon + latticeStationInterval * 2;\r\n    const slCenterPoint = new THREE.Vector2(this.config.spatialHorizon / 2, 0);\r\n\r\n    // Sizes of the sl grids (in pixels, not meters)\r\n    const slWidth = Math.ceil(stationWidth / this.config.slGridCellSize);\r\n    const slHeight = Math.ceil((this.config.roadWidth + this.config.gridMargin * 2) / this.config.slGridCellSize);\r\n\r\n    let startStation;\r\n\r\n    if (this.previousStartStation === null || vehicleStation + latticeStationInterval / 2 > this.previousStartStation) {\r\n      startStation = (this.previousStartStation === null ? vehicleStation : this.previousStartStation) + latticeStationInterval;\r\n      this.previousStartStation = startStation;\r\n      this.previousFirstLatticePoint -= this.config.lattice.numLatitudes;\r\n      this.previousSecondLatticePoint -= this.config.lattice.numLatitudes;\r\n    } else {\r\n      startStation = this.previousStartStation;\r\n    }\r\n\r\n    const lattice = this._buildLattice(lanePath, startStation, vehiclePose.rot, vehicleXform);\r\n\r\n    const temporalHorizon = this.config.spatialHorizon / this.config.speedLimit;\r\n    const dynamicFrameTime = temporalHorizon / this.config.numDynamicFrames;\r\n\r\n    for (const [i, p] of [\r\n      xyObstacleGrid.update(this.config, xyWidth, xyHeight, xyCenterPoint, vehicleXform, staticObstacles),\r\n      slObstacleGrid.update(this.config, slWidth, slHeight, slCenterPoint, xyCenterPoint),\r\n      ...slObstacleGridDilation.update(this.config, slWidth, slHeight),\r\n      slDynamicObstacleGrid.update(this.config, slWidth, slHeight, slCenterPoint, vehicleStation, startTime, dynamicFrameTime, dynamicObstacles),\r\n      xyslMap.update(this.config, xyWidth, xyHeight, xyCenterPoint),\r\n      ...optimizeCubicPaths.update(this.config, vehiclePose),\r\n      optimizeQuinticPaths.update(this.config, vehiclePose),\r\n      ...pathFromVehicleCosts.update(this.config, vehiclePose, xyCenterPoint, slCenterPoint, this.previousFirstLatticePoint, this.previousSecondLatticePoint, dynamicFrameTime),\r\n      graphSearch.update(this.config, vehiclePose, xyCenterPoint, slCenterPoint, this.previousFirstLatticePoint, this.previousSecondLatticePoint, dynamicFrameTime)\r\n    ].entries()) {\r\n      this.gpgpu.updateProgram(i, p);\r\n    }\r\n\r\n    this.gpgpu.updateSharedTextures({\r\n      centerline: {\r\n        width: centerline.length,\r\n        height: 1,\r\n        channels: 3,\r\n        filter: 'linear',\r\n        data: centerlineData\r\n      },\r\n      costTable: {\r\n        width: PathPlanner_NUM_ACCELERATION_PROFILES * PathPlanner_NUM_VELOCITY_RANGES * PathPlanner_NUM_TIME_RANGES,\r\n        height: this.config.lattice.numLatitudes,\r\n        depth: this.config.lattice.numStations,\r\n        channels: 4,\r\n        textureType: '2DArray'\r\n      },\r\n      lattice: {\r\n        width: this.config.lattice.numLatitudes,\r\n        height: this.config.lattice.numStations,\r\n        channels: 4,\r\n        data: lattice\r\n      }\r\n    });\r\n\r\n    this.gpgpu._graphSearchCostTable = null;\r\n    this.gpgpu._dynamicObstacleGrid = null;\r\n\r\n    let start = performance.now();\r\n    const outputs = this.gpgpu.run();\r\n    const costTable = this.gpgpu._graphSearchCostTable;\r\n    const cubicPathParams = outputs[6];\r\n    const cubicPathFromVehicleParams = outputs[7];\r\n    const quinticPathFromVehicleParams = outputs[8];\r\n\r\n    let bestEntry = [Number.POSITIVE_INFINITY];\r\n    let bestEntryIndex;\r\n    const numEntries = costTable.length / 4;\r\n\r\n    for (let i = 0; i < numEntries; i++) {\r\n      const entryUnpacked = this._unpackCostTableIndex(i);\r\n      const entry = [\r\n        costTable[i * 4],\r\n        costTable[i * 4 + 1],\r\n        costTable[i * 4 + 2],\r\n        costTable[i * 4 + 3]\r\n      ];\r\n\r\n      if (entry[0] < 0) continue;\r\n\r\n      entry[0] += this._terminalCost(entryUnpacked, entry);\r\n\r\n      if (entry[0] < bestEntry[0]) {\r\n        bestEntryIndex = i;\r\n        bestEntry = entry;\r\n      }\r\n    }\r\n\r\n    const inverseVehicleXform = (new THREE.Matrix3()).getInverse(vehicleXform);\r\n    let bestTrajectory = null;\r\n    let fromVehicleSegment = null;\r\n    let fromVehicleParams = null;\r\n    let firstLatticePoint = -1;\r\n    let firstAcceleration = -1;\r\n    let secondLatticePoint = -1;\r\n    let secondAcceleration = -1;\r\n\r\n    if (isFinite(bestEntry[0])) {\r\n      [bestTrajectory, fromVehicleSegment, fromVehicleParams, firstLatticePoint, firstAcceleration, secondLatticePoint, secondAcceleration] = this._reconstructTrajectory(\r\n        bestEntryIndex,\r\n        costTable,\r\n        cubicPathParams,\r\n        cubicPathFromVehicleParams,\r\n        quinticPathFromVehicleParams,\r\n        vehiclePose,\r\n        lattice\r\n      );\r\n\r\n      fromVehicleSegment.forEach(p => {\r\n        p.pos = p.pos.applyMatrix3(inverseVehicleXform);\r\n        p.rot += vehiclePose.rot;\r\n      });\r\n\r\n      bestTrajectory.forEach(p => {\r\n        p.pos = p.pos.applyMatrix3(inverseVehicleXform);\r\n        p.rot += vehiclePose.rot;\r\n      });\r\n    }\r\n\r\n    this.previousFirstLatticePoint = firstLatticePoint;\r\n    this.previousFirstAcceleration = firstAcceleration;\r\n    this.previousSecondLatticePoint = secondLatticePoint;\r\n    this.previousSecondAcceleration = secondAcceleration;\r\n\r\n    return {\r\n      path: bestTrajectory,\r\n      fromVehicleSegment: fromVehicleSegment,\r\n      fromVehicleParams: fromVehicleParams,\r\n      latticeStartStation: this.previousStartStation,\r\n      dynamicObstacleGrid: { data: this.gpgpu._dynamicObstacleGrid, width: slWidth, height: slHeight }\r\n    };\r\n  }\r\n\r\n  _buildLattice(lanePath, startStation, vehicleRot, vehicleXform) {\r\n    const centerline = lanePath.sampleStations(startStation, this.config.lattice.numStations, this._latticeStationInterval());\r\n    const offset = Math.floor(this.config.lattice.numLatitudes / 2);\r\n    const lattice = new Float32Array(this.config.lattice.numStations * this.config.lattice.numLatitudes * 4);\r\n    let index = 0;\r\n\r\n    for (let s = 0; s < centerline.length; s++) {\r\n      const sample = centerline[s];\r\n\r\n      for (let l = 0; l < this.config.lattice.numLatitudes; l++) {\r\n        const latitude = (l - offset) / offset * this.config.roadWidth / 2;\r\n        const rot = sample.rot - vehicleRot;\r\n        const pos = THREE.Vector2.fromAngle(rot + Math.PI / 2).multiplyScalar(latitude).add(sample.pos.clone().applyMatrix3(vehicleXform));\r\n        const curv = sample.curv == 0 ? 0 : 1 / (1 / sample.curv - latitude);\r\n\r\n        lattice[index++] = pos.x;\r\n        lattice[index++] = pos.y;\r\n        lattice[index++] = rot;\r\n        lattice[index++] = curv;\r\n      }\r\n    }\r\n\r\n    return lattice;\r\n  }\r\n\r\n  _latticeStationInterval() {\r\n    return this.config.spatialHorizon / this.config.lattice.numStations;\r\n  }\r\n\r\n  _terminalCost([stationIndex, latitudeIndex, timeIndex, velocityIndex, accelerationIndex], [cost, finalVelocity, finalTime, incomingIndex]) {\r\n    // Only consider vertices that reach the end of the spatial or temporal horizon\r\n    if (stationIndex != this.config.lattice.numStations - 1 && finalVelocity > 0.05)\r\n      return Number.POSITIVE_INFINITY;\r\n\r\n    const station = (this.config.spatialHorizon / this.config.lattice.numStations) * (stationIndex + 1);\r\n\r\n    return station * -this.config.stationReachDiscount + finalTime * this.config.extraTimePenalty;\r\n  }\r\n\r\n  _unpackCostTableIndex(index) {\r\n    if (index < 0) return [-1, index + 2, null, null, null];\r\n\r\n    const numPerTime = PathPlanner_NUM_ACCELERATION_PROFILES * PathPlanner_NUM_VELOCITY_RANGES;\r\n    const numPerLatitude = numPerTime * PathPlanner_NUM_TIME_RANGES;\r\n    const numPerStation = this.config.lattice.numLatitudes * numPerLatitude;\r\n\r\n    const stationIndex = Math.floor(index / numPerStation);\r\n    index -= stationIndex * numPerStation;\r\n\r\n    const latitudeIndex = Math.floor(index / numPerLatitude);\r\n    index -= latitudeIndex * numPerLatitude;\r\n\r\n    const timeIndex = Math.floor(index / numPerTime);\r\n    index -= timeIndex * numPerTime;\r\n\r\n    const velocityIndex = Math.floor(index / PathPlanner_NUM_ACCELERATION_PROFILES);\r\n    const accelerationIndex = index % PathPlanner_NUM_ACCELERATION_PROFILES;\r\n\r\n    return [stationIndex, latitudeIndex, timeIndex, velocityIndex, accelerationIndex];\r\n  }\r\n\r\n  _reconstructTrajectory(index, costTable, cubicPathParams, cubicPathFromVehicleParams, quinticPathFromVehicleParams, vehiclePose, lattice) {\r\n    let unpacked = this._unpackCostTableIndex(index);\r\n    unpacked.push(costTable[index * 4 + 1]);\r\n    const nodes = [unpacked];\r\n\r\n    let count = 0;\r\n    while (unpacked[0] >= 0 && count++ < 100) {\r\n      index = costTable[index * 4 + 3];\r\n      unpacked = this._unpackCostTableIndex(index);\r\n\r\n      const finalVelocity = unpacked[0] >= 0 ? costTable[index * 4 + 1] : vehiclePose.velocity;\r\n      unpacked.push(finalVelocity);\r\n\r\n      nodes.unshift(unpacked);\r\n    }\r\n    if (count >= 100) throw new Error('Infinite loop encountered while reconstructing trajectory.');\r\n\r\n    const points = [];\r\n    let fromVehicleSegment = [];\r\n    let fromVehicleParams = null;\r\n\r\n    for (let i = 0; i < nodes.length - 1; i++) {\r\n      const [prevStation, prevLatitude, _pt, _pv, _pa, prevVelocity] = nodes[i];\r\n      const [station, latitude, _t, _v, _a, velocity] = nodes[i + 1];\r\n\r\n      let length;\r\n      let pathBuilder;\r\n\r\n      if (prevStation < 0) {\r\n        const start = {\r\n          pos: new THREE.Vector2(0, 0),\r\n          rot: 0,\r\n          curv: vehiclePose.curv\r\n        };\r\n\r\n        const endIndex = (station * this.config.lattice.numLatitudes + latitude) * 4;\r\n        const end = {\r\n          pos: new THREE.Vector2(lattice[endIndex], lattice[endIndex + 1]),\r\n          rot: lattice[endIndex + 2],\r\n          curv: lattice[endIndex + 3]\r\n        };\r\n\r\n        if (prevLatitude == 0) { // Cubic path from vehicle to lattice node\r\n          length = cubicPathFromVehicleParams[endIndex + 2];\r\n\r\n          const params = {\r\n            p1: cubicPathFromVehicleParams[endIndex],\r\n            p2: cubicPathFromVehicleParams[endIndex + 1],\r\n            sG: length\r\n          };\r\n\r\n          pathBuilder = new CubicPath(start, end, params);\r\n\r\n          fromVehicleParams = { type: 'cubic', params: params };\r\n        } else { // Quintic path from vehicle to lattice node\r\n          length = quinticPathFromVehicleParams[endIndex + 2];\r\n\r\n          const params = {\r\n            p3: quinticPathFromVehicleParams[endIndex],\r\n            p4: quinticPathFromVehicleParams[endIndex + 1],\r\n            sG: length\r\n          };\r\n\r\n          pathBuilder = new QuinticPath(start, end, params);\r\n\r\n          fromVehicleParams = { type: 'quintic', params: params };\r\n        }\r\n      } else {\r\n        const startIndex = (prevStation * this.config.lattice.numLatitudes + prevLatitude) * 4;\r\n        const endIndex = (station * this.config.lattice.numLatitudes + latitude) * 4;\r\n\r\n        const start = {\r\n          pos: new THREE.Vector2(lattice[startIndex], lattice[startIndex + 1]),\r\n          rot: lattice[startIndex + 2],\r\n          curv: lattice[startIndex + 3]\r\n        };\r\n\r\n        const end = {\r\n          pos: new THREE.Vector2(lattice[endIndex], lattice[endIndex + 1]),\r\n          rot: lattice[endIndex + 2],\r\n          curv: lattice[endIndex + 3]\r\n        };\r\n\r\n        const slIndex = station * this.config.lattice.numLatitudes + latitude;\r\n        const connectivityIndex = (prevStation - station + this.config.lattice.stationConnectivity) * this.config.lattice.latitudeConnectivity + prevLatitude - latitude + Math.floor(this.config.lattice.latitudeConnectivity / 2);\r\n        const cubicPathIndex = (connectivityIndex * this.config.lattice.numStations * this.config.lattice.numLatitudes + slIndex) * 4;\r\n\r\n        length = cubicPathParams[cubicPathIndex + 2];\r\n\r\n        pathBuilder = new CubicPath(start, end, {\r\n          p1: cubicPathParams[cubicPathIndex],\r\n          p2: cubicPathParams[cubicPathIndex + 1],\r\n          sG: length\r\n        });\r\n      }\r\n\r\n      const path = pathBuilder.buildPath(Math.ceil(length / 0.25));\r\n\r\n      const prevVelocitySq = prevVelocity * prevVelocity;\r\n      const accel = (velocity * velocity - prevVelocitySq) / 2 / length;\r\n      const ds = length / (path.length - 1);\r\n      let s = 0;\r\n\r\n      for (let p = 0; p < path.length; p++) {\r\n        path[p].velocity = Math.sqrt(2 * accel * s + prevVelocitySq);\r\n        path[p].acceleration = accel;\r\n        s += ds;\r\n      }\r\n\r\n      if (prevStation < 0) {\r\n        fromVehicleSegment = path;\r\n      } else {\r\n        if (i > 0) path.shift();\r\n        points.push(...path);\r\n      }\r\n    }\r\n\r\n    let firstLatticePoint = null\r\n    let firstAcceleration = null;\r\n    let secondLatticePoint = null;\r\n    let secondAcceleration = null;\r\n\r\n    if (nodes.length >= 2) {\r\n      firstLatticePoint = nodes[1][0] * this.config.lattice.numLatitudes + nodes[1][1];\r\n      firstAcceleration = nodes[1][4];\r\n    }\r\n\r\n    if (nodes.length >= 3) {\r\n      secondLatticePoint = nodes[2][0] * this.config.lattice.numLatitudes + nodes[2][1];\r\n      secondAcceleration = nodes[2][4];\r\n    }\r\n\r\n    return [points, fromVehicleSegment, fromVehicleParams, firstLatticePoint, firstAcceleration, secondLatticePoint, secondAcceleration];\r\n  }\r\n}\r\n\r\nfunction vehicleTransform({ pos, rot }) {\r\n  const translate = new THREE.Matrix3();\r\n  translate.set(\r\n    1, 0, -pos.x,\r\n    0, 1, -pos.y,\r\n    0, 0, 1\r\n  );\r\n\r\n  const cosRot = Math.cos(rot);\r\n  const sinRot = Math.sin(rot);\r\n\r\n  const rotate = new THREE.Matrix3();\r\n  rotate.set(\r\n    cosRot, sinRot, 0,\r\n    -sinRot, cosRot, 0,\r\n    0, 0, 1\r\n  );\r\n\r\n  return rotate.multiply(translate);\r\n}\r\n\r\nfunction obstacleTransform(vehicleXform, xyCenterPoint, width, height) {\r\n  const translate = new THREE.Matrix3();\r\n  translate.set(\r\n    1, 0, -xyCenterPoint.x,\r\n    0, 1, -xyCenterPoint.y,\r\n    0, 0, 1\r\n  );\r\n\r\n  const scale = new THREE.Matrix3();\r\n  scale.set(\r\n    2 / width, 0, 0,\r\n    0, 2 / height, 0,\r\n    0, 0, 1\r\n  );\r\n\r\n  return scale.multiply(translate).multiply(vehicleXform);\r\n}\r\n\n;// CONCATENATED MODULE: ./js/autonomy/LanePath.js\nconst halfLaneWidth = 3.7;\r\n\r\nconst centerlineGeometry = new THREE.Geometry();\r\nconst leftBoundaryGeometry = new THREE.Geometry();\r\nconst rightBoundaryGeometry = new THREE.Geometry();\r\n\r\nclass LanePath {\r\n  static hydrate(obj) {\r\n    Object.setPrototypeOf(obj, LanePath.prototype);\r\n  }\r\n\r\n  constructor() {\r\n    this.anchors = [];\r\n    this.centerlines = [];\r\n    this.sampleLengths = [];\r\n    this.arcLengths = [];\r\n    this.leftBoundaries = [];\r\n    this.rightBoundaries = [];\r\n  }\r\n\r\n  get centerline() {\r\n    return [].concat(...this.centerlines);\r\n  }\r\n\r\n  get leftBoundary() {\r\n    return [].concat(...this.leftBoundaries);\r\n  }\r\n\r\n  get rightBoundary() {\r\n    return [].concat(...this.rightBoundaries);\r\n  }\r\n\r\n  get arcLength() {\r\n    return this.arcLengths.reduce((sum, l) => sum + l, 0);\r\n  }\r\n\r\n  sampleStations(startStation, num, interval) {\r\n    const samples = [];\r\n    let anchorIndex = 0;\r\n    let sampleIndex = 0;\r\n    let totalLength = 0;\r\n    let nextStation = startStation;\r\n\r\n    while (totalLength + this.arcLengths[anchorIndex] < nextStation) {\r\n      totalLength += this.arcLengths[anchorIndex];\r\n\r\n      if (++anchorIndex >= this.arcLengths.length)\r\n        return samples;\r\n    }\r\n\r\n    for (let i = 0; i < num; i++) {\r\n      let length = this.sampleLengths[anchorIndex][sampleIndex];\r\n      while (totalLength + length < nextStation) {\r\n        totalLength += length;\r\n\r\n        if (++sampleIndex >= this.sampleLengths[anchorIndex].length) {\r\n          sampleIndex = 0;\r\n\r\n          if (++anchorIndex >= this.sampleLengths.length)\r\n            return samples;\r\n        }\r\n\r\n        length = this.sampleLengths[anchorIndex][sampleIndex];\r\n      }\r\n\r\n      const [p0, p1, p2, p3] = this.anchorsForSplineIndex(anchorIndex);\r\n      const weight = (sampleIndex + (nextStation - totalLength) / length) / this.sampleLengths[anchorIndex].length;\r\n      const pos = catmullRomVec(weight, p0, p1, p2, p3);\r\n      const tangent = tangentAt(weight, p0, p1, p2, p3);\r\n      const rot = Math.atan2(tangent.y, tangent.x);\r\n      const curv = curvatureAt(weight, p0, p1, p2, p3);\r\n\r\n      samples.push({ pos, rot, curv });\r\n      nextStation += interval;\r\n    }\r\n\r\n    return samples;\r\n  }\r\n\r\n  stationLatitudeFromPosition(position, aroundAnchorIndex = null) {\r\n    const [anchorIndex, sampleIndex, sampleStation, prevSampleStation] = this._findClosestSample(position, aroundAnchorIndex);\r\n\r\n    if (anchorIndex === undefined) return [0, 0, 0];\r\n\r\n    let prevPoint;\r\n    let nextPoint;\r\n    let prevStation;\r\n    let nextStation;\r\n\r\n    if (anchorIndex == 0 && sampleIndex == 0) {\r\n      prevPoint = this.centerlines[anchorIndex][sampleIndex];\r\n      nextPoint = this.centerlines[anchorIndex][sampleIndex + 1];\r\n      prevStation = 0;\r\n      nextStation = this.sampleLengths[anchorIndex][sampleIndex];\r\n    } else if (anchorIndex == this.centerlines.length - 1 && sampleIndex == this.centerlines[anchorIndex].length - 1) {\r\n      prevPoint = this.centerlines[anchorIndex][sampleIndex - 1];\r\n      nextPoint = this.centerlines[anchorIndex][sampleIndex];\r\n      prevStation = prevSampleStation;\r\n      nextStation = sampleStation;\r\n    } else {\r\n      prevPoint = sampleIndex == 0 ? this.centerlines[anchorIndex - 1][this.centerlines[anchorIndex - 1].length - 1] : this.centerlines[anchorIndex][sampleIndex - 1];\r\n      nextPoint = sampleIndex == this.centerlines[anchorIndex].length - 1 ? this.centerlines[anchorIndex + 1][0] : this.centerlines[anchorIndex][sampleIndex + 1];\r\n\r\n      const possibleNext = this.centerlines[anchorIndex][sampleIndex];\r\n      const possibleProgress = position.clone().sub(prevPoint).dot(possibleNext.clone().sub(prevPoint)) / prevPoint.distanceToSquared(possibleNext);\r\n\r\n      if (possibleProgress < 1) {\r\n        nextPoint = possibleNext;\r\n        prevStation = prevSampleStation;\r\n        nextStation = sampleStation;\r\n      } else {\r\n        prevPoint = possibleNext;\r\n        prevStation = sampleStation;\r\n        nextStation = sampleStation + this.sampleLengths[anchorIndex][sampleIndex];\r\n      }\r\n    }\r\n\r\n    const progress = Math.clamp(position.clone().sub(prevPoint).dot(nextPoint.clone().sub(prevPoint)) / prevPoint.distanceToSquared(nextPoint), 0, 1);\r\n    const projectedPosition = nextPoint.clone().sub(prevPoint).multiplyScalar(progress).add(prevPoint);\r\n\r\n    const station = prevStation + (nextStation - prevStation) * progress;\r\n    const latitude = Math.sign((nextPoint.x - prevPoint.x) * (position.y - prevPoint.y) - (nextPoint.y - prevPoint.y) * (position.x - prevPoint.x)) * position.distanceTo(projectedPosition);\r\n\r\n    return [station, latitude, anchorIndex];\r\n  }\r\n\r\n  _findClosestSample(position, aroundAnchorIndex = null) {\r\n    let closest = Number.POSITIVE_INFINITY;\r\n    let bestAnchorIndex;\r\n    let bestSampleIndex;\r\n    let bestStation;\r\n    let bestPrevStation;\r\n\r\n    let currStation = 0;\r\n    let prevStation = 0;\r\n\r\n    let startAnchorIndex = 0;\r\n    let endAnchorIndex = this.centerlines.length - 1;\r\n\r\n    if (aroundAnchorIndex !== null) {\r\n      startAnchorIndex = Math.max(0, aroundAnchorIndex - 2);\r\n      endAnchorIndex = Math.min(this.centerlines.length - 1, aroundAnchorIndex + 2);\r\n    }\r\n\r\n    if (startAnchorIndex > 0) {\r\n      for (let anchorIndex = 0; anchorIndex < startAnchorIndex; anchorIndex++) {\r\n        currStation += this.arcLengths[anchorIndex];\r\n      }\r\n\r\n      prevStation = currStation - this.sampleLengths[startAnchorIndex - 1][this.sampleLengths[startAnchorIndex - 1].length - 1];\r\n    }\r\n\r\n    for (let anchorIndex = startAnchorIndex; anchorIndex <= endAnchorIndex; anchorIndex++) {\r\n      const centerline = this.centerlines[anchorIndex];\r\n      for (let sampleIndex = 0; sampleIndex < centerline.length; sampleIndex++) {\r\n        const distSq = position.distanceToSquared(centerline[sampleIndex]);\r\n        if (distSq < closest) {\r\n          closest = distSq;\r\n          bestAnchorIndex = anchorIndex;\r\n          bestSampleIndex = sampleIndex;\r\n          bestStation = currStation;\r\n          bestPrevStation = prevStation;\r\n        }\r\n\r\n        prevStation = currStation;\r\n        currStation += this.sampleLengths[anchorIndex][sampleIndex];\r\n      }\r\n    }\r\n\r\n    return [bestAnchorIndex, bestSampleIndex, bestStation, bestPrevStation];\r\n  }\r\n\r\n  addAnchor(position, resample = true) {\r\n    const index = this.anchors.push(position) - 1;\r\n\r\n    if (resample) {\r\n      for (let i = index - 2; i < index; i++)\r\n        this.resample(i);\r\n    }\r\n  }\r\n\r\n  updateAnchor(index, position) {\r\n    this.anchors[index] = position;\r\n\r\n    for (let i = index - 2; i <= index + 1; i++)\r\n      this.resample(i);\r\n  }\r\n\r\n  removeAnchor(index) {\r\n    if (index < 0 || index >= this.anchors.length) return;\r\n\r\n    this.anchors.splice(index, 1);\r\n\r\n    const segmentIndex = index < this.anchors.length ? index : index - 1;\r\n    this.centerlines.splice(segmentIndex, 1);\r\n    this.sampleLengths.splice(segmentIndex, 1);\r\n    this.leftBoundaries.splice(segmentIndex, 1);\r\n    this.rightBoundaries.splice(segmentIndex, 1);\r\n    this.arcLengths.splice(segmentIndex, 1);\r\n\r\n    for (let i = segmentIndex - 2; i <= segmentIndex; i++)\r\n      this.resample(i);\r\n  }\r\n\r\n  resample(index) {\r\n    if (index < 0 || index > this.anchors.length - 2) return;\r\n\r\n    const [p0, p1, p2, p3] = this.anchorsForSplineIndex(index);\r\n    const points = [];\r\n    const lengths = [];\r\n    const leftBoundary = [];\r\n    const rightBoundary = [];\r\n    let prevPoint = null;\r\n\r\n    const pointsPerSegment = Math.max(10, Math.ceil(p1.distanceTo(p2) / 1));\r\n    const numPoints = index == this.anchors.length - 2 ? pointsPerSegment + 1 : pointsPerSegment;\r\n\r\n    for (let i = 0; i < numPoints; i++) {\r\n      const t = i / pointsPerSegment;\r\n      const point = catmullRomVec(t, p0, p1, p2, p3);\r\n      points.push(point);\r\n\r\n      if (prevPoint != null)\r\n        lengths.push(prevPoint.distanceTo(point));\r\n      prevPoint = point;\r\n\r\n      const tangent = tangentAt(t, p0, p1, p2, p3);\r\n      const normal = new THREE.Vector2(-tangent.y, tangent.x);\r\n\r\n      leftBoundary.push(normal.clone().multiplyScalar(-halfLaneWidth).add(point));\r\n      rightBoundary.push(normal.clone().multiplyScalar(halfLaneWidth).add(point));\r\n    }\r\n\r\n    lengths.push(prevPoint.distanceTo(p2));\r\n\r\n    this.centerlines[index] = points;\r\n    this.sampleLengths[index] = lengths;\r\n    this.leftBoundaries[index] = leftBoundary;\r\n    this.rightBoundaries[index] = rightBoundary;\r\n    this.arcLengths[index] = lengths.reduce((sum, l) => sum + l, 0);\r\n  }\r\n\r\n  resampleAll() {\r\n    for (let i = 0; i < this.anchors.length; i++)\r\n      this.resample(i);\r\n  }\r\n\r\n  anchorsForSplineIndex(index) {\r\n    let p;\r\n    if (index == 0)\r\n      p = [this.anchors[0]].concat(this.anchors.slice(0, 3));\r\n    else\r\n      p = this.anchors.slice(index - 1, index + 3);\r\n\r\n    if (p[3] === undefined)\r\n      p[3] = p[2];\r\n\r\n    return p;\r\n  }\r\n}\r\n\r\nfunction catmullRom(t, p0, p1, p2, p3) {\r\n  const v0 = (p2 - p0) * 0.5;\r\n  const v1 = (p3 - p1) * 0.5;\r\n  const t2 = t * t;\r\n  const t3 = t * t2;\r\n  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\r\n}\r\n\r\nfunction catmullRomVec(t, p0, p1, p2, p3) {\r\n  return new THREE.Vector2(catmullRom(t, p0.x, p1.x, p2.x, p3.x), catmullRom(t, p0.y, p1.y, p2.y, p3.y));\r\n}\r\n\r\nfunction tangentAt(t, p0, p1, p2, p3) {\r\n  const delta = 0.0001;\r\n  let t1 = t - delta;\r\n  let t2 = t + delta;\r\n\r\n  if (t1 < 0) t1 = 0;\r\n  if (t2 > 1) t2 = 1;\r\n\r\n  const prev = catmullRomVec(t1, p0, p1, p2, p3);\r\n  const next = catmullRomVec(t2, p0, p1, p2, p3);\r\n\r\n  return next.sub(prev).normalize();\r\n}\r\n\r\nfunction curvatureAt(t2, p0, p1, p2, p3) {\r\n  const delta = 0.0001;\r\n\r\n  // If we're estimating curvature at one of the endpoints of the spline,\r\n  // slightly shift it inwards to avoid infinite curvature.\r\n  if (t2 == 0) t2 = delta;\r\n  if (t2 == 1) t2 = 1 - delta;\r\n\r\n  let t1 = t2 - delta;\r\n  let t3 = t2 + delta;\r\n\r\n  if (t1 < 0) t1 = 0;\r\n  if (t3 > 1) t3 = 1;\r\n\r\n  const pt1 = catmullRomVec(t1, p0, p1, p2, p3);\r\n  const pt2 = catmullRomVec(t2, p0, p1, p2, p3);\r\n  const pt3 = catmullRomVec(t3, p0, p1, p2, p3);\r\n\r\n  return (Math.atan2(pt3.y - pt2.y, pt3.x - pt2.x) - Math.atan2(pt2.y - pt1.y, pt2.x - pt1.x)) / pt2.distanceTo(pt1);\r\n}\r\n\n;// CONCATENATED MODULE: ./js/autonomy/StaticObstacle.js\nclass StaticObstacle {\r\n  static hydrate(obj) {\r\n    Object.setPrototypeOf(obj, StaticObstacle.prototype);\r\n    Object.setPrototypeOf(obj.pos, THREE.Vector2.prototype);\r\n  }\r\n\r\n  static fromJSON(json) {\r\n    return new StaticObstacle(new THREE.Vector2(json.p[0], json.p[1]), json.r, json.w, json.h);\r\n  }\r\n\r\n  constructor(pos, rot, width, height) {\r\n    this.pos = pos;\r\n    this.rot = rot;\r\n    this.width = width;\r\n    this.height = height;\r\n\r\n    this.updateVertices();\r\n  }\r\n\r\n  toJSON() {\r\n    const trunc = n => +n.toFixed(5);\r\n\r\n    return {\r\n      p: [trunc(this.pos.x), trunc(this.pos.y)],\r\n      r: trunc(this.rot),\r\n      w: trunc(this.width),\r\n      h: trunc(this.height)\r\n    };\r\n  }\r\n\r\n  updateVertices() {\r\n    this.vertices = [];\r\n\r\n    const cosRot = Math.cos(this.rot);\r\n    const sinRot = Math.sin(this.rot);\r\n    const halfWidth = this.width / 2;\r\n    const halfHeight = this.height / 2;\r\n\r\n    const hWcR = halfWidth * cosRot;\r\n    const hWsR = halfWidth * sinRot;\r\n    const hHcR = halfHeight * cosRot;\r\n    const hHsR = halfHeight * sinRot;\r\n\r\n    const v1 = [-hWcR - hHsR + this.pos.x, -hWsR + hHcR + this.pos.y];\r\n    const v2 = [-hWcR + hHsR + this.pos.x, -hWsR - hHcR + this.pos.y];\r\n    const v3 = [hWcR + hHsR + this.pos.x, hWsR - hHcR + this.pos.y];\r\n    const v4 = [hWcR - hHsR + this.pos.x, hWsR + hHcR + this.pos.y];\r\n\r\n    this.vertices = [\r\n      v1[0], v1[1],\r\n      v2[0], v2[1],\r\n      v3[0], v3[1],\r\n      v3[0], v3[1],\r\n      v4[0], v4[1],\r\n      v1[0], v1[1]\r\n    ];\r\n  }\r\n}\r\n\n;// CONCATENATED MODULE: ./js/autonomy/DynamicObstacle.js\n// Half width and half height\r\nconst VEHICLE_SIZE = { w: 2.5, h: 1 };\r\nconst CYCLIST_SIZE = { w: 1.2, h: 0.6 };\r\nconst PEDESTRIAN_SIZE = { w: 0.6, h: 0.6 };\r\n\r\nclass DynamicObstacle {\r\n  static hydrate(obj) {\r\n    Object.setPrototypeOf(obj, DynamicObstacle.prototype);\r\n    Object.setPrototypeOf(obj.startPos, THREE.Vector2.prototype);\r\n    Object.setPrototypeOf(obj.velocity, THREE.Vector2.prototype);\r\n  }\r\n\r\n  constructor(type, startPos, velocity, parallel) {\r\n    this.type = type;\r\n    this.startPos = startPos;\r\n    this.velocity = velocity;\r\n    this.parallel = parallel;\r\n\r\n    switch (type) {\r\n        case 'cyclist':\r\n          this.size = Object.assign({}, CYCLIST_SIZE);\r\n          break;\r\n\r\n        case 'pedestrian':\r\n          this.size = Object.assign({}, PEDESTRIAN_SIZE);\r\n          break;\r\n\r\n        default:\r\n          this.size = Object.assign({}, VEHICLE_SIZE);\r\n    }\r\n\r\n    if (!parallel)\r\n      [this.size.w, this.size.h] = [this.size.h, this.size.w];\r\n  }\r\n\r\n  positionAtTime(time) {\r\n    return this.velocity.clone().multiplyScalar(time).add(this.startPos);\r\n  }\r\n\r\n  positionsInTimeRange(startTime, endTime, numFrames) {\r\n    const dt = (endTime - startTime) / numFrames;\r\n    const positions = [];\r\n    let time = startTime;\r\n\r\n    for (let i = 0; i <= numFrames; i++) {\r\n      positions.push(this.positionAtTime(time));\r\n      time += dt;\r\n    }\r\n\r\n    return positions;\r\n  }\r\n\r\n  verticesInTimeRange(startTime, endTime, config) {\r\n    const positions = this.positionsInTimeRange(startTime, endTime, config.numDynamicSubframes);\r\n    const vertices = [];\r\n\r\n    // Hazard dilation (drawn behind, z = 0.75)\r\n    const hazardHalfWidth = this.size.w + config.dynamicHazardDilationS + config.collisionDilationS;\r\n    const hazardHalfHeight = this.size.h + config.dynamicHazardDilationL + config.collisionDilationL;\r\n\r\n    positions.forEach(p => {\r\n      const v1 = [-hazardHalfWidth + p.x, hazardHalfHeight + p.y];\r\n      const v2 = [hazardHalfWidth + p.x, hazardHalfHeight + p.y];\r\n      const v3 = [hazardHalfWidth + p.x, -hazardHalfHeight + p.y];\r\n      const v4 = [-hazardHalfWidth + p.x, -hazardHalfHeight + p.y];\r\n\r\n      vertices.push(\r\n        v1[0], v1[1], 0.75,\r\n        v2[0], v2[1], 0.75,\r\n        v3[0], v3[1], 0.75,\r\n        v3[0], v3[1], 0.75,\r\n        v4[0], v4[1], 0.75,\r\n        v1[0], v1[1], 0.75\r\n      );\r\n    });\r\n    \r\n    // Collision dilation (drawn in front, z = 0.25)\r\n    const collisionHalfWidth = this.size.w + config.collisionDilationS;\r\n    const collisionHalfHeight = this.size.h + config.collisionDilationL;\r\n\r\n    positions.forEach(p => {\r\n      const v1 = [-collisionHalfWidth + p.x, collisionHalfHeight + p.y];\r\n      const v2 = [collisionHalfWidth + p.x, collisionHalfHeight + p.y];\r\n      const v3 = [collisionHalfWidth + p.x, -collisionHalfHeight + p.y];\r\n      const v4 = [-collisionHalfWidth + p.x, -collisionHalfHeight + p.y];\r\n\r\n      vertices.push(\r\n        v1[0], v1[1], 0.25,\r\n        v2[0], v2[1], 0.25,\r\n        v3[0], v3[1], 0.25,\r\n        v3[0], v3[1], 0.25,\r\n        v4[0], v4[1], 0.25,\r\n        v1[0], v1[1], 0.25\r\n      );\r\n    });\r\n\r\n    return vertices;\r\n  }\r\n}\r\n\n;// CONCATENATED MODULE: ./workers/PathPlannerWorker.js\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction init () {\r\n  let pathPlanner;\r\n  try {\r\n    pathPlanner = new PathPlanner();\r\n  } catch (e) {\r\n    console.log('Error initializing path planner:');\r\n    console.log(e);\r\n\r\n    self.postMessage({ error: true });\r\n\r\n    return;\r\n  }\r\n\r\n  self.onmessage = function(event) {\r\n    const { config, vehiclePose, vehicleStation, lanePath, startTime, staticObstacles, dynamicObstacles, reset } = event.data;\r\n\r\n    LanePath.hydrate(lanePath);\r\n    staticObstacles.forEach(o => StaticObstacle.hydrate(o));\r\n    dynamicObstacles.forEach(o => DynamicObstacle.hydrate(o));\r\n\r\n    if (reset) pathPlanner.reset();\r\n\r\n    pathPlanner.config = config;\r\n\r\n    try {\r\n      const { path, fromVehicleSegment, fromVehicleParams, latticeStartStation, dynamicObstacleGrid } = pathPlanner.plan(vehiclePose, vehicleStation, lanePath, startTime, staticObstacles, dynamicObstacles);\r\n\r\n      self.postMessage({ path, fromVehicleSegment, fromVehicleParams, vehiclePose, vehicleStation, latticeStartStation, config, dynamicObstacleGrid });\r\n    } catch (error) {\r\n      console.log('PathPlannerWorker error');\r\n      console.log(error);\r\n    }\r\n  };\r\n};\r\n\r\nif (typeof(window) === 'undefined') {\r\n  init();\r\n} else {\r\n  window.dash_initPathPlannerWorker = init;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aHJlZS1hdnMtZGFzaC8uL2pzL0dQR1BVLmpzPzQ0MmEiLCJ3ZWJwYWNrOi8vdGhyZWUtYXZzLWRhc2gvLi9qcy9waHlzaWNzL0Nhci5qcz8yYzBlIiwid2VicGFjazovL3RocmVlLWF2cy1kYXNoLy4vanMvYXV0b25vbXkvcGF0aC1wbGFubmluZy9DdWJpY1BhdGguanM/OTQwYyIsIndlYnBhY2s6Ly90aHJlZS1hdnMtZGFzaC8uL2pzL2F1dG9ub215L3BhdGgtcGxhbm5pbmcvUXVpbnRpY1BhdGguanM/OGM2NSIsIndlYnBhY2s6Ly90aHJlZS1hdnMtZGFzaC8uL2pzL2F1dG9ub215L3BhdGgtcGxhbm5pbmcvZ3BncHUtcHJvZ3JhbXMveHlPYnN0YWNsZUdyaWQuanM/ZDc4YyIsIndlYnBhY2s6Ly90aHJlZS1hdnMtZGFzaC8uL2pzL2F1dG9ub215L3BhdGgtcGxhbm5pbmcvZ3BncHUtcHJvZ3JhbXMvc2xPYnN0YWNsZUdyaWQuanM/ZTU0YiIsIndlYnBhY2s6Ly90aHJlZS1hdnMtZGFzaC8uL2pzL2F1dG9ub215L3BhdGgtcGxhbm5pbmcvZ3BncHUtcHJvZ3JhbXMvc2xPYnN0YWNsZUdyaWREaWxhdGlvbi5qcz8xNzQ5Iiwid2VicGFjazovL3RocmVlLWF2cy1kYXNoLy4vanMvYXV0b25vbXkvcGF0aC1wbGFubmluZy9ncGdwdS1wcm9ncmFtcy9zbER5bmFtaWNPYnN0YWNsZUdyaWQuanM/NmMwZSIsIndlYnBhY2s6Ly90aHJlZS1hdnMtZGFzaC8uL2pzL2F1dG9ub215L3BhdGgtcGxhbm5pbmcvZ3BncHUtcHJvZ3JhbXMveHlzbE1hcC5qcz81YmE5Iiwid2VicGFjazovL3RocmVlLWF2cy1kYXNoLy4vanMvYXV0b25vbXkvcGF0aC1wbGFubmluZy9ncGdwdS1wcm9ncmFtcy9vcHRpbWl6ZUN1YmljUGF0aHMuanM/MTUzZCIsIndlYnBhY2s6Ly90aHJlZS1hdnMtZGFzaC8uL2pzL2F1dG9ub215L3BhdGgtcGxhbm5pbmcvZ3BncHUtcHJvZ3JhbXMvb3B0aW1pemVRdWludGljUGF0aHMuanM/YzA1ZCIsIndlYnBhY2s6Ly90aHJlZS1hdnMtZGFzaC8uL2pzL2F1dG9ub215L3BhdGgtcGxhbm5pbmcvZ3BncHUtcHJvZ3JhbXMvZ3JhcGhTZWFyY2hTaGFyZWQuanM/MjA1MiIsIndlYnBhY2s6Ly90aHJlZS1hdnMtZGFzaC8uL2pzL2F1dG9ub215L3BhdGgtcGxhbm5pbmcvZ3BncHUtcHJvZ3JhbXMvcGF0aEZyb21WZWhpY2xlQ29zdHMuanM/ZTUwYyIsIndlYnBhY2s6Ly90aHJlZS1hdnMtZGFzaC8uL2pzL2F1dG9ub215L3BhdGgtcGxhbm5pbmcvZ3BncHUtcHJvZ3JhbXMvZ3JhcGhTZWFyY2guanM/NGM4OCIsIndlYnBhY2s6Ly90aHJlZS1hdnMtZGFzaC8uL2pzL2F1dG9ub215L3BhdGgtcGxhbm5pbmcvZ3BncHUtcHJvZ3JhbXMveHlPYnN0YWNsZUNvc3RHcmlkLmpzP2M5NzQiLCJ3ZWJwYWNrOi8vdGhyZWUtYXZzLWRhc2gvLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL1BhdGhQbGFubmVyLmpzP2QzMjYiLCJ3ZWJwYWNrOi8vdGhyZWUtYXZzLWRhc2gvLi9qcy9hdXRvbm9teS9MYW5lUGF0aC5qcz8wZmE0Iiwid2VicGFjazovL3RocmVlLWF2cy1kYXNoLy4vanMvYXV0b25vbXkvU3RhdGljT2JzdGFjbGUuanM/ODkwNiIsIndlYnBhY2s6Ly90aHJlZS1hdnMtZGFzaC8uL2pzL2F1dG9ub215L0R5bmFtaWNPYnN0YWNsZS5qcz8yZTcwIiwid2VicGFjazovL3RocmVlLWF2cy1kYXNoLy4vd29ya2Vycy9QYXRoUGxhbm5lcldvcmtlci5qcz80ZTc2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QUE2SDtBQUNySixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EiLCJmaWxlIjoiMjc5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogUGFydGlhbGx5IGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vdHVyYm8vanMvYmxvYi9tYXN0ZXIvdHVyYm8uanNcclxuICpcclxuICogVHVyYm8uanMgTGljZW5zZTpcclxuICogQ29weXJpZ2h0IChjKSAyMDE2IG1pbnhvbWF0XHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxyXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXHJcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxyXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gKlxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxyXG4gKiBTT0ZUV0FSRS5cclxuICovXHJcblxyXG5jb25zdCB2ZXJ0ZXhTaGFkZXJDb2RlID0gYCN2ZXJzaW9uIDMwMCBlc1xyXG5pbiB2ZWMyIHBvc2l0aW9uO1xyXG5pbiB2ZWMyIHRleHR1cmU7XHJcbm91dCB2ZWMyIGtlcm5lbFBvc2l0aW9uO1xyXG5cclxudm9pZCBtYWluKHZvaWQpIHtcclxuICBrZXJuZWxQb3NpdGlvbiA9IHRleHR1cmU7XHJcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLnh5LCAwLjAsIDEuMCk7XHJcbn1cclxuYDtcclxuXHJcbmNvbnN0IGZyYWdtZW50U2hhZGVySGVhZGVyID0gYCN2ZXJzaW9uIDMwMCBlc1xyXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XHJcbnByZWNpc2lvbiBoaWdocCBpbnQ7XHJcbnByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XHJcbnByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkRBcnJheTtcclxucHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIzRDtcclxucHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXJDdWJlO1xyXG5cclxuaW4gdmVjMiBrZXJuZWxQb3NpdGlvbjtcclxub3V0IHZlYzQga2VybmVsT3V0O1xyXG51bmlmb3JtIGl2ZWMyIGtlcm5lbFNpemU7XHJcbmA7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHUEdQVSB7XHJcbiAgc3RhdGljIGFsbG9jKHNpemUsIHN0cmlkZSkge1xyXG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHN0cmlkZSkgfHwgc3RyaWRlIDwgMSB8fCBzdHJpZGUgPiA0KVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIHN0cmlkZSBtdXN0IGJlIGFuIGludGVnZXIgYmV0d2VlbiAxIGFuZCA0LlwiKTtcclxuXHJcbiAgICAvLyBGaW5kIHRoZSBzbWFsbGVzdCBwZXJmZWN0IHNxdWFyZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gc2l6ZVxyXG4gICAgY29uc3Qgc3F1YXJlU2l6ZSA9IE1hdGgucG93KE1hdGguY2VpbChNYXRoLnNxcnQoc2l6ZSkpLCAyKTtcclxuXHJcbiAgICBjb25zdCBkYXRhID0gbmV3IEZsb2F0MzJBcnJheShzcXVhcmVTaXplICogc3RyaWRlKTtcclxuICAgIGRhdGEuZ3BncHVTaXplID0gc2l6ZTtcclxuICAgIGRhdGEuZ3BncHVTdHJpZGUgPSBzdHJpZGU7XHJcbiAgICByZXR1cm4gZGF0YTtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKGNvbmZpZ3MsIHNoYXJlZCA9IHt9KSB7XHJcbiAgICB0aGlzLl9zZXRVcEdMKCk7XHJcblxyXG4gICAgdGhpcy5vdXRwdXRUZXh0dXJlcyA9IHt9O1xyXG4gICAgdGhpcy5zaGFyZWRUZXh0dXJlcyA9IHt9O1xyXG5cclxuICAgIHRoaXMucHJvZ3JhbXMgPSBjb25maWdzLm1hcChjID0+IHRoaXMuX3ByZXBhcmVQcm9ncmFtKGMpKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gc2hhcmVkKSB7XHJcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBzaGFyZWRbbmFtZV07XHJcbiAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgY2hhbm5lbHMsIGRhdGEgfSA9IG9wdGlvbnM7XHJcbiAgICAgIHRoaXMuc2hhcmVkVGV4dHVyZXNbbmFtZV0gPSB0aGlzLl9jcmVhdGVUZXh0dXJlKGRhdGEsIHdpZHRoLCBoZWlnaHQsIGNoYW5uZWxzLCBvcHRpb25zKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHVwZGF0ZVNoYXJlZFRleHR1cmVzKHNoYXJlZCkge1xyXG4gICAgdGhpcy5zaGFyZWRUZXh0dXJlcyA9IHt9O1xyXG5cclxuICAgIGZvciAoY29uc3QgbmFtZSBpbiBzaGFyZWQpIHtcclxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHNoYXJlZFtuYW1lXTtcclxuICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBjaGFubmVscywgZGF0YSB9ID0gb3B0aW9ucztcclxuICAgICAgaWYgKHRoaXMuc2hhcmVkVGV4dHVyZXNbbmFtZV0pIHRoaXMuZ2wuZGVsZXRlVGV4dHVyZSh0aGlzLnNoYXJlZFRleHR1cmVzW25hbWVdKTtcclxuICAgICAgdGhpcy5zaGFyZWRUZXh0dXJlc1tuYW1lXSA9IHRoaXMuX2NyZWF0ZVRleHR1cmUoZGF0YSwgd2lkdGgsIGhlaWdodCwgY2hhbm5lbHMsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdXBkYXRlUHJvZ3JhbShwcm9ncmFtT3JQcm9ncmFtSW5kZXgsIGNvbmZpZykge1xyXG4gICAgY29uc3QgcHJvZ3JhbSA9IHR5cGVvZihwcm9ncmFtT3JQcm9ncmFtSW5kZXgpID09ICdudW1iZXInID8gdGhpcy5wcm9ncmFtc1twcm9ncmFtT3JQcm9ncmFtSW5kZXhdIDogcHJvZ3JhbU9yUHJvZ3JhbUluZGV4O1xyXG5cclxuICAgIGlmICghcHJvZ3JhbSlcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9ncmFtIHdpdGggaW5kZXggJHtwcm9ncmFtT3JQcm9ncmFtSW5kZXh9IGRvZXMgbm90IGV4aXN0LmApO1xyXG5cclxuICAgIGlmIChjb25maWcuaW5wdXRzKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgdXBkYXRlUHJvZ3JhbWAgZnVuY3Rpb24gY2Fubm90IGJlIHVzZWQgdG8gdXBkYXRlIGlucHV0cy4gVXNlIGB1cGRhdGVQcm9ncmFtSW5wdXRzYCBpbnN0ZWFkLicpO1xyXG5cclxuICAgIGlmIChjb25maWcubWV0YSlcclxuICAgICAgcHJvZ3JhbS5tZXRhID0gT2JqZWN0LmFzc2lnbihwcm9ncmFtLm1ldGEsIGNvbmZpZy5tZXRhKTtcclxuXHJcbiAgICBpZiAoY29uZmlnLndpZHRoICE9PSB1bmRlZmluZWQgJiYgY29uZmlnLmhlaWdodCAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICB0aGlzLnVwZGF0ZVByb2dyYW1TaXplKHByb2dyYW0sIGNvbmZpZy53aWR0aCwgY29uZmlnLmhlaWdodCk7XHJcblxyXG4gICAgaWYgKHR5cGVvZihjb25maWcudW5pZm9ybXMpID09ICdvYmplY3QnKVxyXG4gICAgICB0aGlzLnVwZGF0ZVByb2dyYW1Vbmlmb3Jtcyhwcm9ncmFtLCBjb25maWcudW5pZm9ybXMpO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlUHJvZ3JhbUlucHV0cyhwcm9ncmFtSW5kZXgsIGlucHV0cykge1xyXG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMucHJvZ3JhbXNbcHJvZ3JhbUluZGV4XTtcclxuXHJcbiAgICBpZiAoIXByb2dyYW0pXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvZ3JhbSB3aXRoIGluZGV4ICR7cHJvZ3JhbUluZGV4fSBkb2VzIG5vdCBleGlzdC5gKTtcclxuXHJcbiAgICBpZiAocHJvZ3JhbS5pbnB1dFRleHR1cmVzLmxlbmd0aCAhPSBpbnB1dHMubGVuZ3RoKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBtdXN0IHByb3ZpZGUgdGhlIHNhbWUgbnVtYmVyIG9mIGlucHV0cyBhcyB3aGVuIHRoZSBwcm9ncmFtIHdhcyBzZXQgdXA6IGdvdCAke2lucHV0cy5sZW5ndGh9IGJ1dCBleHBlY3RlZCAke3Byb2dyYW0uaW5wdXRUZXh0dXJlcy5sZW5ndGh9LmApO1xyXG5cclxuICAgIGNvbnN0IHByZXZpb3VzSW5wdXRXaWR0aCA9IHByb2dyYW0uaW5wdXRXaWR0aDtcclxuICAgIGNvbnN0IHByZXZpb3VzSW5wdXRIZWlnaHQgPSBwcm9ncmFtLmlucHV0SGVpZ2h0O1xyXG5cclxuICAgIGNvbnN0IGNvbmZpZyA9IHByb2dyYW0uY29uZmlnO1xyXG5cclxuICAgIGlmIChjb25maWcud2lkdGggPT09IHVuZGVmaW5lZCB8fCBjb25maWcuaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcHJvZ3JhbS5pbnB1dFdpZHRoID0gdW5kZWZpbmVkO1xyXG4gICAgICBwcm9ncmFtLmlucHV0SGVpZ2h0ID0gdW5kZWZpbmVkO1xyXG4gICAgICBwcm9ncmFtLmlucHV0RGF0YVNpemUgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fcHJlcGFyZVByb2dyYW1JbnB1dHMocHJvZ3JhbSwgaW5wdXRzKTtcclxuXHJcbiAgICBpZiAocHJvZ3JhbS5pbnB1dFdpZHRoICE9IHByZXZpb3VzSW5wdXRXaWR0aCB8fCBwcm9ncmFtLmlucHV0SGVpZ2h0ICE9IHByZXZpb3VzSW5wdXRIZWlnaHQpIHtcclxuICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKHByb2dyYW0uZ2xQcm9ncmFtKTtcclxuICAgICAgdGhpcy5nbC51bmlmb3JtMmkocHJvZ3JhbS5rZXJuZWxTaXplTG9jYXRpb24sIHByb2dyYW0uaW5wdXRXaWR0aCwgcHJvZ3JhbS5pbnB1dEhlaWdodCk7XHJcbiAgICAgIHRoaXMuX3ByZXBhcmVQcm9ncmFtT3V0cHV0KHByb2dyYW0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdXBkYXRlUHJvZ3JhbVNpemUocHJvZ3JhbU9yUHJvZ3JhbUluZGV4LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICBjb25zdCBwcm9ncmFtID0gdHlwZW9mKHByb2dyYW1PclByb2dyYW1JbmRleCkgPT0gJ251bWJlcicgPyB0aGlzLnByb2dyYW1zW3Byb2dyYW1PclByb2dyYW1JbmRleF0gOiBwcm9ncmFtT3JQcm9ncmFtSW5kZXg7XHJcblxyXG4gICAgaWYgKCFwcm9ncmFtKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb2dyYW0gd2l0aCBpbmRleCAke3Byb2dyYW1PclByb2dyYW1JbmRleH0gZG9lcyBub3QgZXhpc3QuYCk7XHJcblxyXG4gICAgaWYgKHByb2dyYW0uaW5wdXRUZXh0dXJlcy5sZW5ndGggIT0gMClcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTaXplIGNhbiBvbmx5IGJlIHVwZGF0ZWQgb24gcHJvZ3JhbXMgd2l0aCBubyBpbnB1dHMuYCk7XHJcblxyXG4gICAgaWYgKHdpZHRoID09IHByb2dyYW0uaW5wdXRXaWR0aCAmJiBoZWlnaHQgPT0gcHJvZ3JhbS5pbnB1dEhlaWdodCkgcmV0dXJuO1xyXG5cclxuICAgIHByb2dyYW0uaW5wdXRXaWR0aCA9IHdpZHRoO1xyXG4gICAgcHJvZ3JhbS5pbnB1dEhlaWdodCA9IGhlaWdodDtcclxuICAgIHByb2dyYW0uaW5wdXREYXRhU2l6ZSA9IHdpZHRoICogaGVpZ2h0O1xyXG5cclxuICAgIHRoaXMuZ2wudXNlUHJvZ3JhbShwcm9ncmFtLmdsUHJvZ3JhbSk7XHJcbiAgICB0aGlzLmdsLnVuaWZvcm0yaShwcm9ncmFtLmtlcm5lbFNpemVMb2NhdGlvbiwgcHJvZ3JhbS5pbnB1dFdpZHRoLCBwcm9ncmFtLmlucHV0SGVpZ2h0KTtcclxuICAgIHRoaXMuX3ByZXBhcmVQcm9ncmFtT3V0cHV0KHByb2dyYW0pO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlUHJvZ3JhbVVuaWZvcm1zKHByb2dyYW1PclByb2dyYW1JbmRleCwgdW5pZm9ybXMpIHtcclxuICAgIGNvbnN0IHByb2dyYW0gPSB0eXBlb2YocHJvZ3JhbU9yUHJvZ3JhbUluZGV4KSA9PSAnbnVtYmVyJyA/IHRoaXMucHJvZ3JhbXNbcHJvZ3JhbU9yUHJvZ3JhbUluZGV4XSA6IHByb2dyYW1PclByb2dyYW1JbmRleDtcclxuICAgIHRoaXMuZ2wudXNlUHJvZ3JhbShwcm9ncmFtLmdsUHJvZ3JhbSk7XHJcblxyXG4gICAgaWYgKCFwcm9ncmFtKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb2dyYW0gd2l0aCBpbmRleCAke3Byb2dyYW1PclByb2dyYW1JbmRleH0gZG9lcyBub3QgZXhpc3QuYCk7XHJcblxyXG4gICAgZm9yIChjb25zdCB1bmlmb3JtTmFtZSBpbiB1bmlmb3Jtcykge1xyXG4gICAgICBjb25zdCB2YWx1ZSA9IHVuaWZvcm1zW3VuaWZvcm1OYW1lXTtcclxuICAgICAgbGV0IHVuaWZvcm07XHJcblxyXG4gICAgICBpZiAodW5pZm9ybSA9IHByb2dyYW0udW5pZm9ybXNbdW5pZm9ybU5hbWVdKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSh1bmlmb3JtLnR5cGUsIHVuaWZvcm0ubG9jYXRpb24sIHZhbHVlKVxyXG4gICAgICB9IGVsc2UgaWYgKHVuaWZvcm0gPSBwcm9ncmFtLnVuaWZvcm1UZXh0dXJlc1t1bmlmb3JtTmFtZV0pIHtcclxuICAgICAgICBpZiAodHlwZW9mKHZhbHVlKSAhPSAnb2JqZWN0JyB8fCB2YWx1ZS50eXBlICE9ICd0ZXh0dXJlJylcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgdGV4dHVyZSB0eXBlIGZvciB1bmlmb3JtICR7dW5pZm9ybU5hbWV9LmApO1xyXG5cclxuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIGNoYW5uZWxzLCBkYXRhIH0gPSB1bmlmb3JtO1xyXG4gICAgICAgIGlmIChwcm9ncmFtLnVuaWZvcm1UZXh0dXJlc1t1bmlmb3JtTmFtZV0udGV4dHVyZSkgdGhpcy5nbC5kZWxldGVUZXh0dXJlKHByb2dyYW0udW5pZm9ybVRleHR1cmVzW3VuaWZvcm1OYW1lXS50ZXh0dXJlKTtcclxuICAgICAgICBwcm9ncmFtLnVuaWZvcm1UZXh0dXJlc1t1bmlmb3JtTmFtZV0udGV4dHVyZSA9IHRoaXMuX2NyZWF0ZVRleHR1cmUoZGF0YSwgd2lkdGgsIGhlaWdodCwgY2hhbm5lbHMsIHVuaWZvcm0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHVuaWZvcm0gJHt1bmlmb3JtTmFtZX0gZG9lcyBub3QgZXhpc3QgaW4gdGhpcyBwcm9ncmFtLmApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBydW4oKSB7XHJcbiAgICBjb25zdCBvdXRwdXRzID0gW107XHJcblxyXG4gICAgZm9yIChjb25zdCBwcm9ncmFtIG9mIHRoaXMucHJvZ3JhbXMpIHtcclxuICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKHByb2dyYW0uZ2xQcm9ncmFtKTtcclxuICAgICAgdGhpcy5nbC52aWV3cG9ydCgwLCAwLCBwcm9ncmFtLmlucHV0V2lkdGgsIHByb2dyYW0uaW5wdXRIZWlnaHQpO1xyXG4gICAgICB0aGlzLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLmdsLkZSQU1FQlVGRkVSLCBwcm9ncmFtLmZyYW1lQnVmZmVyKTtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgW2luZGV4LCBpbnB1dFRleHR1cmVdIG9mIHByb2dyYW0uaW5wdXRUZXh0dXJlcy5lbnRyaWVzKCkpIHtcclxuICAgICAgICB0aGlzLmdsLmFjdGl2ZVRleHR1cmUodGhpcy5nbC5URVhUVVJFMCArIGluZGV4KTtcclxuICAgICAgICB0aGlzLmdsLmJpbmRUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRV8yRCwgaW5wdXRUZXh0dXJlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yIChjb25zdCB1bmlmb3JtTmFtZSBpbiBwcm9ncmFtLnVuaWZvcm1UZXh0dXJlcykge1xyXG4gICAgICAgIGNvbnN0IHVuaWZvcm1UZXh0dXJlID0gcHJvZ3JhbS51bmlmb3JtVGV4dHVyZXNbdW5pZm9ybU5hbWVdO1xyXG4gICAgICAgIHRoaXMuZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkUwICsgdW5pZm9ybVRleHR1cmUuaW5kZXgpO1xyXG4gICAgICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodW5pZm9ybVRleHR1cmUudGFyZ2V0LCB1bmlmb3JtVGV4dHVyZS50ZXh0dXJlIHx8IHRoaXMuc2hhcmVkVGV4dHVyZXNbdW5pZm9ybVRleHR1cmUubmFtZV0gfHwgdGhpcy5vdXRwdXRUZXh0dXJlc1t1bmlmb3JtVGV4dHVyZS5uYW1lXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0eXBlb2YocHJvZ3JhbS5kcmF3KSA9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgcHJvZ3JhbS5kcmF3KHRoaXMsIHByb2dyYW0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgdGhpcy50ZXh0dXJlQnVmZmVyKTtcclxuICAgICAgICB0aGlzLmdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHByb2dyYW0udGV4dHVyZUxvY2F0aW9uKTtcclxuICAgICAgICB0aGlzLmdsLnZlcnRleEF0dHJpYlBvaW50ZXIocHJvZ3JhbS50ZXh0dXJlTG9jYXRpb24sIDIsIHRoaXMuZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcclxuICAgICAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHRoaXMucG9zaXRpb25CdWZmZXIpO1xyXG4gICAgICAgIHRoaXMuZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocHJvZ3JhbS5wb3NpdGlvbkxvY2F0aW9uKTtcclxuICAgICAgICB0aGlzLmdsLnZlcnRleEF0dHJpYlBvaW50ZXIocHJvZ3JhbS5wb3NpdGlvbkxvY2F0aW9uLCAyLCB0aGlzLmdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcbiAgICAgICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhCdWZmZXIpO1xyXG5cclxuICAgICAgICBpZiAocHJvZ3JhbS5kcmF3UHJveHkpIHtcclxuICAgICAgICAgIGNvbnN0IGRyYXcgPSAoKCkgPT4gdGhpcy5nbC5kcmF3RWxlbWVudHModGhpcy5nbC5UUklBTkdMRVMsIDYsIHRoaXMuZ2wuVU5TSUdORURfU0hPUlQsIDApKS5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgcHJvZ3JhbS5kcmF3UHJveHkodGhpcywgcHJvZ3JhbSwgZHJhdyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuZ2wuZHJhd0VsZW1lbnRzKHRoaXMuZ2wuVFJJQU5HTEVTLCA2LCB0aGlzLmdsLlVOU0lHTkVEX1NIT1JULCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChwcm9ncmFtLm91dHB1dCAmJiBwcm9ncmFtLm91dHB1dC5uYW1lICYmICFwcm9ncmFtLm91dHB1dC5yZWFkKSB7XHJcbiAgICAgICAgb3V0cHV0cy5wdXNoKG51bGwpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IG5ldyBGbG9hdDMyQXJyYXkocHJvZ3JhbS5pbnB1dFdpZHRoICogcHJvZ3JhbS5pbnB1dEhlaWdodCAqIDQpO1xyXG4gICAgICAgIHRoaXMuZ2wucmVhZFBpeGVscygwLCAwLCBwcm9ncmFtLmlucHV0V2lkdGgsIHByb2dyYW0uaW5wdXRIZWlnaHQsIHRoaXMuZ2wuUkdCQSwgdGhpcy5nbC5GTE9BVCwgb3V0cHV0KTtcclxuICAgICAgICBvdXRwdXRzLnB1c2gob3V0cHV0LnN1YmFycmF5KDAsIHByb2dyYW0uaW5wdXREYXRhU2l6ZSAqIDQpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRwdXRzO1xyXG4gIH1cclxuXHJcbiAgX3NldFVwR0woKSB7XHJcbiAgICBsZXQgY2FudmFzO1xyXG5cclxuICAgIGlmIChzZWxmLmRvY3VtZW50KVxyXG4gICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgIGVsc2UgaWYgKHNlbGYuT2Zmc2NyZWVuQ2FudmFzKVxyXG4gICAgICBjYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKDAsIDApO1xyXG4gICAgZWxzZVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjcmVhdGUgYSBjYW52YXMuJyk7XHJcblxyXG4gICAgY29uc3QgYXR0ciA9IHsgYWxwaGE6IGZhbHNlLCBhbnRpYWxpYXM6IGZhbHNlIH07XHJcbiAgICB0aGlzLmdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbDJcIiwgYXR0cikgfHwgY2FudmFzLmdldENvbnRleHQoXCJleHBlcmltZW50YWwtd2ViZ2wyXCIsIGF0dHIpO1xyXG5cclxuICAgIGlmICghdGhpcy5nbClcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGluaXRpYWxpemUgV2ViR0wyLiBZb3VyIGJyb3dzZXIgbWF5IG5vdCBzdXBwb3J0IGl0LlwiKTtcclxuXHJcbiAgICBpZiAoIXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKCdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0JykpXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVxdWlyZWQgV2ViR0wgZXh0ZW5zaW9uIEVYVF9jb2xvcl9idWZmZXJfZmxvYXQgbm90IHN1cHBvcnRlZC4nKTtcclxuXHJcbiAgICBpZiAoIXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInKSlcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1aXJlZCBXZWJHTCBleHRlbnNpb24gT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyIG5vdCBzdXBwb3J0ZWQuJyk7XHJcblxyXG4gICAgdGhpcy5wb3NpdGlvbkJ1ZmZlciA9IHRoaXMuX25ld0J1ZmZlcihbLTEsIC0xLCAxLCAtMSwgMSwgMSwgLTEsIDFdKTtcclxuICAgIHRoaXMudGV4dHVyZUJ1ZmZlciA9IHRoaXMuX25ld0J1ZmZlcihbMCwgMCwgMSwgMCwgMSwgMSwgMCwgMV0pO1xyXG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IHRoaXMuX25ld0J1ZmZlcihbMSwgMiwgMCwgMywgMCwgMl0sIFVpbnQxNkFycmF5LCB0aGlzLmdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSKTtcclxuICB9XHJcblxyXG4gIF9wcmVwYXJlUHJvZ3JhbShjb25maWcpIHtcclxuICAgIGNvbnN0IHByb2dyYW0gPSB7IGNvbmZpZyB9O1xyXG5cclxuICAgIHByb2dyYW0uZHJhdyA9IGNvbmZpZy5kcmF3O1xyXG4gICAgcHJvZ3JhbS5kcmF3UHJveHkgPSBjb25maWcuZHJhd1Byb3h5O1xyXG4gICAgcHJvZ3JhbS5tZXRhID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnLm1ldGEpO1xyXG5cclxuICAgIGlmIChjb25maWcud2lkdGggJiYgY29uZmlnLmhlaWdodCkge1xyXG4gICAgICBwcm9ncmFtLmlucHV0V2lkdGggPSBjb25maWcud2lkdGg7XHJcbiAgICAgIHByb2dyYW0uaW5wdXRIZWlnaHQgPSBjb25maWcuaGVpZ2h0O1xyXG4gICAgICBwcm9ncmFtLmlucHV0RGF0YVNpemUgPSBjb25maWcud2lkdGggKiBjb25maWcuaGVpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIHByb2dyYW0ub3V0cHV0ID0gY29uZmlnLm91dHB1dDtcclxuXHJcbiAgICBjb25zdCBrZXJuZWwgPSBjb25maWcua2VybmVsO1xyXG5cclxuICAgIGlmICh0eXBlb2Yoa2VybmVsKSAhPSAnc3RyaW5nJyB8fCBrZXJuZWwubGVuZ3RoID09IDApXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIktlcm5lbCBjb2RlIGNhbm5vdCBiZSBlbXB0eS5cIik7XHJcblxyXG4gICAgY29uc3QgaW5wdXRzID0gY29uZmlnLmlucHV0cyB8fCBbXTtcclxuICAgIGNvbnN0IHVuaWZvcm1zID0gY29uZmlnLnVuaWZvcm1zIHx8IHt9O1xyXG5cclxuICAgIHRoaXMuX3ByZXBhcmVQcm9ncmFtSW5wdXRzKHByb2dyYW0sIGlucHV0cyk7XHJcblxyXG4gICAgbGV0IGZyYWdtZW50U2hhZGVyQ29uZmlnID0gXCJcIjtcclxuICAgIFxyXG4gICAgZm9yIChjb25zdCBpbmRleCBpbiBpbnB1dHMpXHJcbiAgICAgIGZyYWdtZW50U2hhZGVyQ29uZmlnICs9IGB1bmlmb3JtIHNhbXBsZXIyRCBfaW5wdXQke2luZGV4fTtcXG5gO1xyXG5cclxuICAgIGlmIChwcm9ncmFtLmlucHV0V2lkdGggPT09IHVuZGVmaW5lZCB8fCBwcm9ncmFtLmlucHV0SGVpZ2h0ID09PSB1bmRlZmluZWQpXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24ga2VybmVsIHNpemUuIFlvdSBtdXN0IHByb3ZpZGUgZWl0aGVyIGFuIGlucHV0IG9yIHRoZSBgd2lkdGhgIGFuZCBgaGVpZ2h0YCBwYXJhbWV0ZXJzIGluIHRoZSBrZXJuZWwgY29uZmlnLlwiKTtcclxuXHJcbiAgICBwcm9ncmFtLnVuaWZvcm1UZXh0dXJlcyA9IHt9O1xyXG4gICAgcHJvZ3JhbS51bmlmb3JtcyA9IHt9O1xyXG5cclxuICAgIGZvciAoY29uc3QgdW5pZm9ybU5hbWUgaW4gdW5pZm9ybXMpIHtcclxuICAgICAgY29uc3QgdW5pZm9ybSA9IHVuaWZvcm1zW3VuaWZvcm1OYW1lXTtcclxuXHJcbiAgICAgIGlmICh0eXBlb2YodW5pZm9ybSkgPT0gJ251bWJlcicpIHtcclxuICAgICAgICBwcm9ncmFtLnVuaWZvcm1zW3VuaWZvcm1OYW1lXSA9IHtcclxuICAgICAgICAgIHR5cGU6ICdmbG9hdCcsXHJcbiAgICAgICAgICB2YWx1ZTogdW5pZm9ybVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZnJhZ21lbnRTaGFkZXJDb25maWcgKz0gYHVuaWZvcm0gZmxvYXQgJHt1bmlmb3JtTmFtZX07XFxuYDtcclxuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHVuaWZvcm0pKSB7XHJcbiAgICAgICAgaWYgKHVuaWZvcm0ubGVuZ3RoIDwgMiB8fCB1bmlmb3JtLmxlbmd0aCA+IDQpXHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFycmF5IHVuaWZvcm1zIGNhbiBvbmx5IGhhdmUgbGVuZ3RocyBvZiAyLCAzLCBvciA0IGVsZW1lbnRzIChjb3JyZXNwb25kaW5nIHRvIHZlYzIsIHZlYzMsIGFuZCB2ZWM0KS5gKTtcclxuXHJcbiAgICAgICAgY29uc3QgdHlwZSA9IFsndmVjMicsICd2ZWMzJywgJ3ZlYzQnXVt1bmlmb3JtLmxlbmd0aCAtIDJdO1xyXG4gICAgICAgIHByb2dyYW0udW5pZm9ybXNbdW5pZm9ybU5hbWVdID0ge1xyXG4gICAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICAgIHZhbHVlOiB1bmlmb3JtXHJcbiAgICAgICAgfTtcclxuICAgICAgICBmcmFnbWVudFNoYWRlckNvbmZpZyArPSBgdW5pZm9ybSAke3R5cGV9ICR7dW5pZm9ybU5hbWV9O1xcbmA7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCB3aWR0aCwgaGVpZ2h0LCBjaGFubmVscywgZGF0YSwgdmFsdWUsIGxlbmd0aCwgbmFtZSB9ID0gdW5pZm9ybTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGUgPT0gJ3RleHR1cmUnIHx8IHR5cGUgPT0gJ291dHB1dFRleHR1cmUnIHx8IHR5cGUgPT0gJ3NoYXJlZFRleHR1cmUnKSB7XHJcbiAgICAgICAgICBsZXQgdGFyZ2V0LCB0eXBlO1xyXG5cclxuICAgICAgICAgIGlmICh1bmlmb3JtLnRleHR1cmVUeXBlID09ICczRCcpIHtcclxuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5nbC5URVhUVVJFXzNEO1xyXG4gICAgICAgICAgICB0eXBlID0gJ3NhbXBsZXIzRCc7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHVuaWZvcm0udGV4dHVyZVR5cGUgPT0gJzJEQXJyYXknKSB7XHJcbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXMuZ2wuVEVYVFVSRV8yRF9BUlJBWTtcclxuICAgICAgICAgICAgdHlwZSA9ICdzYW1wbGVyMkRBcnJheSc7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLmdsLlRFWFRVUkVfMkQ7XHJcbiAgICAgICAgICAgIHR5cGUgPSAnc2FtcGxlcjJEJztcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAodHlwZSA9PSAndGV4dHVyZScpIHtcclxuICAgICAgICAgICAgcHJvZ3JhbS51bmlmb3JtVGV4dHVyZXNbdW5pZm9ybU5hbWVdID0geyB0YXJnZXQsIHRleHR1cmU6IGRhdGEgPyB0aGlzLl9jcmVhdGVUZXh0dXJlKGRhdGEsIHdpZHRoLCBoZWlnaHQsIGNoYW5uZWxzLCB1bmlmb3JtKSA6IG51bGwgfTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHByb2dyYW0udW5pZm9ybVRleHR1cmVzW3VuaWZvcm1OYW1lXSA9IHsgdGFyZ2V0LCB0ZXh0dXJlOiBudWxsLCBuYW1lOiBuYW1lIHx8IHVuaWZvcm1OYW1lIH07XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZnJhZ21lbnRTaGFkZXJDb25maWcgKz0gYHVuaWZvcm0gJHt0eXBlfSAke3VuaWZvcm1OYW1lfTtcXG5gO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBwcm9ncmFtLnVuaWZvcm1zW3VuaWZvcm1OYW1lXSA9IHsgdHlwZSwgdmFsdWUgfTtcclxuICAgICAgICAgIGlmIChsZW5ndGggIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXJDb25maWcgKz0gYHVuaWZvcm0gJHt0eXBlfSAke3VuaWZvcm1OYW1lfVske2xlbmd0aH1dO1xcbmA7XHJcbiAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyQ29uZmlnICs9IGB1bmlmb3JtICR7dHlwZX0gJHt1bmlmb3JtTmFtZX07XFxuYDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSB0aGlzLmdsLmNyZWF0ZVNoYWRlcih0aGlzLmdsLlZFUlRFWF9TSEFERVIpO1xyXG4gICAgdGhpcy5nbC5zaGFkZXJTb3VyY2UodmVydGV4U2hhZGVyLCBjb25maWcudmVydGV4U2hhZGVyIHx8IHZlcnRleFNoYWRlckNvZGUpO1xyXG4gICAgdGhpcy5nbC5jb21waWxlU2hhZGVyKHZlcnRleFNoYWRlcik7XHJcblxyXG4gICAgaWYgKCF0aGlzLmdsLmdldFNoYWRlclBhcmFtZXRlcih2ZXJ0ZXhTaGFkZXIsIHRoaXMuZ2wuQ09NUElMRV9TVEFUVVMpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBcIkNvdWxkIG5vdCBidWlsZCB2ZXJ0ZXggc2hhZGVyIChmYXRhbCkuXFxuXCIgKyBcIlxcblwiICtcclxuICAgICAgICBcIi0tLSBDT0RFIERVTVAgLS0tXFxuXCIgKyAoY29uZmlnLnZlcnRleFNoYWRlciB8fCB2ZXJ0ZXhTaGFkZXJDb2RlKSArIFwiXFxuXFxuXCIgK1xyXG4gICAgICAgIFwiLS0tIEVSUk9SIExPRyAtLS1cXG5cIiArIHRoaXMuZ2wuZ2V0U2hhZGVySW5mb0xvZyh2ZXJ0ZXhTaGFkZXIpXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZnJhZ21lbnRTaGFkZXJNYWluID0gYFxyXG52b2lkIG1haW4oKSB7XHJcbiAga2VybmVsT3V0ID0gdmVjNChrZXJuZWwoJHtbLi4uQXJyYXkoaW5wdXRzLmxlbmd0aCkua2V5cygpXS5tYXAoaSA9PiBgdGV4dHVyZShfaW5wdXQke2l9LCBrZXJuZWxQb3NpdGlvbilgKS5qb2luKCcsICcpfSkpO1xyXG59XHJcbiAgICBgO1xyXG5cclxuICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gdGhpcy5nbC5jcmVhdGVTaGFkZXIodGhpcy5nbC5GUkFHTUVOVF9TSEFERVIpO1xyXG4gICAgY29uc3QgZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBmcmFnbWVudFNoYWRlckhlYWRlciArIGZyYWdtZW50U2hhZGVyQ29uZmlnICsga2VybmVsICsgZnJhZ21lbnRTaGFkZXJNYWluO1xyXG4gICAgdGhpcy5nbC5zaGFkZXJTb3VyY2UoZnJhZ21lbnRTaGFkZXIsIGZyYWdtZW50U2hhZGVyU291cmNlKTtcclxuICAgIHRoaXMuZ2wuY29tcGlsZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XHJcblxyXG4gICAgaWYgKCF0aGlzLmdsLmdldFNoYWRlclBhcmFtZXRlcihmcmFnbWVudFNoYWRlciwgdGhpcy5nbC5DT01QSUxFX1NUQVRVUykpIHtcclxuICAgICAgY29uc3Qgc291cmNlID0gZnJhZ21lbnRTaGFkZXJTb3VyY2Uuc3BsaXQoJ1xcbicpO1xyXG4gICAgICBsZXQgZGJnTXNnID0gXCJFUlJPUjogQ291bGQgbm90IGJ1aWxkIHNoYWRlciAoZmF0YWwpLlxcblxcbi0tLS0tLS0tLS0tLS0tLS0tLSBLRVJORUwgQ09ERSBEVU1QIC0tLS0tLS0tLS0tLS0tLS0tLVxcblwiXHJcblxyXG4gICAgICBmb3IgKGxldCBsID0gMDsgbCA8IHNvdXJjZS5sZW5ndGg7IGwrKylcclxuICAgICAgICBkYmdNc2cgKz0gYCR7bCArIDF9PiAke3NvdXJjZVtsXX1cXG5gO1xyXG5cclxuICAgICAgZGJnTXNnICs9IFwiXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVSUk9SICBMT0cgLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXCIgKyB0aGlzLmdsLmdldFNoYWRlckluZm9Mb2coZnJhZ21lbnRTaGFkZXIpO1xyXG5cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGRiZ01zZyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvZ3JhbS5nbFByb2dyYW0gPSB0aGlzLmdsLmNyZWF0ZVByb2dyYW0oKTtcclxuICAgIHRoaXMuZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0uZ2xQcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xyXG4gICAgdGhpcy5nbC5hdHRhY2hTaGFkZXIocHJvZ3JhbS5nbFByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcclxuICAgIHRoaXMuZ2wubGlua1Byb2dyYW0ocHJvZ3JhbS5nbFByb2dyYW0pO1xyXG4gICAgdGhpcy5nbC51c2VQcm9ncmFtKHByb2dyYW0uZ2xQcm9ncmFtKTtcclxuXHJcbiAgICBpZiAoIXRoaXMuZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLmdsUHJvZ3JhbSwgdGhpcy5nbC5MSU5LX1NUQVRVUykpXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGxpbmsgR0xTTCBwcm9ncmFtIGNvZGUuJyk7XHJcblxyXG4gICAgbGV0IHRleHR1cmVJbmRleCA9IDA7XHJcblxyXG4gICAgZm9yIChjb25zdCBpbnB1dCBvZiBwcm9ncmFtLmlucHV0VGV4dHVyZXMpIHtcclxuICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLmdsUHJvZ3JhbSwgYF9pbnB1dCR7dGV4dHVyZUluZGV4fWApO1xyXG4gICAgICB0aGlzLmdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdGV4dHVyZUluZGV4KTtcclxuICAgICAgdGV4dHVyZUluZGV4Kys7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChjb25zdCB1bmlmb3JtTmFtZSBpbiBwcm9ncmFtLnVuaWZvcm1UZXh0dXJlcykge1xyXG4gICAgICBwcm9ncmFtLnVuaWZvcm1UZXh0dXJlc1t1bmlmb3JtTmFtZV0uaW5kZXggPSB0ZXh0dXJlSW5kZXg7XHJcbiAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbS5nbFByb2dyYW0sIHVuaWZvcm1OYW1lKTtcclxuICAgICAgdGhpcy5nbC51bmlmb3JtMWkobG9jYXRpb24sIHRleHR1cmVJbmRleCk7XHJcbiAgICAgIHRleHR1cmVJbmRleCsrO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoY29uc3QgdW5pZm9ybU5hbWUgaW4gcHJvZ3JhbS51bmlmb3Jtcykge1xyXG4gICAgICBjb25zdCB7IHR5cGUsIHZhbHVlIH0gPSBwcm9ncmFtLnVuaWZvcm1zW3VuaWZvcm1OYW1lXTtcclxuICAgICAgY29uc3QgbG9jYXRpb24gPSBwcm9ncmFtLnVuaWZvcm1zW3VuaWZvcm1OYW1lXS5sb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0uZ2xQcm9ncmFtLCB1bmlmb3JtTmFtZSk7XHJcblxyXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcclxuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKHR5cGUsIGxvY2F0aW9uLCB2YWx1ZSk7XHJcblxyXG4gICAgICBkZWxldGUgcHJvZ3JhbS51bmlmb3Jtc1t1bmlmb3JtTmFtZV0udmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvZ3JhbS5rZXJuZWxTaXplTG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLmdsUHJvZ3JhbSwgJ2tlcm5lbFNpemUnKTtcclxuICAgIHRoaXMuZ2wudW5pZm9ybTJpKHByb2dyYW0ua2VybmVsU2l6ZUxvY2F0aW9uLCBwcm9ncmFtLmlucHV0V2lkdGgsIHByb2dyYW0uaW5wdXRIZWlnaHQpO1xyXG5cclxuICAgIHByb2dyYW0ucG9zaXRpb25Mb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbS5nbFByb2dyYW0sICdwb3NpdGlvbicpO1xyXG4gICAgcHJvZ3JhbS50ZXh0dXJlTG9jYXRpb24gPSB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0uZ2xQcm9ncmFtLCAndGV4dHVyZScpO1xyXG5cclxuICAgIHByb2dyYW0uZnJhbWVCdWZmZXIgPSB0aGlzLmdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XHJcbiAgICB0aGlzLl9wcmVwYXJlUHJvZ3JhbU91dHB1dChwcm9ncmFtKTtcclxuXHJcbiAgICByZXR1cm4gcHJvZ3JhbTtcclxuICB9XHJcblxyXG4gIF9wcmVwYXJlUHJvZ3JhbUlucHV0cyhwcm9ncmFtLCBpbnB1dHMpIHtcclxuICAgIGlmIChwcm9ncmFtLmlucHV0VGV4dHVyZXMpXHJcbiAgICAgIHByb2dyYW0uaW5wdXRUZXh0dXJlcy5mb3JFYWNoKHQgPT4gdGhpcy5nbC5kZWxldGVUZXh0dXJlKHQpKTtcclxuXHJcbiAgICBwcm9ncmFtLmlucHV0VGV4dHVyZXMgPSBbXTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IFtpbmRleCwgZGF0YV0gb2YgaW5wdXRzLmVudHJpZXMoKSkge1xyXG4gICAgICBpZiAoZGF0YS5ncGdwdVNpemUgPT09IHVuZGVmaW5lZCB8fCBkYXRhLmdwZ3B1U3RyaWRlID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHUEdQVSBpbnB1dHMgbXVzdCBiZSBjcmVhdGVkIGJ5IHRoZSBgYWxsb2NgIGZ1bmN0aW9uLicpO1xyXG5cclxuICAgICAgY29uc3Qgc2l6ZSA9IE1hdGguc3FydChkYXRhLmxlbmd0aCAvIGRhdGEuZ3BncHVTdHJpZGUpO1xyXG4gICAgICBpZiAoc2l6ZSA8PSAwIHx8IHNpemUgJSAxICE9IDApXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHUEdQVSBpbnB1dCBzaXplIGlzIGV4cGVjdGVkIHRvIGJlIGEgcGVyZmVjdCBzcXVhcmUuJyk7XHJcblxyXG4gICAgICBpZiAocHJvZ3JhbS5pbnB1dFdpZHRoID09PSB1bmRlZmluZWQgfHwgcHJvZ3JhbS5pbnB1dEhlaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcHJvZ3JhbS5pbnB1dFdpZHRoID0gc2l6ZTtcclxuICAgICAgICBwcm9ncmFtLmlucHV0SGVpZ2h0ID0gc2l6ZTtcclxuICAgICAgICBwcm9ncmFtLmlucHV0RGF0YVNpemUgPSBkYXRhLmdwZ3B1U2l6ZTtcclxuICAgICAgfSBlbHNlIGlmIChzaXplICE9IHByb2dyYW0uaW5wdXRXaWR0aCB8fCBzaXplICE9IHByb2dyYW0uaW5wdXRIZWlnaHQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFsbCBHUEdQVSBpbnB1dHMgbXVzdCBiZSBvZiB0aGUgc2FtZSBzaXplLiBSZWNlaXZlZCAke2RhdGEuZ3BncHVTaXplfSAoaW50ZXJuYWwgJHtzaXplICogc2l6ZX0pIGJ1dCBleHBlY3RlZCAke3Byb2dyYW0uaW5wdXREYXRhU2l6ZX0gKGludGVybmFsICR7cHJvZ3JhbS5pbnB1dFdpZHRoICogcHJvZ3JhbS5pbnB1dEhlaWdodH0pLmApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwcm9ncmFtLmlucHV0VGV4dHVyZXMucHVzaCh0aGlzLl9jcmVhdGVUZXh0dXJlKGRhdGEsIHNpemUsIHNpemUsIGRhdGEuZ3BncHVTdHJpZGUpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9wcmVwYXJlUHJvZ3JhbU91dHB1dChwcm9ncmFtKSB7XHJcbiAgICB0aGlzLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLmdsLkZSQU1FQlVGRkVSLCBwcm9ncmFtLmZyYW1lQnVmZmVyKTtcclxuXHJcbiAgICBjb25zdCBvdXRwdXRUZXh0dXJlID0gdGhpcy5fY3JlYXRlVGV4dHVyZShudWxsLCBwcm9ncmFtLmlucHV0V2lkdGgsIHByb2dyYW0uaW5wdXRIZWlnaHQsIDQsIHByb2dyYW0ub3V0cHV0KTtcclxuXHJcbiAgICBpZiAocHJvZ3JhbS5vdXRwdXQgJiYgcHJvZ3JhbS5vdXRwdXQudGV4dHVyZVR5cGUgIT09ICczRCcgJiYgcHJvZ3JhbS5vdXRwdXQudGV4dHVyZVR5cGUgIT09ICcyREFycmF5Jykge1xyXG4gICAgICB0aGlzLmdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKHRoaXMuZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZ2wuQ09MT1JfQVRUQUNITUVOVDAsIHRoaXMuZ2wuVEVYVFVSRV8yRCwgb3V0cHV0VGV4dHVyZSwgMCk7XHJcbiAgICAgIGNvbnN0IGZyYW1lQnVmZmVyU3RhdHVzID0gKHRoaXMuZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyh0aGlzLmdsLkZSQU1FQlVGRkVSKSA9PSB0aGlzLmdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKTtcclxuICAgICAgaWYgKCFmcmFtZUJ1ZmZlclN0YXR1cylcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGF0dGFjaGluZyBmbG9hdCB0ZXh0dXJlIHRvIGZyYW1lYnVmZmVyLiBZb3VyIGRldmljZSBpcyBwcm9iYWJseSBpbmNvbXBhdGlibGUuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHByb2dyYW0ub3V0cHV0VGV4dHVyZSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICB0aGlzLmdsLmRlbGV0ZVRleHR1cmUocHJvZ3JhbS5vdXRwdXRUZXh0dXJlKTtcclxuICAgIHByb2dyYW0ub3V0cHV0VGV4dHVyZSA9IG91dHB1dFRleHR1cmU7XHJcblxyXG4gICAgaWYgKHByb2dyYW0ub3V0cHV0ICYmIHByb2dyYW0ub3V0cHV0Lm5hbWUpXHJcbiAgICAgIHRoaXMub3V0cHV0VGV4dHVyZXNbcHJvZ3JhbS5vdXRwdXQubmFtZV0gPSBvdXRwdXRUZXh0dXJlO1xyXG4gIH1cclxuXHJcbiAgX3NldFVuaWZvcm0odHlwZSwgbG9jYXRpb24sIHZhbHVlKSB7XHJcbiAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgY2FzZSAnaW50JzogdGhpcy5nbC51bmlmb3JtMWkobG9jYXRpb24sIHZhbHVlKTsgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2Zsb2F0JzogQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB0aGlzLmdsLnVuaWZvcm0xZnYobG9jYXRpb24sIHZhbHVlKSA6IHRoaXMuZ2wudW5pZm9ybTFmKGxvY2F0aW9uLCB2YWx1ZSk7IGJyZWFrO1xyXG4gICAgICBjYXNlICd2ZWMyJzogdGhpcy5nbC51bmlmb3JtMmZ2KGxvY2F0aW9uLCB2YWx1ZSk7IGJyZWFrO1xyXG4gICAgICBjYXNlICd2ZWMzJzogdGhpcy5nbC51bmlmb3JtM2Z2KGxvY2F0aW9uLCB2YWx1ZSk7IGJyZWFrO1xyXG4gICAgICBjYXNlICd2ZWM0JzogdGhpcy5nbC51bmlmb3JtNGZ2KGxvY2F0aW9uLCB2YWx1ZSk7IGJyZWFrO1xyXG4gICAgICBjYXNlICdtYXQzJzogdGhpcy5nbC51bmlmb3JtTWF0cml4M2Z2KGxvY2F0aW9uLCB2YWx1ZSk7IGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gdW5pZm9ybSB0eXBlICR7dHlwZX0uYCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfbmV3QnVmZmVyKGRhdGEsIGtsYXNzLCB0YXJnZXQpIHtcclxuICAgIGNvbnN0IGJ1ZiA9IHRoaXMuZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblxyXG4gICAgdGhpcy5nbC5iaW5kQnVmZmVyKCh0YXJnZXQgfHwgdGhpcy5nbC5BUlJBWV9CVUZGRVIpLCBidWYpO1xyXG4gICAgdGhpcy5nbC5idWZmZXJEYXRhKCh0YXJnZXQgfHwgdGhpcy5nbC5BUlJBWV9CVUZGRVIpLCBuZXcgKGtsYXNzIHx8IEZsb2F0MzJBcnJheSkoZGF0YSksIHRoaXMuZ2wuU1RBVElDX0RSQVcpO1xyXG5cclxuICAgIHJldHVybiBidWY7XHJcbiAgfVxyXG5cclxuICBfY3JlYXRlVGV4dHVyZShkYXRhLCB3aWR0aCwgaGVpZ2h0LCBjaGFubmVscywgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5nbC5jcmVhdGVUZXh0dXJlKCk7XHJcblxyXG4gICAgbGV0IGludGVybmFsRm9ybWF0LCBmb3JtYXQ7XHJcblxyXG4gICAgc3dpdGNoIChjaGFubmVscykge1xyXG4gICAgICBjYXNlIDE6XHJcbiAgICAgICAgaW50ZXJuYWxGb3JtYXQgPSB0aGlzLmdsLlIzMkY7XHJcbiAgICAgICAgZm9ybWF0ID0gdGhpcy5nbC5SRUQ7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMjpcclxuICAgICAgICBpbnRlcm5hbEZvcm1hdCA9IHRoaXMuZ2wuUkczMkY7XHJcbiAgICAgICAgZm9ybWF0ID0gdGhpcy5nbC5SRztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAzOlxyXG4gICAgICAgIGludGVybmFsRm9ybWF0ID0gdGhpcy5nbC5SR0IzMkY7XHJcbiAgICAgICAgZm9ybWF0ID0gdGhpcy5nbC5SR0I7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgNDpcclxuICAgICAgICBpbnRlcm5hbEZvcm1hdCA9IHRoaXMuZ2wuUkdCQTMyRjtcclxuICAgICAgICBmb3JtYXQgPSB0aGlzLmdsLlJHQkE7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgdGhyb3coXCJUZXh0dXJlIGNoYW5uZWxzIG11c3QgYmV0d2VlbiAxIGFuZCA0LlwiKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0YXJnZXQgPSBvcHRpb25zLnRleHR1cmVUeXBlID09ICczRCcgPyB0aGlzLmdsLlRFWFRVUkVfM0QgOiBvcHRpb25zLnRleHR1cmVUeXBlID09ICcyREFycmF5JyA/IHRoaXMuZ2wuVEVYVFVSRV8yRF9BUlJBWSA6IHRoaXMuZ2wuVEVYVFVSRV8yRDtcclxuXHJcbiAgICB0aGlzLmdsLmJpbmRUZXh0dXJlKHRhcmdldCwgdGV4dHVyZSk7XHJcbiAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCB0aGlzLmdsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLmdsLkNMQU1QX1RPX0VER0UpO1xyXG4gICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgdGhpcy5nbC5URVhUVVJFX1dSQVBfVCwgdGhpcy5nbC5DTEFNUF9UT19FREdFKTtcclxuICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIHRoaXMuZ2wuVEVYVFVSRV9XUkFQX1IsIHRoaXMuZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCB0aGlzLmdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgb3B0aW9ucy5maWx0ZXIgPT0gJ2xpbmVhcicgPyB0aGlzLmdsLkxJTkVBUiA6IHRoaXMuZ2wuTkVBUkVTVCk7XHJcbiAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCB0aGlzLmdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgb3B0aW9ucy5maWx0ZXIgPT0gJ2xpbmVhcicgPyB0aGlzLmdsLkxJTkVBUiA6IHRoaXMuZ2wuTkVBUkVTVCk7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMudGV4dHVyZVR5cGUgPT0gJzNEJyB8fCBvcHRpb25zLnRleHR1cmVUeXBlID09ICcyREFycmF5Jykge1xyXG4gICAgICB0aGlzLmdsLnRleEltYWdlM0QodGFyZ2V0LCAwLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucy5kZXB0aCwgMCwgZm9ybWF0LCB0aGlzLmdsLkZMT0FULCBkYXRhKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuZ2wudGV4SW1hZ2UyRCh0YXJnZXQsIDAsIGludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBmb3JtYXQsIHRoaXMuZ2wuRkxPQVQsIGRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGFyZ2V0LCBudWxsKTtcclxuXHJcbiAgICByZXR1cm4gdGV4dHVyZTtcclxuICB9XHJcbn1cclxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FyIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHggPSAwLCB5ID0gMCwgcm90YXRpb24gPSAwICkge1xyXG5cclxuXHRcdHRoaXMuc2V0UG9zZSggeCwgeSwgcm90YXRpb24gKTtcclxuXHJcblx0XHR0aGlzLnNjb3JlID0gMTAwO1xyXG4gICAgXHR0aGlzLmxhc3RUaW1lTG9nZ2VyID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcblxyXG5cdH1cclxuXHJcbiAgc3RhdGljIGdldEZyb250QXhsZVBvc2l0aW9uKHBvcywgcm90KSB7XHJcbiAgICByZXR1cm4gVEhSRUUuVmVjdG9yMi5mcm9tQW5nbGUocm90KS5tdWx0aXBseVNjYWxhcihDYXIuV0hFRUxfQkFTRSkuYWRkKHBvcyk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZ2V0RmFrZUF4bGVQb3NpdGlvbihwb3MsIHJvdCkge1xyXG4gICAgcmV0dXJuIENhci5mcm9udFRvUmVhckF4bGVQb3NpdGlvbihwb3MsIHJvdCk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgY2VudGVyVG9SZWFyQXhsZVBvc2l0aW9uKHBvcywgcm90KSB7XHJcbiAgICByZXR1cm4gVEhSRUUuVmVjdG9yMi5mcm9tQW5nbGUocm90KS5tdWx0aXBseVNjYWxhcihDYXIuUkVBUl9BWExFX1BPUykuYWRkKHBvcyk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZnJvbnRUb1JlYXJBeGxlUG9zaXRpb24ocG9zLCByb3QpIHtcclxuICAgIHJldHVybiBUSFJFRS5WZWN0b3IyLmZyb21BbmdsZShyb3QpLm11bHRpcGx5U2NhbGFyKC1DYXIuV0hFRUxfQkFTRSkuYWRkKHBvcyk7XHJcbiAgfVxyXG5cclxuICBnZXQgcG9zZSgpIHtcclxuICAgIHJldHVybiB7IHBvczogdGhpcy5yZWFyQXhsZVBvc2l0aW9uLmNsb25lKCksIHJvdDogdGhpcy5yb3RhdGlvbiwgdmVsb2NpdHk6IHRoaXMudmVsb2NpdHksIGN1cnY6IHRoaXMuY3VydmF0dXJlLCBkQ3VydjogdGhpcy5kQ3VydiwgZGRDdXJ2OiB0aGlzLmRkQ3VydiB9O1xyXG4gIH1cclxuXHJcbiAgZ2V0IGN1cnZhdHVyZSgpIHtcclxuICAgIHJldHVybiBNYXRoLnRhbih0aGlzLndoZWVsQW5nbGUpIC8gQ2FyLldIRUVMX0JBU0U7XHJcbiAgfVxyXG5cclxuICBnZXQgcmVhckF4bGVQb3NpdGlvbigpIHtcclxuICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy5wb3NpdGlvbjtcclxuICAgIGNvbnN0IHJvdCA9IHRoaXMucm90YXRpb247XHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoeCArIE1hdGguY29zKHJvdCkgKiBDYXIuUkVBUl9BWExFX1BPUywgeSArIE1hdGguc2luKHJvdCkgKiBDYXIuUkVBUl9BWExFX1BPUyk7XHJcbiAgfVxyXG5cclxuICBnZXQgZnJvbnRBeGxlUG9zaXRpb24oKSB7XHJcbiAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMucG9zaXRpb247XHJcbiAgICBjb25zdCByb3QgPSB0aGlzLnJvdGF0aW9uO1xyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKHggKyBNYXRoLmNvcyhyb3QpICogQ2FyLkZST05UX0FYTEVfUE9TLCB5ICsgTWF0aC5zaW4ocm90KSAqIENhci5GUk9OVF9BWExFX1BPUyk7XHJcbiAgfVxyXG5cclxuICBzZXRQb3NlKHgsIHksIHJvdGF0aW9uKSB7XHJcbiAgICAvLyBUcmFuc2xhdGUgc28gdGhhdCB4IGFuZCB5IGJlY29tZSB0aGUgY2VudGVyIG9mIHRoZSB2ZWhpY2xlIChpbnN0ZWFkIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHJlYXIgYXhsZSlcclxuICAgIHggLT0gQ2FyLlJFQVJfQVhMRV9QT1MgKiBNYXRoLmNvcyhyb3RhdGlvbik7XHJcbiAgICB5IC09IENhci5SRUFSX0FYTEVfUE9TICogTWF0aC5zaW4ocm90YXRpb24pO1xyXG5cclxuICAgIHRoaXMucG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMih4LCB5KTtcclxuICAgIHRoaXMucm90YXRpb24gPSBNYXRoLndyYXBBbmdsZShyb3RhdGlvbik7XHJcbiAgICB0aGlzLnZlbG9jaXR5ID0gMDtcclxuICAgIHRoaXMuYWNjZWxlcmF0aW9uID0gMDtcclxuICAgIHRoaXMud2hlZWxBbmdsZSA9IDA7XHJcbiAgICB0aGlzLndoZWVsQW5ndWxhclZlbG9jaXR5ID0gMDtcclxuICAgIHRoaXMuZEN1cnYgPSAwOyAvLyBkZXJpdmF0aXZlIHdpdGggcmVzcGVjdCB0byBhcmMgbGVuZ3RoXHJcbiAgICB0aGlzLmRkQ3VydiA9IDA7IC8vIGRlcml2YXRpdmUgd2l0aCByZXNwZWN0IHRvIGFyYyBsZW5ndGhcclxuICB9XHJcblxyXG5cdHN0ZXAgKCBkZWx0YSApIHtcclxuXHJcblx0XHRjb25zdCBjdXJ2UHJldiA9IHRoaXMuY3VydmF0dXJlO1xyXG5cdFx0Y29uc3QgZEN1cnZQcmV2ID0gdGhpcy5kQ3VydjtcclxuXHJcblx0XHRjb25zdCBkcmFnID0gKCAwLjUgKiBDYXIuRFJBR19DT0VGRiAqIENhci5GUk9OVEFMX0FSRUEgKiBDYXIuREVOU0lUWV9PRl9BSVIgKiBNYXRoLmFicyggdGhpcy52ZWxvY2l0eSApICsgQ2FyLlJPTExfUkVTSVNUICkgKiAtdGhpcy52ZWxvY2l0eTtcclxuXHRcdHRoaXMudmVsb2NpdHkgKz0gKCB0aGlzLmFjY2VsZXJhdGlvbiArIGRyYWcgLyBDYXIuTUFTUyApICogZGVsdGE7XHJcblxyXG5cdFx0Y29uc3QgdmVsb2NpdHlTcSA9IHRoaXMudmVsb2NpdHkgKiB0aGlzLnZlbG9jaXR5O1xyXG5cdFx0Y29uc3QgbWF4V2hlZWxBbmdsZSA9IE1hdGguY2xhbXAoIE1hdGguYXRhbiggQ2FyLk1BWF9MQVRFUkFMX0FDQ0VMICogQ2FyLldIRUVMX0JBU0UgLyB2ZWxvY2l0eVNxICksIDAuMDcsIENhci5NQVhfV0hFRUxfQU5HTEUgKTtcclxuXHRcdHRoaXMud2hlZWxBbmdsZSA9IE1hdGguY2xhbXAoIE1hdGgud3JhcEFuZ2xlKCB0aGlzLndoZWVsQW5nbGUgKyB0aGlzLndoZWVsQW5ndWxhclZlbG9jaXR5ICogZGVsdGEgKSwgLW1heFdoZWVsQW5nbGUsIG1heFdoZWVsQW5nbGUpO1xyXG5cclxuXHRcdGNvbnN0IGFuZ3VsYXJWZWxvY2l0eSA9IHRoaXMudmVsb2NpdHkgKiB0aGlzLmN1cnZhdHVyZTtcclxuXHRcdHRoaXMucm90YXRpb24gPSBNYXRoLndyYXBBbmdsZSggdGhpcy5yb3RhdGlvbiArIGFuZ3VsYXJWZWxvY2l0eSAqIGRlbHRhICk7XHJcblxyXG5cdFx0Y29uc3QgZGlzdCA9IHRoaXMudmVsb2NpdHkgKiBkZWx0YTtcclxuXHRcdHRoaXMucG9zaXRpb24gPSBUSFJFRS5WZWN0b3IyLmZyb21BbmdsZSggdGhpcy5yb3RhdGlvbiApLm11bHRpcGx5U2NhbGFyKCBkaXN0ICkuYWRkKCB0aGlzLnBvc2l0aW9uICk7XHJcblxyXG5cdFx0dGhpcy5kQ3VydiA9IGRpc3QgPiAwLjEgPyAoIHRoaXMuY3VydmF0dXJlIC0gY3VydlByZXYgKSAvIGRpc3QgOiAwO1xyXG5cdFx0dGhpcy5kZEN1cnYgPSBkaXN0ID4gMC4xID8gKCB0aGlzLmRDdXJ2IC0gZEN1cnZQcmV2ICkgLyBkaXN0IDogMDtcclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGUgKCBjb250cm9scywgZGVsdGEgKSB7XHJcblxyXG5cdFx0Y29uc3QgZ2FzID0gTWF0aC5jbGFtcCggY29udHJvbHMuZ2FzLCAtMSwgKzEgKTtcclxuXHRcdGNvbnN0IGJyYWtlID0gTWF0aC5jbGFtcCggY29udHJvbHMuYnJha2UsIDAsIDEgKTtcclxuXHRcdGNvbnN0IHN0ZWVyID0gTWF0aC5jbGFtcCggY29udHJvbHMuc3RlZXIsIC0xLCArMSApO1xyXG5cclxuXHRcdGlmICggYnJha2UgPiAwICkge1xyXG5cclxuXHRcdFx0dGhpcy5hY2NlbGVyYXRpb24gPSAtTWF0aC5zaWduKCB0aGlzLnZlbG9jaXR5ICkgKiBDYXIuTUFYX0JSQUtFX0RFQ0VMICogYnJha2U7XHJcblx0XHRcdGNvbnN0IG5ld1ZlbG9jaXR5ID0gdGhpcy52ZWxvY2l0eSArIHRoaXMuYWNjZWxlcmF0aW9uICogZGVsdGE7XHJcblxyXG5cdFx0XHQvLyBJZiBhcHBseWluZyB0aGUgYnJha2luZyBkZWNlbGVyYXRpb24gYXQgdGhlIG5leHQgc3RlcCB3b3VsZCBjYXVzZSB0aGUgdmVsb2NpdHlcclxuXHRcdFx0Ly8gdG8gY2hhbmdlIGRpcmVjdGlvbnMsIHRoZW4ganVzdCBzZXQgdGhlIGNhciBhcyBzdG9wcGVkLlxyXG5cdFx0XHRpZiAoIE1hdGguc2lnbiggbmV3VmVsb2NpdHkgKSAhPSBNYXRoLnNpZ24oIHRoaXMudmVsb2NpdHkgKSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy52ZWxvY2l0eSA9IDA7XHJcblx0XHRcdFx0dGhpcy5hY2NlbGVyYXRpb24gPSAwO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLmFjY2VsZXJhdGlvbiA9IENhci5NQVhfR0FTX0FDQ0VMICogZ2FzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHN0ZWVyICE9IDAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLndoZWVsQW5ndWxhclZlbG9jaXR5ID0gc3RlZXIgKiBDYXIuTUFYX1NURUVSX1NQRUVEO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLndoZWVsQW5ndWxhclZlbG9jaXR5ID0gTWF0aC5jbGFtcCggLXRoaXMud2hlZWxBbmdsZSAvIENhci5NQVhfV0hFRUxfQU5HTEUgKiB0aGlzLnZlbG9jaXR5ICogdGhpcy52ZWxvY2l0eSAqIGRlbHRhLCAtQ2FyLk1BWF9TVEVFUl9TUEVFRCwgQ2FyLk1BWF9TVEVFUl9TUEVFRCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5sYXN0VGltZUxvZ2dlciA+IDUwMDAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmxhc3RUaW1lTG9nZ2VyID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcblx0XHRcdGNvbnNvbGUubG9nKCB0aGlzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuQ2FyLkhBTEZfQ0FSX0xFTkdUSCA9IDIuNTsgLy8gbWV0ZXJzXHJcbkNhci5IQUxGX0NBUl9XSURUSCA9IDE7IC8vIG1ldGVyc1xyXG5DYXIuSEFMRl9XSEVFTF9MRU5HVEggPSAwLjM4OyAvLyBtZXRlcnNcclxuQ2FyLkhBTEZfV0hFRUxfV0lEVEggPSAwLjEyOyAvLyBtZXRlcnNcclxuQ2FyLk1BWF9XSEVFTF9BTkdMRSA9IDMyIC8gMTgwICogTWF0aC5QSTsgLy8gcmFkaWFuc1xyXG5DYXIuTUFTUyA9IDE2MDA7IC8vIGtnXHJcbkNhci5EUkFHX0NPRUZGID0gMC43O1xyXG5DYXIuREVOU0lUWV9PRl9BSVIgPSAxLjg1ODA2MDg7IC8vIChrZy9tXjMpXHJcbkNhci5GUk9OVEFMX0FSRUEgPSAxLjg1OyAvLyBtXjJcclxuQ2FyLlJPTExfUkVTSVNUID0gMDtcclxuQ2FyLk1BWF9TVEVFUl9TUEVFRCA9IDAuODsvLzEuMjsgLy8gUmFkaWFucyBwZXIgc2Vjb25kXHJcbkNhci5NQVhfR0FTX0FDQ0VMID0gMy41OyAvLyBtIC8gc14yXHJcbkNhci5NQVhfQlJBS0VfREVDRUwgPSA2LjU7IC8vIG0gLyBzXjJcclxuQ2FyLldIRUVMX0xBVEVSQUxfUE9TID0gMC44NDM7IC8vIG1ldGVyc1xyXG5DYXIuRlJPTlRfQVhMRV9QT1MgPSAxLjY7IC8vIG1ldGVyc1xyXG5DYXIuUkVBUl9BWExFX1BPUyA9IC0xLjQzOyAvLyBtZXRlcnNcclxuQ2FyLldIRUVMX0JBU0UgPSBDYXIuRlJPTlRfQVhMRV9QT1MgLSBDYXIuUkVBUl9BWExFX1BPUzsgLy8gbWV0ZXJzXHJcbkNhci5NQVhfTEFURVJBTF9BQ0NFTCA9IDkuODE7IC8vIG0gLyBzXjJcclxuIiwiY29uc3QgU0lNUFNPTlNfSU5URVJWQUxTID0gODtcclxuY29uc3QgTkVXVE9OX0lURVJBVElPTlMgPSAxNjtcclxuY29uc3QgUkVMQVhBVElPTl9JVEVSQVRJT05TID0gMzI7XHJcbmNvbnN0IENPTlZFUkdFTkNFX0VSUk9SID0gMC4wMTtcclxuXHJcbmNvbnN0IGphY29iaWFuID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcclxuY29uc3QgaW52SmFjb2JpYW4gPSBuZXcgVEhSRUUuTWF0cml4MygpO1xyXG5cclxuLy8gQWx0ZXJuYXRlIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0Fwb2xsb0F1dG8vYXBvbGxvL2Jsb2IvbWFzdGVyL21vZHVsZXMvcGxhbm5pbmcvbWF0aC9zcGlyYWxfY3VydmUvY3ViaWNfc3BpcmFsX2N1cnZlLmNjXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEN1YmljUGF0aCB7XHJcbiAgY29uc3RydWN0b3Ioc3RhcnQsIGVuZCwgcGFyYW1zID0gbnVsbCkge1xyXG4gICAgdGhpcy5zdGFydCA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXJ0KTtcclxuICAgIHRoaXMuZW5kID0gT2JqZWN0LmFzc2lnbih7fSwgZW5kKTtcclxuXHJcbiAgICBpZiAoc3RhcnQucG9zKSB7XHJcbiAgICAgIHRoaXMuc3RhcnQueCA9IHN0YXJ0LnBvcy54O1xyXG4gICAgICB0aGlzLnN0YXJ0LnkgPSBzdGFydC5wb3MueVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChlbmQucG9zKSB7XHJcbiAgICAgIHRoaXMuZW5kLnggPSBlbmQucG9zLng7XHJcbiAgICAgIHRoaXMuZW5kLnkgPSBlbmQucG9zLnlcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkaWZmWCA9IHRoaXMuZW5kLnggLSB0aGlzLnN0YXJ0Lng7XHJcbiAgICBjb25zdCBkaWZmWSA9IHRoaXMuZW5kLnkgLSB0aGlzLnN0YXJ0Lnk7XHJcbiAgICBjb25zdCBzaW5Sb3QgPSBNYXRoLnNpbih0aGlzLnN0YXJ0LnJvdCk7XHJcbiAgICBjb25zdCBjb3NSb3QgPSBNYXRoLmNvcyh0aGlzLnN0YXJ0LnJvdCk7XHJcblxyXG4gICAgdGhpcy5nb2FsID0ge1xyXG4gICAgICB4OiBjb3NSb3QgKiBkaWZmWCArIHNpblJvdCAqIGRpZmZZLFxyXG4gICAgICB5OiAtc2luUm90ICogZGlmZlggKyBjb3NSb3QgKiBkaWZmWSxcclxuICAgICAgcm90OiBNYXRoLndyYXBBbmdsZSh0aGlzLmVuZC5yb3QgLSB0aGlzLnN0YXJ0LnJvdCksXHJcbiAgICAgIGN1cnY6IHRoaXMuZW5kLmN1cnZcclxuICAgIH07XHJcblxyXG4gICAgaWYgKHBhcmFtcylcclxuICAgICAgdGhpcy5wYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMsIHsgcDA6IHRoaXMuc3RhcnQuY3VydiwgcDM6IHRoaXMuZW5kLmN1cnYgfSk7XHJcbiAgICBlbHNlXHJcbiAgICAgIHRoaXMuZ3Vlc3NJbml0aWFsUGFyYW1zKCk7XHJcblxyXG4gICAgdGhpcy5jb252ZXJnZWQgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIGd1ZXNzSW5pdGlhbFBhcmFtcygpIHtcclxuICAgIGNvbnN0IG9yaWdpbmFsR29hbCA9IHRoaXMuZ29hbDtcclxuICAgIGNvbnN0IGRTdGFydEN1cnYgPSB0aGlzLnN0YXJ0LmN1cnYgLyBSRUxBWEFUSU9OX0lURVJBVElPTlM7XHJcbiAgICBjb25zdCBkR29hbFkgPSBvcmlnaW5hbEdvYWwueSAvIFJFTEFYQVRJT05fSVRFUkFUSU9OUztcclxuICAgIGNvbnN0IGRHb2FsUm90ID0gb3JpZ2luYWxHb2FsLnJvdCAvIFJFTEFYQVRJT05fSVRFUkFUSU9OUztcclxuICAgIGNvbnN0IGRHb2FsQ3VydiA9IG9yaWdpbmFsR29hbC5jdXJ2IC8gUkVMQVhBVElPTl9JVEVSQVRJT05TO1xyXG5cclxuICAgIHRoaXMuZ29hbCA9IHtcclxuICAgICAgeDogb3JpZ2luYWxHb2FsLngsXHJcbiAgICAgIHk6IDAsXHJcbiAgICAgIHJvdDogMCxcclxuICAgICAgY3VydjogMFxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnBhcmFtcyA9IHtcclxuICAgICAgcDA6IDAsXHJcbiAgICAgIHAxOiAwLFxyXG4gICAgICBwMjogMCxcclxuICAgICAgcDM6IDAsXHJcbiAgICAgIHNHOiBvcmlnaW5hbEdvYWwueFxyXG4gICAgfTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFJFTEFYQVRJT05fSVRFUkFUSU9OUzsgaSsrKSB7XHJcbiAgICAgIHRoaXMucGFyYW1zLnAwICs9IGRTdGFydEN1cnY7XHJcbiAgICAgIHRoaXMucGFyYW1zLnAzICs9IGRHb2FsQ3VydjtcclxuICAgICAgdGhpcy5nb2FsLnkgKz0gZEdvYWxZO1xyXG4gICAgICB0aGlzLmdvYWwucm90ICs9IGRHb2FsUm90O1xyXG4gICAgICB0aGlzLmdvYWwuY3VydiArPSBkR29hbEN1cnY7XHJcblxyXG4gICAgICB0aGlzLml0ZXJhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmdvYWwgPSBvcmlnaW5hbEdvYWw7XHJcbiAgfVxyXG5cclxuICBvcHRpbWl6ZSgpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTkVXVE9OX0lURVJBVElPTlM7IGkrKykge1xyXG4gICAgICBpZiAodGhpcy5pdGVyYXRlKCkpIHtcclxuICAgICAgICB0aGlzLmNvbnZlcmdlZCA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmNvbnZlcmdlZCA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgaXRlcmF0ZSgpIHtcclxuICAgIGNvbnN0IHsgcDAsIHAxLCBwMiwgcDMsIHNHIH0gPSB0aGlzLnBhcmFtcztcclxuXHJcbiAgICBjb25zdCBkcyA9IHNHIC8gU0lNUFNPTlNfSU5URVJWQUxTO1xyXG4gICAgY29uc3Qgc0dfMiA9IHNHICogc0c7XHJcbiAgICBjb25zdCBzR18zID0gc0dfMiAqIHNHO1xyXG5cclxuICAgIGxldCBkWF9wMSA9IDA7XHJcbiAgICBsZXQgZFhfcDIgPSAwO1xyXG4gICAgbGV0IGRYX3NHID0gMDtcclxuICAgIGxldCBkWV9wMSA9IDA7XHJcbiAgICBsZXQgZFlfcDIgPSAwO1xyXG4gICAgbGV0IGRZX3NHID0gMDtcclxuICAgIGxldCBndWVzc1ggPSAwO1xyXG4gICAgbGV0IGd1ZXNzWSA9IDA7XHJcblxyXG4gICAgbGV0IHRoZXRhLCBjb3NUaGV0YSwgc2luVGhldGEsIGRUX3AxLCBkVF9wMiwgZFRfc0c7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDAsIHMgPSAwOyBpIDw9IFNJTVBTT05TX0lOVEVSVkFMUzsgaSsrLCBzICs9IGRzKSB7XHJcbiAgICAgIGNvbnN0IGNvZWZmID0gaSA9PSAwIHx8IGkgPT0gU0lNUFNPTlNfSU5URVJWQUxTID8gMSA6IGkgJSAyID09IDAgPyAyIDogNDtcclxuXHJcbiAgICAgIGNvbnN0IGEgPSBwMDtcclxuICAgICAgY29uc3QgYiA9ICgtNS41ICogcDAgKyA5ICogcDEgLSA0LjUgKiBwMiArIHAzKSAvIHNHO1xyXG4gICAgICBjb25zdCBjID0gKDkgKiBwMCAtIDIyLjUgKiBwMSArIDE4ICogcDIgLSA0LjUgKiBwMykgLyBzR18yO1xyXG4gICAgICBjb25zdCBkID0gKC00LjUgKiAocDAgLSAzICogcDEgKyAzICogcDIgLSBwMykpIC8gc0dfMztcclxuXHJcbiAgICAgIHRoZXRhID0gKCgoZCAqIHMgLyA0ICsgYyAvIDMpICogcyArIGIgLyAyKSAqIHMgKyBhKSAqIHM7XHJcbiAgICAgIGNvc1RoZXRhID0gTWF0aC5jb3ModGhldGEpO1xyXG4gICAgICBzaW5UaGV0YSA9IE1hdGguc2luKHRoZXRhKTtcclxuXHJcbiAgICAgIGNvbnN0IHNfc0cgPSBzIC8gc0c7XHJcbiAgICAgIGRUX3AxID0gKCgzLjM3NSAqIHNfc0cgLSA3LjUpICogc19zRyArIDQuNSkgKiBzX3NHICogcztcclxuICAgICAgZFRfcDIgPSAoKC0zLjM3NSAqIHNfc0cgKyA2KSAqIHNfc0cgLSAyLjI1KSAqIHNfc0cgKiBzO1xyXG4gICAgICBkVF9zRyA9ICgoMy4zNzUgKiAocDAgLSAzICogcDEgKyAzICogcDIgLSBwMykgKiBzX3NHIC0gMyAqICgyICogcDAgLSA1ICogcDEgKyA0ICogcDIgLSBwMykpICogc19zRyArIDAuMjUgKiAoMTEgKiBwMCAtIDE4ICogcDEgKyA5ICogcDIgLSAyICogcDMpKSAqIHNfc0cgKiBzX3NHO1xyXG5cclxuICAgICAgZFhfcDEgLT0gY29lZmYgKiBzaW5UaGV0YSAqIGRUX3AxO1xyXG4gICAgICBkWF9wMiAtPSBjb2VmZiAqIHNpblRoZXRhICogZFRfcDI7XHJcbiAgICAgIGRYX3NHIC09IGNvZWZmICogc2luVGhldGEgKiBkVF9zRztcclxuXHJcbiAgICAgIGRZX3AxICs9IGNvZWZmICogY29zVGhldGEgKiBkVF9wMTtcclxuICAgICAgZFlfcDIgKz0gY29lZmYgKiBjb3NUaGV0YSAqIGRUX3AyO1xyXG4gICAgICBkWV9zRyArPSBjb2VmZiAqIGNvc1RoZXRhICogZFRfc0c7XHJcblxyXG4gICAgICBndWVzc1ggKz0gY29lZmYgKiBjb3NUaGV0YTtcclxuICAgICAgZ3Vlc3NZICs9IGNvZWZmICogc2luVGhldGE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWZ0ZXIgdGhlIFNpbXBzb24ncyBpbnRlZ3JhdGlvbiBsb29wLCBgdGhldGFgLCBgY29zVGhldGFgLCBgc2luVGhldGFgLFxyXG4gICAgLy8gYGRUX3AxYCwgYGRUX3AyYCwgYW5kIGBkVF9zR2AgaG9sZCB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzIGZvciBgc0dgLlxyXG5cclxuICAgIGNvbnN0IGhPdmVyMyA9IHNHIC8gU0lNUFNPTlNfSU5URVJWQUxTIC8gMztcclxuXHJcbiAgICBjb25zdCBkZWx0YVggPSB0aGlzLmdvYWwueCAtIGd1ZXNzWCAqIGhPdmVyMztcclxuICAgIGNvbnN0IGRlbHRhWSA9IHRoaXMuZ29hbC55IC0gZ3Vlc3NZICogaE92ZXIzO1xyXG4gICAgY29uc3QgZGVsdGFSb3QgPSBNYXRoLndyYXBBbmdsZSh0aGlzLmdvYWwucm90IC0gdGhldGEpO1xyXG5cclxuICAgIGlmIChNYXRoLmFicyhkZWx0YVgpICsgTWF0aC5hYnMoZGVsdGFZKSArIE1hdGguYWJzKGRlbHRhUm90KSA8IENPTlZFUkdFTkNFX0VSUk9SKVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICBqYWNvYmlhbi5zZXQoXHJcbiAgICAgIGRYX3AxICogaE92ZXIzLCBkWF9wMiAqIGhPdmVyMywgY29zVGhldGEgKyBkWF9zRyAqIGhPdmVyMyxcclxuICAgICAgZFlfcDEgKiBoT3ZlcjMsIGRZX3AyICogaE92ZXIzLCBzaW5UaGV0YSArIGRZX3NHICogaE92ZXIzLFxyXG4gICAgICBkVF9wMSwgZFRfcDIsIGRUX3NHXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IFttMTEsIG0yMSwgbTMxLCBtMTIsIG0yMiwgbTMyLCBtMTMsIG0yMywgbTMzXSA9IGludkphY29iaWFuLmdldEludmVyc2UoamFjb2JpYW4pLmVsZW1lbnRzO1xyXG5cclxuICAgIHRoaXMucGFyYW1zLnAxICs9IG0xMSAqIGRlbHRhWCArIG0xMiAqIGRlbHRhWSArIG0xMyAqIGRlbHRhUm90O1xyXG4gICAgdGhpcy5wYXJhbXMucDIgKz0gbTIxICogZGVsdGFYICsgbTIyICogZGVsdGFZICsgbTIzICogZGVsdGFSb3Q7XHJcbiAgICB0aGlzLnBhcmFtcy5zRyArPSBtMzEgKiBkZWx0YVggKyBtMzIgKiBkZWx0YVkgKyBtMzMgKiBkZWx0YVJvdDtcclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBidWlsZFBhdGgobnVtKSB7XHJcbiAgICBjb25zdCB7IHAwLCBwMSwgcDIsIHAzLCBzRyB9ID0gdGhpcy5wYXJhbXM7XHJcblxyXG4gICAgY29uc3Qgc0dfMiA9IHNHICogc0c7XHJcbiAgICBjb25zdCBzR18zID0gc0dfMiAqIHNHO1xyXG5cclxuICAgIGNvbnN0IGEgPSBwMDtcclxuICAgIGNvbnN0IGIgPSAoLTUuNSAqIHAwICsgOSAqIHAxIC0gNC41ICogcDIgKyBwMykgLyBzRztcclxuICAgIGNvbnN0IGMgPSAoOSAqIHAwIC0gMjIuNSAqIHAxICsgMTggKiBwMiAtIDQuNSAqIHAzKSAvIHNHXzI7XHJcbiAgICBjb25zdCBkID0gKC00LjUgKiAocDAgLSAzICogcDEgKyAzICogcDIgLSBwMykpIC8gc0dfMztcclxuXHJcbiAgICBjb25zdCBwYXRoID0gW3sgcG9zOiBuZXcgVEhSRUUuVmVjdG9yMih0aGlzLnN0YXJ0LngsIHRoaXMuc3RhcnQueSksIHJvdDogdGhpcy5zdGFydC5yb3QsIGN1cnY6IHRoaXMuc3RhcnQuY3VydiB9XTtcclxuICAgIGNvbnN0IGRzID0gc0cgLyAobnVtIC0gMSk7XHJcbiAgICBsZXQgcyA9IGRzO1xyXG4gICAgbGV0IGR4ID0gMDtcclxuICAgIGxldCBkeSA9IDA7XHJcbiAgICBsZXQgcHJldkNvc1JvdCA9IE1hdGguY29zKHBhdGhbMF0ucm90KTtcclxuICAgIGxldCBwcmV2U2luUm90ID0gTWF0aC5zaW4ocGF0aFswXS5yb3QpO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbnVtIC0gMTsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHJvdCA9ICgoKGQgKiBzIC8gNCArIGMgLyAzKSAqIHMgKyBiIC8gMikgKiBzICsgYSkgKiBzICsgdGhpcy5zdGFydC5yb3Q7XHJcbiAgICAgIGNvbnN0IGN1cnYgPSAoKGQgKiBzICsgYykgKiBzICsgYikgKiBzICsgYTtcclxuICAgICAgY29uc3QgY29zUm90ID0gTWF0aC5jb3Mocm90KTtcclxuICAgICAgY29uc3Qgc2luUm90ID0gTWF0aC5zaW4ocm90KTtcclxuXHJcbiAgICAgIGR4ID0gZHggKiAoaSAtIDEpIC8gaSArIChjb3NSb3QgKyBwcmV2Q29zUm90KSAvICgyICogaSk7XHJcbiAgICAgIGR5ID0gZHkgKiAoaSAtIDEpIC8gaSArIChzaW5Sb3QgKyBwcmV2U2luUm90KSAvICgyICogaSk7XHJcblxyXG4gICAgICBwYXRoLnB1c2goeyBwb3M6IG5ldyBUSFJFRS5WZWN0b3IyKHMgKiBkeCArIHRoaXMuc3RhcnQueCwgcyAqIGR5ICsgdGhpcy5zdGFydC55KSwgcm90OiByb3QsIGN1cnY6IGN1cnYgfSk7XHJcblxyXG4gICAgICBzICs9IGRzO1xyXG4gICAgICBwcmV2Q29zUm90ID0gY29zUm90O1xyXG4gICAgICBwcmV2U2luUm90ID0gc2luUm90O1xyXG4gICAgfVxyXG5cclxuICAgIHBhdGgucHVzaCh7IHBvczogbmV3IFRIUkVFLlZlY3RvcjIodGhpcy5lbmQueCwgdGhpcy5lbmQueSksIHJvdDogdGhpcy5lbmQucm90LCBjdXJ2OiB0aGlzLmVuZC5jdXJ2IH0pO1xyXG5cclxuICAgIHJldHVybiBwYXRoO1xyXG4gIH1cclxufVxyXG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBRdWludGljUGF0aCB7XHJcbiAgY29uc3RydWN0b3Ioc3RhcnQsIGVuZCwgcGFyYW1zKSB7XHJcbiAgICB0aGlzLnN0YXJ0ID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhcnQpO1xyXG4gICAgdGhpcy5lbmQgPSBPYmplY3QuYXNzaWduKHt9LCBlbmQpO1xyXG5cclxuICAgIGlmIChzdGFydC5wb3MpIHtcclxuICAgICAgdGhpcy5zdGFydC54ID0gc3RhcnQucG9zLng7XHJcbiAgICAgIHRoaXMuc3RhcnQueSA9IHN0YXJ0LnBvcy55XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGVuZC5wb3MpIHtcclxuICAgICAgdGhpcy5lbmQueCA9IGVuZC5wb3MueDtcclxuICAgICAgdGhpcy5lbmQueSA9IGVuZC5wb3MueVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRpZmZYID0gdGhpcy5lbmQueCAtIHRoaXMuc3RhcnQueDtcclxuICAgIGNvbnN0IGRpZmZZID0gdGhpcy5lbmQueSAtIHRoaXMuc3RhcnQueTtcclxuICAgIGNvbnN0IHNpblJvdCA9IE1hdGguc2luKHRoaXMuc3RhcnQucm90KTtcclxuICAgIGNvbnN0IGNvc1JvdCA9IE1hdGguY29zKHRoaXMuc3RhcnQucm90KTtcclxuXHJcbiAgICB0aGlzLmdvYWwgPSB7XHJcbiAgICAgIHg6IGNvc1JvdCAqIGRpZmZYICsgc2luUm90ICogZGlmZlksXHJcbiAgICAgIHk6IC1zaW5Sb3QgKiBkaWZmWCArIGNvc1JvdCAqIGRpZmZZLFxyXG4gICAgICByb3Q6IE1hdGgud3JhcEFuZ2xlKHRoaXMuZW5kLnJvdCAtIHRoaXMuc3RhcnQucm90KSxcclxuICAgICAgY3VydjogdGhpcy5lbmQuY3VydlxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcywgeyBwMDogdGhpcy5zdGFydC5jdXJ2LCBwMTogdGhpcy5zdGFydC5kQ3VydiB8fCAwLCBwMjogdGhpcy5zdGFydC5kZEN1cnYgfHwgMCwgcDU6IHRoaXMuZW5kLmN1cnYgfSk7XHJcbiAgfVxyXG5cclxuICBidWlsZFBhdGgobnVtKSB7XHJcbiAgICBjb25zdCB7IHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUsIHNHIH0gPSB0aGlzLnBhcmFtcztcclxuXHJcbiAgICBjb25zdCBzR18yID0gc0cgKiBzRztcclxuICAgIGNvbnN0IHNHXzMgPSBzR18yICogc0c7XHJcblxyXG4gICAgY29uc3QgYSA9IHAwO1xyXG4gICAgY29uc3QgYiA9IHAxO1xyXG4gICAgY29uc3QgYyA9IHAyIC8gMi4wO1xyXG4gICAgY29uc3QgZCA9ICgtNzEuODc1ICogcDAgKyA4MS4wICogcDMgLSAxMC4xMjUgKiBwNCArIHA1IC0gMjEuMjUgKiBwMSAqIHNHIC0gMi43NSAqIHAyICogc0dfMikgLyBzR18zO1xyXG4gICAgY29uc3QgZSA9ICgxNjYuNSAqIHAwIC0gMjAyLjUgKiBwMyArIDQwLjUgKiBwNCAtIDQuNSAqIHA1ICsgNDUuMCAqIHAxICogc0cgKyA0LjUgKiBwMiAqIHNHXzIpIC8gKHNHXzIgKiBzR18yKTtcclxuICAgIGNvbnN0IGYgPSAoLTk1LjYyNSAqIHAwICsgMTIxLjUgKiBwMyAtIDMwLjM3NSAqIHA0ICsgNC41ICogcDUgLSAyNC43NSAqIHAxICogc0cgLSAyLjI1ICogcDIgKiBzR18yKSAvIChzR18yICogc0dfMyk7XHJcblxyXG4gICAgY29uc3QgcGF0aCA9IFt7IHBvczogbmV3IFRIUkVFLlZlY3RvcjIodGhpcy5zdGFydC54LCB0aGlzLnN0YXJ0LnkpLCByb3Q6IHRoaXMuc3RhcnQucm90LCBjdXJ2OiB0aGlzLnN0YXJ0LmN1cnYgfV07XHJcbiAgICBjb25zdCBkcyA9IHNHIC8gKG51bSAtIDEpO1xyXG4gICAgbGV0IHMgPSBkcztcclxuICAgIGxldCBkeCA9IDA7XHJcbiAgICBsZXQgZHkgPSAwO1xyXG4gICAgbGV0IHByZXZDb3NSb3QgPSBNYXRoLmNvcyhwYXRoWzBdLnJvdCk7XHJcbiAgICBsZXQgcHJldlNpblJvdCA9IE1hdGguc2luKHBhdGhbMF0ucm90KTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG51bSAtIDE7IGkrKykge1xyXG4gICAgICBjb25zdCByb3QgPSAoKCgoKGYgKiBzIC8gNi4wICsgZSAvIDUuMCkgKiBzICsgZCAvIDQuMCkgKiBzICsgYyAvIDMuMCkgKiBzICsgYiAvIDIuMCkgKiBzICsgYSkgKiBzICsgdGhpcy5zdGFydC5yb3Q7XHJcbiAgICAgIGNvbnN0IGN1cnYgPSAoKCgoZiAqIHMgKyBlKSAqIHMgKyBkKSAqIHMgKyBjKSAqIHMgKyBiKSAqIHMgKyBhO1xyXG4gICAgICBjb25zdCBjb3NSb3QgPSBNYXRoLmNvcyhyb3QpO1xyXG4gICAgICBjb25zdCBzaW5Sb3QgPSBNYXRoLnNpbihyb3QpO1xyXG5cclxuICAgICAgZHggPSBkeCAqIChpIC0gMSkgLyBpICsgKGNvc1JvdCArIHByZXZDb3NSb3QpIC8gKDIgKiBpKTtcclxuICAgICAgZHkgPSBkeSAqIChpIC0gMSkgLyBpICsgKHNpblJvdCArIHByZXZTaW5Sb3QpIC8gKDIgKiBpKTtcclxuXHJcbiAgICAgIHBhdGgucHVzaCh7IHBvczogbmV3IFRIUkVFLlZlY3RvcjIocyAqIGR4ICsgdGhpcy5zdGFydC54LCBzICogZHkgKyB0aGlzLnN0YXJ0LnkpLCByb3Q6IHJvdCwgY3VydjogY3VydiB9KTtcclxuXHJcbiAgICAgIHMgKz0gZHM7XHJcbiAgICAgIHByZXZDb3NSb3QgPSBjb3NSb3Q7XHJcbiAgICAgIHByZXZTaW5Sb3QgPSBzaW5Sb3Q7XHJcbiAgICB9XHJcblxyXG4gICAgcGF0aC5wdXNoKHsgcG9zOiBuZXcgVEhSRUUuVmVjdG9yMih0aGlzLmVuZC54LCB0aGlzLmVuZC55KSwgcm90OiB0aGlzLmVuZC5yb3QsIGN1cnY6IHRoaXMuZW5kLmN1cnYgfSk7XHJcblxyXG4gICAgcmV0dXJuIHBhdGg7XHJcbiAgfVxyXG59XHJcbiIsImNvbnN0IE9CU1RBQ0xFX1ZFUlRFWF9TSEFERVIgPSBgI3ZlcnNpb24gMzAwIGVzXHJcbnVuaWZvcm0gbWF0MyB4Zm9ybTtcclxuaW4gdmVjMiBwb3NpdGlvbjtcclxuXHJcbnZvaWQgbWFpbih2b2lkKSB7XHJcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KCh4Zm9ybSAqIHZlYzMocG9zaXRpb24sIDEpKS54eSwgMCwgMSk7XHJcbn1cclxuYDtcclxuXHJcbmNvbnN0IE9CU1RBQ0xFX0tFUk5FTCA9IGBcclxuICB2ZWM0IGtlcm5lbCgpIHtcclxuICAgIHJldHVybiB2ZWM0KDEsIDAsIDAsIDEpO1xyXG4gIH1cclxuYDtcclxuXHJcbmxldCBvYnN0YWNsZVZlcnRpY2VzO1xyXG5sZXQgb2JzdGFjbGVYZm9ybTtcclxuXHJcbi8vIERyYXcgb2JzdGFjbGUgdHJpYW5nbGVzIHRvIFhZLXNwYWNlIG9ic3RhY2xlIGdyaWRcclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHNldFVwKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAga2VybmVsOiBPQlNUQUNMRV9LRVJORUwsXHJcbiAgICAgIHZlcnRleFNoYWRlcjogT0JTVEFDTEVfVkVSVEVYX1NIQURFUixcclxuICAgICAgb3V0cHV0OiB7IG5hbWU6ICd4eU9ic3RhY2xlR3JpZCcgfSxcclxuICAgICAgZHJhdzogKGdwZ3B1LCBwcm9ncmFtKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSBncGdwdS5nbDtcclxuXHJcbiAgICAgICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcclxuICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcclxuXHJcbiAgICAgICAgaWYgKG9ic3RhY2xlVmVydGljZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgY29uc3QgYnVmID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblxyXG4gICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1Zik7XHJcbiAgICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgb2JzdGFjbGVWZXJ0aWNlcywgZ2wuU1RBVElDX0RSQVcpO1xyXG4gICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocHJvZ3JhbS5wb3NpdGlvbkxvY2F0aW9uKTtcclxuICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocHJvZ3JhbS5wb3NpdGlvbkxvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xyXG5cclxuICAgICAgICAgIGNvbnN0IHhmb3JtTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbS5nbFByb2dyYW0sICd4Zm9ybScpO1xyXG4gICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdih4Zm9ybUxvY2F0aW9uLCBmYWxzZSwgb2JzdGFjbGVYZm9ybS5lbGVtZW50cyk7XHJcblxyXG4gICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIG9ic3RhY2xlVmVydGljZXMubGVuZ3RoIC8gMik7XHJcblxyXG4gICAgICAgICAgZ2wuZGVsZXRlQnVmZmVyKGJ1Zik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0sXHJcblxyXG4gIHVwZGF0ZShjb25maWcsIHh5V2lkdGgsIHh5SGVpZ2h0LCB4eUNlbnRlclBvaW50LCB2ZWhpY2xlWGZvcm0sIG9ic3RhY2xlcykge1xyXG4gICAgb2JzdGFjbGVWZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgb2JzdGFjbGVzLm1hcChvID0+IG8udmVydGljZXMpKSk7XHJcblxyXG4gICAgY29uc3QgdHJhbnNsYXRlID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcclxuICAgIHRyYW5zbGF0ZS5zZXQoXHJcbiAgICAgIDEsIDAsIC14eUNlbnRlclBvaW50LngsXHJcbiAgICAgIDAsIDEsIC14eUNlbnRlclBvaW50LnksXHJcbiAgICAgIDAsIDAsIDFcclxuICAgICk7XHJcblxyXG4gICAgY29uc3Qgc2NhbGUgPSBuZXcgVEhSRUUuTWF0cml4MygpO1xyXG4gICAgc2NhbGUuc2V0KFxyXG4gICAgICAyIC8gKHh5V2lkdGggKiBjb25maWcueHlHcmlkQ2VsbFNpemUpLCAwLCAwLFxyXG4gICAgICAwLCAyIC8gKHh5SGVpZ2h0ICogY29uZmlnLnh5R3JpZENlbGxTaXplKSwgMCxcclxuICAgICAgMCwgMCwgMVxyXG4gICAgKTtcclxuXHJcbiAgICBvYnN0YWNsZVhmb3JtID0gc2NhbGUubXVsdGlwbHkodHJhbnNsYXRlKS5tdWx0aXBseSh2ZWhpY2xlWGZvcm0pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHdpZHRoOiB4eVdpZHRoLFxyXG4gICAgICBoZWlnaHQ6IHh5SGVpZ2h0XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsImNvbnN0IFNMX09CU1RBQ0xFX0tFUk5FTCA9IGBcclxuXHJcbnZlYzQga2VybmVsKCkge1xyXG4gIGZsb2F0IGNlbnRlcmxpbmVXaWR0aCA9IGZsb2F0KHRleHR1cmVTaXplKGNlbnRlcmxpbmUsIDApLngpO1xyXG5cclxuICB2ZWMyIHNsID0gKGtlcm5lbFBvc2l0aW9uIC0gMC41KSAqIHZlYzIoa2VybmVsU2l6ZSkgKiB2ZWMyKHNsR3JpZENlbGxTaXplKSArIHNsQ2VudGVyUG9pbnQ7XHJcbiAgZmxvYXQgY2VudGVybGluZUNvb3JkID0gc2wueCAvIGNlbnRlcmxpbmVTdGF0aW9uSW50ZXJ2YWwgLyBjZW50ZXJsaW5lV2lkdGggKiAoY2VudGVybGluZVdpZHRoIC0gMS4wKSAvIGNlbnRlcmxpbmVXaWR0aCArICgwLjUgLyBjZW50ZXJsaW5lV2lkdGgpO1xyXG4gIGlmIChjZW50ZXJsaW5lQ29vcmQgPCAwLjAgfHwgY2VudGVybGluZUNvb3JkID4gMS4wKSByZXR1cm4gdmVjNCgwKTtcclxuXHJcbiAgdmVjMyBjZW50ZXJsaW5lU2FtcGxlID0gdGV4dHVyZShjZW50ZXJsaW5lLCB2ZWMyKGNlbnRlcmxpbmVDb29yZCwgMCkpLnh5ejtcclxuICBmbG9hdCBwZXJwaW5kaWN1bGFyID0gY2VudGVybGluZVNhbXBsZS56ICsgcmFkaWFucyg5MC4wKTtcclxuICB2ZWMyIHh5ID0gY2VudGVybGluZVNhbXBsZS54eSArIHNsLnl5ICogdmVjMihjb3MocGVycGluZGljdWxhciksIHNpbihwZXJwaW5kaWN1bGFyKSk7XHJcblxyXG4gIHZlYzIgeHlUZXhDb29yZHMgPSAoeHkgLSB4eUNlbnRlclBvaW50KSAvIHZlYzIodGV4dHVyZVNpemUoeHlPYnN0YWNsZUdyaWQsIDApKSAvIHZlYzIoeHlHcmlkQ2VsbFNpemUpICsgMC41O1xyXG4gIHJldHVybiB0ZXh0dXJlKHh5T2JzdGFjbGVHcmlkLCB4eVRleENvb3Jkcyk7XHJcbn1cclxuXHJcbmA7XHJcblxyXG4vLyBDb252ZXJ0IFhZLXNwYWNlIG9ic3RhY2xlIGdyaWQgdG8gU0wtc3BhY2Ugb2JzdGFjbGUgZ3JpZFxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgc2V0VXAoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBrZXJuZWw6IFNMX09CU1RBQ0xFX0tFUk5FTCxcclxuICAgICAgb3V0cHV0OiB7IG5hbWU6ICdzbE9ic3RhY2xlR3JpZCcgfSxcclxuICAgICAgdW5pZm9ybXM6IHtcclxuICAgICAgICB4eU9ic3RhY2xlR3JpZDogeyB0eXBlOiAnb3V0cHV0VGV4dHVyZScgfSxcclxuICAgICAgICBzbEdyaWRDZWxsU2l6ZTogeyB0eXBlOiAnZmxvYXQnIH0sXHJcbiAgICAgICAgeHlHcmlkQ2VsbFNpemU6IHsgdHlwZTogJ2Zsb2F0JyB9LFxyXG4gICAgICAgIHNsQ2VudGVyUG9pbnQ6IHsgdHlwZTogJ3ZlYzInIH0sXHJcbiAgICAgICAgeHlDZW50ZXJQb2ludDogeyB0eXBlOiAndmVjMicgfSxcclxuICAgICAgICBjZW50ZXJsaW5lU3RhdGlvbkludGVydmFsOiB7IHR5cGU6ICdmbG9hdCcgfSxcclxuICAgICAgICBjZW50ZXJsaW5lOiB7IHR5cGU6ICdzaGFyZWRUZXh0dXJlJyB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICB1cGRhdGUoY29uZmlnLCBzbFdpZHRoLCBzbEhlaWdodCwgc2xDZW50ZXJQb2ludCwgeHlDZW50ZXJQb2ludCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgd2lkdGg6IHNsV2lkdGgsXHJcbiAgICAgIGhlaWdodDogc2xIZWlnaHQsXHJcbiAgICAgIHVuaWZvcm1zOiB7XHJcbiAgICAgICAgc2xHcmlkQ2VsbFNpemU6IGNvbmZpZy5zbEdyaWRDZWxsU2l6ZSxcclxuICAgICAgICB4eUdyaWRDZWxsU2l6ZTogY29uZmlnLnh5R3JpZENlbGxTaXplLFxyXG4gICAgICAgIHNsQ2VudGVyUG9pbnQ6IFtzbENlbnRlclBvaW50LngsIHNsQ2VudGVyUG9pbnQueV0sXHJcbiAgICAgICAgeHlDZW50ZXJQb2ludDogW3h5Q2VudGVyUG9pbnQueCwgeHlDZW50ZXJQb2ludC55XSxcclxuICAgICAgICBjZW50ZXJsaW5lU3RhdGlvbkludGVydmFsOiBjb25maWcuY2VudGVybGluZVN0YXRpb25JbnRlcnZhbFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsImNvbnN0IFNMX09CU1RBQ0xFX0RJTEFUSU9OX0tFUk5FTCA9IGBcclxuXHJcbi8vIFRPRE86IHRlc3QgcGVyZm9ybWFuY2Ugb2YgcmV0dXJuaW5nIGVhcmx5IGlmIG5vbi16ZXJvIHBpeGVsIGZvdW5kXHJcbnZlYzQga2VybmVsKCkge1xyXG4gIGZsb2F0IHZhbCA9IDAuMDtcclxuXHJcbiAgZm9yIChpbnQgZCA9IDA7IGQgPD0gY29sbGlzaW9uRGlsYXRpb247IGQrKykge1xyXG4gICAgdmFsID0gbWF4KHZhbCwgdGV4dHVyZShzbE9ic3RhY2xlR3JpZCwga2VybmVsUG9zaXRpb24gKyBkZWx0YSAqIHZlYzIoZCkpLnIpO1xyXG4gICAgdmFsID0gbWF4KHZhbCwgdGV4dHVyZShzbE9ic3RhY2xlR3JpZCwga2VybmVsUG9zaXRpb24gKyBkZWx0YSAqIHZlYzIoLWQpKS5yKTtcclxuICB9XHJcblxyXG4gIGZvciAoaW50IGQgPSBjb2xsaXNpb25EaWxhdGlvbiArIDE7IGQgPD0gY29sbGlzaW9uRGlsYXRpb24gKyBoYXphcmREaWxhdGlvbjsgZCsrKSB7XHJcbiAgICB2YWwgPSBtYXgodmFsLCB0ZXh0dXJlKHNsT2JzdGFjbGVHcmlkLCBrZXJuZWxQb3NpdGlvbiArIGRlbHRhICogdmVjMihkKSkuciAqIDAuNSk7XHJcbiAgICB2YWwgPSBtYXgodmFsLCB0ZXh0dXJlKHNsT2JzdGFjbGVHcmlkLCBrZXJuZWxQb3NpdGlvbiArIGRlbHRhICogdmVjMigtZCkpLnIgKiAwLjUpO1xyXG4gIH1cclxuXHJcbiAgdmFsID0gbWF4KHZhbCwgc3RlcCgwLjEsIHZhbCkgKiAwLjUpO1xyXG5cclxuICByZXR1cm4gdmVjNCh2YWwsIDAsIDAsIDEpO1xyXG59XHJcblxyXG5gO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHNldFVwKCkge1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgeyAvLyBTTC1zcGFjZSBvYnN0YWNsZSBncmlkIFMgZGlsYXRpb25cclxuICAgICAgICBrZXJuZWw6IFNMX09CU1RBQ0xFX0RJTEFUSU9OX0tFUk5FTCxcclxuICAgICAgICBvdXRwdXQ6IHsgbmFtZTogJ3NsT2JzdGFjbGVHcmlkU3RhdGlvbkRpbGF0ZWQnIH0sXHJcbiAgICAgICAgdW5pZm9ybXM6IHtcclxuICAgICAgICAgIHNsT2JzdGFjbGVHcmlkOiB7IHR5cGU6ICdvdXRwdXRUZXh0dXJlJyB9LFxyXG4gICAgICAgICAgZGVsdGE6IHsgdHlwZTogJ3ZlYzInIH0sXHJcbiAgICAgICAgICBjb2xsaXNpb25EaWxhdGlvbjogeyB0eXBlOiAnaW50JyB9LFxyXG4gICAgICAgICAgaGF6YXJkRGlsYXRpb246IHsgdHlwZTogJ2ludCcgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgeyAvLyBTTC1zcGFjZSBvYnN0YWNsZSBncmlkIEwgZGlsYXRpb25cclxuICAgICAgICBrZXJuZWw6IFNMX09CU1RBQ0xFX0RJTEFUSU9OX0tFUk5FTCxcclxuICAgICAgICBvdXRwdXQ6IHsgbmFtZTogJ3NsT2JzdGFjbGVHcmlkRGlsYXRlZCcgfSxcclxuICAgICAgICB1bmlmb3Jtczoge1xyXG4gICAgICAgICAgc2xPYnN0YWNsZUdyaWQ6IHsgdHlwZTogJ291dHB1dFRleHR1cmUnLCBuYW1lOiAnc2xPYnN0YWNsZUdyaWRTdGF0aW9uRGlsYXRlZCcgfSxcclxuICAgICAgICAgIGRlbHRhOiB7IHR5cGU6ICd2ZWMyJyB9LFxyXG4gICAgICAgICAgY29sbGlzaW9uRGlsYXRpb246IHsgdHlwZTogJ2ludCcgfSxcclxuICAgICAgICAgIGhhemFyZERpbGF0aW9uOiB7IHR5cGU6ICdpbnQnIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIF07XHJcbiAgfSxcclxuXHJcbiAgdXBkYXRlKGNvbmZpZywgc2xXaWR0aCwgc2xIZWlnaHQpIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgIHsgLy8gU0wtc3BhY2Ugb2JzdGFjbGUgZ3JpZCBTIGRpbGF0aW9uXHJcbiAgICAgICAgd2lkdGg6IHNsV2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBzbEhlaWdodCxcclxuICAgICAgICB1bmlmb3Jtczoge1xyXG4gICAgICAgICAgZGVsdGE6IFsxIC8gc2xXaWR0aCwgMF0sXHJcbiAgICAgICAgICBjb2xsaXNpb25EaWxhdGlvbjogTWF0aC5jZWlsKGNvbmZpZy5jb2xsaXNpb25EaWxhdGlvblMgLyBjb25maWcuc2xHcmlkQ2VsbFNpemUpLFxyXG4gICAgICAgICAgaGF6YXJkRGlsYXRpb246IE1hdGguY2VpbChjb25maWcuaGF6YXJkRGlsYXRpb25TIC8gY29uZmlnLnNsR3JpZENlbGxTaXplKVxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgeyAvLyBTTC1zcGFjZSBvYnN0YWNsZSBncmlkIEwgZGlsYXRpb25cclxuICAgICAgICB3aWR0aDogc2xXaWR0aCxcclxuICAgICAgICBoZWlnaHQ6IHNsSGVpZ2h0LFxyXG4gICAgICAgIHVuaWZvcm1zOiB7XHJcbiAgICAgICAgICBkZWx0YTogWzAsIDEgLyBzbEhlaWdodF0sXHJcbiAgICAgICAgICBjb2xsaXNpb25EaWxhdGlvbjogTWF0aC5jZWlsKGNvbmZpZy5jb2xsaXNpb25EaWxhdGlvbkwgLyBjb25maWcuc2xHcmlkQ2VsbFNpemUpLFxyXG4gICAgICAgICAgaGF6YXJkRGlsYXRpb246IE1hdGguY2VpbChjb25maWcuaGF6YXJkRGlsYXRpb25MIC8gY29uZmlnLnNsR3JpZENlbGxTaXplKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgXTtcclxuICB9XHJcbn1cclxuIiwiY29uc3QgRFlOQU1JQ19PQlNUQUNMRV9WRVJURVhfU0hBREVSID0gYCN2ZXJzaW9uIDMwMCBlc1xyXG51bmlmb3JtIG1hdDMgeGZvcm07XHJcbmluIHZlYzMgcG9zaXRpb247XHJcbm91dCBmbG9hdCBjb2xvcjtcclxuXHJcbnZvaWQgbWFpbih2b2lkKSB7XHJcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KCh4Zm9ybSAqIHZlYzMocG9zaXRpb24ueHksIDEpKS54eSwgcG9zaXRpb24ueiwgMSk7XHJcblxyXG4gIC8vIFRoZSB6IGNvb3JkaW5hdGUgaXMgMC4yNSBmb3IgY29sbGlzaW9uIHpvbmUgYW5kIDAuNzUgZm9yIGhhemFyZCB6b25lLFxyXG4gIC8vIHNvIHRoYXQgdGhlIGNvbGxpc2lvbiB6b25lIGlzIGRyYXduIG9uIHRvcC5cclxuICAvLyBDb252ZXJ0IHRoaXMgdG8gMS4wIGZvciBjb2xsaXNpb24gem9uZSwgMC41IGZvciBoYXphcmQgem9uZVxyXG4gIGNvbG9yID0gKDEuMCAtIHN0ZXAoMC41LCBwb3NpdGlvbi56KSkgKiAwLjUgKyAwLjU7XHJcbn1cclxuYDtcclxuXHJcbmNvbnN0IERZTkFNSUNfT0JTVEFDTEVfS0VSTkVMID0gYFxyXG4gIGluIGZsb2F0IGNvbG9yO1xyXG5cclxuICB2ZWM0IGtlcm5lbCgpIHtcclxuICAgIHJldHVybiB2ZWM0KGNvbG9yLCAwLCAwLCAxKTtcclxuICB9XHJcbmA7XHJcblxyXG5sZXQgb2JzdGFjbGVWZXJ0aWNlcztcclxubGV0IG9ic3RhY2xlWGZvcm07XHJcbmNvbnN0IG51bUR5bmFtaWNGcmFtZXMgPSAyMDtcclxuXHJcbi8vIERyYXcgZHluYW1pYyBvYnN0YWNsZSB0cmlhbmdsZXMgdG8gU0wtc3BhY2Ugb2JzdGFjbGUgZ3JpZFxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgc2V0VXAoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBrZXJuZWw6IERZTkFNSUNfT0JTVEFDTEVfS0VSTkVMLFxyXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IERZTkFNSUNfT0JTVEFDTEVfVkVSVEVYX1NIQURFUixcclxuICAgICAgb3V0cHV0OiB7IG5hbWU6ICdzbER5bmFtaWNPYnN0YWNsZUdyaWQnLCB0ZXh0dXJlVHlwZTogJzJEQXJyYXknLCBkZXB0aDogbnVtRHluYW1pY0ZyYW1lcyB9LFxyXG4gICAgICBkcmF3OiAoZ3BncHUsIHByb2dyYW0pID0+IHtcclxuICAgICAgICBjb25zdCBnbCA9IGdwZ3B1LmdsO1xyXG5cclxuICAgICAgICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlbmRlcmJ1ZmZlciA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xyXG4gICAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIpO1xyXG4gICAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoZ2wuUkVOREVSQlVGRkVSLCBnbC5ERVBUSF9DT01QT05FTlQxNiwgcHJvZ3JhbS5pbnB1dFdpZHRoLCBwcm9ncmFtLmlucHV0SGVpZ2h0KTtcclxuICAgICAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuREVQVEhfQVRUQUNITUVOVCwgZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIpO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBmcmFtZSA9IDA7IGZyYW1lIDwgbnVtRHluYW1pY0ZyYW1lczsgZnJhbWUrKykge1xyXG4gICAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlTGF5ZXIoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBwcm9ncmFtLm91dHB1dFRleHR1cmUsIDAsIGZyYW1lKTtcclxuICAgICAgICAgIGNvbnN0IGZyYW1lQnVmZmVyU3RhdHVzID0gKGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZ2wuRlJBTUVCVUZGRVIpID09IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKTtcclxuICAgICAgICAgIGlmICghZnJhbWVCdWZmZXJTdGF0dXMpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgYXR0YWNoaW5nIGZsb2F0IHRleHR1cmUgdG8gZnJhbWVidWZmZXIuIFlvdXIgZGV2aWNlIGlzIHByb2JhYmx5IGluY29tcGF0aWJsZS4nKTtcclxuXHJcbiAgICAgICAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApO1xyXG4gICAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQpO1xyXG5cclxuICAgICAgICAgIGlmIChvYnN0YWNsZVZlcnRpY2VzW2ZyYW1lXS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cclxuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1Zik7XHJcbiAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBvYnN0YWNsZVZlcnRpY2VzW2ZyYW1lXSwgZ2wuU1RBVElDX0RSQVcpO1xyXG4gICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwcm9ncmFtLnBvc2l0aW9uTG9jYXRpb24pO1xyXG4gICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHByb2dyYW0ucG9zaXRpb25Mb2NhdGlvbiwgMywgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHhmb3JtTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbS5nbFByb2dyYW0sICd4Zm9ybScpO1xyXG4gICAgICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHhmb3JtTG9jYXRpb24sIGZhbHNlLCBvYnN0YWNsZVhmb3JtLmVsZW1lbnRzKTtcclxuXHJcbiAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCBvYnN0YWNsZVZlcnRpY2VzW2ZyYW1lXS5sZW5ndGggLyAzKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChmcmFtZSA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgY29uc3Qgb2JzdGFjbGVHcmlkID0gbmV3IEZsb2F0MzJBcnJheShwcm9ncmFtLmlucHV0V2lkdGggKiBwcm9ncmFtLmlucHV0SGVpZ2h0ICogNCk7XHJcbiAgICAgICAgICAgICAgZ2wucmVhZFBpeGVscygwLCAwLCBwcm9ncmFtLmlucHV0V2lkdGgsIHByb2dyYW0uaW5wdXRIZWlnaHQsIGdsLlJHQkEsIGdsLkZMT0FULCBvYnN0YWNsZUdyaWQpO1xyXG4gICAgICAgICAgICAgIGdwZ3B1Ll9keW5hbWljT2JzdGFjbGVHcmlkID0gb2JzdGFjbGVHcmlkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBnbC5kZWxldGVCdWZmZXIoYnVmKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBudWxsKTtcclxuICAgICAgICBnbC5kZWxldGVSZW5kZXJidWZmZXIocmVuZGVyYnVmZmVyKTtcclxuICAgICAgICBnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0sXHJcblxyXG4gIHVwZGF0ZShjb25maWcsIHNsV2lkdGgsIHNsSGVpZ2h0LCBzbENlbnRlclBvaW50LCB2ZWhpY2xlU3RhdGlvbiwgc3RhcnRUaW1lLCBkeW5hbWljRnJhbWVUaW1lLCBkeW5hbWljT2JzdGFjbGVzKSB7XHJcbiAgICBvYnN0YWNsZVZlcnRpY2VzID0gW107XHJcblxyXG4gICAgbGV0IHRpbWUgPSBzdGFydFRpbWU7XHJcbiAgICBmb3IgKGxldCBmcmFtZSA9IDA7IGZyYW1lIDwgbnVtRHluYW1pY0ZyYW1lczsgZnJhbWUrKykge1xyXG4gICAgICBjb25zdCB2ZXJ0aWNlcyA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGR5bmFtaWNPYnN0YWNsZXMubWFwKG8gPT4gby52ZXJ0aWNlc0luVGltZVJhbmdlKHRpbWUsIHRpbWUgKyBkeW5hbWljRnJhbWVUaW1lLCBjb25maWcpKSk7XHJcbiAgICAgIG9ic3RhY2xlVmVydGljZXMucHVzaChuZXcgRmxvYXQzMkFycmF5KHZlcnRpY2VzKSk7XHJcbiAgICAgIHRpbWUgKz0gZHluYW1pY0ZyYW1lVGltZTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0cmFuc2xhdGUgPSBuZXcgVEhSRUUuTWF0cml4MygpO1xyXG4gICAgdHJhbnNsYXRlLnNldChcclxuICAgICAgMSwgMCwgLXNsQ2VudGVyUG9pbnQueCAtIHZlaGljbGVTdGF0aW9uLFxyXG4gICAgICAwLCAxLCAtc2xDZW50ZXJQb2ludC55LFxyXG4gICAgICAwLCAwLCAxXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IHNjYWxlID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcclxuICAgIHNjYWxlLnNldChcclxuICAgICAgMiAvIChzbFdpZHRoICogY29uZmlnLnNsR3JpZENlbGxTaXplKSwgMCwgMCxcclxuICAgICAgMCwgMiAvIChzbEhlaWdodCAqIGNvbmZpZy5zbEdyaWRDZWxsU2l6ZSksIDAsXHJcbiAgICAgIDAsIDAsIDFcclxuICAgICk7XHJcblxyXG4gICAgb2JzdGFjbGVYZm9ybSA9IHNjYWxlLm11bHRpcGx5KHRyYW5zbGF0ZSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgd2lkdGg6IHNsV2lkdGgsXHJcbiAgICAgIGhlaWdodDogc2xIZWlnaHRcclxuICAgIH1cclxuICB9XHJcbn1cclxuIiwiY29uc3QgWFlTTF9NQVBfS0VSTkVMID0gYFxyXG5cclxudmVjNCBrZXJuZWwoKSB7XHJcbiAgdmVjMiB4eSA9IChrZXJuZWxQb3NpdGlvbiAtIDAuNSkgKiB2ZWMyKGtlcm5lbFNpemUpICogdmVjMih4eUdyaWRDZWxsU2l6ZSkgKyB4eUNlbnRlclBvaW50O1xyXG5cclxuICBpbnQgbnVtU2FtcGxlcyA9IHRleHR1cmVTaXplKGNlbnRlcmxpbmUsIDApLng7XHJcbiAgaW50IGNsb3Nlc3QgPSAwO1xyXG4gIGZsb2F0IGNsb3Nlc3REaXN0ID0gZGlzdGFuY2UoeHksIHRleGVsRmV0Y2goY2VudGVybGluZSwgaXZlYzIoMCwgMCksIDApLnh5KTtcclxuICBmb3IgKGludCBpID0gMTsgaSA8IG51bVNhbXBsZXM7IGkrKykge1xyXG4gICAgZmxvYXQgZGlzdCA9IGRpc3RhbmNlKHh5LCB0ZXhlbEZldGNoKGNlbnRlcmxpbmUsIGl2ZWMyKGksIDApLCAwKS54eSk7XHJcbiAgICBpZiAoZGlzdCA8IGNsb3Nlc3REaXN0KSB7XHJcbiAgICAgIGNsb3Nlc3REaXN0ID0gZGlzdDtcclxuICAgICAgY2xvc2VzdCA9IGk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2ZWMyIGNsb3Nlc3RQb3MgPSB0ZXhlbEZldGNoKGNlbnRlcmxpbmUsIGl2ZWMyKGNsb3Nlc3QsIDApLCAwKS54eTtcclxuICB2ZWMyIHByZXYsIG5leHQ7XHJcbiAgaW50IHByZXZJbmRleCwgbmV4dEluZGV4O1xyXG5cclxuICBpZiAoY2xvc2VzdCA9PSAwKSB7XHJcbiAgICBwcmV2SW5kZXggPSAwO1xyXG4gICAgbmV4dEluZGV4ID0gMTtcclxuICAgIHByZXYgPSBjbG9zZXN0UG9zO1xyXG4gICAgbmV4dCA9IHRleGVsRmV0Y2goY2VudGVybGluZSwgaXZlYzIoMSwgMCksIDApLnh5O1xyXG4gIH0gZWxzZSBpZiAoY2xvc2VzdCA9PSBudW1TYW1wbGVzIC0gMSkge1xyXG4gICAgcHJldkluZGV4ID0gY2xvc2VzdCAtIDE7XHJcbiAgICBuZXh0SW5kZXggPSBjbG9zZXN0O1xyXG4gICAgcHJldiA9IHRleGVsRmV0Y2goY2VudGVybGluZSwgaXZlYzIocHJldkluZGV4LCAwKSwgMCkueHk7XHJcbiAgICBuZXh0ID0gY2xvc2VzdFBvcztcclxuICB9IGVsc2Uge1xyXG4gICAgdmVjMiBiZWZvcmUgPSB0ZXhlbEZldGNoKGNlbnRlcmxpbmUsIGl2ZWMyKGNsb3Nlc3QgLSAxLCAwKSwgMCkueHk7XHJcbiAgICB2ZWMyIGFmdGVyID0gdGV4ZWxGZXRjaChjZW50ZXJsaW5lLCBpdmVjMihjbG9zZXN0ICsgMSwgMCksIDApLnh5O1xyXG5cclxuICAgIGlmIChkaXN0YW5jZShiZWZvcmUsIHh5KSA8IGRpc3RhbmNlKGFmdGVyLCB4eSkpIHtcclxuICAgICAgcHJldkluZGV4ID0gY2xvc2VzdCAtIDE7XHJcbiAgICAgIG5leHRJbmRleCA9IGNsb3Nlc3Q7XHJcbiAgICAgIHByZXYgPSBiZWZvcmU7XHJcbiAgICAgIG5leHQgPSBjbG9zZXN0UG9zO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcHJldkluZGV4ID0gY2xvc2VzdDtcclxuICAgICAgbmV4dEluZGV4ID0gY2xvc2VzdCArIDE7XHJcbiAgICAgIHByZXYgPSBjbG9zZXN0UG9zO1xyXG4gICAgICBuZXh0ID0gYWZ0ZXI7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmbG9hdCBkaXN0ID0gZGlzdGFuY2UocHJldiwgbmV4dCk7XHJcbiAgZmxvYXQgcHJvZ3Jlc3MgPSBjbGFtcChkb3QoeHkgLSBwcmV2LCBuZXh0IC0gcHJldikgLyBkaXN0IC8gZGlzdCwgMC4wLCAxLjApO1xyXG4gIHZlYzIgcHJvamVjdGVkUG9zID0gKG5leHQgLSBwcmV2KSAqIHZlYzIocHJvZ3Jlc3MpICsgcHJldjtcclxuXHJcbiAgcmV0dXJuIHZlYzQoXHJcbiAgICAoZmxvYXQocHJldkluZGV4KSArIHByb2dyZXNzKSAqIGNlbnRlcmxpbmVTdGF0aW9uSW50ZXJ2YWwsXHJcbiAgICBzaWduKGRldGVybWluYW50KG1hdDIobmV4dCAtIHByZXYsIHh5IC0gcHJldikpKSAqIGRpc3RhbmNlKHh5LCBwcm9qZWN0ZWRQb3MpLFxyXG4gICAgMCxcclxuICAgIDBcclxuICApO1xyXG59XHJcblxyXG5gO1xyXG5cclxuLy8gQnVpbGQgWFktU0wgbWFwXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBzZXRVcCgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGtlcm5lbDogWFlTTF9NQVBfS0VSTkVMLFxyXG4gICAgICBvdXRwdXQ6IHsgbmFtZTogJ3h5c2xNYXAnLCBmaWx0ZXI6ICdsaW5lYXInIH0sXHJcbiAgICAgIHVuaWZvcm1zOiB7XHJcbiAgICAgICAgY2VudGVybGluZTogeyB0eXBlOiAnc2hhcmVkVGV4dHVyZScgfSxcclxuICAgICAgICB4eUNlbnRlclBvaW50OiB7IHR5cGU6ICd2ZWMyJyB9LFxyXG4gICAgICAgIHh5R3JpZENlbGxTaXplOiB7IHR5cGU6ICdmbG9hdCd9LFxyXG4gICAgICAgIGNlbnRlcmxpbmVTdGF0aW9uSW50ZXJ2YWw6IHsgdHlwZTogJ2Zsb2F0J31cclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9LFxyXG5cclxuICB1cGRhdGUoY29uZmlnLCB4eVdpZHRoLCB4eUhlaWdodCwgeHlDZW50ZXJQb2ludCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgd2lkdGg6IHh5V2lkdGgsXHJcbiAgICAgIGhlaWdodDogeHlIZWlnaHQsXHJcbiAgICAgIHVuaWZvcm1zOiB7XHJcbiAgICAgICAgeHlDZW50ZXJQb2ludDogW3h5Q2VudGVyUG9pbnQueCwgeHlDZW50ZXJQb2ludC55XSxcclxuICAgICAgICB4eUdyaWRDZWxsU2l6ZTogY29uZmlnLnh5R3JpZENlbGxTaXplLFxyXG4gICAgICAgIGNlbnRlcmxpbmVTdGF0aW9uSW50ZXJ2YWw6IGNvbmZpZy5jZW50ZXJsaW5lU3RhdGlvbkludGVydmFsXHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiIsIi8vIENvbmZpZzpcclxuLy8gbnVtIHN0YXRpb25zXHJcbi8vIG51bSBsYXRpdHVkZXNcclxuLy8gc3RhdGlvbiBjb25uZWN0aXZpdHlcclxuLy8gbGF0aXR1ZGUgY29ubmVjdGl2aXR5XHJcbi8vXHJcbi8vIFNoYXJlZDpcclxuLy8gbGF0dGljZVxyXG5cclxuY29uc3QgT1BUSU1JWkVfQ1VCSUNfU0hBUkVEID0gYFxyXG5cclxuY29uc3QgaW50IE5FV1RPTl9JVEVSQVRJT05TID0gMTY7XHJcbmNvbnN0IGludCBSRUxBWEFUSU9OX0lURVJBVElPTlMgPSAxNjtcclxuY29uc3QgZmxvYXQgQ09OVkVSR0VOQ0VfRVJST1IgPSAwLjAxO1xyXG5cclxuLy8gVGhlc2UgdHdvIGNvbnN0cyBtdXN0IHN0YXkgaW4gc3luYy5cclxuY29uc3QgaW50IFNJTVBTT05TX0lOVEVSVkFMUyA9IDg7XHJcbi8vY29uc3QgZmxvYXQgU0lNUFNPTlNfQ09FRkZTW1NJTVBTT05TX0lOVEVSVkFMUyArIDFdID0gZmxvYXRbXSgxLjAsIDQuMCwgMi4wLCA0LjAsIDIuMCwgNC4wLCAyLjAsIDQuMCwgMi4wLCA0LjAsIDIuMCwgNC4wLCAyLjAsIDQuMCwgMi4wLCA0LjAsIDEuMCk7XHJcbmNvbnN0IGZsb2F0IFNJTVBTT05TX0NPRUZGU1tTSU1QU09OU19JTlRFUlZBTFMgKyAxXSA9IGZsb2F0W10oMS4wLCA0LjAsIDIuMCwgNC4wLCAyLjAsIDQuMCwgMi4wLCA0LjAsIDEuMCk7XHJcblxyXG5jb25zdCBmbG9hdCBQSSA9IDMuMTQxNTkyNjUzNTg5NzkzMjM4NDYyNjQzMzgzMjc5NTtcclxuY29uc3QgZmxvYXQgVFdPX1BJID0gUEkgKyBQSTtcclxuXHJcbmNvbnN0IGZsb2F0IFJFTEFYQVRJT05fSVRFUkFUSU9OU19GID0gZmxvYXQoUkVMQVhBVElPTl9JVEVSQVRJT05TKTtcclxuY29uc3QgZmxvYXQgU0lNUFNPTlNfSU5URVJWQUxTX0YgPSBmbG9hdChTSU1QU09OU19JTlRFUlZBTFMpO1xyXG5cclxuZmxvYXQgd3JhcEFuZ2xlKGZsb2F0IGFuZ2xlKSB7XHJcbiAgYW5nbGUgPSBtb2QoYW5nbGUsIFRXT19QSSk7XHJcbiAgaWYgKGFuZ2xlIDw9IC1QSSkgcmV0dXJuIGFuZ2xlICsgVFdPX1BJO1xyXG4gIGVsc2UgaWYgKGFuZ2xlID4gUEkpIHJldHVybiBhbmdsZSAtIFRXT19QSTtcclxuICByZXR1cm4gYW5nbGU7XHJcbn1cclxuXHJcbnZlYzQgaXRlcmF0ZSh2ZWM0IGdvYWwsIGZsb2F0IHAwLCBmbG9hdCBwMSwgZmxvYXQgcDIsIGZsb2F0IHAzLCBmbG9hdCBzRykge1xyXG4gIGZsb2F0IGRzID0gc0cgLyBTSU1QU09OU19JTlRFUlZBTFNfRjtcclxuICBmbG9hdCBzR18yID0gc0cgKiBzRztcclxuICBmbG9hdCBzR18zID0gc0dfMiAqIHNHO1xyXG5cclxuICB2ZWMzIGRYX3AgPSB2ZWMzKDAuMCk7XHJcbiAgdmVjMyBkWV9wID0gdmVjMygwLjApO1xyXG4gIHZlYzIgZ3Vlc3MgPSB2ZWMyKDAuMCk7XHJcbiAgZmxvYXQgcyA9IDAuMDtcclxuXHJcbiAgZmxvYXQgdGhldGEsIGNvc1RoZXRhLCBzaW5UaGV0YTtcclxuICB2ZWMzIGRUX3A7XHJcblxyXG4gIGZvciAoaW50IGkgPSAwOyBpIDw9IFNJTVBTT05TX0lOVEVSVkFMUzsgaSsrKSB7XHJcbiAgICBmbG9hdCBjb2VmZiA9IFNJTVBTT05TX0NPRUZGU1tpXTtcclxuXHJcbiAgICBmbG9hdCBhID0gcDA7XHJcbiAgICBmbG9hdCBiID0gKC01LjUgKiBwMCArIDkuMCAqIHAxIC0gNC41ICogcDIgKyBwMykgLyBzRztcclxuICAgIGZsb2F0IGMgPSAoOS4wICogcDAgLSAyMi41ICogcDEgKyAxOC4wICogcDIgLSA0LjUgKiBwMykgLyBzR18yO1xyXG4gICAgZmxvYXQgZCA9ICgtNC41ICogKHAwIC0gMy4wICogcDEgKyAzLjAgKiBwMiAtIHAzKSkgLyBzR18zO1xyXG5cclxuICAgIHRoZXRhID0gKCgoZCAqIHMgLyA0LjAgKyBjIC8gMy4wKSAqIHMgKyBiIC8gMi4wKSAqIHMgKyBhKSAqIHM7XHJcbiAgICBjb3NUaGV0YSA9IGNvcyh0aGV0YSk7XHJcbiAgICBzaW5UaGV0YSA9IHNpbih0aGV0YSk7XHJcblxyXG4gICAgZmxvYXQgc19zRyA9IHMgLyBzRztcclxuXHJcbiAgICBkVF9wID0gdmVjMyhcclxuICAgICAgLy8gcDFcclxuICAgICAgKCgzLjM3NSAqIHNfc0cgLSA3LjUpICogc19zRyArIDQuNSkgKiBzX3NHICogcyxcclxuXHJcbiAgICAgIC8vIHAyXHJcbiAgICAgICgoLTMuMzc1ICogc19zRyArIDYuMCkgKiBzX3NHIC0gMi4yNSkgKiBzX3NHICogcyxcclxuXHJcbiAgICAgIC8vIHNHXHJcbiAgICAgICgoMy4zNzUgKiAocDAgLSAzLjAgKiBwMSArIDMuMCAqIHAyIC0gcDMpICogc19zRyAtIDMuMCAqICgyLjAgKiBwMCAtIDUuMCAqIHAxICsgNC4wICogcDIgLSBwMykpICogc19zRyArIDAuMjUgKiAoMTEuMCAqIHAwIC0gMTguMCAqIHAxICsgOS4wICogcDIgLSAyLjAgKiBwMykpICogc19zRyAqIHNfc0dcclxuICAgICk7XHJcblxyXG4gICAgZFhfcCAtPSBjb2VmZiAqIHNpblRoZXRhICogZFRfcDtcclxuICAgIGRZX3AgKz0gY29lZmYgKiBjb3NUaGV0YSAqIGRUX3A7XHJcblxyXG4gICAgZ3Vlc3MgKz0gY29lZmYgKiB2ZWMyKGNvc1RoZXRhLCBzaW5UaGV0YSk7XHJcblxyXG4gICAgcyArPSBkcztcclxuICB9XHJcblxyXG4gIGZsb2F0IGhPdmVyMyA9IHNHIC8gU0lNUFNPTlNfSU5URVJWQUxTX0YgLyAzLjA7XHJcblxyXG4gIHZlYzMgZGVsdGE7XHJcbiAgZGVsdGEueHkgPSBnb2FsLnh5IC0gZ3Vlc3MgKiBoT3ZlcjM7XHJcbiAgZGVsdGEueiA9IHdyYXBBbmdsZShnb2FsLnogLSB0aGV0YSk7XHJcblxyXG4gIGlmIChhYnMoZGVsdGEueCkgKyBhYnMoZGVsdGEueSkgKyBhYnMoZGVsdGEueikgPCBDT05WRVJHRU5DRV9FUlJPUilcclxuICAgIHJldHVybiB2ZWM0KHAxLCBwMiwgc0csIDEuMCk7XHJcblxyXG4gIGRYX3AueHl6ICo9IGhPdmVyMztcclxuICBkWV9wLnh5eiAqPSBoT3ZlcjM7XHJcbiAgZFhfcC56ICs9IGNvc1RoZXRhO1xyXG4gIGRZX3AueiArPSBzaW5UaGV0YTtcclxuXHJcbiAgbWF0MyBpbnZKYWNvYmlhbiA9IGludmVyc2UodHJhbnNwb3NlKG1hdDMoZFhfcCwgZFlfcCwgZFRfcCkpKTtcclxuXHJcbiAgdmVjMyBkZWx0YVAgPSBpbnZKYWNvYmlhbiAqIGRlbHRhO1xyXG4gIHZlYzQgcGFyYW1zID0gdmVjNChwMSwgcDIsIHNHLCAwLjApO1xyXG4gIHBhcmFtcy54eXogKz0gZGVsdGFQO1xyXG5cclxuICByZXR1cm4gcGFyYW1zO1xyXG59XHJcblxyXG4vKiBJbnB1dDpcclxuICogICBzdGFydDogKHZlYzQpXHJcbiAqICAgICB4OiB4IHBvc2l0aW9uLFxyXG4gKiAgICAgeTogeSBwb3NpdGlvbixcclxuICogICAgIHo6IHRoZXRhIHJvdGF0aW9uLFxyXG4gKiAgICAgdzogayBjdXJ2YXR1cmVcclxuICogICBlbmQ6ICh2ZWM0KVxyXG4gKiAgICAgeDogeCBwb3NpdGlvbixcclxuICogICAgIHk6IHkgcG9zaXRpb24sXHJcbiAqICAgICB6OiB0aGV0YSByb3RhdGlvbixcclxuICogICAgIHc6IGsgY3VydmF0dXJlXHJcbiAqXHJcbiAqIE91dHB1dDogKHZlYzQpXHJcbiAqICAgeDogcDEsXHJcbiAqICAgeTogcDIsXHJcbiAqICAgejogc0csXHJcbiAqICAgdzogMSBpZiBjb252ZXJnZWQsIDAgaWYgbm90XHJcbiAqL1xyXG5cclxudmVjNCBvcHRpbWl6ZSh2ZWM0IHN0YXJ0LCB2ZWM0IGVuZCkge1xyXG4gIC8vIFRyYW5zbGF0ZSBhbmQgcm90YXRlIHN0YXJ0IGFuZCBlbmQgc28gdGhhdCBzdGFydCBpcyBhdCB0aGUgb3JpZ2luXHJcbiAgZmxvYXQgc2luUm90ID0gc2luKHN0YXJ0LnopO1xyXG4gIGZsb2F0IGNvc1JvdCA9IGNvcyhzdGFydC56KTtcclxuXHJcbiAgdmVjNCBkaWZmID0gZW5kIC0gc3RhcnQ7XHJcbiAgdmVjNCBnb2FsO1xyXG4gIGdvYWwueHkgPSBtYXQyKGNvc1JvdCwgLXNpblJvdCwgc2luUm90LCBjb3NSb3QpICogZGlmZi54eTtcclxuICBnb2FsLnogPSB3cmFwQW5nbGUoZGlmZi56KTtcclxuICBnb2FsLncgPSBlbmQudztcclxuXHJcbiAgdmVjNCBvcmlnaW5hbEdvYWwgPSBnb2FsO1xyXG4gIHZlYzQgZEdvYWw7XHJcbiAgZEdvYWwueCA9IDAuMDtcclxuICBkR29hbC55encgPSBnb2FsLnl6dyAvIFJFTEFYQVRJT05fSVRFUkFUSU9OU19GO1xyXG4gIGZsb2F0IGRLMCA9IHN0YXJ0LncgLyBSRUxBWEFUSU9OX0lURVJBVElPTlNfRjtcclxuXHJcbiAgLy8gUmVsYXggdGhlIGdvYWwgdG8gKHgsIDAsIDAsIDApXHJcbiAgZ29hbC55encgPSB2ZWMzKDAsIDAsIDApO1xyXG5cclxuICAvLyBSZWxheCB0aGUgcGFyYW1zIHRvICgwLCAwLCAwLCAwLCBnb2FsLngpXHJcbiAgZmxvYXQgcDAgPSAwLjA7XHJcbiAgZmxvYXQgcDEgPSAwLjA7XHJcbiAgZmxvYXQgcDIgPSAwLjA7XHJcbiAgZmxvYXQgcDMgPSAwLjA7XHJcbiAgZmxvYXQgc0cgPSBnb2FsLng7XHJcblxyXG4gIGlmIChzRyA8IDAuMSkgcmV0dXJuIHZlYzQoMC4wKTtcclxuXHJcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBSRUxBWEFUSU9OX0lURVJBVElPTlM7IGkrKykge1xyXG4gICAgcDAgKz0gZEswO1xyXG4gICAgcDMgKz0gZEdvYWwudztcclxuICAgIGdvYWwgKz0gZEdvYWw7XHJcbiAgICBcclxuICAgIHZlYzQgcmVzdWx0ID0gaXRlcmF0ZShnb2FsLCBwMCwgcDEsIHAyLCBwMywgc0cpO1xyXG4gICAgcDEgPSByZXN1bHQueDtcclxuICAgIHAyID0gcmVzdWx0Lnk7XHJcbiAgICBzRyA9IHJlc3VsdC56O1xyXG4gIH1cclxuXHJcbiAgZ29hbCA9IG9yaWdpbmFsR29hbDtcclxuXHJcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBORVdUT05fSVRFUkFUSU9OUzsgaSsrKSB7XHJcbiAgICB2ZWM0IHJlc3VsdCA9IGl0ZXJhdGUoZ29hbCwgcDAsIHAxLCBwMiwgcDMsIHNHKTtcclxuICAgIGlmIChyZXN1bHQudyA9PSAxLjApIHtcclxuICAgICAgcmVzdWx0LncgPSBzdGVwKDAuMCwgcmVzdWx0LnopO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHAxID0gcmVzdWx0Lng7XHJcbiAgICBwMiA9IHJlc3VsdC55O1xyXG4gICAgc0cgPSByZXN1bHQuejtcclxuICB9XHJcblxyXG4gIHJldHVybiB2ZWM0KHAxLCBwMiwgc0csIDAuMCk7XHJcbn1cclxuXHJcbmA7XHJcblxyXG5jb25zdCBPUFRJTUlaRV9DVUJJQ19LRVJORUwgPSBPUFRJTUlaRV9DVUJJQ19TSEFSRUQgKyBgXHJcblxyXG4vLyB3aWR0aDogc3RhdGlvbiAqIGxhdGl0dWRlIGluZGV4XHJcbi8vIGhlaWdodDogc3RhdGlvbl9jb25uICogbGF0dGljZV9jb25uXHJcbi8vXHJcbi8vIGxhdHRpY2U6XHJcbi8vIHdpZHRoOiBsYXRpdHVkZXNcclxuLy8gaGVpZ2h0OiBzdGF0aW9uc1xyXG5cclxudmVjNCBrZXJuZWwoKSB7XHJcbiAgaXZlYzIgaW5kZXhlcyA9IGl2ZWMyKGtlcm5lbFBvc2l0aW9uICogdmVjMihrZXJuZWxTaXplKSk7XHJcblxyXG4gIGludCBlbmRTdGF0aW9uID0gaW5kZXhlcy54IC8gbnVtTGF0aXR1ZGVzO1xyXG4gIGludCBlbmRMYXRpdHVkZSA9IGludChtb2QoZmxvYXQoaW5kZXhlcy54KSwgZmxvYXQobnVtTGF0aXR1ZGVzKSkpO1xyXG5cclxuICBpbnQgc3RhcnRTdGF0aW9uID0gZW5kU3RhdGlvbiAtIHN0YXRpb25Db25uZWN0aXZpdHkgKyBpbmRleGVzLnkgLyBsYXRpdHVkZUNvbm5lY3Rpdml0eTtcclxuICBpbnQgc3RhcnRMYXRpdHVkZSA9IGVuZExhdGl0dWRlIC0gbGF0aXR1ZGVDb25uZWN0aXZpdHkgLyAyICsgaW50KG1vZChmbG9hdChpbmRleGVzLnkpLCBmbG9hdChsYXRpdHVkZUNvbm5lY3Rpdml0eSkpKTtcclxuXHJcbiAgaWYgKHN0YXJ0U3RhdGlvbiA8IDAgfHwgc3RhcnRTdGF0aW9uID49IG51bVN0YXRpb25zIHx8IHN0YXJ0TGF0aXR1ZGUgPCAwIHx8IHN0YXJ0TGF0aXR1ZGUgPj0gbnVtTGF0aXR1ZGVzKVxyXG4gICAgcmV0dXJuIHZlYzQoMC4wKTtcclxuXHJcbiAgdmVjNCBzdGFydCA9IHRleGVsRmV0Y2gobGF0dGljZSwgaXZlYzIoc3RhcnRMYXRpdHVkZSwgc3RhcnRTdGF0aW9uKSwgMCk7XHJcbiAgdmVjNCBlbmQgPSB0ZXhlbEZldGNoKGxhdHRpY2UsIGl2ZWMyKGVuZExhdGl0dWRlLCBlbmRTdGF0aW9uKSwgMCk7XHJcblxyXG4gIHJldHVybiBvcHRpbWl6ZShzdGFydCwgZW5kKTtcclxufVxyXG5cclxuYDtcclxuXHJcbmNvbnN0IE9QVElNSVpFX0NVQklDX0ZST01fVkVISUNMRV9LRVJORUwgPSBPUFRJTUlaRV9DVUJJQ19TSEFSRUQgKyBgXHJcblxyXG52ZWM0IGtlcm5lbCgpIHtcclxuICBpdmVjMiBpbmRleGVzID0gaXZlYzIoa2VybmVsUG9zaXRpb24gKiB2ZWMyKGtlcm5lbFNpemUpKTtcclxuXHJcbiAgdmVjNCBzdGFydCA9IHZlYzQoMCwgMCwgMCwgY3VydlZlaGljbGUpO1xyXG4gIHZlYzQgZW5kID0gdGV4ZWxGZXRjaChsYXR0aWNlLCBpbmRleGVzLCAwKTtcclxuXHJcbiAgcmV0dXJuIG9wdGltaXplKHN0YXJ0LCBlbmQpO1xyXG59XHJcblxyXG5gO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHNldFVwKCkge1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgeyAvLyBDdWJpYyBwYXRocyBiZXR3ZWVuIGxhdHRpY2Ugbm9kZXNcclxuICAgICAgICBrZXJuZWw6IE9QVElNSVpFX0NVQklDX0tFUk5FTCxcclxuICAgICAgICBvdXRwdXQ6IHsgbmFtZTogJ2N1YmljUGF0aHMnLCByZWFkOiB0cnVlIH0sXHJcbiAgICAgICAgdW5pZm9ybXM6IHtcclxuICAgICAgICAgIGxhdHRpY2U6IHsgdHlwZTogJ3NoYXJlZFRleHR1cmUnIH0sXHJcbiAgICAgICAgICBudW1TdGF0aW9uczogeyB0eXBlOiAnaW50JyB9LFxyXG4gICAgICAgICAgbnVtTGF0aXR1ZGVzOiB7IHR5cGU6ICdpbnQnIH0sXHJcbiAgICAgICAgICBzdGF0aW9uQ29ubmVjdGl2aXR5OiB7IHR5cGU6ICdpbnQnIH0sXHJcbiAgICAgICAgICBsYXRpdHVkZUNvbm5lY3Rpdml0eTogeyB0eXBlOiAnaW50JyB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICB7IC8vIEN1YmljIHBhdGhzIGZyb20gdmVoaWNsZSB0byBsYXR0aWNlIG5vZGVzXHJcbiAgICAgICAga2VybmVsOiBPUFRJTUlaRV9DVUJJQ19GUk9NX1ZFSElDTEVfS0VSTkVMLFxyXG4gICAgICAgIG91dHB1dDogeyBuYW1lOiAnY3ViaWNQYXRoc0Zyb21WZWhpY2xlJywgcmVhZDogdHJ1ZSB9LFxyXG4gICAgICAgIHVuaWZvcm1zOiB7XHJcbiAgICAgICAgICBsYXR0aWNlOiB7IHR5cGU6ICdzaGFyZWRUZXh0dXJlJyB9LFxyXG4gICAgICAgICAgY3VydlZlaGljbGU6IHsgdHlwZTogJ2Zsb2F0JyB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICBdXHJcbiAgfSxcclxuXHJcbiAgdXBkYXRlKGNvbmZpZywgcG9zZSkge1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgeyAvLyBDdWJpYyBwYXRocyBiZXR3ZWVuIGxhdHRpY2Ugbm9kZXNcclxuICAgICAgICB3aWR0aDogY29uZmlnLmxhdHRpY2UubnVtU3RhdGlvbnMgKiBjb25maWcubGF0dGljZS5udW1MYXRpdHVkZXMsXHJcbiAgICAgICAgaGVpZ2h0OiBjb25maWcubGF0dGljZS5zdGF0aW9uQ29ubmVjdGl2aXR5ICogY29uZmlnLmxhdHRpY2UubGF0aXR1ZGVDb25uZWN0aXZpdHksXHJcbiAgICAgICAgdW5pZm9ybXM6IHtcclxuICAgICAgICAgIG51bVN0YXRpb25zOiBjb25maWcubGF0dGljZS5udW1TdGF0aW9ucyxcclxuICAgICAgICAgIG51bUxhdGl0dWRlczogY29uZmlnLmxhdHRpY2UubnVtTGF0aXR1ZGVzLFxyXG4gICAgICAgICAgc3RhdGlvbkNvbm5lY3Rpdml0eTogY29uZmlnLmxhdHRpY2Uuc3RhdGlvbkNvbm5lY3Rpdml0eSxcclxuICAgICAgICAgIGxhdGl0dWRlQ29ubmVjdGl2aXR5OiBjb25maWcubGF0dGljZS5sYXRpdHVkZUNvbm5lY3Rpdml0eSxcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHsgLy8gQ3ViaWMgcGF0aHMgZnJvbSB2ZWhpY2xlIHRvIGxhdHRpY2Ugbm9kZXNcclxuICAgICAgICB3aWR0aDogY29uZmlnLmxhdHRpY2UubnVtTGF0aXR1ZGVzLFxyXG4gICAgICAgIGhlaWdodDogY29uZmlnLmxhdHRpY2Uuc3RhdGlvbkNvbm5lY3Rpdml0eSxcclxuICAgICAgICB1bmlmb3Jtczoge1xyXG4gICAgICAgICAgY3VydlZlaGljbGU6IHBvc2UuY3VydlxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgXTtcclxuICB9XHJcbn1cclxuIiwiY29uc3QgT1BUSU1JWkVfS0VSTkVMID0gYFxyXG5cclxuY29uc3QgaW50IE5FV1RPTl9JVEVSQVRJT05TID0gMzI7XHJcbmNvbnN0IGludCBSRUxBWEFUSU9OX0lURVJBVElPTlMgPSAzMjtcclxuY29uc3QgZmxvYXQgQ09OVkVSR0VOQ0VfRVJST1IgPSAwLjAxO1xyXG5cclxuLy8gVGhlc2UgdHdvIGNvbnN0cyBtdXN0IHN0YXkgaW4gc3luYy5cclxuY29uc3QgaW50IFNJTVBTT05TX0lOVEVSVkFMUyA9IDg7XHJcbmNvbnN0IGZsb2F0IFNJTVBTT05TX0NPRUZGU1tTSU1QU09OU19JTlRFUlZBTFMgKyAxXSA9IGZsb2F0W10oMS4wLCA0LjAsIDIuMCwgNC4wLCAyLjAsIDQuMCwgMi4wLCA0LjAsIDEuMCk7XHJcblxyXG5jb25zdCBmbG9hdCBQSSA9IDMuMTQxNTkyNjUzNTg5NzkzMjM4NDYyNjQzMzgzMjc5NTtcclxuY29uc3QgZmxvYXQgVFdPX1BJID0gUEkgKyBQSTtcclxuXHJcbmNvbnN0IGZsb2F0IFJFTEFYQVRJT05fSVRFUkFUSU9OU19GID0gZmxvYXQoUkVMQVhBVElPTl9JVEVSQVRJT05TKTtcclxuY29uc3QgZmxvYXQgU0lNUFNPTlNfSU5URVJWQUxTX0YgPSBmbG9hdChTSU1QU09OU19JTlRFUlZBTFMpO1xyXG5cclxuZmxvYXQgd3JhcEFuZ2xlKGZsb2F0IGFuZ2xlKSB7XHJcbiAgYW5nbGUgPSBtb2QoYW5nbGUsIFRXT19QSSk7XHJcbiAgaWYgKGFuZ2xlIDw9IC1QSSkgcmV0dXJuIGFuZ2xlICsgVFdPX1BJO1xyXG4gIGVsc2UgaWYgKGFuZ2xlID4gUEkpIHJldHVybiBhbmdsZSAtIFRXT19QSTtcclxuICByZXR1cm4gYW5nbGU7XHJcbn1cclxuXHJcbnZlYzQgaXRlcmF0ZSh2ZWM0IGdvYWwsIGZsb2F0IHAwLCBmbG9hdCBwMSwgZmxvYXQgcDIsIGZsb2F0IHAzLCBmbG9hdCBwNCwgZmxvYXQgcDUsIGZsb2F0IHNHKSB7XHJcbiAgZmxvYXQgZHMgPSBzRyAvIFNJTVBTT05TX0lOVEVSVkFMU19GO1xyXG4gIGZsb2F0IHNHXzIgPSBzRyAqIHNHO1xyXG4gIGZsb2F0IHNHXzMgPSBzR18yICogc0c7XHJcblxyXG4gIHZlYzMgZFhfcCA9IHZlYzMoMC4wKTtcclxuICB2ZWMzIGRZX3AgPSB2ZWMzKDAuMCk7XHJcbiAgdmVjMiBndWVzcyA9IHZlYzIoMC4wKTtcclxuICBmbG9hdCBzID0gMC4wO1xyXG5cclxuICBmbG9hdCB0aGV0YSwgY29zVGhldGEsIHNpblRoZXRhO1xyXG4gIHZlYzMgZFRfcDtcclxuXHJcbiAgZm9yIChpbnQgaSA9IDA7IGkgPD0gU0lNUFNPTlNfSU5URVJWQUxTOyBpKyspIHtcclxuICAgIGZsb2F0IGNvZWZmID0gU0lNUFNPTlNfQ09FRkZTW2ldO1xyXG5cclxuICAgIGZsb2F0IGEgPSBwMDtcclxuICAgIGZsb2F0IGIgPSBwMTtcclxuICAgIGZsb2F0IGMgPSBwMiAvIDIuMDtcclxuICAgIGZsb2F0IGQgPSAoLTcxLjg3NSAqIHAwICsgODEuMCAqIHAzIC0gMTAuMTI1ICogcDQgKyBwNSAtIDIxLjI1ICogcDEgKiBzRyAtIDIuNzUgKiBwMiAqIHNHXzIpIC8gc0dfMztcclxuICAgIGZsb2F0IGUgPSAoMTY2LjUgKiBwMCAtIDIwMi41ICogcDMgKyA0MC41ICogcDQgLSA0LjUgKiBwNSArIDQ1LjAgKiBwMSAqIHNHICsgNC41ICogcDIgKiBzR18yKSAvIChzR18yICogc0dfMik7XHJcbiAgICBmbG9hdCBmID0gKC05NS42MjUgKiBwMCArIDEyMS41ICogcDMgLSAzMC4zNzUgKiBwNCArIDQuNSAqIHA1IC0gMjQuNzUgKiBwMSAqIHNHIC0gMi4yNSAqIHAyICogc0dfMikgLyAoc0dfMiAqIHNHXzMpO1xyXG5cclxuICAgIHRoZXRhID0gKCgoKChmICogcyAvIDYuMCArIGUgLyA1LjApICogcyArIGQgLyA0LjApICogcyArIGMgLyAzLjApICogcyArIGIgLyAyLjApICogcyArIGEpICogcztcclxuICAgIGNvc1RoZXRhID0gY29zKHRoZXRhKTtcclxuICAgIHNpblRoZXRhID0gc2luKHRoZXRhKTtcclxuXHJcbiAgICBmbG9hdCBzXzIgPSBzICogcztcclxuICAgIGZsb2F0IHNfc0cgPSBzIC8gc0c7XHJcbiAgICBmbG9hdCBzX3NHXzIgPSBzX3NHICogc19zRztcclxuICAgIGZsb2F0IHNfc0dfMyA9IHNfc0dfMiAqIHNfc0c7XHJcbiAgICBmbG9hdCBzX3NHXzQgPSBzX3NHXzMgKiBzX3NHO1xyXG4gICAgZmxvYXQgc19zR181ID0gc19zR180ICogc19zRztcclxuXHJcbiAgICBkVF9wID0gdmVjMyhcclxuICAgICAgLy8gcDNcclxuICAgICAgKCgyMC4yNSAqIHNfc0cgLSA0MC41KSAqIHNfc0cgKyAyMC4yNSkgKiBzX3NHXzMgKiBzLFxyXG5cclxuICAgICAgLy8gcDRcclxuICAgICAgKCgtNS4wNjI1ICogc19zRyArIDguMSkgKiBzX3NHIC0gMi41MzEyNSkgKiBzX3NHXzMgKiBzLFxyXG5cclxuICAgICAgLy8gc0dcclxuICAgICAgKDUzLjkwNjI1ICogcDAgLSA2MC43NSAqIHAzICsgNy41OTM3NSAqIHA0IC0gMC43NSAqIHA1KSAqIHNfc0dfNCArIDEwLjYyNSAqIHAxICogcyAqIHNfc0dfMyArIDAuNjg3NSAqIHAyICogc18yICogc19zR18yICsgKC0xMzMuMiAqIHAwICsgMTYyLjAgKiBwMyAtIDMyLjQgKiBwNCArIDMuNiAqIHA1KSAqIHNfc0dfNSArICgtMjcuMCkgKiBwMSAqIHMgKiBzX3NHXzQgLSAxLjggKiBwMiAqIHNfMiAqIHNfc0dfMyArICg3OS42ODc1ICogcDAgLSAxMDEuMjUgKiBwMyArIDI1LjMxMjUgKiBwNCAtIDMuNzUgKiBwNSkgKiBzX3NHXzUgKiBzX3NHICsgMTYuNSAqIHAxICogcyAqIHNfc0dfNSArIDEuMTI1ICogcDIgKiBzXzIgKiBzX3NHXzRcclxuICAgICk7XHJcblxyXG4gICAgZFhfcCAtPSBjb2VmZiAqIHNpblRoZXRhICogZFRfcDtcclxuICAgIGRZX3AgKz0gY29lZmYgKiBjb3NUaGV0YSAqIGRUX3A7XHJcblxyXG4gICAgZ3Vlc3MgKz0gY29lZmYgKiB2ZWMyKGNvc1RoZXRhLCBzaW5UaGV0YSk7XHJcblxyXG4gICAgcyArPSBkcztcclxuICB9XHJcblxyXG4gIGZsb2F0IGhPdmVyMyA9IHNHIC8gU0lNUFNPTlNfSU5URVJWQUxTX0YgLyAzLjA7XHJcblxyXG4gIHZlYzMgZGVsdGE7XHJcbiAgZGVsdGEueHkgPSBnb2FsLnh5IC0gZ3Vlc3MgKiBoT3ZlcjM7XHJcbiAgZGVsdGEueiA9IHdyYXBBbmdsZShnb2FsLnogLSB0aGV0YSk7XHJcblxyXG4gIGlmIChhYnMoZGVsdGEueCkgKyBhYnMoZGVsdGEueSkgKyBhYnMoZGVsdGEueikgPCBDT05WRVJHRU5DRV9FUlJPUilcclxuICAgIHJldHVybiB2ZWM0KHAzLCBwNCwgc0csIDEuMCk7XHJcblxyXG4gIGRYX3AueHl6ICo9IGhPdmVyMztcclxuICBkWV9wLnh5eiAqPSBoT3ZlcjM7XHJcbiAgZFhfcC56ICs9IGNvc1RoZXRhO1xyXG4gIGRZX3AueiArPSBzaW5UaGV0YTtcclxuXHJcbiAgbWF0MyBpbnZKYWNvYmlhbiA9IGludmVyc2UodHJhbnNwb3NlKG1hdDMoZFhfcCwgZFlfcCwgZFRfcCkpKTtcclxuXHJcbiAgdmVjMyBkZWx0YVAgPSBpbnZKYWNvYmlhbiAqIGRlbHRhO1xyXG4gIHZlYzQgcGFyYW1zID0gdmVjNChwMywgcDQsIHNHLCAwLjApO1xyXG4gIHBhcmFtcy54eXogKz0gZGVsdGFQO1xyXG5cclxuICByZXR1cm4gcGFyYW1zO1xyXG59XHJcblxyXG52ZWM0IG9wdGltaXplKHZlYzQgc3RhcnQsIHZlYzQgZW5kKSB7XHJcbiAgLy8gVHJhbnNsYXRlIGFuZCByb3RhdGUgc3RhcnQgYW5kIGVuZCBzbyB0aGF0IHN0YXJ0IGlzIGF0IHRoZSBvcmlnaW5cclxuICBmbG9hdCBzaW5Sb3QgPSBzaW4oc3RhcnQueik7XHJcbiAgZmxvYXQgY29zUm90ID0gY29zKHN0YXJ0LnopO1xyXG5cclxuICB2ZWM0IGRpZmYgPSBlbmQgLSBzdGFydDtcclxuICB2ZWM0IGdvYWw7XHJcbiAgZ29hbC54eSA9IG1hdDIoY29zUm90LCAtc2luUm90LCBzaW5Sb3QsIGNvc1JvdCkgKiBkaWZmLnh5O1xyXG4gIGdvYWwueiA9IHdyYXBBbmdsZShkaWZmLnopO1xyXG4gIGdvYWwudyA9IGVuZC53O1xyXG5cclxuICB2ZWM0IG9yaWdpbmFsR29hbCA9IGdvYWw7XHJcbiAgdmVjNCBkR29hbDtcclxuICBkR29hbC54ID0gMC4wO1xyXG4gIGRHb2FsLnl6dyA9IGdvYWwueXp3IC8gUkVMQVhBVElPTl9JVEVSQVRJT05TX0Y7XHJcbiAgZmxvYXQgZF9LMCA9IHN0YXJ0LncgLyBSRUxBWEFUSU9OX0lURVJBVElPTlNfRjtcclxuICBmbG9hdCBkX2RLMCA9IGRDdXJ2VmVoaWNsZSAvIFJFTEFYQVRJT05fSVRFUkFUSU9OU19GO1xyXG4gIGZsb2F0IGRfZGRLMCA9IGRkQ3VydlZlaGljbGUgLyBSRUxBWEFUSU9OX0lURVJBVElPTlNfRjtcclxuXHJcbiAgLy8gUmVsYXggdGhlIGdvYWwgdG8gKHgsIDAsIDAsIDApXHJcbiAgZ29hbC55encgPSB2ZWMzKDAsIDAsIDApO1xyXG5cclxuICAvLyBSZWxheCB0aGUgcGFyYW1zIHRvICgwLCAwLCAwLCAwLCBnb2FsLngpXHJcbiAgZmxvYXQgcDAgPSAwLjA7XHJcbiAgZmxvYXQgcDEgPSAwLjA7XHJcbiAgZmxvYXQgcDIgPSAwLjA7XHJcbiAgZmxvYXQgcDMgPSAwLjA7XHJcbiAgZmxvYXQgcDQgPSAwLjA7XHJcbiAgZmxvYXQgcDUgPSAwLjA7XHJcbiAgZmxvYXQgc0cgPSBnb2FsLng7XHJcblxyXG4gIGlmIChzRyA8IDAuMSkgcmV0dXJuIHZlYzQoMC4wKTtcclxuXHJcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBSRUxBWEFUSU9OX0lURVJBVElPTlM7IGkrKykge1xyXG4gICAgcDAgKz0gZF9LMDtcclxuICAgIHAxICs9IGRfZEswO1xyXG4gICAgcDIgKz0gZF9kZEswO1xyXG4gICAgcDUgKz0gZEdvYWwudztcclxuICAgIGdvYWwgKz0gZEdvYWw7XHJcbiAgICBcclxuICAgIHZlYzQgcmVzdWx0ID0gaXRlcmF0ZShnb2FsLCBwMCwgcDEsIHAyLCBwMywgcDQsIHA1LCBzRyk7XHJcbiAgICBwMyA9IHJlc3VsdC54O1xyXG4gICAgcDQgPSByZXN1bHQueTtcclxuICAgIHNHID0gcmVzdWx0Lno7XHJcbiAgfVxyXG5cclxuICBnb2FsID0gb3JpZ2luYWxHb2FsO1xyXG5cclxuICBmb3IgKGludCBpID0gMDsgaSA8IE5FV1RPTl9JVEVSQVRJT05TOyBpKyspIHtcclxuICAgIHZlYzQgcmVzdWx0ID0gaXRlcmF0ZShnb2FsLCBwMCwgcDEsIHAyLCBwMywgcDQsIHA1LCBzRyk7XHJcbiAgICBpZiAocmVzdWx0LncgPT0gMS4wKSB7XHJcbiAgICAgIHJlc3VsdC53ID0gc3RlcCgwLjAsIHJlc3VsdC56KTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBwMyA9IHJlc3VsdC54O1xyXG4gICAgcDQgPSByZXN1bHQueTtcclxuICAgIHNHID0gcmVzdWx0Lno7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdmVjNChwMywgcDQsIHNHLCAwLjApO1xyXG59XHJcblxyXG52ZWM0IGtlcm5lbCgpIHtcclxuICBpdmVjMiBsYXR0aWNlSW5kZXhlcyA9IGl2ZWMyKGtlcm5lbFBvc2l0aW9uICogdmVjMihrZXJuZWxTaXplKSk7XHJcblxyXG4gIHZlYzQgc3RhcnQgPSB2ZWM0KDAsIDAsIDAsIGN1cnZWZWhpY2xlKTtcclxuICB2ZWM0IGVuZCA9IHRleGVsRmV0Y2gobGF0dGljZSwgbGF0dGljZUluZGV4ZXMsIDApO1xyXG5cclxuICByZXR1cm4gb3B0aW1pemUoc3RhcnQsIGVuZCk7XHJcbn1cclxuXHJcbmA7XHJcblxyXG4vLyBRdWludGljIHNwaXJhbCBwYXRoIG9wdGltaXplclxyXG4vLyAgICogU3RhcnQgb2YgcGF0aHMgaXMgdGhlIHZlaGljbGUgcG9zZVxyXG4vLyAgICAgKiB4LXBvcywgeS1wb3MsIGFuZCByb3RhdGlvbiBhcmVuJ3QgbmVlZGVkLCBzaW5jZSB0aGUgbGF0dGljZSBvcmlnaW4gaXMgdGhlIHZlaGljbGUgcG9zZVxyXG4vLyAgICAgKiBTbyBhc3N1bWUgcG9zaXRpb24gYW5kIHJvdGF0aW9uIGFyZSAwXHJcbi8vICAgKiBFbmRzIG9mIHBhdGhzIGFyZSBhbGwgbGF0aXR1ZGVzIHdpdGhpbiB0aGUgZmlyc3QgKHN0YXRpb25Db25uZWN0aXZpdHkpIHN0YXRpb25zXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBzZXRVcCgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGtlcm5lbDogT1BUSU1JWkVfS0VSTkVMLFxyXG4gICAgICBvdXRwdXQ6IHsgbmFtZTogJ3F1aW50aWNQYXRoc0Zyb21WZWhpY2xlJywgcmVhZDogdHJ1ZSB9LFxyXG4gICAgICB1bmlmb3Jtczoge1xyXG4gICAgICAgIGxhdHRpY2U6IHsgdHlwZTogJ3NoYXJlZFRleHR1cmUnIH0sXHJcbiAgICAgICAgY3VydlZlaGljbGU6IHsgdHlwZTogJ2Zsb2F0JyB9LFxyXG4gICAgICAgIGRDdXJ2VmVoaWNsZTogeyB0eXBlOiAnZmxvYXQnIH0sXHJcbiAgICAgICAgZGRDdXJ2VmVoaWNsZTogeyB0eXBlOiAnZmxvYXQnIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9LFxyXG5cclxuICB1cGRhdGUoY29uZmlnLCBwb3NlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB3aWR0aDogY29uZmlnLmxhdHRpY2UubnVtTGF0aXR1ZGVzLFxyXG4gICAgICBoZWlnaHQ6IGNvbmZpZy5sYXR0aWNlLnN0YXRpb25Db25uZWN0aXZpdHksXHJcbiAgICAgIHVuaWZvcm1zOiB7XHJcbiAgICAgICAgY3VydlZlaGljbGU6IHBvc2UuY3VydixcclxuICAgICAgICBkQ3VydlZlaGljbGU6IHBvc2UuZEN1cnYsXHJcbiAgICAgICAgZGRDdXJ2VmVoaWNsZTogcG9zZS5kZEN1cnZcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuIiwiY29uc3QgU0hBUkVEX1NIQURFUiA9IGBcclxuXHJcbmNvbnN0IGZsb2F0IHNtYWxsViA9IDAuMDE7XHJcbnZlYzQgcGF0aFNhbXBsZXNbMTI4XTtcclxuZmxvYXQgcGF0aFNhbXBsZUN1cnZSYXRlc1sxMjhdO1xyXG5cclxuZmxvYXQgY2FsY3VsYXRlQWNjZWxlcmF0aW9uKGludCBpbmRleCwgZmxvYXQgaW5pdGlhbFZlbG9jaXR5U3EsIGZsb2F0IGRpc3RhbmNlKSB7XHJcbiAgaWYgKGluZGV4IDw9IDQpIHtcclxuICAgIC8vIFthTWF4SGFyZCwgYU1pbkhhcmQsIGFNYXhTb2Z0LCBhTWluU29mdCwgMF1cclxuICAgIHJldHVybiBhY2NlbGVyYXRpb25Qcm9maWxlc1tpbmRleF07XHJcbiAgfSBlbHNlIHtcclxuICAgIGZsb2F0IGZpbmFsVmVsb2NpdHkgPSBmaW5hbFZlbG9jaXR5UHJvZmlsZXNbaW5kZXggLSA1XTtcclxuICAgIGlmIChkaXN0YW5jZSA8IDAuMDAxKSByZXR1cm4gMC4wO1xyXG4gICAgcmV0dXJuIGNsYW1wKChmaW5hbFZlbG9jaXR5ICogZmluYWxWZWxvY2l0eSAtIGluaXRpYWxWZWxvY2l0eVNxKSAvICgyLjAgKiBkaXN0YW5jZSksIGFjY2VsZXJhdGlvblByb2ZpbGVzWzFdLCBhY2NlbGVyYXRpb25Qcm9maWxlc1swXSk7XHJcbiAgfVxyXG59XHJcblxyXG52ZWMyIHh5MnNsKHZlYzQgeHl0aykge1xyXG4gIHZlYzIgeHkgPSB4eXRrLnh5ICsgcmVhckF4bGVUb0NlbnRlciAqIHZlYzIoY29zKHh5dGsueiksIHNpbih4eXRrLnopKTtcclxuICB2ZWMyIHh5VGV4Q29vcmRzID0gKHh5IC0geHlDZW50ZXJQb2ludCkgLyB2ZWMyKHRleHR1cmVTaXplKHh5c2xNYXAsIDApKSAvIHZlYzIoeHlHcmlkQ2VsbFNpemUpICsgMC41O1xyXG4gIHJldHVybiB0ZXh0dXJlKHh5c2xNYXAsIHh5VGV4Q29vcmRzKS54eTtcclxufVxyXG5cclxuZmxvYXQgc2FtcGxlU3RhdGljQ29zdCh2ZWM0IHh5dGspIHtcclxuICB2ZWMyIHNsID0geHkyc2woeHl0ayk7XHJcbiAgdmVjMiBzbFRleENvb3JkcyA9IChzbCAtIHNsQ2VudGVyUG9pbnQpIC8gdmVjMih0ZXh0dXJlU2l6ZShzbE9ic3RhY2xlR3JpZCwgMCkpIC8gdmVjMihzbEdyaWRDZWxsU2l6ZSkgKyAwLjU7XHJcbiAgZmxvYXQgb2JzdGFjbGVDb3N0ID0gdGV4dHVyZShzbE9ic3RhY2xlR3JpZCwgc2xUZXhDb29yZHMpLnI7XHJcblxyXG4gIGlmIChvYnN0YWNsZUNvc3QgPj0gMC43NSkgcmV0dXJuIC0xLjA7IC8vIEluZmluaXRlIGNvc3RcclxuXHJcbiAgb2JzdGFjbGVDb3N0ID0gc3RlcCgwLjI1LCBvYnN0YWNsZUNvc3QpICogb2JzdGFjbGVIYXphcmRDb3N0O1xyXG5cclxuICBmbG9hdCBhYnNMYXRpdHVkZSA9IGFicyhzbC55KTtcclxuICBpZiAoYWJzTGF0aXR1ZGUgPj0gbGFuZVNob3VsZGVyTGF0aXR1ZGUpIHJldHVybiAtMS4wO1xyXG5cclxuICBmbG9hdCBsYW5lQ29zdCA9IGFicyhhYnNMYXRpdHVkZSAtIGxhbmVDZW50ZXJMYXRpdHVkZSkgKiBsYW5lQ29zdFNsb3BlICsgc3RlcCgwLjAsIC1zbC55ICogc2lnbihsYW5lUHJlZmVyZW5jZSkpICogbGFuZVByZWZlcmVuY2VEaXNjb3VudDtcclxuXHJcbiAgcmV0dXJuIG9ic3RhY2xlQ29zdCArIGxhbmVDb3N0O1xyXG59XHJcblxyXG5mbG9hdCBzYW1wbGVEeW5hbWljQ29zdCh2ZWM0IHh5dGssIGZsb2F0IHRpbWUsIGZsb2F0IHZlbG9jaXR5LCBmbG9hdCBhY2NlbGVyYXRpb24pIHtcclxuICB2ZWMyIHNsID0geHkyc2woeHl0ayk7XHJcbiAgdmVjMiBzbFRleENvb3JkcyA9IChzbCAtIHNsQ2VudGVyUG9pbnQpIC8gdmVjMih0ZXh0dXJlU2l6ZShzbER5bmFtaWNPYnN0YWNsZUdyaWQsIDApLnh5KSAvIHZlYzIoc2xHcmlkQ2VsbFNpemUpICsgMC41O1xyXG4gIGZsb2F0IGR5bmFtaWNGcmFtZSA9IGZsb29yKHRpbWUgLyBkeW5hbWljRnJhbWVUaW1lKTtcclxuXHJcbiAgZmxvYXQgb2JzdGFjbGVDb3N0ID0gdGV4dHVyZShzbER5bmFtaWNPYnN0YWNsZUdyaWQsIHZlYzMoc2xUZXhDb29yZHMsIGR5bmFtaWNGcmFtZSkpLnI7XHJcblxyXG4gIGlmIChvYnN0YWNsZUNvc3QgPiAwLjc1KSByZXR1cm4gLTEuMDsgLy8gSW5maW5pdGUgY29zdFxyXG5cclxuICByZXR1cm4gc3RlcCgwLjI1LCBvYnN0YWNsZUNvc3QpICogb2JzdGFjbGVIYXphcmRDb3N0O1xyXG59XHJcblxyXG5mbG9hdCBjYWxjdWxhdGVBdmVyYWdlU3RhdGljQ29zdChpbnQgbnVtU2FtcGxlcykge1xyXG4gIGZsb2F0IGF2ZXJhZ2VTdGF0aWNDb3N0ID0gMC4wO1xyXG5cclxuICBmb3IgKGludCBpID0gMDsgaSA8IG51bVNhbXBsZXM7IGkrKykge1xyXG4gICAgZmxvYXQgY29zdCA9IHNhbXBsZVN0YXRpY0Nvc3QocGF0aFNhbXBsZXNbaV0pO1xyXG5cclxuICAgIGlmIChjb3N0IDwgMC4wKSByZXR1cm4gY29zdDtcclxuXHJcbiAgICBhdmVyYWdlU3RhdGljQ29zdCArPSBjb3N0O1xyXG4gIH1cclxuXHJcbiAgYXZlcmFnZVN0YXRpY0Nvc3QgLz0gZmxvYXQobnVtU2FtcGxlcyk7XHJcblxyXG4gIHJldHVybiBhdmVyYWdlU3RhdGljQ29zdDtcclxufVxyXG5cclxuZmxvYXQgY2FsY3VsYXRlQXZlcmFnZUR5bmFtaWNDb3N0KGludCBudW1TYW1wbGVzLCBmbG9hdCBwYXRoTGVuZ3RoLCBmbG9hdCBpbml0aWFsVGltZSwgZmxvYXQgaW5pdGlhbFZlbG9jaXR5LCBmbG9hdCBhY2NlbGVyYXRpb24sIGZsb2F0IGFiYW5kb25UaHJlc2hvbGQpIHtcclxuICBmbG9hdCBzID0gMC4wO1xyXG4gIGZsb2F0IGRzID0gcGF0aExlbmd0aCAvIGZsb2F0KG51bVNhbXBsZXMgLSAxKTtcclxuICBmbG9hdCBhdmVyYWdlRHluYW1pY0Nvc3QgPSAwLjA7XHJcbiAgZmxvYXQgbWF4VmVsb2NpdHkgPSAwLjA7XHJcbiAgZmxvYXQgbWF4TGF0ZXJhbEFjY2VsZXJhdGlvbiA9IDAuMDtcclxuICBmbG9hdCBudW1TYW1wbGVzX2YgPSBmbG9hdChudW1TYW1wbGVzKTtcclxuXHJcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBudW1TYW1wbGVzOyBpKyspIHtcclxuICAgIHZlYzQgcGF0aFNhbXBsZSA9IHBhdGhTYW1wbGVzW2ldOyAvLyB2ZWM0KHgtcG9zLCB5LXBvcywgdGhldGEgKHJvdGF0aW9uKSwga2FwcGEgKGN1cnZhdHVyZSkpXHJcblxyXG4gICAgZmxvYXQgdmVsb2NpdHlTcSA9IDIuMCAqIGFjY2VsZXJhdGlvbiAqIHMgKyBpbml0aWFsVmVsb2NpdHkgKiBpbml0aWFsVmVsb2NpdHk7XHJcbiAgICBmbG9hdCB2ZWxvY2l0eSA9IG1heChzbWFsbFYsIHNxcnQobWF4KDAuMCwgdmVsb2NpdHlTcSkpKTtcclxuICAgIG1heFZlbG9jaXR5ID0gbWF4KG1heFZlbG9jaXR5LCB2ZWxvY2l0eSk7XHJcbiAgICBtYXhMYXRlcmFsQWNjZWxlcmF0aW9uID0gbWF4KG1heExhdGVyYWxBY2NlbGVyYXRpb24sIGFicyhwYXRoU2FtcGxlLncgKiB2ZWxvY2l0eSAqIHZlbG9jaXR5KSk7XHJcblxyXG4gICAgZmxvYXQgdGltZSA9IDIuMCAqIHMgLyAoaW5pdGlhbFZlbG9jaXR5ICsgdmVsb2NpdHkpICsgaW5pdGlhbFRpbWU7XHJcblxyXG4gICAgZmxvYXQgZEN1cnYgPSBwYXRoU2FtcGxlQ3VydlJhdGVzW2ldICogdmVsb2NpdHk7XHJcbiAgICBpZiAoZEN1cnYgPiBkQ3VydmF0dXJlTWF4KSByZXR1cm4gLTEuMDtcclxuXHJcbiAgICBmbG9hdCBjb3N0ID0gc2FtcGxlRHluYW1pY0Nvc3QocGF0aFNhbXBsZSwgdGltZSwgdmVsb2NpdHksIGFjY2VsZXJhdGlvbik7XHJcbiAgICBpZiAoY29zdCA8IDAuMCkgcmV0dXJuIGNvc3Q7XHJcblxyXG4gICAgYXZlcmFnZUR5bmFtaWNDb3N0ICs9IGNvc3Q7XHJcbiAgICBpZiAoYXZlcmFnZUR5bmFtaWNDb3N0IC8gbnVtU2FtcGxlc19mID49IGFiYW5kb25UaHJlc2hvbGQpIHJldHVybiAtMS4wO1xyXG5cclxuICAgIHMgKz0gZHM7XHJcbiAgfVxyXG5cclxuICBhdmVyYWdlRHluYW1pY0Nvc3QgLz0gbnVtU2FtcGxlc19mO1xyXG5cclxuICAvLyBBcHBseSBzcGVlZGluZyBwZW5hbGl0eSBpZiBhbnkgdmVsb2NpdHkgYWxvbmcgdGhlIHRyYWplY3RvcnkgaXMgb3ZlciB0aGUgc3BlZWQgbGltaXRcclxuICBhdmVyYWdlRHluYW1pY0Nvc3QgKz0gc3RlcChzcGVlZExpbWl0LCBtYXhWZWxvY2l0eSkgKiBzcGVlZExpbWl0UGVuYWx0eTtcclxuXHJcbiAgLy8gQXBwbHkgaGFyZCBhY2NlbGVyYXRpb24vZGVjZWxlcmF0aW9uIHBlbmFsdGllcyBpZiB0aGUgYWNjZWxlcmF0aW9uL2RlY2VsZXJhdGlvbiBleGNlZWRzIHRoZSBzb2Z0IGxpbWl0c1xyXG4gIGF2ZXJhZ2VEeW5hbWljQ29zdCArPSBzdGVwKGFjY2VsZXJhdGlvblByb2ZpbGVzWzJdICsgMC4wMDAxLCBhY2NlbGVyYXRpb24pICogaGFyZEFjY2VsZXJhdGlvblBlbmFsdHk7XHJcbiAgYXZlcmFnZUR5bmFtaWNDb3N0ICs9ICgxLjAgLSBzdGVwKGFjY2VsZXJhdGlvblByb2ZpbGVzWzNdLCBhY2NlbGVyYXRpb24pKSAqIGhhcmREZWNlbGVyYXRpb25QZW5hbHR5O1xyXG5cclxuICAvLyBQZW5hbGl6ZSBsYXRlcmFsIGFjY2VsZXJhdGlvblxyXG4gIGF2ZXJhZ2VEeW5hbWljQ29zdCArPSBzdGVwKHNvZnRMYXRlcmFsQWNjZWxlcmF0aW9uTGltaXQsIG1heExhdGVyYWxBY2NlbGVyYXRpb24pICogc29mdExhdGVyYWxBY2NlbGVyYXRpb25QZW5hbHR5O1xyXG4gIGF2ZXJhZ2VEeW5hbWljQ29zdCArPSBsaW5lYXJMYXRlcmFsQWNjZWxlcmF0aW9uUGVuYWx0eSAqIG1heExhdGVyYWxBY2NlbGVyYXRpb247XHJcblxyXG4gIHJldHVybiBhdmVyYWdlRHluYW1pY0Nvc3Q7XHJcbn1cclxuXHJcbnZlYzMgY2FsY3VsYXRlQVZUKGludCBhY2NlbGVyYXRpb25JbmRleCwgZmxvYXQgaW5pdGlhbFZlbG9jaXR5LCBmbG9hdCBpbml0aWFsVGltZSwgZmxvYXQgcGF0aExlbmd0aCkge1xyXG4gIGZsb2F0IGluaXRpYWxWZWxvY2l0eVNxID0gaW5pdGlhbFZlbG9jaXR5ICogaW5pdGlhbFZlbG9jaXR5O1xyXG4gIGZsb2F0IGFjY2VsZXJhdGlvbiA9IGNhbGN1bGF0ZUFjY2VsZXJhdGlvbihhY2NlbGVyYXRpb25JbmRleCwgaW5pdGlhbFZlbG9jaXR5U3EsIHBhdGhMZW5ndGgpO1xyXG5cclxuICBmbG9hdCBmaW5hbFZlbG9jaXR5U3EgPSAyLjAgKiBhY2NlbGVyYXRpb24gKiBwYXRoTGVuZ3RoICsgaW5pdGlhbFZlbG9jaXR5U3E7XHJcbiAgZmxvYXQgZmluYWxWZWxvY2l0eSA9IG1heChzbWFsbFYsIHNxcnQobWF4KDAuMCwgZmluYWxWZWxvY2l0eVNxKSkpO1xyXG5cclxuICBmbG9hdCBmaW5hbFRpbWUgPSBpbml0aWFsVGltZTtcclxuXHJcbiAgaWYgKGFjY2VsZXJhdGlvbiA9PSAwLjApIHtcclxuICAgIGZpbmFsVGltZSArPSBwYXRoTGVuZ3RoIC8gZmluYWxWZWxvY2l0eTtcclxuICB9IGVsc2UgaWYgKGZpbmFsVmVsb2NpdHlTcSA8PSAwLjApIHsgLy8gQ2FsY3VsYXRlIGZpbmFsIHRpbWUgaWYgdGhlIHZlaGljbGUgc3RvcHMgYmVmb3JlIHRoZSBlbmQgb2YgdGhlIHRyYWplY3RvcnlcclxuICAgIGZsb2F0IGRpc3RhbmNlTGVmdCA9IHBhdGhMZW5ndGggLSAoc21hbGxWICogc21hbGxWIC0gaW5pdGlhbFZlbG9jaXR5U3EpIC8gKDIuMCAqIGFjY2VsZXJhdGlvbik7XHJcbiAgICBmaW5hbFRpbWUgKz0gKGZpbmFsVmVsb2NpdHkgLSBpbml0aWFsVmVsb2NpdHkpIC8gYWNjZWxlcmF0aW9uICsgZGlzdGFuY2VMZWZ0IC8gc21hbGxWO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBmaW5hbFRpbWUgKz0gMi4wICogcGF0aExlbmd0aCAvIChmaW5hbFZlbG9jaXR5ICsgaW5pdGlhbFZlbG9jaXR5KTtcclxuICB9XHJcblxyXG4gIHJldHVybiB2ZWMzKGFjY2VsZXJhdGlvbiwgZmluYWxWZWxvY2l0eSwgZmluYWxUaW1lKTtcclxufVxyXG5cclxuYDtcclxuXHJcbmNvbnN0IFNBTVBMRV9DVUJJQ19QQVRIX0ZOID0gYFxyXG5cclxuaW50IHNhbXBsZUN1YmljUGF0aCh2ZWM0IHN0YXJ0LCB2ZWM0IGVuZCwgdmVjNCBjdWJpY1BhdGhQYXJhbXMpIHtcclxuICBmbG9hdCBwMCA9IHN0YXJ0Lnc7XHJcbiAgZmxvYXQgcDEgPSBjdWJpY1BhdGhQYXJhbXMueDtcclxuICBmbG9hdCBwMiA9IGN1YmljUGF0aFBhcmFtcy55O1xyXG4gIGZsb2F0IHAzID0gZW5kLnc7XHJcbiAgZmxvYXQgc0cgPSBjdWJpY1BhdGhQYXJhbXMuejtcclxuXHJcbiAgaWYgKHNHIDw9IDAuMCkgcmV0dXJuIDA7XHJcblxyXG4gIGludCBudW1TYW1wbGVzID0gaW50KGNlaWwoc0cgLyBwYXRoU2FtcGxpbmdTdGVwKSkgKyAxO1xyXG5cclxuICBmbG9hdCBzR18yID0gc0cgKiBzRztcclxuICBmbG9hdCBzR18zID0gc0dfMiAqIHNHO1xyXG5cclxuICBmbG9hdCBhID0gcDA7XHJcbiAgZmxvYXQgYiA9ICgtNS41ICogcDAgKyA5LjAgKiBwMSAtIDQuNSAqIHAyICsgcDMpIC8gc0c7XHJcbiAgZmxvYXQgYyA9ICg5LjAgKiBwMCAtIDIyLjUgKiBwMSArIDE4LjAgKiBwMiAtIDQuNSAqIHAzKSAvIHNHXzI7XHJcbiAgZmxvYXQgZCA9ICgtNC41ICogKHAwIC0gMy4wICogcDEgKyAzLjAgKiBwMiAtIHAzKSkgLyBzR18zO1xyXG5cclxuICBwYXRoU2FtcGxlc1swXSA9IHN0YXJ0O1xyXG5cclxuICBmbG9hdCBkcyA9IHNHIC8gZmxvYXQobnVtU2FtcGxlcyAtIDEpO1xyXG4gIGZsb2F0IHMgPSBkcztcclxuICB2ZWMyIGR4eSA9IHZlYzIoMCk7XHJcbiAgdmVjMiBwcmV2Q29zU2luID0gdmVjMihjb3Moc3RhcnQueiksIHNpbihzdGFydC56KSk7XHJcblxyXG4gIGZvciAoaW50IGkgPSAxOyBpIDwgbnVtU2FtcGxlczsgaSsrKSB7XHJcbiAgICBmbG9hdCByb3QgPSAoKChkICogcyAvIDQuMCArIGMgLyAzLjApICogcyArIGIgLyAyLjApICogcyArIGEpICogcyArIHN0YXJ0Lno7XHJcbiAgICBmbG9hdCBjdXJ2ID0gKChkICogcyArIGMpICogcyArIGIpICogcyArIGE7XHJcblxyXG4gICAgdmVjMiBjb3NTaW4gPSB2ZWMyKGNvcyhyb3QpLCBzaW4ocm90KSk7XHJcbiAgICBkeHkgPSBkeHkgKiB2ZWMyKGZsb2F0KGkgLSAxKSAvIGZsb2F0KGkpKSArIChjb3NTaW4gKyBwcmV2Q29zU2luKSAvIHZlYzIoMiAqIGkpO1xyXG5cclxuICAgIHBhdGhTYW1wbGVzW2ldID0gdmVjNChkeHkgKiB2ZWMyKHMpICsgc3RhcnQueHksIHJvdCwgY3Vydik7XHJcbiAgICBwYXRoU2FtcGxlQ3VydlJhdGVzW2ldID0gYiArIHMgKiAoMi4wICogYyArIDMuMCAqIGQgKiBzKTtcclxuXHJcbiAgICBzICs9IGRzO1xyXG4gICAgcHJldkNvc1NpbiA9IGNvc1NpbjtcclxuICB9XHJcblxyXG4gIHJldHVybiBudW1TYW1wbGVzO1xyXG59XHJcblxyXG5gO1xyXG5cclxuY29uc3QgU0FNUExFX1FVSU5USUNfUEFUSF9GTiA9IGBcclxuXHJcbmludCBzYW1wbGVRdWludGljUGF0aCh2ZWM0IHN0YXJ0LCB2ZWM0IGVuZCwgdmVjNCBxdWludGljUGF0aFBhcmFtcykge1xyXG4gIGZsb2F0IHAwID0gc3RhcnQudztcclxuICBmbG9hdCBwMSA9IGRDdXJ2VmVoaWNsZTtcclxuICBmbG9hdCBwMiA9IGRkQ3VydlZlaGljbGU7XHJcbiAgZmxvYXQgcDMgPSBxdWludGljUGF0aFBhcmFtcy54O1xyXG4gIGZsb2F0IHA0ID0gcXVpbnRpY1BhdGhQYXJhbXMueTtcclxuICBmbG9hdCBwNSA9IGVuZC53O1xyXG4gIGZsb2F0IHNHID0gcXVpbnRpY1BhdGhQYXJhbXMuejtcclxuXHJcbiAgaWYgKHNHIDw9IDAuMCkgcmV0dXJuIDA7XHJcblxyXG4gIGludCBudW1TYW1wbGVzID0gaW50KGNlaWwoc0cgLyBwYXRoU2FtcGxpbmdTdGVwKSkgKyAxO1xyXG5cclxuICBmbG9hdCBzR18yID0gc0cgKiBzRztcclxuICBmbG9hdCBzR18zID0gc0dfMiAqIHNHO1xyXG5cclxuICBmbG9hdCBhID0gcDA7XHJcbiAgZmxvYXQgYiA9IHAxO1xyXG4gIGZsb2F0IGMgPSBwMiAvIDIuMDtcclxuICBmbG9hdCBkID0gKC03MS44NzUgKiBwMCArIDgxLjAgKiBwMyAtIDEwLjEyNSAqIHA0ICsgcDUgLSAyMS4yNSAqIHAxICogc0cgLSAyLjc1ICogcDIgKiBzR18yKSAvIHNHXzM7XHJcbiAgZmxvYXQgZSA9ICgxNjYuNSAqIHAwIC0gMjAyLjUgKiBwMyArIDQwLjUgKiBwNCAtIDQuNSAqIHA1ICsgNDUuMCAqIHAxICogc0cgKyA0LjUgKiBwMiAqIHNHXzIpIC8gKHNHXzIgKiBzR18yKTtcclxuICBmbG9hdCBmID0gKC05NS42MjUgKiBwMCArIDEyMS41ICogcDMgLSAzMC4zNzUgKiBwNCArIDQuNSAqIHA1IC0gMjQuNzUgKiBwMSAqIHNHIC0gMi4yNSAqIHAyICogc0dfMikgLyAoc0dfMiAqIHNHXzMpO1xyXG5cclxuICBwYXRoU2FtcGxlc1swXSA9IHN0YXJ0O1xyXG5cclxuICBmbG9hdCBkcyA9IHNHIC8gZmxvYXQobnVtU2FtcGxlcyAtIDEpO1xyXG4gIGZsb2F0IHMgPSBkcztcclxuICB2ZWMyIGR4eSA9IHZlYzIoMCk7XHJcbiAgdmVjMiBwcmV2Q29zU2luID0gdmVjMihjb3Moc3RhcnQueiksIHNpbihzdGFydC56KSk7XHJcblxyXG4gIGZvciAoaW50IGkgPSAxOyBpIDwgbnVtU2FtcGxlczsgaSsrKSB7XHJcbiAgICBmbG9hdCByb3QgPSAoKCgoKGYgKiBzIC8gNi4wICsgZSAvIDUuMCkgKiBzICsgZCAvIDQuMCkgKiBzICsgYyAvIDMuMCkgKiBzICsgYiAvIDIuMCkgKiBzICsgYSkgKiBzICsgc3RhcnQuejtcclxuICAgIGZsb2F0IGN1cnYgPSAoKCgoZiAqIHMgKyBlKSAqIHMgKyBkKSAqIHMgKyBjKSAqIHMgKyBiKSAqIHMgKyBhO1xyXG5cclxuICAgIHZlYzIgY29zU2luID0gdmVjMihjb3Mocm90KSwgc2luKHJvdCkpO1xyXG4gICAgZHh5ID0gZHh5ICogdmVjMihmbG9hdChpIC0gMSkgLyBmbG9hdChpKSkgKyAoY29zU2luICsgcHJldkNvc1NpbikgLyB2ZWMyKDIgKiBpKTtcclxuXHJcbiAgICBwYXRoU2FtcGxlc1tpXSA9IHZlYzQoZHh5ICogdmVjMihzKSArIHN0YXJ0Lnh5LCByb3QsIGN1cnYpO1xyXG4gICAgcGF0aFNhbXBsZUN1cnZSYXRlc1tpXSA9IGIgKyBzICogKDIuMCAqIGMgKyBzICogKDMuMCAqIGQgKyBzICogKDQuMCAqIGUgKyA1LjAgKiBmICogcykpKTtcclxuXHJcbiAgICBzICs9IGRzO1xyXG4gICAgcHJldkNvc1NpbiA9IGNvc1NpbjtcclxuICB9XHJcblxyXG4gIHJldHVybiBudW1TYW1wbGVzO1xyXG59XHJcblxyXG5gO1xyXG5cclxuY29uc3QgTlVNX0FDQ0VMRVJBVElPTl9QUk9GSUxFUyA9IDg7XHJcbmNvbnN0IE5VTV9WRUxPQ0lUWV9SQU5HRVMgPSA0O1xyXG5jb25zdCBOVU1fVElNRV9SQU5HRVMgPSAyO1xyXG5cclxuY29uc3QgU0hBUkVEX1VOSUZPUk1TID0ge1xyXG4gIHh5c2xNYXA6IHsgdHlwZTogJ291dHB1dFRleHR1cmUnIH0sXHJcbiAgc2xPYnN0YWNsZUdyaWQ6IHsgdHlwZTogJ291dHB1dFRleHR1cmUnLCBuYW1lOiAnc2xPYnN0YWNsZUdyaWREaWxhdGVkJyB9LFxyXG4gIHNsRHluYW1pY09ic3RhY2xlR3JpZDogeyB0eXBlOiAnb3V0cHV0VGV4dHVyZScsIG5hbWU6ICdzbER5bmFtaWNPYnN0YWNsZUdyaWQnLCB0ZXh0dXJlVHlwZTogJzJEQXJyYXknIH0sXHJcbiAgYWNjZWxlcmF0aW9uUHJvZmlsZXM6IHsgdHlwZTogJ2Zsb2F0JywgbGVuZ3RoOiA1IH0sXHJcbiAgZmluYWxWZWxvY2l0eVByb2ZpbGVzOiB7IHR5cGU6ICdmbG9hdCcsIGxlbmd0aDogMyB9LFxyXG4gIHh5Q2VudGVyUG9pbnQ6IHsgdHlwZTogJ3ZlYzInIH0sXHJcbiAgeHlHcmlkQ2VsbFNpemU6IHsgdHlwZTogJ2Zsb2F0JyB9LFxyXG4gIHNsQ2VudGVyUG9pbnQ6IHsgdHlwZTogJ3ZlYzInIH0sXHJcbiAgc2xHcmlkQ2VsbFNpemU6IHsgdHlwZTogJ2Zsb2F0J30sXHJcbiAgbGFuZUNlbnRlckxhdGl0dWRlOiB7IHR5cGU6ICdmbG9hdCd9LFxyXG4gIGxhbmVTaG91bGRlckxhdGl0dWRlOiB7IHR5cGU6ICdmbG9hdCd9LFxyXG4gIGxhbmVDb3N0U2xvcGU6IHsgdHlwZTogJ2Zsb2F0J30sXHJcbiAgbGFuZVByZWZlcmVuY2U6IHsgdHlwZTogJ2Zsb2F0JyB9LFxyXG4gIGxhbmVQcmVmZXJlbmNlRGlzY291bnQ6IHsgdHlwZTogJ2Zsb2F0JyB9LFxyXG4gIG9ic3RhY2xlSGF6YXJkQ29zdDogeyB0eXBlOiAnZmxvYXQnIH0sXHJcbiAgc3BlZWRMaW1pdDogeyB0eXBlOiAnZmxvYXQnIH0sXHJcbiAgc3BlZWRMaW1pdFBlbmFsdHk6IHsgdHlwZTogJ2Zsb2F0JyB9LFxyXG4gIGhhcmRBY2NlbGVyYXRpb25QZW5hbHR5OiB7IHR5cGU6ICdmbG9hdCcgfSxcclxuICBoYXJkRGVjZWxlcmF0aW9uUGVuYWx0eTogeyB0eXBlOiAnZmxvYXQnIH0sXHJcbiAgc29mdExhdGVyYWxBY2NlbGVyYXRpb25MaW1pdDogeyB0eXBlOiAnZmxvYXQnIH0sXHJcbiAgc29mdExhdGVyYWxBY2NlbGVyYXRpb25QZW5hbHR5OiB7IHR5cGU6ICdmbG9hdCcgfSxcclxuICBsaW5lYXJMYXRlcmFsQWNjZWxlcmF0aW9uUGVuYWx0eTogeyB0eXBlOiAnZmxvYXQnIH0sXHJcbiAgZEN1cnZhdHVyZU1heDogeyB0eXBlOiAnZmxvYXQnIH0sXHJcbiAgcGF0aFNhbXBsaW5nU3RlcDogeyB0eXBlOiAnZmxvYXQnIH0sXHJcbiAgcmVhckF4bGVUb0NlbnRlcjogeyB0eXBlOiAnZmxvYXQnIH0sXHJcbiAgZHluYW1pY0ZyYW1lVGltZTogeyB0eXBlOiAnZmxvYXQnIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIGJ1aWxkVW5pZm9ybVZhbHVlcyhjb25maWcsIHh5Q2VudGVyUG9pbnQsIHNsQ2VudGVyUG9pbnQsIGR5bmFtaWNGcmFtZVRpbWUpIHtcclxuICByZXR1cm4ge1xyXG4gICAgYWNjZWxlcmF0aW9uUHJvZmlsZXM6IFszLjUsIC02LjUsIDIuMCwgLTMuMCwgMF0sXHJcbiAgICBmaW5hbFZlbG9jaXR5UHJvZmlsZXM6IFswLjk5OSAqIGNvbmZpZy5zcGVlZExpbWl0LCAxLjAsIDAuMDFdLFxyXG4gICAgeHlDZW50ZXJQb2ludDogW3h5Q2VudGVyUG9pbnQueCwgeHlDZW50ZXJQb2ludC55XSxcclxuICAgIHh5R3JpZENlbGxTaXplOiBjb25maWcueHlHcmlkQ2VsbFNpemUsXHJcbiAgICBzbENlbnRlclBvaW50OiBbc2xDZW50ZXJQb2ludC54LCBzbENlbnRlclBvaW50LnldLFxyXG4gICAgc2xHcmlkQ2VsbFNpemU6IGNvbmZpZy5zbEdyaWRDZWxsU2l6ZSxcclxuICAgIGxhbmVDZW50ZXJMYXRpdHVkZTogY29uZmlnLmxhbmVDZW50ZXJMYXRpdHVkZSxcclxuICAgIGxhbmVTaG91bGRlckxhdGl0dWRlOiBjb25maWcubGFuZVNob3VsZGVyTGF0aXR1ZGUsXHJcbiAgICBsYW5lQ29zdFNsb3BlOiBjb25maWcubGFuZUNvc3RTbG9wZSxcclxuICAgIGxhbmVQcmVmZXJlbmNlOiBjb25maWcubGFuZVByZWZlcmVuY2UsXHJcbiAgICBsYW5lUHJlZmVyZW5jZURpc2NvdW50OiBjb25maWcubGFuZVByZWZlcmVuY2VEaXNjb3VudCxcclxuICAgIG9ic3RhY2xlSGF6YXJkQ29zdDogY29uZmlnLm9ic3RhY2xlSGF6YXJkQ29zdCxcclxuICAgIHNwZWVkTGltaXQ6IGNvbmZpZy5zcGVlZExpbWl0LFxyXG4gICAgc3BlZWRMaW1pdFBlbmFsdHk6IGNvbmZpZy5zcGVlZExpbWl0UGVuYWx0eSxcclxuICAgIGhhcmRBY2NlbGVyYXRpb25QZW5hbHR5OiBjb25maWcuaGFyZEFjY2VsZXJhdGlvblBlbmFsdHksXHJcbiAgICBoYXJkRGVjZWxlcmF0aW9uUGVuYWx0eTogY29uZmlnLmhhcmREZWNlbGVyYXRpb25QZW5hbHR5LFxyXG4gICAgc29mdExhdGVyYWxBY2NlbGVyYXRpb25MaW1pdDogY29uZmlnLnNvZnRMYXRlcmFsQWNjZWxlcmF0aW9uTGltaXQsXHJcbiAgICBzb2Z0TGF0ZXJhbEFjY2VsZXJhdGlvblBlbmFsdHk6IGNvbmZpZy5zb2Z0TGF0ZXJhbEFjY2VsZXJhdGlvblBlbmFsdHksXHJcbiAgICBsaW5lYXJMYXRlcmFsQWNjZWxlcmF0aW9uUGVuYWx0eTogY29uZmlnLmxpbmVhckxhdGVyYWxBY2NlbGVyYXRpb25QZW5hbHR5LFxyXG4gICAgZEN1cnZhdHVyZU1heDogY29uZmlnLmRDdXJ2YXR1cmVNYXgsXHJcbiAgICBwYXRoU2FtcGxpbmdTdGVwOiBjb25maWcucGF0aFNhbXBsaW5nU3RlcCxcclxuICAgIHJlYXJBeGxlVG9DZW50ZXI6IGNvbmZpZy5yZWFyQXhsZVRvQ2VudGVyLFxyXG4gICAgZHluYW1pY0ZyYW1lVGltZTogZHluYW1pY0ZyYW1lVGltZVxyXG4gIH07XHJcbn1cclxuXHJcbmV4cG9ydCB7XHJcbiAgU0hBUkVEX1NIQURFUixcclxuICBTQU1QTEVfQ1VCSUNfUEFUSF9GTixcclxuICBTQU1QTEVfUVVJTlRJQ19QQVRIX0ZOLFxyXG5cclxuICBOVU1fQUNDRUxFUkFUSU9OX1BST0ZJTEVTLFxyXG4gIE5VTV9WRUxPQ0lUWV9SQU5HRVMsXHJcbiAgTlVNX1RJTUVfUkFOR0VTLFxyXG5cclxuICBTSEFSRURfVU5JRk9STVMsXHJcbiAgYnVpbGRVbmlmb3JtVmFsdWVzXHJcbn1cclxuIiwiaW1wb3J0IHsgU0hBUkVEX1NIQURFUiwgU0FNUExFX0NVQklDX1BBVEhfRk4sIFNBTVBMRV9RVUlOVElDX1BBVEhfRk4sIE5VTV9BQ0NFTEVSQVRJT05fUFJPRklMRVMsIFNIQVJFRF9VTklGT1JNUywgYnVpbGRVbmlmb3JtVmFsdWVzIH0gZnJvbSBcIi4vZ3JhcGhTZWFyY2hTaGFyZWQuanNcIjtcclxuXHJcbmZ1bmN0aW9uIGZyb21WZWhpY2xlUGF0aENvc3RzS2VybmVsKHBhdGhUeXBlKSB7XHJcbiAgcmV0dXJuIFNIQVJFRF9TSEFERVIgKyAocGF0aFR5cGUgPT0gJ2N1YmljJyA/IFNBTVBMRV9DVUJJQ19QQVRIX0ZOIDogU0FNUExFX1FVSU5USUNfUEFUSF9GTikgK1xyXG5cclxuYFxyXG5cclxuLyogQ2FsY3VsYXRlIGNvc3Qgb2YgYSB7Y3ViaWN8cXVpbnRpY30gcGF0aCBmcm9tIHZlaGljbGUgdG8gKHN0YXRpb25Db25uZWN0aXZpdHkgKiBudW1MYXRpdHVkZXMgKiBudW1BY2NlbGVyYXRpb25zKSBub2Rlc1xyXG4gKiAgIHdpZHRoOiBudW1MYXRpdHVkZXNcclxuICogICBoZWlnaHQ6IHN0YXRpb24gKiBudW1BY2NlbGVyYXRpb25zXHJcbiAqL1xyXG52ZWM0IGtlcm5lbCgpIHtcclxuICBpdmVjMiBpbmRleGVzID0gaXZlYzIoa2VybmVsUG9zaXRpb24gKiB2ZWMyKGtlcm5lbFNpemUpKTtcclxuXHJcbiAgaW50IGxhdGl0dWRlID0gaW5kZXhlcy54O1xyXG4gIGludCBzdGF0aW9uID0gaW5kZXhlcy55IC8gbnVtQWNjZWxlcmF0aW9ucztcclxuICBpbnQgYWNjZWxlcmF0aW9uSW5kZXggPSBpbnQobW9kKGZsb2F0KGluZGV4ZXMueSksIGZsb2F0KG51bUFjY2VsZXJhdGlvbnMpKSk7XHJcblxyXG4gIHZlYzQgcGF0aFN0YXJ0ID0gdmVjNCgwLCAwLCAwLCBjdXJ2VmVoaWNsZSk7XHJcbiAgdmVjNCBwYXRoRW5kID0gdGV4ZWxGZXRjaChsYXR0aWNlLCBpdmVjMihsYXRpdHVkZSwgc3RhdGlvbiksIDApO1xyXG5cclxuICB2ZWM0IHBhdGhQYXJhbXMgPSB0ZXhlbEZldGNoKHBhdGhzRnJvbVZlaGljbGUsIGl2ZWMyKGxhdGl0dWRlLCBzdGF0aW9uKSwgMCk7XHJcblxyXG4gIC8vIElmIHRoZSBwYXRoIGRpZG4ndCBjb252ZXJnZVxyXG4gIGlmIChwYXRoUGFyYW1zLncgPT0gMC4wKSByZXR1cm4gdmVjNCgtMSk7XHJcblxyXG4gIGludCBudW1TYW1wbGVzID0gJHtwYXRoVHlwZSA9PSAnY3ViaWMnID8gJ3NhbXBsZUN1YmljUGF0aCcgOiAnc2FtcGxlUXVpbnRpY1BhdGgnfShwYXRoU3RhcnQsIHBhdGhFbmQsIHBhdGhQYXJhbXMpO1xyXG4gIGZsb2F0IHBhdGhMZW5ndGggPSBwYXRoUGFyYW1zLno7XHJcblxyXG4gIGlmIChudW1TYW1wbGVzIDwgMikgcmV0dXJuIHZlYzQoLTEpO1xyXG5cclxuICBmbG9hdCBhdmVyYWdlU3RhdGljQ29zdCA9IGNhbGN1bGF0ZUF2ZXJhZ2VTdGF0aWNDb3N0KG51bVNhbXBsZXMpO1xyXG4gIGlmIChhdmVyYWdlU3RhdGljQ29zdCA8IDAuMCkgcmV0dXJuIHZlYzQoLTEpO1xyXG5cclxuICBpbnQgc2xJbmRleCA9IHN0YXRpb24gKiBrZXJuZWxTaXplLnggKyBsYXRpdHVkZTtcclxuICBmbG9hdCBoeXN0ZXJlc2lzQWRqdXN0bWVudCA9IChzbEluZGV4ID09IGZpcnN0TGF0dGljZVBvaW50IHx8IHNsSW5kZXggPT0gc2Vjb25kTGF0dGljZVBvaW50KSA/ICAwLjAgOiBoeXN0ZXJlc2lzRGlzY291bnQ7XHJcbiAgYXZlcmFnZVN0YXRpY0Nvc3QgKz0gaHlzdGVyZXNpc0FkanVzdG1lbnQ7XHJcblxyXG4gIHZlYzMgYXZ0ID0gY2FsY3VsYXRlQVZUKGFjY2VsZXJhdGlvbkluZGV4LCB2ZWxvY2l0eVZlaGljbGUsIDAuMCwgcGF0aExlbmd0aCk7XHJcbiAgZmxvYXQgYWNjZWxlcmF0aW9uID0gYXZ0Lng7XHJcbiAgZmxvYXQgZmluYWxWZWxvY2l0eSA9IGF2dC55O1xyXG4gIGZsb2F0IGZpbmFsVGltZSA9IGF2dC56O1xyXG5cclxuICBmbG9hdCBhdmVyYWdlRHluYW1pY0Nvc3QgPSBjYWxjdWxhdGVBdmVyYWdlRHluYW1pY0Nvc3QobnVtU2FtcGxlcywgcGF0aExlbmd0aCwgMC4wLCB2ZWxvY2l0eVZlaGljbGUsIGFjY2VsZXJhdGlvbiwgMS4wIC8gMC4wKTtcclxuICBpZiAoYXZlcmFnZUR5bmFtaWNDb3N0IDwgMC4wKSByZXR1cm4gdmVjNCgtMSk7XHJcblxyXG4gIGF2ZXJhZ2VEeW5hbWljQ29zdCArPSBhY2NlbGVyYXRpb25DaGFuZ2VQZW5hbHR5O1xyXG5cclxuICAvLyBUaGUgY29zdCBvZiBhIHRyYWplY3RvcnkgaXMgdGhlIGF2ZXJhZ2Ugc2FtcGxlIGNvc3Qgc2NhbGVkIGJ5IHRoZSBwYXRoIGxlbmd0aFxyXG4gIGZsb2F0IHRvdGFsQ29zdCA9IChhdmVyYWdlU3RhdGljQ29zdCArIGF2ZXJhZ2VEeW5hbWljQ29zdCArICR7cGF0aFR5cGUgPT0gJ2N1YmljJyA/ICcoY3ViaWNQYXRoUGVuYWx0eSAqIHZlbG9jaXR5VmVoaWNsZSAqIHZlbG9jaXR5VmVoaWNsZSknIDogJzAuMCd9KSAqIHBhdGhMZW5ndGg7XHJcbiAgJHtwYXRoVHlwZSAhPSAnY3ViaWMnID8gJ3RvdGFsQ29zdCA9IC0xLjA7JyA6ICcnfVxyXG5cclxuICByZXR1cm4gdmVjNCh0b3RhbENvc3QsIGZpbmFsVmVsb2NpdHksIGZpbmFsVGltZSwgJHtwYXRoVHlwZSA9PSAnY3ViaWMnID8gJy0yJyA6ICctMSd9KTtcclxufVxyXG5cclxuYDtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHNldFVwKCkge1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAge1xyXG4gICAgICAgIGtlcm5lbDogZnJvbVZlaGljbGVQYXRoQ29zdHNLZXJuZWwoJ2N1YmljJyksXHJcbiAgICAgICAgb3V0cHV0OiB7IG5hbWU6ICdjdWJpY1BhdGhGcm9tVmVoaWNsZUNvc3RzJyB9LFxyXG4gICAgICAgIHVuaWZvcm1zOiBPYmplY3QuYXNzaWduKHt9LCBTSEFSRURfVU5JRk9STVMsIHtcclxuICAgICAgICAgIGxhdHRpY2U6IHsgdHlwZTogJ3NoYXJlZFRleHR1cmUnIH0sXHJcbiAgICAgICAgICBwYXRoc0Zyb21WZWhpY2xlOiB7IHR5cGU6ICdvdXRwdXRUZXh0dXJlJywgbmFtZTogJ2N1YmljUGF0aHNGcm9tVmVoaWNsZScgfSxcclxuICAgICAgICAgIGZpcnN0TGF0dGljZVBvaW50OiB7IHR5cGU6ICdpbnQnIH0sXHJcbiAgICAgICAgICBzZWNvbmRMYXR0aWNlUG9pbnQ6IHsgdHlwZTogJ2ludCcgfSxcclxuICAgICAgICAgIHZlbG9jaXR5VmVoaWNsZTogeyB0eXBlOiAnZmxvYXQnIH0sXHJcbiAgICAgICAgICBjdXJ2VmVoaWNsZTogeyB0eXBlOiAnZmxvYXQnIH0sXHJcbiAgICAgICAgICBudW1BY2NlbGVyYXRpb25zOiB7IHR5cGU6ICdpbnQnIH0sXHJcbiAgICAgICAgICBjdWJpY1BhdGhQZW5hbHR5OiB7IHR5cGU6ICdmbG9hdCcgfSxcclxuICAgICAgICAgIGh5c3RlcmVzaXNEaXNjb3VudDogeyB0eXBlOiAnZmxvYXQnIH0sXHJcbiAgICAgICAgICBhY2NlbGVyYXRpb25DaGFuZ2VQZW5hbHR5OiB7IHR5cGU6ICdmbG9hdCcgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0sXHJcbiAgICAgIHtcclxuICAgICAgICBrZXJuZWw6IGZyb21WZWhpY2xlUGF0aENvc3RzS2VybmVsKCdxdWludGljJyksXHJcbiAgICAgICAgb3V0cHV0OiB7IG5hbWU6ICdxdWludGljUGF0aEZyb21WZWhpY2xlQ29zdHMnIH0sXHJcbiAgICAgICAgdW5pZm9ybXM6IE9iamVjdC5hc3NpZ24oe30sIFNIQVJFRF9VTklGT1JNUywge1xyXG4gICAgICAgICAgbGF0dGljZTogeyB0eXBlOiAnc2hhcmVkVGV4dHVyZScgfSxcclxuICAgICAgICAgIHBhdGhzRnJvbVZlaGljbGU6IHsgdHlwZTogJ291dHB1dFRleHR1cmUnLCBuYW1lOiAncXVpbnRpY1BhdGhzRnJvbVZlaGljbGUnIH0sXHJcbiAgICAgICAgICBmaXJzdExhdHRpY2VQb2ludDogeyB0eXBlOiAnaW50JyB9LFxyXG4gICAgICAgICAgc2Vjb25kTGF0dGljZVBvaW50OiB7IHR5cGU6ICdpbnQnIH0sXHJcbiAgICAgICAgICB2ZWxvY2l0eVZlaGljbGU6IHsgdHlwZTogJ2Zsb2F0JyB9LFxyXG4gICAgICAgICAgY3VydlZlaGljbGU6IHsgdHlwZTogJ2Zsb2F0JyB9LFxyXG4gICAgICAgICAgZEN1cnZWZWhpY2xlOiB7IHR5cGU6ICdmbG9hdCcgfSxcclxuICAgICAgICAgIGRkQ3VydlZlaGljbGU6IHsgdHlwZTogJ2Zsb2F0JyB9LFxyXG4gICAgICAgICAgbnVtQWNjZWxlcmF0aW9uczogeyB0eXBlOiAnaW50JyB9LFxyXG4gICAgICAgICAgaHlzdGVyZXNpc0Rpc2NvdW50OiB7IHR5cGU6ICdmbG9hdCcgfSxcclxuICAgICAgICAgIGFjY2VsZXJhdGlvbkNoYW5nZVBlbmFsdHk6IHsgdHlwZTogJ2Zsb2F0JyB9XHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG4gICAgXTtcclxuICB9LFxyXG5cclxuICB1cGRhdGUoY29uZmlnLCBwb3NlLCB4eUNlbnRlclBvaW50LCBzbENlbnRlclBvaW50LCBmaXJzdExhdHRpY2VQb2ludCwgc2Vjb25kTGF0dGljZVBvaW50LCBkeW5hbWljRnJhbWVUaW1lKSB7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICB7XHJcbiAgICAgICAgd2lkdGg6IGNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcyxcclxuICAgICAgICBoZWlnaHQ6IGNvbmZpZy5sYXR0aWNlLnN0YXRpb25Db25uZWN0aXZpdHkgKiBOVU1fQUNDRUxFUkFUSU9OX1BST0ZJTEVTLFxyXG4gICAgICAgIHVuaWZvcm1zOiBPYmplY3QuYXNzaWduKHt9LCBidWlsZFVuaWZvcm1WYWx1ZXMoY29uZmlnLCB4eUNlbnRlclBvaW50LCBzbENlbnRlclBvaW50LCBkeW5hbWljRnJhbWVUaW1lKSwge1xyXG4gICAgICAgICAgZmlyc3RMYXR0aWNlUG9pbnQ6IGZpcnN0TGF0dGljZVBvaW50LFxyXG4gICAgICAgICAgc2Vjb25kTGF0dGljZVBvaW50OiBzZWNvbmRMYXR0aWNlUG9pbnQsXHJcbiAgICAgICAgICB2ZWxvY2l0eVZlaGljbGU6IHBvc2UudmVsb2NpdHksXHJcbiAgICAgICAgICBjdXJ2VmVoaWNsZTogcG9zZS5jdXJ2LFxyXG4gICAgICAgICAgbnVtQWNjZWxlcmF0aW9uczogTlVNX0FDQ0VMRVJBVElPTl9QUk9GSUxFUyxcclxuICAgICAgICAgIGN1YmljUGF0aFBlbmFsdHk6IGNvbmZpZy5jdWJpY1BhdGhQZW5hbHR5LFxyXG4gICAgICAgICAgaHlzdGVyZXNpc0Rpc2NvdW50OiBjb25maWcuaHlzdGVyZXNpc0Rpc2NvdW50LFxyXG4gICAgICAgICAgYWNjZWxlcmF0aW9uQ2hhbmdlUGVuYWx0eTogY29uZmlnLmFjY2VsZXJhdGlvbkNoYW5nZVBlbmFsdHlcclxuICAgICAgICB9KVxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgd2lkdGg6IGNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcyxcclxuICAgICAgICBoZWlnaHQ6IGNvbmZpZy5sYXR0aWNlLnN0YXRpb25Db25uZWN0aXZpdHkgKiBOVU1fQUNDRUxFUkFUSU9OX1BST0ZJTEVTLFxyXG4gICAgICAgIHVuaWZvcm1zOiBPYmplY3QuYXNzaWduKHt9LCBidWlsZFVuaWZvcm1WYWx1ZXMoY29uZmlnLCB4eUNlbnRlclBvaW50LCBzbENlbnRlclBvaW50LCBkeW5hbWljRnJhbWVUaW1lKSwge1xyXG4gICAgICAgICAgZmlyc3RMYXR0aWNlUG9pbnQ6IGZpcnN0TGF0dGljZVBvaW50LFxyXG4gICAgICAgICAgc2Vjb25kTGF0dGljZVBvaW50OiBzZWNvbmRMYXR0aWNlUG9pbnQsXHJcbiAgICAgICAgICB2ZWxvY2l0eVZlaGljbGU6IHBvc2UudmVsb2NpdHksXHJcbiAgICAgICAgICBjdXJ2VmVoaWNsZTogcG9zZS5jdXJ2LFxyXG4gICAgICAgICAgZEN1cnZWZWhpY2xlOiBwb3NlLmRDdXJ2LFxyXG4gICAgICAgICAgZGRDdXJ2VmVoaWNsZTogcG9zZS5kZEN1cnYsXHJcbiAgICAgICAgICBudW1BY2NlbGVyYXRpb25zOiBOVU1fQUNDRUxFUkFUSU9OX1BST0ZJTEVTLFxyXG4gICAgICAgICAgaHlzdGVyZXNpc0Rpc2NvdW50OiBjb25maWcuaHlzdGVyZXNpc0Rpc2NvdW50LFxyXG4gICAgICAgICAgYWNjZWxlcmF0aW9uQ2hhbmdlUGVuYWx0eTogY29uZmlnLmFjY2VsZXJhdGlvbkNoYW5nZVBlbmFsdHlcclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcbiAgICBdO1xyXG4gIH1cclxufVxyXG4iLCIvKiBTdGF0ZSBMYXR0aWNlIENvc3QgTWFwXHJcbiAqIFxyXG4gKiA1LWRpbWVuc2lvbmFsIG5vZGU6IHN0YXRpb24sIGxhdGl0dWRlLCBhY2NlbGVyYXRpb24gcHJvZmlsZSwgdmVsb2NpdHksIHRpbWVcclxuICpcclxuICogQSBkcmF3IGNhbGwgcGVyIHN0YXRpb24gc1xyXG4gKiAgICogSW5wdXQgdG8ga2VybmVsOiBsYXRpdHVkZSBsLCBhY2NlbGVyYXRpb24gcHJvZmlsZSBhLCB2ZWxvY2l0eSByYW5nZSB2LCB0aW1lIHJhbmdlIHRcclxuICogICAqIEZpbmQgYWxsIFNMIHZlcnRpY2VzIHRoYXQgY2FuIGNvbm5lY3QgdG8gdGhpcyBub2RlXHJcbiAqICAgKiBGb3IgZWFjaCBvZiB0aG9zZSB2ZXJ0aWNlcywgY2hlY2sgaWYgYW55IHRlcm1pbmF0ZSBpbiB0aGlzIHNwZWNpZmljIHZlbG9jaXR5IGFuZCB0aW1lIHJhbmdlXHJcbiAqICAgICAqIEJhc2VkIG9uIGluaXRpYWwgdmVsb2NpdHksIGluaXRpYWwgdGltZSwgYW5kIGFjY2VsZXJhdGlvblxyXG4gKiAgICAgKiBFYWNoIGNvbm5lY3RlZCBTTCB2ZXJ0ZXggc2hvdWxkIGhhdmUgYSAqIHYgKiB0IG5vZGVzIHRoYXQgY291bGQgcG9zc2libHkgdGVybWluYXRlIGF0IHRoaXMgbm9kZVxyXG4gKiAgICogRm9yIGFsbCB2YWxpZCBlZGdlcywgZmluZCB0aGUgb25lIHdpdGggdGhlIGxvd2VzdCBjb3N0XHJcbiAqXHJcbiAqIElucHV0OlxyXG4gKiAgICogMkQgdGV4dHVyZSBhcnJheSBjb3N0IG1hcFxyXG4gKiAgICAgKiBIZWlnaHQ6IG51bSBvZiBsYXRpdHVkZXMgKH4yMClcclxuICogICAgICogV2lkdGg6IG51bSBvZiBhY2NlbGVyYXRpb24gcHJvZmlsZXMgKiBudW0gb2YgdGltZSByYW5nZXMgKiBudW0gb2YgdmVsb2NpdHkgcmFuZ2VzICg4ICogMiAqIDQgPSB+NjQpXHJcbiAqICAgICAgICogQSBmbGF0dGVuZWQgM0QgYXJyYXk6XHJcbiAqICAgICAgICAgZDE6IGFjY2VsZXJhdGlvblxyXG4gKiAgICAgICAgIGQyOiB2ZWxvY2l0eVxyXG4gKiAgICAgICAgIGQzOiB0aW1lXHJcbiAqICAgICAqIExheWVyOiBudW0gb2Ygc3RhdGlvbnMgKH4xMClcclxuICogICBcclxuICogT3V0cHV0OlxyXG4gKiAgICogMkQgdGV4dHVyZSBzbGljZSBvZiB0aGUgbmV4dCBzdGF0aW9uIGluIHRoZSBpbnB1dCAyRCB0ZXh0dXJlIGFycmF5IGNvc3QgbWFwXHJcbiAqXHJcbiAqIENvc3QgTWFwIEVsZW1lbnRzOlxyXG4gKiAgICogVHJhdmVyc2FsIGNvc3Qgc28gZmFyXHJcbiAqICAgKiBFbmRpbmcgdmVsb2NpdHlcclxuICogICAqIEVuZGluZyB0aW1lXHJcbiAqICAgKiBJbmRleCBvZiBwYXJlbnQgbm9kZVxyXG4gKlxyXG4gKiBTaW5jZSBvbmUgY3ViaWMgcGF0aCBjYW4gYmUgc2hhcmVkIGJldHdlZW4gbXVsdGlwbGUgdHJhamVjdG9yaWVzLCB0aGV5IG5lZWQgdG8gYmUgcHJlLW9wdGltaXplZC5cclxuICpcclxuICogUXVpbnRpYyBQYXRoczpcclxuICogICBTdGF0aW9ucyAwIHRocm91Z2ggKG51bVN0YXRpb25zIC0gMSkgY29ycmVzcG9uZCB0byB0aGUgc3RhdGlvbnMgb24gdGhlIGxhdHRpY2U7IGhvd2V2ZXIsXHJcbiAqICAgYSBuZXcgc3RhdGlvbiAoc3RhdGlvbiAtMSkgd2lsbCBiZSB1c2VkIHRvIHNpZ25pZml5IHRoZSBzaW5nbGUgdmVoaWNsZSBwb3NlIG5vZGUuIEVpdGhlclxyXG4gKiAgIGEgY3ViaWMgcGF0aCBvciBxdWludGljIHBhdGggY2FuIGJlIHVzZWQgdG8gY29ubmVjdCB0aGlzIHNpbmdsZSBub2RlIHRvIHRoZSBsYXR0aWNlXHJcbiAqICAgKGRlcGVuZGluZyBvbiB2ZWhpY2xlIHZlbG9jaXR5KS4gQXQgc3RhdGlvbiAtMSwgbGF0aXR1ZGUgMCB3aWxsIGNvcnJlc3BvbmQgdG8gYSBjdWJpYyBwYXRoLFxyXG4gKiAgIGFuZCBsYXRpdHVkZSAxIHdpbGwgY29ycmVzcG9uZCB0byBhIHF1aW50aWMgcGF0aC4gQWxsIG90aGVyIGxhdGl0dWRlcyB3aWxsIGJlIHNraXBwZWQuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgU0hBUkVEX1NIQURFUiwgU0FNUExFX0NVQklDX1BBVEhfRk4sIFNBTVBMRV9RVUlOVElDX1BBVEhfRk4sIE5VTV9BQ0NFTEVSQVRJT05fUFJPRklMRVMsIE5VTV9WRUxPQ0lUWV9SQU5HRVMsIE5VTV9USU1FX1JBTkdFUywgU0hBUkVEX1VOSUZPUk1TLCBidWlsZFVuaWZvcm1WYWx1ZXMgfSBmcm9tIFwiLi9ncmFwaFNlYXJjaFNoYXJlZC5qc1wiO1xyXG5cclxuY29uc3QgU09MVkVfU1RBVElPTl9LRVJORUwgPVxyXG4gIFNIQVJFRF9TSEFERVIgK1xyXG4gIFNBTVBMRV9DVUJJQ19QQVRIX0ZOICtcclxuICBTQU1QTEVfUVVJTlRJQ19QQVRIX0ZOICtcclxuXHJcbmBcclxuXHJcbnZlYzQga2VybmVsKCkge1xyXG4gIGl2ZWMyIGluZGV4ZXMgPSBpdmVjMihrZXJuZWxQb3NpdGlvbiAqIHZlYzIoa2VybmVsU2l6ZSkpO1xyXG5cclxuICBpbnQgbGF0aXR1ZGUgPSBpbmRleGVzLnk7XHJcblxyXG4gIGludCBudW1QZXJUaW1lID0gbnVtQWNjZWxlcmF0aW9ucyAqIG51bVZlbG9jaXRpZXM7XHJcbiAgaW50IHRpbWVJbmRleCA9IGluZGV4ZXMueCAvIG51bVBlclRpbWU7XHJcbiAgaW5kZXhlcy54IC09IHRpbWVJbmRleCAqIG51bVBlclRpbWU7XHJcbiAgaW50IHZlbG9jaXR5SW5kZXggPSBpbmRleGVzLnggLyBudW1BY2NlbGVyYXRpb25zO1xyXG4gIGludCBhY2NlbGVyYXRpb25JbmRleCA9IGludChtb2QoZmxvYXQoaW5kZXhlcy54KSwgZmxvYXQobnVtQWNjZWxlcmF0aW9ucykpKTtcclxuXHJcbiAgaW50IG1pbkxhdGl0dWRlID0gbWF4KGxhdGl0dWRlIC0gbGF0aXR1ZGVDb25uZWN0aXZpdHkgLyAyLCAwKTtcclxuICBpbnQgbWF4TGF0aXR1ZGUgPSBtaW4obGF0aXR1ZGUgKyBsYXRpdHVkZUNvbm5lY3Rpdml0eSAvIDIsIG51bUxhdGl0dWRlcyAtIDEpO1xyXG5cclxuICBpbnQgc2xJbmRleCA9IHN0YXRpb24gKiBudW1MYXRpdHVkZXMgKyBsYXRpdHVkZTtcclxuXHJcbiAgdmVjNCBwYXRoRW5kID0gdGV4ZWxGZXRjaChsYXR0aWNlLCBpdmVjMihsYXRpdHVkZSwgc3RhdGlvbiksIDApO1xyXG5cclxuICBmbG9hdCBtaW5WZWxvY2l0eSA9IHZlbG9jaXR5UmFuZ2VzW3ZlbG9jaXR5SW5kZXhdO1xyXG4gIGZsb2F0IG1heFZlbG9jaXR5ID0gdmVsb2NpdHlSYW5nZXNbdmVsb2NpdHlJbmRleCArIDFdO1xyXG5cclxuICBmbG9hdCBtaW5UaW1lID0gdGltZVJhbmdlc1t0aW1lSW5kZXhdO1xyXG4gIGZsb2F0IG1heFRpbWUgPSB0aW1lUmFuZ2VzW3RpbWVJbmRleCArIDFdO1xyXG5cclxuICB2ZWM0IGJlc3RUcmFqZWN0b3J5ID0gdmVjNCgtMSk7IC8vIC0xIG1lYW5zIGluZmluaXRlIGNvc3RcclxuICBmbG9hdCBiZXN0VGVybWluYWxDb3N0ID0gMS4wIC8gMC4wO1xyXG5cclxuICBmbG9hdCBoeXN0ZXJlc2lzQWRqdXN0bWVudCA9IChzbEluZGV4ID09IGZpcnN0TGF0dGljZVBvaW50IHx8IHNsSW5kZXggPT0gc2Vjb25kTGF0dGljZVBvaW50KSA/ICAwLjAgOiBoeXN0ZXJlc2lzRGlzY291bnQ7XHJcblxyXG4gIGZvciAoaW50IHByZXZTdGF0aW9uID0gbWF4KHN0YXRpb24gLSBzdGF0aW9uQ29ubmVjdGl2aXR5LCAwKTsgcHJldlN0YXRpb24gPCBzdGF0aW9uOyBwcmV2U3RhdGlvbisrKSB7XHJcbiAgICBpbnQgc3RhdGlvbkNvbm5lY3Rpdml0eUluZGV4ID0gcHJldlN0YXRpb24gLSBzdGF0aW9uICsgc3RhdGlvbkNvbm5lY3Rpdml0eTtcclxuXHJcbiAgICBmb3IgKGludCBwcmV2TGF0aXR1ZGUgPSBtaW5MYXRpdHVkZTsgcHJldkxhdGl0dWRlIDw9IG1heExhdGl0dWRlOyBwcmV2TGF0aXR1ZGUrKykge1xyXG4gICAgICBpbnQgbGF0aXR1ZGVDb25uZWN0aXZpdHlJbmRleCA9IHByZXZMYXRpdHVkZSAtIGxhdGl0dWRlICsgbGF0aXR1ZGVDb25uZWN0aXZpdHkgLyAyO1xyXG4gICAgICBpbnQgY29ubmVjdGl2aXR5SW5kZXggPSBzdGF0aW9uQ29ubmVjdGl2aXR5SW5kZXggKiBsYXRpdHVkZUNvbm5lY3Rpdml0eSArIGxhdGl0dWRlQ29ubmVjdGl2aXR5SW5kZXg7XHJcblxyXG4gICAgICB2ZWM0IHBhdGhTdGFydCA9IHRleGVsRmV0Y2gobGF0dGljZSwgaXZlYzIocHJldkxhdGl0dWRlLCBwcmV2U3RhdGlvbiksIDApO1xyXG4gICAgICB2ZWM0IGN1YmljUGF0aFBhcmFtcyA9IHRleGVsRmV0Y2goY3ViaWNQYXRocywgaXZlYzIoc2xJbmRleCwgY29ubmVjdGl2aXR5SW5kZXgpLCAwKTtcclxuXHJcbiAgICAgIC8vIElmIHRoZSBwYXRoIGRpZG4ndCBjb252ZXJnZVxyXG4gICAgICBpZiAoY3ViaWNQYXRoUGFyYW1zLncgPT0gMC4wKSBjb250aW51ZTtcclxuXHJcbiAgICAgIGludCBudW1TYW1wbGVzID0gc2FtcGxlQ3ViaWNQYXRoKHBhdGhTdGFydCwgcGF0aEVuZCwgY3ViaWNQYXRoUGFyYW1zKTtcclxuICAgICAgZmxvYXQgcGF0aExlbmd0aCA9IGN1YmljUGF0aFBhcmFtcy56O1xyXG5cclxuICAgICAgaWYgKG51bVNhbXBsZXMgPCAyKSBjb250aW51ZTtcclxuXHJcbiAgICAgIGZsb2F0IGF2ZXJhZ2VTdGF0aWNDb3N0ID0gY2FsY3VsYXRlQXZlcmFnZVN0YXRpY0Nvc3QobnVtU2FtcGxlcyk7XHJcbiAgICAgIGlmIChhdmVyYWdlU3RhdGljQ29zdCA8IDAuMCkgY29udGludWU7XHJcblxyXG4gICAgICBhdmVyYWdlU3RhdGljQ29zdCArPSBoeXN0ZXJlc2lzQWRqdXN0bWVudDtcclxuXHJcbiAgICAgIGlmIChhdmVyYWdlU3RhdGljQ29zdCAqIHBhdGhMZW5ndGggPj0gYmVzdFRlcm1pbmFsQ29zdCkgY29udGludWU7XHJcblxyXG4gICAgICBmb3IgKGludCBwcmV2VmVsb2NpdHkgPSAwOyBwcmV2VmVsb2NpdHkgPCBudW1WZWxvY2l0aWVzOyBwcmV2VmVsb2NpdHkrKykge1xyXG4gICAgICAgIGZvciAoaW50IHByZXZUaW1lID0gMDsgcHJldlRpbWUgPCBudW1UaW1lczsgcHJldlRpbWUrKykge1xyXG4gICAgICAgICAgZm9yIChpbnQgcHJldkFjY2VsID0gMDsgcHJldkFjY2VsIDwgbnVtQWNjZWxlcmF0aW9uczsgcHJldkFjY2VsKyspIHtcclxuICAgICAgICAgICAgaW50IGF2dEluZGV4ID0gcHJldlRpbWUgKiBudW1QZXJUaW1lICsgcHJldlZlbG9jaXR5ICogbnVtQWNjZWxlcmF0aW9ucyArIHByZXZBY2NlbDtcclxuXHJcbiAgICAgICAgICAgIC8vIENvc3QgdGFibGUgZW50cnk6XHJcbiAgICAgICAgICAgIC8vICAgeDogY29zdCBzbyBmYXJcclxuICAgICAgICAgICAgLy8gICB5OiBlbmQgdmVsb2NpdHlcclxuICAgICAgICAgICAgLy8gICB6OiBlbmQgdGltZVxyXG4gICAgICAgICAgICAvLyAgIHc6IHBhcmVudCBpbmRleFxyXG4gICAgICAgICAgICB2ZWM0IGNvc3RUYWJsZUVudHJ5ID0gdGV4ZWxGZXRjaChjb3N0VGFibGUsIGl2ZWMzKGF2dEluZGV4LCBwcmV2TGF0aXR1ZGUsIHByZXZTdGF0aW9uKSwgMCk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBjb3N0IGVudHJ5IGlzIGluZmluaXR5XHJcbiAgICAgICAgICAgIGlmIChjb3N0VGFibGVFbnRyeS54IDwgMC4wIHx8IGF2ZXJhZ2VTdGF0aWNDb3N0ICogcGF0aExlbmd0aCArIGNvc3RUYWJsZUVudHJ5LnggPj0gYmVzdFRlcm1pbmFsQ29zdCkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICB2ZWMzIGF2dCA9IGNhbGN1bGF0ZUFWVChhY2NlbGVyYXRpb25JbmRleCwgY29zdFRhYmxlRW50cnkueSwgY29zdFRhYmxlRW50cnkueiwgcGF0aExlbmd0aCk7XHJcbiAgICAgICAgICAgIGZsb2F0IGFjY2VsZXJhdGlvbiA9IGF2dC54O1xyXG4gICAgICAgICAgICBmbG9hdCBmaW5hbFZlbG9jaXR5ID0gYXZ0Lnk7XHJcbiAgICAgICAgICAgIGZsb2F0IGZpbmFsVGltZSA9IGF2dC56O1xyXG5cclxuICAgICAgICAgICAgaWYgKGF2ZXJhZ2VTdGF0aWNDb3N0ICogcGF0aExlbmd0aCArIGNvc3RUYWJsZUVudHJ5LnggKyBleHRyYVRpbWVQZW5hbHR5ICogZmluYWxUaW1lID49IGJlc3RUZXJtaW5hbENvc3QpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlIGNhbGN1bGF0ZWQgZmluYWwgdmVsb2NpdHkgZG9lcyBub3QgbWF0Y2ggdGhpcyBmcmFnbWVudCdzIHZlbG9jaXR5IHJhbmdlLCB0aGVuIHNraXAgdGhpcyB0cmFqZWN0b3J5XHJcbiAgICAgICAgICAgIGlmIChmaW5hbFZlbG9jaXR5IDwgbWluVmVsb2NpdHkgfHwgZmluYWxWZWxvY2l0eSA+PSBtYXhWZWxvY2l0eSkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB0aGUgY2FsY3VsYXRlZCBmaW5hbCB0aW1lIGRvZXMgbm90IG1hdGNoIHRoaXMgZnJhZ21lbnQncyB0aW1lIHJhbmdlLCB0aGVuIHNraXAgdGhpcyB0cmFqZWN0b3J5XHJcbiAgICAgICAgICAgIGlmIChmaW5hbFRpbWUgPCBtaW5UaW1lIHx8IGZpbmFsVGltZSA+PSBtYXhUaW1lKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IGFiYW5kb25UaHJlc2hvbGQgPSAoYmVzdFRlcm1pbmFsQ29zdCAtIGV4dHJhVGltZVBlbmFsdHkgKiBmaW5hbFRpbWUgLSBjb3N0VGFibGVFbnRyeS54KSAvIHBhdGhMZW5ndGggLSBhdmVyYWdlU3RhdGljQ29zdDtcclxuICAgICAgICAgICAgZmxvYXQgYXZlcmFnZUR5bmFtaWNDb3N0ID0gY2FsY3VsYXRlQXZlcmFnZUR5bmFtaWNDb3N0KG51bVNhbXBsZXMsIHBhdGhMZW5ndGgsIGNvc3RUYWJsZUVudHJ5LnosIGNvc3RUYWJsZUVudHJ5LnksIGFjY2VsZXJhdGlvbiwgYWJhbmRvblRocmVzaG9sZCk7XHJcbiAgICAgICAgICAgIGlmIChhdmVyYWdlRHluYW1pY0Nvc3QgPCAwLjApIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKGFjY2VsZXJhdGlvbkluZGV4ICE9IHByZXZBY2NlbClcclxuICAgICAgICAgICAgICBhdmVyYWdlRHluYW1pY0Nvc3QgKz0gYWNjZWxlcmF0aW9uQ2hhbmdlUGVuYWx0eTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBjb3N0IG9mIGEgdHJhamVjdG9yeSBpcyB0aGUgYXZlcmFnZSBzYW1wbGUgY29zdCBzY2FsZWQgYnkgdGhlIHBhdGggbGVuZ3RoXHJcbiAgICAgICAgICAgIGZsb2F0IHRvdGFsQ29zdCA9IChhdmVyYWdlU3RhdGljQ29zdCArIGF2ZXJhZ2VEeW5hbWljQ29zdCkgKiBwYXRoTGVuZ3RoICsgY29zdFRhYmxlRW50cnkueDtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IHRlcm1pbmFsQ29zdCA9IHRvdGFsQ29zdCArIGV4dHJhVGltZVBlbmFsdHkgKiBmaW5hbFRpbWU7XHJcbiAgICAgICAgICAgIGlmICh0ZXJtaW5hbENvc3QgPj0gYmVzdFRlcm1pbmFsQ29zdCkgY29udGludWU7XHJcbiAgICAgICAgICAgIGJlc3RUZXJtaW5hbENvc3QgPSB0ZXJtaW5hbENvc3Q7XHJcblxyXG4gICAgICAgICAgICBpbnQgaW5jb21pbmdJbmRleCA9IGF2dEluZGV4ICsgbnVtUGVyVGltZSAqIG51bVRpbWVzICogKHByZXZMYXRpdHVkZSArIG51bUxhdGl0dWRlcyAqIHByZXZTdGF0aW9uKTtcclxuICAgICAgICAgICAgYmVzdFRyYWplY3RvcnkgPSB2ZWM0KHRvdGFsQ29zdCwgZmluYWxWZWxvY2l0eSwgZmluYWxUaW1lLCBpbmNvbWluZ0luZGV4KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChzdGF0aW9uIDwgc3RhdGlvbkNvbm5lY3Rpdml0eSkge1xyXG4gICAgaXZlYzIgc2xhSW5kZXggPSBpdmVjMihsYXRpdHVkZSwgc3RhdGlvbiAqIG51bUFjY2VsZXJhdGlvbnMgKyBhY2NlbGVyYXRpb25JbmRleCk7XHJcblxyXG4gICAgdmVjNCBjb3N0VGFibGVFbnRyeSA9IHRleGVsRmV0Y2goY3ViaWNQYXRoRnJvbVZlaGljbGVDb3N0cywgc2xhSW5kZXgsIDApO1xyXG4gICAgZmxvYXQgdGVybWluYWxDb3N0O1xyXG5cclxuICAgIGlmIChjb3N0VGFibGVFbnRyeS54ID49IDAuMCkge1xyXG4gICAgICB0ZXJtaW5hbENvc3QgPSBjb3N0VGFibGVFbnRyeS54ICsgZXh0cmFUaW1lUGVuYWx0eSAqIGNvc3RUYWJsZUVudHJ5Lno7XHJcblxyXG4gICAgICBpZiAodGVybWluYWxDb3N0IDwgYmVzdFRlcm1pbmFsQ29zdCkge1xyXG4gICAgICAgIGJlc3RUZXJtaW5hbENvc3QgPSB0ZXJtaW5hbENvc3Q7XHJcbiAgICAgICAgYmVzdFRyYWplY3RvcnkgPSBjb3N0VGFibGVFbnRyeTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvc3RUYWJsZUVudHJ5ID0gdGV4ZWxGZXRjaChxdWludGljUGF0aEZyb21WZWhpY2xlQ29zdHMsIHNsYUluZGV4LCAwKTtcclxuXHJcbiAgICBpZiAoY29zdFRhYmxlRW50cnkueCA+PSAwLjApIHtcclxuICAgICAgdGVybWluYWxDb3N0ID0gY29zdFRhYmxlRW50cnkueCArIGV4dHJhVGltZVBlbmFsdHkgKiBjb3N0VGFibGVFbnRyeS56O1xyXG5cclxuICAgICAgaWYgKHRlcm1pbmFsQ29zdCA8IGJlc3RUZXJtaW5hbENvc3QpIHtcclxuICAgICAgICBiZXN0VGVybWluYWxDb3N0ID0gdGVybWluYWxDb3N0O1xyXG4gICAgICAgIGJlc3RUcmFqZWN0b3J5ID0gY29zdFRhYmxlRW50cnk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBiZXN0VHJhamVjdG9yeTtcclxufVxyXG5cclxuYDtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBzZXRVcCgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGtlcm5lbDogU09MVkVfU1RBVElPTl9LRVJORUwsXHJcbiAgICAgIG91dHB1dDogeyBuYW1lOiAnZ3JhcGhTZWFyY2gnIH0sXHJcbiAgICAgIHVuaWZvcm1zOiBPYmplY3QuYXNzaWduKHt9LCBTSEFSRURfVU5JRk9STVMsIHtcclxuICAgICAgICBsYXR0aWNlOiB7IHR5cGU6ICdzaGFyZWRUZXh0dXJlJyB9LFxyXG4gICAgICAgIGNvc3RUYWJsZTogeyB0eXBlOiAnc2hhcmVkVGV4dHVyZScsIHRleHR1cmVUeXBlOiAnMkRBcnJheScgfSxcclxuICAgICAgICBjdWJpY1BhdGhzOiB7IHR5cGU6ICdvdXRwdXRUZXh0dXJlJyB9LFxyXG4gICAgICAgIGN1YmljUGF0aEZyb21WZWhpY2xlQ29zdHM6IHsgdHlwZTogJ291dHB1dFRleHR1cmUnIH0sXHJcbiAgICAgICAgcXVpbnRpY1BhdGhGcm9tVmVoaWNsZUNvc3RzOiB7IHR5cGU6ICdvdXRwdXRUZXh0dXJlJyB9LFxyXG4gICAgICAgIGZpcnN0TGF0dGljZVBvaW50OiB7IHR5cGU6ICdpbnQnIH0sXHJcbiAgICAgICAgc2Vjb25kTGF0dGljZVBvaW50OiB7IHR5cGU6ICdpbnQnIH0sXHJcbiAgICAgICAgdmVsb2NpdHlWZWhpY2xlOiB7IHR5cGU6ICdmbG9hdCcgfSxcclxuICAgICAgICBjdXJ2VmVoaWNsZTogeyB0eXBlOiAnZmxvYXQnIH0sXHJcbiAgICAgICAgZEN1cnZWZWhpY2xlOiB7IHR5cGU6ICdmbG9hdCcgfSxcclxuICAgICAgICBkZEN1cnZWZWhpY2xlOiB7IHR5cGU6ICdmbG9hdCcgfSxcclxuICAgICAgICBleHRyYVRpbWVQZW5hbHR5OiB7IHR5cGU6ICdmbG9hdCcgfSxcclxuICAgICAgICBoeXN0ZXJlc2lzRGlzY291bnQ6IHsgdHlwZTogJ2Zsb2F0JyB9LFxyXG4gICAgICAgIGFjY2VsZXJhdGlvbkNoYW5nZVBlbmFsdHk6IHsgdHlwZTogJ2Zsb2F0JyB9LFxyXG4gICAgICAgIG51bVN0YXRpb25zOiB7IHR5cGU6ICdpbnQnIH0sXHJcbiAgICAgICAgbnVtTGF0aXR1ZGVzOiB7IHR5cGU6ICdpbnQnIH0sXHJcbiAgICAgICAgbnVtQWNjZWxlcmF0aW9uczogeyB0eXBlOiAnaW50JyB9LFxyXG4gICAgICAgIG51bVZlbG9jaXRpZXM6IHsgdHlwZTogJ2ludCcgfSxcclxuICAgICAgICBudW1UaW1lczogeyB0eXBlOiAnaW50JyB9LFxyXG4gICAgICAgIHN0YXRpb25Db25uZWN0aXZpdHk6IHsgdHlwZTogJ2ludCcgfSxcclxuICAgICAgICBsYXRpdHVkZUNvbm5lY3Rpdml0eTogeyB0eXBlOiAnaW50JyB9LFxyXG4gICAgICAgIHZlbG9jaXR5UmFuZ2VzOiB7IHR5cGU6ICdmbG9hdCcsIGxlbmd0aDogTlVNX1ZFTE9DSVRZX1JBTkdFUyArIDEgfSxcclxuICAgICAgICB0aW1lUmFuZ2VzOiB7IHR5cGU6ICdmbG9hdCcsIGxlbmd0aDogTlVNX1RJTUVfUkFOR0VTICsgMSB9LFxyXG4gICAgICAgIHN0YXRpb246IHsgdHlwZTogJ2ludCcgfSAvLyBVcGRhdGVkIGluIGBkcmF3UHJveHlgXHJcbiAgICAgIH0pLFxyXG4gICAgICBkcmF3UHJveHk6IChncGdwdSwgcHJvZ3JhbSwgZHJhdykgPT4ge1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gTlVNX0FDQ0VMRVJBVElPTl9QUk9GSUxFUyAqIE5VTV9WRUxPQ0lUWV9SQU5HRVMgKiBOVU1fVElNRV9SQU5HRVM7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gcHJvZ3JhbS5tZXRhLmxhdHRpY2UubnVtTGF0aXR1ZGVzO1xyXG4gICAgICAgIGNvbnN0IGNvc3RUYWJsZSA9IG5ldyBGbG9hdDMyQXJyYXkod2lkdGggKiBoZWlnaHQgKiBwcm9ncmFtLm1ldGEubGF0dGljZS5udW1TdGF0aW9ucyAqIDQpO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IHByb2dyYW0ubWV0YS5sYXR0aWNlLm51bVN0YXRpb25zOyBzKyspIHtcclxuICAgICAgICAgIGdwZ3B1LnVwZGF0ZVByb2dyYW1Vbmlmb3Jtcyhwcm9ncmFtLCB7IHN0YXRpb246IHMgfSk7XHJcbiAgICAgICAgICBkcmF3KCk7XHJcblxyXG4gICAgICAgICAgZ3BncHUuZ2wucmVhZFBpeGVscygwLCAwLCB3aWR0aCwgaGVpZ2h0LCBncGdwdS5nbC5SR0JBLCBncGdwdS5nbC5GTE9BVCwgY29zdFRhYmxlLCBzICogd2lkdGggKiBoZWlnaHQgKiA0KTtcclxuXHJcbiAgICAgICAgICBncGdwdS5nbC5iaW5kVGV4dHVyZShncGdwdS5nbC5URVhUVVJFXzJEX0FSUkFZLCBncGdwdS5zaGFyZWRUZXh0dXJlcy5jb3N0VGFibGUpO1xyXG4gICAgICAgICAgZ3BncHUuZ2wuY29weVRleFN1YkltYWdlM0QoZ3BncHUuZ2wuVEVYVFVSRV8yRF9BUlJBWSwgMCwgMCwgMCwgcywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBncGdwdS5fZ3JhcGhTZWFyY2hDb3N0VGFibGUgPSBjb3N0VGFibGU7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSxcclxuXHJcbiAgdXBkYXRlKGNvbmZpZywgcG9zZSwgeHlDZW50ZXJQb2ludCwgc2xDZW50ZXJQb2ludCwgZmlyc3RMYXR0aWNlUG9pbnQsIHNlY29uZExhdHRpY2VQb2ludCwgZHluYW1pY0ZyYW1lVGltZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgd2lkdGg6IE5VTV9BQ0NFTEVSQVRJT05fUFJPRklMRVMgKiBOVU1fVkVMT0NJVFlfUkFOR0VTICogTlVNX1RJTUVfUkFOR0VTLFxyXG4gICAgICBoZWlnaHQ6IGNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcyxcclxuICAgICAgbWV0YToge1xyXG4gICAgICAgIGxhdHRpY2U6IGNvbmZpZy5sYXR0aWNlXHJcbiAgICAgIH0sXHJcbiAgICAgIHVuaWZvcm1zOiBPYmplY3QuYXNzaWduKHt9LCBidWlsZFVuaWZvcm1WYWx1ZXMoY29uZmlnLCB4eUNlbnRlclBvaW50LCBzbENlbnRlclBvaW50LCBkeW5hbWljRnJhbWVUaW1lKSwge1xyXG4gICAgICAgIGZpcnN0TGF0dGljZVBvaW50OiBmaXJzdExhdHRpY2VQb2ludCxcclxuICAgICAgICBzZWNvbmRMYXR0aWNlUG9pbnQ6IHNlY29uZExhdHRpY2VQb2ludCxcclxuICAgICAgICB2ZWxvY2l0eVZlaGljbGU6IHBvc2UudmVsb2NpdHksXHJcbiAgICAgICAgY3VydlZlaGljbGU6IHBvc2UuY3VydixcclxuICAgICAgICBkQ3VydlZlaGljbGU6IHBvc2UuZEN1cnYsXHJcbiAgICAgICAgZGRDdXJ2VmVoaWNsZTogcG9zZS5kZEN1cnYsXHJcbiAgICAgICAgZXh0cmFUaW1lUGVuYWx0eTogY29uZmlnLmV4dHJhVGltZVBlbmFsdHksXHJcbiAgICAgICAgaHlzdGVyZXNpc0Rpc2NvdW50OiBjb25maWcuaHlzdGVyZXNpc0Rpc2NvdW50LFxyXG4gICAgICAgIGFjY2VsZXJhdGlvbkNoYW5nZVBlbmFsdHk6IGNvbmZpZy5hY2NlbGVyYXRpb25DaGFuZ2VQZW5hbHR5LFxyXG4gICAgICAgIG51bVN0YXRpb25zOiBjb25maWcubGF0dGljZS5udW1TdGF0aW9ucyxcclxuICAgICAgICBudW1MYXRpdHVkZXM6IGNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcyxcclxuICAgICAgICBudW1BY2NlbGVyYXRpb25zOiBOVU1fQUNDRUxFUkFUSU9OX1BST0ZJTEVTLFxyXG4gICAgICAgIG51bVZlbG9jaXRpZXM6IE5VTV9WRUxPQ0lUWV9SQU5HRVMsXHJcbiAgICAgICAgbnVtVGltZXM6IE5VTV9USU1FX1JBTkdFUyxcclxuICAgICAgICBzdGF0aW9uQ29ubmVjdGl2aXR5OiBjb25maWcubGF0dGljZS5zdGF0aW9uQ29ubmVjdGl2aXR5LFxyXG4gICAgICAgIGxhdGl0dWRlQ29ubmVjdGl2aXR5OiBjb25maWcubGF0dGljZS5sYXRpdHVkZUNvbm5lY3Rpdml0eSxcclxuICAgICAgICB2ZWxvY2l0eVJhbmdlczogWzAsIGNvbmZpZy5zcGVlZExpbWl0IC8gMywgY29uZmlnLnNwZWVkTGltaXQgKiAyIC8gMywgY29uZmlnLnNwZWVkTGltaXQsIDEwMDAwMDBdLFxyXG4gICAgICAgIHRpbWVSYW5nZXM6IFswLCAxMCwgMTAwMDAwMF1cclxuICAgICAgfSlcclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiIsImNvbnN0IFhZX09CU1RBQ0xFX0NPU1RfS0VSTkVMID0gYFxyXG5cclxudmVjNCBrZXJuZWwoKSB7XHJcbiAgdmVjMiB4eSA9IChrZXJuZWxQb3NpdGlvbiAtIDAuNSkgKiB2ZWMyKGtlcm5lbFNpemUpICogdmVjMih4eUdyaWRDZWxsU2l6ZSkgKyB4eUNlbnRlclBvaW50O1xyXG5cclxuICB2ZWMyIHh5VGV4Q29vcmRzID0gKHh5IC0geHlDZW50ZXJQb2ludCkgLyB2ZWMyKHRleHR1cmVTaXplKHh5c2xNYXAsIDApKSAvIHZlYzIoeHlHcmlkQ2VsbFNpemUpICsgMC41O1xyXG4gIHZlYzIgc2wgPSB0ZXh0dXJlKHh5c2xNYXAsIHh5VGV4Q29vcmRzKS54eTtcclxuXHJcbiAgdmVjMiBzbFRleENvb3JkcyA9IChzbCAtIHNsQ2VudGVyUG9pbnQpIC8gdmVjMih0ZXh0dXJlU2l6ZShzbE9ic3RhY2xlR3JpZCwgMCkpIC8gdmVjMihzbEdyaWRDZWxsU2l6ZSkgKyAwLjU7XHJcbiAgcmV0dXJuIHRleHR1cmUoc2xPYnN0YWNsZUdyaWQsIHNsVGV4Q29vcmRzKTtcclxufVxyXG5cclxuYDtcclxuXHJcbi8vIEJ1aWxkIFhZIG9ic3RhY2xlIGNvc3RzIHVzaW5nIFhZU0wgbWFwXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBzZXRVcCgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGtlcm5lbDogWFlfT0JTVEFDTEVfQ09TVF9LRVJORUwsXHJcbiAgICAgIG91dHB1dDogeyBuYW1lOiAneHlPYnN0YWNsZUNvc3RHcmlkJywgcmVhZDogdHJ1ZSB9LFxyXG4gICAgICB1bmlmb3Jtczoge1xyXG4gICAgICAgIHh5c2xNYXA6IHsgdHlwZTogJ291dHB1dFRleHR1cmUnIH0sXHJcbiAgICAgICAgc2xPYnN0YWNsZUdyaWQ6IHsgdHlwZTogJ291dHB1dFRleHR1cmUnLCBuYW1lOiAnc2xPYnN0YWNsZUdyaWREaWxhdGVkJyB9LFxyXG4gICAgICAgIHh5Q2VudGVyUG9pbnQ6IHsgdHlwZTogJ3ZlYzInIH0sXHJcbiAgICAgICAgeHlHcmlkQ2VsbFNpemU6IHsgdHlwZTogJ2Zsb2F0J30sXHJcbiAgICAgICAgc2xDZW50ZXJQb2ludDogeyB0eXBlOiAndmVjMicgfSxcclxuICAgICAgICBzbEdyaWRDZWxsU2l6ZTogeyB0eXBlOiAnZmxvYXQnfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0sXHJcblxyXG4gIHVwZGF0ZShjb25maWcsIHh5V2lkdGgsIHh5SGVpZ2h0LCB4eUNlbnRlclBvaW50LCBzbENlbnRlclBvaW50KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB3aWR0aDogeHlXaWR0aCxcclxuICAgICAgaGVpZ2h0OiB4eUhlaWdodCxcclxuICAgICAgdW5pZm9ybXM6IHtcclxuICAgICAgICB4eUNlbnRlclBvaW50OiBbeHlDZW50ZXJQb2ludC54LCB4eUNlbnRlclBvaW50LnldLFxyXG4gICAgICAgIHh5R3JpZENlbGxTaXplOiBjb25maWcueHlHcmlkQ2VsbFNpemUsXHJcbiAgICAgICAgc2xDZW50ZXJQb2ludDogW3NsQ2VudGVyUG9pbnQueCwgc2xDZW50ZXJQb2ludC55XSxcclxuICAgICAgICBzbEdyaWRDZWxsU2l6ZTogY29uZmlnLnNsR3JpZENlbGxTaXplXHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBHUEdQVSBmcm9tIFwiLi4vLi4vR1BHUFUuanNcIjtcclxuaW1wb3J0IENhciBmcm9tIFwiLi4vLi4vcGh5c2ljcy9DYXIuanNcIjtcclxuaW1wb3J0IEN1YmljUGF0aCBmcm9tIFwiLi9DdWJpY1BhdGguanNcIjtcclxuaW1wb3J0IFF1aW50aWNQYXRoIGZyb20gXCIuL1F1aW50aWNQYXRoLmpzXCI7XHJcbmltcG9ydCB4eU9ic3RhY2xlR3JpZCBmcm9tIFwiLi9ncGdwdS1wcm9ncmFtcy94eU9ic3RhY2xlR3JpZC5qc1wiO1xyXG5pbXBvcnQgc2xPYnN0YWNsZUdyaWQgZnJvbSBcIi4vZ3BncHUtcHJvZ3JhbXMvc2xPYnN0YWNsZUdyaWQuanNcIjtcclxuaW1wb3J0IHNsT2JzdGFjbGVHcmlkRGlsYXRpb24gZnJvbSBcIi4vZ3BncHUtcHJvZ3JhbXMvc2xPYnN0YWNsZUdyaWREaWxhdGlvbi5qc1wiO1xyXG5pbXBvcnQgc2xEeW5hbWljT2JzdGFjbGVHcmlkIGZyb20gXCIuL2dwZ3B1LXByb2dyYW1zL3NsRHluYW1pY09ic3RhY2xlR3JpZC5qc1wiO1xyXG5pbXBvcnQgeHlzbE1hcCBmcm9tIFwiLi9ncGdwdS1wcm9ncmFtcy94eXNsTWFwLmpzXCI7XHJcbmltcG9ydCBvcHRpbWl6ZUN1YmljUGF0aHMgZnJvbSBcIi4vZ3BncHUtcHJvZ3JhbXMvb3B0aW1pemVDdWJpY1BhdGhzLmpzXCI7XHJcbmltcG9ydCBvcHRpbWl6ZVF1aW50aWNQYXRocyBmcm9tIFwiLi9ncGdwdS1wcm9ncmFtcy9vcHRpbWl6ZVF1aW50aWNQYXRocy5qc1wiO1xyXG5pbXBvcnQgcGF0aEZyb21WZWhpY2xlQ29zdHMgZnJvbSBcIi4vZ3BncHUtcHJvZ3JhbXMvcGF0aEZyb21WZWhpY2xlQ29zdHMuanNcIjtcclxuaW1wb3J0IGdyYXBoU2VhcmNoIGZyb20gXCIuL2dwZ3B1LXByb2dyYW1zL2dyYXBoU2VhcmNoLmpzXCI7XHJcbmltcG9ydCB4eU9ic3RhY2xlQ29zdEdyaWQgZnJvbSBcIi4vZ3BncHUtcHJvZ3JhbXMveHlPYnN0YWNsZUNvc3RHcmlkLmpzXCI7XHJcblxyXG5jb25zdCBOVU1fQUNDRUxFUkFUSU9OX1BST0ZJTEVTID0gODtcclxuY29uc3QgTlVNX1ZFTE9DSVRZX1JBTkdFUyA9IDQ7XHJcbmNvbnN0IE5VTV9USU1FX1JBTkdFUyA9IDI7XHJcblxyXG4vKiBPYnN0YWNsZSBjb3N0IG1hcDpcclxuICpcclxuICogMS4gUmFzdGVyaXplIHRyaWFuZ2xlcyBmcm9tIHBvbHlnb25hbCBvYnN0YWNsZXMgaW50byBYWS1zcGFjZSBvY2N1cGFuY3kgZ3JpZFxyXG4gKiAyLiBDb252ZXJ0IG9jY3VwYW5jeSBncmlkIHRvIFNMLXNwYWNlXHJcbiAqICAgICogV2lkdGggaXMgc3BhdGlhbCBob3Jpem9uIG9mIHRoZSBzdGF0ZSBsYXR0aWNlXHJcbiAqICAgICogSGVpZ2h0IGlzIGxhbmUgd2lkdGhcclxuICogICAgKiBSZXNvbHV0aW9uIHNob3VsZCBiZSBoaWdoZXIgdGhhbiBYWS1ncmlkXHJcbiAqICAgICogR2V0IFhZIHBvc2l0aW9uIGZyb20gY2VudGVybGluZSB0ZXh0dXJlXHJcbiAqICAgICogTG9va3VwIFhZIGluIFhZIG9jY3VwYW5jeSBncmlkIChuZWFyZXN0KVxyXG4gKiAzLiBEaWxhdGUgU0wtc3BhY2UgZ3JpZCB1c2luZyB0d28gcGFzc2VzIChhbG9uZyBzdGF0aW9uLCB0aGVuIGFsb25nIGxhdGl0dWRlKVxyXG4gKiAgICAqIGNvbGxpc2lvbiBhcmVhOiBoYWxmIGNhciBzaXplICsgMC4zbVxyXG4gKiAgICAqIGhpZ2ggY29zdCBhcmVhOiAxIG1ldGVyXHJcbiAqIDQuIENvbnZlcnQgYmFjayB0byBYWS1zcGFjZSB1c2luZyBYWVNMIG1hcFxyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhdGhQbGFubmVyIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMucHJldmlvdXNTdGFydFN0YXRpb24gPSBudWxsO1xyXG4gICAgdGhpcy5wcmV2aW91c0ZpcnN0TGF0dGljZVBvaW50ID0gLTE7XHJcbiAgICB0aGlzLnByZXZpb3VzU2Vjb25kTGF0dGljZVBvaW50ID0gLTE7XHJcbiAgICB0aGlzLnByZXZpb3VzRmlyc3RBY2NlbGVyYXRpb24gPSAtMTtcclxuICAgIHRoaXMucHJldmlvdXNTZWNvbmRMYXR0aWNlUG9pbnQgPSAtMTtcclxuXHJcbiAgICBsZXQgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgIGNvbnN0IHByb2dyYW1zID0gW1xyXG4gICAgICB4eU9ic3RhY2xlR3JpZC5zZXRVcCgpLFxyXG4gICAgICBzbE9ic3RhY2xlR3JpZC5zZXRVcCgpLFxyXG4gICAgICAuLi5zbE9ic3RhY2xlR3JpZERpbGF0aW9uLnNldFVwKCksXHJcbiAgICAgIHNsRHluYW1pY09ic3RhY2xlR3JpZC5zZXRVcCgpLFxyXG4gICAgICB4eXNsTWFwLnNldFVwKCksXHJcbiAgICAgIC4uLm9wdGltaXplQ3ViaWNQYXRocy5zZXRVcCgpLFxyXG4gICAgICBvcHRpbWl6ZVF1aW50aWNQYXRocy5zZXRVcCgpLFxyXG4gICAgICAuLi5wYXRoRnJvbVZlaGljbGVDb3N0cy5zZXRVcCgpLFxyXG4gICAgICBncmFwaFNlYXJjaC5zZXRVcCgpLFxyXG4gICAgXS5tYXAocCA9PiBPYmplY3QuYXNzaWduKHt9LCBwLCB7IHdpZHRoOiAxLCBoZWlnaHQ6IDEgfSkpO1xyXG5cclxuICAgIHRoaXMuZ3BncHUgPSBuZXcgR1BHUFUocHJvZ3JhbXMpO1xyXG4gIH1cclxuXHJcbiAgcmVzZXQoKSB7XHJcbiAgICB0aGlzLnByZXZpb3VzU3RhcnRTdGF0aW9uID0gbnVsbDtcclxuICAgIHRoaXMucHJldmlvdXNGaXJzdExhdHRpY2VQb2ludCA9IC0xO1xyXG4gICAgdGhpcy5wcmV2aW91c1NlY29uZExhdHRpY2VQb2ludCA9IC0xO1xyXG4gICAgdGhpcy5wcmV2aW91c0ZpcnN0QWNjZWxlcmF0aW9uID0gLTE7XHJcbiAgICB0aGlzLnByZXZpb3VzU2Vjb25kTGF0dGljZVBvaW50ID0gLTE7XHJcbiAgfVxyXG5cclxuICBwbGFuKHZlaGljbGVQb3NlLCB2ZWhpY2xlU3RhdGlvbiwgbGFuZVBhdGgsIHN0YXJ0VGltZSwgc3RhdGljT2JzdGFjbGVzLCBkeW5hbWljT2JzdGFjbGVzKSB7XHJcbiAgICBjb25zdCBsYXR0aWNlU3RhdGlvbkludGVydmFsID0gdGhpcy5fbGF0dGljZVN0YXRpb25JbnRlcnZhbCgpO1xyXG5cclxuICAgIGNvbnN0IGNlbnRlcmxpbmVSYXcgPSBsYW5lUGF0aC5zYW1wbGVTdGF0aW9ucyh2ZWhpY2xlU3RhdGlvbiwgTWF0aC5jZWlsKCh0aGlzLmNvbmZpZy5zcGF0aWFsSG9yaXpvbiArIGxhdHRpY2VTdGF0aW9uSW50ZXJ2YWwpIC8gdGhpcy5jb25maWcuY2VudGVybGluZVN0YXRpb25JbnRlcnZhbCkgKyAxLCB0aGlzLmNvbmZpZy5jZW50ZXJsaW5lU3RhdGlvbkludGVydmFsKTtcclxuXHJcbiAgICAvLyBUcmFuc2Zvcm0gYWxsIGNlbnRlcmxpbmUgcG9pbnRzIGludG8gdmVoaWNsZSBmcmFtZVxyXG4gICAgY29uc3QgdmVoaWNsZVhmb3JtID0gdmVoaWNsZVRyYW5zZm9ybSh2ZWhpY2xlUG9zZSk7XHJcbiAgICBjb25zdCBjZW50ZXJsaW5lID0gY2VudGVybGluZVJhdy5tYXAoYyA9PiB7IHJldHVybiB7IHBvczogYy5wb3MuY2xvbmUoKS5hcHBseU1hdHJpeDModmVoaWNsZVhmb3JtKSwgcm90OiBjLnJvdCAtIHZlaGljbGVQb3NlLnJvdCwgY3VydjogYy5jdXJ2IH0gfSk7XHJcblxyXG4gICAgY29uc3QgY2VudGVybGluZURhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGNlbnRlcmxpbmUubGVuZ3RoICogMyk7XHJcbiAgICBjb25zdCBtYXhQb2ludCA9IG5ldyBUSFJFRS5WZWN0b3IyKDAsIDApO1xyXG4gICAgY29uc3QgbWluUG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMigwLCAwKTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNlbnRlcmxpbmUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3Qgc2FtcGxlID0gY2VudGVybGluZVtpXTtcclxuICAgICAgY29uc3QgcG9zID0gc2FtcGxlLnBvcztcclxuICAgICAgY2VudGVybGluZURhdGFbaSAqIDMgKyAwXSA9IHBvcy54O1xyXG4gICAgICBjZW50ZXJsaW5lRGF0YVtpICogMyArIDFdID0gcG9zLnk7XHJcbiAgICAgIGNlbnRlcmxpbmVEYXRhW2kgKiAzICsgMl0gPSBzYW1wbGUucm90O1xyXG5cclxuICAgICAgbWF4UG9pbnQubWF4KHBvcyk7XHJcbiAgICAgIG1pblBvaW50Lm1pbihwb3MpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRpZmYgPSBtYXhQb2ludC5jbG9uZSgpLnN1YihtaW5Qb2ludCk7XHJcbiAgICBjb25zdCB4eUNlbnRlclBvaW50ID0gbWluUG9pbnQuY2xvbmUoKS5hZGQobWF4UG9pbnQpLmRpdmlkZVNjYWxhcigyKTtcclxuXHJcbiAgICAvLyBTaXplcyBvZiB0aGUgeHkgZ3JpZHMgKGluIHBpeGVscywgbm90IG1ldGVycylcclxuICAgIGNvbnN0IHh5V2lkdGggPSBNYXRoLmNlaWwoKGRpZmYueCArIHRoaXMuY29uZmlnLmdyaWRNYXJnaW4gKiAyKSAvIHRoaXMuY29uZmlnLnh5R3JpZENlbGxTaXplKTtcclxuICAgIGNvbnN0IHh5SGVpZ2h0ID0gTWF0aC5jZWlsKChkaWZmLnkgKyB0aGlzLmNvbmZpZy5ncmlkTWFyZ2luICogMikgLyB0aGlzLmNvbmZpZy54eUdyaWRDZWxsU2l6ZSk7XHJcblxyXG4gICAgY29uc3Qgc3RhdGlvbldpZHRoID0gdGhpcy5jb25maWcuc3BhdGlhbEhvcml6b24gKyBsYXR0aWNlU3RhdGlvbkludGVydmFsICogMjtcclxuICAgIGNvbnN0IHNsQ2VudGVyUG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMih0aGlzLmNvbmZpZy5zcGF0aWFsSG9yaXpvbiAvIDIsIDApO1xyXG5cclxuICAgIC8vIFNpemVzIG9mIHRoZSBzbCBncmlkcyAoaW4gcGl4ZWxzLCBub3QgbWV0ZXJzKVxyXG4gICAgY29uc3Qgc2xXaWR0aCA9IE1hdGguY2VpbChzdGF0aW9uV2lkdGggLyB0aGlzLmNvbmZpZy5zbEdyaWRDZWxsU2l6ZSk7XHJcbiAgICBjb25zdCBzbEhlaWdodCA9IE1hdGguY2VpbCgodGhpcy5jb25maWcucm9hZFdpZHRoICsgdGhpcy5jb25maWcuZ3JpZE1hcmdpbiAqIDIpIC8gdGhpcy5jb25maWcuc2xHcmlkQ2VsbFNpemUpO1xyXG5cclxuICAgIGxldCBzdGFydFN0YXRpb247XHJcblxyXG4gICAgaWYgKHRoaXMucHJldmlvdXNTdGFydFN0YXRpb24gPT09IG51bGwgfHwgdmVoaWNsZVN0YXRpb24gKyBsYXR0aWNlU3RhdGlvbkludGVydmFsIC8gMiA+IHRoaXMucHJldmlvdXNTdGFydFN0YXRpb24pIHtcclxuICAgICAgc3RhcnRTdGF0aW9uID0gKHRoaXMucHJldmlvdXNTdGFydFN0YXRpb24gPT09IG51bGwgPyB2ZWhpY2xlU3RhdGlvbiA6IHRoaXMucHJldmlvdXNTdGFydFN0YXRpb24pICsgbGF0dGljZVN0YXRpb25JbnRlcnZhbDtcclxuICAgICAgdGhpcy5wcmV2aW91c1N0YXJ0U3RhdGlvbiA9IHN0YXJ0U3RhdGlvbjtcclxuICAgICAgdGhpcy5wcmV2aW91c0ZpcnN0TGF0dGljZVBvaW50IC09IHRoaXMuY29uZmlnLmxhdHRpY2UubnVtTGF0aXR1ZGVzO1xyXG4gICAgICB0aGlzLnByZXZpb3VzU2Vjb25kTGF0dGljZVBvaW50IC09IHRoaXMuY29uZmlnLmxhdHRpY2UubnVtTGF0aXR1ZGVzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3RhcnRTdGF0aW9uID0gdGhpcy5wcmV2aW91c1N0YXJ0U3RhdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBsYXR0aWNlID0gdGhpcy5fYnVpbGRMYXR0aWNlKGxhbmVQYXRoLCBzdGFydFN0YXRpb24sIHZlaGljbGVQb3NlLnJvdCwgdmVoaWNsZVhmb3JtKTtcclxuXHJcbiAgICBjb25zdCB0ZW1wb3JhbEhvcml6b24gPSB0aGlzLmNvbmZpZy5zcGF0aWFsSG9yaXpvbiAvIHRoaXMuY29uZmlnLnNwZWVkTGltaXQ7XHJcbiAgICBjb25zdCBkeW5hbWljRnJhbWVUaW1lID0gdGVtcG9yYWxIb3Jpem9uIC8gdGhpcy5jb25maWcubnVtRHluYW1pY0ZyYW1lcztcclxuXHJcbiAgICBmb3IgKGNvbnN0IFtpLCBwXSBvZiBbXHJcbiAgICAgIHh5T2JzdGFjbGVHcmlkLnVwZGF0ZSh0aGlzLmNvbmZpZywgeHlXaWR0aCwgeHlIZWlnaHQsIHh5Q2VudGVyUG9pbnQsIHZlaGljbGVYZm9ybSwgc3RhdGljT2JzdGFjbGVzKSxcclxuICAgICAgc2xPYnN0YWNsZUdyaWQudXBkYXRlKHRoaXMuY29uZmlnLCBzbFdpZHRoLCBzbEhlaWdodCwgc2xDZW50ZXJQb2ludCwgeHlDZW50ZXJQb2ludCksXHJcbiAgICAgIC4uLnNsT2JzdGFjbGVHcmlkRGlsYXRpb24udXBkYXRlKHRoaXMuY29uZmlnLCBzbFdpZHRoLCBzbEhlaWdodCksXHJcbiAgICAgIHNsRHluYW1pY09ic3RhY2xlR3JpZC51cGRhdGUodGhpcy5jb25maWcsIHNsV2lkdGgsIHNsSGVpZ2h0LCBzbENlbnRlclBvaW50LCB2ZWhpY2xlU3RhdGlvbiwgc3RhcnRUaW1lLCBkeW5hbWljRnJhbWVUaW1lLCBkeW5hbWljT2JzdGFjbGVzKSxcclxuICAgICAgeHlzbE1hcC51cGRhdGUodGhpcy5jb25maWcsIHh5V2lkdGgsIHh5SGVpZ2h0LCB4eUNlbnRlclBvaW50KSxcclxuICAgICAgLi4ub3B0aW1pemVDdWJpY1BhdGhzLnVwZGF0ZSh0aGlzLmNvbmZpZywgdmVoaWNsZVBvc2UpLFxyXG4gICAgICBvcHRpbWl6ZVF1aW50aWNQYXRocy51cGRhdGUodGhpcy5jb25maWcsIHZlaGljbGVQb3NlKSxcclxuICAgICAgLi4ucGF0aEZyb21WZWhpY2xlQ29zdHMudXBkYXRlKHRoaXMuY29uZmlnLCB2ZWhpY2xlUG9zZSwgeHlDZW50ZXJQb2ludCwgc2xDZW50ZXJQb2ludCwgdGhpcy5wcmV2aW91c0ZpcnN0TGF0dGljZVBvaW50LCB0aGlzLnByZXZpb3VzU2Vjb25kTGF0dGljZVBvaW50LCBkeW5hbWljRnJhbWVUaW1lKSxcclxuICAgICAgZ3JhcGhTZWFyY2gudXBkYXRlKHRoaXMuY29uZmlnLCB2ZWhpY2xlUG9zZSwgeHlDZW50ZXJQb2ludCwgc2xDZW50ZXJQb2ludCwgdGhpcy5wcmV2aW91c0ZpcnN0TGF0dGljZVBvaW50LCB0aGlzLnByZXZpb3VzU2Vjb25kTGF0dGljZVBvaW50LCBkeW5hbWljRnJhbWVUaW1lKVxyXG4gICAgXS5lbnRyaWVzKCkpIHtcclxuICAgICAgdGhpcy5ncGdwdS51cGRhdGVQcm9ncmFtKGksIHApO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZ3BncHUudXBkYXRlU2hhcmVkVGV4dHVyZXMoe1xyXG4gICAgICBjZW50ZXJsaW5lOiB7XHJcbiAgICAgICAgd2lkdGg6IGNlbnRlcmxpbmUubGVuZ3RoLFxyXG4gICAgICAgIGhlaWdodDogMSxcclxuICAgICAgICBjaGFubmVsczogMyxcclxuICAgICAgICBmaWx0ZXI6ICdsaW5lYXInLFxyXG4gICAgICAgIGRhdGE6IGNlbnRlcmxpbmVEYXRhXHJcbiAgICAgIH0sXHJcbiAgICAgIGNvc3RUYWJsZToge1xyXG4gICAgICAgIHdpZHRoOiBOVU1fQUNDRUxFUkFUSU9OX1BST0ZJTEVTICogTlVNX1ZFTE9DSVRZX1JBTkdFUyAqIE5VTV9USU1FX1JBTkdFUyxcclxuICAgICAgICBoZWlnaHQ6IHRoaXMuY29uZmlnLmxhdHRpY2UubnVtTGF0aXR1ZGVzLFxyXG4gICAgICAgIGRlcHRoOiB0aGlzLmNvbmZpZy5sYXR0aWNlLm51bVN0YXRpb25zLFxyXG4gICAgICAgIGNoYW5uZWxzOiA0LFxyXG4gICAgICAgIHRleHR1cmVUeXBlOiAnMkRBcnJheSdcclxuICAgICAgfSxcclxuICAgICAgbGF0dGljZToge1xyXG4gICAgICAgIHdpZHRoOiB0aGlzLmNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcyxcclxuICAgICAgICBoZWlnaHQ6IHRoaXMuY29uZmlnLmxhdHRpY2UubnVtU3RhdGlvbnMsXHJcbiAgICAgICAgY2hhbm5lbHM6IDQsXHJcbiAgICAgICAgZGF0YTogbGF0dGljZVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmdwZ3B1Ll9ncmFwaFNlYXJjaENvc3RUYWJsZSA9IG51bGw7XHJcbiAgICB0aGlzLmdwZ3B1Ll9keW5hbWljT2JzdGFjbGVHcmlkID0gbnVsbDtcclxuXHJcbiAgICBsZXQgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgIGNvbnN0IG91dHB1dHMgPSB0aGlzLmdwZ3B1LnJ1bigpO1xyXG4gICAgY29uc3QgY29zdFRhYmxlID0gdGhpcy5ncGdwdS5fZ3JhcGhTZWFyY2hDb3N0VGFibGU7XHJcbiAgICBjb25zdCBjdWJpY1BhdGhQYXJhbXMgPSBvdXRwdXRzWzZdO1xyXG4gICAgY29uc3QgY3ViaWNQYXRoRnJvbVZlaGljbGVQYXJhbXMgPSBvdXRwdXRzWzddO1xyXG4gICAgY29uc3QgcXVpbnRpY1BhdGhGcm9tVmVoaWNsZVBhcmFtcyA9IG91dHB1dHNbOF07XHJcblxyXG4gICAgbGV0IGJlc3RFbnRyeSA9IFtOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldO1xyXG4gICAgbGV0IGJlc3RFbnRyeUluZGV4O1xyXG4gICAgY29uc3QgbnVtRW50cmllcyA9IGNvc3RUYWJsZS5sZW5ndGggLyA0O1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtRW50cmllczsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGVudHJ5VW5wYWNrZWQgPSB0aGlzLl91bnBhY2tDb3N0VGFibGVJbmRleChpKTtcclxuICAgICAgY29uc3QgZW50cnkgPSBbXHJcbiAgICAgICAgY29zdFRhYmxlW2kgKiA0XSxcclxuICAgICAgICBjb3N0VGFibGVbaSAqIDQgKyAxXSxcclxuICAgICAgICBjb3N0VGFibGVbaSAqIDQgKyAyXSxcclxuICAgICAgICBjb3N0VGFibGVbaSAqIDQgKyAzXVxyXG4gICAgICBdO1xyXG5cclxuICAgICAgaWYgKGVudHJ5WzBdIDwgMCkgY29udGludWU7XHJcblxyXG4gICAgICBlbnRyeVswXSArPSB0aGlzLl90ZXJtaW5hbENvc3QoZW50cnlVbnBhY2tlZCwgZW50cnkpO1xyXG5cclxuICAgICAgaWYgKGVudHJ5WzBdIDwgYmVzdEVudHJ5WzBdKSB7XHJcbiAgICAgICAgYmVzdEVudHJ5SW5kZXggPSBpO1xyXG4gICAgICAgIGJlc3RFbnRyeSA9IGVudHJ5O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaW52ZXJzZVZlaGljbGVYZm9ybSA9IChuZXcgVEhSRUUuTWF0cml4MygpKS5nZXRJbnZlcnNlKHZlaGljbGVYZm9ybSk7XHJcbiAgICBsZXQgYmVzdFRyYWplY3RvcnkgPSBudWxsO1xyXG4gICAgbGV0IGZyb21WZWhpY2xlU2VnbWVudCA9IG51bGw7XHJcbiAgICBsZXQgZnJvbVZlaGljbGVQYXJhbXMgPSBudWxsO1xyXG4gICAgbGV0IGZpcnN0TGF0dGljZVBvaW50ID0gLTE7XHJcbiAgICBsZXQgZmlyc3RBY2NlbGVyYXRpb24gPSAtMTtcclxuICAgIGxldCBzZWNvbmRMYXR0aWNlUG9pbnQgPSAtMTtcclxuICAgIGxldCBzZWNvbmRBY2NlbGVyYXRpb24gPSAtMTtcclxuXHJcbiAgICBpZiAoaXNGaW5pdGUoYmVzdEVudHJ5WzBdKSkge1xyXG4gICAgICBbYmVzdFRyYWplY3RvcnksIGZyb21WZWhpY2xlU2VnbWVudCwgZnJvbVZlaGljbGVQYXJhbXMsIGZpcnN0TGF0dGljZVBvaW50LCBmaXJzdEFjY2VsZXJhdGlvbiwgc2Vjb25kTGF0dGljZVBvaW50LCBzZWNvbmRBY2NlbGVyYXRpb25dID0gdGhpcy5fcmVjb25zdHJ1Y3RUcmFqZWN0b3J5KFxyXG4gICAgICAgIGJlc3RFbnRyeUluZGV4LFxyXG4gICAgICAgIGNvc3RUYWJsZSxcclxuICAgICAgICBjdWJpY1BhdGhQYXJhbXMsXHJcbiAgICAgICAgY3ViaWNQYXRoRnJvbVZlaGljbGVQYXJhbXMsXHJcbiAgICAgICAgcXVpbnRpY1BhdGhGcm9tVmVoaWNsZVBhcmFtcyxcclxuICAgICAgICB2ZWhpY2xlUG9zZSxcclxuICAgICAgICBsYXR0aWNlXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBmcm9tVmVoaWNsZVNlZ21lbnQuZm9yRWFjaChwID0+IHtcclxuICAgICAgICBwLnBvcyA9IHAucG9zLmFwcGx5TWF0cml4MyhpbnZlcnNlVmVoaWNsZVhmb3JtKTtcclxuICAgICAgICBwLnJvdCArPSB2ZWhpY2xlUG9zZS5yb3Q7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgYmVzdFRyYWplY3RvcnkuZm9yRWFjaChwID0+IHtcclxuICAgICAgICBwLnBvcyA9IHAucG9zLmFwcGx5TWF0cml4MyhpbnZlcnNlVmVoaWNsZVhmb3JtKTtcclxuICAgICAgICBwLnJvdCArPSB2ZWhpY2xlUG9zZS5yb3Q7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucHJldmlvdXNGaXJzdExhdHRpY2VQb2ludCA9IGZpcnN0TGF0dGljZVBvaW50O1xyXG4gICAgdGhpcy5wcmV2aW91c0ZpcnN0QWNjZWxlcmF0aW9uID0gZmlyc3RBY2NlbGVyYXRpb247XHJcbiAgICB0aGlzLnByZXZpb3VzU2Vjb25kTGF0dGljZVBvaW50ID0gc2Vjb25kTGF0dGljZVBvaW50O1xyXG4gICAgdGhpcy5wcmV2aW91c1NlY29uZEFjY2VsZXJhdGlvbiA9IHNlY29uZEFjY2VsZXJhdGlvbjtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBwYXRoOiBiZXN0VHJhamVjdG9yeSxcclxuICAgICAgZnJvbVZlaGljbGVTZWdtZW50OiBmcm9tVmVoaWNsZVNlZ21lbnQsXHJcbiAgICAgIGZyb21WZWhpY2xlUGFyYW1zOiBmcm9tVmVoaWNsZVBhcmFtcyxcclxuICAgICAgbGF0dGljZVN0YXJ0U3RhdGlvbjogdGhpcy5wcmV2aW91c1N0YXJ0U3RhdGlvbixcclxuICAgICAgZHluYW1pY09ic3RhY2xlR3JpZDogeyBkYXRhOiB0aGlzLmdwZ3B1Ll9keW5hbWljT2JzdGFjbGVHcmlkLCB3aWR0aDogc2xXaWR0aCwgaGVpZ2h0OiBzbEhlaWdodCB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgX2J1aWxkTGF0dGljZShsYW5lUGF0aCwgc3RhcnRTdGF0aW9uLCB2ZWhpY2xlUm90LCB2ZWhpY2xlWGZvcm0pIHtcclxuICAgIGNvbnN0IGNlbnRlcmxpbmUgPSBsYW5lUGF0aC5zYW1wbGVTdGF0aW9ucyhzdGFydFN0YXRpb24sIHRoaXMuY29uZmlnLmxhdHRpY2UubnVtU3RhdGlvbnMsIHRoaXMuX2xhdHRpY2VTdGF0aW9uSW50ZXJ2YWwoKSk7XHJcbiAgICBjb25zdCBvZmZzZXQgPSBNYXRoLmZsb29yKHRoaXMuY29uZmlnLmxhdHRpY2UubnVtTGF0aXR1ZGVzIC8gMik7XHJcbiAgICBjb25zdCBsYXR0aWNlID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmNvbmZpZy5sYXR0aWNlLm51bVN0YXRpb25zICogdGhpcy5jb25maWcubGF0dGljZS5udW1MYXRpdHVkZXMgKiA0KTtcclxuICAgIGxldCBpbmRleCA9IDA7XHJcblxyXG4gICAgZm9yIChsZXQgcyA9IDA7IHMgPCBjZW50ZXJsaW5lLmxlbmd0aDsgcysrKSB7XHJcbiAgICAgIGNvbnN0IHNhbXBsZSA9IGNlbnRlcmxpbmVbc107XHJcblxyXG4gICAgICBmb3IgKGxldCBsID0gMDsgbCA8IHRoaXMuY29uZmlnLmxhdHRpY2UubnVtTGF0aXR1ZGVzOyBsKyspIHtcclxuICAgICAgICBjb25zdCBsYXRpdHVkZSA9IChsIC0gb2Zmc2V0KSAvIG9mZnNldCAqIHRoaXMuY29uZmlnLnJvYWRXaWR0aCAvIDI7XHJcbiAgICAgICAgY29uc3Qgcm90ID0gc2FtcGxlLnJvdCAtIHZlaGljbGVSb3Q7XHJcbiAgICAgICAgY29uc3QgcG9zID0gVEhSRUUuVmVjdG9yMi5mcm9tQW5nbGUocm90ICsgTWF0aC5QSSAvIDIpLm11bHRpcGx5U2NhbGFyKGxhdGl0dWRlKS5hZGQoc2FtcGxlLnBvcy5jbG9uZSgpLmFwcGx5TWF0cml4Myh2ZWhpY2xlWGZvcm0pKTtcclxuICAgICAgICBjb25zdCBjdXJ2ID0gc2FtcGxlLmN1cnYgPT0gMCA/IDAgOiAxIC8gKDEgLyBzYW1wbGUuY3VydiAtIGxhdGl0dWRlKTtcclxuXHJcbiAgICAgICAgbGF0dGljZVtpbmRleCsrXSA9IHBvcy54O1xyXG4gICAgICAgIGxhdHRpY2VbaW5kZXgrK10gPSBwb3MueTtcclxuICAgICAgICBsYXR0aWNlW2luZGV4KytdID0gcm90O1xyXG4gICAgICAgIGxhdHRpY2VbaW5kZXgrK10gPSBjdXJ2O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGxhdHRpY2U7XHJcbiAgfVxyXG5cclxuICBfbGF0dGljZVN0YXRpb25JbnRlcnZhbCgpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbmZpZy5zcGF0aWFsSG9yaXpvbiAvIHRoaXMuY29uZmlnLmxhdHRpY2UubnVtU3RhdGlvbnM7XHJcbiAgfVxyXG5cclxuICBfdGVybWluYWxDb3N0KFtzdGF0aW9uSW5kZXgsIGxhdGl0dWRlSW5kZXgsIHRpbWVJbmRleCwgdmVsb2NpdHlJbmRleCwgYWNjZWxlcmF0aW9uSW5kZXhdLCBbY29zdCwgZmluYWxWZWxvY2l0eSwgZmluYWxUaW1lLCBpbmNvbWluZ0luZGV4XSkge1xyXG4gICAgLy8gT25seSBjb25zaWRlciB2ZXJ0aWNlcyB0aGF0IHJlYWNoIHRoZSBlbmQgb2YgdGhlIHNwYXRpYWwgb3IgdGVtcG9yYWwgaG9yaXpvblxyXG4gICAgaWYgKHN0YXRpb25JbmRleCAhPSB0aGlzLmNvbmZpZy5sYXR0aWNlLm51bVN0YXRpb25zIC0gMSAmJiBmaW5hbFZlbG9jaXR5ID4gMC4wNSlcclxuICAgICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuXHJcbiAgICBjb25zdCBzdGF0aW9uID0gKHRoaXMuY29uZmlnLnNwYXRpYWxIb3Jpem9uIC8gdGhpcy5jb25maWcubGF0dGljZS5udW1TdGF0aW9ucykgKiAoc3RhdGlvbkluZGV4ICsgMSk7XHJcblxyXG4gICAgcmV0dXJuIHN0YXRpb24gKiAtdGhpcy5jb25maWcuc3RhdGlvblJlYWNoRGlzY291bnQgKyBmaW5hbFRpbWUgKiB0aGlzLmNvbmZpZy5leHRyYVRpbWVQZW5hbHR5O1xyXG4gIH1cclxuXHJcbiAgX3VucGFja0Nvc3RUYWJsZUluZGV4KGluZGV4KSB7XHJcbiAgICBpZiAoaW5kZXggPCAwKSByZXR1cm4gWy0xLCBpbmRleCArIDIsIG51bGwsIG51bGwsIG51bGxdO1xyXG5cclxuICAgIGNvbnN0IG51bVBlclRpbWUgPSBOVU1fQUNDRUxFUkFUSU9OX1BST0ZJTEVTICogTlVNX1ZFTE9DSVRZX1JBTkdFUztcclxuICAgIGNvbnN0IG51bVBlckxhdGl0dWRlID0gbnVtUGVyVGltZSAqIE5VTV9USU1FX1JBTkdFUztcclxuICAgIGNvbnN0IG51bVBlclN0YXRpb24gPSB0aGlzLmNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcyAqIG51bVBlckxhdGl0dWRlO1xyXG5cclxuICAgIGNvbnN0IHN0YXRpb25JbmRleCA9IE1hdGguZmxvb3IoaW5kZXggLyBudW1QZXJTdGF0aW9uKTtcclxuICAgIGluZGV4IC09IHN0YXRpb25JbmRleCAqIG51bVBlclN0YXRpb247XHJcblxyXG4gICAgY29uc3QgbGF0aXR1ZGVJbmRleCA9IE1hdGguZmxvb3IoaW5kZXggLyBudW1QZXJMYXRpdHVkZSk7XHJcbiAgICBpbmRleCAtPSBsYXRpdHVkZUluZGV4ICogbnVtUGVyTGF0aXR1ZGU7XHJcblxyXG4gICAgY29uc3QgdGltZUluZGV4ID0gTWF0aC5mbG9vcihpbmRleCAvIG51bVBlclRpbWUpO1xyXG4gICAgaW5kZXggLT0gdGltZUluZGV4ICogbnVtUGVyVGltZTtcclxuXHJcbiAgICBjb25zdCB2ZWxvY2l0eUluZGV4ID0gTWF0aC5mbG9vcihpbmRleCAvIE5VTV9BQ0NFTEVSQVRJT05fUFJPRklMRVMpO1xyXG4gICAgY29uc3QgYWNjZWxlcmF0aW9uSW5kZXggPSBpbmRleCAlIE5VTV9BQ0NFTEVSQVRJT05fUFJPRklMRVM7XHJcblxyXG4gICAgcmV0dXJuIFtzdGF0aW9uSW5kZXgsIGxhdGl0dWRlSW5kZXgsIHRpbWVJbmRleCwgdmVsb2NpdHlJbmRleCwgYWNjZWxlcmF0aW9uSW5kZXhdO1xyXG4gIH1cclxuXHJcbiAgX3JlY29uc3RydWN0VHJhamVjdG9yeShpbmRleCwgY29zdFRhYmxlLCBjdWJpY1BhdGhQYXJhbXMsIGN1YmljUGF0aEZyb21WZWhpY2xlUGFyYW1zLCBxdWludGljUGF0aEZyb21WZWhpY2xlUGFyYW1zLCB2ZWhpY2xlUG9zZSwgbGF0dGljZSkge1xyXG4gICAgbGV0IHVucGFja2VkID0gdGhpcy5fdW5wYWNrQ29zdFRhYmxlSW5kZXgoaW5kZXgpO1xyXG4gICAgdW5wYWNrZWQucHVzaChjb3N0VGFibGVbaW5kZXggKiA0ICsgMV0pO1xyXG4gICAgY29uc3Qgbm9kZXMgPSBbdW5wYWNrZWRdO1xyXG5cclxuICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICB3aGlsZSAodW5wYWNrZWRbMF0gPj0gMCAmJiBjb3VudCsrIDwgMTAwKSB7XHJcbiAgICAgIGluZGV4ID0gY29zdFRhYmxlW2luZGV4ICogNCArIDNdO1xyXG4gICAgICB1bnBhY2tlZCA9IHRoaXMuX3VucGFja0Nvc3RUYWJsZUluZGV4KGluZGV4KTtcclxuXHJcbiAgICAgIGNvbnN0IGZpbmFsVmVsb2NpdHkgPSB1bnBhY2tlZFswXSA+PSAwID8gY29zdFRhYmxlW2luZGV4ICogNCArIDFdIDogdmVoaWNsZVBvc2UudmVsb2NpdHk7XHJcbiAgICAgIHVucGFja2VkLnB1c2goZmluYWxWZWxvY2l0eSk7XHJcblxyXG4gICAgICBub2Rlcy51bnNoaWZ0KHVucGFja2VkKTtcclxuICAgIH1cclxuICAgIGlmIChjb3VudCA+PSAxMDApIHRocm93IG5ldyBFcnJvcignSW5maW5pdGUgbG9vcCBlbmNvdW50ZXJlZCB3aGlsZSByZWNvbnN0cnVjdGluZyB0cmFqZWN0b3J5LicpO1xyXG5cclxuICAgIGNvbnN0IHBvaW50cyA9IFtdO1xyXG4gICAgbGV0IGZyb21WZWhpY2xlU2VnbWVudCA9IFtdO1xyXG4gICAgbGV0IGZyb21WZWhpY2xlUGFyYW1zID0gbnVsbDtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICBjb25zdCBbcHJldlN0YXRpb24sIHByZXZMYXRpdHVkZSwgX3B0LCBfcHYsIF9wYSwgcHJldlZlbG9jaXR5XSA9IG5vZGVzW2ldO1xyXG4gICAgICBjb25zdCBbc3RhdGlvbiwgbGF0aXR1ZGUsIF90LCBfdiwgX2EsIHZlbG9jaXR5XSA9IG5vZGVzW2kgKyAxXTtcclxuXHJcbiAgICAgIGxldCBsZW5ndGg7XHJcbiAgICAgIGxldCBwYXRoQnVpbGRlcjtcclxuXHJcbiAgICAgIGlmIChwcmV2U3RhdGlvbiA8IDApIHtcclxuICAgICAgICBjb25zdCBzdGFydCA9IHtcclxuICAgICAgICAgIHBvczogbmV3IFRIUkVFLlZlY3RvcjIoMCwgMCksXHJcbiAgICAgICAgICByb3Q6IDAsXHJcbiAgICAgICAgICBjdXJ2OiB2ZWhpY2xlUG9zZS5jdXJ2XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgZW5kSW5kZXggPSAoc3RhdGlvbiAqIHRoaXMuY29uZmlnLmxhdHRpY2UubnVtTGF0aXR1ZGVzICsgbGF0aXR1ZGUpICogNDtcclxuICAgICAgICBjb25zdCBlbmQgPSB7XHJcbiAgICAgICAgICBwb3M6IG5ldyBUSFJFRS5WZWN0b3IyKGxhdHRpY2VbZW5kSW5kZXhdLCBsYXR0aWNlW2VuZEluZGV4ICsgMV0pLFxyXG4gICAgICAgICAgcm90OiBsYXR0aWNlW2VuZEluZGV4ICsgMl0sXHJcbiAgICAgICAgICBjdXJ2OiBsYXR0aWNlW2VuZEluZGV4ICsgM11cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAocHJldkxhdGl0dWRlID09IDApIHsgLy8gQ3ViaWMgcGF0aCBmcm9tIHZlaGljbGUgdG8gbGF0dGljZSBub2RlXHJcbiAgICAgICAgICBsZW5ndGggPSBjdWJpY1BhdGhGcm9tVmVoaWNsZVBhcmFtc1tlbmRJbmRleCArIDJdO1xyXG5cclxuICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcclxuICAgICAgICAgICAgcDE6IGN1YmljUGF0aEZyb21WZWhpY2xlUGFyYW1zW2VuZEluZGV4XSxcclxuICAgICAgICAgICAgcDI6IGN1YmljUGF0aEZyb21WZWhpY2xlUGFyYW1zW2VuZEluZGV4ICsgMV0sXHJcbiAgICAgICAgICAgIHNHOiBsZW5ndGhcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgcGF0aEJ1aWxkZXIgPSBuZXcgQ3ViaWNQYXRoKHN0YXJ0LCBlbmQsIHBhcmFtcyk7XHJcblxyXG4gICAgICAgICAgZnJvbVZlaGljbGVQYXJhbXMgPSB7IHR5cGU6ICdjdWJpYycsIHBhcmFtczogcGFyYW1zIH07XHJcbiAgICAgICAgfSBlbHNlIHsgLy8gUXVpbnRpYyBwYXRoIGZyb20gdmVoaWNsZSB0byBsYXR0aWNlIG5vZGVcclxuICAgICAgICAgIGxlbmd0aCA9IHF1aW50aWNQYXRoRnJvbVZlaGljbGVQYXJhbXNbZW5kSW5kZXggKyAyXTtcclxuXHJcbiAgICAgICAgICBjb25zdCBwYXJhbXMgPSB7XHJcbiAgICAgICAgICAgIHAzOiBxdWludGljUGF0aEZyb21WZWhpY2xlUGFyYW1zW2VuZEluZGV4XSxcclxuICAgICAgICAgICAgcDQ6IHF1aW50aWNQYXRoRnJvbVZlaGljbGVQYXJhbXNbZW5kSW5kZXggKyAxXSxcclxuICAgICAgICAgICAgc0c6IGxlbmd0aFxyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICBwYXRoQnVpbGRlciA9IG5ldyBRdWludGljUGF0aChzdGFydCwgZW5kLCBwYXJhbXMpO1xyXG5cclxuICAgICAgICAgIGZyb21WZWhpY2xlUGFyYW1zID0geyB0eXBlOiAncXVpbnRpYycsIHBhcmFtczogcGFyYW1zIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSAocHJldlN0YXRpb24gKiB0aGlzLmNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcyArIHByZXZMYXRpdHVkZSkgKiA0O1xyXG4gICAgICAgIGNvbnN0IGVuZEluZGV4ID0gKHN0YXRpb24gKiB0aGlzLmNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcyArIGxhdGl0dWRlKSAqIDQ7XHJcblxyXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0ge1xyXG4gICAgICAgICAgcG9zOiBuZXcgVEhSRUUuVmVjdG9yMihsYXR0aWNlW3N0YXJ0SW5kZXhdLCBsYXR0aWNlW3N0YXJ0SW5kZXggKyAxXSksXHJcbiAgICAgICAgICByb3Q6IGxhdHRpY2Vbc3RhcnRJbmRleCArIDJdLFxyXG4gICAgICAgICAgY3VydjogbGF0dGljZVtzdGFydEluZGV4ICsgM11cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBlbmQgPSB7XHJcbiAgICAgICAgICBwb3M6IG5ldyBUSFJFRS5WZWN0b3IyKGxhdHRpY2VbZW5kSW5kZXhdLCBsYXR0aWNlW2VuZEluZGV4ICsgMV0pLFxyXG4gICAgICAgICAgcm90OiBsYXR0aWNlW2VuZEluZGV4ICsgMl0sXHJcbiAgICAgICAgICBjdXJ2OiBsYXR0aWNlW2VuZEluZGV4ICsgM11cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBzbEluZGV4ID0gc3RhdGlvbiAqIHRoaXMuY29uZmlnLmxhdHRpY2UubnVtTGF0aXR1ZGVzICsgbGF0aXR1ZGU7XHJcbiAgICAgICAgY29uc3QgY29ubmVjdGl2aXR5SW5kZXggPSAocHJldlN0YXRpb24gLSBzdGF0aW9uICsgdGhpcy5jb25maWcubGF0dGljZS5zdGF0aW9uQ29ubmVjdGl2aXR5KSAqIHRoaXMuY29uZmlnLmxhdHRpY2UubGF0aXR1ZGVDb25uZWN0aXZpdHkgKyBwcmV2TGF0aXR1ZGUgLSBsYXRpdHVkZSArIE1hdGguZmxvb3IodGhpcy5jb25maWcubGF0dGljZS5sYXRpdHVkZUNvbm5lY3Rpdml0eSAvIDIpO1xyXG4gICAgICAgIGNvbnN0IGN1YmljUGF0aEluZGV4ID0gKGNvbm5lY3Rpdml0eUluZGV4ICogdGhpcy5jb25maWcubGF0dGljZS5udW1TdGF0aW9ucyAqIHRoaXMuY29uZmlnLmxhdHRpY2UubnVtTGF0aXR1ZGVzICsgc2xJbmRleCkgKiA0O1xyXG5cclxuICAgICAgICBsZW5ndGggPSBjdWJpY1BhdGhQYXJhbXNbY3ViaWNQYXRoSW5kZXggKyAyXTtcclxuXHJcbiAgICAgICAgcGF0aEJ1aWxkZXIgPSBuZXcgQ3ViaWNQYXRoKHN0YXJ0LCBlbmQsIHtcclxuICAgICAgICAgIHAxOiBjdWJpY1BhdGhQYXJhbXNbY3ViaWNQYXRoSW5kZXhdLFxyXG4gICAgICAgICAgcDI6IGN1YmljUGF0aFBhcmFtc1tjdWJpY1BhdGhJbmRleCArIDFdLFxyXG4gICAgICAgICAgc0c6IGxlbmd0aFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBwYXRoID0gcGF0aEJ1aWxkZXIuYnVpbGRQYXRoKE1hdGguY2VpbChsZW5ndGggLyAwLjI1KSk7XHJcblxyXG4gICAgICBjb25zdCBwcmV2VmVsb2NpdHlTcSA9IHByZXZWZWxvY2l0eSAqIHByZXZWZWxvY2l0eTtcclxuICAgICAgY29uc3QgYWNjZWwgPSAodmVsb2NpdHkgKiB2ZWxvY2l0eSAtIHByZXZWZWxvY2l0eVNxKSAvIDIgLyBsZW5ndGg7XHJcbiAgICAgIGNvbnN0IGRzID0gbGVuZ3RoIC8gKHBhdGgubGVuZ3RoIC0gMSk7XHJcbiAgICAgIGxldCBzID0gMDtcclxuXHJcbiAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgcGF0aC5sZW5ndGg7IHArKykge1xyXG4gICAgICAgIHBhdGhbcF0udmVsb2NpdHkgPSBNYXRoLnNxcnQoMiAqIGFjY2VsICogcyArIHByZXZWZWxvY2l0eVNxKTtcclxuICAgICAgICBwYXRoW3BdLmFjY2VsZXJhdGlvbiA9IGFjY2VsO1xyXG4gICAgICAgIHMgKz0gZHM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChwcmV2U3RhdGlvbiA8IDApIHtcclxuICAgICAgICBmcm9tVmVoaWNsZVNlZ21lbnQgPSBwYXRoO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChpID4gMCkgcGF0aC5zaGlmdCgpO1xyXG4gICAgICAgIHBvaW50cy5wdXNoKC4uLnBhdGgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGZpcnN0TGF0dGljZVBvaW50ID0gbnVsbFxyXG4gICAgbGV0IGZpcnN0QWNjZWxlcmF0aW9uID0gbnVsbDtcclxuICAgIGxldCBzZWNvbmRMYXR0aWNlUG9pbnQgPSBudWxsO1xyXG4gICAgbGV0IHNlY29uZEFjY2VsZXJhdGlvbiA9IG51bGw7XHJcblxyXG4gICAgaWYgKG5vZGVzLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgIGZpcnN0TGF0dGljZVBvaW50ID0gbm9kZXNbMV1bMF0gKiB0aGlzLmNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcyArIG5vZGVzWzFdWzFdO1xyXG4gICAgICBmaXJzdEFjY2VsZXJhdGlvbiA9IG5vZGVzWzFdWzRdO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChub2Rlcy5sZW5ndGggPj0gMykge1xyXG4gICAgICBzZWNvbmRMYXR0aWNlUG9pbnQgPSBub2Rlc1syXVswXSAqIHRoaXMuY29uZmlnLmxhdHRpY2UubnVtTGF0aXR1ZGVzICsgbm9kZXNbMl1bMV07XHJcbiAgICAgIHNlY29uZEFjY2VsZXJhdGlvbiA9IG5vZGVzWzJdWzRdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBbcG9pbnRzLCBmcm9tVmVoaWNsZVNlZ21lbnQsIGZyb21WZWhpY2xlUGFyYW1zLCBmaXJzdExhdHRpY2VQb2ludCwgZmlyc3RBY2NlbGVyYXRpb24sIHNlY29uZExhdHRpY2VQb2ludCwgc2Vjb25kQWNjZWxlcmF0aW9uXTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHZlaGljbGVUcmFuc2Zvcm0oeyBwb3MsIHJvdCB9KSB7XHJcbiAgY29uc3QgdHJhbnNsYXRlID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcclxuICB0cmFuc2xhdGUuc2V0KFxyXG4gICAgMSwgMCwgLXBvcy54LFxyXG4gICAgMCwgMSwgLXBvcy55LFxyXG4gICAgMCwgMCwgMVxyXG4gICk7XHJcblxyXG4gIGNvbnN0IGNvc1JvdCA9IE1hdGguY29zKHJvdCk7XHJcbiAgY29uc3Qgc2luUm90ID0gTWF0aC5zaW4ocm90KTtcclxuXHJcbiAgY29uc3Qgcm90YXRlID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcclxuICByb3RhdGUuc2V0KFxyXG4gICAgY29zUm90LCBzaW5Sb3QsIDAsXHJcbiAgICAtc2luUm90LCBjb3NSb3QsIDAsXHJcbiAgICAwLCAwLCAxXHJcbiAgKTtcclxuXHJcbiAgcmV0dXJuIHJvdGF0ZS5tdWx0aXBseSh0cmFuc2xhdGUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvYnN0YWNsZVRyYW5zZm9ybSh2ZWhpY2xlWGZvcm0sIHh5Q2VudGVyUG9pbnQsIHdpZHRoLCBoZWlnaHQpIHtcclxuICBjb25zdCB0cmFuc2xhdGUgPSBuZXcgVEhSRUUuTWF0cml4MygpO1xyXG4gIHRyYW5zbGF0ZS5zZXQoXHJcbiAgICAxLCAwLCAteHlDZW50ZXJQb2ludC54LFxyXG4gICAgMCwgMSwgLXh5Q2VudGVyUG9pbnQueSxcclxuICAgIDAsIDAsIDFcclxuICApO1xyXG5cclxuICBjb25zdCBzY2FsZSA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XHJcbiAgc2NhbGUuc2V0KFxyXG4gICAgMiAvIHdpZHRoLCAwLCAwLFxyXG4gICAgMCwgMiAvIGhlaWdodCwgMCxcclxuICAgIDAsIDAsIDFcclxuICApO1xyXG5cclxuICByZXR1cm4gc2NhbGUubXVsdGlwbHkodHJhbnNsYXRlKS5tdWx0aXBseSh2ZWhpY2xlWGZvcm0pO1xyXG59XHJcbiIsImNvbnN0IGhhbGZMYW5lV2lkdGggPSAzLjc7XHJcblxyXG5jb25zdCBjZW50ZXJsaW5lR2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuY29uc3QgbGVmdEJvdW5kYXJ5R2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuY29uc3QgcmlnaHRCb3VuZGFyeUdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYW5lUGF0aCB7XHJcbiAgc3RhdGljIGh5ZHJhdGUob2JqKSB7XHJcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yob2JqLCBMYW5lUGF0aC5wcm90b3R5cGUpO1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLmFuY2hvcnMgPSBbXTtcclxuICAgIHRoaXMuY2VudGVybGluZXMgPSBbXTtcclxuICAgIHRoaXMuc2FtcGxlTGVuZ3RocyA9IFtdO1xyXG4gICAgdGhpcy5hcmNMZW5ndGhzID0gW107XHJcbiAgICB0aGlzLmxlZnRCb3VuZGFyaWVzID0gW107XHJcbiAgICB0aGlzLnJpZ2h0Qm91bmRhcmllcyA9IFtdO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGNlbnRlcmxpbmUoKSB7XHJcbiAgICByZXR1cm4gW10uY29uY2F0KC4uLnRoaXMuY2VudGVybGluZXMpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGxlZnRCb3VuZGFyeSgpIHtcclxuICAgIHJldHVybiBbXS5jb25jYXQoLi4udGhpcy5sZWZ0Qm91bmRhcmllcyk7XHJcbiAgfVxyXG5cclxuICBnZXQgcmlnaHRCb3VuZGFyeSgpIHtcclxuICAgIHJldHVybiBbXS5jb25jYXQoLi4udGhpcy5yaWdodEJvdW5kYXJpZXMpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGFyY0xlbmd0aCgpIHtcclxuICAgIHJldHVybiB0aGlzLmFyY0xlbmd0aHMucmVkdWNlKChzdW0sIGwpID0+IHN1bSArIGwsIDApO1xyXG4gIH1cclxuXHJcbiAgc2FtcGxlU3RhdGlvbnMoc3RhcnRTdGF0aW9uLCBudW0sIGludGVydmFsKSB7XHJcbiAgICBjb25zdCBzYW1wbGVzID0gW107XHJcbiAgICBsZXQgYW5jaG9ySW5kZXggPSAwO1xyXG4gICAgbGV0IHNhbXBsZUluZGV4ID0gMDtcclxuICAgIGxldCB0b3RhbExlbmd0aCA9IDA7XHJcbiAgICBsZXQgbmV4dFN0YXRpb24gPSBzdGFydFN0YXRpb247XHJcblxyXG4gICAgd2hpbGUgKHRvdGFsTGVuZ3RoICsgdGhpcy5hcmNMZW5ndGhzW2FuY2hvckluZGV4XSA8IG5leHRTdGF0aW9uKSB7XHJcbiAgICAgIHRvdGFsTGVuZ3RoICs9IHRoaXMuYXJjTGVuZ3Roc1thbmNob3JJbmRleF07XHJcblxyXG4gICAgICBpZiAoKythbmNob3JJbmRleCA+PSB0aGlzLmFyY0xlbmd0aHMubGVuZ3RoKVxyXG4gICAgICAgIHJldHVybiBzYW1wbGVzO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcclxuICAgICAgbGV0IGxlbmd0aCA9IHRoaXMuc2FtcGxlTGVuZ3Roc1thbmNob3JJbmRleF1bc2FtcGxlSW5kZXhdO1xyXG4gICAgICB3aGlsZSAodG90YWxMZW5ndGggKyBsZW5ndGggPCBuZXh0U3RhdGlvbikge1xyXG4gICAgICAgIHRvdGFsTGVuZ3RoICs9IGxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKCsrc2FtcGxlSW5kZXggPj0gdGhpcy5zYW1wbGVMZW5ndGhzW2FuY2hvckluZGV4XS5sZW5ndGgpIHtcclxuICAgICAgICAgIHNhbXBsZUluZGV4ID0gMDtcclxuXHJcbiAgICAgICAgICBpZiAoKythbmNob3JJbmRleCA+PSB0aGlzLnNhbXBsZUxlbmd0aHMubGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxlbmd0aCA9IHRoaXMuc2FtcGxlTGVuZ3Roc1thbmNob3JJbmRleF1bc2FtcGxlSW5kZXhdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBbcDAsIHAxLCBwMiwgcDNdID0gdGhpcy5hbmNob3JzRm9yU3BsaW5lSW5kZXgoYW5jaG9ySW5kZXgpO1xyXG4gICAgICBjb25zdCB3ZWlnaHQgPSAoc2FtcGxlSW5kZXggKyAobmV4dFN0YXRpb24gLSB0b3RhbExlbmd0aCkgLyBsZW5ndGgpIC8gdGhpcy5zYW1wbGVMZW5ndGhzW2FuY2hvckluZGV4XS5sZW5ndGg7XHJcbiAgICAgIGNvbnN0IHBvcyA9IGNhdG11bGxSb21WZWMod2VpZ2h0LCBwMCwgcDEsIHAyLCBwMyk7XHJcbiAgICAgIGNvbnN0IHRhbmdlbnQgPSB0YW5nZW50QXQod2VpZ2h0LCBwMCwgcDEsIHAyLCBwMyk7XHJcbiAgICAgIGNvbnN0IHJvdCA9IE1hdGguYXRhbjIodGFuZ2VudC55LCB0YW5nZW50LngpO1xyXG4gICAgICBjb25zdCBjdXJ2ID0gY3VydmF0dXJlQXQod2VpZ2h0LCBwMCwgcDEsIHAyLCBwMyk7XHJcblxyXG4gICAgICBzYW1wbGVzLnB1c2goeyBwb3MsIHJvdCwgY3VydiB9KTtcclxuICAgICAgbmV4dFN0YXRpb24gKz0gaW50ZXJ2YWw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHNhbXBsZXM7XHJcbiAgfVxyXG5cclxuICBzdGF0aW9uTGF0aXR1ZGVGcm9tUG9zaXRpb24ocG9zaXRpb24sIGFyb3VuZEFuY2hvckluZGV4ID0gbnVsbCkge1xyXG4gICAgY29uc3QgW2FuY2hvckluZGV4LCBzYW1wbGVJbmRleCwgc2FtcGxlU3RhdGlvbiwgcHJldlNhbXBsZVN0YXRpb25dID0gdGhpcy5fZmluZENsb3Nlc3RTYW1wbGUocG9zaXRpb24sIGFyb3VuZEFuY2hvckluZGV4KTtcclxuXHJcbiAgICBpZiAoYW5jaG9ySW5kZXggPT09IHVuZGVmaW5lZCkgcmV0dXJuIFswLCAwLCAwXTtcclxuXHJcbiAgICBsZXQgcHJldlBvaW50O1xyXG4gICAgbGV0IG5leHRQb2ludDtcclxuICAgIGxldCBwcmV2U3RhdGlvbjtcclxuICAgIGxldCBuZXh0U3RhdGlvbjtcclxuXHJcbiAgICBpZiAoYW5jaG9ySW5kZXggPT0gMCAmJiBzYW1wbGVJbmRleCA9PSAwKSB7XHJcbiAgICAgIHByZXZQb2ludCA9IHRoaXMuY2VudGVybGluZXNbYW5jaG9ySW5kZXhdW3NhbXBsZUluZGV4XTtcclxuICAgICAgbmV4dFBvaW50ID0gdGhpcy5jZW50ZXJsaW5lc1thbmNob3JJbmRleF1bc2FtcGxlSW5kZXggKyAxXTtcclxuICAgICAgcHJldlN0YXRpb24gPSAwO1xyXG4gICAgICBuZXh0U3RhdGlvbiA9IHRoaXMuc2FtcGxlTGVuZ3Roc1thbmNob3JJbmRleF1bc2FtcGxlSW5kZXhdO1xyXG4gICAgfSBlbHNlIGlmIChhbmNob3JJbmRleCA9PSB0aGlzLmNlbnRlcmxpbmVzLmxlbmd0aCAtIDEgJiYgc2FtcGxlSW5kZXggPT0gdGhpcy5jZW50ZXJsaW5lc1thbmNob3JJbmRleF0ubGVuZ3RoIC0gMSkge1xyXG4gICAgICBwcmV2UG9pbnQgPSB0aGlzLmNlbnRlcmxpbmVzW2FuY2hvckluZGV4XVtzYW1wbGVJbmRleCAtIDFdO1xyXG4gICAgICBuZXh0UG9pbnQgPSB0aGlzLmNlbnRlcmxpbmVzW2FuY2hvckluZGV4XVtzYW1wbGVJbmRleF07XHJcbiAgICAgIHByZXZTdGF0aW9uID0gcHJldlNhbXBsZVN0YXRpb247XHJcbiAgICAgIG5leHRTdGF0aW9uID0gc2FtcGxlU3RhdGlvbjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHByZXZQb2ludCA9IHNhbXBsZUluZGV4ID09IDAgPyB0aGlzLmNlbnRlcmxpbmVzW2FuY2hvckluZGV4IC0gMV1bdGhpcy5jZW50ZXJsaW5lc1thbmNob3JJbmRleCAtIDFdLmxlbmd0aCAtIDFdIDogdGhpcy5jZW50ZXJsaW5lc1thbmNob3JJbmRleF1bc2FtcGxlSW5kZXggLSAxXTtcclxuICAgICAgbmV4dFBvaW50ID0gc2FtcGxlSW5kZXggPT0gdGhpcy5jZW50ZXJsaW5lc1thbmNob3JJbmRleF0ubGVuZ3RoIC0gMSA/IHRoaXMuY2VudGVybGluZXNbYW5jaG9ySW5kZXggKyAxXVswXSA6IHRoaXMuY2VudGVybGluZXNbYW5jaG9ySW5kZXhdW3NhbXBsZUluZGV4ICsgMV07XHJcblxyXG4gICAgICBjb25zdCBwb3NzaWJsZU5leHQgPSB0aGlzLmNlbnRlcmxpbmVzW2FuY2hvckluZGV4XVtzYW1wbGVJbmRleF07XHJcbiAgICAgIGNvbnN0IHBvc3NpYmxlUHJvZ3Jlc3MgPSBwb3NpdGlvbi5jbG9uZSgpLnN1YihwcmV2UG9pbnQpLmRvdChwb3NzaWJsZU5leHQuY2xvbmUoKS5zdWIocHJldlBvaW50KSkgLyBwcmV2UG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQocG9zc2libGVOZXh0KTtcclxuXHJcbiAgICAgIGlmIChwb3NzaWJsZVByb2dyZXNzIDwgMSkge1xyXG4gICAgICAgIG5leHRQb2ludCA9IHBvc3NpYmxlTmV4dDtcclxuICAgICAgICBwcmV2U3RhdGlvbiA9IHByZXZTYW1wbGVTdGF0aW9uO1xyXG4gICAgICAgIG5leHRTdGF0aW9uID0gc2FtcGxlU3RhdGlvbjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwcmV2UG9pbnQgPSBwb3NzaWJsZU5leHQ7XHJcbiAgICAgICAgcHJldlN0YXRpb24gPSBzYW1wbGVTdGF0aW9uO1xyXG4gICAgICAgIG5leHRTdGF0aW9uID0gc2FtcGxlU3RhdGlvbiArIHRoaXMuc2FtcGxlTGVuZ3Roc1thbmNob3JJbmRleF1bc2FtcGxlSW5kZXhdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcHJvZ3Jlc3MgPSBNYXRoLmNsYW1wKHBvc2l0aW9uLmNsb25lKCkuc3ViKHByZXZQb2ludCkuZG90KG5leHRQb2ludC5jbG9uZSgpLnN1YihwcmV2UG9pbnQpKSAvIHByZXZQb2ludC5kaXN0YW5jZVRvU3F1YXJlZChuZXh0UG9pbnQpLCAwLCAxKTtcclxuICAgIGNvbnN0IHByb2plY3RlZFBvc2l0aW9uID0gbmV4dFBvaW50LmNsb25lKCkuc3ViKHByZXZQb2ludCkubXVsdGlwbHlTY2FsYXIocHJvZ3Jlc3MpLmFkZChwcmV2UG9pbnQpO1xyXG5cclxuICAgIGNvbnN0IHN0YXRpb24gPSBwcmV2U3RhdGlvbiArIChuZXh0U3RhdGlvbiAtIHByZXZTdGF0aW9uKSAqIHByb2dyZXNzO1xyXG4gICAgY29uc3QgbGF0aXR1ZGUgPSBNYXRoLnNpZ24oKG5leHRQb2ludC54IC0gcHJldlBvaW50LngpICogKHBvc2l0aW9uLnkgLSBwcmV2UG9pbnQueSkgLSAobmV4dFBvaW50LnkgLSBwcmV2UG9pbnQueSkgKiAocG9zaXRpb24ueCAtIHByZXZQb2ludC54KSkgKiBwb3NpdGlvbi5kaXN0YW5jZVRvKHByb2plY3RlZFBvc2l0aW9uKTtcclxuXHJcbiAgICByZXR1cm4gW3N0YXRpb24sIGxhdGl0dWRlLCBhbmNob3JJbmRleF07XHJcbiAgfVxyXG5cclxuICBfZmluZENsb3Nlc3RTYW1wbGUocG9zaXRpb24sIGFyb3VuZEFuY2hvckluZGV4ID0gbnVsbCkge1xyXG4gICAgbGV0IGNsb3Nlc3QgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcbiAgICBsZXQgYmVzdEFuY2hvckluZGV4O1xyXG4gICAgbGV0IGJlc3RTYW1wbGVJbmRleDtcclxuICAgIGxldCBiZXN0U3RhdGlvbjtcclxuICAgIGxldCBiZXN0UHJldlN0YXRpb247XHJcblxyXG4gICAgbGV0IGN1cnJTdGF0aW9uID0gMDtcclxuICAgIGxldCBwcmV2U3RhdGlvbiA9IDA7XHJcblxyXG4gICAgbGV0IHN0YXJ0QW5jaG9ySW5kZXggPSAwO1xyXG4gICAgbGV0IGVuZEFuY2hvckluZGV4ID0gdGhpcy5jZW50ZXJsaW5lcy5sZW5ndGggLSAxO1xyXG5cclxuICAgIGlmIChhcm91bmRBbmNob3JJbmRleCAhPT0gbnVsbCkge1xyXG4gICAgICBzdGFydEFuY2hvckluZGV4ID0gTWF0aC5tYXgoMCwgYXJvdW5kQW5jaG9ySW5kZXggLSAyKTtcclxuICAgICAgZW5kQW5jaG9ySW5kZXggPSBNYXRoLm1pbih0aGlzLmNlbnRlcmxpbmVzLmxlbmd0aCAtIDEsIGFyb3VuZEFuY2hvckluZGV4ICsgMik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHN0YXJ0QW5jaG9ySW5kZXggPiAwKSB7XHJcbiAgICAgIGZvciAobGV0IGFuY2hvckluZGV4ID0gMDsgYW5jaG9ySW5kZXggPCBzdGFydEFuY2hvckluZGV4OyBhbmNob3JJbmRleCsrKSB7XHJcbiAgICAgICAgY3VyclN0YXRpb24gKz0gdGhpcy5hcmNMZW5ndGhzW2FuY2hvckluZGV4XTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHJldlN0YXRpb24gPSBjdXJyU3RhdGlvbiAtIHRoaXMuc2FtcGxlTGVuZ3Roc1tzdGFydEFuY2hvckluZGV4IC0gMV1bdGhpcy5zYW1wbGVMZW5ndGhzW3N0YXJ0QW5jaG9ySW5kZXggLSAxXS5sZW5ndGggLSAxXTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGxldCBhbmNob3JJbmRleCA9IHN0YXJ0QW5jaG9ySW5kZXg7IGFuY2hvckluZGV4IDw9IGVuZEFuY2hvckluZGV4OyBhbmNob3JJbmRleCsrKSB7XHJcbiAgICAgIGNvbnN0IGNlbnRlcmxpbmUgPSB0aGlzLmNlbnRlcmxpbmVzW2FuY2hvckluZGV4XTtcclxuICAgICAgZm9yIChsZXQgc2FtcGxlSW5kZXggPSAwOyBzYW1wbGVJbmRleCA8IGNlbnRlcmxpbmUubGVuZ3RoOyBzYW1wbGVJbmRleCsrKSB7XHJcbiAgICAgICAgY29uc3QgZGlzdFNxID0gcG9zaXRpb24uZGlzdGFuY2VUb1NxdWFyZWQoY2VudGVybGluZVtzYW1wbGVJbmRleF0pO1xyXG4gICAgICAgIGlmIChkaXN0U3EgPCBjbG9zZXN0KSB7XHJcbiAgICAgICAgICBjbG9zZXN0ID0gZGlzdFNxO1xyXG4gICAgICAgICAgYmVzdEFuY2hvckluZGV4ID0gYW5jaG9ySW5kZXg7XHJcbiAgICAgICAgICBiZXN0U2FtcGxlSW5kZXggPSBzYW1wbGVJbmRleDtcclxuICAgICAgICAgIGJlc3RTdGF0aW9uID0gY3VyclN0YXRpb247XHJcbiAgICAgICAgICBiZXN0UHJldlN0YXRpb24gPSBwcmV2U3RhdGlvbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByZXZTdGF0aW9uID0gY3VyclN0YXRpb247XHJcbiAgICAgICAgY3VyclN0YXRpb24gKz0gdGhpcy5zYW1wbGVMZW5ndGhzW2FuY2hvckluZGV4XVtzYW1wbGVJbmRleF07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gW2Jlc3RBbmNob3JJbmRleCwgYmVzdFNhbXBsZUluZGV4LCBiZXN0U3RhdGlvbiwgYmVzdFByZXZTdGF0aW9uXTtcclxuICB9XHJcblxyXG4gIGFkZEFuY2hvcihwb3NpdGlvbiwgcmVzYW1wbGUgPSB0cnVlKSB7XHJcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuYW5jaG9ycy5wdXNoKHBvc2l0aW9uKSAtIDE7XHJcblxyXG4gICAgaWYgKHJlc2FtcGxlKSB7XHJcbiAgICAgIGZvciAobGV0IGkgPSBpbmRleCAtIDI7IGkgPCBpbmRleDsgaSsrKVxyXG4gICAgICAgIHRoaXMucmVzYW1wbGUoaSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB1cGRhdGVBbmNob3IoaW5kZXgsIHBvc2l0aW9uKSB7XHJcbiAgICB0aGlzLmFuY2hvcnNbaW5kZXhdID0gcG9zaXRpb247XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IGluZGV4IC0gMjsgaSA8PSBpbmRleCArIDE7IGkrKylcclxuICAgICAgdGhpcy5yZXNhbXBsZShpKTtcclxuICB9XHJcblxyXG4gIHJlbW92ZUFuY2hvcihpbmRleCkge1xyXG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmFuY2hvcnMubGVuZ3RoKSByZXR1cm47XHJcblxyXG4gICAgdGhpcy5hbmNob3JzLnNwbGljZShpbmRleCwgMSk7XHJcblxyXG4gICAgY29uc3Qgc2VnbWVudEluZGV4ID0gaW5kZXggPCB0aGlzLmFuY2hvcnMubGVuZ3RoID8gaW5kZXggOiBpbmRleCAtIDE7XHJcbiAgICB0aGlzLmNlbnRlcmxpbmVzLnNwbGljZShzZWdtZW50SW5kZXgsIDEpO1xyXG4gICAgdGhpcy5zYW1wbGVMZW5ndGhzLnNwbGljZShzZWdtZW50SW5kZXgsIDEpO1xyXG4gICAgdGhpcy5sZWZ0Qm91bmRhcmllcy5zcGxpY2Uoc2VnbWVudEluZGV4LCAxKTtcclxuICAgIHRoaXMucmlnaHRCb3VuZGFyaWVzLnNwbGljZShzZWdtZW50SW5kZXgsIDEpO1xyXG4gICAgdGhpcy5hcmNMZW5ndGhzLnNwbGljZShzZWdtZW50SW5kZXgsIDEpO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSBzZWdtZW50SW5kZXggLSAyOyBpIDw9IHNlZ21lbnRJbmRleDsgaSsrKVxyXG4gICAgICB0aGlzLnJlc2FtcGxlKGkpO1xyXG4gIH1cclxuXHJcbiAgcmVzYW1wbGUoaW5kZXgpIHtcclxuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aGlzLmFuY2hvcnMubGVuZ3RoIC0gMikgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IFtwMCwgcDEsIHAyLCBwM10gPSB0aGlzLmFuY2hvcnNGb3JTcGxpbmVJbmRleChpbmRleCk7XHJcbiAgICBjb25zdCBwb2ludHMgPSBbXTtcclxuICAgIGNvbnN0IGxlbmd0aHMgPSBbXTtcclxuICAgIGNvbnN0IGxlZnRCb3VuZGFyeSA9IFtdO1xyXG4gICAgY29uc3QgcmlnaHRCb3VuZGFyeSA9IFtdO1xyXG4gICAgbGV0IHByZXZQb2ludCA9IG51bGw7XHJcblxyXG4gICAgY29uc3QgcG9pbnRzUGVyU2VnbWVudCA9IE1hdGgubWF4KDEwLCBNYXRoLmNlaWwocDEuZGlzdGFuY2VUbyhwMikgLyAxKSk7XHJcbiAgICBjb25zdCBudW1Qb2ludHMgPSBpbmRleCA9PSB0aGlzLmFuY2hvcnMubGVuZ3RoIC0gMiA/IHBvaW50c1BlclNlZ21lbnQgKyAxIDogcG9pbnRzUGVyU2VnbWVudDtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBvaW50czsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHQgPSBpIC8gcG9pbnRzUGVyU2VnbWVudDtcclxuICAgICAgY29uc3QgcG9pbnQgPSBjYXRtdWxsUm9tVmVjKHQsIHAwLCBwMSwgcDIsIHAzKTtcclxuICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xyXG5cclxuICAgICAgaWYgKHByZXZQb2ludCAhPSBudWxsKVxyXG4gICAgICAgIGxlbmd0aHMucHVzaChwcmV2UG9pbnQuZGlzdGFuY2VUbyhwb2ludCkpO1xyXG4gICAgICBwcmV2UG9pbnQgPSBwb2ludDtcclxuXHJcbiAgICAgIGNvbnN0IHRhbmdlbnQgPSB0YW5nZW50QXQodCwgcDAsIHAxLCBwMiwgcDMpO1xyXG4gICAgICBjb25zdCBub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMigtdGFuZ2VudC55LCB0YW5nZW50LngpO1xyXG5cclxuICAgICAgbGVmdEJvdW5kYXJ5LnB1c2gobm9ybWFsLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoLWhhbGZMYW5lV2lkdGgpLmFkZChwb2ludCkpO1xyXG4gICAgICByaWdodEJvdW5kYXJ5LnB1c2gobm9ybWFsLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoaGFsZkxhbmVXaWR0aCkuYWRkKHBvaW50KSk7XHJcbiAgICB9XHJcblxyXG4gICAgbGVuZ3Rocy5wdXNoKHByZXZQb2ludC5kaXN0YW5jZVRvKHAyKSk7XHJcblxyXG4gICAgdGhpcy5jZW50ZXJsaW5lc1tpbmRleF0gPSBwb2ludHM7XHJcbiAgICB0aGlzLnNhbXBsZUxlbmd0aHNbaW5kZXhdID0gbGVuZ3RocztcclxuICAgIHRoaXMubGVmdEJvdW5kYXJpZXNbaW5kZXhdID0gbGVmdEJvdW5kYXJ5O1xyXG4gICAgdGhpcy5yaWdodEJvdW5kYXJpZXNbaW5kZXhdID0gcmlnaHRCb3VuZGFyeTtcclxuICAgIHRoaXMuYXJjTGVuZ3Roc1tpbmRleF0gPSBsZW5ndGhzLnJlZHVjZSgoc3VtLCBsKSA9PiBzdW0gKyBsLCAwKTtcclxuICB9XHJcblxyXG4gIHJlc2FtcGxlQWxsKCkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFuY2hvcnMubGVuZ3RoOyBpKyspXHJcbiAgICAgIHRoaXMucmVzYW1wbGUoaSk7XHJcbiAgfVxyXG5cclxuICBhbmNob3JzRm9yU3BsaW5lSW5kZXgoaW5kZXgpIHtcclxuICAgIGxldCBwO1xyXG4gICAgaWYgKGluZGV4ID09IDApXHJcbiAgICAgIHAgPSBbdGhpcy5hbmNob3JzWzBdXS5jb25jYXQodGhpcy5hbmNob3JzLnNsaWNlKDAsIDMpKTtcclxuICAgIGVsc2VcclxuICAgICAgcCA9IHRoaXMuYW5jaG9ycy5zbGljZShpbmRleCAtIDEsIGluZGV4ICsgMyk7XHJcblxyXG4gICAgaWYgKHBbM10gPT09IHVuZGVmaW5lZClcclxuICAgICAgcFszXSA9IHBbMl07XHJcblxyXG4gICAgcmV0dXJuIHA7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjYXRtdWxsUm9tKHQsIHAwLCBwMSwgcDIsIHAzKSB7XHJcbiAgY29uc3QgdjAgPSAocDIgLSBwMCkgKiAwLjU7XHJcbiAgY29uc3QgdjEgPSAocDMgLSBwMSkgKiAwLjU7XHJcbiAgY29uc3QgdDIgPSB0ICogdDtcclxuICBjb25zdCB0MyA9IHQgKiB0MjtcclxuICByZXR1cm4gKDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEpICogdDMgKyAoLTMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxKSAqIHQyICsgdjAgKiB0ICsgcDE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNhdG11bGxSb21WZWModCwgcDAsIHAxLCBwMiwgcDMpIHtcclxuICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoY2F0bXVsbFJvbSh0LCBwMC54LCBwMS54LCBwMi54LCBwMy54KSwgY2F0bXVsbFJvbSh0LCBwMC55LCBwMS55LCBwMi55LCBwMy55KSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRhbmdlbnRBdCh0LCBwMCwgcDEsIHAyLCBwMykge1xyXG4gIGNvbnN0IGRlbHRhID0gMC4wMDAxO1xyXG4gIGxldCB0MSA9IHQgLSBkZWx0YTtcclxuICBsZXQgdDIgPSB0ICsgZGVsdGE7XHJcblxyXG4gIGlmICh0MSA8IDApIHQxID0gMDtcclxuICBpZiAodDIgPiAxKSB0MiA9IDE7XHJcblxyXG4gIGNvbnN0IHByZXYgPSBjYXRtdWxsUm9tVmVjKHQxLCBwMCwgcDEsIHAyLCBwMyk7XHJcbiAgY29uc3QgbmV4dCA9IGNhdG11bGxSb21WZWModDIsIHAwLCBwMSwgcDIsIHAzKTtcclxuXHJcbiAgcmV0dXJuIG5leHQuc3ViKHByZXYpLm5vcm1hbGl6ZSgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjdXJ2YXR1cmVBdCh0MiwgcDAsIHAxLCBwMiwgcDMpIHtcclxuICBjb25zdCBkZWx0YSA9IDAuMDAwMTtcclxuXHJcbiAgLy8gSWYgd2UncmUgZXN0aW1hdGluZyBjdXJ2YXR1cmUgYXQgb25lIG9mIHRoZSBlbmRwb2ludHMgb2YgdGhlIHNwbGluZSxcclxuICAvLyBzbGlnaHRseSBzaGlmdCBpdCBpbndhcmRzIHRvIGF2b2lkIGluZmluaXRlIGN1cnZhdHVyZS5cclxuICBpZiAodDIgPT0gMCkgdDIgPSBkZWx0YTtcclxuICBpZiAodDIgPT0gMSkgdDIgPSAxIC0gZGVsdGE7XHJcblxyXG4gIGxldCB0MSA9IHQyIC0gZGVsdGE7XHJcbiAgbGV0IHQzID0gdDIgKyBkZWx0YTtcclxuXHJcbiAgaWYgKHQxIDwgMCkgdDEgPSAwO1xyXG4gIGlmICh0MyA+IDEpIHQzID0gMTtcclxuXHJcbiAgY29uc3QgcHQxID0gY2F0bXVsbFJvbVZlYyh0MSwgcDAsIHAxLCBwMiwgcDMpO1xyXG4gIGNvbnN0IHB0MiA9IGNhdG11bGxSb21WZWModDIsIHAwLCBwMSwgcDIsIHAzKTtcclxuICBjb25zdCBwdDMgPSBjYXRtdWxsUm9tVmVjKHQzLCBwMCwgcDEsIHAyLCBwMyk7XHJcblxyXG4gIHJldHVybiAoTWF0aC5hdGFuMihwdDMueSAtIHB0Mi55LCBwdDMueCAtIHB0Mi54KSAtIE1hdGguYXRhbjIocHQyLnkgLSBwdDEueSwgcHQyLnggLSBwdDEueCkpIC8gcHQyLmRpc3RhbmNlVG8ocHQxKTtcclxufVxyXG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0aWNPYnN0YWNsZSB7XHJcbiAgc3RhdGljIGh5ZHJhdGUob2JqKSB7XHJcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yob2JqLCBTdGF0aWNPYnN0YWNsZS5wcm90b3R5cGUpO1xyXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG9iai5wb3MsIFRIUkVFLlZlY3RvcjIucHJvdG90eXBlKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XHJcbiAgICByZXR1cm4gbmV3IFN0YXRpY09ic3RhY2xlKG5ldyBUSFJFRS5WZWN0b3IyKGpzb24ucFswXSwganNvbi5wWzFdKSwganNvbi5yLCBqc29uLncsIGpzb24uaCk7XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3Rvcihwb3MsIHJvdCwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgdGhpcy5wb3MgPSBwb3M7XHJcbiAgICB0aGlzLnJvdCA9IHJvdDtcclxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgIHRoaXMudXBkYXRlVmVydGljZXMoKTtcclxuICB9XHJcblxyXG4gIHRvSlNPTigpIHtcclxuICAgIGNvbnN0IHRydW5jID0gbiA9PiArbi50b0ZpeGVkKDUpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHA6IFt0cnVuYyh0aGlzLnBvcy54KSwgdHJ1bmModGhpcy5wb3MueSldLFxyXG4gICAgICByOiB0cnVuYyh0aGlzLnJvdCksXHJcbiAgICAgIHc6IHRydW5jKHRoaXMud2lkdGgpLFxyXG4gICAgICBoOiB0cnVuYyh0aGlzLmhlaWdodClcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICB1cGRhdGVWZXJ0aWNlcygpIHtcclxuICAgIHRoaXMudmVydGljZXMgPSBbXTtcclxuXHJcbiAgICBjb25zdCBjb3NSb3QgPSBNYXRoLmNvcyh0aGlzLnJvdCk7XHJcbiAgICBjb25zdCBzaW5Sb3QgPSBNYXRoLnNpbih0aGlzLnJvdCk7XHJcbiAgICBjb25zdCBoYWxmV2lkdGggPSB0aGlzLndpZHRoIC8gMjtcclxuICAgIGNvbnN0IGhhbGZIZWlnaHQgPSB0aGlzLmhlaWdodCAvIDI7XHJcblxyXG4gICAgY29uc3QgaFdjUiA9IGhhbGZXaWR0aCAqIGNvc1JvdDtcclxuICAgIGNvbnN0IGhXc1IgPSBoYWxmV2lkdGggKiBzaW5Sb3Q7XHJcbiAgICBjb25zdCBoSGNSID0gaGFsZkhlaWdodCAqIGNvc1JvdDtcclxuICAgIGNvbnN0IGhIc1IgPSBoYWxmSGVpZ2h0ICogc2luUm90O1xyXG5cclxuICAgIGNvbnN0IHYxID0gWy1oV2NSIC0gaEhzUiArIHRoaXMucG9zLngsIC1oV3NSICsgaEhjUiArIHRoaXMucG9zLnldO1xyXG4gICAgY29uc3QgdjIgPSBbLWhXY1IgKyBoSHNSICsgdGhpcy5wb3MueCwgLWhXc1IgLSBoSGNSICsgdGhpcy5wb3MueV07XHJcbiAgICBjb25zdCB2MyA9IFtoV2NSICsgaEhzUiArIHRoaXMucG9zLngsIGhXc1IgLSBoSGNSICsgdGhpcy5wb3MueV07XHJcbiAgICBjb25zdCB2NCA9IFtoV2NSIC0gaEhzUiArIHRoaXMucG9zLngsIGhXc1IgKyBoSGNSICsgdGhpcy5wb3MueV07XHJcblxyXG4gICAgdGhpcy52ZXJ0aWNlcyA9IFtcclxuICAgICAgdjFbMF0sIHYxWzFdLFxyXG4gICAgICB2MlswXSwgdjJbMV0sXHJcbiAgICAgIHYzWzBdLCB2M1sxXSxcclxuICAgICAgdjNbMF0sIHYzWzFdLFxyXG4gICAgICB2NFswXSwgdjRbMV0sXHJcbiAgICAgIHYxWzBdLCB2MVsxXVxyXG4gICAgXTtcclxuICB9XHJcbn1cclxuIiwiLy8gSGFsZiB3aWR0aCBhbmQgaGFsZiBoZWlnaHRcclxuY29uc3QgVkVISUNMRV9TSVpFID0geyB3OiAyLjUsIGg6IDEgfTtcclxuY29uc3QgQ1lDTElTVF9TSVpFID0geyB3OiAxLjIsIGg6IDAuNiB9O1xyXG5jb25zdCBQRURFU1RSSUFOX1NJWkUgPSB7IHc6IDAuNiwgaDogMC42IH07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEeW5hbWljT2JzdGFjbGUge1xyXG4gIHN0YXRpYyBoeWRyYXRlKG9iaikge1xyXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG9iaiwgRHluYW1pY09ic3RhY2xlLnByb3RvdHlwZSk7XHJcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yob2JqLnN0YXJ0UG9zLCBUSFJFRS5WZWN0b3IyLnByb3RvdHlwZSk7XHJcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yob2JqLnZlbG9jaXR5LCBUSFJFRS5WZWN0b3IyLnByb3RvdHlwZSk7XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3Rvcih0eXBlLCBzdGFydFBvcywgdmVsb2NpdHksIHBhcmFsbGVsKSB7XHJcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgdGhpcy5zdGFydFBvcyA9IHN0YXJ0UG9zO1xyXG4gICAgdGhpcy52ZWxvY2l0eSA9IHZlbG9jaXR5O1xyXG4gICAgdGhpcy5wYXJhbGxlbCA9IHBhcmFsbGVsO1xyXG5cclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ2N5Y2xpc3QnOlxyXG4gICAgICAgICAgdGhpcy5zaXplID0gT2JqZWN0LmFzc2lnbih7fSwgQ1lDTElTVF9TSVpFKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlICdwZWRlc3RyaWFuJzpcclxuICAgICAgICAgIHRoaXMuc2l6ZSA9IE9iamVjdC5hc3NpZ24oe30sIFBFREVTVFJJQU5fU0laRSk7XHJcbiAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHRoaXMuc2l6ZSA9IE9iamVjdC5hc3NpZ24oe30sIFZFSElDTEVfU0laRSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFwYXJhbGxlbClcclxuICAgICAgW3RoaXMuc2l6ZS53LCB0aGlzLnNpemUuaF0gPSBbdGhpcy5zaXplLmgsIHRoaXMuc2l6ZS53XTtcclxuICB9XHJcblxyXG4gIHBvc2l0aW9uQXRUaW1lKHRpbWUpIHtcclxuICAgIHJldHVybiB0aGlzLnZlbG9jaXR5LmNsb25lKCkubXVsdGlwbHlTY2FsYXIodGltZSkuYWRkKHRoaXMuc3RhcnRQb3MpO1xyXG4gIH1cclxuXHJcbiAgcG9zaXRpb25zSW5UaW1lUmFuZ2Uoc3RhcnRUaW1lLCBlbmRUaW1lLCBudW1GcmFtZXMpIHtcclxuICAgIGNvbnN0IGR0ID0gKGVuZFRpbWUgLSBzdGFydFRpbWUpIC8gbnVtRnJhbWVzO1xyXG4gICAgY29uc3QgcG9zaXRpb25zID0gW107XHJcbiAgICBsZXQgdGltZSA9IHN0YXJ0VGltZTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBudW1GcmFtZXM7IGkrKykge1xyXG4gICAgICBwb3NpdGlvbnMucHVzaCh0aGlzLnBvc2l0aW9uQXRUaW1lKHRpbWUpKTtcclxuICAgICAgdGltZSArPSBkdDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcG9zaXRpb25zO1xyXG4gIH1cclxuXHJcbiAgdmVydGljZXNJblRpbWVSYW5nZShzdGFydFRpbWUsIGVuZFRpbWUsIGNvbmZpZykge1xyXG4gICAgY29uc3QgcG9zaXRpb25zID0gdGhpcy5wb3NpdGlvbnNJblRpbWVSYW5nZShzdGFydFRpbWUsIGVuZFRpbWUsIGNvbmZpZy5udW1EeW5hbWljU3ViZnJhbWVzKTtcclxuICAgIGNvbnN0IHZlcnRpY2VzID0gW107XHJcblxyXG4gICAgLy8gSGF6YXJkIGRpbGF0aW9uIChkcmF3biBiZWhpbmQsIHogPSAwLjc1KVxyXG4gICAgY29uc3QgaGF6YXJkSGFsZldpZHRoID0gdGhpcy5zaXplLncgKyBjb25maWcuZHluYW1pY0hhemFyZERpbGF0aW9uUyArIGNvbmZpZy5jb2xsaXNpb25EaWxhdGlvblM7XHJcbiAgICBjb25zdCBoYXphcmRIYWxmSGVpZ2h0ID0gdGhpcy5zaXplLmggKyBjb25maWcuZHluYW1pY0hhemFyZERpbGF0aW9uTCArIGNvbmZpZy5jb2xsaXNpb25EaWxhdGlvbkw7XHJcblxyXG4gICAgcG9zaXRpb25zLmZvckVhY2gocCA9PiB7XHJcbiAgICAgIGNvbnN0IHYxID0gWy1oYXphcmRIYWxmV2lkdGggKyBwLngsIGhhemFyZEhhbGZIZWlnaHQgKyBwLnldO1xyXG4gICAgICBjb25zdCB2MiA9IFtoYXphcmRIYWxmV2lkdGggKyBwLngsIGhhemFyZEhhbGZIZWlnaHQgKyBwLnldO1xyXG4gICAgICBjb25zdCB2MyA9IFtoYXphcmRIYWxmV2lkdGggKyBwLngsIC1oYXphcmRIYWxmSGVpZ2h0ICsgcC55XTtcclxuICAgICAgY29uc3QgdjQgPSBbLWhhemFyZEhhbGZXaWR0aCArIHAueCwgLWhhemFyZEhhbGZIZWlnaHQgKyBwLnldO1xyXG5cclxuICAgICAgdmVydGljZXMucHVzaChcclxuICAgICAgICB2MVswXSwgdjFbMV0sIDAuNzUsXHJcbiAgICAgICAgdjJbMF0sIHYyWzFdLCAwLjc1LFxyXG4gICAgICAgIHYzWzBdLCB2M1sxXSwgMC43NSxcclxuICAgICAgICB2M1swXSwgdjNbMV0sIDAuNzUsXHJcbiAgICAgICAgdjRbMF0sIHY0WzFdLCAwLjc1LFxyXG4gICAgICAgIHYxWzBdLCB2MVsxXSwgMC43NVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIENvbGxpc2lvbiBkaWxhdGlvbiAoZHJhd24gaW4gZnJvbnQsIHogPSAwLjI1KVxyXG4gICAgY29uc3QgY29sbGlzaW9uSGFsZldpZHRoID0gdGhpcy5zaXplLncgKyBjb25maWcuY29sbGlzaW9uRGlsYXRpb25TO1xyXG4gICAgY29uc3QgY29sbGlzaW9uSGFsZkhlaWdodCA9IHRoaXMuc2l6ZS5oICsgY29uZmlnLmNvbGxpc2lvbkRpbGF0aW9uTDtcclxuXHJcbiAgICBwb3NpdGlvbnMuZm9yRWFjaChwID0+IHtcclxuICAgICAgY29uc3QgdjEgPSBbLWNvbGxpc2lvbkhhbGZXaWR0aCArIHAueCwgY29sbGlzaW9uSGFsZkhlaWdodCArIHAueV07XHJcbiAgICAgIGNvbnN0IHYyID0gW2NvbGxpc2lvbkhhbGZXaWR0aCArIHAueCwgY29sbGlzaW9uSGFsZkhlaWdodCArIHAueV07XHJcbiAgICAgIGNvbnN0IHYzID0gW2NvbGxpc2lvbkhhbGZXaWR0aCArIHAueCwgLWNvbGxpc2lvbkhhbGZIZWlnaHQgKyBwLnldO1xyXG4gICAgICBjb25zdCB2NCA9IFstY29sbGlzaW9uSGFsZldpZHRoICsgcC54LCAtY29sbGlzaW9uSGFsZkhlaWdodCArIHAueV07XHJcblxyXG4gICAgICB2ZXJ0aWNlcy5wdXNoKFxyXG4gICAgICAgIHYxWzBdLCB2MVsxXSwgMC4yNSxcclxuICAgICAgICB2MlswXSwgdjJbMV0sIDAuMjUsXHJcbiAgICAgICAgdjNbMF0sIHYzWzFdLCAwLjI1LFxyXG4gICAgICAgIHYzWzBdLCB2M1sxXSwgMC4yNSxcclxuICAgICAgICB2NFswXSwgdjRbMV0sIDAuMjUsXHJcbiAgICAgICAgdjFbMF0sIHYxWzFdLCAwLjI1XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gdmVydGljZXM7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBUSFJFRSBmcm9tICdzY3JpcHQtbG9hZGVyIS4uL3ZlbmRvci90aHJlZS5qcyc7XHJcbmltcG9ydCBVdGlscyBmcm9tICdzY3JpcHQtbG9hZGVyIS4uL2pzL1V0aWxzLmpzJztcclxuaW1wb3J0IFBhdGhQbGFubmVyIGZyb20gJy4uL2pzL2F1dG9ub215L3BhdGgtcGxhbm5pbmcvUGF0aFBsYW5uZXIuanMnO1xyXG5pbXBvcnQgTGFuZVBhdGggZnJvbSAnLi4vanMvYXV0b25vbXkvTGFuZVBhdGguanMnO1xyXG5pbXBvcnQgU3RhdGljT2JzdGFjbGUgZnJvbSAnLi4vanMvYXV0b25vbXkvU3RhdGljT2JzdGFjbGUuanMnO1xyXG5pbXBvcnQgRHluYW1pY09ic3RhY2xlIGZyb20gJy4uL2pzL2F1dG9ub215L0R5bmFtaWNPYnN0YWNsZS5qcyc7XHJcblxyXG5mdW5jdGlvbiBpbml0ICgpIHtcclxuICBsZXQgcGF0aFBsYW5uZXI7XHJcbiAgdHJ5IHtcclxuICAgIHBhdGhQbGFubmVyID0gbmV3IFBhdGhQbGFubmVyKCk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgY29uc29sZS5sb2coJ0Vycm9yIGluaXRpYWxpemluZyBwYXRoIHBsYW5uZXI6Jyk7XHJcbiAgICBjb25zb2xlLmxvZyhlKTtcclxuXHJcbiAgICBzZWxmLnBvc3RNZXNzYWdlKHsgZXJyb3I6IHRydWUgfSk7XHJcblxyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgc2VsZi5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xyXG4gICAgY29uc3QgeyBjb25maWcsIHZlaGljbGVQb3NlLCB2ZWhpY2xlU3RhdGlvbiwgbGFuZVBhdGgsIHN0YXJ0VGltZSwgc3RhdGljT2JzdGFjbGVzLCBkeW5hbWljT2JzdGFjbGVzLCByZXNldCB9ID0gZXZlbnQuZGF0YTtcclxuXHJcbiAgICBMYW5lUGF0aC5oeWRyYXRlKGxhbmVQYXRoKTtcclxuICAgIHN0YXRpY09ic3RhY2xlcy5mb3JFYWNoKG8gPT4gU3RhdGljT2JzdGFjbGUuaHlkcmF0ZShvKSk7XHJcbiAgICBkeW5hbWljT2JzdGFjbGVzLmZvckVhY2gobyA9PiBEeW5hbWljT2JzdGFjbGUuaHlkcmF0ZShvKSk7XHJcblxyXG4gICAgaWYgKHJlc2V0KSBwYXRoUGxhbm5lci5yZXNldCgpO1xyXG5cclxuICAgIHBhdGhQbGFubmVyLmNvbmZpZyA9IGNvbmZpZztcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IHBhdGgsIGZyb21WZWhpY2xlU2VnbWVudCwgZnJvbVZlaGljbGVQYXJhbXMsIGxhdHRpY2VTdGFydFN0YXRpb24sIGR5bmFtaWNPYnN0YWNsZUdyaWQgfSA9IHBhdGhQbGFubmVyLnBsYW4odmVoaWNsZVBvc2UsIHZlaGljbGVTdGF0aW9uLCBsYW5lUGF0aCwgc3RhcnRUaW1lLCBzdGF0aWNPYnN0YWNsZXMsIGR5bmFtaWNPYnN0YWNsZXMpO1xyXG5cclxuICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7IHBhdGgsIGZyb21WZWhpY2xlU2VnbWVudCwgZnJvbVZlaGljbGVQYXJhbXMsIHZlaGljbGVQb3NlLCB2ZWhpY2xlU3RhdGlvbiwgbGF0dGljZVN0YXJ0U3RhdGlvbiwgY29uZmlnLCBkeW5hbWljT2JzdGFjbGVHcmlkIH0pO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5sb2coJ1BhdGhQbGFubmVyV29ya2VyIGVycm9yJyk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcclxuICAgIH1cclxuICB9O1xyXG59O1xyXG5cclxuaWYgKHR5cGVvZih3aW5kb3cpID09PSAndW5kZWZpbmVkJykge1xyXG4gIGluaXQoKTtcclxufSBlbHNlIHtcclxuICB3aW5kb3cuZGFzaF9pbml0UGF0aFBsYW5uZXJXb3JrZXIgPSBpbml0O1xyXG59XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///279\n")}},__webpack_module_cache__={};function __webpack_require__(c){var t=__webpack_module_cache__[c];if(void 0!==t)return t.exports;var X=__webpack_module_cache__[c]={exports:{}};return __webpack_modules__[c](X,X.exports,__webpack_require__),X.exports}var __webpack_exports__=__webpack_require__(279)})()}void 0===typeof window&&dash_initPathPlannerWorker();